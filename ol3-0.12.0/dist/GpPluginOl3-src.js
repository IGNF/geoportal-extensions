/*!
 * @brief Geoportal Extension for OpenLayers 3
 *
 * This software is released under the licence CeCILL-B (Free BSD compatible)
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt
 * @see http://www.cecill.info/
 *
 * copyright CeCILL-B
 * copyright IGN
 * @author IGN
 * @version 0.12.0
 * @date 2017-07-27
 *
 */
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and cont  ributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/  master/LICENSE
 * @version   3.0.2
 */
/*!
 * Sortable -- minimalist JavaScript library for reorderable drag-and-drop lists
 *
 * Released under MIT LICENSE
 * 
 * Copyright 2013-2016 Lebedev Konstantin <ibnRubaXa@gmail.com>
 * http://rubaxa.github.io/Sortable/
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/*!
 * Proj4js - Javascript reprojection library. 
 * 
 * Authors:
 * 
 * - Mike Adair madairATdmsolutions.ca
 * - Richard Greenwood richATgreenwoodmap.com
 * - Didier Richard didier.richardATign.fr
 * - Stephen Irons stephen.ironsATclear.net.nz
 * - Olivier Terral oterralATgmail.com
 * - Calvin Metcalf cmetcalfATappgeo.com
 * 
 * Copyright (c) 2014, Mike Adair, Richard Greenwood, Didier Richard, Stephen Irons, Olivier Terral and Calvin Metcalf
 * 
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 * 
 *  _THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 *  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE._
 * 
 */
;(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['ol'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('ol'));
  } else {
    root.Gp = factory(root.ol);
  }
}(this, function(ol) {

var request, xmldom;
var gp, CommonUtilsAutoLoadConfig, CommonUtilsLayerUtils, proj4, CommonUtilsRegister, CommonUtilsProxyUtils, Ol3GfiUtils, Ol3Utils, Ol3FormatsKML, Ol3SourcesWMTS, Ol3CRSCRS, CommonUtilsConfig, Ol3LayersSourceWMTS, Ol3LayersSourceWMS, Ol3LayersLayerWMTS, Ol3LayersLayerWMS, CommonUtilsSelectorID, sortable, CommonControlsLayerSwitcherDOM, Ol3ControlsLayerSwitcher, CommonControlsGetFeatureInfoDOM, Ol3ControlsGetFeatureInfo, Ol3ControlsUtilsMarkers, CommonUtilsCheckRightManagement, CommonControlsSearchEngineDOM, CommonControlsSearchEngineUtils, Ol3ControlsSearchEngine, CommonUtilsMathUtils, CommonControlsMousePositionDOM, Ol3ControlsMousePosition, Ol3ControlsUtilsInteractions, CommonControlsDrawingDOM, Ol3ControlsDrawing, CommonControlsLocationSelectorDOM, Ol3ControlsLocationSelector, CommonControlsRouteDOM, Ol3ControlsRoute, CommonControlsIsoDOM, Ol3ControlsIsocurve, CommonControlsReverseGeocodingDOM, Ol3ControlsReverseGeocode, CommonControlsLayerImportDOM, Ol3ControlsLayerImport, Ol3ControlsGeoportalAttribution, Ol3ControlsMeasuresMeasures, CommonControlsMeasureToolBoxDOM, Ol3ControlsMeasureToolBox, CommonControlsElevationPathDOM, Ol3ControlsElevationPath, CommonControlsMeasureLengthDOM, Ol3ControlsMeasuresMeasureLength, CommonControlsMeasureAreaDOM, Ol3ControlsMeasuresMeasureArea, CommonControlsMeasureAzimuthDOM, Ol3ControlsMeasuresMeasureAzimuth, Ol3GpPluginOl3;
(function (root, factory) {
    if (true) {
        gp = function (require, require) {
            return typeof factory === 'function' ? factory(require, require) : factory;
        }({}, {});
    } else if (typeof exports === 'object') {
        module.exports = factory(request, xmldom);
    } else {
        root.Gp = factory(root.request, root.xmldom);
    }
}(this, function (request, xmldom) {
    var log4js, loggerCfg, UtilsLoggerByDefault, UtilsHelper, es6Promise, ProtocolsXHR, UtilsMessagesResources, ExceptionsErrorService, ProtocolsJSONP, ProtocolsProtocol, ServicesDefaultUrlService, ServicesCommonService, ServicesAltiRequestModelAltiRequest, ServicesAltiRequestModelAltiElevationRequest, ServicesAltiRequestModelAltiProfilRequest, ServicesAltiRequestAltiRequestREST, FormatsWPS, ServicesAltiRequestAltiRequestWPS, ServicesAltiRequestAltiRequestFactory, FormatsXML, ServicesAltiResponseModelAltiResponse, ServicesAltiResponseModelElevation, ServicesAltiFormatsAltiResponseReader, ServicesAltiResponseAltiResponseFactory, ServicesAltiAlti, ServicesAutoConfResponseModelAutoConfResponse, ServicesAutoConfResponseModelConstraint, ServicesAutoConfResponseModelFormat, ServicesAutoConfResponseModelLayer, ServicesAutoConfResponseModelLegend, ServicesAutoConfResponseModelMetadata, ServicesAutoConfResponseModelOriginator, ServicesAutoConfResponseModelService, ServicesAutoConfResponseModelStyle, ServicesAutoConfResponseModelTerritory, ServicesAutoConfResponseModelThematic, ServicesAutoConfResponseModelTileMatrixSet, ServicesAutoConfResponseModelTileMatrix, ServicesAutoConfResponseModelTileMatrixLimit, ServicesAutoConfFormatsAutoConfResponseReader, ServicesAutoConfResponseAutoConfResponseFactory, ServicesAutoConfAutoConf, FormatsXLSRequestHeader, FormatsXLSRequest, FormatsXLSAbstractService, FormatsXLS, FormatsXLSLocationUtilityServiceModelAddress, FormatsXLSLocationUtilityServiceGeocodeFilterExtension, FormatsXLSLocationUtilityServiceGeocodeRequest, FormatsXLSLocationUtilityServiceModelPosition, FormatsXLSLocationUtilityServiceModelPreference, FormatsXLSLocationUtilityServiceReverseGeocodeRequest, FormatsXLSLocationUtilityService, ServicesGeocodeRequestGeocodeLocation, ServicesGeocodeRequestModelStreetAddress, ServicesGeocodeRequestModelPositionOfInterest, ServicesGeocodeRequestModelCadastralParcel, ServicesGeocodeRequestModelAdministratif, ServicesGeocodeRequestDirectGeocodeRequestFactory, ServicesGeocodeResponseModelGeocodeResponse, ServicesGeocodeResponseModelGeocodedLocation, ServicesGeocodeResponseModelDirectGeocodedLocation, ServicesGeocodeFormatsDirectGeocodeResponseReader, ServicesGeocodeResponseDirectGeocodeResponseFactory, ServicesGeocodeGeocode, ServicesGeocodeRequestReverseGeocodeRequestFactory, ServicesGeocodeResponseModelReverseGeocodedLocation, ServicesGeocodeFormatsReverseGeocodeResponseReader, ServicesGeocodeResponseReverseGeocodeResponseFactory, ServicesGeocodeReverseGeocode, ServicesAutoCompleteResponseModelAutoCompleteResponse, ServicesAutoCompleteResponseModelSuggestedLocation, ServicesAutoCompleteResponseAutoCompleteResponseFactory, ServicesAutoCompleteAutoComplete, FormatsXLSRouteServiceModelRoutePlan, FormatsXLSRouteServiceDetermineRouteRequest, FormatsXLSRouteServiceRouteRequestExtension, FormatsXLSRouteService, ServicesRouteRequestRouteRequestOLS, ServicesRouteRequestModelRouteParamREST, ServicesRouteRequestRouteRequestREST, ServicesRouteRequestRouteRequestFactory, FormatsWKT, ServicesRouteResponseModelRouteResponse, ServicesRouteResponseModelRouteInstruction, ServicesRouteFormatsRouteResponseRESTReader, ServicesRouteFormatsRouteResponseOLSReader, ServicesRouteResponseRouteResponseFactory, ServicesRouteRoute, ServicesProcessIsoCurveRequestModelProcessIsoCurveParam, ServicesProcessIsoCurveRequestProcessIsoCurveRequest, ServicesProcessIsoCurveResponseModelProcessIsoCurveResponse, ServicesProcessIsoCurveFormatsProcessIsoCurveResponseReader, ServicesProcessIsoCurveResponseProcessIsoCurveResponseFactory, ServicesProcessIsoCurveProcessIsoCurve, ServicesServices, Gp;
    log4js = undefined;
    loggerCfg = {
        loggers: [{
                root: true,
                level: 'all',
                appenders: [{
                        type: 'Console',
                        layout: {
                            type: 'PatternLayout',
                            pattern: '%d{yyyy-MM-dd HH:mm:ss} [%p] %c - %m%n'
                        }
                    }]
            }]
    };
    UtilsLoggerByDefault = function (Log4js, Config) {
        var LoggerByDefault = {
            getLogger: function (name) {
                Log4js.load(Config, function (error) {
                    if (error) {
                        throw error;
                    }
                });
                var logname = name || 'default';
                return Log4js.getLogger(logname);
            }
        };
        return LoggerByDefault;
    }(log4js, loggerCfg);
    UtilsHelper = function () {
        var Helper = {
            normalyzeParameters: function (params) {
                var myParams = null;
                if (params) {
                    var tabParams = [];
                    for (var key in params) {
                        if (params.hasOwnProperty(key)) {
                            var value = params[key];
                            if (!value) {
                                value = '';
                            }
                            tabParams.push(key + '=' + value);
                        }
                    }
                    myParams = tabParams.join('&');
                }
                return myParams;
            },
            normalyzeUrl: function (url, params, encode) {
                var myUrl = url;
                if (url) {
                    var k = url.indexOf('?');
                    if (k === -1) {
                        myUrl += '?';
                    }
                    if (k !== -1 && k !== url.length - 1) {
                        myUrl += '&';
                    }
                }
                if (params) {
                    if (typeof params === 'string') {
                        myUrl += params;
                    } else {
                        myUrl += this.normalyzeParameters(params);
                    }
                }
                if (encode) {
                    myUrl = encodeURIComponent(myUrl);
                }
                return myUrl;
            },
            indent: function (n, msg) {
                var num = n || 0;
                return new Array(num + 1).join('\t') + msg;
            }
        };
        return Helper;
    }();
    (function (global, factory) {
        if (true) {
            es6Promise = function () {
                return typeof factory === 'function' ? factory() : factory;
            }();
        } else if (typeof exports === 'object') {
            module.exports = factory();
        } else {
            global.ES6Promise = factory();
        }
    }(this, function () {
        'use strict';
        function objectOrFunction(x) {
            return typeof x === 'function' || typeof x === 'object' && x !== null;
        }
        function isFunction(x) {
            return typeof x === 'function';
        }
        var _isArray = undefined;
        if (!Array.isArray) {
            _isArray = function (x) {
                return Object.prototype.toString.call(x) === '[object Array]';
            };
        } else {
            _isArray = Array.isArray;
        }
        var isArray = _isArray;
        var len = 0;
        var vertxNext = undefined;
        var customSchedulerFn = undefined;
        var asap = function asap(callback, arg) {
            queue[len] = callback;
            queue[len + 1] = arg;
            len += 2;
            if (len === 2) {
                if (customSchedulerFn) {
                    customSchedulerFn(flush);
                } else {
                    scheduleFlush();
                }
            }
        };
        function setScheduler(scheduleFn) {
            customSchedulerFn = scheduleFn;
        }
        function setAsap(asapFn) {
            asap = asapFn;
        }
        var browserWindow = typeof window !== 'undefined' ? window : undefined;
        var browserGlobal = browserWindow || {};
        var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
        var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
        function useNextTick() {
            return function () {
                return process.nextTick(flush);
            };
        }
        function useVertxTimer() {
            if (typeof vertxNext !== 'undefined') {
                return function () {
                    vertxNext(flush);
                };
            }
            return useSetTimeout();
        }
        function useMutationObserver() {
            var iterations = 0;
            var observer = new BrowserMutationObserver(flush);
            var node = document.createTextNode('');
            observer.observe(node, { characterData: true });
            return function () {
                node.data = iterations = ++iterations % 2;
            };
        }
        function useMessageChannel() {
            var channel = new MessageChannel();
            channel.port1.onmessage = flush;
            return function () {
                return channel.port2.postMessage(0);
            };
        }
        function useSetTimeout() {
            var globalSetTimeout = setTimeout;
            return function () {
                return globalSetTimeout(flush, 1);
            };
        }
        var queue = new Array(1000);
        function flush() {
            for (var i = 0; i < len; i += 2) {
                var callback = queue[i];
                var arg = queue[i + 1];
                callback(arg);
                queue[i] = undefined;
                queue[i + 1] = undefined;
            }
            len = 0;
        }
        function attemptVertx() {
            try {
                var r = require;
                var vertx = r('vertx');
                vertxNext = vertx.runOnLoop || vertx.runOnContext;
                return useVertxTimer();
            } catch (e) {
                return useSetTimeout();
            }
        }
        var scheduleFlush = undefined;
        if (isNode) {
            scheduleFlush = useNextTick();
        } else if (BrowserMutationObserver) {
            scheduleFlush = useMutationObserver();
        } else if (isWorker) {
            scheduleFlush = useMessageChannel();
        } else if (browserWindow === undefined && typeof require === 'function') {
            scheduleFlush = attemptVertx();
        } else {
            scheduleFlush = useSetTimeout();
        }
        function then(onFulfillment, onRejection) {
            var _arguments = arguments;
            var parent = this;
            var child = new this.constructor(noop);
            if (child[PROMISE_ID] === undefined) {
                makePromise(child);
            }
            var _state = parent._state;
            if (_state) {
                (function () {
                    var callback = _arguments[_state - 1];
                    asap(function () {
                        return invokeCallback(_state, child, callback, parent._result);
                    });
                }());
            } else {
                subscribe(parent, child, onFulfillment, onRejection);
            }
            return child;
        }
        function resolve(object) {
            var Constructor = this;
            if (object && typeof object === 'object' && object.constructor === Constructor) {
                return object;
            }
            var promise = new Constructor(noop);
            _resolve(promise, object);
            return promise;
        }
        var PROMISE_ID = Math.random().toString(36).substring(16);
        function noop() {
        }
        var PENDING = void 0;
        var FULFILLED = 1;
        var REJECTED = 2;
        var GET_THEN_ERROR = new ErrorObject();
        function selfFulfillment() {
            return new TypeError('You cannot resolve a promise with itself');
        }
        function cannotReturnOwn() {
            return new TypeError('A promises callback cannot return that same promise.');
        }
        function getThen(promise) {
            try {
                return promise.then;
            } catch (error) {
                GET_THEN_ERROR.error = error;
                return GET_THEN_ERROR;
            }
        }
        function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
            try {
                then.call(value, fulfillmentHandler, rejectionHandler);
            } catch (e) {
                return e;
            }
        }
        function handleForeignThenable(promise, thenable, then) {
            asap(function (promise) {
                var sealed = false;
                var error = tryThen(then, thenable, function (value) {
                    if (sealed) {
                        return;
                    }
                    sealed = true;
                    if (thenable !== value) {
                        _resolve(promise, value);
                    } else {
                        fulfill(promise, value);
                    }
                }, function (reason) {
                    if (sealed) {
                        return;
                    }
                    sealed = true;
                    _reject(promise, reason);
                }, 'Settle: ' + (promise._label || ' unknown promise'));
                if (!sealed && error) {
                    sealed = true;
                    _reject(promise, error);
                }
            }, promise);
        }
        function handleOwnThenable(promise, thenable) {
            if (thenable._state === FULFILLED) {
                fulfill(promise, thenable._result);
            } else if (thenable._state === REJECTED) {
                _reject(promise, thenable._result);
            } else {
                subscribe(thenable, undefined, function (value) {
                    return _resolve(promise, value);
                }, function (reason) {
                    return _reject(promise, reason);
                });
            }
        }
        function handleMaybeThenable(promise, maybeThenable, then$$) {
            if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
                handleOwnThenable(promise, maybeThenable);
            } else {
                if (then$$ === GET_THEN_ERROR) {
                    _reject(promise, GET_THEN_ERROR.error);
                    GET_THEN_ERROR.error = null;
                } else if (then$$ === undefined) {
                    fulfill(promise, maybeThenable);
                } else if (isFunction(then$$)) {
                    handleForeignThenable(promise, maybeThenable, then$$);
                } else {
                    fulfill(promise, maybeThenable);
                }
            }
        }
        function _resolve(promise, value) {
            if (promise === value) {
                _reject(promise, selfFulfillment());
            } else if (objectOrFunction(value)) {
                handleMaybeThenable(promise, value, getThen(value));
            } else {
                fulfill(promise, value);
            }
        }
        function publishRejection(promise) {
            if (promise._onerror) {
                promise._onerror(promise._result);
            }
            publish(promise);
        }
        function fulfill(promise, value) {
            if (promise._state !== PENDING) {
                return;
            }
            promise._result = value;
            promise._state = FULFILLED;
            if (promise._subscribers.length !== 0) {
                asap(publish, promise);
            }
        }
        function _reject(promise, reason) {
            if (promise._state !== PENDING) {
                return;
            }
            promise._state = REJECTED;
            promise._result = reason;
            asap(publishRejection, promise);
        }
        function subscribe(parent, child, onFulfillment, onRejection) {
            var _subscribers = parent._subscribers;
            var length = _subscribers.length;
            parent._onerror = null;
            _subscribers[length] = child;
            _subscribers[length + FULFILLED] = onFulfillment;
            _subscribers[length + REJECTED] = onRejection;
            if (length === 0 && parent._state) {
                asap(publish, parent);
            }
        }
        function publish(promise) {
            var subscribers = promise._subscribers;
            var settled = promise._state;
            if (subscribers.length === 0) {
                return;
            }
            var child = undefined, callback = undefined, detail = promise._result;
            for (var i = 0; i < subscribers.length; i += 3) {
                child = subscribers[i];
                callback = subscribers[i + settled];
                if (child) {
                    invokeCallback(settled, child, callback, detail);
                } else {
                    callback(detail);
                }
            }
            promise._subscribers.length = 0;
        }
        function ErrorObject() {
            this.error = null;
        }
        var TRY_CATCH_ERROR = new ErrorObject();
        function tryCatch(callback, detail) {
            try {
                return callback(detail);
            } catch (e) {
                TRY_CATCH_ERROR.error = e;
                return TRY_CATCH_ERROR;
            }
        }
        function invokeCallback(settled, promise, callback, detail) {
            var hasCallback = isFunction(callback), value = undefined, error = undefined, succeeded = undefined, failed = undefined;
            if (hasCallback) {
                value = tryCatch(callback, detail);
                if (value === TRY_CATCH_ERROR) {
                    failed = true;
                    error = value.error;
                    value.error = null;
                } else {
                    succeeded = true;
                }
                if (promise === value) {
                    _reject(promise, cannotReturnOwn());
                    return;
                }
            } else {
                value = detail;
                succeeded = true;
            }
            if (promise._state !== PENDING) {
            } else if (hasCallback && succeeded) {
                _resolve(promise, value);
            } else if (failed) {
                _reject(promise, error);
            } else if (settled === FULFILLED) {
                fulfill(promise, value);
            } else if (settled === REJECTED) {
                _reject(promise, value);
            }
        }
        function initializePromise(promise, resolver) {
            try {
                resolver(function resolvePromise(value) {
                    _resolve(promise, value);
                }, function rejectPromise(reason) {
                    _reject(promise, reason);
                });
            } catch (e) {
                _reject(promise, e);
            }
        }
        var id = 0;
        function nextId() {
            return id++;
        }
        function makePromise(promise) {
            promise[PROMISE_ID] = id++;
            promise._state = undefined;
            promise._result = undefined;
            promise._subscribers = [];
        }
        function Enumerator(Constructor, input) {
            this._instanceConstructor = Constructor;
            this.promise = new Constructor(noop);
            if (!this.promise[PROMISE_ID]) {
                makePromise(this.promise);
            }
            if (isArray(input)) {
                this._input = input;
                this.length = input.length;
                this._remaining = input.length;
                this._result = new Array(this.length);
                if (this.length === 0) {
                    fulfill(this.promise, this._result);
                } else {
                    this.length = this.length || 0;
                    this._enumerate();
                    if (this._remaining === 0) {
                        fulfill(this.promise, this._result);
                    }
                }
            } else {
                _reject(this.promise, validationError());
            }
        }
        function validationError() {
            return new Error('Array Methods must be provided an Array');
        }
        Enumerator.prototype._enumerate = function () {
            var length = this.length;
            var _input = this._input;
            for (var i = 0; this._state === PENDING && i < length; i++) {
                this._eachEntry(_input[i], i);
            }
        };
        Enumerator.prototype._eachEntry = function (entry, i) {
            var c = this._instanceConstructor;
            var resolve$$ = c.resolve;
            if (resolve$$ === resolve) {
                var _then = getThen(entry);
                if (_then === then && entry._state !== PENDING) {
                    this._settledAt(entry._state, i, entry._result);
                } else if (typeof _then !== 'function') {
                    this._remaining--;
                    this._result[i] = entry;
                } else if (c === Promise) {
                    var promise = new c(noop);
                    handleMaybeThenable(promise, entry, _then);
                    this._willSettleAt(promise, i);
                } else {
                    this._willSettleAt(new c(function (resolve$$) {
                        return resolve$$(entry);
                    }), i);
                }
            } else {
                this._willSettleAt(resolve$$(entry), i);
            }
        };
        Enumerator.prototype._settledAt = function (state, i, value) {
            var promise = this.promise;
            if (promise._state === PENDING) {
                this._remaining--;
                if (state === REJECTED) {
                    _reject(promise, value);
                } else {
                    this._result[i] = value;
                }
            }
            if (this._remaining === 0) {
                fulfill(promise, this._result);
            }
        };
        Enumerator.prototype._willSettleAt = function (promise, i) {
            var enumerator = this;
            subscribe(promise, undefined, function (value) {
                return enumerator._settledAt(FULFILLED, i, value);
            }, function (reason) {
                return enumerator._settledAt(REJECTED, i, reason);
            });
        };
        function all(entries) {
            return new Enumerator(this, entries).promise;
        }
        function race(entries) {
            var Constructor = this;
            if (!isArray(entries)) {
                return new Constructor(function (_, reject) {
                    return reject(new TypeError('You must pass an array to race.'));
                });
            } else {
                return new Constructor(function (resolve, reject) {
                    var length = entries.length;
                    for (var i = 0; i < length; i++) {
                        Constructor.resolve(entries[i]).then(resolve, reject);
                    }
                });
            }
        }
        function reject(reason) {
            var Constructor = this;
            var promise = new Constructor(noop);
            _reject(promise, reason);
            return promise;
        }
        function needsResolver() {
            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
        }
        function needsNew() {
            throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
        }
        function Promise(resolver) {
            this[PROMISE_ID] = nextId();
            this._result = this._state = undefined;
            this._subscribers = [];
            if (noop !== resolver) {
                typeof resolver !== 'function' && needsResolver();
                this instanceof Promise ? initializePromise(this, resolver) : needsNew();
            }
        }
        Promise.all = all;
        Promise.race = race;
        Promise.resolve = resolve;
        Promise.reject = reject;
        Promise._setScheduler = setScheduler;
        Promise._setAsap = setAsap;
        Promise._asap = asap;
        Promise.prototype = {
            constructor: Promise,
            then: then,
            'catch': function _catch(onRejection) {
                return this.then(null, onRejection);
            }
        };
        function polyfill() {
            var local = undefined;
            if (typeof global !== 'undefined') {
                local = global;
            } else if (typeof self !== 'undefined') {
                local = self;
            } else {
                try {
                    local = Function('return this')();
                } catch (e) {
                    throw new Error('polyfill failed because global object is unavailable in this environment');
                }
            }
            var P = local.Promise;
            if (P) {
                var promiseToString = null;
                try {
                    promiseToString = Object.prototype.toString.call(P.resolve());
                } catch (e) {
                }
                if (promiseToString === '[object Promise]' && !P.cast) {
                    return;
                }
            }
            local.Promise = Promise;
        }
        Promise.polyfill = polyfill;
        Promise.Promise = Promise;
        return Promise;
    }));
    ProtocolsXHR = function (Logger, Helper, ES6Promise, require) {
        var XHR = {
            call: function (settings) {
                ES6Promise.polyfill();
                if (!settings.url) {
                    throw new Error('missing parameter : url is not defined !');
                }
                if (!settings.method) {
                    throw new Error('missing parameter : method is not defined !');
                }
                if (!settings.format) {
                    settings.format = 'text';
                }
                var options = {};
                options.url = settings.url;
                options.data = settings.data ? settings.data : null;
                options.method = settings.method;
                options.timeOut = settings.timeOut || 0;
                options.scope = settings.scope || this;
                options.proxy = settings.proxy || null;
                options.content = settings.content || null;
                options.headers = settings.headers || { referer: 'http://localhost' };
                switch (settings.method) {
                case 'DELETE':
                case 'GET':
                    break;
                case 'PUT':
                case 'POST':
                    options.content = settings.content ? settings.content : 'application/x-www-form-urlencoded';
                    options.headers = settings.headers ? settings.headers : { referer: 'http://localhost' };
                    break;
                case 'HEAD':
                case 'OPTIONS':
                    throw new Error('HTTP method not yet supported !');
                default:
                    throw new Error('HTTP method unknown !');
                }
                switch (settings.format) {
                case 'text':
                    this.__call(options).then(function (response) {
                        settings.onResponse.call(this, response);
                    }).catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                    break;
                case 'json':
                    this.__callJSON(options).then(function (response) {
                        settings.onResponse.call(this, response);
                    }).catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                    break;
                case 'xml':
                    this.__callXML(options).then(function (response) {
                        settings.onResponse.call(this, response);
                    }).catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                    break;
                default:
                    throw new Error('This output Format is not yet supported !');
                }
            },
            __call: function (options) {
                var promise = new Promise(function (resolve, reject) {
                    var corps = options.method === 'POST' || options.method === 'PUT' ? true : false;
                    if (options.data && (typeof options.data === 'object' && Object.keys(options.data).length || typeof options.data === 'string' && options.data.length) && !corps) {
                        options.url = Helper.normalyzeUrl(options.url, options.data);
                    }
                    var hXHR = null;
                    if (typeof window === 'undefined') {
                        var req = request;
                        if (options.data && typeof options.data === 'string' && corps) {
                            options.body = options.data;
                        }
                        req(options, function (error, response, body) {
                            if (!error && response.statusCode == 200 && body) {
                                resolve(body);
                            } else {
                                reject('Errors Occured on Http Request (nodejs) : ' + body);
                            }
                        });
                    } else {
                        if (window.XMLHttpRequest) {
                            hXHR = new XMLHttpRequest();
                            hXHR.open(options.method, options.url, true);
                            hXHR.overrideMimeType = options.content;
                            var onTimeOutTrigger = null;
                            if (options.timeOut > 0) {
                                onTimeOutTrigger = window.setTimeout(function () {
                                    var message = 'TimeOut Occured on Http Request with XMLHttpRequest !';
                                    reject({
                                        message: message,
                                        status: -1
                                    });
                                }, options.timeOut);
                            }
                            if (corps) {
                                hXHR.setRequestHeader('Content-type', options.content);
                            }
                            hXHR.onerror = function (e) {
                                console.log(e);
                                reject(new Error('Errors Occured on Http Request with XMLHttpRequest !'));
                            };
                            hXHR.ontimeout = function () {
                                reject(new Error('TimeOut Occured on Http Request with XMLHttpRequest !'));
                            };
                            hXHR.onreadystatechange = function () {
                                if (hXHR.readyState == 4) {
                                    if (hXHR.status == 200) {
                                        window.clearTimeout(onTimeOutTrigger);
                                        resolve(hXHR.response);
                                    } else {
                                        var message = 'Errors Occured on Http Request (status : \'' + hXHR.status + '\' | response : \'' + hXHR.response + '\')';
                                        var status = hXHR.status;
                                        reject({
                                            message: message,
                                            status: status
                                        });
                                    }
                                }
                            };
                            var data4xhr = options.data && corps ? options.data : null;
                            hXHR.send(data4xhr);
                        } else if (window.XDomainRequest) {
                            hXHR = new XDomainRequest();
                            hXHR.open(options.method, options.url);
                            hXHR.overrideMimeType = options.content;
                            if (options.timeOut > 0) {
                                hXHR.timeout = options.timeout;
                            }
                            if (corps) {
                                hXHR.setRequestHeader('Content-type', options.content);
                            }
                            hXHR.onerror = function () {
                                reject(new Error('Errors Occured on Http Request with XMLHttpRequest !'));
                            };
                            hXHR.ontimeout = function () {
                                reject(new Error('TimeOut Occured on Http Request with XMLHttpRequest !'));
                            };
                            hXHR.onload = function () {
                                if (hXHR.status == 200) {
                                    resolve(hXHR.responseText);
                                } else {
                                    var message = 'Errors Occured on Http Request (status : \'' + hXHR.status + '\' | response : \'' + hXHR.responseText + '\')';
                                    var status = hXHR.status;
                                    reject({
                                        message: message,
                                        status: status
                                    });
                                }
                            };
                            var data4xdr = options.data && corps ? options.data : null;
                            hXHR.send(data4xdr);
                        } else {
                            throw new Error('CORS not supported');
                        }
                    }
                });
                return promise;
            },
            __callJSON: function (options) {
                return this.__call(options).then(JSON.parse).catch(function (error) {
                    console.log('_callJSON failed on : ', options.url, error);
                    throw error;
                });
            },
            __callXML: function (options) {
                return this.__call(options).then(function (response) {
                    var xmlDoc;
                    if (typeof window === 'undefined') {
                        var DOMParser = xmldom.DOMParser;
                        xmlDoc = new DOMParser().parseFromString(response, 'text/xml');
                    } else {
                        if (window.DOMParser) {
                            var parser = new window.DOMParser();
                            xmlDoc = parser.parseFromString(response, 'text/xml');
                        } else {
                            xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
                            xmlDoc.async = false;
                            xmlDoc.loadXML(response);
                        }
                    }
                    return xmlDoc;
                }).catch(function (error) {
                    console.log('__callXML failed on : ', options.url, error);
                    throw error;
                });
            }
        };
        return XHR;
    }(UtilsLoggerByDefault, UtilsHelper, es6Promise, {});
    UtilsMessagesResources = function () {
        var MessagesResources = {
            PARAM_MISSING: 'Parameter(s) \'%var%\' missing',
            PARAM_EMPTY: 'Parameter(s) \'%var%\' empty',
            PARAM_TYPE: 'Wrong type(s) for parameter(s) \'%var%\'',
            PARAM_FORMAT: 'Parameter(s) \'%var%\' not correctly formatted',
            PARAM_NOT_SUPPORT: 'Value(s) for parameter(s) \'%var%\' not supported',
            PARAM_NOT_SUPPORT_NODEJS: 'Value(s) for parameter(s) \'%var%\' not supported to NodeJS',
            PARAM_UNKNOWN: 'Value(s) for parameter(s) \'%var%\' unknown',
            SERVICE_REQUEST_BUILD: 'An error occurred during the request building of the service',
            SERVICE_REQUEST_EMPTY: 'The request sent to the service is empty',
            SERVICE_RESPONSE_EXCEPTION: 'The service returned an exception : \'%var%\'',
            SERVICE_RESPONSE_EXCEPTION_2: 'The service returned an exception',
            SERVICE_RESPONSE_ANALYSE: 'An error occurred while parsing the response \'%var%\' of the service',
            SERVICE_RESPONSE_ANALYSE_2: 'An unknown error occurred while parsing the response',
            SERVICE_RESPONSE_EMPTY: 'The response of the service is empty',
            SERVICE_RESPONSE_EMPTY_2: 'The response from the service could not be analyzed or is empty',
            SERVICE_RESPONSE_FORMAT: 'The format of the service response is not supported (handled format(s) : \'%var%\')',
            SERVICE_RESPONSE_FORMAT_2: 'The format of the service response is not supported',
            SERVICE_RESPONSE_FORMAT_3: 'No suggestion matching the search',
            CLASS_CONSTRUCTOR: '\'%var%\' constructor cannot be called as a function.',
            getMessage: function (clef, parametres) {
                if (!arguments) {
                    return 'Message indefined !';
                }
                var params = Array.prototype.slice.call(arguments);
                var key = params.shift();
                var args = params;
                var message = this[key];
                try {
                    if (Array.isArray(args) && args.length > 0) {
                        message = message.replace('%var%', args.join(' - '));
                    } else {
                        message = message.replace('%var%', '%var% (not specified)');
                    }
                } catch (e) {
                }
                return message;
            }
        };
        return MessagesResources;
    }();
    ExceptionsErrorService = function () {
        function ErrorService(error) {
            if (!(this instanceof ErrorService)) {
                throw new TypeError('ErrorService constructor cannot be called as a function.');
            }
            var e = error;
            if (typeof error === 'string' || error instanceof String) {
                this.message = error;
                this.status = -1;
                this.type = ErrorService.TYPE_UNKERR;
            } else {
                this.message = e.message || 'undefined!?';
                this.type = e.type;
                this.status = e.status || -1;
            }
            this.name = 'ErrorService';
            this.stack = new Error().stack;
        }
        ErrorService.TYPE_SRVERR = 'SERVICE_ERROR';
        ErrorService.TYPE_USEERR = 'USAGE_ERROR';
        ErrorService.TYPE_UNKERR = 'UNKNOWN_ERROR';
        ErrorService.prototype = Object.create(Error.prototype, {
            constructor: {
                value: ErrorService,
                writable: true,
                configurable: true
            }
        });
        return ErrorService;
    }();
    ProtocolsJSONP = function (Logger) {
        var JSONP = {
            uuid: function () {
                var id = Math.floor(Date.now());
                return function () {
                    return id++;
                };
            }(),
            call: function (options) {
                if (!options) {
                    throw new Error('missing parameter : options !');
                }
                if (!options.url) {
                    throw new Error('missing parameter : options.url !');
                }
                if (!options.timeOut) {
                    options.timeOut = 0;
                }
                if (!options.onResponse) {
                    throw new Error('missing parameter : options.onResponse !');
                }
                var callbackId = typeof options.callbackSuffix === 'string' ? options.callbackSuffix : this.uuid();
                var urlHasCallbackKey = false;
                var urlHasCallbackName = false;
                var idx = options.url.indexOf('callback=');
                if (idx != -1) {
                    urlHasCallbackKey = true;
                    var j = options.url.indexOf('&', idx);
                    if (j === -1) {
                        j = options.url.length;
                    }
                    var callbackName = options.url.substring(idx + 9, j);
                    if (callbackName) {
                        urlHasCallbackName = true;
                        options.callbackName = callbackName;
                    }
                }
                if (!urlHasCallbackKey) {
                    var k = options.url.indexOf('?');
                    if (k === -1) {
                        options.url = options.url + '?' + 'callback=';
                    } else if (k === options.url.length) {
                        options.url = options.url + 'callback=';
                    } else {
                        options.url = options.url + '&' + 'callback=';
                    }
                }
                var HasCallbackName = options.callbackName ? true : urlHasCallbackName;
                if (!urlHasCallbackName) {
                    if (!options.callbackName) {
                        options.callbackName = 'callback';
                        if (callbackId || callbackId === '') {
                            options.callbackName += callbackId;
                        }
                    }
                    options.url = options.url.replace('callback=', 'callback=' + options.callbackName);
                }
                if (!options.onTimeOut) {
                    options.onTimeOut = function () {
                        console.log('TimeOut while invoking url : ' + options.url);
                    };
                }
                if (!HasCallbackName) {
                    var self = this;
                    var onTimeOutTrigger = null;
                    if (options.timeOut > 0) {
                        onTimeOutTrigger = window.setTimeout(function () {
                            window[options.callbackName] = function () {
                            };
                            options.onTimeOut();
                            self._deleteScript(callbackId);
                        }, options.timeOut);
                    }
                    window[options.callbackName] = function (data) {
                        window.clearTimeout(onTimeOutTrigger);
                        options.onResponse(data);
                        self._deleteScript(callbackId);
                    };
                }
                this._createScript(callbackId, options.url);
            },
            _createScript: function (callbackId, url) {
                var scriptu;
                var scripto = document.getElementById('results' + callbackId);
                scriptu = document.createElement('script');
                scriptu.setAttribute('type', 'text/javascript');
                scriptu.setAttribute('src', url);
                scriptu.setAttribute('charset', 'UTF-8');
                scriptu.setAttribute('id', 'results' + callbackId);
                scriptu.setAttribute('async', 'true');
                var node = document.documentElement || document.getElementsByTagName('head')[0];
                if (scripto === null) {
                    node.appendChild(scriptu);
                } else {
                    node.replaceChild(scriptu, scripto);
                }
            },
            _deleteScript: function (callbackId) {
                var script = document.getElementById('results' + callbackId);
                if (script) {
                    var node = script.parentNode || document.documentElement;
                    if (!node) {
                        return;
                    }
                    node.removeChild(script);
                }
            }
        };
        return JSONP;
    }(UtilsLoggerByDefault);
    ProtocolsProtocol = function (Helper, XHR, JSONP) {
        var Protocol = {
            send: function (options) {
                var settings = options || {
                    method: 'GET',
                    protocol: 'XHR',
                    timeOut: 0,
                    format: null,
                    wrap: true,
                    nocache: true,
                    output: 'json',
                    callback: null,
                    callbackSuffix: null
                };
                if (typeof window === 'undefined' && options.protocol === 'JSONP') {
                    console.log('Value(s) for parameter(s) \'protocol=JSONP (instead use XHR)\' not supported to NodeJS');
                    return;
                }
                if (options.protocol === 'XHR' || options.format === 'json') {
                    settings.wrap = false;
                } else if (options.protocol === 'JSONP' && options.format === 'xml') {
                    settings.wrap = true;
                }
                settings.callback = options.protocol == 'JSONP' ? null : null;
                settings.output = settings.wrap ? 'json' : null;
                if (settings.wrap) {
                    var params = {};
                    params.output = settings.output;
                    params.callback = settings.callback;
                    delete params.callback;
                    settings.url = Helper.normalyzeUrl(options.url, params);
                }
                switch (settings.protocol) {
                case 'XHR':
                    if (options.method === 'GET' && options.nocache) {
                        settings.url = Helper.normalyzeUrl(settings.url, { t: new Date().getTime() });
                    }
                    XHR.call(settings);
                    break;
                case 'JSONP':
                    if (settings.data) {
                        settings.url = Helper.normalyzeUrl(settings.url, settings.data);
                    }
                    JSONP.call(settings);
                    break;
                default:
                    throw new Error('protocol not supported (XHR|JSONP) !');
                }
            }
        };
        return Protocol;
    }(UtilsHelper, ProtocolsXHR, ProtocolsJSONP);
    ServicesDefaultUrlService = function () {
        var isBrowser = typeof window !== 'undefined' ? true : false;
        var protocol = isBrowser ? location && location.protocol && location.protocol.indexOf('https:') === 0 ? 'https://' : 'http://' : 'http://';
        var hostname = 'wxs.ign.fr';
        var keyname = '%KEY%';
        var url = protocol + hostname.concat('/', keyname);
        var fkey = function (key) {
            return this._key.replace(key ? keyname : null, key);
        };
        var DefaultUrlService = {
            Alti: {
                _key: {
                    'elevation-json': url + '/alti/rest/elevation.json',
                    'elevation-xml': url + '/alti/rest/elevation.xml',
                    'profil-json': url + '/alti/rest/elevationLine.json',
                    'profil-xml': url + '/alti/rest/elevationLine.xml',
                    wps: url + '/alti/wps'
                },
                url: function (key) {
                    return {
                        'elevation-json': this._key['elevation-json'].replace(key ? keyname : null, key),
                        'elevation-xml': this._key['elevation-xml'].replace(key ? keyname : null, key),
                        'profil-json': this._key['profil-json'].replace(key ? keyname : null, key),
                        'profil-xml': this._key['profil-xml'].replace(key ? keyname : null, key),
                        wps: this._key.wps.replace(key ? keyname : null, key)
                    };
                }
            },
            ProcessIsoCurve: {
                _key: {
                    'iso-json': url + '/isochrone/isochrone.json',
                    'iso-xml': url + '/isochrone/isochrone.xml'
                },
                url: function (key) {
                    return {
                        'iso-json': this._key['iso-json'].replace(key ? keyname : null, key),
                        'iso-xml': this._key['iso-xml'].replace(key ? keyname : null, key)
                    };
                }
            },
            AutoComplete: {
                _key: url + '/ols/apis/completion',
                url: fkey
            },
            ReverseGeocode: {
                _key: url + '/geoportail/ols',
                url: fkey
            },
            AutoConf: {
                _key: {
                    apiKey: url + '/autoconf',
                    apiKeys: url + '/autoconf?keys=%KEYS%'
                },
                url: function (key) {
                    var keys = '';
                    if (Array.isArray(key) && key.length > 0) {
                        keys = key[0];
                        for (var i = 1; i < key.length; i++) {
                            keys += ',' + key[i];
                        }
                    }
                    return {
                        apiKey: this._key['apiKey'].replace(key ? keyname : null, key),
                        apiKeys: this._key['apiKeys'].replace(keyname, key[0]).replace('%KEYS%', keys),
                        aggregate: protocol + hostname.concat('/') + key + '/autoconf/id/'
                    };
                }
            },
            Geocode: {
                _key: url + '/geoportail/ols',
                url: fkey
            },
            Route: {
                _key: {
                    ols: url + '/itineraire/ols',
                    'route-json': url + '/itineraire/rest/route.json',
                    'route-xml': url + '/itineraire/rest/route.xml'
                },
                url: function (key) {
                    return {
                        ols: this._key.ols.replace(key ? keyname : null, key),
                        'route-json': this._key['route-json'].replace(key ? keyname : null, key),
                        'route-xml': this._key['route-xml'].replace(key ? keyname : null, key)
                    };
                }
            }
        };
        return DefaultUrlService;
    }();
    ServicesCommonService = function (Logger, Helper, _, Protocol, ErrorService, DefaultUrlService) {
        function CommonService(options) {
            if (!(this instanceof CommonService)) {
                throw new TypeError(_.getMessage('CLASS_CONSTRUCTOR'));
            }
            this.options = {
                protocol: 'XHR',
                proxyURL: '',
                callbackSuffix: null,
                httpMethod: 'GET',
                timeOut: 0,
                rawResponse: false,
                scope: this,
                onSuccess: function (response) {
                    console.log('onSuccess - la reponse est la suivante : ', response);
                },
                onFailure: function (error) {
                    if (error.status === 200 || !error.status) {
                        console.log('onFailure : ', error.message);
                    } else {
                        console.log('onFailure - Erreur (', error.status, ') : ', error.message);
                    }
                }
            };
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
            if (!this.options.apiKey && !this.options.serverUrl) {
                throw new Error(_.getMessage('PARAM_MISSING', 'apiKey', 'serverUrl'));
            }
            if (this.options.rawResponse && !this.options.onSuccess) {
                this.options.onSuccess = function (response) {
                    console.log('onSuccess - la rponse brute du service est la suivante : ', response);
                };
            }
            var bOnSuccess = this.options.onSuccess !== null && typeof this.options.onSuccess === 'function' ? true : false;
            if (!bOnSuccess) {
                throw new Error(_.getMessage('PARAM_MISSING', 'onSuccess()'));
            }
            if (!this.options.serverUrl) {
                var urlByDefault = DefaultUrlService[this.CLASSNAME].url(this.options.apiKey);
                if (typeof urlByDefault === 'string') {
                    this.options.serverUrl = urlByDefault;
                } else {
                }
            }
            this.options.httpMethod = typeof options.httpMethod === 'string' ? options.httpMethod.toUpperCase() : 'GET';
            switch (this.options.httpMethod) {
            case 'POST':
            case 'GET':
                break;
            case 'PUT':
            case 'DELETE':
            case 'HEAD':
            case 'OPTIONS':
                throw new Error(_.getMessage('PARAM_NOT_SUPPORT', 'httpMethod'));
            default:
                throw new Error(_.getMessage('PARAM_UNKNOWN', 'httpMethod'));
            }
            this.options.protocol = typeof options.protocol === 'string' ? options.protocol.toUpperCase() : 'XHR';
            switch (this.options.protocol) {
            case 'JSONP':
            case 'XHR':
                break;
            default:
                throw new Error(_.getMessage('PARAM_UNKNOWN', 'protocol'));
            }
            if (typeof window === 'undefined' && this.options.protocol === 'JSONP') {
                throw new Error(_.getMessage('PARAM_NOT_SUPPORT_NODEJS', 'protocol=JSONP (instead use XHR)'));
            }
            if (this.options.protocol === 'JSONP') {
                this.options.httpMethod = 'GET';
            }
            this.options.nocache = options.nocache || false;
            this.options.outputFormat = null;
            this.request = null;
            this.response = null;
        }
        CommonService.prototype = {
            constructor: CommonService,
            call: function () {
                function run() {
                    this.buildRequest.call(this, onError, onBuildRequest);
                }
                run.call(this);
                function onBuildRequest(result) {
                    this.callService.call(this, onError, onCallService);
                }
                function onCallService(result) {
                    this.analyzeResponse.call(this, onError, onAnalyzeResponse);
                }
                function onAnalyzeResponse(result) {
                    if (result) {
                        this.options.onSuccess.call(this, result);
                    } else {
                        return onError.call(this, new ErrorService('Analyse de la reponse en chec !?'));
                    }
                }
                function onError(error) {
                    var e = error;
                    if (!(e instanceof ErrorService)) {
                        e = new ErrorService(error.message);
                    }
                    this.options.onFailure.call(this, e);
                }
            },
            buildRequest: function (error, success) {
            },
            callService: function (error, success) {
                var strUrlProxified = null;
                var strData = this.request;
                var bUrlProxified = this.options.proxyURL && this.options.protocol === 'XHR' ? true : false;
                this.options.serverUrl = Helper.normalyzeUrl(this.options.serverUrl, { 'gp-access-lib': '1.0.1' }, false);
                if (bUrlProxified) {
                    if (this.options.httpMethod === 'GET') {
                        strUrlProxified = this.options.proxyURL + Helper.normalyzeUrl(this.options.serverUrl, this.request, true);
                        strData = null;
                    }
                    if (this.options.httpMethod === 'POST') {
                        strUrlProxified = this.options.proxyURL + Helper.normalyzeUrl(this.options.serverUrl, null, true);
                        strData = this.request;
                    }
                }
                var self = this;
                var options = {
                    url: strUrlProxified || this.options.serverUrl,
                    method: this.options.httpMethod,
                    protocol: this.options.protocol,
                    timeOut: this.options.timeOut || 0,
                    format: this.options.outputFormat,
                    nocache: this.options.nocache || false,
                    wrap: this.options.protocol === 'XHR' ? false : true,
                    callbackSuffix: this.options.callbackSuffix,
                    data: strData,
                    headers: null,
                    content: this.options.contentType || 'application/xml',
                    scope: this.options.scope || this,
                    onResponse: function (response) {
                        var content = null;
                        if (self.options.protocol == 'XHR') {
                            content = response;
                        }
                        if (self.options.protocol == 'JSONP') {
                            if (response) {
                                if (response.http) {
                                    if (response.http.status !== 200) {
                                        error.call(self, new ErrorService({
                                            status: response.http.status,
                                            message: response.http.error,
                                            type: ErrorService.TYPE_SRVERR
                                        }));
                                        return;
                                    } else {
                                        content = response.xml;
                                        if (self.options.rawResponse) {
                                            content = response;
                                        }
                                    }
                                } else {
                                    content = response;
                                }
                            } else {
                                error.call(self, new ErrorService('Le contenu de la reponse est vide !?'));
                                return;
                            }
                        }
                        self.response = content;
                        success.call(self, content);
                    },
                    onFailure: function (e) {
                        e.type = ErrorService.TYPE_SRVERR;
                        error.call(self, new ErrorService(e));
                    },
                    onTimeOut: function () {
                        error.call(self, new ErrorService('TimeOut!'));
                    }
                };
                Protocol.send(options);
            },
            analyzeResponse: function (error, success) {
            }
        };
        return CommonService;
    }(UtilsLoggerByDefault, UtilsHelper, UtilsMessagesResources, ProtocolsProtocol, ExceptionsErrorService, ServicesDefaultUrlService);
    ServicesAltiRequestModelAltiRequest = function (Logger) {
        function AltiRequest(options) {
            if (!(this instanceof AltiRequest)) {
                throw new TypeError('AltiRequest constructor cannot be called as a function.');
            }
            this.options = options || {};
            this.positions = this.options.positions || [];
            this.delimiter = this.options.delimiter || '|';
            this.indent = this.options.indent || false;
            this.crs = this.options.crs || 'CRS:84';
            this.format = this.options.format || 'json';
        }
        AltiRequest.CLASSNAME = 'AltiRequest';
        AltiRequest.prototype = {
            constructor: AltiRequest,
            setPositions: function (lstPosition) {
                var positions = [];
                for (var i = 0; i < lstPosition.length; i++) {
                    var o = lstPosition[i];
                    if (o.lon && o.lat) {
                        positions.push(o);
                    }
                }
                this.positions = positions;
            },
            getPositions: function (pos) {
                if (!pos) {
                    return this.positions;
                }
                var index = this.positions.length - 1;
                if (pos > index || pos < index) {
                    return this.positions;
                }
                return this.positions[pos];
            },
            addPositions: function (lstPosition) {
                for (var i = 0; i < lstPosition.length; i++) {
                    var o = lstPosition[i];
                    if (o.lon && o.lat) {
                        this.positions.push(lstPosition[i]);
                    }
                }
            },
            getLon: function () {
                var lstLon = [];
                for (var i = 0; i < this.positions.length; i++) {
                    lstLon.push(this.positions[i].lon);
                }
                return lstLon.join(this.delimiter);
            },
            getLat: function () {
                var lstLat = [];
                for (var i = 0; i < this.positions.length; i++) {
                    lstLat.push(this.positions[i].lat);
                }
                return lstLat.join(this.delimiter);
            }
        };
        AltiRequest.prototype.getData = function () {
            var map = [];
            map.push({
                k: 'lon',
                v: this.getLon()
            });
            map.push({
                k: 'lat',
                v: this.getLat()
            });
            map.push({
                k: 'delimiter',
                v: this.delimiter
            });
            map.push({
                k: 'indent',
                v: this.indent
            });
            map.push({
                k: 'crs',
                v: this.crs
            });
            map.push({
                k: 'format',
                v: this.format
            });
            return map;
        };
        return AltiRequest;
    }(UtilsLoggerByDefault);
    ServicesAltiRequestModelAltiElevationRequest = function (Logger, AltiRequest) {
        function AltiElevationRequest(options) {
            if (!(this instanceof AltiElevationRequest)) {
                throw new TypeError('AltiElevationRequest constructor cannot be called as a function.');
            }
            this.CLASSNAME = 'AltiElevationRequest';
            AltiRequest.apply(this, arguments);
            this.zonly = this.options.zonly || false;
        }
        AltiElevationRequest.prototype = Object.create(AltiRequest.prototype, {
            zonly: {
                get: function () {
                    return this._zonly;
                },
                set: function (z) {
                    this._zonly = z;
                }
            }
        });
        AltiElevationRequest.prototype.constructor = AltiElevationRequest;
        AltiElevationRequest.prototype.getData = function () {
            var map = [];
            map.push({
                k: 'lon',
                v: this.getLon()
            });
            map.push({
                k: 'lat',
                v: this.getLat()
            });
            map.push({
                k: 'indent',
                v: this.indent
            });
            map.push({
                k: 'crs',
                v: this.crs
            });
            map.push({
                k: 'zonly',
                v: this.zonly
            });
            map.push({
                k: 'format',
                v: this.format
            });
            return map;
        };
        return AltiElevationRequest;
    }(UtilsLoggerByDefault, ServicesAltiRequestModelAltiRequest);
    ServicesAltiRequestModelAltiProfilRequest = function (Logger, AltiRequest) {
        function AltiProfilRequest(options) {
            if (!(this instanceof AltiProfilRequest)) {
                throw new TypeError('AltiProfilRequest constructor cannot be called as a function.');
            }
            this.CLASSNAME = 'AltiProfilRequest';
            AltiRequest.apply(this, arguments);
            this.sampling = this.options.sampling || 3;
        }
        AltiProfilRequest.prototype = Object.create(AltiRequest.prototype, {
            sampling: {
                get: function () {
                    return this._sampling;
                },
                set: function (value) {
                    this._sampling = value;
                }
            }
        });
        AltiProfilRequest.prototype.constructor = AltiProfilRequest;
        AltiProfilRequest.prototype.getData = function () {
            var map = [];
            map.push({
                k: 'lon',
                v: this.getLon()
            });
            map.push({
                k: 'lat',
                v: this.getLat()
            });
            map.push({
                k: 'indent',
                v: this.indent
            });
            map.push({
                k: 'crs',
                v: this.crs
            });
            map.push({
                k: 'sampling',
                v: this.sampling
            });
            map.push({
                k: 'format',
                v: this.format
            });
            return map;
        };
        return AltiProfilRequest;
    }(UtilsLoggerByDefault, ServicesAltiRequestModelAltiRequest);
    ServicesAltiRequestAltiRequestREST = function (Logger, _, AltiElevationRequest, AltiProfilRequest) {
        function AltiRequestREST(options) {
            if (!(this instanceof AltiRequestREST)) {
                throw new TypeError('AltiRequestREST constructor cannot be called as a function.');
            }
            this.options = options || {};
            if (!this.options) {
                throw new Error(_.getMessage('PARAM_EMPTY', 'options'));
            }
            if (!this.options.type) {
                throw new Error(_.getMessage('PARAM_EMPTY', 'type (Elevation or Profil)'));
            }
            this.DataObject = null;
            switch (this.options.type) {
            case 'Elevation':
                this.DataObject = new AltiElevationRequest(this.options.param);
                break;
            case 'Profil':
                this.DataObject = new AltiProfilRequest(this.options.param);
                break;
            default:
                throw new Error(_.getMessage('PARAM_TYPE', 'type (Elevation or Profil)'));
            }
            this.method = this.options.method || 'GET';
        }
        AltiRequestREST.prototype = {
            requestString: null,
            constructor: AltiRequestREST,
            template: {
                get: {
                    value: 'lon=__LON__&lat=__LAT__&indent=__INDENT__&crs=\'__CRS__\'',
                    input: {
                        point: '&zonly=__ZONLY__',
                        profil: '&sampling=__SAMPLING__'
                    }
                },
                post: {
                    value: 'lon=__LON__\n' + 'lat=__LAT__\n' + 'indent=__INDENT__\n' + 'crs=\'__CRS__\'\n',
                    input: {
                        point: 'zonly=__ZONLY__',
                        profil: 'sampling=__SAMPLING__'
                    }
                }
            },
            processRequestString: function () {
                var template = '';
                if (this.method == 'POST') {
                    template = this.template.post.value;
                } else if (this.method == 'GET') {
                    template = this.template.get.value;
                }
                template = template.replace(/__LON__/g, this.DataObject.getLon());
                template = template.replace(/__LAT__/g, this.DataObject.getLat());
                template = template.replace(/__INDENT__/g, this.DataObject.indent);
                template = template.replace(/__CRS__/g, this.DataObject.crs);
                template = template + this.__addDataInputs();
                this.requestString = template;
                return this.requestString;
            },
            __addDataInputs: function () {
                var myTemplate;
                if (this.method == 'POST') {
                    myTemplate = this.template.post;
                } else if (this.method == 'GET') {
                    myTemplate = this.template.get;
                } else {
                    throw new Error('No other HTTP method supported by the service !');
                }
                var tmpl = null;
                if (this.DataObject.CLASSNAME == 'AltiElevationRequest') {
                    tmpl = myTemplate.input.point;
                    return tmpl.replace(/__ZONLY__/g, this.DataObject.zonly);
                } else if (this.DataObject.CLASSNAME == 'AltiProfilRequest') {
                    tmpl = myTemplate.input.profil;
                    return tmpl.replace(/__SAMPLING__/g, this.DataObject.sampling);
                } else {
                    throw new Error('No other object supported than elevation or profil !?');
                }
            }
        };
        return AltiRequestREST;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ServicesAltiRequestModelAltiElevationRequest, ServicesAltiRequestModelAltiProfilRequest);
    FormatsWPS = function (Logger) {
        function WPS(options) {
            if (!(this instanceof WPS)) {
                throw new TypeError('WPS constructor cannot be called as a function.');
            }
            this.options = options || {};
            this.DataObject = this.options.data;
            if (!this.DataObject) {
                throw new TypeError('This data object is not defined !');
            }
            this.paramservice = this.options.param.service || 'WPS';
            this.paramversion = this.options.param.version || '1.0.0';
            this.paramidentifier = this.options.param.identifier || 'gs:WPS';
            this.paramrawdataoutput = this.options.param.rawdataoutput || 'result';
            this.paramrequest = this.options.param.request || 'Execute';
            this.method = this.options.method || 'GET';
        }
        WPS.prototype = {
            requestString: null,
            constructor: WPS,
            template: {
                get: {
                    value: 'service=__SERVICE__' + '&version=__VERSION__' + '&rawdataoutput=__RAWDATAOUTPUT__' + '&identifier=__IDENTIFIER__' + '&request=__REQUEST__' + '&datainputs=<!-- __DATAINPUTS__ -->',
                    input: '__KEY__=__DATA__'
                },
                post: {
                    value: '<?xml version="1.0" encoding="UTF-8"?>' + '<wps:__REQUEST__ version="__VERSION__" service="__SERVICE__" ' + '__NAMESPACE__ __SCHEMALOCATION__>' + '<ows:Identifier>__IDENTIFIER__</ows:Identifier>' + '<wps:DataInputs>' + '<!-- __DATAINPUTS__ -->' + '</wps:DataInputs>' + '<wps:ResponseForm>' + '<wps:RawDataOutput>' + '<ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>' + '</wps:RawDataOutput>' + '</wps:ResponseForm>' + '</wps:__REQUEST__>',
                    input: '<wps:Input>' + '<ows:Identifier>__KEY__</ows:Identifier>' + '<wps:Data>' + '<wps:LiteralData>__DATA__</wps:LiteralData>' + '</wps:Data>' + '</wps:Input>'
                }
            },
            namespaceByDefault: function () {
                var ns = [
                    'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"',
                    'xmlns="http://www.opengis.net/wps/1.0.0"',
                    'xmlns:wfs="http://www.opengis.net/wfs"',
                    'xmlns:wps="http://www.opengis.net/wps/1.0.0"',
                    'xmlns:ows="http://www.opengis.net/ows/1.1"',
                    'xmlns:gml="http://www.opengis.net/gml"',
                    'xmlns:ogc="http://www.opengis.net/ogc"',
                    'xmlns:wcs="http://www.opengis.net/wcs/1.1.1"',
                    'xmlns:xlink="http://www.w3.org/1999/xlink"'
                ];
                return ns.join(' ');
            },
            schemaLocationByDefault: function () {
                return 'xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd"';
            },
            processRequestString: function () {
                var template = '';
                if (this.method == 'POST') {
                    template = this.template.post.value;
                } else if (this.method == 'GET') {
                    template = this.template.get.value;
                } else {
                    return false;
                }
                template = template.replace(/__SERVICE__/g, this.paramservice);
                template = template.replace(/__VERSION__/g, this.paramversion);
                template = template.replace(/__RAWDATAOUTPUT__/g, this.paramrawdataoutput);
                template = template.replace(/__IDENTIFIER__/g, this.paramidentifier);
                template = template.replace(/__REQUEST__/g, this.paramrequest);
                if (this.method == 'POST') {
                    template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);
                    template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);
                }
                template = template.replace(/<!-- __DATAINPUTS__ -->/g, this.__addDataInputs());
                if (!template) {
                    return false;
                }
                this.requestString = template;
                return true;
            },
            __addDataInputs: function () {
                var tmpl = this.method == 'GET' ? this.template.get.input : this.template.post.input;
                var sep = this.method == 'GET' ? ';' : '';
                var result = '';
                var that = this;
                var map = this.DataObject.getData();
                for (var i = 0; i < map.length; i++) {
                    (function (j) {
                        if (sep) {
                            sep = j == map.length - 1 ? '' : ';';
                        }
                        result = result.concat(that.__addDataInput(tmpl, map[j].k, map[j].v), sep);
                    }(i));
                }
                return result;
            },
            __addDataInput: function (tmpl, key, data) {
                var tmp = tmpl;
                tmp = tmp.replace(/__KEY__/g, key);
                tmp = tmp.replace(/__DATA__/g, data);
                return tmp;
            },
            setMethod: function (method) {
                if (method == 'GET' || method == 'POST') {
                    this.method = method;
                } else {
                }
            },
            getMethod: function () {
                return this.method;
            }
        };
        return WPS;
    }(UtilsLoggerByDefault);
    ServicesAltiRequestAltiRequestWPS = function (Logger, _, WPS, AltiElevationRequest, AltiProfilRequest) {
        var AltiRequestWPS = {
            build: function (options) {
                if (!options) {
                    throw new Error(_.getMessage('PARAM_EMPTY', 'options'));
                }
                if (!options.type) {
                    throw new Error(_.getMessage('PARAM_EMPTY', 'type (Elevation or Profil)'));
                }
                var DataObject = null;
                switch (options.type) {
                case 'Elevation':
                    options.wps.identifier = 'gs:WPSElevation';
                    DataObject = new AltiElevationRequest(options.param);
                    break;
                case 'Profil':
                    options.wps.identifier = 'gs:WPSLineElevation';
                    DataObject = new AltiProfilRequest(options.param);
                    break;
                default:
                    throw new Error(_.getMessage('PARAM_TYPE', 'type (Elevation or Profil)'));
                }
                var settings = {
                    data: DataObject,
                    method: options.method,
                    param: options.wps
                };
                var rqstWPS = new WPS(settings);
                if (!rqstWPS.processRequestString()) {
                    throw new Error('Enable to process request !');
                }
                return rqstWPS.requestString;
            }
        };
        return AltiRequestWPS;
    }(UtilsLoggerByDefault, UtilsMessagesResources, FormatsWPS, ServicesAltiRequestModelAltiElevationRequest, ServicesAltiRequestModelAltiProfilRequest);
    ServicesAltiRequestAltiRequestFactory = function (Logger, ErrorService, AltiRequestREST, AltiRequestWPS) {
        var AltiRequestFactory = {
            build: function (options) {
                var request = null;
                var settings = {
                    type: options.sampling ? 'Profil' : 'Elevation',
                    method: options.httpMethod,
                    param: {
                        positions: null,
                        delimiter: null,
                        indent: null,
                        crs: null,
                        format: null,
                        sampling: null,
                        zonly: null
                    }
                };
                settings.param.positions = options.positions;
                settings.param.format = options.outputFormat;
                settings.param.sampling = options.sampling;
                settings.param.zonly = options.zonly;
                var bOnError = options.onError !== null && typeof options.onError === 'function' ? true : false;
                var bOnSuccess = options.onSuccess !== null && typeof options.onSuccess === 'function' ? true : false;
                var message = null;
                switch (options.api) {
                case 'REST':
                    var myReq = new AltiRequestREST(settings);
                    if (!myReq.processRequestString()) {
                        message = 'Error in process request (rest) !';
                        if (bOnError) {
                            options.onError.call(options.scope, new ErrorService(message));
                            return;
                        }
                        throw new Error(message);
                    }
                    request = myReq.requestString;
                    break;
                case 'WPS':
                    settings.wps = {
                        service: null,
                        version: null,
                        identifier: null,
                        rawdataoutput: null,
                        request: null
                    };
                    request = AltiRequestWPS.build(settings);
                    if (!request) {
                        message = 'Error in process request (wps) !';
                        if (bOnError) {
                            options.onError.call(options.scope, new ErrorService(message));
                            return;
                        }
                        throw new Error(message);
                    }
                    break;
                default:
                    message = 'Type of API is not supported by service (REST or WPS) !';
                    if (bOnError) {
                        options.onError.call(options.scope, new ErrorService(message));
                        return;
                    }
                    throw new Error(message);
                }
                if (bOnSuccess) {
                    options.onSuccess.call(options.scope, request);
                }
                return request;
            }
        };
        return AltiRequestFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, ServicesAltiRequestAltiRequestREST, ServicesAltiRequestAltiRequestWPS);
    FormatsXML = function (Logger, require) {
        function XML(options) {
            if (!(this instanceof XML)) {
                throw new TypeError('XML constructor cannot be called as a function.');
            }
            this.xmlString = null;
            this.xmlDoc = null;
            this.reader = null;
            if (options) {
                if (options.xmlString && typeof options.xmlString === 'string') {
                    this.xmlString = options.xmlString;
                    this.xmlDoc = __getXMLDOC(options.xmlString);
                }
                if (options.reader) {
                    this.setReader(options.reader);
                }
            }
        }
        XML.prototype = {
            constructor: XML,
            getXMLString: function () {
                return this.xmlString;
            },
            setXMLString: function (xmlString) {
                if (xmlString && typeof xmlString === 'string') {
                    this.xmlString = xmlString;
                    this.xmlDoc = __getXMLDOC(xmlString);
                }
            },
            getReader: function () {
                return this.reader;
            },
            setReader: function (reader) {
                if (reader && reader.read && typeof reader.read === 'function') {
                    this.reader = reader;
                }
            },
            getXMLDoc: function () {
                return this.xmlDoc;
            },
            setXMLDoc: function (doc) {
                this.xmlDoc = doc;
            },
            parse: function () {
                if (!this.xmlDoc && this.xmlString) {
                    this.xmlDoc = __getXMLDOC(this.xmlString);
                }
                if (this.xmlDoc) {
                    var root = __getRootNode(this.xmlDoc);
                    if (root) {
                        var parserOutput;
                        if (this.reader && this.reader.read) {
                            parserOutput = this.reader.read(root);
                        } else {
                            parserOutput = {};
                            parserOutput[root.nodeName] = __readDefault(root);
                        }
                        return parserOutput;
                    } else {
                        return {};
                    }
                }
            }
        };
        function __getXMLDOC(xmlString) {
            if (typeof exports === 'object') {
                var DOMParser = xmldom.DOMParser;
                return new DOMParser().parseFromString(xmlString, 'text/xml');
            } else {
                var parser;
                var xmlDoc;
                var errorMsg = 'Erreur lors du parsing de la rponse du service : XML non conforme';
                if (window.ActiveXObject) {
                    xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
                    xmlDoc.async = false;
                    xmlDoc.loadXML(xmlString);
                    var parseError = xmlDoc.parseError;
                    if (parseError.errorCode) {
                        if (parseError.line && parseError.linepos) {
                            errorMsg += '( ligne ' + parseError.line + ', colonne ' + parseError.linepos;
                        }
                        if (parseError.reason) {
                            errorMsg += ':  ' + parseError.reason + ')';
                        }
                        throw new Error(errorMsg);
                    }
                    return xmlDoc;
                } else if (window.DOMParser) {
                    parser = new window.DOMParser();
                    try {
                        xmlDoc = parser.parseFromString(xmlString, 'text/xml');
                    } catch (e) {
                        if (e.message === 'SyntaxError') {
                            throw new Error(errorMsg);
                        } else {
                            throw new Error('Erreur lors du parsing de la rponse du service : ' + e.message);
                        }
                    }
                    if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
                        var parsererror = xmlDoc.getElementsByTagName('parsererror');
                        for (var i = 0; i < parsererror.length; i++) {
                            var content = parsererror[i].innerHTML;
                            if (content.indexOf('Huge input lookup') == -1) {
                                errorMsg += '(' + content + ')';
                                throw new Error(errorMsg);
                            }
                        }
                    } else if (!xmlDoc.documentElement) {
                        throw new Error(errorMsg);
                    }
                    return xmlDoc;
                } else {
                    throw new Error('Incompatible DOM Parser pour ce navigateur !');
                }
            }
        }
        function __getRootNode(xmlDoc) {
            var root;
            if (xmlDoc.nodeType === 9) {
                root = xmlDoc.documentElement;
            } else if (xmlDoc.nodeType === 1) {
                root = xmlDoc;
            }
            return root;
        }
        function __readDefault(node) {
            var data = {};
            if (node.attributes.length > 0) {
                var dataAttributes = __getAttributes(node);
                data['attributes'] = dataAttributes;
            }
            if (node.hasChildNodes()) {
                var childData = {};
                var child;
                var children = node.childNodes;
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    if (child.nodeType === 3) {
                        data['textContent'] = child.nodeValue;
                    } else if (child.nodeType === 1) {
                        childData = __readDefault(child);
                        if (!data[child.nodeName]) {
                            data[child.nodeName] = childData;
                        } else {
                            if (!Array.isArray(data[child.nodeName])) {
                                var old = data[child.nodeName];
                                data[child.nodeName] = [];
                                data[child.nodeName].push(old);
                            }
                            data[child.nodeName].push(childData);
                        }
                    }
                }
            }
            return data;
        }
        function __getAttributes(node) {
            if (node.attributes.length > 0) {
                var nodeAttributes = {};
                var attributes = node.attributes;
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    nodeAttributes[attribute.nodeName] = attribute.nodeValue;
                }
                return nodeAttributes;
            }
        }
        return XML;
    }(UtilsLoggerByDefault, {});
    ServicesAltiResponseModelAltiResponse = function () {
        function AltiResponse() {
            if (!(this instanceof AltiResponse)) {
                throw new TypeError('AltiResponse constructor cannot be called as a function.');
            }
            this.elevations = [];
        }
        AltiResponse.prototype = { constructor: AltiResponse };
        return AltiResponse;
    }();
    ServicesAltiResponseModelElevation = function () {
        function Elevation() {
            if (!(this instanceof Elevation)) {
                throw new TypeError('Elevation constructor cannot be called as a function.');
            }
            this.z = null;
        }
        Elevation.prototype = { constructor: Elevation };
        return Elevation;
    }();
    ServicesAltiFormatsAltiResponseReader = function (Logger, AltiResponse, Elevation) {
        var AltiResponseReader = {};
        AltiResponseReader.READERS = {
            elevations: function (root) {
                var altiResponse = new AltiResponse();
                if (root.hasChildNodes()) {
                    var children = root.childNodes;
                    var child;
                    var elevation;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (AltiResponseReader.READERS[child.nodeName]) {
                            elevation = AltiResponseReader.READERS[child.nodeName](child);
                            altiResponse.elevations.push(elevation);
                        }
                    }
                }
                return altiResponse;
            },
            elevation: function (node) {
                var elevation = new Elevation();
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (AltiResponseReader.READERS[child.nodeName]) {
                            AltiResponseReader.READERS[child.nodeName](child, elevation);
                        }
                    }
                }
                return elevation;
            },
            lat: function (node, elevation) {
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    elevation.lat = parseFloat(textNode.nodeValue);
                } else {
                    throw new Error('Erreur dans la lecture de la rponse du service: latitude attendue mais absente');
                }
            },
            lon: function (node, elevation) {
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    elevation.lon = parseFloat(textNode.nodeValue);
                } else {
                    throw new Error('Erreur dans la lecture de la rponse du service: longitude attendue mais absente');
                }
            },
            z: function (node, elevation) {
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    if (elevation) {
                        elevation.z = parseFloat(textNode.nodeValue);
                    } else {
                        elevation = new Elevation();
                        elevation.z = parseFloat(textNode.nodeValue);
                        return elevation;
                    }
                } else {
                    throw new Error('Erreur dans la lecture de la rponse du service: altitude attendue mais absente');
                }
            },
            acc: function (node, elevation) {
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    elevation.acc = parseFloat(textNode.nodeValue);
                } else {
                    throw new Error('Erreur dans la lecture de la rponse du service: prcision (acc) attendue mais absente');
                }
            },
            exceptionreport: function (node) {
                var response = {};
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (child.nodeName === 'Exception') {
                            response.exceptionReport = AltiResponseReader.READERS.exception(child);
                        }
                    }
                }
                return response;
            },
            exception: function (node) {
                var exceptionReport = {};
                var exceptionCode = node.getAttribute('exceptionCode');
                if (exceptionCode) {
                    exceptionReport.exceptionCode = exceptionCode;
                }
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    exceptionReport.exception = textNode.nodeValue;
                }
                return exceptionReport;
            },
            error: function (node) {
                var response = { error: {} };
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        var textNode;
                        if (child.nodeType === 1 && child.nodeName === 'code') {
                            textNode = child.firstChild;
                            if (textNode && textNode.nodeType === 3) {
                                response.error.code = textNode.nodeValue;
                            }
                        }
                        if (child.nodeType === 1 && child.nodeName === 'description') {
                            textNode = child.firstChild;
                            if (textNode && textNode.nodeType === 3) {
                                response.error.description = textNode.nodeValue;
                            }
                        }
                    }
                }
                return response;
            }
        };
        AltiResponseReader.read = function (root) {
            if (root.nodeName === 'elevations') {
                var altiResponse = AltiResponseReader.READERS.elevations(root);
                return altiResponse;
            } else if (root.nodeName === 'ExceptionReport') {
                var exceptionReport = AltiResponseReader.READERS.exceptionreport(root);
                return exceptionReport;
            } else if (root.nodeName === 'error') {
                var error = AltiResponseReader.READERS.error(root);
                return error;
            } else {
                throw new Error('Erreur lors de la lecture de la rponse : elle n\'est pas au format attendu.');
            }
        };
        return AltiResponseReader;
    }(UtilsLoggerByDefault, ServicesAltiResponseModelAltiResponse, ServicesAltiResponseModelElevation);
    ServicesAltiResponseAltiResponseFactory = function (Logger, ErrorService, MRes, XML, AltiResponseReader, AltiResponse, Elevation) {
        var AltiResponseFactory = {
            build: function (options) {
                var data = null;
                if (options.response) {
                    if (options.rawResponse) {
                        data = options.response;
                    } else {
                        switch (options.outputFormat) {
                        case 'xml':
                            try {
                                var p = new XML({ reader: AltiResponseReader });
                                if (typeof options.response === 'string') {
                                    p.setXMLString(options.response);
                                } else {
                                    p.setXMLDoc(options.response);
                                }
                                data = p.parse();
                                if (!data) {
                                    throw new Error(MRes.getMessage('SERVICE_RESPONSE_EXCEPTION_2'));
                                }
                            } catch (e) {
                                var message = e.message;
                                options.onError.call(options.scope, new ErrorService({
                                    message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', message),
                                    status: 200,
                                    type: ErrorService.TYPE_SRVERR
                                }));
                                return;
                            }
                            break;
                        case 'json':
                            var JSONResponse;
                            if (typeof options.response === 'string') {
                                JSONResponse = window.JSON.parse(options.response);
                            } else {
                                JSONResponse = options.response;
                            }
                            if (JSONResponse.error) {
                                options.onError.call(options.scope, new ErrorService({
                                    message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', JSONResponse.error.description),
                                    status: 200,
                                    type: ErrorService.TYPE_SRVERR
                                }));
                                return;
                            }
                            if (JSONResponse) {
                                var elevations = JSONResponse.elevations;
                                var altiResponse = new AltiResponse();
                                var elevation;
                                if (Array.isArray(elevations) && elevations.length) {
                                    for (var i = 0; i < elevations.length; i++) {
                                        elevation = new Elevation();
                                        if (typeof elevations[i] === 'object') {
                                            if (elevations[i].lon) {
                                                elevation.lon = elevations[i].lon;
                                            }
                                            if (elevations[i].lat) {
                                                elevation.lat = elevations[i].lat;
                                            }
                                            if (elevations[i].z) {
                                                elevation.z = elevations[i].z;
                                            }
                                            if (elevations[i].acc) {
                                                elevation.acc = elevations[i].acc;
                                            }
                                        } else if (typeof elevations[i] === 'number') {
                                            elevation.z = elevations[i];
                                        }
                                        if (Array.isArray(altiResponse.elevations)) {
                                            altiResponse.elevations.push(elevation);
                                        }
                                    }
                                }
                                data = altiResponse;
                            }
                            if (!data) {
                                options.onError.call(options.scope, new ErrorService({
                                    message: MRes.getMessage('SERVICE_RESPONSE_ANALYSE_2'),
                                    type: ErrorService.TYPE_UNKERR,
                                    status: -1
                                }));
                                return;
                            }
                            break;
                        default:
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_FORMAT_2'),
                                type: ErrorService.TYPE_UNKERR,
                                status: -1
                            }));
                            return;
                        }
                        if (data.exceptionReport) {
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', data.exceptionReport),
                                type: ErrorService.TYPE_SRVERR,
                                status: 200
                            }));
                            return;
                        } else if (data.error) {
                            var errorMess = data.error.description;
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', errorMess),
                                type: ErrorService.TYPE_SRVERR,
                                status: 200
                            }));
                            return;
                        }
                    }
                } else {
                    options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EMPTY')));
                    return;
                }
                options.onSuccess.call(options.scope, data);
                return;
            }
        };
        return AltiResponseFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, UtilsMessagesResources, FormatsXML, ServicesAltiFormatsAltiResponseReader, ServicesAltiResponseModelAltiResponse, ServicesAltiResponseModelElevation);
    ServicesAltiAlti = function (Logger, _, ErrorService, CommonService, DefaultUrlService, AltiRequestFactory, AltiResponseFactory) {
        function Alti(options) {
            if (!(this instanceof Alti)) {
                throw new TypeError(_.getMessage('CLASS_CONSTRUCTOR', 'Alti'));
            }
            this.CLASSNAME = 'Alti';
            CommonService.apply(this, arguments);
            if (!options.positions) {
                throw new Error(_.getMessage('PARAM_MISSING', 'positions'));
            }
            if (options.positions.length === 0) {
                throw new Error(_.getMessage('PARAM_EMPTY', 'positions'));
            }
            this.options.positions = options.positions;
            this.options.outputFormat = typeof options.outputFormat === 'string' ? options.outputFormat.toLowerCase() : 'xml';
            this.options.sampling = options.sampling || null;
            this.options.api = typeof options.api === 'string' ? options.api.toUpperCase() : 'REST';
            if (this.options.api === 'REST') {
                this.options.httpMethod = 'GET';
            }
            this.options.zonly = options.zonly || false;
            if (!this.options.serverUrl) {
                var lstUrlByDefault = DefaultUrlService.Alti.url(this.options.apiKey);
                var urlFound = null;
                switch (this.options.api) {
                case 'WPS':
                    urlFound = lstUrlByDefault.wps;
                    break;
                case 'REST':
                    var key = (options.sampling ? 'profil' : 'elevation') + '-' + this.options.outputFormat;
                    urlFound = lstUrlByDefault[key];
                    break;
                default:
                    throw new Error(_.getMessage('PARAM_UNKNOWN', 'api'));
                }
                if (!urlFound) {
                    throw new Error('Url by default not found !');
                }
                this.options.serverUrl = urlFound;
            }
            var idx = this.options.serverUrl.lastIndexOf('.');
            if (idx !== -1) {
                var extension = this.options.serverUrl.substring(idx + 1);
                if (extension && extension.length < 5) {
                    switch (extension.toLowerCase()) {
                    case 'json':
                    case 'xml':
                        this.options.outputFormat = extension.toLowerCase();
                        break;
                    default:
                        throw new Error('type of service : unknown or unsupported (json or xml) !');
                    }
                }
            }
        }
        Alti.prototype = Object.create(CommonService.prototype, {});
        Alti.prototype.constructor = Alti;
        Alti.prototype.buildRequest = function (error, success) {
            var options = {
                httpMethod: this.options.httpMethod,
                onSuccess: function (result) {
                    this.request = result;
                    success.call(this, this.request);
                },
                onError: error,
                scope: this,
                positions: this.options.positions,
                outputFormat: this.options.outputFormat,
                sampling: this.options.sampling,
                api: this.options.api,
                zonly: this.options.zonly
            };
            AltiRequestFactory.build(options);
        };
        Alti.prototype.analyzeResponse = function (error, success) {
            if (this.response) {
                var options = {
                    response: this.response,
                    outputFormat: this.options.outputFormat,
                    rawResponse: this.options.rawResponse,
                    onError: error,
                    onSuccess: success,
                    scope: this
                };
                AltiResponseFactory.build(options);
            } else {
                error.call(this, new ErrorService(_.getMessage('SERVICE_RESPONSE_EMPTY')));
            }
        };
        return Alti;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, ServicesCommonService, ServicesDefaultUrlService, ServicesAltiRequestAltiRequestFactory, ServicesAltiResponseAltiResponseFactory);
    ServicesAutoConfResponseModelAutoConfResponse = function () {
        function AutoConfResponse() {
            if (!(this instanceof AutoConfResponse)) {
                throw new TypeError('AutoConfResponse constructor cannot be called as a function.');
            }
            this.generalOptions = {
                apiKeys: {},
                title: null,
                defaultGMLGFIStyle: null,
                theme: null,
                wgs84Resolutions: []
            };
            this.layers = {};
            this.territories = {};
            this.tileMatrixSets = {};
            this.services = {};
        }
        AutoConfResponse.prototype = {
            constructor: AutoConfResponse,
            isConfLoaded: function (apiKey) {
                if (!apiKey) {
                    return;
                }
                if (this.generalOptions.apiKeys[apiKey]) {
                    return true;
                }
                return false;
            },
            getLayersId: function (apiKey) {
                return this.generalOptions.apiKeys[apiKey];
            },
            getLayersConf: function (apiKey) {
                var layers = {};
                var layersIdArray = this.getLayersId(apiKey);
                if (layersIdArray) {
                    for (var i = 0; i < layersIdArray.length; i++) {
                        var lyrId = layersIdArray[i];
                        layers[lyrId] = this.layers[lyrId];
                    }
                }
                return layers;
            },
            getLayerConf: function (layerId) {
                if (!this.layers) {
                    return;
                }
                return this.layers[layerId];
            },
            getTileMatrixSets: function () {
                return this.tileMatrixSets;
            },
            getTMSConf: function (tmsID) {
                if (!this.tileMatrixSets) {
                    return;
                }
                return this.tileMatrixSets[tmsID];
            },
            getTerritories: function () {
                return this.territories;
            },
            getTerritoryConf: function (territoryID) {
                if (!this.territories) {
                    return;
                }
                return this.territories[territoryID];
            },
            getServices: function () {
                return this.services;
            },
            getServiceConf: function (serviceID) {
                if (!this.services) {
                    return;
                }
                return this.services[serviceID];
            }
        };
        return AutoConfResponse;
    }();
    ServicesAutoConfResponseModelConstraint = function () {
        function Constraint() {
            if (!(this instanceof Constraint)) {
                throw new TypeError('Constraint constructor cannot be called as a function.');
            }
            this.crs = null;
            this.bbox = {
                left: null,
                right: null,
                top: null,
                bottom: null
            };
            this.minScaleDenominator = null;
            this.maxScaleDenominator = null;
            this.temporalExtent = [
                null,
                null
            ];
        }
        Constraint.prototype = { constructor: Constraint };
        return Constraint;
    }();
    ServicesAutoConfResponseModelFormat = function () {
        function Format() {
            if (!(this instanceof Format)) {
                throw new TypeError('Format constructor cannot be called as a function.');
            }
            this.current = null;
            this.name = null;
        }
        Format.prototype = { constructor: Format };
        return Format;
    }();
    ServicesAutoConfResponseModelLayer = function () {
        function Layer() {
            if (!(this instanceof Layer)) {
                throw new TypeError('Layer constructor cannot be called as a function.');
            }
        }
        Layer.prototype = {
            constructor: Layer,
            getName: function () {
                return this.name;
            },
            getTitle: function () {
                return this.title;
            },
            getDescription: function () {
                return this.description;
            },
            getLayerId: function () {
                return this.layerId;
            },
            getQuicklookUrl: function () {
                return this.quicklookUrl;
            },
            getDefaultProjection: function () {
                return this.defaultProjection;
            },
            getProjections: function () {
                var projections = [];
                projections.push(this.defaultProjection);
                var proj = projections.concat(this.additionalProjections);
                return proj;
            },
            getBBOX: function () {
                if (!this.globalConstraint) {
                    return;
                }
                return this.globalConstraint.bbox;
            },
            getMinScaleDenominator: function () {
                if (!this.globalConstraint) {
                    return;
                }
                return this.globalConstraint.minScaleDenominator;
            },
            getMaxScaleDenominator: function () {
                if (!this.globalConstraint) {
                    return;
                }
                return this.globalConstraint.maxScaleDenominator;
            },
            getTMSID: function () {
                if (this.wmtsOptions) {
                    return this.wmtsOptions.tileMatrixSetLink;
                }
                return;
            },
            getServiceParams: function () {
                return this.serviceParams;
            },
            getServerUrl: function (apiKey) {
                if (!apiKey || !this.serviceParams || !this.serviceParams.serverUrl) {
                    return;
                }
                return this.serviceParams.serverUrl[apiKey];
            },
            getLegends: function () {
                return this.legends;
            },
            getMetadata: function () {
                return this.metadata;
            },
            getStyles: function () {
                return this.styles;
            },
            getDefaultStyle: function () {
                if (!this.styles) {
                    return;
                }
                var style;
                var s = this.styles;
                for (var i = 0; i < s.length; i++) {
                    if (s[i].current === true) {
                        style = s[i].name;
                        break;
                    }
                }
                return style;
            },
            getThematics: function () {
                return this.thematics;
            },
            getDefaultFormat: function () {
                if (!this.formats) {
                    return;
                }
                var format;
                var f = this.formats;
                for (var i = 0; i < f.length; i++) {
                    if (f[i].current === true) {
                        format = f[i].name;
                        break;
                    }
                }
                return format;
            },
            getConstraints: function () {
                return this.constraints;
            },
            getOriginators: function () {
                return this.originators;
            },
            getDimensions: function () {
                return this.dimensions;
            },
            getAggregatedLayers: function () {
                if (this.isAggregate) {
                    return this.aggregatedLayers;
                } else {
                    return;
                }
            }
        };
        return Layer;
    }();
    ServicesAutoConfResponseModelLegend = function () {
        function Legend() {
            if (!(this instanceof Legend)) {
                throw new TypeError('Legend constructor cannot be called as a function.');
            }
            this.format = null;
            this.url = null;
            this.minScaleDenominator = null;
        }
        Legend.prototype = { constructor: Legend };
        return Legend;
    }();
    ServicesAutoConfResponseModelMetadata = function () {
        function Metadata() {
            if (!(this instanceof Metadata)) {
                throw new TypeError('Metadata constructor cannot be called as a function.');
            }
            this.format = null;
            this.url = null;
        }
        Metadata.prototype = { constructor: Metadata };
        return Metadata;
    }();
    ServicesAutoConfResponseModelOriginator = function () {
        function Originator() {
            if (!(this instanceof Originator)) {
                throw new TypeError('Originator constructor cannot be called as a function.');
            }
            this.name = null;
            this.attribution = null;
            this.logo = null;
            this.url = null;
            this.constraints = [];
        }
        Originator.prototype = { constructor: Originator };
        return Originator;
    }();
    ServicesAutoConfResponseModelService = function () {
        function Service() {
            if (!(this instanceof Service)) {
                throw new TypeError('Service constructor cannot be called as a function.');
            }
            this.title = null;
            this.serverUrl = null;
            this.version = null;
        }
        Service.prototype = { constructor: Service };
        return Service;
    }();
    ServicesAutoConfResponseModelStyle = function () {
        function Style() {
            if (!(this instanceof Style)) {
                throw new TypeError('Style constructor cannot be called as a function.');
            }
            this.name = null;
            this.title = null;
            this.current = null;
        }
        Style.prototype = { constructor: Style };
        return Style;
    }();
    ServicesAutoConfResponseModelTerritory = function () {
        function Territory() {
            if (!(this instanceof Territory)) {
                throw new TypeError('Territory constructor cannot be called as a function.');
            }
            this.isDefault = null;
            this.defaultCRS = null;
            this.additionalCRS = [];
            this.geoBBOX = {
                left: null,
                right: null,
                top: null,
                bottom: null
            };
            this.geoCenter = {
                lon: null,
                lat: null
            };
            this.defaultOptions = {
                resolution: null,
                minScaleDenominator: null,
                maxScaleDenominator: null
            };
            this.defaultLayers = [];
        }
        Territory.prototype = { constructor: Territory };
        return Territory;
    }();
    ServicesAutoConfResponseModelThematic = function () {
        function Thematic() {
            if (!(this instanceof Thematic)) {
                throw new TypeError('Thematic constructor cannot be called as a function.');
            }
            this.inspire = null;
            this.name = null;
        }
        Thematic.prototype = { constructor: Thematic };
        return Thematic;
    }();
    ServicesAutoConfResponseModelTileMatrixSet = function () {
        function TileMatrixSet() {
            if (!(this instanceof TileMatrixSet)) {
                throw new TypeError('TileMatrixSet constructor cannot be called as a function.');
            }
            this.projection = null;
            this.nativeResolutions = [];
            this.matrixIds = [];
            this.tileMatrices = {};
        }
        TileMatrixSet.prototype = {
            constructor: TileMatrixSet,
            getResolutions: function () {
                return this.nativeResolutions;
            },
            getMatrixIds: function () {
                return this.matrixIds;
            },
            getProjection: function () {
                return this.projection;
            },
            getTileMatrices: function () {
                return this.tileMatrices;
            },
            getTopLeftCorner: function () {
                var topLeftCorner;
                var matrices = this.getTileMatrices();
                if (matrices) {
                    for (var id in matrices) {
                        if (matrices.hasOwnProperty(id)) {
                            topLeftCorner = matrices[id].topLeftCorner;
                            break;
                        }
                    }
                }
                return topLeftCorner;
            }
        };
        return TileMatrixSet;
    }();
    ServicesAutoConfResponseModelTileMatrix = function () {
        function TileMatrix() {
            if (!(this instanceof TileMatrix)) {
                throw new TypeError('TileMatrix constructor cannot be called as a function.');
            }
            this.matrixId = null;
            this.matrixHeight = null;
            this.matrixWidth = null;
            this.scaleDenominator = null;
            this.tileHeight = null;
            this.tileWidth = null;
            this.topLeftCorner = null;
        }
        TileMatrix.prototype = {
            constructor: TileMatrix,
            getTopLeftCorner: function () {
                return this.topLeftCorner;
            },
            getScaleDenominator: function () {
                return this.scaleDenominator;
            },
            getTileHeight: function () {
                return this.tileHeight;
            },
            getTileWidth: function () {
                return this.tileWidth;
            },
            getMatrixHeight: function () {
                return this.matrixHeight;
            },
            getMatrixWidth: function () {
                return this.matrixWidth;
            }
        };
        return TileMatrix;
    }();
    ServicesAutoConfResponseModelTileMatrixLimit = function () {
        function TileMatrixLimit() {
            if (!(this instanceof TileMatrixLimit)) {
                throw new TypeError('TileMatrixLimit constructor cannot be called as a function.');
            }
            this.minTileRow = null;
            this.maxTileRow = null;
            this.minTileCol = null;
            this.maxTileCol = null;
        }
        TileMatrixLimit.prototype = { constructor: TileMatrixLimit };
        return TileMatrixLimit;
    }();
    ServicesAutoConfFormatsAutoConfResponseReader = function (Logger, AutoConfResponse, Constraint, Format, Layer, Legend, Metadata, Originator, Service, Style, Territory, Thematic, TileMatrixSet, TileMatrix, TileMatrixLimit) {
        var AutoConfResponseReader = {};
        AutoConfResponseReader.VERSION = '1.1.0';
        AutoConfResponseReader.NAMESPACES = {
            xmlns: 'http://www.opengis.net/context',
            gpp: 'http://api.ign.fr/geoportail',
            ows: 'http://www.opengis.net/ows/1.1',
            sld: 'http://www.opengis.net/sld',
            wmts: 'http://www.opengis.net/wmts/1.0',
            xlink: 'http://www.w3.org/1999/xlink',
            xsi: 'http://www.w3.org/2001/XMLSchema-instance'
        };
        AutoConfResponseReader.SCHEMALOCATION = [
            'http://www.opengis.net/context http://gpp3-wxs.ign.fr/schemas/extContext.xsd http://api.ign.fr/geoportail http://wxs.ign.fr/schemas/autoconf/autoconf.xsd',
            'http://www.opengis.net/context http://gpp3-wxs.ign.fr/schemas/extContext.xsd http://api.ign.fr/geoportail http://gpp3-wxs.ign.fr/schemas/autoconf.xsd'
        ];
        AutoConfResponseReader.DEFAULTPREFIX = 'context';
        AutoConfResponseReader.READERS = {
            context: {
                ViewContext: function (viewContextNode) {
                    __checkServiceAttributes(viewContextNode);
                    var config = new AutoConfResponse();
                    __getChildNodes(viewContextNode, config);
                    return config;
                },
                Title: function (titleNode, data) {
                    if (data && data.generalOptions) {
                        data.generalOptions.title = __getChildValue(titleNode);
                    } else if (data && data.lyr) {
                        data.lyr.title = __getChildValue(titleNode);
                    }
                },
                Abstract: function (node, data) {
                    if (data && data.lyr) {
                        data.lyr.description = __getChildValue(node);
                    }
                },
                Server: function (node, data) {
                    var serverId = node.getAttribute('service');
                    var title = node.getAttribute('title');
                    var version = node.getAttribute('version');
                    if (serverId) {
                        if (data && data.services && typeof data.services === 'object' && !data.services[serverId]) {
                            var s = new Service();
                            s.title = title;
                            s.version = version;
                            __getChildNodes(node, s);
                            data.services[serverId] = s;
                        } else if (data && data.lyr) {
                            if (!data.lyr.serviceParams) {
                                data.lyr.serviceParams = {};
                            }
                            data.lyr.serviceParams.id = serverId;
                            data.lyr.serviceParams.version = version;
                        }
                    }
                },
                OnlineResource: function (node, service) {
                    if (service && service.hasOwnProperty('serverUrl')) {
                        service.serverUrl = node.getAttribute('xlink:href');
                    }
                },
                LayerList: function (layerListNode, config) {
                    __getChildNodes(layerListNode, config);
                    if (config && config.layers && config.generalOptions && config.services) {
                        for (var lyr in config.layers) {
                            if (config.layers.hasOwnProperty(lyr)) {
                                var layerConfig = config.layers[lyr];
                                var apiKeys = layerConfig.apiKeys;
                                if (apiKeys && Array.isArray(apiKeys)) {
                                    for (var i = 0; i < apiKeys.length; i++) {
                                        var key = apiKeys[i];
                                        if (config.generalOptions.apiKeys) {
                                            if (!config.generalOptions.apiKeys[key] || !Array.isArray(config.generalOptions.apiKeys[key])) {
                                                config.generalOptions.apiKeys[key] = [];
                                            }
                                            config.generalOptions.apiKeys[key].push(lyr);
                                        }
                                    }
                                }
                                var serviceParams = layerConfig.serviceParams;
                                if (serviceParams && serviceParams.id) {
                                    if (!config.services[serviceParams.id]) {
                                        var s = new Service();
                                        if (serviceParams.serverUrl) {
                                            s.serverUrl = serviceParams.serverUrl;
                                        }
                                        if (serviceParams.version) {
                                            s.version = serviceParams.version;
                                        }
                                        config.services[serviceParams.id] = s;
                                    }
                                }
                                if (layerConfig.wmtsOptions && layerConfig.wmtsOptions.tileMatrixSetLink && config.tileMatrixSets) {
                                    var tmsLink = layerConfig.wmtsOptions.tileMatrixSetLink;
                                    var tileMatrixSets = config.tileMatrixSets;
                                    for (var tms in tileMatrixSets) {
                                        if (tileMatrixSets.hasOwnProperty(tms) && tms === tmsLink) {
                                            layerConfig.defaultProjection = tileMatrixSets[tms].projection;
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                Layer: function (layerNode, config) {
                    if (config && config.layers) {
                        var lyrData = {
                            lyr: new Layer(),
                            lyrId: null
                        };
                        var hidden = layerNode.getAttribute('hidden');
                        if (hidden === '1') {
                            lyrData.lyr.hidden = true;
                        } else {
                            lyrData.lyr.hidden = false;
                        }
                        var queryable = layerNode.getAttribute('queryable');
                        if (queryable === '1') {
                            lyrData.lyr.queryable = true;
                        } else {
                            lyrData.lyr.queryable = false;
                        }
                        __getChildNodes(layerNode, lyrData);
                        if (lyrData.lyrId) {
                            if (lyrData.lyr.serviceParams && lyrData.lyr.serviceParams.id) {
                                var serviceid = lyrData.lyr.serviceParams.id;
                                if (serviceid.toUpperCase().indexOf('OPENLS') !== -1 || serviceid.toUpperCase().indexOf('ELEVATION') !== -1) {
                                    var resourceId = lyrData.lyrId.split('$')[0];
                                    lyrData.lyrId = resourceId + '$' + serviceid;
                                }
                            }
                            lyrData.lyr.layerId = lyrData.lyrId;
                            config.layers[lyrData.lyrId] = lyrData.lyr;
                        }
                    }
                },
                Name: function (node, lyrData) {
                    if (lyrData && lyrData.lyr) {
                        lyrData.lyr.name = __getChildValue(node);
                    }
                },
                SRS: function (node, lyrData) {
                    if (lyrData && lyrData.lyr) {
                        lyrData.lyr.defaultProjection = __getChildValue(node);
                    }
                },
                Format: function (node, lyrData) {
                    if (lyrData && lyrData.lyr) {
                        var f = new Format();
                        var current = node.getAttribute('current');
                        if (current === '1') {
                            f.current = true;
                        } else {
                            f.current = false;
                        }
                        f.name = __getChildValue(node);
                        if (!lyrData.lyr.formats || !Array.isArray(lyrData.lyr.formats)) {
                            lyrData.lyr.formats = [];
                        }
                        lyrData.lyr.formats.push(f);
                    }
                },
                Style: function (node, lyrData) {
                    if (lyrData && lyrData.lyr) {
                        var s = new Style();
                        var current = node.getAttribute('current');
                        if (current === '1' || current === 1) {
                            s.current = true;
                        } else {
                            s.current = false;
                        }
                        if (node.hasChildNodes) {
                            var children = node.childNodes;
                            var child;
                            var childName;
                            for (var i = 0; i < children.length; i++) {
                                child = children[i];
                                if (child.nodeType === 1) {
                                    childName = child.localName || child.baseName || child.nodeName;
                                    if (childName === 'Name') {
                                        s.name = __getChildValue(child);
                                    } else if (childName === 'Title') {
                                        s.title = __getChildValue(child);
                                    }
                                }
                            }
                        }
                        if (!lyrData.lyr.styles || !Array.isArray(lyrData.lyr.styles)) {
                            lyrData.lyr.styles = [];
                        }
                        lyrData.lyr.styles.push(s);
                    }
                },
                Dimension: function (node, lyrData) {
                    var name = node.getAttribute('name');
                    var dim = __getChildValue(node);
                    if (lyrData && lyrData.lyr) {
                        if (!lyrData.lyr.dimensions) {
                            lyrData.lyr.dimensions = {};
                        }
                        if (name === 'Type') {
                            lyrData.lyr.dimensions.type = dim;
                        } else if (name === 'VisibilityRange') {
                            lyrData.lyr.dimensions.visibilityRange = dim;
                        } else if (name === 'VisibilityMode ') {
                            lyrData.lyr.dimensions.visibilityMode = dim;
                        } else if (name === 'GeometricType') {
                            lyrData.lyr.dimensions.geometricType = dim;
                        } else if (name === 'NoDataValue') {
                            lyrData.lyr.dimensions.noDataValue = dim;
                        }
                    }
                }
            },
            gpp: {
                Theme: function (themeNode, config) {
                    if (config && config.generalOptions && config.generalOptions.hasOwnProperty('theme')) {
                        config.generalOptions.theme = __getChildValue(themeNode);
                    }
                },
                defaultGMLGFIStyleUrl: function (node, config) {
                    if (config && config.generalOptions && config.generalOptions.hasOwnProperty('defaultGMLGFIStyle')) {
                        config.generalOptions.defaultGMLGFIStyle = __getChildValue(node);
                    }
                },
                Territory: function (territoryNode, config) {
                    var tid = territoryNode.getAttribute('id');
                    if (tid) {
                        var t = new Territory();
                        var isDefault = territoryNode.getAttribute('default');
                        if (isDefault === '1') {
                            t.isDefault = true;
                        } else {
                            t.isDefault = false;
                        }
                        __getChildNodes(territoryNode, t);
                        if (config && config.territories && typeof config.territories === 'object') {
                            config.territories[tid] = t;
                        }
                    }
                },
                defaultCRS: function (node, territory) {
                    if (territory && territory.hasOwnProperty('defaultCRS')) {
                        territory.defaultCRS = __getChildValue(node);
                    }
                },
                AdditionalCRS: function (node, data) {
                    var addCRS = __getChildValue(node);
                    if (addCRS && data) {
                        if (Array.isArray(data.additionalCRS)) {
                            data.additionalCRS.push(addCRS);
                        } else {
                            if (!data.additionalProjections || !Array.isArray(data.additionalProjections)) {
                                data.additionalProjections = [];
                            }
                            data.additionalProjections.push(addCRS);
                        }
                    }
                },
                DefaultLayer: function (node, territory) {
                    var lyr = node.getAttribute('layerId');
                    if (lyr && territory && Array.isArray(territory.defaultLayers)) {
                        territory.defaultLayers.push(lyr);
                    }
                },
                BoundingBox: function (node, data) {
                    if (data) {
                        var values = __getChildValue(node).split(',');
                        if (values.length === 4) {
                            var bbox = {
                                left: parseFloat(values[0]),
                                right: parseFloat(values[2]),
                                top: parseFloat(values[3]),
                                bottom: parseFloat(values[1])
                            };
                            var minT = node.getAttribute('minT');
                            var maxT = node.getAttribute('maxT');
                            if (data.hasOwnProperty('geoBBOX')) {
                                data.geoBBOX = bbox;
                            } else if (data.hasOwnProperty('bbox')) {
                                if (data.bbox.left || data.bbox.right || data.bbox.top || data.bbox.bottom) {
                                    if (!data.multiConstraints) {
                                        data.multiConstraints = [];
                                    }
                                    var newConstraint = new Constraint();
                                    newConstraint.bbox = bbox;
                                    newConstraint.temporalExtent = [
                                        minT,
                                        maxT
                                    ];
                                    data.multiConstraints.push(newConstraint);
                                } else {
                                    data.bbox = bbox;
                                    data.temporalExtent = [
                                        minT,
                                        maxT
                                    ];
                                }
                            } else {
                                if (!data.globalConstraint) {
                                    data.globalConstraint = new Constraint();
                                }
                                data.globalConstraint.bbox = bbox;
                                data.globalConstraint.temporalExtent = [
                                    minT,
                                    maxT
                                ];
                            }
                        }
                    }
                },
                Resolution: function (node, territory) {
                    var res = __getChildValue(node);
                    if (res && territory && territory.defaultOptions && territory.defaultOptions.hasOwnProperty('resolution')) {
                        territory.defaultOptions.resolution = parseFloat(res);
                    }
                },
                x: function (node, territory) {
                    var lon = __getChildValue(node);
                    if (lon && territory && territory.geoCenter && territory.geoCenter.hasOwnProperty('lon')) {
                        territory.geoCenter.lon = parseFloat(lon);
                    }
                },
                y: function (node, territory) {
                    var lat = __getChildValue(node);
                    if (lat && territory && territory.geoCenter && territory.geoCenter.hasOwnProperty('lat')) {
                        territory.geoCenter.lat = parseFloat(lat);
                    }
                },
                Resolutions: function (resNode, config) {
                    if (config && config.generalOptions && config.generalOptions.hasOwnProperty('wgs84Resolutions')) {
                        config.generalOptions.wgs84Resolutions = __getChildValue(resNode).split(',');
                    }
                },
                Layer: function (node, lyrData) {
                    if (lyrData && lyrData.hasOwnProperty('lyrId') && lyrData.lyr) {
                        lyrData.lyrId = node.getAttribute('id');
                        var aggregate = node.getAttribute('aggregate');
                        var more = node.getAttribute('more');
                        if (aggregate || more) {
                            lyrData.lyr.isAggregate = true;
                        }
                        __getChildNodes(node, lyrData.lyr);
                    }
                },
                Constraint: function (node, data) {
                    var c = new Constraint();
                    __getChildNodes(node, c);
                    if (data) {
                        if (!data.constraints || !Array.isArray(data.constraints)) {
                            data.constraints = [];
                        }
                        if (c.multiConstraints && Array.isArray(c.multiConstraints)) {
                            var constraint = new Constraint();
                            constraint.crs = c.crs;
                            constraint.bbox = c.bbox;
                            constraint.minScaleDenominator = c.minScaleDenominator;
                            constraint.maxScaleDenominator = c.maxScaleDenominator;
                            constraint.temporalExtent = c.temporalExtent;
                            data.constraints.push(constraint);
                            for (var i = 0; i < c.multiConstraints.length; i++) {
                                constraint = new Constraint();
                                constraint.crs = c.crs;
                                constraint.minScaleDenominator = c.minScaleDenominator;
                                constraint.maxScaleDenominator = c.maxScaleDenominator;
                                constraint.bbox = c.multiConstraints[i].bbox;
                                constraint.temporalExtent = c.multiConstraints[i].temporalExtent;
                                data.constraints.push(constraint);
                            }
                        } else {
                            data.constraints.push(c);
                        }
                    }
                },
                CRS: function (node, data) {
                    if (data && data.hasOwnProperty('crs')) {
                        data.crs = __getChildValue(node);
                    }
                },
                Thematic: function (node, lyr) {
                    if (lyr) {
                        var t = new Thematic();
                        t.inspire = false;
                        t.name = __getChildValue(node);
                        if (!lyr.thematics || !Array.isArray(lyr.thematics)) {
                            lyr.thematics = [];
                        }
                        lyr.thematics.push(t);
                    }
                },
                InspireThematic: function (node, lyr) {
                    if (lyr) {
                        var t = new Thematic();
                        t.inspire = true;
                        t.name = __getChildValue(node);
                        if (!lyr.thematics || !Array.isArray(lyr.thematics)) {
                            lyr.thematics = [];
                        }
                        lyr.thematics.push(t);
                    }
                },
                Originator: function (node, lyr) {
                    if (lyr) {
                        var o = new Originator();
                        o.name = node.getAttribute('name');
                        __getChildNodes(node, o);
                        if (!lyr.originators || !Array.isArray(lyr.originators)) {
                            lyr.originators = [];
                        }
                        lyr.originators.push(o);
                    }
                },
                Attribution: function (node, originator) {
                    if (originator && originator.hasOwnProperty('attribution')) {
                        originator.attribution = __getChildValue(node);
                    }
                },
                Logo: function (node, originator) {
                    if (originator && originator.hasOwnProperty('logo')) {
                        originator.logo = __getChildValue(node);
                    }
                },
                URL: function (node, originator) {
                    if (originator && originator.hasOwnProperty('url')) {
                        originator.url = __getChildValue(node);
                    }
                },
                Legend: function (node, lyr) {
                    var l = new Legend();
                    __getChildNodes(node, l);
                    if (lyr) {
                        if (!lyr.legends || !Array.isArray(lyr.legends)) {
                            lyr.legends = [];
                        }
                        lyr.legends.push(l);
                    }
                },
                LegendURL: function (node, legend) {
                    if (legend && legend.hasOwnProperty('format')) {
                        legend.format = node.getAttribute('format');
                        if (node.hasChildNodes) {
                            var child = node.childNodes[0];
                            var childName = child.localName || child.baseName || child.nodeName;
                            if (childName === 'OnlineResource' && legend.hasOwnProperty('url')) {
                                legend.url = child.getAttribute('xlink:href');
                            }
                        }
                    }
                },
                QuickLook: function (node, lyr) {
                    if (node.hasChildNodes) {
                        var child = node.childNodes[0];
                        var childName = child.localName || child.baseName || child.nodeName;
                        if (childName === 'OnlineResource' && lyr) {
                            lyr.quicklookUrl = child.getAttribute('xlink:href');
                        }
                    }
                },
                MetadataURL: function (node, lyr) {
                    if (lyr) {
                        var m = new Metadata();
                        m.format = node.getAttribute('format');
                        if (node.hasChildNodes) {
                            var child = node.childNodes[0];
                            var childName = child.localName || child.baseName || child.nodeName;
                            if (childName === 'OnlineResource') {
                                m.url = child.getAttribute('xlink:href');
                            }
                        }
                        if (!lyr.metadata && !Array.isArray(lyr.metadata)) {
                            lyr.metadata = [];
                        }
                        lyr.metadata.push(m);
                    }
                },
                Key: function (node, lyr) {
                    if (lyr) {
                        var key = node.getAttribute('id');
                        if (!lyr.apiKeys || !Array.isArray(lyr.apiKeys)) {
                            lyr.apiKeys = [];
                        }
                        lyr.apiKeys.push(key);
                        var serverUrl = __getChildValue(node);
                        if (!lyr.serviceParams) {
                            lyr.serviceParams = {};
                        }
                        if (!lyr.serviceParams.serverUrl) {
                            lyr.serviceParams.serverUrl = {};
                        }
                        if (!lyr.serviceParams.serverUrl[key]) {
                            lyr.serviceParams.serverUrl[key] = serverUrl;
                        }
                    }
                }
            },
            ows: {
                Identifier: function (node, data) {
                    if (data && data.hasOwnProperty('TMS')) {
                        data.identifier = __getChildValue(node);
                    } else if (data && data.hasOwnProperty('matrixId')) {
                        data.matrixId = __getChildValue(node);
                    }
                },
                SupportedCRS: function (node, tmsData) {
                    if (tmsData && tmsData.TMS && tmsData.TMS.hasOwnProperty('projection')) {
                        tmsData.TMS.projection = __getChildValue(node);
                    }
                }
            },
            sld: {
                MinScaleDenominator: function (node, data) {
                    var minScale = __getChildValue(node);
                    if (minScale && data) {
                        if (data.hasOwnProperty('defaultOptions')) {
                            data.defaultOptions.minScaleDenominator = parseFloat(minScale);
                        } else if (data.lyr) {
                            if (!data.lyr.globalConstraint) {
                                data.lyr.globalConstraint = new Constraint();
                            }
                            data.lyr.globalConstraint.minScaleDenominator = parseFloat(minScale);
                        } else if (data.hasOwnProperty('minScaleDenominator')) {
                            data.minScaleDenominator = parseFloat(minScale);
                        }
                    }
                },
                MaxScaleDenominator: function (node, data) {
                    var maxScale = __getChildValue(node);
                    if (maxScale && data) {
                        if (data.hasOwnProperty('defaultOptions')) {
                            data.defaultOptions.maxScaleDenominator = parseFloat(maxScale);
                        } else if (data.lyr) {
                            if (!data.lyr.globalConstraint) {
                                data.lyr.globalConstraint = new Constraint();
                            }
                            data.lyr.globalConstraint.maxScaleDenominator = parseFloat(maxScale);
                        } else if (data.hasOwnProperty('maxScaleDenominator')) {
                            data.maxScaleDenominator = parseFloat(maxScale);
                        }
                    }
                }
            },
            wmts: {
                TileMatrixSetLimits: function (node, lyr) {
                    if (lyr) {
                        var limits = {};
                        __getChildNodes(node, limits);
                        if (!lyr.wmtsOptions) {
                            lyr.wmtsOptions = {};
                        }
                        lyr.wmtsOptions.tileMatrixSetLimits = limits;
                    }
                },
                TileMatrixLimits: function (node, limits) {
                    var limit = new TileMatrixLimit();
                    var limitId;
                    if (node.hasChildNodes) {
                        var children = node.childNodes;
                        for (var i = 0; i < children.length; i++) {
                            var child = children[i];
                            var childName = child.localName || child.baseName || child.nodeName;
                            if (childName === 'TileMatrix') {
                                limitId = __getChildValue(child);
                            } else if (childName === 'MinTileRow') {
                                limit.minTileRow = __getChildValue(child);
                            } else if (childName === 'MaxTileRow') {
                                limit.maxTileRow = __getChildValue(child);
                            } else if (childName === 'MinTileCol') {
                                limit.minTileCol = __getChildValue(child);
                            } else if (childName === 'MaxTileCol') {
                                limit.maxTileCol = __getChildValue(child);
                            }
                        }
                        if (limitId && limits && !limits[limitId]) {
                            limits[limitId] = limit;
                        }
                    }
                },
                TileMatrixSet: function (node, data) {
                    if (data && data.tileMatrixSets) {
                        var tmsData = {};
                        tmsData.TMS = new TileMatrixSet();
                        tmsData.resolutions = [];
                        __getChildNodes(node, tmsData);
                        var tileMatrices = tmsData.TMS.tileMatrices;
                        for (var tm in tileMatrices) {
                            if (tileMatrices.hasOwnProperty(tm)) {
                                tmsData.TMS.matrixIds.push(tm);
                            }
                        }
                        if (tmsData.TMS.getProjection() === 'IGNF:WGS84G' || tmsData.TMS.getProjection() === 'EPSG:4326') {
                            if (data.generalOptions && Array.isArray(data.generalOptions.wgs84Resolutions)) {
                                var wgs84Resolutions = data.generalOptions.wgs84Resolutions;
                                for (var i = 0; i < wgs84Resolutions.length; i++) {
                                    tmsData.resolutions[i] = parseFloat(wgs84Resolutions[i]);
                                }
                            }
                        }
                        if (Array.isArray(tmsData.resolutions) && tmsData.resolutions.sort !== undefined) {
                            tmsData.resolutions.sort(function (x, y) {
                                return y - x;
                            });
                        }
                        tmsData.TMS.nativeResolutions = tmsData.resolutions;
                        data.tileMatrixSets[tmsData.identifier] = tmsData.TMS;
                    } else {
                        if (data && !data.wmtsOptions) {
                            data.wmtsOptions = {};
                        }
                        data.wmtsOptions.tileMatrixSetLink = __getChildValue(node);
                    }
                },
                TileMatrix: function (node, tmsData) {
                    if (tmsData) {
                        var tileMatrix = new TileMatrix();
                        __getChildNodes(node, tileMatrix);
                        if (tmsData.TMS && tmsData.TMS.getProjection()) {
                            var proj = tmsData.TMS.getProjection();
                            if (proj === 'EPSG:3857' || proj === 'EPSG:2154') {
                                var r = tileMatrix.scaleDenominator * 0.00028;
                                if (tmsData.resolutions && Array.isArray(tmsData.resolutions)) {
                                    tmsData.resolutions.push(r);
                                }
                            }
                        }
                        if (tmsData.TMS && tmsData.TMS.tileMatrices) {
                            tmsData.TMS.tileMatrices[tileMatrix.matrixId] = tileMatrix;
                        }
                    }
                },
                ScaleDenominator: function (node, tileMatrix) {
                    var scale = __getChildValue(node);
                    if (scale && tileMatrix && tileMatrix.hasOwnProperty('scaleDenominator')) {
                        tileMatrix.scaleDenominator = parseFloat(scale);
                    }
                },
                TopLeftCorner: function (node, tileMatrix) {
                    var values = __getChildValue(node).split(' ');
                    if (values && tileMatrix) {
                        tileMatrix.topLeftCorner = {};
                        tileMatrix.topLeftCorner.x = parseFloat(values[0]);
                        tileMatrix.topLeftCorner.y = parseFloat(values[1]);
                    }
                },
                TileWidth: function (node, tileMatrix) {
                    var value = __getChildValue(node);
                    if (value && tileMatrix && tileMatrix.hasOwnProperty('tileWidth')) {
                        tileMatrix.tileWidth = parseInt(value, 10);
                    }
                },
                TileHeight: function (node, tileMatrix) {
                    var value = __getChildValue(node);
                    if (value && tileMatrix && tileMatrix.hasOwnProperty('tileHeight')) {
                        tileMatrix.tileHeight = parseInt(value, 10);
                    }
                },
                MatrixWidth: function (node, tileMatrix) {
                    var value = __getChildValue(node);
                    if (value && tileMatrix && tileMatrix.hasOwnProperty('matrixWidth')) {
                        tileMatrix.matrixWidth = parseInt(value, 10);
                    }
                },
                MatrixHeight: function (node, tileMatrix) {
                    var value = __getChildValue(node);
                    if (value && tileMatrix && tileMatrix.hasOwnProperty('matrixHeight')) {
                        tileMatrix.matrixHeight = parseInt(value, 10);
                    }
                }
            },
            serviceException: function (node) {
                var response = {};
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (child.nodeName === 'exception') {
                            response.exceptionReport = AutoConfResponseReader.READERS['exception'](child);
                        }
                    }
                }
                return response;
            },
            exception: function (node) {
                var exceptionReport = {};
                var exceptionCode = node.getAttribute('code');
                if (exceptionCode) {
                    exceptionReport.exceptionCode = exceptionCode;
                }
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    exceptionReport.exception = textNode.nodeValue;
                }
                return exceptionReport;
            }
        };
        AutoConfResponseReader.read = function (root) {
            if (root.nodeName === 'ViewContext') {
                var nsPrefix = root.prefix || AutoConfResponseReader.DEFAULTPREFIX;
                var config = AutoConfResponseReader.READERS[nsPrefix][root.nodeName](root);
                return config;
            } else if (root.nodeName === 'serviceException') {
                var exceptionReport = AutoConfResponseReader.READERS[root.nodeName](root);
                return exceptionReport;
            } else {
                throw new Error('Erreur lors de la lecture de la rponse : elle n\'est pas au format attendu.');
            }
        };
        function __getAttributes(node) {
            if (node.attributes.length > 0) {
                var nodeAttributes = {};
                var attributes = node.attributes;
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    nodeAttributes[attribute.nodeName] = attribute.nodeValue;
                }
                return nodeAttributes;
            }
        }
        function __getChildNodes(node, data) {
            if (node.hasChildNodes()) {
                var children = node.childNodes;
                var child;
                var childName;
                var childPrefix;
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    if (child.nodeType === 1) {
                        childName = child.localName || child.baseName || child.nodeName;
                        childPrefix = child.prefix || AutoConfResponseReader.DEFAULTPREFIX;
                        if (AutoConfResponseReader.READERS[childPrefix][childName]) {
                            var reader = AutoConfResponseReader.READERS[childPrefix][childName];
                            reader(child, data);
                        } else {
                            __getChildNodes(child, data);
                        }
                    }
                }
            }
        }
        function __getChildValue(node) {
            var textNode;
            var value = '';
            if (node.hasChildNodes()) {
                textNode = node.firstChild;
                if (textNode.nodeType === 3 || textNode.nodeType === 4) {
                    value = textNode.nodeValue;
                }
            }
            return value;
        }
        function __checkServiceAttributes(viewContextNode) {
            if (viewContextNode.attributes.length > 0) {
                var xlsAttributes = __getAttributes(viewContextNode);
                for (var att in xlsAttributes) {
                    if (xlsAttributes.hasOwnProperty(att)) {
                        if (att === 'version') {
                            if (xlsAttributes['version'] !== AutoConfResponseReader.VERSION) {
                                console.log('[AutoConfResponseReader] autoconf version is not the expected one : there may be errors in parsing');
                                return;
                            }
                        }
                        if (att === 'xmlns') {
                            if (xlsAttributes[att] !== AutoConfResponseReader.NAMESPACES.xmlns) {
                                console.log('[AutoConfResponseReader] autoconf response default namespace is not the expected one');
                                return;
                            }
                            continue;
                        }
                        var prefix = att.split(':')[0];
                        var ns = att.split(':')[1];
                        if (prefix === 'xmlns' && ns) {
                            if (AutoConfResponseReader.NAMESPACES[ns]) {
                                if (AutoConfResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {
                                    console.log('[AutoConfResponseReader] autoconf response ' + att + ' namespace is not the expected one');
                                    return;
                                }
                            }
                        }
                        if (ns === 'schemaLocation') {
                            if (xlsAttributes[att] !== AutoConfResponseReader.SCHEMALOCATION[0] && xlsAttributes[att] !== AutoConfResponseReader.SCHEMALOCATION[1]) {
                                console.log('[AutoConfResponseReader] autoconf response schema location is not the expected one');
                                return;
                            }
                        }
                    }
                }
            }
        }
        return AutoConfResponseReader;
    }(UtilsLoggerByDefault, ServicesAutoConfResponseModelAutoConfResponse, ServicesAutoConfResponseModelConstraint, ServicesAutoConfResponseModelFormat, ServicesAutoConfResponseModelLayer, ServicesAutoConfResponseModelLegend, ServicesAutoConfResponseModelMetadata, ServicesAutoConfResponseModelOriginator, ServicesAutoConfResponseModelService, ServicesAutoConfResponseModelStyle, ServicesAutoConfResponseModelTerritory, ServicesAutoConfResponseModelThematic, ServicesAutoConfResponseModelTileMatrixSet, ServicesAutoConfResponseModelTileMatrix, ServicesAutoConfResponseModelTileMatrixLimit);
    ServicesAutoConfResponseAutoConfResponseFactory = function (Logger, ErrorService, MRes, XML, AutoConfResponseReader) {
        var AutoConfReponseFactory = {
            build: function (options) {
                var data = null;
                if (options.response) {
                    if (options.rawResponse) {
                        data = options.response;
                    } else {
                        try {
                            var p = new XML({ reader: AutoConfResponseReader });
                            if (typeof options.response === 'string') {
                                p.setXMLString(options.response);
                            } else {
                                p.setXMLDoc(options.response);
                            }
                            data = p.parse();
                        } catch (e) {
                            var message = e.message;
                            if (typeof options.response === 'string') {
                                message += '\n(raw response service\'' + options.response + '\')';
                            } else {
                                message += '\n(raw response service\'' + options.response.documentElement.innerHTML + '\')';
                            }
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', message),
                                status: 200,
                                type: ErrorService.TYPE_SRVERR
                            }));
                            return;
                        }
                        var isEmpty = true;
                        for (var key in data) {
                            if (data.hasOwnProperty(key)) {
                                isEmpty = false;
                            }
                        }
                        if (isEmpty) {
                            options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EMPTY_2')));
                            return;
                        }
                        if (data.exceptionReport) {
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', data.exceptionReport),
                                type: ErrorService.TYPE_SRVERR,
                                status: 200
                            }));
                            return;
                        }
                    }
                } else {
                    options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EMPTY')));
                    return;
                }
                var scope = typeof window !== 'undefined' ? window : {};
                if (!scope.Gp) {
                    scope.Gp = {};
                }
                if (!scope.Gp.Config) {
                    scope.Gp.Config = data;
                } else {
                    this.mergeConfig(scope.Gp.Config, data, options.layerId);
                }
                options.onSuccess.call(options.scope, scope.Gp.Config);
                return;
            },
            mergeConfig: function (GpConfig, data, layerId) {
                if (data && GpConfig) {
                    for (var prop in data) {
                        if (data.hasOwnProperty(prop)) {
                            if (prop == 'generalOptions') {
                                for (var key in data[prop].apiKeys) {
                                    if (data[prop].apiKeys.hasOwnProperty(key) && !GpConfig.generalOptions.apiKeys[key]) {
                                        GpConfig.generalOptions.apiKeys[key] = data[prop].apiKeys[key];
                                    }
                                }
                            } else {
                                if (GpConfig[prop]) {
                                    for (var obj in data[prop]) {
                                        if (data[prop].hasOwnProperty(obj) && !GpConfig[prop][obj]) {
                                            GpConfig[prop][obj] = data[prop][obj];
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (layerId) {
                        var aggregatedLayers = [];
                        for (var lyr in data.layers) {
                            if (data.layers.hasOwnProperty(lyr)) {
                                aggregatedLayers.push(lyr);
                            }
                        }
                        if (GpConfig.layers[layerId]) {
                            GpConfig.layers[layerId].aggregatedLayers = aggregatedLayers;
                        }
                    }
                }
            }
        };
        return AutoConfReponseFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, UtilsMessagesResources, FormatsXML, ServicesAutoConfFormatsAutoConfResponseReader);
    ServicesAutoConfAutoConf = function (Logger, _, ErrorService, Helper, DefaultUrlService, CommonService, AutoConfResponseFactory) {
        function AutoConf(options) {
            if (!(this instanceof AutoConf)) {
                throw new TypeError(_.getMessage('CLASS_CONSTRUCTOR', 'AutoConf'));
            }
            this.CLASSNAME = 'AutoConf';
            if (!options) {
                options = {};
            }
            options.protocol = options.protocol || 'JSONP';
            CommonService.apply(this, arguments);
            if (!this.options.serverUrl) {
                if (!this.options.serverUrl) {
                    var lstUrlByDefault = DefaultUrlService.AutoConf.url(this.options.apiKey);
                    if (!this.options.layerId) {
                        if (Array.isArray(this.options.apiKey) && this.options.apiKey.length > 0) {
                            this.options.serverUrl = lstUrlByDefault.apiKeys;
                        } else {
                            this.options.serverUrl = lstUrlByDefault.apiKey;
                        }
                    } else {
                        this.options.serverUrl = lstUrlByDefault.aggregate + this.options.layerId;
                    }
                }
            }
            if (this.options.protocol === 'XHR' && this.options.httpMethod === 'POST') {
                this.options.httpMethod = 'GET';
            }
            this.options.outputFormat = this.options.rawResponse ? '' : 'xml';
        }
        AutoConf.prototype = Object.create(CommonService.prototype, {});
        AutoConf.prototype.constructor = AutoConf;
        AutoConf.prototype.buildRequest = function (error, success) {
            var scope = typeof window !== 'undefined' ? window : {};
            if (scope.Gp && scope.Gp.Config && scope.Gp.Config.generalOptions && scope.Gp.Config.layers) {
                if (scope.Gp.Config.generalOptions.apiKeys[this.options.apiKey]) {
                    if (this.options.layerId) {
                        if (scope.Gp.Config.layers[this.options.layerId] && scope.Gp.Config.layers[this.options.layerId].aggregatedLayers) {
                            this.options.onSuccess.call(this, scope.Gp.Config);
                            return;
                        }
                    } else {
                        this.options.onSuccess.call(this, scope.Gp.Config);
                        return;
                    }
                }
            }
            this.request = '';
            var bLocal;
            if (this.options.serverUrl.indexOf('http://') === -1) {
                bLocal = true;
            } else {
                bLocal = false;
            }
            if (!bLocal && this.layerId) {
                this.request = Helper.normalyzeParameters({ layerId: this.layerId });
            }
            success.call(this, this.request);
        };
        AutoConf.prototype.analyzeResponse = function (error, success) {
            if (this.response) {
                var options = {
                    layerId: this.options.layerId,
                    response: this.response,
                    rawResponse: this.options.rawResponse,
                    onSuccess: success,
                    onError: error,
                    scope: this
                };
                AutoConfResponseFactory.build(options);
            } else {
                error.call(this, new ErrorService(_.getMessage('SERVICE_RESPONSE_EMPTY')));
            }
        };
        return AutoConf;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, UtilsHelper, ServicesDefaultUrlService, ServicesCommonService, ServicesAutoConfResponseAutoConfResponseFactory);
    FormatsXLSRequestHeader = function (Logger) {
        function RequestHeader(options) {
            if (!(this instanceof RequestHeader)) {
                throw new TypeError('RequestHeader constructor cannot be called as a function.');
            }
            this.options = options || { srsName: 'EPSG:4326' };
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
        }
        RequestHeader.prototype = {
            requestString: null,
            template: '<RequestHeader srsName="__SRSNAME__"/>',
            constructor: RequestHeader,
            toString: function () {
                var template = null;
                template = this.template;
                template = template.replace(/__SRSNAME__/g, this.options.srsName);
                this.requestString = template;
                return this.requestString;
            }
        };
        return RequestHeader;
    }(UtilsLoggerByDefault);
    FormatsXLSRequest = function (Logger) {
        function Request(options) {
            if (!(this instanceof Request)) {
                throw new TypeError('Request constructor cannot be called as a function.');
            }
            this.options = options || {
                maximumResponses: 25,
                methodName: null,
                version: '1.2'
            };
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
        }
        Request.prototype = {
            requestString: null,
            template: '<Request maximumResponses="__MAXRESPONSES__" methodName="__METHODNAME__" requestID="__UUID__" version="__VERSION__">' + '<!-- __REQUESTSERVICE__ -->' + '</Request>',
            constructor: Request,
            guid: function () {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = Math.random() * 16 | 0;
                    var v = c === 'x' ? r : r & 3 | 8;
                    return v.toString(16);
                });
            },
            toString: function () {
                var template = null;
                template = this.template;
                template = template.replace(/__MAXRESPONSES__/g, this.options.maximumResponses);
                template = template.replace(/__METHODNAME__/g, this.options.methodName);
                template = template.replace(/__UUID__/g, this.guid());
                template = template.replace(/__VERSION__/g, this.options.version);
                this.requestString = template;
                return this.requestString;
            }
        };
        return Request;
    }(UtilsLoggerByDefault);
    FormatsXLSAbstractService = function (Logger) {
        function AbstractService(options) {
            if (!(this instanceof AbstractService)) {
                throw new TypeError('AbstractService constructor cannot be called as a function.');
            }
            this.options = options || {};
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
        }
        AbstractService.prototype = {
            strRequest: null,
            oRequest: null,
            oFilter: null,
            constructor: AbstractService,
            addRequest: function (oRequest) {
            },
            addFilter: function (oFilter) {
            },
            toString: function () {
            }
        };
        return AbstractService;
    }(UtilsLoggerByDefault);
    FormatsXLS = function (Logger, RequestHeader, Request, AbstractService) {
        function XLS(options) {
            if (!(this instanceof XLS)) {
                throw new TypeError('XLS constructor cannot be called as a function.');
            }
            this.options = {
                srsName: 'EPSG:4326',
                maximumResponses: 25
            };
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    if (options[opt]) {
                        this.options[opt] = options[opt];
                    }
                }
            }
        }
        XLS.VERSION = '1.2';
        XLS.prototype = {
            requestString: null,
            namespace: false,
            oService: null,
            constructor: XLS,
            template: '<?xml version="1.0" encoding="UTF-8"?>\n' + '<XLS version="__VERSION__"\n' + '__NAMESPACE__ \n' + '__SCHEMALOCATION__>\n' + '__REQUESTHEADER__\n' + '__REQUEST__\n' + '</XLS>\n',
            namespaceByDefault: function () {
                var ns = [
                    'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"',
                    'xmlns:xls="http://www.opengis.net/xls"',
                    'xmlns:gml="http://www.opengis.net/gml"'
                ];
                return ns.join(' ');
            },
            schemaLocationByDefault: function () {
                return 'xsi:schemaLocation="http://www.opengis.net/xls http://schemas.opengis.net/ols/1.2/olsAll.xsd"';
            },
            setService: function (oService) {
                if (!oService) {
                    return;
                }
                if (oService instanceof AbstractService) {
                    this.oService = oService;
                } else {
                }
            },
            getService: function () {
                return this.oService;
            }
        };
        XLS.prototype.addNamespace = function (ns, request) {
            var keyNS = ns.key;
            var bFound = false;
            var allNS = this.namespaceByDefault().split(' ');
            for (var index = 0; index < allNS.length; index++) {
                var element = allNS[index];
                var map = element.split('=');
                var key = map[0];
                if (key === 'xmlns:' + keyNS) {
                    bFound = true;
                    break;
                }
            }
            if (!bFound) {
                return request;
            }
            var regex;
            var subst;
            regex = /<(\w+[\s>])/g;
            subst = '<' + keyNS + ':$1';
            request = request.replace(regex, subst);
            regex = /<\/(\w+[\s>])/g;
            subst = '</' + keyNS + ':$1';
            request = request.replace(regex, subst);
            return request;
        };
        XLS.prototype.build = function () {
            var bService = this.getService() ? true : false;
            var template = '';
            template = this.template;
            template = template.replace(/__VERSION__/g, XLS.VERSION);
            template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);
            template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);
            var oHeader = new RequestHeader({ srsName: this.options.srsName });
            template = template.replace(/__REQUESTHEADER__/g, oHeader.toString());
            var oRequest = new Request({
                maximumResponses: this.options.maximumResponses,
                version: XLS.VERSION,
                methodName: bService ? this.getService().CLASSTYPE : null
            });
            template = template.replace(/__REQUEST__/g, oRequest.toString());
            if (bService) {
                template = template.replace(/<!-- __REQUESTSERVICE__ -->/g, this.getService().toString());
            }
            if (!template) {
                return;
            }
            if (this.namespace) {
                template = this.addNamespace({
                    key: 'xls',
                    url: 'http://www.opengis.net/xls'
                }, template);
            }
            this.requestString = template;
            return this.requestString;
        };
        return XLS;
    }(UtilsLoggerByDefault, FormatsXLSRequestHeader, FormatsXLSRequest, FormatsXLSAbstractService);
    FormatsXLSLocationUtilityServiceModelAddress = function (Gp, Logger) {
        function Address(options) {
            if (!(this instanceof Address)) {
                throw new TypeError('Address constructor cannot be called as a function.');
            }
            this.options = options || {
                location: {},
                type: ['StreetAddress'],
                filter: {}
            };
            if (!options.location) {
                throw new Error('l\'option \'location\' n\'est pas renseigne !');
            }
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
        }
        Address.prototype = {
            constructor: Address,
            requestString: null,
            template: {
                address: '<Address countryCode="__COUNTRYCODE__">' + '__LOCATION__' + '__PLACE__' + '__POSTALCODE__' + '__ENVELOPE__' + '</Address>',
                location: {
                    freeFormAddress: '<freeFormAddress>__FREEFORMADDRESSVALUE__</freeFormAddress>',
                    streetAddress: {
                        container: '<StreetAddress>' + '__STREET__' + '__BUILDING__' + '</StreetAddress>',
                        building: '<Building number="__BUILDINGVALUE__"/>',
                        street: '<Street>__STREETVALUE__</Street>'
                    }
                },
                place: '<Place type="__PLACETYPE__">__PLACEVALUE__</Place>',
                postalCode: '<PostalCode>__POSTALCODEVALUE__</PostalCode>',
                envelope: '<gml:Envelope>' + '<gml:lowerCorner>__LEFT__ __BOTTOM__</gml:lowerCorner>' + '<gml:upperCorner>__RIGHT__ __TOP__</gml:upperCorner>' + '</gml:Envelope>'
            }
        };
        Address.prototype.toString = function () {
            var template = null;
            template = this.template.address;
            template = template.replace(/__COUNTRYCODE__/g, this.options.type);
            if (typeof this.options.location === 'string') {
                var tmplFreeFormAddress = this.template.location.freeFormAddress;
                tmplFreeFormAddress = tmplFreeFormAddress.replace(/__FREEFORMADDRESSVALUE__/g, this.options.location);
                template = template.replace(/__LOCATION__/g, tmplFreeFormAddress);
            } else {
                var tmplBuilding = '';
                var tmplStreet = '';
                if (this.options.location.number) {
                    tmplBuilding = this.template.location.streetAddress.building;
                    tmplBuilding = tmplBuilding.replace(/__BUILDINGVALUE__/g, this.options.location.number);
                }
                if (this.options.location.street) {
                    tmplStreet = this.template.location.streetAddress.street;
                    tmplStreet = tmplStreet.replace(/__STREETVALUE__/g, this.options.location.street);
                }
                var tmplStreetAddress = this.template.location.streetAddress.container;
                tmplStreetAddress = tmplStreetAddress.replace(/__STREET__/g, tmplStreet);
                tmplStreetAddress = tmplStreetAddress.replace(/__BUILDING__/g, tmplBuilding);
                template = template.replace(/__LOCATION__/g, tmplStreetAddress);
            }
            var tmplPostalCode = '';
            if (this.options.location.postalCode) {
                tmplPostalCode = this.template.postalCode;
                tmplPostalCode = tmplPostalCode.replace(/__POSTALCODEVALUE__/g, this.options.location.postalCode);
            }
            var tmplEnvelope = '';
            if (this.options.filter) {
                var bbox = this.options.filter.bbox;
                if (bbox) {
                    tmplEnvelope = this.template.envelope;
                    tmplEnvelope = tmplEnvelope.replace(/__LEFT__/g, bbox.left);
                    tmplEnvelope = tmplEnvelope.replace(/__BOTTOM__/g, bbox.bottom);
                    tmplEnvelope = tmplEnvelope.replace(/__RIGHT__/g, bbox.right);
                    tmplEnvelope = tmplEnvelope.replace(/__TOP__/g, bbox.top);
                }
            }
            var Places = [];
            var tmplPlace = '';
            if (this.options.filter) {
                var filters = this.options.filter;
                for (var filter in filters) {
                    if (filter === 'bbox') {
                        continue;
                    }
                    tmplPlace = this.template.place;
                    tmplPlace = tmplPlace.replace(/__PLACETYPE__/g, filter);
                    tmplPlace = tmplPlace.replace(/__PLACEVALUE__/g, filters[filter]);
                    Places.push(tmplPlace);
                }
            }
            var tmplPlaceCity = '';
            if (this.options.location.city) {
                tmplPlaceCity = this.template.place;
                tmplPlaceCity = tmplPlaceCity.replace(/__PLACETYPE__/g, 'Municipality');
                tmplPlaceCity = tmplPlaceCity.replace(/__PLACEVALUE__/g, this.options.location.city);
                Places.push(tmplPlaceCity);
            }
            template = template.replace(/__POSTALCODE__/g, tmplPostalCode);
            template = template.replace(/__PLACE__/g, Places.join('\n'));
            template = template.replace(/__ENVELOPE__/g, tmplEnvelope);
            this.requestString = template;
            return this.requestString;
        };
        return Address;
    }(Gp, UtilsLoggerByDefault);
    FormatsXLSLocationUtilityServiceGeocodeFilterExtension = function (Logger) {
        function GeocodeFilterExtension() {
            if (!(this instanceof GeocodeFilterExtension)) {
                throw new TypeError('GeocodeFilterExtension constructor cannot be called as a function.');
            }
            this.filters = [];
        }
        GeocodeFilterExtension.prototype = {
            constructor: GeocodeFilterExtension,
            addFilterExtensions: function (oGeocodeLocation) {
                if (oGeocodeLocation) {
                    this.filters.push(oGeocodeLocation);
                }
            },
            getNames: function () {
                var names = [];
                for (var idx in this.filters) {
                    names.push(this.filters[idx].CLASSNAME);
                }
                return names;
            },
            getFilter: function (name) {
                var filter = null;
                for (var idx in this.filters) {
                    if (this.filters[idx].CLASSNAME == name) {
                        filter = this.filters[idx];
                    }
                }
                return filter;
            },
            getFilters: function () {
                return this.filters;
            },
            getAttributs: function (name) {
                var attributs = [];
                for (var idx in this.filters) {
                    if (this.filters[idx].CLASSNAME == name) {
                        attributs = this.filters[idx].attributesList;
                    }
                }
                return attributs;
            },
            setPlaceAttributs: function (name, options) {
                var filter = this.getFilter(name);
                var attributs = this.getAttributs(name);
                for (var idx in attributs) {
                    var value = attributs[idx];
                    if (options[value]) {
                        filter.placeAttributes[value] = options[value];
                    }
                }
            },
            getPlaceAttributs: function (name) {
                var places = {};
                for (var idx in this.filters) {
                    if (this.filters[idx].CLASSNAME == name) {
                        places = this.filters[idx].placeAttributes;
                    }
                }
                return places;
            }
        };
        return GeocodeFilterExtension;
    }(UtilsLoggerByDefault);
    FormatsXLSLocationUtilityServiceGeocodeRequest = function (Logger, Address, GeocodeFilterExtension) {
        function GeocodeRequest(options) {
            if (!(this instanceof GeocodeRequest)) {
                throw new TypeError('GeocodeRequest constructor cannot be called as a function.');
            }
            this.options = options || {};
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
            this.CLASSNAME = 'GeocodeRequest';
        }
        GeocodeRequest.prototype = {
            strRequest: null,
            oAddress: null,
            oFilter: null,
            template: '<GeocodeRequest returnFreeForm="__RETURNFREEFORM__">' + '__ADDRESS__' + '</GeocodeRequest>',
            addAddress: function (oAddress) {
                if (oAddress instanceof Address) {
                    this.oAddress = oAddress;
                }
            },
            addFilter: function (oFilter) {
                if (oFilter instanceof GeocodeFilterExtension) {
                    this.oFilter = oFilter;
                }
            },
            constructor: GeocodeRequest,
            toString: function () {
                var template = '';
                template = this.template;
                if (!this.oAddress) {
                    var settings = {};
                    settings.location = this.options.location;
                    settings.type = this.options.filterOptions.type || ['StreetAddress'];
                    settings.filter = this.options.filterOptions;
                    delete settings.filter.type;
                    if (this.oFilter) {
                        settings.filter = {};
                        for (var idx in settings.type) {
                            var filter = settings.type[idx];
                            var oFilter = this.oFilter.getFilter(filter);
                            if (!oFilter) {
                                continue;
                            }
                            var mFilter = this.options.filterOptions;
                            var attributs = oFilter.attributesList;
                            for (var idxe = 0; idxe < attributs.length; idxe++) {
                                var key = attributs[idxe];
                                if (mFilter[key]) {
                                    var matchingKey = oFilter.serviceAttributes[idxe];
                                    oFilter.placeAttributes[matchingKey] = mFilter[key];
                                }
                            }
                            var places = oFilter.placeAttributes;
                            for (var kplace in places) {
                                if (places.hasOwnProperty(kplace)) {
                                    settings.filter[kplace] = places[kplace];
                                }
                            }
                        }
                    }
                    this.oAddress = new Address(settings);
                    if (!this.oAddress) {
                        throw new Error('La construction de l\'adresse n\'est pas correctement definie !?');
                    }
                }
                template = template.replace(/__ADDRESS__/g, this.oAddress.toString());
                template = template.replace(/__RETURNFREEFORM__/g, this.options.returnFreeForm ? 'true' : 'false');
                this.strRequest = template;
                return this.strRequest;
            }
        };
        return GeocodeRequest;
    }(UtilsLoggerByDefault, FormatsXLSLocationUtilityServiceModelAddress, FormatsXLSLocationUtilityServiceGeocodeFilterExtension);
    FormatsXLSLocationUtilityServiceModelPosition = function (Logger) {
        function Position(options) {
            if (!(this instanceof Position)) {
                throw new TypeError('Position constructor cannot be called as a function.');
            }
            this.options = options || {};
            if (!options.position) {
                throw new Error('l\'option \'position\' n\'est pas renseigne !');
            }
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
        }
        Position.prototype = {
            constructor: Position,
            requestString: null,
            template: {
                position: '<Position>' + '__GMLPOINT__' + '__GMLFILTER__' + '</Position>',
                gml: {
                    point: '<gml:Point xmlns:gml="http://www.opengis.net/gml"><gml:pos>__X__ __Y__</gml:pos></gml:Point>',
                    pos: null,
                    filter: {
                        bbox: '<gml:Envelope xmlns:gml="http://www.opengis.net/gml">' + '<gml:lowerCorner>__LEFT__ __BOTTOM__</gml:lowerCorner>' + '<gml:upperCorner>__RIGHT__ __TOP__</gml:upperCorner>' + '</gml:Envelope>',
                        circle: '<gml:CircleByCenterPoint xmlns:gml="http://www.opengis.net/gml"><gml:pos>__X__ __Y__</gml:pos><gml:radius>__RADIUS__</gml:radius></gml:CircleByCenterPoint>',
                        polygon: '<gml:Polygon xmlns:gml="http://www.opengis.net/gml"><gml:exterior><gml:LinearRing><gml:posList>__XY__</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>',
                        multipolygon: null
                    }
                }
            }
        };
        Position.prototype.toString = function () {
            var template = this.template.position;
            var tmplGmlPoint = this.template.gml.point;
            tmplGmlPoint = tmplGmlPoint.replace(/__X__/g, this.options.position.x);
            tmplGmlPoint = tmplGmlPoint.replace(/__Y__/g, this.options.position.y);
            var tmplGmlFilter = '';
            if (this.options.filter) {
                var filter = this.options.filter;
                for (var name in filter) {
                    switch (name) {
                    case 'circle':
                        tmplGmlFilter = this.template.gml.filter[name];
                        tmplGmlFilter = tmplGmlFilter.replace(/__X__/g, filter[name].x);
                        tmplGmlFilter = tmplGmlFilter.replace(/__Y__/g, filter[name].y);
                        tmplGmlFilter = tmplGmlFilter.replace(/__RADIUS__/g, filter[name].radius);
                        break;
                    case 'bbox':
                        tmplGmlFilter = this.template.gml.filter[name];
                        tmplGmlFilter = tmplGmlFilter.replace(/__LEFT__/g, filter[name].left);
                        tmplGmlFilter = tmplGmlFilter.replace(/__BOTTOM__/g, filter[name].bottom);
                        tmplGmlFilter = tmplGmlFilter.replace(/__RIGHT__/g, filter[name].right);
                        tmplGmlFilter = tmplGmlFilter.replace(/__TOP__/g, filter[name].top);
                        break;
                    case 'polygon':
                        tmplGmlFilter = this.template.gml.filter[name];
                        var strPoints = '';
                        var lstPoints = filter[name];
                        for (var i = 0; i < lstPoints.length; i++) {
                            var coord = lstPoints[i];
                            if (Array.isArray(coord)) {
                                break;
                            }
                            if (coord.x && coord.y || (coord.x === 0 || coord.y === 0)) {
                                strPoints += coord.x + ' ' + coord.y;
                            }
                            if (lstPoints.length !== i + 1) {
                                strPoints += ' ';
                            }
                        }
                        tmplGmlFilter = tmplGmlFilter.replace(/__XY__/g, strPoints);
                        break;
                    case 'multipolygon':
                        break;
                    default:
                    }
                }
            }
            template = template.replace(/__GMLPOINT__/g, tmplGmlPoint);
            template = template.replace(/__GMLFILTER__/g, tmplGmlFilter);
            this.requestString = template;
            return this.requestString;
        };
        return Position;
    }(UtilsLoggerByDefault);
    FormatsXLSLocationUtilityServiceModelPreference = function (Logger) {
        function Preference(type) {
            if (!(this instanceof Preference)) {
                throw new TypeError('Preference constructor cannot be called as a function.');
            }
            this.type = type;
        }
        Preference.prototype = {
            constructor: Preference,
            requestString: null,
            template: '<ReverseGeocodePreference>__TYPE__</ReverseGeocodePreference>'
        };
        Preference.prototype.toString = function () {
            var Preferences = [];
            var tmplPreference = '';
            for (var idx = 0; idx < this.type.length; idx++) {
                tmplPreference = this.template;
                tmplPreference = tmplPreference.replace(/__TYPE__/g, this.type[idx]);
                Preferences.push(tmplPreference);
            }
            this.strRequest = Preferences.join('\n');
            return this.strRequest;
        };
        return Preference;
    }(UtilsLoggerByDefault);
    FormatsXLSLocationUtilityServiceReverseGeocodeRequest = function (Logger, Position, Preference) {
        function ReverseGeocodeRequest(options) {
            if (!(this instanceof ReverseGeocodeRequest)) {
                throw new TypeError('ReverseGeocodeRequest constructor cannot be called as a function.');
            }
            this.options = options || {};
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
            this.CLASSNAME = 'ReverseGeocodeRequest';
        }
        ReverseGeocodeRequest.prototype = {
            strRequest: null,
            oPosition: null,
            oPreference: null,
            constructor: ReverseGeocodeRequest,
            template: '<ReverseGeocodeRequest returnFreeForm="__RETURNFREEFORM__">' + '__POSITION__' + '__PREFERENCE__' + '</ReverseGeocodeRequest>',
            addPosition: function (oPosition) {
                if (oPosition instanceof Position) {
                    this.oPosition = oPosition;
                }
            },
            addPreferences: function (oPreference) {
                if (oPreference instanceof Preference) {
                    this.oPreference = oPreference;
                }
            },
            toString: function () {
                var template = '';
                template = this.template;
                if (!this.oPreference) {
                    this.oPreference = new Preference(this.options.filterOptions.type || ['StreetAddress']);
                    if (!this.oPreference) {
                        throw new Error('Les preferences ne sont pas definies !?');
                    }
                }
                template = template.replace(/__PREFERENCE__/g, this.oPreference.toString());
                if (!this.oPosition) {
                    var settings = {
                        position: this.options.position,
                        filter: {}
                    };
                    if (this.options.filterOptions) {
                        settings.filter = this.options.filterOptions;
                        delete settings.filter.type;
                    }
                    this.oPosition = new Position(settings);
                    if (!this.oPosition) {
                        throw new Error('La position et ses filtres ne sont pas definis !?');
                    }
                }
                template = template.replace(/__POSITION__/g, this.oPosition.toString());
                template = template.replace(/__RETURNFREEFORM__/g, this.options.returnFreeForm ? 'true' : 'false');
                this.strRequest = template;
                return this.strRequest;
            }
        };
        return ReverseGeocodeRequest;
    }(UtilsLoggerByDefault, FormatsXLSLocationUtilityServiceModelPosition, FormatsXLSLocationUtilityServiceModelPreference);
    FormatsXLSLocationUtilityService = function (Logger, AbstractService, GeocodeRequest, ReverseGeocodeRequest, GeocodeFilterExtension) {
        function LocationUtilityService(options) {
            if (!(this instanceof LocationUtilityService)) {
                throw new TypeError('LocationUtilityService constructor cannot be called as a function.');
            }
            this.CLASSNAME = 'LocationUtilityService';
            this.CLASSTYPE = null;
            AbstractService.apply(this, arguments);
            if (this.options) {
                this.CLASSTYPE = this.options.location ? 'GeocodeRequest' : this.options.position ? 'ReverseGeocodeRequest' : null;
            }
        }
        LocationUtilityService.prototype = Object.create(AbstractService.prototype, {});
        LocationUtilityService.prototype.constructor = LocationUtilityService;
        LocationUtilityService.prototype.addRequest = function (oLUSRequest) {
            this.CLASSTYPE = oLUSRequest.CLASSNAME;
            switch (this.CLASSTYPE) {
            case 'GeocodeRequest':
            case 'ReverseGeocodeRequest':
                this.oRequest = oLUSRequest;
                break;
            default:
                throw new Error('Ce n\'est pas un objet de type \'LUS Request\' !?');
            }
        };
        LocationUtilityService.prototype.addFilter = function (oFilter) {
            if (oFilter instanceof GeocodeFilterExtension) {
                this.oFilter = oFilter;
            }
        };
        LocationUtilityService.prototype.toString = function () {
            if (!this.oRequest) {
                if (!this.options) {
                    throw new Error('Les options ne sont pas renseignes, impossible de construire la requte !');
                }
                if (this.CLASSTYPE === 'GeocodeRequest') {
                    var settingsDirect = {
                        location: this.options.location,
                        returnFreeForm: this.options.returnFreeForm,
                        filterOptions: this.options.filterOptions || {}
                    };
                    this.oRequest = new GeocodeRequest(settingsDirect);
                    if (this.oFilter) {
                        this.oRequest.addFilter(this.oFilter);
                    }
                } else if (this.CLASSTYPE === 'ReverseGeocodeRequest') {
                    var settingsInv = {
                        position: this.options.position,
                        returnFreeForm: this.options.returnFreeForm,
                        filterOptions: this.options.filterOptions || {}
                    };
                    this.oRequest = new ReverseGeocodeRequest(settingsInv);
                } else {
                }
            }
            if (!this.oRequest) {
                throw new Error('Type de Geocodage indefini !');
            }
            this.strRequest = this.oRequest.toString();
            return this.strRequest;
        };
        return LocationUtilityService;
    }(UtilsLoggerByDefault, FormatsXLSAbstractService, FormatsXLSLocationUtilityServiceGeocodeRequest, FormatsXLSLocationUtilityServiceReverseGeocodeRequest, FormatsXLSLocationUtilityServiceGeocodeFilterExtension);
    ServicesGeocodeRequestGeocodeLocation = function () {
        function GeocodeLocation() {
            if (!(this instanceof GeocodeLocation)) {
                throw new TypeError('GeocodeLocation constructor cannot be called as a function.');
            }
            this.placeAttributes = {};
            this.attributesList = [];
            this.serviceAttributes = [];
        }
        GeocodeLocation.prototype = { constructor: GeocodeLocation };
        return GeocodeLocation;
    }();
    ServicesGeocodeRequestModelStreetAddress = function (GeocodeLocation) {
        function StreetAddress() {
            if (!(this instanceof StreetAddress)) {
                throw new TypeError('StreetAddress constructor cannot be called as a function.');
            }
            GeocodeLocation.apply(this, arguments);
            this.CLASSNAME = 'StreetAddress';
            this.attributesList = [
                'bbox',
                'ID',
                'IDTR',
                'quality',
                'territory',
                'commune',
                'department',
                'insee',
                'municipality'
            ];
            this.serviceAttributes = [
                'bbox',
                'ID',
                'IDTR',
                'Qualite',
                'Territoire',
                'Commune',
                'Departement',
                'INSEE',
                'Municipality'
            ];
        }
        StreetAddress.prototype = Object.create(GeocodeLocation.prototype);
        StreetAddress.prototype.constructor = StreetAddress;
        return StreetAddress;
    }(ServicesGeocodeRequestGeocodeLocation);
    ServicesGeocodeRequestModelPositionOfInterest = function (GeocodeLocation) {
        function PositionOfInterest() {
            if (!(this instanceof PositionOfInterest)) {
                throw new TypeError('PositionOfInterest constructor cannot be called as a function.');
            }
            GeocodeLocation.apply(this, arguments);
            this.CLASSNAME = 'PositionOfInterest';
            this.attributesList = [
                'bbox',
                'importance',
                'nature',
                'territory',
                'commune',
                'department',
                'insee',
                'municipality'
            ];
            this.serviceAttributes = [
                'bbox',
                'Importance',
                'Nature',
                'Territoire',
                'Commune',
                'Departement',
                'INSEE',
                'Municipality'
            ];
        }
        PositionOfInterest.prototype = Object.create(GeocodeLocation.prototype);
        PositionOfInterest.prototype.constructor = PositionOfInterest;
        return PositionOfInterest;
    }(ServicesGeocodeRequestGeocodeLocation);
    ServicesGeocodeRequestModelCadastralParcel = function (GeocodeLocation) {
        function CadastralParcel() {
            if (!(this instanceof CadastralParcel)) {
                throw new TypeError('CadastralParcel constructor cannot be called as a function.');
            }
            GeocodeLocation.apply(this, arguments);
            this.CLASSNAME = 'CadastralParcel';
            this.attributesList = [
                'absorbedCity',
                'sheet',
                'number',
                'section',
                'commune',
                'department',
                'insee',
                'municipality',
                'origin'
            ];
            this.serviceAttributes = [
                'CommuneAbsorbee',
                'Feuille',
                'Numero',
                'Section',
                'Commune',
                'Departement',
                'INSEE',
                'Municipality',
                'Type'
            ];
        }
        CadastralParcel.prototype = Object.create(GeocodeLocation.prototype);
        CadastralParcel.prototype.constructor = CadastralParcel;
        return CadastralParcel;
    }(ServicesGeocodeRequestGeocodeLocation);
    ServicesGeocodeRequestModelAdministratif = function (GeocodeLocation) {
        function Administratif() {
            if (!(this instanceof Administratif)) {
                throw new TypeError('Administratif constructor cannot be called as a function.');
            }
            GeocodeLocation.apply(this, arguments);
            this.CLASSNAME = 'Administratif';
            this.attributesList = [
                'bbox',
                'prefecture',
                'inseeRegion',
                'inseeDepartment',
                'municipality'
            ];
            this.serviceAttributes = [
                'bbox',
                'Prefecture',
                'InseeRegion',
                'InseeDepartement',
                'Municipality'
            ];
        }
        Administratif.prototype = Object.create(GeocodeLocation.prototype);
        Administratif.prototype.constructor = Administratif;
        return Administratif;
    }(ServicesGeocodeRequestGeocodeLocation);
    ServicesGeocodeRequestDirectGeocodeRequestFactory = function (Logger, XLS, LocationUtilityService, GeocodeFilterExtension, StreetAddress, PositionOfInterest, CadastralParcel, Administratif) {
        var DirectGeocodeRequestFactory = {
            build: function (options) {
                var request = null;
                var oFilter = new GeocodeFilterExtension();
                oFilter.addFilterExtensions(new Administratif());
                oFilter.addFilterExtensions(new StreetAddress());
                oFilter.addFilterExtensions(new PositionOfInterest());
                oFilter.addFilterExtensions(new CadastralParcel());
                var oLUS = new LocationUtilityService({
                    location: options.location,
                    returnFreeForm: options.returnFreeForm,
                    filterOptions: options.filterOptions
                });
                oLUS.addFilter(oFilter);
                var oXLS = new XLS({
                    srsName: options.srs,
                    maximumResponses: options.maximumResponses
                });
                oXLS.namespace = true;
                oXLS.setService(oLUS);
                request = oXLS.build();
                if (options.httpMethod == 'GET') {
                    var myRequest = 'qxml=' + encodeURIComponent(request).replace(/\-/g, '%2D').replace(/\_/g, '%5F').replace(/\./g, '%2E').replace(/\!/g, '%21').replace(/\~/g, '%7E').replace(/\*/g, '%2A').replace(/\'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29');
                    request = myRequest;
                }
                return request;
            }
        };
        return DirectGeocodeRequestFactory;
    }(UtilsLoggerByDefault, FormatsXLS, FormatsXLSLocationUtilityService, FormatsXLSLocationUtilityServiceGeocodeFilterExtension, ServicesGeocodeRequestModelStreetAddress, ServicesGeocodeRequestModelPositionOfInterest, ServicesGeocodeRequestModelCadastralParcel, ServicesGeocodeRequestModelAdministratif);
    ServicesGeocodeResponseModelGeocodeResponse = function () {
        function GeocodeResponse() {
            if (!(this instanceof GeocodeResponse)) {
                throw new TypeError('GeocodeResponse constructor cannot be called as a function.');
            }
            this.locations = [];
        }
        GeocodeResponse.prototype = { constructor: GeocodeResponse };
        return GeocodeResponse;
    }();
    ServicesGeocodeResponseModelGeocodedLocation = function () {
        function GeocodedLocation() {
            if (!(this instanceof GeocodedLocation)) {
                throw new TypeError('GeocodedLocation constructor cannot be called as a function.');
            }
            this.position = {
                x: null,
                y: null
            };
            this.matchType = null;
            this.placeAttributes = {};
            this.type = null;
        }
        GeocodedLocation.prototype = { constructor: GeocodedLocation };
        return GeocodedLocation;
    }();
    ServicesGeocodeResponseModelDirectGeocodedLocation = function (GeocodedLocation) {
        function DirectGeocodedLocation() {
            if (!(this instanceof DirectGeocodedLocation)) {
                throw new TypeError('DirectGeocodedLocation constructor cannot be called as a function.');
            }
            GeocodedLocation.apply(this, arguments);
            this.CLASSNAME = 'DirectGeocodedLocation';
            this.accuracy = null;
        }
        DirectGeocodedLocation.prototype = Object.create(GeocodedLocation.prototype);
        DirectGeocodedLocation.prototype.constructor = DirectGeocodedLocation;
        return DirectGeocodedLocation;
    }(ServicesGeocodeResponseModelGeocodedLocation);
    ServicesGeocodeFormatsDirectGeocodeResponseReader = function (Logger, MR, ErrSrv, GeocodeResponse, DirectGeocodedLocation) {
        var DirectGeocodeResponseReader = {};
        DirectGeocodeResponseReader.VERSION = '1.2';
        DirectGeocodeResponseReader.NAMESPACES = {
            xmlns: 'http://www.opengis.net/xls',
            gml: 'http://www.opengis.net/gml',
            xls: 'http://www.opengis.net/xls',
            xlsext: 'http://www.opengis.net/xlsext',
            xsi: 'http://www.w3.org/2001/XMLSchema-instance'
        };
        DirectGeocodeResponseReader.SCHEMALOCATION = 'http://wxs.ign.fr/schemas/olsAll.xsd';
        DirectGeocodeResponseReader.DEFAULTPREFIX = 'xls';
        DirectGeocodeResponseReader.READERS = {
            xls: {
                XLS: function (root) {
                    var geocodeResponse = new GeocodeResponse();
                    __checkServiceAttributes(root);
                    __getChildNodes(root, geocodeResponse);
                    return geocodeResponse;
                },
                GeocodedAddress: function (node, geocodeResponse) {
                    var geocodedLocation = new DirectGeocodedLocation();
                    __getChildNodes(node, geocodedLocation);
                    if (geocodeResponse && Array.isArray(geocodeResponse.locations)) {
                        geocodeResponse.locations.push(geocodedLocation);
                    }
                },
                GeocodeMatchCode: function (node, geocodedLocation) {
                    var acc = node.getAttribute('accuracy');
                    if (acc && geocodedLocation) {
                        geocodedLocation.accuracy = parseFloat(acc);
                    }
                    var matchType = node.getAttribute('matchType');
                    if (matchType && geocodedLocation) {
                        geocodedLocation.matchType = matchType;
                    }
                },
                Address: function (node, geocodedLocation) {
                    var countrycode = node.getAttribute('countryCode');
                    if (geocodedLocation && countrycode) {
                        geocodedLocation.type = countrycode;
                    }
                    __getChildNodes(node, geocodedLocation);
                },
                freeFormAddress: function (node, geocodedLocation) {
                    if (geocodedLocation && geocodedLocation.hasOwnProperty('placeAttributes')) {
                        geocodedLocation.placeAttributes.freeform = __getChildValue(node);
                    }
                },
                Building: function (node, geocodedLocation) {
                    var num = node.getAttribute('number');
                    if (geocodedLocation && geocodedLocation.hasOwnProperty('placeAttributes')) {
                        if (num) {
                            geocodedLocation.placeAttributes.number = num;
                        } else if (node.getAttribute('buildingName')) {
                            geocodedLocation.placeAttributes.number = node.getAttribute('buildingName');
                        } else if (node.getAttribute('subdivision')) {
                            geocodedLocation.placeAttributes.number = node.getAttribute('subdivision');
                        }
                    }
                },
                Street: function (node, geocodedLocation) {
                    if (geocodedLocation && geocodedLocation.hasOwnProperty('placeAttributes')) {
                        if (geocodedLocation.type === 'StreetAddress') {
                            geocodedLocation.placeAttributes.street = __getChildValue(node);
                        } else if (geocodedLocation.type === 'CadastralParcel') {
                            geocodedLocation.placeAttributes.cadastralParcel = __getChildValue(node);
                        }
                    }
                },
                Place: function (node, geocodedLocation) {
                    var placeType = node.getAttribute('type');
                    var placeName = __getChildValue(node);
                    if (geocodedLocation && geocodedLocation.hasOwnProperty('placeAttributes')) {
                        if (placeType === 'Municipality') {
                            geocodedLocation.placeAttributes.municipality = placeName;
                        } else if (placeType === 'Bbox') {
                            var values = placeName.split(';');
                            if (values.length === 4) {
                                geocodedLocation.placeAttributes.bbox = {
                                    left: parseFloat(values[0]),
                                    right: parseFloat(values[2]),
                                    top: parseFloat(values[1]),
                                    bottom: parseFloat(values[3])
                                };
                            }
                        } else if (placeType === 'Commune') {
                            geocodedLocation.placeAttributes.commune = placeName;
                        } else if (placeType === 'Departement') {
                            geocodedLocation.placeAttributes.department = placeName;
                        } else if (placeType === 'INSEE') {
                            geocodedLocation.placeAttributes.insee = placeName;
                        } else if (placeType === 'Qualite') {
                            geocodedLocation.placeAttributes.quality = placeName;
                        } else if (placeType === 'Territoire') {
                            geocodedLocation.placeAttributes.territory = placeName;
                        } else if (placeType === 'ID') {
                            geocodedLocation.placeAttributes.ID = placeName;
                        } else if (placeType === 'ID_TR') {
                            geocodedLocation.placeAttributes.IDTR = placeName;
                        } else if (placeType === 'Importance') {
                            geocodedLocation.placeAttributes.importance = parseInt(placeName, 10);
                        } else if (placeType === 'Nature') {
                            geocodedLocation.placeAttributes.nature = placeName;
                        } else if (placeType === 'Numero') {
                            geocodedLocation.placeAttributes.number = placeName;
                        } else if (placeType === 'Feuille') {
                            geocodedLocation.placeAttributes.sheet = placeName;
                        } else if (placeType === 'Section') {
                            geocodedLocation.placeAttributes.section = placeName;
                        } else if (placeType === 'CommuneAbsorbee') {
                            geocodedLocation.placeAttributes.absorbedCity = placeName;
                        } else if (placeType === 'Arrondissement') {
                            if (placeName) {
                                geocodedLocation.placeAttributes.arrondissement = placeName;
                            }
                        } else if (placeType === 'Type') {
                            geocodedLocation.placeAttributes.origin = placeName;
                        } else if (placeType === 'Prefecture') {
                            geocodedLocation.placeAttributes.prefecture = placeName;
                        } else if (placeType === 'InseeRegion') {
                            geocodedLocation.placeAttributes.inseeRegion = placeName;
                        } else if (placeType === 'InseeDepartment') {
                            geocodedLocation.placeAttributes.inseeDepartment = placeName;
                        }
                    }
                },
                PostalCode: function (node, geocodedLocation) {
                    if (geocodedLocation && geocodedLocation.hasOwnProperty('placeAttributes')) {
                        geocodedLocation.placeAttributes.postalCode = __getChildValue(node);
                    }
                },
                Error: function (node) {
                    var srvMess = node.getAttribute('message');
                    var errorCode = node.getAttribute('errorCode');
                    var message = MR.getMessage('SERVICE_RESPONSE_EXCEPTION', '(' + errorCode + ') : ' + srvMess);
                    throw new ErrSrv({
                        message: message,
                        type: ErrSrv.TYPE_SRVERR
                    });
                }
            },
            gml: {
                pos: function (node, geocodedLocation) {
                    var pos = __getChildValue(node);
                    if (geocodedLocation && pos) {
                        geocodedLocation.position = {
                            x: parseFloat(pos.split(' ')[0]),
                            y: parseFloat(pos.split(' ')[1])
                        };
                    }
                }
            },
            ExceptionReport: function (node) {
                var response = {};
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (child.nodeName === 'Exception') {
                            response.exceptionReport = DirectGeocodeResponseReader.READERS['Exception'](child);
                        }
                    }
                }
                return response;
            },
            Exception: function (node) {
                var exceptionReport = {};
                var exceptionCode = node.getAttribute('exceptionCode');
                if (exceptionCode) {
                    exceptionReport.exceptionCode = exceptionCode;
                }
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    exceptionReport.exception = textNode.nodeValue;
                }
                return exceptionReport;
            }
        };
        DirectGeocodeResponseReader.read = function (root) {
            if (root.nodeName === 'XLS') {
                var nsPrefix = root.prefix;
                if (!nsPrefix) {
                    nsPrefix = DirectGeocodeResponseReader.DEFAULTPREFIX;
                }
                var geocodeResponse = DirectGeocodeResponseReader.READERS[nsPrefix][root.nodeName](root);
                return geocodeResponse;
            } else if (root.nodeName === 'ExceptionReport') {
                var exceptionReport = DirectGeocodeResponseReader.READERS[root.nodeName](root);
                return exceptionReport;
            } else {
                var mess = MR.getMessage('SERVICE_RESPONSE_ANALYSE', root.nodeName);
                throw new ErrSrv({
                    message: mess,
                    type: ErrSrv.TYPE_UNKERR,
                    status: 200
                });
            }
        };
        function __getAttributes(node) {
            if (node.attributes.length > 0) {
                var nodeAttributes = {};
                var attributes = node.attributes;
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    nodeAttributes[attribute.nodeName] = attribute.nodeValue;
                }
                return nodeAttributes;
            }
        }
        function __getChildNodes(node, data) {
            if (node.hasChildNodes()) {
                var children = node.childNodes;
                var child;
                var childName;
                var childPrefix;
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    if (child.nodeType === 1) {
                        childName = child.localName || child.baseName || child.nodeName;
                        childPrefix = child.prefix || DirectGeocodeResponseReader.DEFAULTPREFIX;
                        if (DirectGeocodeResponseReader.READERS[childPrefix][childName]) {
                            var reader = DirectGeocodeResponseReader.READERS[childPrefix][childName];
                            reader(child, data);
                        } else {
                            __getChildNodes(child, data);
                        }
                    }
                }
            }
        }
        function __getChildValue(node) {
            var textNode;
            var value = '';
            if (node.hasChildNodes()) {
                textNode = node.firstChild;
                if (textNode.nodeType === 3) {
                    value = textNode.nodeValue;
                }
            }
            return value;
        }
        function __checkServiceAttributes(XLSNode) {
            if (XLSNode.attributes.length > 0) {
                var xlsAttributes = __getAttributes(XLSNode);
                for (var att in xlsAttributes) {
                    if (xlsAttributes.hasOwnProperty(att)) {
                        if (att === 'version') {
                            if (xlsAttributes['version'] !== DirectGeocodeResponseReader.VERSION) {
                                console.log('[DirectGeocodeResponseReader] geocode version is not the expected one : there may be errors in parsing');
                                return;
                            }
                        }
                        if (att === 'xmlns') {
                            if (xlsAttributes[att] !== DirectGeocodeResponseReader.NAMESPACES[DirectGeocodeResponseReader.DEFAULTPREFIX]) {
                                console.log('[DirectGeocodeResponseReader] geocode response default namespace is not the expected one');
                                return;
                            }
                            continue;
                        }
                        var prefix = att.split(':')[0];
                        var ns = att.split(':')[1];
                        if (prefix === 'xmlns' && ns) {
                            if (DirectGeocodeResponseReader.NAMESPACES[ns]) {
                                if (DirectGeocodeResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {
                                    console.log('[DirectGeocodeResponseReader] geocode response ' + att + ' namespace is not the expected one');
                                    return;
                                }
                            }
                        }
                        if (ns === 'schemaLocation') {
                            if (DirectGeocodeResponseReader.SCHEMALOCATION !== xlsAttributes[att]) {
                                console.log('[DirectGeocodeResponseReader] geocode response schema location is not the expected one');
                                return;
                            }
                        }
                    }
                }
            }
        }
        return DirectGeocodeResponseReader;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, ServicesGeocodeResponseModelGeocodeResponse, ServicesGeocodeResponseModelDirectGeocodedLocation);
    ServicesGeocodeResponseDirectGeocodeResponseFactory = function (Logger, ErrorService, MRes, XML, DirectGeocodeResponseReader) {
        var DirectGeocodeReponseFactory = {
            build: function (options) {
                var data = null;
                if (options.response) {
                    if (options.rawResponse) {
                        data = options.response;
                    } else {
                        try {
                            var p = new XML({ reader: DirectGeocodeResponseReader });
                            if (typeof options.response === 'string') {
                                p.setXMLString(options.response);
                            } else {
                                p.setXMLDoc(options.response);
                            }
                            data = p.parse();
                            if (!data) {
                                throw new Error('L\'analyse de la rponse du service !?');
                            }
                        } catch (e) {
                            var message = e.message;
                            if (typeof options.response === 'string') {
                                message += '(\'' + options.response + '\')';
                            } else {
                                message += '(\'' + options.response.documentElement.innerHTML + '\')';
                            }
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_ANALYSE', message),
                                type: ErrorService.TYPE_UNKERR,
                                status: -1
                            }));
                            return;
                        }
                        if (data.exceptionReport) {
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', data.exceptionReport),
                                type: ErrorService.TYPE_SRVERR,
                                status: 200
                            }));
                            return;
                        }
                    }
                } else {
                    options.onError.call(options.scope, new ErrorService({
                        message: MRes.getMessage('SERVICE_RESPONSE_EMPTY'),
                        type: ErrorService.TYPE_SRVERR,
                        status: -1
                    }));
                    return;
                }
                options.onSuccess.call(options.scope, data);
                return;
            }
        };
        return DirectGeocodeReponseFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, UtilsMessagesResources, FormatsXML, ServicesGeocodeFormatsDirectGeocodeResponseReader);
    ServicesGeocodeGeocode = function (Logger, _, ErrorService, CommonService, DirectGeocodeRequestFactory, DirectGeocodeResponseFactory) {
        function Geocode(options) {
            if (!(this instanceof Geocode)) {
                throw new TypeError(_.getMessage('CLASS_CONSTRUCTOR', 'Geocode'));
            }
            this.CLASSNAME = 'Geocode';
            CommonService.apply(this, arguments);
            if (!options.location) {
                throw new Error(_.getMessage('PARAM_MISSING', 'location'));
            }
            if (typeof options.location === 'object' && Object.keys(options.location).length === 0) {
                throw new Error(_.getMessage('PARAM_EMPTY', 'location'));
            } else if (typeof options.location === 'string' && options.location.length === 0) {
                throw new Error(_.getMessage('PARAM_EMPTY', 'location'));
            }
            this.options.location = options.location;
            if (!options.filterOptions || typeof options.filterOptions !== 'object') {
                this.options.filterOptions = options.filterOptions = { type: ['StreetAddress'] };
            }
            if (Object.keys(options.filterOptions).length === 0) {
                this.options.filterOptions = { type: ['StreetAddress'] };
            }
            var filter = Object.keys(options.filterOptions);
            for (var i = 0; i < filter.length; i++) {
                var key = filter[i];
                var filtersCouldBeNumberList = [
                    'department',
                    'number',
                    'postalCode',
                    'insee',
                    'importance',
                    'ID',
                    'IDTR',
                    'absorbedCity',
                    'sheet',
                    'section',
                    'inseeRegion',
                    'inseeDepartment'
                ];
                if (filtersCouldBeNumberList.indexOf(key) !== -1 && typeof options.filterOptions[key] !== 'string') {
                    options.filterOptions[key] = options.filterOptions[key].toString();
                }
                if (!options.filterOptions[key]) {
                    delete this.options.filterOptions[key];
                }
            }
            this.options.filterOptions.type = options.filterOptions.type || ['StreetAddress'];
            this.options.maximumResponses = options.maximumResponses || 25;
            this.options.returnFreeForm = options.returnFreeForm || false;
            this.options.srs = options.srs || 'EPSG:4326';
            this.options.outputFormat = this.options.rawResponse ? '' : 'xml';
        }
        Geocode.prototype = Object.create(CommonService.prototype, {});
        Geocode.prototype.constructor = Geocode;
        Geocode.prototype.buildRequest = function (error, success) {
            var options = {
                httpMethod: this.options.httpMethod,
                location: this.options.location,
                returnFreeForm: this.options.returnFreeForm,
                filterOptions: this.options.filterOptions,
                srs: this.options.srs,
                maximumResponses: this.options.maximumResponses
            };
            this.request = DirectGeocodeRequestFactory.build(options);
            if (!this.request) {
                error.call(this, new ErrorService(_.getMessage('SERVICE_REQUEST_BUILD')));
            } else {
                success.call(this, this.request);
            }
        };
        Geocode.prototype.analyzeResponse = function (error, success) {
            if (this.response) {
                var options = {
                    response: this.response,
                    rawResponse: this.options.rawResponse,
                    onError: error,
                    onSuccess: success,
                    scope: this
                };
                DirectGeocodeResponseFactory.build(options);
            } else {
                error.call(this, new ErrorService(_.getMessage('SERVICE_RESPONSE_EMPTY')));
            }
        };
        return Geocode;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, ServicesCommonService, ServicesGeocodeRequestDirectGeocodeRequestFactory, ServicesGeocodeResponseDirectGeocodeResponseFactory);
    ServicesGeocodeRequestReverseGeocodeRequestFactory = function (Logger, XLS, LocationUtilityService) {
        var ReverseGeocodeRequestFactory = {
            build: function (options) {
                var settings = options || {};
                var request = null;
                var oLUS = new LocationUtilityService({
                    position: settings.position,
                    returnFreeForm: settings.returnFreeForm,
                    filterOptions: settings.filterOptions
                });
                var oXLS = new XLS({
                    srsName: settings.srs,
                    maximumResponses: settings.maximumResponses
                });
                oXLS.namespace = true;
                oXLS.setService(oLUS);
                request = oXLS.build();
                if (settings.httpMethod == 'GET') {
                    var myRequest = 'qxml=' + encodeURIComponent(request).replace(/\-/g, '%2D').replace(/\_/g, '%5F').replace(/\./g, '%2E').replace(/\!/g, '%21').replace(/\~/g, '%7E').replace(/\*/g, '%2A').replace(/\'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29');
                    request = myRequest;
                }
                return request;
            }
        };
        return ReverseGeocodeRequestFactory;
    }(UtilsLoggerByDefault, FormatsXLS, FormatsXLSLocationUtilityService);
    ServicesGeocodeResponseModelReverseGeocodedLocation = function (GeocodedLocation) {
        function ReverseGeocodedLocation() {
            if (!(this instanceof ReverseGeocodedLocation)) {
                throw new TypeError('ReverseGeocodedLocation constructor cannot be called as a function.');
            }
            GeocodedLocation.apply(this, arguments);
            this.CLASSNAME = 'ReverseGeocodedLocation';
            this.searchCenterDistance = null;
        }
        ReverseGeocodedLocation.prototype = Object.create(GeocodedLocation.prototype);
        ReverseGeocodedLocation.prototype.constructor = ReverseGeocodedLocation;
        return ReverseGeocodedLocation;
    }(ServicesGeocodeResponseModelGeocodedLocation);
    ServicesGeocodeFormatsReverseGeocodeResponseReader = function (Logger, MR, ErrSrv, ReverseGeocodeResponse, ReverseGeocodedLocation) {
        var ReverseGeocodeResponseReader = {};
        ReverseGeocodeResponseReader.VERSION = '1.2';
        ReverseGeocodeResponseReader.NAMESPACES = {
            xmlns: 'http://www.opengis.net/xls',
            gml: 'http://www.opengis.net/gml',
            xls: 'http://www.opengis.net/xls',
            xlsext: 'http://www.opengis.net/xlsext',
            xsi: 'http://www.w3.org/2001/XMLSchema-instance'
        };
        ReverseGeocodeResponseReader.SCHEMALOCATION = 'http://wxs.ign.fr/schemas/olsAll.xsd';
        ReverseGeocodeResponseReader.DEFAULTPREFIX = 'xls';
        ReverseGeocodeResponseReader.READERS = {
            xls: {
                XLS: function (root) {
                    var reverseGeocodeResponse = new ReverseGeocodeResponse();
                    __checkServiceAttributes(root);
                    __getChildNodes(root, reverseGeocodeResponse);
                    return reverseGeocodeResponse;
                },
                ReverseGeocodedLocation: function (node, reverseGeocodeResponse) {
                    var reverseGeocodedLocation = new ReverseGeocodedLocation();
                    __getChildNodes(node, reverseGeocodedLocation);
                    if (reverseGeocodeResponse && Array.isArray(reverseGeocodeResponse.locations)) {
                        reverseGeocodeResponse.locations.push(reverseGeocodedLocation);
                    }
                },
                Address: function (node, reverseGeocodedLocation) {
                    var countrycode = node.getAttribute('countryCode');
                    if (reverseGeocodedLocation && countrycode) {
                        reverseGeocodedLocation.type = countrycode;
                    }
                    __getChildNodes(node, reverseGeocodedLocation);
                },
                Building: function (node, reverseGeocodedLocation) {
                    var num = node.getAttribute('number');
                    if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty('placeAttributes')) {
                        if (num) {
                            reverseGeocodedLocation.placeAttributes.number = num;
                        } else if (node.getAttribute('buildingName')) {
                            reverseGeocodedLocation.placeAttributes.number = node.getAttribute('buildingName');
                        } else if (node.getAttribute('subdivision')) {
                            reverseGeocodedLocation.placeAttributes.number = node.getAttribute('subdivision');
                        }
                    }
                },
                Street: function (node, reverseGeocodedLocation) {
                    if (reverseGeocodedLocation.type === 'StreetAddress') {
                        reverseGeocodedLocation.placeAttributes.street = __getChildValue(node);
                    } else if (reverseGeocodedLocation.type === 'CadastralParcel') {
                        reverseGeocodedLocation.placeAttributes.cadastralParcel = __getChildValue(node);
                    }
                },
                Place: function (node, reverseGeocodedLocation) {
                    var placeType = node.getAttribute('type');
                    var placeName = __getChildValue(node);
                    if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty('placeAttributes')) {
                        if (placeType === 'Municipality') {
                            reverseGeocodedLocation.placeAttributes.municipality = placeName;
                        } else if (placeType === 'Bbox') {
                            var values = placeName.split(';');
                            if (values.length === 4) {
                                reverseGeocodedLocation.placeAttributes.bbox = {
                                    left: parseFloat(values[0]),
                                    right: parseFloat(values[2]),
                                    top: parseFloat(values[1]),
                                    bottom: parseFloat(values[3])
                                };
                            }
                        } else if (placeType === 'Commune') {
                            reverseGeocodedLocation.placeAttributes.commune = placeName;
                        } else if (placeType === 'Departement') {
                            reverseGeocodedLocation.placeAttributes.department = placeName;
                        } else if (placeType === 'INSEE') {
                            reverseGeocodedLocation.placeAttributes.insee = placeName;
                        } else if (placeType === 'Qualite') {
                            reverseGeocodedLocation.placeAttributes.quality = placeName;
                        } else if (placeType === 'Territoire') {
                            reverseGeocodedLocation.placeAttributes.territory = placeName;
                        } else if (placeType === 'ID') {
                            reverseGeocodedLocation.placeAttributes.ID = placeName;
                        } else if (placeType === 'ID_TR') {
                            reverseGeocodedLocation.placeAttributes.IDTR = placeName;
                        } else if (placeType === 'Importance') {
                            reverseGeocodedLocation.placeAttributes.importance = parseInt(placeName, 10);
                        } else if (placeType === 'Nature') {
                            reverseGeocodedLocation.placeAttributes.nature = placeName;
                        } else if (placeType === 'Numero') {
                            reverseGeocodedLocation.placeAttributes.number = placeName;
                        } else if (placeType === 'Feuille') {
                            reverseGeocodedLocation.placeAttributes.sheet = placeName;
                        } else if (placeType === 'Section') {
                            reverseGeocodedLocation.placeAttributes.section = placeName;
                        } else if (placeType === 'CommuneAbsorbee') {
                            reverseGeocodedLocation.placeAttributes.absorbedCity = placeName;
                        } else if (placeType === 'Arrondissement') {
                            if (placeName) {
                                reverseGeocodedLocation.placeAttributes.arrondissement = placeName;
                            }
                        } else if (placeType === 'Type') {
                            reverseGeocodedLocation.placeAttributes.origin = placeName;
                        } else if (placeType === 'Prefecture') {
                            reverseGeocodedLocation.placeAttributes.prefecture = placeName;
                        } else if (placeType === 'InseeRegion') {
                            reverseGeocodedLocation.placeAttributes.inseeRegion = placeName;
                        } else if (placeType === 'InseeDepartment') {
                            reverseGeocodedLocation.placeAttributes.inseeDepartment = placeName;
                        }
                    }
                },
                PostalCode: function (node, reverseGeocodedLocation) {
                    if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty('placeAttributes')) {
                        reverseGeocodedLocation.placeAttributes.postalCode = __getChildValue(node);
                    }
                },
                SearchCentreDistance: function (node, reverseGeocodedLocation) {
                    if (reverseGeocodedLocation) {
                        reverseGeocodedLocation.searchCenterDistance = parseFloat(node.getAttribute('value'));
                    }
                },
                Error: function (node) {
                    var srvMess = node.getAttribute('message');
                    var errorCode = node.getAttribute('errorCode');
                    var message = MR.getMessage('SERVICE_RESPONSE_EXCEPTION', '(' + errorCode + ') : ' + srvMess);
                    throw new ErrSrv({
                        message: message,
                        type: ErrSrv.TYPE_SRVERR
                    });
                }
            },
            gml: {
                pos: function (node, reverseGeocodedLocation) {
                    var pos = __getChildValue(node);
                    if (reverseGeocodedLocation && pos) {
                        reverseGeocodedLocation.position = {
                            x: parseFloat(pos.split(' ')[0]),
                            y: parseFloat(pos.split(' ')[1])
                        };
                    }
                }
            },
            xlsext: {
                ExtendedGeocodeMatchCode: function (node, reverseGeocodedLocation) {
                    if (reverseGeocodedLocation) {
                        reverseGeocodedLocation.matchType = __getChildValue(node);
                    }
                }
            },
            ExceptionReport: function (node) {
                var response = {};
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (child.nodeName === 'Exception') {
                            response.exceptionReport = ReverseGeocodeResponseReader.READERS['Exception'](child);
                        }
                    }
                }
                return response;
            },
            Exception: function (node) {
                var exceptionReport = {};
                var exceptionCode = node.getAttribute('exceptionCode');
                if (exceptionCode) {
                    exceptionReport.exceptionCode = exceptionCode;
                }
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    exceptionReport.exception = textNode.nodeValue;
                }
                return exceptionReport;
            }
        };
        ReverseGeocodeResponseReader.read = function (root) {
            if (root.nodeName === 'XLS') {
                var nsPrefix = root.prefix;
                if (!nsPrefix) {
                    nsPrefix = ReverseGeocodeResponseReader.DEFAULTPREFIX;
                }
                var geocodeResponse = ReverseGeocodeResponseReader.READERS[nsPrefix][root.nodeName](root);
                return geocodeResponse;
            } else if (root.nodeName === 'ExceptionReport') {
                var exceptionReport = ReverseGeocodeResponseReader.READERS[root.nodeName](root);
                return exceptionReport;
            } else {
                throw new Error('Erreur lors de la lecture de la rponse : elle n\'est pas au format attendu.');
            }
        };
        function __getAttributes(node) {
            if (node.attributes.length > 0) {
                var nodeAttributes = {};
                var attributes = node.attributes;
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    nodeAttributes[attribute.nodeName] = attribute.nodeValue;
                }
                return nodeAttributes;
            }
        }
        function __getChildNodes(node, data) {
            if (node.hasChildNodes()) {
                var children = node.childNodes;
                var child;
                var childName;
                var childPrefix;
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    if (child.nodeType === 1) {
                        childName = child.localName || child.baseName || child.nodeName;
                        childPrefix = child.prefix || ReverseGeocodeResponseReader.DEFAULTPREFIX;
                        if (ReverseGeocodeResponseReader.READERS[childPrefix][childName]) {
                            var reader = ReverseGeocodeResponseReader.READERS[childPrefix][childName];
                            reader(child, data);
                        } else {
                            __getChildNodes(child, data);
                        }
                    }
                }
            }
        }
        function __getChildValue(node) {
            var textNode;
            var value = '';
            if (node.hasChildNodes()) {
                textNode = node.firstChild;
                if (textNode.nodeType === 3) {
                    value = textNode.nodeValue;
                }
            }
            return value;
        }
        function __checkServiceAttributes(XLSNode) {
            if (XLSNode.attributes.length > 0) {
                var xlsAttributes = __getAttributes(XLSNode);
                for (var att in xlsAttributes) {
                    if (xlsAttributes.hasOwnProperty(att)) {
                        if (att === 'version') {
                            if (xlsAttributes['version'] !== ReverseGeocodeResponseReader.VERSION) {
                                console.log('[ReverseGeocodeResponseReader] geocode version is not the expected one : there may be errors in parsing');
                                return;
                            }
                        }
                        if (att === 'xmlns') {
                            if (xlsAttributes[att] !== ReverseGeocodeResponseReader.NAMESPACES[ReverseGeocodeResponseReader.DEFAULTPREFIX]) {
                                console.log('[ReverseGeocodeResponseReader] geocode response default namespace is not the expected one');
                                return;
                            }
                            continue;
                        }
                        var prefix = att.split(':')[0];
                        var ns = att.split(':')[1];
                        if (prefix === 'xmlns' && ns) {
                            if (ReverseGeocodeResponseReader.NAMESPACES[ns]) {
                                if (ReverseGeocodeResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {
                                    console.log('[ReverseGeocodeResponseReader] geocode response ' + att + ' namespace is not the expected one');
                                    return;
                                }
                            }
                        }
                        if (ns === 'schemaLocation') {
                            if (ReverseGeocodeResponseReader.SCHEMALOCATION !== xlsAttributes[att]) {
                                console.log('[ReverseGeocodeResponseReader] geocode response schema location is not the expected one');
                                return;
                            }
                        }
                    }
                }
            }
        }
        return ReverseGeocodeResponseReader;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, ServicesGeocodeResponseModelGeocodeResponse, ServicesGeocodeResponseModelReverseGeocodedLocation);
    ServicesGeocodeResponseReverseGeocodeResponseFactory = function (Logger, MRes, ErrorService, XML, ReverseGeocodeResponseReader) {
        var ReverseGeocodeReponseFactory = {
            build: function (options) {
                var data = null;
                if (options.response) {
                    if (options.rawResponse) {
                        data = options.response;
                    } else {
                        try {
                            var p = new XML({ reader: ReverseGeocodeResponseReader });
                            if (typeof options.response === 'string') {
                                p.setXMLString(options.response);
                            } else {
                                p.setXMLDoc(options.response);
                            }
                            data = p.parse();
                            if (!data) {
                                throw new Error('L\'analyse de la rponse du service !?');
                            }
                        } catch (e) {
                            e.status = 200;
                            options.onError.call(options.scope, e);
                            return;
                        }
                        if (data.exceptionReport) {
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', data.exceptionReport),
                                type: ErrorService.TYPE_SRVERR,
                                status: 200
                            }));
                            return;
                        }
                        if (options.scope && options.scope.options && options.scope.options.srs && options.scope.options.srs !== 'EPSG:4326') {
                            var location;
                            var pos;
                            if (data || data.locations || data.locations.length) {
                                for (var i = 0; i < data.locations.length; i++) {
                                    location = data.locations[i];
                                    if (location) {
                                        pos = location.position;
                                        if (pos) {
                                            location.position = {
                                                x: pos.y,
                                                y: pos.x
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    options.onError.call(options.scope, new ErrorService({
                        message: MRes.getMessage('SERVICE_RESPONSE_EMPTY'),
                        type: ErrorService.TYPE_SRVERR,
                        status: -1
                    }));
                    return;
                }
                options.onSuccess.call(options.scope, data);
                return;
            }
        };
        return ReverseGeocodeReponseFactory;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, FormatsXML, ServicesGeocodeFormatsReverseGeocodeResponseReader);
    ServicesGeocodeReverseGeocode = function (Logger, _, ErrorService, CommonService, ReverseGeocodeRequestFactory, ReverseGeocodeResponseFactory) {
        function ReverseGeocode(options) {
            if (!(this instanceof ReverseGeocode)) {
                throw new TypeError(_.getMessage('CLASS_CONSTRUCTOR', 'ReverseGeocode'));
            }
            this.CLASSNAME = 'ReverseGeocode';
            CommonService.apply(this, arguments);
            if (!options.position) {
                throw new Error(_.getMessage('PARAM_MISSING', 'position'));
            }
            if (options.position.x == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'position.x'));
            }
            if (options.position.y == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'position.y'));
            }
            this.options.position = options.position;
            if (!options.filterOptions || typeof options.filterOptions !== 'object') {
                this.options.filterOptions = options.filterOptions = { type: ['StreetAddress'] };
            }
            if (Object.keys(options.filterOptions).length === 0) {
                this.options.filterOptions = { type: ['StreetAddress'] };
            }
            var filter = Object.keys(options.filterOptions);
            for (var i = 0; i < filter.length; i++) {
                var key = filter[i];
                if (!options.filterOptions[key] || Object.keys(options.filterOptions[key]).length === 0) {
                    delete this.options.filterOptions[key];
                }
            }
            this.options.filterOptions.type = options.filterOptions.type || ['StreetAddress'];
            if (!Array.isArray(this.options.filterOptions.type)) {
                throw new Error(_.getMessage('PARAM_TYPE', 'filterOptions.type'));
            }
            this.options.maximumResponses = options.maximumResponses || 25;
            this.options.returnFreeForm = options.returnFreeForm || false;
            this.options.srs = options.srs || 'CRS:84';
            if (ReverseGeocode.geoEPSG.indexOf(this.options.srs) === -1) {
                this.options.position = {
                    x: this.options.position.y,
                    y: this.options.position.x
                };
                if (this.options.filterOptions && this.options.filterOptions.circle) {
                    var circle = this.options.filterOptions.circle;
                    this.options.filterOptions.circle = {
                        x: circle.y,
                        y: circle.x,
                        radius: circle.radius
                    };
                }
                if (this.options.filterOptions && this.options.filterOptions.polygon) {
                    var polygon = this.options.filterOptions.polygon;
                    for (i = 0; i < polygon.length; i++) {
                        var coords = polygon[i];
                        this.options.filterOptions.polygon[i] = {
                            x: coords.y,
                            y: coords.x
                        };
                    }
                }
            }
            this.options.outputFormat = this.options.rawResponse ? '' : 'xml';
        }
        ReverseGeocode.prototype = Object.create(CommonService.prototype, {});
        ReverseGeocode.prototype.constructor = ReverseGeocode;
        ReverseGeocode.prototype.buildRequest = function (error, success) {
            var options = {
                httpMethod: this.options.httpMethod,
                position: this.options.position,
                returnFreeForm: this.options.returnFreeForm,
                filterOptions: this.options.filterOptions,
                srs: 'EPSG:4326',
                maximumResponses: this.options.maximumResponses
            };
            this.request = ReverseGeocodeRequestFactory.build(options);
            if (!this.request) {
                error.call(this, new ErrorService(_.getMessage('SERVICE_REQUEST_BUILD')));
            } else {
                success.call(this, this.request);
            }
        };
        ReverseGeocode.prototype.analyzeResponse = function (error, success) {
            if (this.response) {
                var options = {
                    response: this.response,
                    rawResponse: this.options.rawResponse,
                    onError: error,
                    onSuccess: success,
                    scope: this
                };
                ReverseGeocodeResponseFactory.build(options);
            } else {
                error.call(this, new ErrorService(_.getMessage('SERVICE_RESPONSE_EMPTY')));
            }
        };
        ReverseGeocode.geoEPSG = ['EPSG:4326'];
        return ReverseGeocode;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, ServicesCommonService, ServicesGeocodeRequestReverseGeocodeRequestFactory, ServicesGeocodeResponseReverseGeocodeResponseFactory);
    ServicesAutoCompleteResponseModelAutoCompleteResponse = function () {
        function AutoCompleteResponse() {
            if (!(this instanceof AutoCompleteResponse)) {
                throw new TypeError('AutoCompleteResponse constructor cannot be called as a function.');
            }
            this.suggestedLocations = [];
        }
        AutoCompleteResponse.prototype = { constructor: AutoCompleteResponse };
        return AutoCompleteResponse;
    }();
    ServicesAutoCompleteResponseModelSuggestedLocation = function () {
        function SuggestedLocation() {
            if (!(this instanceof SuggestedLocation)) {
                throw new TypeError('SuggestedLocation constructor cannot be called as a function.');
            }
            this.type = null;
            this.position = {
                x: null,
                y: null
            };
            this.commune = null;
            this.fullText = null;
            this.postalCode = null;
            this.classification = null;
            this.street = null;
            this.poi = null;
            this.kind = null;
        }
        SuggestedLocation.prototype = { constructor: SuggestedLocation };
        return SuggestedLocation;
    }();
    ServicesAutoCompleteResponseAutoCompleteResponseFactory = function (Logger, ErrorService, MRes, XML, AutoCompleteResponse, SuggestedLocation) {
        var AutoCompleteResponseFactory = {
            build: function (options) {
                var data = null;
                if (options.response) {
                    if (options.rawResponse) {
                        data = options.response;
                    } else {
                        var JSONResponse;
                        if (typeof options.response === 'string') {
                            JSONResponse = window.JSON.parse(options.response);
                        } else {
                            JSONResponse = options.response;
                        }
                        if (JSONResponse) {
                            if (JSONResponse.error) {
                                options.onError.call(options.scope, new ErrorService({
                                    message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', JSONResponse.error.description),
                                    status: JSONResponse.error.code,
                                    type: ErrorService.TYPE_SRVERR
                                }));
                                return;
                            }
                            data = new AutoCompleteResponse();
                            if (JSONResponse.results && Array.isArray(JSONResponse.results)) {
                                var suggestedLocation;
                                for (var i = 0; i < JSONResponse.results.length; i++) {
                                    var result = JSONResponse.results[i];
                                    suggestedLocation = new SuggestedLocation();
                                    if (suggestedLocation) {
                                        if (result && result.country === 'StreetAddress') {
                                            suggestedLocation.street = result.street;
                                            suggestedLocation.type = 'StreetAddress';
                                        } else if (result && result.country === 'PositionOfInterest') {
                                            suggestedLocation.poi = result.street;
                                            suggestedLocation.kind = result.kind;
                                            suggestedLocation.type = 'PositionOfInterest';
                                        }
                                        if (suggestedLocation.position) {
                                            suggestedLocation.position.x = result.x;
                                            suggestedLocation.position.y = result.y;
                                        }
                                        suggestedLocation.commune = result.city;
                                        suggestedLocation.fullText = result.fulltext;
                                        suggestedLocation.postalCode = result.zipcode;
                                        suggestedLocation.classification = result.classification;
                                    }
                                    data.suggestedLocations.push(suggestedLocation);
                                }
                            } else {
                                options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_FORMAT_3')));
                                return;
                            }
                            if (!data.suggestedLocations.length) {
                                options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_FORMAT_3')));
                                return;
                            }
                        }
                        if (!data) {
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_ANALYSE_2'),
                                type: ErrorService.TYPE_UNKERR,
                                status: -1
                            }));
                            return;
                        }
                        if (data.exceptionReport) {
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', data.exceptionReport),
                                type: ErrorService.TYPE_SRVERR,
                                status: 200
                            }));
                            return;
                        }
                    }
                } else {
                    options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EMPTY')));
                    return;
                }
                options.onSuccess.call(options.scope, data);
                return;
            }
        };
        return AutoCompleteResponseFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, UtilsMessagesResources, FormatsXML, ServicesAutoCompleteResponseModelAutoCompleteResponse, ServicesAutoCompleteResponseModelSuggestedLocation);
    ServicesAutoCompleteAutoComplete = function (CommonService, AutoCompleteResponseFactory, Logger, MR, ErrorService, Helper) {
        function AutoComplete(options) {
            if (!(this instanceof AutoComplete)) {
                throw new TypeError(MR.getMessage('CLASS_CONSTRUCTOR', 'AutoComplete'));
            }
            this.CLASSNAME = 'AutoComplete';
            CommonService.apply(this, arguments);
            if (!options.text) {
                throw new Error(MR.getMessage('PARAM_MISSING', 'text'));
            }
            this.options.text = options.text;
            if (!options.filterOptions || typeof options.filterOptions !== 'object') {
                this.options.filterOptions = options.filterOptions = {
                    territory: [],
                    type: ['StreetAddress']
                };
            }
            if (Object.keys(options.filterOptions).length === 0) {
                this.options.filterOptions = {
                    territory: [],
                    type: ['StreetAddress']
                };
            }
            this.options.filterOptions.type = options.filterOptions.type || ['StreetAddress'];
            this.options.filterOptions.territory = options.filterOptions.territory || [];
            this.options.maximumResponses = options.maximumResponses || 10;
            if (this.options.protocol === 'XHR' && this.options.httpMethod === 'POST') {
                this.options.httpMethod = 'GET';
            }
            this.options.outputFormat = this.options.rawResponse ? '' : 'json';
        }
        AutoComplete.prototype = Object.create(CommonService.prototype, {});
        AutoComplete.prototype.constructor = AutoComplete;
        AutoComplete.prototype.buildRequest = function (error, success) {
            var territories = '';
            if (this.options.filterOptions.territory) {
                territories = this.options.filterOptions.territory.join(';');
            }
            var types = '';
            if (this.options.filterOptions.type) {
                types = this.options.filterOptions.type.join(',');
            }
            this.request = Helper.normalyzeParameters({
                text: encodeURIComponent(this.options.text),
                type: types,
                terr: territories,
                maximumResponses: this.options.maximumResponses
            });
            success.call(this, this.request);
        };
        AutoComplete.prototype.analyzeResponse = function (error, success) {
            if (this.response) {
                var options = {
                    response: this.response,
                    rawResponse: this.options.rawResponse,
                    onSuccess: success,
                    onError: error,
                    scope: this
                };
                AutoCompleteResponseFactory.build(options);
            } else {
                error.call(this, new ErrorService(MR.getMessage('SERVICE_RESPONSE_EMPTY')));
            }
        };
        return AutoComplete;
    }(ServicesCommonService, ServicesAutoCompleteResponseAutoCompleteResponseFactory, UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, UtilsHelper);
    FormatsXLSRouteServiceModelRoutePlan = function (Logger) {
        function RoutePlan(options) {
            if (!(this instanceof RoutePlan)) {
                throw new TypeError('RoutePlan constructor cannot be called as a function.');
            }
            this.options = options || {};
            if (!options.startPoint) {
                throw new Error('l\'option \'startPoint\' n\'est pas renseigne !');
            }
            if (!options.endPoint) {
                throw new Error('l\'option \'endPoint\' n\'est pas renseigne !');
            }
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
        }
        RoutePlan.prototype = {
            constructor: RoutePlan,
            requestString: null,
            template: {
                routePlan: '<RoutePlan>' + '__ROUTEPREFERENCE__' + '__GRAPH__' + '__WAYPOINTLIST__' + '__AVOIDLIST__' + '</RoutePlan>',
                routePreference: '<RoutePreference>__VALUEROUTEPREFERENCE__</RoutePreference>',
                graph: '<xlsext:graphName xmlns:xlsext="http://www.opengis.net/xlsext" name="__VALUEGRAPH__"/>',
                wayPointList: {
                    container: '<WayPointList>' + '__STARTPOINT__' + '__VIAPOINT__' + '__ENDPOINT__' + '</WayPointList>',
                    point: '<Position><gml:Point xmlns:gml="http://www.opengis.net/gml"><gml:pos>__X__ __Y__</gml:pos></gml:Point></Position>',
                    startPoint: '<StartPoint>' + '__POINT__' + '</StartPoint>',
                    endPoint: '<EndPoint>' + '__POINT__' + '</EndPoint>',
                    viaPoint: '<ViaPoint>' + '__POINT__' + '</ViaPoint>'
                },
                avoidList: {
                    container: '<AvoidList>' + '__AVOIDFEATURE__' + '</AvoidList>',
                    avoidFeature: '<AvoidFeature>__VALUEAVOIDFEATURE__</AvoidFeature>'
                }
            },
            toString: function () {
                var template = '';
                template = this.template.routePlan;
                if (this.options.routePreference) {
                    var tmplPreference = this.template.routePreference;
                    tmplPreference = tmplPreference.replace(/__VALUEROUTEPREFERENCE__/, this.options.routePreference);
                    template = template.replace(/__ROUTEPREFERENCE__/g, tmplPreference);
                }
                template = template.replace(/__ROUTEPREFERENCE__/g, '');
                if (this.options.avoidFeature) {
                    var tmplAvoidList = this.template.avoidList.container;
                    var avoidFeatures = [];
                    for (var i = 0; i < this.options.avoidFeature.length; i++) {
                        var tmplAvoidFeature = this.template.avoidList.avoidFeature;
                        tmplAvoidFeature = tmplAvoidFeature.replace(/__VALUEAVOIDFEATURE__/, this.options.avoidFeature[i]);
                        avoidFeatures.push(tmplAvoidFeature);
                    }
                    tmplAvoidList = tmplAvoidList.replace(/__AVOIDFEATURE__/, avoidFeatures.join('\n'));
                    template = template.replace(/__AVOIDLIST__/g, tmplAvoidList);
                }
                template = template.replace(/__AVOIDLIST__/g, '');
                if (this.options.graph) {
                    var tmplVehicle = this.template.graph;
                    tmplVehicle = tmplVehicle.replace(/__VALUEGRAPH__/, this.options.graph);
                    template = template.replace(/__GRAPH__/g, tmplVehicle);
                }
                template = template.replace(/__GRAPH__/g, '');
                var tmplWayPointList = this.template.wayPointList.container;
                var tmplPoint = '';
                tmplPoint = this.template.wayPointList.point;
                tmplPoint = tmplPoint.replace(/__X__/, this.options.startPoint.x);
                tmplPoint = tmplPoint.replace(/__Y__/, this.options.startPoint.y);
                tmplWayPointList = tmplWayPointList.replace(/__STARTPOINT__/, this.template.wayPointList.startPoint.replace(/__POINT__/, tmplPoint));
                tmplPoint = this.template.wayPointList.point;
                tmplPoint = tmplPoint.replace(/__X__/, this.options.endPoint.x);
                tmplPoint = tmplPoint.replace(/__Y__/, this.options.endPoint.y);
                tmplWayPointList = tmplWayPointList.replace(/__ENDPOINT__/, this.template.wayPointList.endPoint.replace(/__POINT__/, tmplPoint));
                if (this.options.viaPoint) {
                    var points = [];
                    for (var j = 0; j < this.options.viaPoint.length; j++) {
                        var p = this.options.viaPoint[j];
                        tmplPoint = this.template.wayPointList.point;
                        tmplPoint = tmplPoint.replace(/__X__/, p.x);
                        tmplPoint = tmplPoint.replace(/__Y__/, p.y);
                        points.push(tmplPoint);
                    }
                    tmplWayPointList = tmplWayPointList.replace(/__VIAPOINT__/, this.template.wayPointList.viaPoint.replace(/__POINT__/, points.join('\n')));
                } else {
                    tmplWayPointList = tmplWayPointList.replace(/__VIAPOINT__/, '');
                }
                template = template.replace(/__WAYPOINTLIST__/g, tmplWayPointList);
                this.requestString = template;
                return this.requestString;
            }
        };
        return RoutePlan;
    }(UtilsLoggerByDefault);
    FormatsXLSRouteServiceDetermineRouteRequest = function (Logger, RoutePlan) {
        function DetermineRouteRequest(options) {
            if (!(this instanceof DetermineRouteRequest)) {
                throw new TypeError('DetermineRouteRequest constructor cannot be called as a function.');
            }
            this.options = options || {};
            for (var opt in options) {
                if (options.hasOwnProperty(opt)) {
                    this.options[opt] = options[opt];
                }
            }
            this.CLASSNAME = 'DetermineRouteRequest';
        }
        DetermineRouteRequest.prototype = {
            strRequest: null,
            oRoutePlan: null,
            template: {
                determineRouteRequest: '<DetermineRouteRequest distanceUnit="__DISTANCEUNIT__">' + '__ROUTEPLAN__' + '__ROUTEINSTRUCTIONREQUEST__' + '__ROUTEGEOMETRYREQUEST__' + '__ROUTEMAPREQUEST__' + '</DetermineRouteRequest>',
                routeInstructionRequest: '<RouteInstructionsRequest ' + 'provideGeometry="__PROVIDEGEOMETRY__" ' + 'provideBoundingBox="__PROVIDEBBOX__" />',
                routeGeometryRequest: '<RouteGeometryRequest />',
                routeMapRequest: ''
            },
            addRoute: function (oRoutePlan) {
                if (oRoutePlan instanceof RoutePlan) {
                    this.oRoutePlan = oRoutePlan;
                }
            },
            constructor: DetermineRouteRequest,
            toString: function () {
                var template = '';
                template = this.template.determineRouteRequest;
                template = template.replace(/__DISTANCEUNIT__/g, this.options.distanceUnit || 'KM');
                if (!this.oRoutePlan) {
                    var settings = this.options.route;
                    this.oRoutePlan = new RoutePlan(settings);
                    if (!this.oRoutePlan) {
                        throw new Error('La construction du calcul d\'initineraire n\'est pas correctement definie !?');
                    }
                }
                template = template.replace(/__ROUTEPLAN__/g, this.oRoutePlan.toString());
                var tmplInstruction = this.template.routeInstructionRequest;
                tmplInstruction = tmplInstruction.replace(/__PROVIDEGEOMETRY__/g, this.options.provideGeometry || false);
                tmplInstruction = tmplInstruction.replace(/__PROVIDEBBOX__/g, this.options.provideBoundingBox || false);
                template = template.replace(/__ROUTEINSTRUCTIONREQUEST__/g, tmplInstruction);
                var tmplGeometry = this.template.routeGeometryRequest;
                template = template.replace(/__ROUTEGEOMETRYREQUEST__/g, tmplGeometry);
                var tmplMap = this.template.routeMapRequest;
                template = template.replace(/__ROUTEMAPREQUEST__/g, tmplMap);
                this.strRequest = template;
                return this.strRequest;
            }
        };
        return DetermineRouteRequest;
    }(UtilsLoggerByDefault, FormatsXLSRouteServiceModelRoutePlan);
    FormatsXLSRouteServiceRouteRequestExtension = undefined;
    FormatsXLSRouteService = function (Logger, AbstractService, DetermineRouteRequest, RouteRequestExtension) {
        function RouteService(options) {
            if (!(this instanceof RouteService)) {
                throw new TypeError('RouteService constructor cannot be called as a function.');
            }
            this.CLASSNAME = 'RouteService';
            this.CLASSTYPE = 'RouteRequest';
            AbstractService.apply(this, arguments);
        }
        RouteService.prototype = Object.create(AbstractService.prototype, {});
        RouteService.prototype.constructor = RouteService;
        RouteService.prototype.addRequest = function (oRequest) {
            if (oRequest.CLASSNAME === 'DetermineRouteRequest') {
                this.oRequest = oRequest;
            } else {
                throw new Error('Ce n\'est pas un objet de type \'Route Request\' !?');
            }
        };
        RouteService.prototype.addFilter = function (oFilter) {
            if (oFilter instanceof RouteRequestExtension) {
                this.oFilter = oFilter;
            }
        };
        RouteService.prototype.toString = function () {
            if (!this.oRequest) {
                if (!this.options) {
                    throw new Error('Les options ne sont pas renseignes, impossible de construire la requte !');
                }
                if (this.CLASSTYPE === 'RouteRequest') {
                    var settings = {
                        distanceUnit: this.options.distanceUnit || null,
                        provideGeometry: this.options.provideGeometry || null,
                        provideBoundingBox: this.options.provideBoundingBox || null,
                        route: {
                            routePreference: this.options.routePreference || null,
                            startPoint: this.options.startPoint,
                            viaPoint: this.options.viaPoint || null,
                            endPoint: this.options.endPoint,
                            avoidFeature: this.options.avoidFeature || null,
                            graph: this.options.graph || null,
                            expectedStartTime: this.options.expectedStartTime || null
                        }
                    };
                    this.oRequest = new DetermineRouteRequest(settings);
                    if (this.oFilter) {
                        this.oRequest.addFilter(this.oFilter);
                    }
                }
            }
            if (!this.oRequest) {
                throw new Error('Type de requte indefini !');
            }
            this.strRequest = this.oRequest.toString();
            return this.strRequest;
        };
        return RouteService;
    }(UtilsLoggerByDefault, FormatsXLSAbstractService, FormatsXLSRouteServiceDetermineRouteRequest, FormatsXLSRouteServiceRouteRequestExtension);
    ServicesRouteRequestRouteRequestOLS = function (Logger, XLS, RouteService) {
        var RouteRequestOLS = {
            build: function (options) {
                var request = null;
                var settings = {
                    startPoint: options.startPoint,
                    endPoint: options.endPoint,
                    viaPoint: options.viaPoints,
                    provideBoundingBox: options.provideBbox,
                    avoidFeature: options.exclusions,
                    expectedStartTime: options.expectedStartTime,
                    distanceUnit: options.distanceUnit,
                    graph: options.graph,
                    provideGeometry: options.geometryInInstructions,
                    routePreference: options.routePreference
                };
                var oRS = new RouteService(settings);
                var oXLS = new XLS({
                    srsName: options.srs,
                    maximumResponses: options.maximumResponses
                });
                oXLS.namespace = true;
                oXLS.setService(oRS);
                request = oXLS.build();
                if (options.httpMethod == 'GET') {
                    var myRequest = 'qxml=' + encodeURIComponent(request).replace(/\-/g, '%2D').replace(/\_/g, '%5F').replace(/\./g, '%2E').replace(/\!/g, '%21').replace(/\~/g, '%7E').replace(/\*/g, '%2A').replace(/\'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29');
                    request = myRequest;
                }
                return request;
            }
        };
        return RouteRequestOLS;
    }(UtilsLoggerByDefault, FormatsXLS, FormatsXLSRouteService);
    ServicesRouteRequestModelRouteParamREST = function (Logger) {
        function RouteParamREST(options) {
            if (!(this instanceof RouteParamREST)) {
                throw new TypeError('RouteParamREST constructor cannot be called as a function.');
            }
            this.options = options || {};
            this.origin = this.options.startPoint.x + ',' + this.options.startPoint.y;
            this.destination = this.options.endPoint.x + ',' + this.options.endPoint.y;
            this.waypoints = this.options.viaPoints || null;
            this.startDateTime = this.options.expectedStartTime || null;
            this.graphName = this.options.graph;
            this.srs = this.options.srs;
            this.exclusions = this.options.exclusions;
            this.method = 'TIME';
            if (this.options.routePreference) {
                var value = this.options.routePreference;
                switch (value) {
                case 'fastest':
                    this.method = 'TIME';
                    break;
                case 'shortest':
                    this.method = 'DISTANCE';
                    break;
                default:
                    this.method = 'TIME';
                }
            }
            this.format = this.options.geometryInInstructions ? 'STANDARDEXT' : 'STANDARD';
            this.tolerance = 10;
            this.profileId = null;
            this.profileName = null;
        }
        RouteParamREST.CLASSNAME = 'RouteParamREST';
        RouteParamREST.prototype = {
            constructor: RouteParamREST,
            getWaypoints: function () {
                if (!this.waypoints) {
                    return;
                }
                var array = [];
                for (var i = 0; i < this.waypoints.length; i++) {
                    var obj = this.waypoints[i];
                    array.push(obj.x + ',' + obj.y);
                }
                return array.join(';');
            },
            getExclusions: function () {
                return this.exclusions.join(';');
            }
        };
        RouteParamREST.prototype.getParams = function () {
            var map = [];
            map.push({
                k: 'origin',
                v: this.origin
            });
            map.push({
                k: 'destination',
                v: this.destination
            });
            map.push({
                k: 'method',
                v: this.method
            });
            if (this.waypoints) {
                map.push({
                    k: 'waypoints',
                    v: this.getWaypoints()
                });
            }
            if (this.startDateTime) {
                map.push({
                    k: 'startDateTime',
                    v: this.startDateTime
                });
            }
            if (this.graphName) {
                map.push({
                    k: 'graphName',
                    v: this.graphName
                });
            }
            if (this.exclusions) {
                map.push({
                    k: 'exclusions',
                    v: this.getExclusions()
                });
            }
            if (this.srs) {
                map.push({
                    k: 'srs',
                    v: this.srs
                });
            }
            if (this.format) {
                map.push({
                    k: 'format',
                    v: this.format
                });
            }
            return map;
        };
        return RouteParamREST;
    }(UtilsLoggerByDefault);
    ServicesRouteRequestRouteRequestREST = function (Logger, _, RouteParamREST) {
        function RouteRequestREST(options) {
            if (!(this instanceof RouteRequestREST)) {
                throw new TypeError('RouteRequestREST constructor cannot be called as a function.');
            }
            if (!options) {
                throw new Error(_.getMessage('PARAM_EMPTY', 'options'));
            }
            this.settings = options;
        }
        RouteRequestREST.prototype = {
            requestString: null,
            constructor: RouteRequestREST,
            processRequestString: function () {
                var oParams = new RouteParamREST(this.settings);
                var params = oParams.getParams();
                var request = '';
                for (var i = 0; i < params.length; i++) {
                    var o = params[i];
                    if (request) {
                        request += '&';
                    }
                    request += o.k + '=' + o.v;
                }
                this.requestString = request;
                return this.requestString;
            }
        };
        return RouteRequestREST;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ServicesRouteRequestModelRouteParamREST);
    ServicesRouteRequestRouteRequestFactory = function (Logger, ErrorService, RouteRequestOLS, RouteRequestREST) {
        var RouteRequestFactory = {
            build: function (options) {
                var request = null;
                var settings = options || {};
                var bOnError = options.onError !== null && typeof options.onError === 'function' ? true : false;
                var message = null;
                switch (options.api) {
                case 'REST':
                    var myReq = new RouteRequestREST(settings);
                    if (!myReq.processRequestString()) {
                        message = 'Error process request (rest) !';
                        if (bOnError) {
                            options.onError.call(options.scope, new ErrorService(message));
                            return;
                        }
                        throw new Error(message);
                    }
                    request = myReq.requestString;
                    break;
                case 'OLS':
                    request = RouteRequestOLS.build(settings);
                    if (!request) {
                        message = 'Error process request (ols) !';
                        if (bOnError) {
                            options.onError.call(options.scope, new ErrorService(message));
                            return;
                        }
                        throw new Error(message);
                    }
                    break;
                default:
                    message = 'Type of API is not supported by service (REST or OLS) !';
                    if (bOnError) {
                        options.onError.call(options.scope, new ErrorService(message));
                        return;
                    }
                    throw new Error(message);
                }
                return request;
            }
        };
        return RouteRequestFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, ServicesRouteRequestRouteRequestOLS, ServicesRouteRequestRouteRequestREST);
    FormatsWKT = function (Logger) {
        var WKT = {
            toJson: function (strWkt, success, error) {
                var json = null;
                try {
                    if (!strWkt) {
                        throw new Error('La chaine WKT n\'est pas renseigne !');
                    }
                    if (!success) {
                        success = function (json) {
                            console.log(json);
                        };
                    }
                    if (!error) {
                        error = function (e) {
                            console.log(e);
                        };
                    }
                    var regex;
                    var subst;
                    var result;
                    regex = /(-?\d+\.?[0-9]*)\s(-?\d+\.?[0-9]+)/g;
                    subst = '[$1,$2]';
                    strWkt = strWkt.replace(regex, subst);
                    regex = /^(\w+)/;
                    result = regex.exec(strWkt);
                    if (RegExp.$1 === 'POLYGON') {
                        subst = '{"type" : "Polygon",';
                        strWkt = strWkt.replace(RegExp.$1, subst);
                        regex = /(\({2}?)/;
                        subst = '"coordinates" : [[';
                        strWkt = strWkt.replace(regex, subst);
                        regex = /(\){2}?)/;
                        subst = ']]}';
                        strWkt = strWkt.replace(regex, subst);
                        regex = /(\()/g;
                        subst = '[';
                        strWkt = strWkt.replace(regex, subst);
                        regex = /(\))/g;
                        subst = ']';
                        strWkt = strWkt.replace(regex, subst);
                    } else if (RegExp.$1 === 'LINESTRING') {
                        subst = '{"type" : "LineString",';
                        strWkt = strWkt.replace(RegExp.$1, subst);
                        regex = /(\(\(?)/;
                        subst = '"coordinates" : [';
                        strWkt = strWkt.replace(regex, subst);
                        regex = /(\)\)?)/;
                        subst = ']}';
                        strWkt = strWkt.replace(regex, subst);
                    }
                    json = JSON.parse(strWkt);
                    if (!json) {
                        throw new Error('Le JSON est vide !');
                    }
                    if (!json.type) {
                        throw new Error('Le type de geometrie n\'est pas connu !');
                    }
                    if (!json.coordinates) {
                        throw new Error('La liste des points est vide !');
                    }
                    success.call(this, json);
                } catch (e) {
                    if (e.name === 'SyntaxError') {
                        error.call(this, 'Erreur de parsing JSON !');
                        return;
                    }
                    error.call(this, e);
                }
            }
        };
        return WKT;
    }(UtilsLoggerByDefault);
    ServicesRouteResponseModelRouteResponse = function () {
        function RouteResponse() {
            if (!(this instanceof RouteResponse)) {
                throw new TypeError('RouteResponse constructor cannot be called as a function.');
            }
            this.totalTime = null;
            this.totalDistance = null;
            this.bbox = {
                left: null,
                right: null,
                top: null,
                bottom: null
            };
            this.routeGeometry = null;
            this.routeInstructions = [];
        }
        RouteResponse.prototype = { constructor: RouteResponse };
        return RouteResponse;
    }();
    ServicesRouteResponseModelRouteInstruction = function () {
        function RouteInstruction() {
            if (!(this instanceof RouteInstruction)) {
                throw new TypeError('RouteInstruction constructor cannot be called as a function.');
            }
            this.duration = null;
            this.distance = null;
            this.code = null;
            this.instruction = null;
            this.geometry = null;
        }
        RouteInstruction.prototype = { constructor: RouteInstruction };
        return RouteInstruction;
    }();
    ServicesRouteFormatsRouteResponseRESTReader = function (Logger, WKT, MessagesResources, ErrSrv, RouteResponse, RouteInstruction) {
        var RouteResponseRESTReader = {};
        RouteResponseRESTReader.READERS = {
            routeResult: function (node) {
                var response = new RouteResponse();
                __getChildNodes(node, response);
                if (response.status === 'error') {
                    var message = MessagesResources.getMessage('SERVICE_RESPONSE_EXCEPTION', response.message);
                    throw new ErrSrv({
                        message: message,
                        type: ErrSrv.TYPE_SRVERR
                    });
                }
                return response;
            },
            status: function (node, response) {
                var status = __getChildValue(node);
                if (status === 'ERROR' || status === 'error') {
                    if (response) {
                        response.status = 'error';
                    }
                }
            },
            message: function (node, response) {
                if (response) {
                    response.message = __getChildValue(node);
                }
            },
            distance: function (node, response) {
                if (response) {
                    response.totalDistance = __getChildValue(node);
                }
            },
            durationSeconds: function (node, response) {
                if (response) {
                    response.totalTime = parseFloat(__getChildValue(node));
                }
            },
            bounds: function (node, response) {
                if (response && response.bbox) {
                    var coords = __getChildValue(node).split(/[,;]/);
                    response.bbox.left = parseFloat(coords[0]);
                    response.bbox.bottom = parseFloat(coords[1]);
                    response.bbox.right = parseFloat(coords[2]);
                    response.bbox.top = parseFloat(coords[3]);
                }
            },
            geometryWkt: function (node, response) {
                if (response) {
                    var geomWkt = node.innerHTML;
                    var onWKTSuccess = function (json) {
                        response.routeGeometry = json;
                    };
                    var onWKTError = function () {
                        var msg = MessagesResources.getMessage('PARAM_FORMAT', ['geometryWkt']);
                        throw new Error(msg);
                    };
                    WKT.toJson(geomWkt, onWKTSuccess, onWKTError);
                }
            },
            step: function (node, response) {
                var routeInstruction = new RouteInstruction();
                var name;
                if (node.hasChildNodes) {
                    var children = node.childNodes;
                    var child;
                    var childName;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (child.nodeType === 1) {
                            childName = child.localName || child.baseName || child.nodeName;
                            if (childName === 'durationSeconds') {
                                routeInstruction.duration = __getChildValue(child);
                            } else if (childName === 'distance') {
                                routeInstruction.distance = __getChildValue(child);
                            } else if (childName === 'navInstruction') {
                                routeInstruction.code = __getChildValue(child);
                            } else if (childName === 'name') {
                                name = __getChildValue(child);
                            }
                        }
                    }
                }
                if (routeInstruction.code) {
                    switch (routeInstruction.code) {
                    case 'F':
                        if (name != 'Valeur non renseigne') {
                            routeInstruction.instruction = 'Tout droit ' + name;
                        } else {
                            routeInstruction.instruction = 'Continuer tout droit ';
                        }
                        break;
                    case 'B':
                        routeInstruction.instruction = 'Demi-tour ' + name;
                        break;
                    case 'L':
                        routeInstruction.instruction = 'Tourner  gauche ' + name;
                        break;
                    case 'R':
                        routeInstruction.instruction = 'Tourner  droite ' + name;
                        break;
                    case 'BL':
                        routeInstruction.instruction = 'Tourner trs  gauche ' + name;
                        break;
                    case 'BR':
                        routeInstruction.instruction = 'Tourner trs  droite ' + name;
                        break;
                    case 'FL':
                        routeInstruction.instruction = 'Tourner lgrement  gauche ' + name;
                        break;
                    case 'FR':
                        routeInstruction.instruction = 'Tourner lgrement  droite ' + name;
                        break;
                    case 'round_about_entry':
                        routeInstruction.instruction = 'Entre rond-point ' + name;
                        break;
                    case 'round_about_exit':
                        routeInstruction.instruction = 'Sortie rond-point ' + name;
                        break;
                    case null:
                        routeInstruction.instruction = 'Prendre ' + name;
                        break;
                    default:
                        routeInstruction.instruction = '?' + routeInstruction.code + '? ' + name;
                        break;
                    }
                }
                if (Array.isArray(response.routeInstructions)) {
                    response.routeInstructions.push(routeInstruction);
                }
            }
        };
        RouteResponseRESTReader.read = function (root) {
            var response;
            if (root.nodeName === 'routeResult') {
                response = RouteResponseRESTReader.READERS['routeResult'](root);
                return response;
            } else {
                throw new Error('Erreur lors de la lecture de la rponse : elle n\'est pas au format attendu.');
            }
        };
        function __getChildValue(node) {
            var textNode;
            var value = '';
            if (node.hasChildNodes()) {
                textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    value = textNode.nodeValue;
                }
            }
            return value;
        }
        function __getChildNodes(node, data) {
            if (node.hasChildNodes()) {
                var children = node.childNodes;
                var child;
                var childName;
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    if (child.nodeType === 1) {
                        childName = child.localName || child.baseName || child.nodeName;
                        if (RouteResponseRESTReader.READERS[childName]) {
                            var reader = RouteResponseRESTReader.READERS[childName];
                            reader(child, data);
                        } else {
                            __getChildNodes(child, data);
                        }
                    }
                }
            }
        }
        return RouteResponseRESTReader;
    }(UtilsLoggerByDefault, FormatsWKT, UtilsMessagesResources, ExceptionsErrorService, ServicesRouteResponseModelRouteResponse, ServicesRouteResponseModelRouteInstruction);
    ServicesRouteFormatsRouteResponseOLSReader = function (Logger) {
        var RouteResponseOLSReader = {};
        RouteResponseOLSReader.READERS = {};
        RouteResponseOLSReader.read = function (root) {
        };
        return RouteResponseOLSReader;
    }(UtilsLoggerByDefault);
    ServicesRouteResponseRouteResponseFactory = function (Logger, ErrorService, XML, WKT, MRes, RouteResponseRESTReader, RouteResponseOLSReader, RouteResponse, RouteInstruction) {
        var RouteResponseFactory = {
            build: function (options) {
                var data = null;
                if (options.response) {
                    if (options.rawResponse) {
                        data = options.response;
                    } else {
                        switch (options.outputFormat) {
                        case 'xml':
                            var routeReader = options.api === 'REST' ? RouteResponseRESTReader : RouteResponseOLSReader;
                            try {
                                var p = new XML({ reader: routeReader });
                                if (typeof options.response === 'string') {
                                    p.setXMLString(options.response);
                                } else {
                                    p.setXMLDoc(options.response);
                                }
                                data = p.parse();
                                if (!data) {
                                    throw new ErrorService(MRes.getMessage('SERVICE_RESPONSE_FORMAT', 'xml'));
                                }
                            } catch (e) {
                                options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_ANALYSE', options.response)));
                                return;
                            }
                            break;
                        case 'json':
                            var JSONResponse;
                            if (typeof options.response === 'string') {
                                JSONResponse = window.JSON.parse(options.response);
                            } else {
                                JSONResponse = options.response;
                            }
                            if (JSONResponse.message) {
                                options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', JSONResponse.message)));
                                return;
                            }
                            if (JSONResponse) {
                                var legs = [];
                                var legSteps = [];
                                var steps = [];
                                data = new RouteResponse();
                                if (data.hasOwnProperty('totalTime')) {
                                    data.totalTime = parseFloat(JSONResponse.durationSeconds);
                                }
                                if (data.hasOwnProperty('totalDistance')) {
                                    data.totalDistance = options.distanceUnit === 'm' ? JSONResponse.distanceMeters : JSONResponse.distance;
                                }
                                if (data.hasOwnProperty('bbox')) {
                                    var coords = JSONResponse.bounds.split(/[,;]/);
                                    data.bbox.left = parseFloat(coords[0]);
                                    data.bbox.bottom = parseFloat(coords[1]);
                                    data.bbox.right = parseFloat(coords[2]);
                                    data.bbox.top = parseFloat(coords[3]);
                                }
                                var onWKTSuccess = function (json) {
                                    data.routeGeometry = json;
                                };
                                var onWKTError = function (e) {
                                    console.log(e);
                                    options.onError.call(options.scope, new ErrorService(MRes.getMessage('PARAM_FORMAT', ['geometryWkt'])));
                                };
                                if (data.hasOwnProperty('routeGeometry')) {
                                    var geometry = JSONResponse.geometryWkt || JSONResponse.simplifiedWkt;
                                    if (geometry) {
                                        WKT.toJson(geometry, onWKTSuccess, onWKTError);
                                        if (!data.routeGeometry) {
                                            return;
                                        }
                                    }
                                }
                                if (data.hasOwnProperty('routeInstructions')) {
                                    var legList = JSONResponse.legs;
                                    var i;
                                    if (Array.isArray(legList) && legList.length) {
                                        for (i = 0; i < legList.length; i++) {
                                            legs.push(legList[i]);
                                        }
                                    }
                                    if (Array.isArray(legs) && legs.length) {
                                        for (i = 0; i < legs.length; i++) {
                                            legSteps.push(legs[i].steps);
                                        }
                                    }
                                    if (Array.isArray(legSteps) && legSteps.length) {
                                        for (i = 0; i < legSteps.length; i++) {
                                            steps = steps.concat(legSteps[i]);
                                        }
                                    }
                                    steps.forEach(function (step) {
                                        data.routeInstructions.push(new RouteInstruction());
                                        data.routeInstructions[data.routeInstructions.length - 1].duration = step.durationSeconds;
                                        data.routeInstructions[data.routeInstructions.length - 1].distance = options.distanceUnit === 'm' ? step.distanceMeters : step.distance;
                                        data.routeInstructions[data.routeInstructions.length - 1].code = step.navInstruction;
                                        var points = [];
                                        for (var i = 0; i < step.points.length; i++) {
                                            var point = step.points[i].split(',');
                                            if (point) {
                                                points.push(point);
                                            }
                                        }
                                        if (points && points.length !== 0) {
                                            data.routeInstructions[data.routeInstructions.length - 1].geometry = {
                                                coordinates: points,
                                                type: 'LineString'
                                            };
                                        } else {
                                            data.routeInstructions[data.routeInstructions.length - 1].geometry = null;
                                        }
                                        if (step.name == 'Valeur non renseigne') {
                                            step.name = '';
                                        }
                                        switch (step.navInstruction) {
                                        case 'F':
                                            if (step.name) {
                                                data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Tout droit ' + step.name;
                                            } else {
                                                data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Continuer tout droit ';
                                            }
                                            break;
                                        case 'B':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Demi-tour ' + step.name;
                                            break;
                                        case 'L':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Tourner  gauche ' + step.name;
                                            break;
                                        case 'R':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Tourner  droite ' + step.name;
                                            break;
                                        case 'BL':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Tourner trs  gauche ' + step.name;
                                            break;
                                        case 'BR':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Tourner trs  droite ' + step.name;
                                            break;
                                        case 'FL':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Tourner lgrement  gauche ' + step.name;
                                            break;
                                        case 'FR':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Tourner lgrement  droite ' + step.name;
                                            break;
                                        case 'round_about_entry':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Entre rond-point ' + step.name;
                                            break;
                                        case 'round_about_exit':
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Sortie rond-point ' + step.name;
                                            break;
                                        case null:
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = 'Prendre tout droit ' + step.name;
                                            break;
                                        default:
                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = '?' + step.navInstruction + '? ' + step.name;
                                            break;
                                        }
                                    });
                                }
                            }
                            if (!data) {
                                options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_ANALYSE', 'json')));
                                return;
                            }
                            break;
                        default:
                            options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_FORMAT', 'json', 'xml')));
                            return;
                        }
                        if (data && data.exceptionReport) {
                            options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EXCEPTION_2')));
                            return;
                        }
                    }
                } else {
                    options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EMPTY')));
                    return;
                }
                options.onSuccess.call(options.scope, data);
                return;
            }
        };
        return RouteResponseFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, FormatsXML, FormatsWKT, UtilsMessagesResources, ServicesRouteFormatsRouteResponseRESTReader, ServicesRouteFormatsRouteResponseOLSReader, ServicesRouteResponseModelRouteResponse, ServicesRouteResponseModelRouteInstruction);
    ServicesRouteRoute = function (Logger, _, ErrorService, CommonService, DefaultUrlService, RouteRequestFactory, RouteResponseFactory) {
        function Route(options) {
            if (!(this instanceof Route)) {
                throw new TypeError(_.getMessage('CLASS_CONSTRUCTOR', 'Route'));
            }
            this.CLASSNAME = 'Route';
            CommonService.apply(this, arguments);
            if (!options.startPoint) {
                throw new Error(_.getMessage('PARAM_MISSING', 'startPoint'));
            }
            if (options.startPoint.x == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'startPoint.x'));
            }
            if (options.startPoint.y == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'startPoint.y'));
            }
            if (!options.endPoint) {
                throw new Error(_.getMessage('PARAM_MISSING', 'endPoint'));
            }
            if (options.endPoint.x == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'endPoint.x'));
            }
            if (options.endPoint.y == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'endPoint.y'));
            }
            this.options.api = typeof options.api == 'string' ? options.api.toUpperCase() : 'REST';
            this.options.outputFormat = typeof options.outputFormat == 'string' ? options.outputFormat.toLowerCase() : 'json';
            this.options.startPoint = options.startPoint;
            this.options.endPoint = options.endPoint;
            this.options.viaPoints = options.viaPoints || null;
            this.options.exclusions = options.exclusions || null;
            this.options.routePreference = options.routePreference || 'fastest';
            this.options.graph = options.graph || 'Voiture';
            this.options.geometryInInstructions = options.geometryInInstructions || false;
            this.options.provideBbox = options.provideBbox || true;
            this.options.distanceUnit = options.distanceUnit || 'km';
            this.options.expectedStartTime = null;
            this.options.srs = options.srs || 'EPSG:4326';
            this.options.api = 'REST';
            if (this.options.protocol === 'XHR') {
                this.options.httpMethod = 'GET';
            }
            if (!this.options.serverUrl) {
                var lstUrlByDefault = DefaultUrlService.Route.url(this.options.apiKey);
                var urlFound = null;
                switch (this.options.api) {
                case 'OLS':
                    urlFound = lstUrlByDefault.ols;
                    break;
                case 'REST':
                    var key = 'route' + '-' + this.options.outputFormat;
                    urlFound = lstUrlByDefault[key];
                    break;
                default:
                    throw new Error(_.getMessage('PARAM_UNKNOWN', 'api'));
                }
                if (!urlFound) {
                    throw new Error('Url by default not found !');
                }
                this.options.serverUrl = urlFound;
            }
            var idx = this.options.serverUrl.lastIndexOf('.');
            if (idx !== -1) {
                var extension = this.options.serverUrl.substring(idx + 1);
                if (extension && extension.length < 5) {
                    switch (extension.toLowerCase()) {
                    case 'json':
                    case 'xml':
                        this.options.outputFormat = extension.toLowerCase();
                        break;
                    default:
                        throw new Error('type of service : unknown or unsupported (json or xml) !');
                    }
                }
            }
        }
        Route.prototype = Object.create(CommonService.prototype, {});
        Route.prototype.constructor = Route;
        Route.prototype.buildRequest = function (error, success) {
            var options = {
                api: this.options.api,
                startPoint: this.options.startPoint,
                endPoint: this.options.endPoint,
                viaPoints: this.options.viaPoints,
                provideBbox: this.options.provideBbox,
                exclusions: this.options.exclusions,
                distanceUnit: this.options.distanceUnit,
                graph: this.options.graph,
                geometryInInstructions: this.options.geometryInInstructions,
                routePreference: this.options.routePreference,
                srs: this.options.srs
            };
            this.request = RouteRequestFactory.build(options);
            if (!this.request) {
                error.call(this, new ErrorService(_.getMessage('SERVICE_REQUEST_BUILD')));
            } else {
                success.call(this, this.request);
            }
        };
        Route.prototype.analyzeResponse = function (error, success) {
            if (this.response) {
                var options = {
                    distanceUnit: this.options.distanceUnit,
                    response: this.response,
                    outputFormat: this.options.outputFormat,
                    api: this.options.api,
                    rawResponse: this.options.rawResponse,
                    onError: error,
                    onSuccess: success,
                    scope: this
                };
                RouteResponseFactory.build(options);
            } else {
                error.call(this, new ErrorService(_.getMessage('SERVICE_RESPONSE_EMPTY')));
            }
        };
        return Route;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, ServicesCommonService, ServicesDefaultUrlService, ServicesRouteRequestRouteRequestFactory, ServicesRouteResponseRouteResponseFactory);
    ServicesProcessIsoCurveRequestModelProcessIsoCurveParam = function (Logger) {
        function ProcessIsoCurveParam(options) {
            if (!(this instanceof ProcessIsoCurveParam)) {
                throw new TypeError('ProcessIsoCurveParam constructor cannot be called as a function.');
            }
            this.options = options || {};
            this.id = this.options.id;
            this.location = this.options.position;
            this.srs = this.options.srs;
            this.graphName = this.options.graph;
            this.profileId = this.options.profileId || null;
            this.profileName = this.options.profileName || null;
            this.exclusions = this.options.exclusions;
            this.reverse = this.options.reverse;
            this.smoothing = this.options.smoothing;
            this.holes = this.options.holes;
            var value = this.options.method;
            switch (value) {
            case 'time':
                this.method = 'time';
                this.time = this.options.time;
                break;
            case 'distance':
                this.method = 'distance';
                this.distance = this.options.distance;
                break;
            default:
                this.method = 'time';
            }
        }
        ProcessIsoCurveParam.CLASSNAME = 'ProcessIsoCurveParam';
        ProcessIsoCurveParam.prototype = {
            constructor: ProcessIsoCurveParam,
            getLocation: function () {
                return this.location.x + ',' + this.location.y;
            },
            getExclusions: function () {
                return this.exclusions.join(';');
            }
        };
        ProcessIsoCurveParam.prototype.getParams = function () {
            var map = [];
            map.push({
                k: 'location',
                v: this.getLocation()
            });
            map.push({
                k: 'smoothing',
                v: this.smoothing
            });
            map.push({
                k: 'holes',
                v: this.holes
            });
            map.push({
                k: 'reverse',
                v: this.reverse
            });
            map.push({
                k: 'method',
                v: this.method
            });
            if (this.time) {
                map.push({
                    k: 'time',
                    v: this.time
                });
            }
            if (this.distance) {
                map.push({
                    k: 'distance',
                    v: this.distance
                });
            }
            map.push({
                k: 'graphName',
                v: this.graphName
            });
            if (this.exclusions) {
                map.push({
                    k: 'exclusions',
                    v: this.getExclusions()
                });
            }
            if (this.srs) {
                map.push({
                    k: 'srs',
                    v: this.srs
                });
            }
            return map;
        };
        return ProcessIsoCurveParam;
    }(UtilsLoggerByDefault);
    ServicesProcessIsoCurveRequestProcessIsoCurveRequest = function (Logger, _, ProcessIsoCurveParam) {
        function ProcessIsoCurveRequest(options) {
            if (!(this instanceof ProcessIsoCurveRequest)) {
                throw new TypeError('ProcessIsoCurveRequest constructor cannot be called as a function.');
            }
            if (!options) {
                throw new Error(_.getMessage('PARAM_EMPTY', 'options'));
            }
            this.settings = options;
            this.mode = this.settings.httpMethod || 'GET';
        }
        ProcessIsoCurveRequest.prototype = {
            requestString: null,
            constructor: ProcessIsoCurveRequest,
            template: {
                container: '<?xml version="1.0" encoding="UTF-8"?>\n' + '<isochroneRequest>\n' + '__ID__' + '\t<location>\n' + '\t\t<x>__X__</x>\n' + '\t\t<y>__Y__</y>\n' + '\t</location>\n' + '\t<srs>__SRS__</srs>\n' + '\t<graphName>__GRAPHNAME__</graphName>\n' + '__PROFIL__' + '__EXCLUSIONS__' + '\t<method>__METHOD__</method>\n' + '__TIME__' + '__DISTANCE__' + '\t<reverse>__REVERSE__</reverse>\n' + '\t<smoothing>__SMOOTHING__</smoothing>\n' + '\t<holes>__HOLES__</holes>\n' + '</isochroneRequest>',
                id: '\t<id>__IDVALUE__</id>\n',
                profil: '\t<profileId>__PROFILID__</profileId>\n' + '\t<profileName>__PROFILNAME__</profileName>\n',
                exclusions: {
                    container: '\t<exclusions>\n' + '__EXCLUSIONFEATURE__\n' + '\t</exclusions>\n',
                    feature: '\t\t<exclusion>__EXCLUSIONVALUE__</exclusion>'
                },
                time: '\t<time>__TIMEVALUE__</time>\n',
                distance: '\t<distance>__DISTANCEVALUE__</distance>\n'
            },
            processRequestString: function () {
                var request = '';
                var i = 0;
                switch (this.mode) {
                case 'GET':
                    var oParams = new ProcessIsoCurveParam(this.settings);
                    var params = oParams.getParams();
                    for (i = 0; i < params.length; i++) {
                        var o = params[i];
                        if (request) {
                            request += '&';
                        }
                        request += o.k + '=' + o.v;
                    }
                    break;
                case 'POST':
                    request = this.template.container;
                    request = request.replace(/__ID__/g, '');
                    request = request.replace(/__PROFIL__/g, '');
                    request = request.replace(/__X__/g, this.settings.position.x);
                    request = request.replace(/__Y__/g, this.settings.position.y);
                    request = request.replace(/__GRAPHNAME__/g, this.settings.graph);
                    request = request.replace(/__SRS__/g, this.settings.srs);
                    request = request.replace(/__SMOOTHING__/g, this.settings.smoothing);
                    request = request.replace(/__HOLES__/g, this.settings.holes);
                    request = request.replace(/__REVERSE__/g, this.settings.reverse);
                    if (this.settings.exclusions) {
                        var tmplExclusions = this.template.exclusions.container;
                        var exclusions = [];
                        for (i = 0; i < this.settings.exclusions.length; i++) {
                            var tmplFeature = this.template.exclusions.feature;
                            tmplFeature = tmplFeature.replace(/__EXCLUSIONVALUE__/, this.settings.exclusions[i]);
                            exclusions.push(tmplFeature);
                        }
                        tmplExclusions = tmplExclusions.replace(/__EXCLUSIONFEATURE__/, exclusions.join('\n'));
                        request = request.replace(/__EXCLUSIONS__/g, tmplExclusions);
                    }
                    request = request.replace(/__EXCLUSIONS__/g, '');
                    if (this.settings.distance) {
                        var tmplDistance = this.template.distance;
                        tmplDistance = tmplDistance.replace(/__DISTANCEVALUE__/g, this.settings.distance);
                        request = request.replace(/__DISTANCE__/g, tmplDistance);
                        request = request.replace(/__METHOD__/g, 'distance');
                    }
                    request = request.replace(/__DISTANCE__/g, '');
                    if (this.settings.time) {
                        var tmplTime = this.template.time;
                        tmplTime = tmplTime.replace(/__TIMEVALUE__/g, this.settings.time);
                        request = request.replace(/__TIME__/g, tmplTime);
                        request = request.replace(/__METHOD__/g, 'time');
                    }
                    request = request.replace(/__TIME__/g, '');
                    break;
                default:
                }
                this.requestString = request;
                return this.requestString;
            }
        };
        return ProcessIsoCurveRequest;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ServicesProcessIsoCurveRequestModelProcessIsoCurveParam);
    ServicesProcessIsoCurveResponseModelProcessIsoCurveResponse = function () {
        function ProcessIsoCurveResponse() {
            if (!(this instanceof ProcessIsoCurveResponse)) {
                throw new TypeError('ProcessIsoCurveResponse constructor cannot be called as a function.');
            }
            this.message = null;
            this.id = null;
            this.location = {};
            this.location.x = null;
            this.location.y = null;
            this.srs = null;
            this.geometry = null;
            this.time = null;
            this.distance = null;
        }
        ProcessIsoCurveResponse.prototype = { constructor: ProcessIsoCurveResponse };
        return ProcessIsoCurveResponse;
    }();
    ServicesProcessIsoCurveFormatsProcessIsoCurveResponseReader = function (Logger, WKT, ErrSrv, MessagesResources, ProcessIsoCurveResponse) {
        var ProcessIsoCurveResponseReader = {};
        ProcessIsoCurveResponseReader.READERS = {
            isochronResult: function (root) {
                var response = new ProcessIsoCurveResponse();
                if (root.hasChildNodes()) {
                    var children = root.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (ProcessIsoCurveResponseReader.READERS[child.nodeName]) {
                            ProcessIsoCurveResponseReader.READERS[child.nodeName](child, response);
                        }
                    }
                }
                if (response.status === 'error') {
                    var message = MessagesResources.getMessage('SERVICE_RESPONSE_EXCEPTION', response.message);
                    throw new ErrSrv({
                        message: message,
                        type: ErrSrv.TYPE_SRVERR
                    });
                }
                return response;
            },
            message: function (node, response) {
                if (response) {
                    response.message = __getChildValue(node);
                }
            },
            status: function (node, response) {
                var status = __getChildValue(node);
                if (status === 'ERROR' || status === 'error') {
                    if (response) {
                        response.status = 'error';
                    }
                }
            },
            id: function (node, response) {
                if (response) {
                    response.id = __getChildValue(node);
                }
            },
            location: function (node, response) {
                var coords = __getChildValue(node);
                if (response && response.location) {
                    response.location.x = parseFloat(coords.split(',')[0]);
                    response.location.y = parseFloat(coords.split(',')[1]);
                }
            },
            srs: function (node, response) {
                if (response) {
                    response.srs = __getChildValue(node);
                }
            },
            distance: function (node, response) {
                if (response) {
                    response.distance = parseFloat(__getChildValue(node));
                }
            },
            time: function (node, response) {
                if (response) {
                    response.time = parseFloat(__getChildValue(node));
                }
            },
            wktGeometry: function (node, response) {
                if (response) {
                    var wktGeometry = node.innerHTML;
                    var onWKTSuccess = function (json) {
                        response.geometry = json;
                    };
                    var onWKTError = function () {
                        var msg = MessagesResources.getMessage('PARAM_FORMAT', ['wktGeometry']);
                        throw new Error(msg);
                    };
                    if (response.hasOwnProperty('geometry')) {
                        WKT.toJson(wktGeometry, onWKTSuccess, onWKTError);
                    }
                }
            },
            serviceResult: function (node) {
                var response = {};
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (ProcessIsoCurveResponseReader.READERS[child.nodeName]) {
                            ProcessIsoCurveResponseReader.READERS[child.nodeName](child, response);
                        }
                    }
                }
                return response;
            },
            ExceptionReport: function (node) {
                var response = {};
                if (node.hasChildNodes()) {
                    var children = node.childNodes;
                    var child;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (child.nodeName === 'Exception') {
                            response.exceptionReport = ProcessIsoCurveResponseReader.READERS['Exception'](child);
                        }
                    }
                }
                return response;
            },
            Exception: function (node) {
                var exceptionReport = {};
                var exceptionCode = node.getAttribute('exceptionCode');
                if (exceptionCode) {
                    exceptionReport.exceptionCode = exceptionCode;
                }
                var textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    exceptionReport.exception = textNode.nodeValue;
                }
                return exceptionReport;
            }
        };
        ProcessIsoCurveResponseReader.read = function (root) {
            var response;
            if (root.nodeName === 'isochronResult' || root.nodeName === 'isochroneResult' || root.nodeName === 'IsochroneResult') {
                response = ProcessIsoCurveResponseReader.READERS['isochronResult'](root);
                return response;
            } else if (root.nodeName === 'ExceptionReport') {
                response = ProcessIsoCurveResponseReader.READERS[root.nodeName](root);
                return response;
            } else if (ProcessIsoCurveResponseReader.READERS[root.nodeName]) {
                response = ProcessIsoCurveResponseReader.READERS[root.nodeName](root);
                if (response.status === 'error') {
                    var errMsg = MessagesResources.getMessage('SERVICE_RESPONSE_EXCEPTION', response.message);
                    throw new ErrSrv({
                        message: errMsg,
                        type: ErrSrv.TYPE_SRVERR
                    });
                }
                return response;
            } else {
                throw new ErrSrv({
                    message: MessagesResources.getMessage('SERVICE_RESPONSE_ANALYSE', root.nodeName),
                    type: ErrSrv.TYPE_UNKERR
                });
            }
        };
        function __getChildValue(node) {
            var textNode;
            var value = '';
            if (node.hasChildNodes()) {
                textNode = node.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    value = textNode.nodeValue;
                }
            }
            return value;
        }
        return ProcessIsoCurveResponseReader;
    }(UtilsLoggerByDefault, FormatsWKT, ExceptionsErrorService, UtilsMessagesResources, ServicesProcessIsoCurveResponseModelProcessIsoCurveResponse);
    ServicesProcessIsoCurveResponseProcessIsoCurveResponseFactory = function (Logger, ErrorService, MRes, XML, WKT, ProcessIsoCurveResponseReader, ProcessIsoCurveResponse) {
        var ProcessIsoCurveResponseFactory = {
            build: function (options) {
                var data = null;
                if (options.response) {
                    if (options.rawResponse) {
                        data = options.response;
                    } else {
                        switch (options.outputFormat) {
                        case 'xml':
                            try {
                                var p = new XML({ reader: ProcessIsoCurveResponseReader });
                                if (typeof options.response === 'string') {
                                    p.setXMLString(options.response);
                                } else {
                                    p.setXMLDoc(options.response);
                                }
                                data = p.parse();
                                if (!data) {
                                    throw new Error(MRes.getMessage('SERVICE_RESPONSE_EXCEPTION_2'));
                                }
                            } catch (e) {
                                var message = e.message;
                                message += '\n(raw response service : \'' + options.response + '\')';
                                options.onError.call(options.scope, new ErrorService({
                                    message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', message),
                                    status: 200,
                                    type: ErrorService.TYPE_SRVERR
                                }));
                                return;
                            }
                            break;
                        case 'json':
                            var JSONResponse;
                            if (typeof options.response === 'string') {
                                JSONResponse = window.JSON.parse(options.response);
                            } else {
                                JSONResponse = options.response;
                            }
                            if (JSONResponse.status === 'OK' || JSONResponse.status === 'ok') {
                                data = new ProcessIsoCurveResponse();
                                if (data) {
                                    data.time = JSONResponse.time;
                                    data.distance = JSONResponse.distance;
                                    data.message = JSONResponse.message;
                                    data.id = JSONResponse.id;
                                    data.srs = JSONResponse.srs;
                                    var onWKTSuccess = function (json) {
                                        data.geometry = json;
                                    };
                                    var onWKTError = function () {
                                        options.onError.call(options.scope, new ErrorService({ message: MRes.getMessage('PARAM_FORMAT', 'wktGeometry') }));
                                    };
                                    if (data.hasOwnProperty('geometry')) {
                                        WKT.toJson(JSONResponse.wktGeometry, onWKTSuccess, onWKTError);
                                        if (!data.geometry) {
                                            return;
                                        }
                                    }
                                    var coords = JSONResponse.location.split(',');
                                    if (data.location) {
                                        data.location.x = coords[0];
                                        data.location.y = coords[1];
                                    }
                                } else {
                                    options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_ANALYSE', options.response)));
                                    return;
                                }
                            } else if (JSONResponse.status === 'ERROR' || JSONResponse.status === 'error') {
                                var mess = JSONResponse.message;
                                mess += '\n(raw response service : \'' + JSONResponse + '\')';
                                options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', mess)));
                                return;
                            }
                            break;
                        default:
                            options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_FORMAT', 'json', 'xml')));
                            return;
                        }
                        if (data && data.exceptionReport) {
                            options.onError.call(options.scope, new ErrorService({
                                message: MRes.getMessage('SERVICE_RESPONSE_EXCEPTION', data.exceptionReport),
                                type: ErrorService.TYPE_SRVERR,
                                status: 200
                            }));
                            return;
                        }
                    }
                } else {
                    options.onError.call(options.scope, new ErrorService(MRes.getMessage('SERVICE_RESPONSE_EMPTY')));
                    return;
                }
                options.onSuccess.call(options.scope, data);
                return;
            }
        };
        return ProcessIsoCurveResponseFactory;
    }(UtilsLoggerByDefault, ExceptionsErrorService, UtilsMessagesResources, FormatsXML, FormatsWKT, ServicesProcessIsoCurveFormatsProcessIsoCurveResponseReader, ServicesProcessIsoCurveResponseModelProcessIsoCurveResponse);
    ServicesProcessIsoCurveProcessIsoCurve = function (Logger, _, ErrorService, CommonService, DefaultUrlService, ProcessIsoCurveRequest, ProcessIsoCurveResponseFactory) {
        function ProcessIsoCurve(options) {
            if (!(this instanceof ProcessIsoCurve)) {
                throw new TypeError(_.getMessage('CLASS_CONSTRUCTOR', 'ProcessIsoCurve'));
            }
            this.CLASSNAME = 'ProcessIsoCurve';
            CommonService.apply(this, arguments);
            if (!options.position) {
                throw new Error(_.getMessage('PARAM_MISSING', 'position'));
            }
            if (options.position.x == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'position.x'));
            }
            if (options.position.y == null) {
                throw new Error(_.getMessage('PARAM_MISSING', 'position.y'));
            }
            if (!options.time && !options.distance) {
                throw new Error('Parameter(s) \'distance\' missing. Parameter time to calculate an isochrone, parameter distance for an isodistance');
            }
            if (!options.time && options.distance) {
                this.options.method = 'distance';
                if (this.options.time) {
                    delete this.options.time;
                }
            }
            if (options.time && !options.distance) {
                this.options.method = 'time';
                if (this.options.distance) {
                    delete this.options.distance;
                }
            }
            this.options.method = this.options.method || 'time';
            this.options.exclusions = options.exclusions || null;
            this.options.graph = options.graph || 'Voiture';
            this.options.reverse = options.reverse || false;
            this.options.smoothing = options.smoothing || false;
            this.options.holes = options.holes || false;
            this.options.srs = options.srs || 'EPSG:4326';
            this.options.outputFormat = typeof options.outputFormat == 'string' ? options.outputFormat.toLowerCase() : 'json';
            if (!this.options.serverUrl) {
                var lstUrlByDefault = DefaultUrlService.ProcessIsoCurve.url(this.options.apiKey);
                var urlFound = lstUrlByDefault['iso' + '-' + this.options.outputFormat];
                if (!urlFound) {
                    throw new Error('Url by default not found !');
                }
                this.options.serverUrl = urlFound;
            }
            var idx = this.options.serverUrl.lastIndexOf('.');
            if (idx !== -1) {
                var extension = this.options.serverUrl.substring(idx + 1);
                if (extension && extension.length < 5) {
                    switch (extension.toLowerCase()) {
                    case 'json':
                    case 'xml':
                        this.options.outputFormat = extension.toLowerCase();
                        break;
                    default:
                        throw new Error('type of service : unknown or unsupported (json or xml) !');
                    }
                }
            }
        }
        ProcessIsoCurve.prototype = Object.create(CommonService.prototype, {});
        ProcessIsoCurve.prototype.constructor = ProcessIsoCurve;
        ProcessIsoCurve.prototype.buildRequest = function (error, success) {
            try {
                var oIsoCurve = new ProcessIsoCurveRequest(this.options);
                if (!oIsoCurve.processRequestString()) {
                    throw new Error(_.getMessage('SERVICE_REQUEST_BUILD'));
                }
                this.request = oIsoCurve.requestString;
            } catch (e) {
                error.call(this, new ErrorService(e.message));
                return;
            }
            success.call(this, this.request);
        };
        ProcessIsoCurve.prototype.analyzeResponse = function (onError, onSuccess) {
            if (this.response) {
                var options = {
                    response: this.response,
                    outputFormat: this.options.outputFormat,
                    rawResponse: this.options.rawResponse,
                    onSuccess: onSuccess,
                    onError: onError,
                    scope: this
                };
                ProcessIsoCurveResponseFactory.build(options);
            } else {
                onError.call(this, new ErrorService(_.getMessage('SERVICE_RESPONSE_EMPTY')));
            }
        };
        return ProcessIsoCurve;
    }(UtilsLoggerByDefault, UtilsMessagesResources, ExceptionsErrorService, ServicesCommonService, ServicesDefaultUrlService, ServicesProcessIsoCurveRequestProcessIsoCurveRequest, ServicesProcessIsoCurveResponseProcessIsoCurveResponseFactory);
    ServicesServices = function (Alti, AutoConf, Geocode, ReverseGeocode, AutoComplete, Route, ProcessIsoCurve) {
        var Services = {
            getConfig: function (options) {
                var autoconfService = new AutoConf(options);
                autoconfService.call();
            },
            getAltitude: function (options) {
                var altiService = new Alti(options);
                altiService.call();
            },
            geocode: function (options) {
                var geocodeService = new Geocode(options);
                geocodeService.call();
            },
            reverseGeocode: function (options) {
                var reverseGeocodeService = new ReverseGeocode(options);
                reverseGeocodeService.call();
            },
            autoComplete: function (options) {
                var autoCompleteService = new AutoComplete(options);
                autoCompleteService.call();
            },
            route: function (options) {
                var routeService = new Route(options);
                routeService.call();
            },
            isoCurve: function (options) {
                var processIsoCurveService = new ProcessIsoCurve(options);
                processIsoCurveService.call();
            }
        };
        var point = {};
        var circle = {};
        var bbox = {};
        return Services;
    }(ServicesAltiAlti, ServicesAutoConfAutoConf, ServicesGeocodeGeocode, ServicesGeocodeReverseGeocode, ServicesAutoCompleteAutoComplete, ServicesRouteRoute, ServicesProcessIsoCurveProcessIsoCurve);
    Gp = function (XHR, Services, AltiResponse, Elevation, AutoCompleteResponse, SuggestedLocation, GetConfigResponse, Constraint, Format, Layer, Legend, Metadata, Originator, Service, Style, Territory, Thematic, TM, TMLimit, TMS, GeocodeResponse, GeocodedLocation, DirectGeocodedLocation, ReverseGeocodedLocation, IsoCurveResponse, RouteResponse, RouteInstruction, Error, Helper, DefaultUrl) {
        var scope = typeof window !== 'undefined' ? window : {};
        var Gp = scope.Gp || {
            servicesVersion: '1.0.1',
            servicesDate: '2017-07-25',
            extend: function (strNS, value) {
                var parts = strNS.split('.');
                var parent = this;
                var pl;
                pl = parts.length;
                for (var i = 0; i < pl; i++) {
                    if (typeof parent[parts[i]] === 'undefined') {
                        parent[parts[i]] = {};
                    }
                    var n = pl - 1;
                    if (i === n) {
                        parent[parts[i]] = value;
                    }
                    parent = parent[parts[i]];
                }
                return this;
            }
        };
        Gp.extend('Protocols', {});
        Gp.extend('Protocols.XHR', XHR);
        Gp.extend('Services', Services);
        Gp.extend('Services.AltiResponse', AltiResponse);
        Gp.extend('Services.Alti.Elevation', Elevation);
        Gp.extend('Services.AutoCompleteResponse', AutoCompleteResponse);
        Gp.extend('Services.AutoComplete.SuggestedLocation', SuggestedLocation);
        Gp.extend('Services.GetConfigResponse', GetConfigResponse);
        Gp.extend('Services.Config.Constraint', Constraint);
        Gp.extend('Services.Config.Format', Format);
        Gp.extend('Services.Config.Layer', Layer);
        Gp.extend('Services.Config.Legend', Legend);
        Gp.extend('Services.Config.Metadata', Metadata);
        Gp.extend('Services.Config.Originator', Originator);
        Gp.extend('Services.Config.Service', Service);
        Gp.extend('Services.Config.Style', Style);
        Gp.extend('Services.Config.Territory', Territory);
        Gp.extend('Services.Config.Thematic', SuggestedLocation);
        Gp.extend('Services.Config.TileMatrix', TM);
        Gp.extend('Services.Config.TileMatrixLimit', TMLimit);
        Gp.extend('Services.Config.TileMatrixSet', TMS);
        Gp.extend('Services.GeocodeResponse', GeocodeResponse);
        Gp.extend('Services.Geocode.GeocodedLocation', GeocodedLocation);
        Gp.extend('Services.Geocode.DirectGeocodedLocation', DirectGeocodedLocation);
        Gp.extend('Services.Geocode.ReverseGeocodedLocation', ReverseGeocodedLocation);
        Gp.extend('Services.IsoCurveResponse', IsoCurveResponse);
        Gp.extend('Services.RouteResponse', RouteResponse);
        Gp.extend('Services.Route.RouteInstruction', RouteInstruction);
        Gp.extend('Error', Error);
        Gp.extend('Helper', Helper);
        Gp.extend('Services.DefaultUrl', DefaultUrl);
        scope.Gp = Gp;
        return scope.Gp;
    }(ProtocolsXHR, ServicesServices, ServicesAltiResponseModelAltiResponse, ServicesAltiResponseModelElevation, ServicesAutoCompleteResponseModelAutoCompleteResponse, ServicesAutoCompleteResponseModelSuggestedLocation, ServicesAutoConfResponseModelAutoConfResponse, ServicesAutoConfResponseModelConstraint, ServicesAutoConfResponseModelFormat, ServicesAutoConfResponseModelLayer, ServicesAutoConfResponseModelLegend, ServicesAutoConfResponseModelMetadata, ServicesAutoConfResponseModelOriginator, ServicesAutoConfResponseModelService, ServicesAutoConfResponseModelStyle, ServicesAutoConfResponseModelTerritory, ServicesAutoConfResponseModelThematic, ServicesAutoConfResponseModelTileMatrix, ServicesAutoConfResponseModelTileMatrixLimit, ServicesAutoConfResponseModelTileMatrixSet, ServicesGeocodeResponseModelGeocodeResponse, ServicesGeocodeResponseModelGeocodedLocation, ServicesGeocodeResponseModelDirectGeocodedLocation, ServicesGeocodeResponseModelReverseGeocodedLocation, ServicesProcessIsoCurveResponseModelProcessIsoCurveResponse, ServicesRouteResponseModelRouteResponse, ServicesRouteResponseModelRouteInstruction, ExceptionsErrorService, UtilsHelper, ServicesDefaultUrlService);
    return Gp;
}));
CommonUtilsAutoLoadConfig = function (Gp) {
    (function () {
        var scripts = document.getElementsByTagName('script');
        var key = scripts[scripts.length - 1].getAttribute('data-key');
        if (key) {
            var splitKeys = key.split(/;|,|\|/);
            if (key && splitKeys.length > 1) {
                var keys = [];
                for (var i = 0; i < splitKeys.length; i++) {
                    keys.push(splitKeys[i]);
                }
                key = keys;
            }
        }
        var url = scripts[scripts.length - 1].getAttribute('data-url');
        var timeout = scripts[scripts.length - 1].getAttribute('data-timeout');
        var success = function () {
        };
        var error = function (e) {
            throw new Error('Configuration load failed : ' + e.message);
        };
        if (!key && !url) {
            return;
        }
        var options = {
            apiKey: key,
            onSuccess: success,
            onFailure: error
        };
        if (url) {
            options.serverUrl = url;
            options.callbackSuffix = '';
        }
        if (timeout) {
            options.timeOut = timeout;
        }
        if (!Gp.Config) {
            Gp.Services.getConfig(options);
        }
    }());
}(gp);
CommonUtilsLayerUtils = function () {
    var LayerUtils = {
        getZoomLevelFromScaleDenominator: function (scaleDenominator, crs) {
            var resolutionsNatives = {};
            switch (crs) {
            case 'EPSG:2154':
                resolutionsNatives = {
                    0: 104579.224549894,
                    1: 52277.5323537905,
                    2: 26135.4870785954,
                    3: 13066.8913818,
                    4: 6533.2286041135,
                    5: 3266.5595244627,
                    6: 1633.2660045974,
                    7: 816.629554986,
                    8: 408.3139146768,
                    9: 204.1567415109,
                    10: 102.0783167832,
                    11: 51.0391448966,
                    12: 25.5195690743,
                    13: 12.7597836936,
                    14: 6.379891636,
                    15: 3.1899457653,
                    16: 1.5949728695,
                    17: 0.7974864315,
                    18: 0.3987432149,
                    19: 0.1993716073,
                    20: 0.0996858037,
                    21: 0.0498429018
                };
                break;
            default:
                resolutionsNatives = {
                    0: 156543.033928041,
                    1: 78271.51696402048,
                    2: 39135.758482010235,
                    3: 19567.87924100512,
                    4: 9783.93962050256,
                    5: 4891.96981025128,
                    6: 2445.98490512564,
                    7: 1222.99245256282,
                    8: 611.49622628141,
                    9: 305.7481131407048,
                    10: 152.8740565703525,
                    11: 76.43702828517624,
                    12: 38.21851414258813,
                    13: 19.10925707129406,
                    14: 9.554628535647032,
                    15: 4.777314267823516,
                    16: 2.388657133911758,
                    17: 1.194328566955879,
                    18: 0.5971642834779395,
                    19: 0.2985821417389697,
                    20: 0.1492910708694849,
                    21: 0.0746455354347424
                };
                break;
            }
            var resolution = scaleDenominator * 0.00028;
            for (var index in resolutionsNatives) {
                if (resolutionsNatives.hasOwnProperty(index)) {
                    if (resolutionsNatives[index] <= resolution) {
                        index = parseInt(index, 10);
                        return index;
                    }
                }
            }
            return 0;
        },
        getAttributions: function (params) {
            var zoom = params.zoom;
            var attributions = [];
            if (params.originators != null && params.visibility) {
                var drawLogo;
                for (var j = 0, jl = params.originators.length; j < jl; j++) {
                    drawLogo = true;
                    var originator = params.originators[j];
                    var constraints = params.originators[j].constraints || [];
                    for (var k = 0, kl = constraints.length; k < kl; k++) {
                        var constraint = constraints[k];
                        drawLogo = true;
                        var minZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.maxScaleDenominator, params.crs);
                        var maxZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.minScaleDenominator, params.crs) || 21;
                        if (minZoomLevel && minZoomLevel > zoom) {
                            drawLogo = false;
                        }
                        if (drawLogo && maxZoomLevel !== null && maxZoomLevel < zoom) {
                            drawLogo = false;
                        }
                        var bbox = constraint.bbox;
                        if (drawLogo && bbox) {
                            drawLogo = false;
                            var viewExtent = params.extent;
                            if (viewExtent) {
                                var bounds = [
                                    bbox.top,
                                    bbox.left,
                                    bbox.bottom,
                                    bbox.right
                                ];
                                if (this.intersects(viewExtent, bounds)) {
                                    drawLogo = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (drawLogo) {
                        var logo = originator.logo;
                        var url = originator.url;
                        var name = originator.name ? originator.name : '';
                        var text = originator.attribution;
                        var container = document.createElement('div');
                        container.className = 'gp-control-attribution';
                        var link = null;
                        link = document.createElement('a');
                        link.className = 'gp-control-attribution-link';
                        link.target = '_blank';
                        container.appendChild(link);
                        if (url) {
                            link.href = url;
                        }
                        var bImage = logo ? true : false;
                        var image = null;
                        if (bImage) {
                            image = document.createElement('img');
                            if (link) {
                                image.className = 'gp-control-attribution-image';
                                link.appendChild(image);
                            } else {
                                image.className = '';
                                container.appendChild(image);
                            }
                            image.src = logo;
                            image.title = text || name;
                            image.style.height = '30px';
                            image.style.width = '30px';
                        } else {
                            if (name) {
                                link.textContent = name;
                            } else if (text) {
                                link.textContent = text;
                            } else if (url) {
                                link.textContent = url;
                            } else {
                                link.textContent = '';
                            }
                        }
                        attributions.push(container.innerHTML + ' ');
                    }
                }
            }
            return attributions;
        },
        intersects: function (extent1, extent2) {
            var intersectsX = extent1[1] <= extent2[3] && extent2[1] <= extent1[3];
            var intersectsY = extent1[2] <= extent2[0] && extent2[2] <= extent1[0];
            return intersectsX && intersectsY;
        }
    };
    return LayerUtils;
}();
!function (e) {
    if ('object' == typeof exports)
        module.exports = e();
    else if (true)
        proj4 = function () {
            return typeof e === 'function' ? e() : e;
        }();
    else {
        var f;
        'undefined' != typeof window ? f = window : 'undefined' != typeof global ? f = global : 'undefined' != typeof self && (f = self), f.proj4 = e();
    }
}(function () {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == 'function' && require;
                    if (!u && a)
                        return a(o, !0);
                    if (i)
                        return i(o, !0);
                    throw new Error('Cannot find module \'' + o + '\'');
                }
                var f = n[o] = { exports: {} };
                t[o][0].call(f.exports, function (e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, f, f.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == 'function' && require;
        for (var o = 0; o < r.length; o++)
            s(r[o]);
        return s;
    }({
        1: [
            function (_dereq_, module, exports) {
                var mgrs = _dereq_('mgrs');
                function Point(x, y, z) {
                    if (!(this instanceof Point)) {
                        return new Point(x, y, z);
                    }
                    if (Array.isArray(x)) {
                        this.x = x[0];
                        this.y = x[1];
                        this.z = x[2] || 0;
                    } else if (typeof x === 'object') {
                        this.x = x.x;
                        this.y = x.y;
                        this.z = x.z || 0;
                    } else if (typeof x === 'string' && typeof y === 'undefined') {
                        var coords = x.split(',');
                        this.x = parseFloat(coords[0], 10);
                        this.y = parseFloat(coords[1], 10);
                        this.z = parseFloat(coords[2], 10) || 0;
                    } else {
                        this.x = x;
                        this.y = y;
                        this.z = z || 0;
                    }
                    console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
                }
                Point.fromMGRS = function (mgrsStr) {
                    return new Point(mgrs.toPoint(mgrsStr));
                };
                Point.prototype.toMGRS = function (accuracy) {
                    return mgrs.forward([
                        this.x,
                        this.y
                    ], accuracy);
                };
                module.exports = Point;
                return exports;
            },
            { 'mgrs': 66 }
        ],
        2: [
            function (_dereq_, module, exports) {
                var parseCode = _dereq_('./parseCode');
                var extend = _dereq_('./extend');
                var projections = _dereq_('./projections');
                var deriveConstants = _dereq_('./deriveConstants');
                function Projection(srsCode, callback) {
                    if (!(this instanceof Projection)) {
                        return new Projection(srsCode);
                    }
                    callback = callback || function (error) {
                        if (error) {
                            throw error;
                        }
                    };
                    var json = parseCode(srsCode);
                    if (typeof json !== 'object') {
                        callback(srsCode);
                        return;
                    }
                    var modifiedJSON = deriveConstants(json);
                    var ourProj = Projection.projections.get(modifiedJSON.projName);
                    if (ourProj) {
                        extend(this, modifiedJSON);
                        extend(this, ourProj);
                        this.init();
                        callback(null, this);
                    } else {
                        callback(srsCode);
                    }
                }
                Projection.projections = projections;
                Projection.projections.start();
                module.exports = Projection;
                return exports;
            },
            {
                './deriveConstants': 32,
                './extend': 33,
                './parseCode': 36,
                './projections': 38
            }
        ],
        3: [
            function (_dereq_, module, exports) {
                module.exports = function (crs, denorm, point) {
                    var xin = point.x, yin = point.y, zin = point.z || 0;
                    var v, t, i;
                    for (i = 0; i < 3; i++) {
                        if (denorm && i === 2 && point.z === undefined) {
                            continue;
                        }
                        if (i === 0) {
                            v = xin;
                            t = 'x';
                        } else if (i === 1) {
                            v = yin;
                            t = 'y';
                        } else {
                            v = zin;
                            t = 'z';
                        }
                        switch (crs.axis[i]) {
                        case 'e':
                            point[t] = v;
                            break;
                        case 'w':
                            point[t] = -v;
                            break;
                        case 'n':
                            point[t] = v;
                            break;
                        case 's':
                            point[t] = -v;
                            break;
                        case 'u':
                            if (point[t] !== undefined) {
                                point.z = v;
                            }
                            break;
                        case 'd':
                            if (point[t] !== undefined) {
                                point.z = -v;
                            }
                            break;
                        default:
                            return null;
                        }
                    }
                    return point;
                };
                return exports;
            },
            {}
        ],
        4: [
            function (_dereq_, module, exports) {
                var HALF_PI = Math.PI / 2;
                var sign = _dereq_('./sign');
                module.exports = function (x) {
                    return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
                };
                return exports;
            },
            { './sign': 21 }
        ],
        5: [
            function (_dereq_, module, exports) {
                var TWO_PI = Math.PI * 2;
                var sign = _dereq_('./sign');
                module.exports = function (x) {
                    return Math.abs(x) < Math.PI ? x : x - sign(x) * TWO_PI;
                };
                return exports;
            },
            { './sign': 21 }
        ],
        6: [
            function (_dereq_, module, exports) {
                module.exports = function (x) {
                    if (Math.abs(x) > 1) {
                        x = x > 1 ? 1 : -1;
                    }
                    return Math.asin(x);
                };
                return exports;
            },
            {}
        ],
        7: [
            function (_dereq_, module, exports) {
                module.exports = function (x) {
                    return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
                };
                return exports;
            },
            {}
        ],
        8: [
            function (_dereq_, module, exports) {
                module.exports = function (x) {
                    return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
                };
                return exports;
            },
            {}
        ],
        9: [
            function (_dereq_, module, exports) {
                module.exports = function (x) {
                    return 0.05859375 * x * x * (1 + 0.75 * x);
                };
                return exports;
            },
            {}
        ],
        10: [
            function (_dereq_, module, exports) {
                module.exports = function (x) {
                    return x * x * x * (35 / 3072);
                };
                return exports;
            },
            {}
        ],
        11: [
            function (_dereq_, module, exports) {
                module.exports = function (a, e, sinphi) {
                    var temp = e * sinphi;
                    return a / Math.sqrt(1 - temp * temp);
                };
                return exports;
            },
            {}
        ],
        12: [
            function (_dereq_, module, exports) {
                module.exports = function (ml, e0, e1, e2, e3) {
                    var phi;
                    var dphi;
                    phi = ml / e0;
                    for (var i = 0; i < 15; i++) {
                        dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
                        phi += dphi;
                        if (Math.abs(dphi) <= 1e-10) {
                            return phi;
                        }
                    }
                    return NaN;
                };
                return exports;
            },
            {}
        ],
        13: [
            function (_dereq_, module, exports) {
                var HALF_PI = Math.PI / 2;
                module.exports = function (eccent, q) {
                    var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
                    if (Math.abs(Math.abs(q) - temp) < 0.000001) {
                        if (q < 0) {
                            return -1 * HALF_PI;
                        } else {
                            return HALF_PI;
                        }
                    }
                    var phi = Math.asin(0.5 * q);
                    var dphi;
                    var sin_phi;
                    var cos_phi;
                    var con;
                    for (var i = 0; i < 30; i++) {
                        sin_phi = Math.sin(phi);
                        cos_phi = Math.cos(phi);
                        con = eccent * sin_phi;
                        dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
                        phi += dphi;
                        if (Math.abs(dphi) <= 1e-10) {
                            return phi;
                        }
                    }
                    return NaN;
                };
                return exports;
            },
            {}
        ],
        14: [
            function (_dereq_, module, exports) {
                module.exports = function (e0, e1, e2, e3, phi) {
                    return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
                };
                return exports;
            },
            {}
        ],
        15: [
            function (_dereq_, module, exports) {
                module.exports = function (eccent, sinphi, cosphi) {
                    var con = eccent * sinphi;
                    return cosphi / Math.sqrt(1 - con * con);
                };
                return exports;
            },
            {}
        ],
        16: [
            function (_dereq_, module, exports) {
                var HALF_PI = Math.PI / 2;
                module.exports = function (eccent, ts) {
                    var eccnth = 0.5 * eccent;
                    var con, dphi;
                    var phi = HALF_PI - 2 * Math.atan(ts);
                    for (var i = 0; i <= 15; i++) {
                        con = eccent * Math.sin(phi);
                        dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
                        phi += dphi;
                        if (Math.abs(dphi) <= 1e-10) {
                            return phi;
                        }
                    }
                    return -9999;
                };
                return exports;
            },
            {}
        ],
        17: [
            function (_dereq_, module, exports) {
                var C00 = 1;
                var C02 = 0.25;
                var C04 = 0.046875;
                var C06 = 0.01953125;
                var C08 = 0.01068115234375;
                var C22 = 0.75;
                var C44 = 0.46875;
                var C46 = 0.013020833333333334;
                var C48 = 0.007120768229166667;
                var C66 = 0.3645833333333333;
                var C68 = 0.005696614583333333;
                var C88 = 0.3076171875;
                module.exports = function (es) {
                    var en = [];
                    en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
                    en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
                    var t = es * es;
                    en[2] = t * (C44 - es * (C46 + es * C48));
                    t *= es;
                    en[3] = t * (C66 - es * C68);
                    en[4] = t * es * C88;
                    return en;
                };
                return exports;
            },
            {}
        ],
        18: [
            function (_dereq_, module, exports) {
                var pj_mlfn = _dereq_('./pj_mlfn');
                var EPSLN = 1e-10;
                var MAX_ITER = 20;
                module.exports = function (arg, es, en) {
                    var k = 1 / (1 - es);
                    var phi = arg;
                    for (var i = MAX_ITER; i; --i) {
                        var s = Math.sin(phi);
                        var t = 1 - es * s * s;
                        t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
                        phi -= t;
                        if (Math.abs(t) < EPSLN) {
                            return phi;
                        }
                    }
                    return phi;
                };
                return exports;
            },
            { './pj_mlfn': 19 }
        ],
        19: [
            function (_dereq_, module, exports) {
                module.exports = function (phi, sphi, cphi, en) {
                    cphi *= sphi;
                    sphi *= sphi;
                    return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
                };
                return exports;
            },
            {}
        ],
        20: [
            function (_dereq_, module, exports) {
                module.exports = function (eccent, sinphi) {
                    var con;
                    if (eccent > 1e-7) {
                        con = eccent * sinphi;
                        return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
                    } else {
                        return 2 * sinphi;
                    }
                };
                return exports;
            },
            {}
        ],
        21: [
            function (_dereq_, module, exports) {
                module.exports = function (x) {
                    return x < 0 ? -1 : 1;
                };
                return exports;
            },
            {}
        ],
        22: [
            function (_dereq_, module, exports) {
                module.exports = function (esinp, exp) {
                    return Math.pow((1 - esinp) / (1 + esinp), exp);
                };
                return exports;
            },
            {}
        ],
        23: [
            function (_dereq_, module, exports) {
                module.exports = function (array) {
                    var out = {
                        x: array[0],
                        y: array[1]
                    };
                    if (array.length > 2) {
                        out.z = array[2];
                    }
                    if (array.length > 3) {
                        out.m = array[3];
                    }
                    return out;
                };
                return exports;
            },
            {}
        ],
        24: [
            function (_dereq_, module, exports) {
                var HALF_PI = Math.PI / 2;
                module.exports = function (eccent, phi, sinphi) {
                    var con = eccent * sinphi;
                    var com = 0.5 * eccent;
                    con = Math.pow((1 - con) / (1 + con), com);
                    return Math.tan(0.5 * (HALF_PI - phi)) / con;
                };
                return exports;
            },
            {}
        ],
        25: [
            function (_dereq_, module, exports) {
                exports.wgs84 = {
                    towgs84: '0,0,0',
                    ellipse: 'WGS84',
                    datumName: 'WGS84'
                };
                exports.ch1903 = {
                    towgs84: '674.374,15.056,405.346',
                    ellipse: 'bessel',
                    datumName: 'swiss'
                };
                exports.ggrs87 = {
                    towgs84: '-199.87,74.79,246.62',
                    ellipse: 'GRS80',
                    datumName: 'Greek_Geodetic_Reference_System_1987'
                };
                exports.nad83 = {
                    towgs84: '0,0,0',
                    ellipse: 'GRS80',
                    datumName: 'North_American_Datum_1983'
                };
                exports.nad27 = {
                    nadgrids: '@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat',
                    ellipse: 'clrk66',
                    datumName: 'North_American_Datum_1927'
                };
                exports.potsdam = {
                    towgs84: '606.0,23.0,413.0',
                    ellipse: 'bessel',
                    datumName: 'Potsdam Rauenberg 1950 DHDN'
                };
                exports.carthage = {
                    towgs84: '-263.0,6.0,431.0',
                    ellipse: 'clark80',
                    datumName: 'Carthage 1934 Tunisia'
                };
                exports.hermannskogel = {
                    towgs84: '653.0,-212.0,449.0',
                    ellipse: 'bessel',
                    datumName: 'Hermannskogel'
                };
                exports.ire65 = {
                    towgs84: '482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15',
                    ellipse: 'mod_airy',
                    datumName: 'Ireland 1965'
                };
                exports.rassadiran = {
                    towgs84: '-133.63,-157.5,-158.62',
                    ellipse: 'intl',
                    datumName: 'Rassadiran'
                };
                exports.nzgd49 = {
                    towgs84: '59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993',
                    ellipse: 'intl',
                    datumName: 'New Zealand Geodetic Datum 1949'
                };
                exports.osgb36 = {
                    towgs84: '446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894',
                    ellipse: 'airy',
                    datumName: 'Airy 1830'
                };
                exports.s_jtsk = {
                    towgs84: '589,76,480',
                    ellipse: 'bessel',
                    datumName: 'S-JTSK (Ferro)'
                };
                exports.beduaram = {
                    towgs84: '-106,-87,188',
                    ellipse: 'clrk80',
                    datumName: 'Beduaram'
                };
                exports.gunung_segara = {
                    towgs84: '-403,684,41',
                    ellipse: 'bessel',
                    datumName: 'Gunung Segara Jakarta'
                };
                exports.rnb72 = {
                    towgs84: '106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1',
                    ellipse: 'intl',
                    datumName: 'Reseau National Belge 1972'
                };
                return exports;
            },
            {}
        ],
        26: [
            function (_dereq_, module, exports) {
                exports.MERIT = {
                    a: 6378137,
                    rf: 298.257,
                    ellipseName: 'MERIT 1983'
                };
                exports.SGS85 = {
                    a: 6378136,
                    rf: 298.257,
                    ellipseName: 'Soviet Geodetic System 85'
                };
                exports.GRS80 = {
                    a: 6378137,
                    rf: 298.257222101,
                    ellipseName: 'GRS 1980(IUGG, 1980)'
                };
                exports.IAU76 = {
                    a: 6378140,
                    rf: 298.257,
                    ellipseName: 'IAU 1976'
                };
                exports.airy = {
                    a: 6377563.396,
                    b: 6356256.91,
                    ellipseName: 'Airy 1830'
                };
                exports.APL4 = {
                    a: 6378137,
                    rf: 298.25,
                    ellipseName: 'Appl. Physics. 1965'
                };
                exports.NWL9D = {
                    a: 6378145,
                    rf: 298.25,
                    ellipseName: 'Naval Weapons Lab., 1965'
                };
                exports.mod_airy = {
                    a: 6377340.189,
                    b: 6356034.446,
                    ellipseName: 'Modified Airy'
                };
                exports.andrae = {
                    a: 6377104.43,
                    rf: 300,
                    ellipseName: 'Andrae 1876 (Den., Iclnd.)'
                };
                exports.aust_SA = {
                    a: 6378160,
                    rf: 298.25,
                    ellipseName: 'Australian Natl & S. Amer. 1969'
                };
                exports.GRS67 = {
                    a: 6378160,
                    rf: 298.247167427,
                    ellipseName: 'GRS 67(IUGG 1967)'
                };
                exports.bessel = {
                    a: 6377397.155,
                    rf: 299.1528128,
                    ellipseName: 'Bessel 1841'
                };
                exports.bess_nam = {
                    a: 6377483.865,
                    rf: 299.1528128,
                    ellipseName: 'Bessel 1841 (Namibia)'
                };
                exports.clrk66 = {
                    a: 6378206.4,
                    b: 6356583.8,
                    ellipseName: 'Clarke 1866'
                };
                exports.clrk80 = {
                    a: 6378249.145,
                    rf: 293.4663,
                    ellipseName: 'Clarke 1880 mod.'
                };
                exports.clrk58 = {
                    a: 6378293.645208759,
                    rf: 294.2606763692654,
                    ellipseName: 'Clarke 1858'
                };
                exports.CPM = {
                    a: 6375738.7,
                    rf: 334.29,
                    ellipseName: 'Comm. des Poids et Mesures 1799'
                };
                exports.delmbr = {
                    a: 6376428,
                    rf: 311.5,
                    ellipseName: 'Delambre 1810 (Belgium)'
                };
                exports.engelis = {
                    a: 6378136.05,
                    rf: 298.2566,
                    ellipseName: 'Engelis 1985'
                };
                exports.evrst30 = {
                    a: 6377276.345,
                    rf: 300.8017,
                    ellipseName: 'Everest 1830'
                };
                exports.evrst48 = {
                    a: 6377304.063,
                    rf: 300.8017,
                    ellipseName: 'Everest 1948'
                };
                exports.evrst56 = {
                    a: 6377301.243,
                    rf: 300.8017,
                    ellipseName: 'Everest 1956'
                };
                exports.evrst69 = {
                    a: 6377295.664,
                    rf: 300.8017,
                    ellipseName: 'Everest 1969'
                };
                exports.evrstSS = {
                    a: 6377298.556,
                    rf: 300.8017,
                    ellipseName: 'Everest (Sabah & Sarawak)'
                };
                exports.fschr60 = {
                    a: 6378166,
                    rf: 298.3,
                    ellipseName: 'Fischer (Mercury Datum) 1960'
                };
                exports.fschr60m = {
                    a: 6378155,
                    rf: 298.3,
                    ellipseName: 'Fischer 1960'
                };
                exports.fschr68 = {
                    a: 6378150,
                    rf: 298.3,
                    ellipseName: 'Fischer 1968'
                };
                exports.helmert = {
                    a: 6378200,
                    rf: 298.3,
                    ellipseName: 'Helmert 1906'
                };
                exports.hough = {
                    a: 6378270,
                    rf: 297,
                    ellipseName: 'Hough'
                };
                exports.intl = {
                    a: 6378388,
                    rf: 297,
                    ellipseName: 'International 1909 (Hayford)'
                };
                exports.kaula = {
                    a: 6378163,
                    rf: 298.24,
                    ellipseName: 'Kaula 1961'
                };
                exports.lerch = {
                    a: 6378139,
                    rf: 298.257,
                    ellipseName: 'Lerch 1979'
                };
                exports.mprts = {
                    a: 6397300,
                    rf: 191,
                    ellipseName: 'Maupertius 1738'
                };
                exports.new_intl = {
                    a: 6378157.5,
                    b: 6356772.2,
                    ellipseName: 'New International 1967'
                };
                exports.plessis = {
                    a: 6376523,
                    rf: 6355863,
                    ellipseName: 'Plessis 1817 (France)'
                };
                exports.krass = {
                    a: 6378245,
                    rf: 298.3,
                    ellipseName: 'Krassovsky, 1942'
                };
                exports.SEasia = {
                    a: 6378155,
                    b: 6356773.3205,
                    ellipseName: 'Southeast Asia'
                };
                exports.walbeck = {
                    a: 6376896,
                    b: 6355834.8467,
                    ellipseName: 'Walbeck'
                };
                exports.WGS60 = {
                    a: 6378165,
                    rf: 298.3,
                    ellipseName: 'WGS 60'
                };
                exports.WGS66 = {
                    a: 6378145,
                    rf: 298.25,
                    ellipseName: 'WGS 66'
                };
                exports.WGS7 = {
                    a: 6378135,
                    rf: 298.26,
                    ellipseName: 'WGS 72'
                };
                exports.WGS84 = {
                    a: 6378137,
                    rf: 298.257223563,
                    ellipseName: 'WGS 84'
                };
                exports.sphere = {
                    a: 6370997,
                    b: 6370997,
                    ellipseName: 'Normal Sphere (r=6370997)'
                };
                return exports;
            },
            {}
        ],
        27: [
            function (_dereq_, module, exports) {
                exports.greenwich = 0;
                exports.lisbon = -9.131906111111;
                exports.paris = 2.337229166667;
                exports.bogota = -74.080916666667;
                exports.madrid = -3.687938888889;
                exports.rome = 12.452333333333;
                exports.bern = 7.439583333333;
                exports.jakarta = 106.807719444444;
                exports.ferro = -17.666666666667;
                exports.brussels = 4.367975;
                exports.stockholm = 18.058277777778;
                exports.athens = 23.7163375;
                exports.oslo = 10.722916666667;
                return exports;
            },
            {}
        ],
        28: [
            function (_dereq_, module, exports) {
                var proj = _dereq_('./Proj');
                var transform = _dereq_('./transform');
                var wgs84 = proj('WGS84');
                function transformer(from, to, coords) {
                    var transformedArray;
                    if (Array.isArray(coords)) {
                        transformedArray = transform(from, to, coords);
                        if (coords.length === 3) {
                            return [
                                transformedArray.x,
                                transformedArray.y,
                                transformedArray.z
                            ];
                        } else {
                            return [
                                transformedArray.x,
                                transformedArray.y
                            ];
                        }
                    } else {
                        return transform(from, to, coords);
                    }
                }
                function checkProj(item) {
                    if (item instanceof proj) {
                        return item;
                    }
                    if (item.oProj) {
                        return item.oProj;
                    }
                    return proj(item);
                }
                function proj4(fromProj, toProj, coord) {
                    fromProj = checkProj(fromProj);
                    var single = false;
                    var obj;
                    if (typeof toProj === 'undefined') {
                        toProj = fromProj;
                        fromProj = wgs84;
                        single = true;
                    } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
                        coord = toProj;
                        toProj = fromProj;
                        fromProj = wgs84;
                        single = true;
                    }
                    toProj = checkProj(toProj);
                    if (coord) {
                        return transformer(fromProj, toProj, coord);
                    } else {
                        obj = {
                            forward: function (coords) {
                                return transformer(fromProj, toProj, coords);
                            },
                            inverse: function (coords) {
                                return transformer(toProj, fromProj, coords);
                            }
                        };
                        if (single) {
                            obj.oProj = toProj;
                        }
                        return obj;
                    }
                }
                module.exports = proj4;
                return exports;
            },
            {
                './Proj': 2,
                './transform': 64
            }
        ],
        29: [
            function (_dereq_, module, exports) {
                var HALF_PI = Math.PI / 2;
                var PJD_3PARAM = 1;
                var PJD_7PARAM = 2;
                var PJD_GRIDSHIFT = 3;
                var PJD_WGS84 = 4;
                var PJD_NODATUM = 5;
                var SEC_TO_RAD = 0.00000484813681109536;
                var AD_C = 1.0026;
                var COS_67P5 = 0.3826834323650898;
                var datum = function (proj) {
                    if (!(this instanceof datum)) {
                        return new datum(proj);
                    }
                    this.datum_type = PJD_WGS84;
                    if (!proj) {
                        return;
                    }
                    if (proj.datumCode && proj.datumCode === 'none') {
                        this.datum_type = PJD_NODATUM;
                    }
                    if (proj.datum_params) {
                        for (var i = 0; i < proj.datum_params.length; i++) {
                            proj.datum_params[i] = parseFloat(proj.datum_params[i]);
                        }
                        if (proj.datum_params[0] !== 0 || proj.datum_params[1] !== 0 || proj.datum_params[2] !== 0) {
                            this.datum_type = PJD_3PARAM;
                        }
                        if (proj.datum_params.length > 3) {
                            if (proj.datum_params[3] !== 0 || proj.datum_params[4] !== 0 || proj.datum_params[5] !== 0 || proj.datum_params[6] !== 0) {
                                this.datum_type = PJD_7PARAM;
                                proj.datum_params[3] *= SEC_TO_RAD;
                                proj.datum_params[4] *= SEC_TO_RAD;
                                proj.datum_params[5] *= SEC_TO_RAD;
                                proj.datum_params[6] = proj.datum_params[6] / 1000000 + 1;
                            }
                        }
                    }
                    this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;
                    this.a = proj.a;
                    this.b = proj.b;
                    this.es = proj.es;
                    this.ep2 = proj.ep2;
                    this.datum_params = proj.datum_params;
                    if (this.datum_type === PJD_GRIDSHIFT) {
                        this.grids = proj.grids;
                    }
                };
                datum.prototype = {
                    compare_datums: function (dest) {
                        if (this.datum_type !== dest.datum_type) {
                            return false;
                        } else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 5e-11) {
                            return false;
                        } else if (this.datum_type === PJD_3PARAM) {
                            return this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2];
                        } else if (this.datum_type === PJD_7PARAM) {
                            return this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6];
                        } else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {
                            return this.nadgrids === dest.nadgrids;
                        } else {
                            return true;
                        }
                    },
                    geodetic_to_geocentric: function (p) {
                        var Longitude = p.x;
                        var Latitude = p.y;
                        var Height = p.z ? p.z : 0;
                        var X;
                        var Y;
                        var Z;
                        var Error_Code = 0;
                        var Rn;
                        var Sin_Lat;
                        var Sin2_Lat;
                        var Cos_Lat;
                        if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
                            Latitude = -HALF_PI;
                        } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
                            Latitude = HALF_PI;
                        } else if (Latitude < -HALF_PI || Latitude > HALF_PI) {
                            return null;
                        }
                        if (Longitude > Math.PI) {
                            Longitude -= 2 * Math.PI;
                        }
                        Sin_Lat = Math.sin(Latitude);
                        Cos_Lat = Math.cos(Latitude);
                        Sin2_Lat = Sin_Lat * Sin_Lat;
                        Rn = this.a / Math.sqrt(1 - this.es * Sin2_Lat);
                        X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);
                        Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);
                        Z = (Rn * (1 - this.es) + Height) * Sin_Lat;
                        p.x = X;
                        p.y = Y;
                        p.z = Z;
                        return Error_Code;
                    },
                    geocentric_to_geodetic: function (p) {
                        var genau = 1e-12;
                        var genau2 = genau * genau;
                        var maxiter = 30;
                        var P;
                        var RR;
                        var CT;
                        var ST;
                        var RX;
                        var RK;
                        var RN;
                        var CPHI0;
                        var SPHI0;
                        var CPHI;
                        var SPHI;
                        var SDPHI;
                        var At_Pole;
                        var iter;
                        var X = p.x;
                        var Y = p.y;
                        var Z = p.z ? p.z : 0;
                        var Longitude;
                        var Latitude;
                        var Height;
                        At_Pole = false;
                        P = Math.sqrt(X * X + Y * Y);
                        RR = Math.sqrt(X * X + Y * Y + Z * Z);
                        if (P / this.a < genau) {
                            At_Pole = true;
                            Longitude = 0;
                            if (RR / this.a < genau) {
                                Latitude = HALF_PI;
                                Height = -this.b;
                                return;
                            }
                        } else {
                            Longitude = Math.atan2(Y, X);
                        }
                        CT = Z / RR;
                        ST = P / RR;
                        RX = 1 / Math.sqrt(1 - this.es * (2 - this.es) * ST * ST);
                        CPHI0 = ST * (1 - this.es) * RX;
                        SPHI0 = CT * RX;
                        iter = 0;
                        do {
                            iter++;
                            RN = this.a / Math.sqrt(1 - this.es * SPHI0 * SPHI0);
                            Height = P * CPHI0 + Z * SPHI0 - RN * (1 - this.es * SPHI0 * SPHI0);
                            RK = this.es * RN / (RN + Height);
                            RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
                            CPHI = ST * (1 - RK) * RX;
                            SPHI = CT * RX;
                            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
                            CPHI0 = CPHI;
                            SPHI0 = SPHI;
                        } while (SDPHI * SDPHI > genau2 && iter < maxiter);
                        Latitude = Math.atan(SPHI / Math.abs(CPHI));
                        p.x = Longitude;
                        p.y = Latitude;
                        p.z = Height;
                        return p;
                    },
                    geocentric_to_geodetic_noniter: function (p) {
                        var X = p.x;
                        var Y = p.y;
                        var Z = p.z ? p.z : 0;
                        var Longitude;
                        var Latitude;
                        var Height;
                        var W;
                        var W2;
                        var T0;
                        var T1;
                        var S0;
                        var S1;
                        var Sin_B0;
                        var Sin3_B0;
                        var Cos_B0;
                        var Sin_p1;
                        var Cos_p1;
                        var Rn;
                        var Sum;
                        var At_Pole;
                        X = parseFloat(X);
                        Y = parseFloat(Y);
                        Z = parseFloat(Z);
                        At_Pole = false;
                        if (X !== 0) {
                            Longitude = Math.atan2(Y, X);
                        } else {
                            if (Y > 0) {
                                Longitude = HALF_PI;
                            } else if (Y < 0) {
                                Longitude = -HALF_PI;
                            } else {
                                At_Pole = true;
                                Longitude = 0;
                                if (Z > 0) {
                                    Latitude = HALF_PI;
                                } else if (Z < 0) {
                                    Latitude = -HALF_PI;
                                } else {
                                    Latitude = HALF_PI;
                                    Height = -this.b;
                                    return;
                                }
                            }
                        }
                        W2 = X * X + Y * Y;
                        W = Math.sqrt(W2);
                        T0 = Z * AD_C;
                        S0 = Math.sqrt(T0 * T0 + W2);
                        Sin_B0 = T0 / S0;
                        Cos_B0 = W / S0;
                        Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;
                        T1 = Z + this.b * this.ep2 * Sin3_B0;
                        Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;
                        S1 = Math.sqrt(T1 * T1 + Sum * Sum);
                        Sin_p1 = T1 / S1;
                        Cos_p1 = Sum / S1;
                        Rn = this.a / Math.sqrt(1 - this.es * Sin_p1 * Sin_p1);
                        if (Cos_p1 >= COS_67P5) {
                            Height = W / Cos_p1 - Rn;
                        } else if (Cos_p1 <= -COS_67P5) {
                            Height = W / -Cos_p1 - Rn;
                        } else {
                            Height = Z / Sin_p1 + Rn * (this.es - 1);
                        }
                        if (At_Pole === false) {
                            Latitude = Math.atan(Sin_p1 / Cos_p1);
                        }
                        p.x = Longitude;
                        p.y = Latitude;
                        p.z = Height;
                        return p;
                    },
                    geocentric_to_wgs84: function (p) {
                        if (this.datum_type === PJD_3PARAM) {
                            p.x += this.datum_params[0];
                            p.y += this.datum_params[1];
                            p.z += this.datum_params[2];
                        } else if (this.datum_type === PJD_7PARAM) {
                            var Dx_BF = this.datum_params[0];
                            var Dy_BF = this.datum_params[1];
                            var Dz_BF = this.datum_params[2];
                            var Rx_BF = this.datum_params[3];
                            var Ry_BF = this.datum_params[4];
                            var Rz_BF = this.datum_params[5];
                            var M_BF = this.datum_params[6];
                            var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;
                            var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;
                            var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
                            p.x = x_out;
                            p.y = y_out;
                            p.z = z_out;
                        }
                    },
                    geocentric_from_wgs84: function (p) {
                        if (this.datum_type === PJD_3PARAM) {
                            p.x -= this.datum_params[0];
                            p.y -= this.datum_params[1];
                            p.z -= this.datum_params[2];
                        } else if (this.datum_type === PJD_7PARAM) {
                            var Dx_BF = this.datum_params[0];
                            var Dy_BF = this.datum_params[1];
                            var Dz_BF = this.datum_params[2];
                            var Rx_BF = this.datum_params[3];
                            var Ry_BF = this.datum_params[4];
                            var Rz_BF = this.datum_params[5];
                            var M_BF = this.datum_params[6];
                            var x_tmp = (p.x - Dx_BF) / M_BF;
                            var y_tmp = (p.y - Dy_BF) / M_BF;
                            var z_tmp = (p.z - Dz_BF) / M_BF;
                            p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;
                            p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;
                            p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;
                        }
                    }
                };
                module.exports = datum;
                return exports;
            },
            {}
        ],
        30: [
            function (_dereq_, module, exports) {
                var PJD_3PARAM = 1;
                var PJD_7PARAM = 2;
                var PJD_GRIDSHIFT = 3;
                var PJD_NODATUM = 5;
                var SRS_WGS84_SEMIMAJOR = 6378137;
                var SRS_WGS84_ESQUARED = 0.006694379990141316;
                module.exports = function (source, dest, point) {
                    var wp, i, l;
                    function checkParams(fallback) {
                        return fallback === PJD_3PARAM || fallback === PJD_7PARAM;
                    }
                    if (source.compare_datums(dest)) {
                        return point;
                    }
                    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
                        return point;
                    }
                    var src_a = source.a;
                    var src_es = source.es;
                    var dst_a = dest.a;
                    var dst_es = dest.es;
                    var fallback = source.datum_type;
                    if (fallback === PJD_GRIDSHIFT) {
                        if (this.apply_gridshift(source, 0, point) === 0) {
                            source.a = SRS_WGS84_SEMIMAJOR;
                            source.es = SRS_WGS84_ESQUARED;
                        } else {
                            if (!source.datum_params) {
                                source.a = src_a;
                                source.es = source.es;
                                return point;
                            }
                            wp = 1;
                            for (i = 0, l = source.datum_params.length; i < l; i++) {
                                wp *= source.datum_params[i];
                            }
                            if (wp === 0) {
                                source.a = src_a;
                                source.es = source.es;
                                return point;
                            }
                            if (source.datum_params.length > 3) {
                                fallback = PJD_7PARAM;
                            } else {
                                fallback = PJD_3PARAM;
                            }
                        }
                    }
                    if (dest.datum_type === PJD_GRIDSHIFT) {
                        dest.a = SRS_WGS84_SEMIMAJOR;
                        dest.es = SRS_WGS84_ESQUARED;
                    }
                    if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {
                        source.geodetic_to_geocentric(point);
                        if (checkParams(source.datum_type)) {
                            source.geocentric_to_wgs84(point);
                        }
                        if (checkParams(dest.datum_type)) {
                            dest.geocentric_from_wgs84(point);
                        }
                        dest.geocentric_to_geodetic(point);
                    }
                    if (dest.datum_type === PJD_GRIDSHIFT) {
                        this.apply_gridshift(dest, 1, point);
                    }
                    source.a = src_a;
                    source.es = src_es;
                    dest.a = dst_a;
                    dest.es = dst_es;
                    return point;
                };
                return exports;
            },
            {}
        ],
        31: [
            function (_dereq_, module, exports) {
                var globals = _dereq_('./global');
                var parseProj = _dereq_('./projString');
                var wkt = _dereq_('./wkt');
                function defs(name) {
                    var that = this;
                    if (arguments.length === 2) {
                        var def = arguments[1];
                        if (typeof def === 'string') {
                            if (def[0] === '+') {
                                defs[name] = parseProj(arguments[1]);
                            } else {
                                defs[name] = wkt(arguments[1]);
                            }
                        } else {
                            defs[name] = def;
                        }
                    } else if (arguments.length === 1) {
                        if (Array.isArray(name)) {
                            return name.map(function (v) {
                                if (Array.isArray(v)) {
                                    defs.apply(that, v);
                                } else {
                                    defs(v);
                                }
                            });
                        } else if (typeof name === 'string') {
                            if (name in defs) {
                                return defs[name];
                            }
                        } else if ('EPSG' in name) {
                            defs['EPSG:' + name.EPSG] = name;
                        } else if ('ESRI' in name) {
                            defs['ESRI:' + name.ESRI] = name;
                        } else if ('IAU2000' in name) {
                            defs['IAU2000:' + name.IAU2000] = name;
                        } else {
                            console.log(name);
                        }
                        return;
                    }
                }
                globals(defs);
                module.exports = defs;
                return exports;
            },
            {
                './global': 34,
                './projString': 37,
                './wkt': 65
            }
        ],
        32: [
            function (_dereq_, module, exports) {
                var Datum = _dereq_('./constants/Datum');
                var Ellipsoid = _dereq_('./constants/Ellipsoid');
                var extend = _dereq_('./extend');
                var datum = _dereq_('./datum');
                var EPSLN = 1e-10;
                var SIXTH = 0.16666666666666666;
                var RA4 = 0.04722222222222222;
                var RA6 = 0.022156084656084655;
                module.exports = function (json) {
                    if (json.datumCode && json.datumCode !== 'none') {
                        var datumDef = Datum[json.datumCode];
                        if (datumDef) {
                            json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
                            json.ellps = datumDef.ellipse;
                            json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
                        }
                    }
                    if (!json.a) {
                        var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;
                        extend(json, ellipse);
                    }
                    if (json.rf && !json.b) {
                        json.b = (1 - 1 / json.rf) * json.a;
                    }
                    if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {
                        json.sphere = true;
                        json.b = json.a;
                    }
                    json.a2 = json.a * json.a;
                    json.b2 = json.b * json.b;
                    json.es = (json.a2 - json.b2) / json.a2;
                    json.e = Math.sqrt(json.es);
                    if (json.R_A) {
                        json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));
                        json.a2 = json.a * json.a;
                        json.b2 = json.b * json.b;
                        json.es = 0;
                    }
                    json.ep2 = (json.a2 - json.b2) / json.b2;
                    if (!json.k0) {
                        json.k0 = 1;
                    }
                    if (!json.axis) {
                        json.axis = 'enu';
                    }
                    json.datum = datum(json);
                    return json;
                };
                return exports;
            },
            {
                './constants/Datum': 25,
                './constants/Ellipsoid': 26,
                './datum': 29,
                './extend': 33
            }
        ],
        33: [
            function (_dereq_, module, exports) {
                module.exports = function (destination, source) {
                    destination = destination || {};
                    var value, property;
                    if (!source) {
                        return destination;
                    }
                    for (property in source) {
                        value = source[property];
                        if (value !== undefined) {
                            destination[property] = value;
                        }
                    }
                    return destination;
                };
                return exports;
            },
            {}
        ],
        34: [
            function (_dereq_, module, exports) {
                module.exports = function (defs) {
                    defs('EPSG:4326', '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees');
                    defs('EPSG:4269', '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees');
                    defs('EPSG:3857', '+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs');
                    defs.WGS84 = defs['EPSG:4326'];
                    defs['EPSG:3785'] = defs['EPSG:3857'];
                    defs.GOOGLE = defs['EPSG:3857'];
                    defs['EPSG:900913'] = defs['EPSG:3857'];
                    defs['EPSG:102113'] = defs['EPSG:3857'];
                };
                return exports;
            },
            {}
        ],
        35: [
            function (_dereq_, module, exports) {
                var proj4 = _dereq_('./core');
                proj4.defaultDatum = 'WGS84';
                proj4.Proj = _dereq_('./Proj');
                proj4.WGS84 = new proj4.Proj('WGS84');
                proj4.Point = _dereq_('./Point');
                proj4.toPoint = _dereq_('./common/toPoint');
                proj4.defs = _dereq_('./defs');
                proj4.transform = _dereq_('./transform');
                proj4.mgrs = _dereq_('mgrs');
                proj4.version = _dereq_('../package.json').version;
                _dereq_('./includedProjections')(proj4);
                module.exports = proj4;
                return exports;
            },
            {
                '../package.json': 67,
                './Point': 1,
                './Proj': 2,
                './common/toPoint': 23,
                './core': 28,
                './defs': 31,
                './includedProjections': 'gWUPNW',
                './transform': 64,
                'mgrs': 66
            }
        ],
        36: [
            function (_dereq_, module, exports) {
                var defs = _dereq_('./defs');
                var wkt = _dereq_('./wkt');
                var projStr = _dereq_('./projString');
                function testObj(code) {
                    return typeof code === 'string';
                }
                function testDef(code) {
                    return code in defs;
                }
                function testWKT(code) {
                    var codeWords = [
                        'GEOGCS',
                        'GEOCCS',
                        'PROJCS',
                        'LOCAL_CS'
                    ];
                    return codeWords.reduce(function (a, b) {
                        return a + 1 + code.indexOf(b);
                    }, 0);
                }
                function testProj(code) {
                    return code[0] === '+';
                }
                function parse(code) {
                    if (testObj(code)) {
                        if (testDef(code)) {
                            return defs[code];
                        } else if (testWKT(code)) {
                            return wkt(code);
                        } else if (testProj(code)) {
                            return projStr(code);
                        }
                    } else {
                        return code;
                    }
                }
                module.exports = parse;
                return exports;
            },
            {
                './defs': 31,
                './projString': 37,
                './wkt': 65
            }
        ],
        37: [
            function (_dereq_, module, exports) {
                var D2R = 0.017453292519943295;
                var PrimeMeridian = _dereq_('./constants/PrimeMeridian');
                module.exports = function (defData) {
                    var self = {};
                    var paramObj = {};
                    defData.split('+').map(function (v) {
                        return v.trim();
                    }).filter(function (a) {
                        return a;
                    }).forEach(function (a) {
                        var split = a.split('=');
                        split.push(true);
                        paramObj[split[0].toLowerCase()] = split[1];
                    });
                    var paramName, paramVal, paramOutname;
                    var params = {
                        proj: 'projName',
                        datum: 'datumCode',
                        rf: function (v) {
                            self.rf = parseFloat(v, 10);
                        },
                        lat_0: function (v) {
                            self.lat0 = v * D2R;
                        },
                        lat_1: function (v) {
                            self.lat1 = v * D2R;
                        },
                        lat_2: function (v) {
                            self.lat2 = v * D2R;
                        },
                        lat_ts: function (v) {
                            self.lat_ts = v * D2R;
                        },
                        lon_0: function (v) {
                            self.long0 = v * D2R;
                        },
                        lon_1: function (v) {
                            self.long1 = v * D2R;
                        },
                        lon_2: function (v) {
                            self.long2 = v * D2R;
                        },
                        alpha: function (v) {
                            self.alpha = parseFloat(v) * D2R;
                        },
                        lonc: function (v) {
                            self.longc = v * D2R;
                        },
                        x_0: function (v) {
                            self.x0 = parseFloat(v, 10);
                        },
                        y_0: function (v) {
                            self.y0 = parseFloat(v, 10);
                        },
                        k_0: function (v) {
                            self.k0 = parseFloat(v, 10);
                        },
                        k: function (v) {
                            self.k0 = parseFloat(v, 10);
                        },
                        r_a: function () {
                            self.R_A = true;
                        },
                        zone: function (v) {
                            self.zone = parseInt(v, 10);
                        },
                        south: function () {
                            self.utmSouth = true;
                        },
                        towgs84: function (v) {
                            self.datum_params = v.split(',').map(function (a) {
                                return parseFloat(a, 10);
                            });
                        },
                        to_meter: function (v) {
                            self.to_meter = parseFloat(v, 10);
                        },
                        from_greenwich: function (v) {
                            self.from_greenwich = v * D2R;
                        },
                        pm: function (v) {
                            self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v, 10)) * D2R;
                        },
                        nadgrids: function (v) {
                            if (v === '@null') {
                                self.datumCode = 'none';
                            } else {
                                self.nadgrids = v;
                            }
                        },
                        axis: function (v) {
                            var legalAxis = 'ewnsud';
                            if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                                self.axis = v;
                            }
                        }
                    };
                    for (paramName in paramObj) {
                        paramVal = paramObj[paramName];
                        if (paramName in params) {
                            paramOutname = params[paramName];
                            if (typeof paramOutname === 'function') {
                                paramOutname(paramVal);
                            } else {
                                self[paramOutname] = paramVal;
                            }
                        } else {
                            self[paramName] = paramVal;
                        }
                    }
                    if (typeof self.datumCode === 'string' && self.datumCode !== 'WGS84') {
                        self.datumCode = self.datumCode.toLowerCase();
                    }
                    return self;
                };
                return exports;
            },
            { './constants/PrimeMeridian': 27 }
        ],
        38: [
            function (_dereq_, module, exports) {
                var projs = [
                    _dereq_('./projections/merc'),
                    _dereq_('./projections/longlat')
                ];
                var names = {};
                var projStore = [];
                function add(proj, i) {
                    var len = projStore.length;
                    if (!proj.names) {
                        console.log(i);
                        return true;
                    }
                    projStore[len] = proj;
                    proj.names.forEach(function (n) {
                        names[n.toLowerCase()] = len;
                    });
                    return this;
                }
                exports.add = add;
                exports.get = function (name) {
                    if (!name) {
                        return false;
                    }
                    var n = name.toLowerCase();
                    if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
                        return projStore[names[n]];
                    }
                };
                exports.start = function () {
                    projs.forEach(add);
                };
                return exports;
            },
            {
                './projections/longlat': 50,
                './projections/merc': 51
            }
        ],
        39: [
            function (_dereq_, module, exports) {
                var EPSLN = 1e-10;
                var msfnz = _dereq_('../common/msfnz');
                var qsfnz = _dereq_('../common/qsfnz');
                var adjust_lon = _dereq_('../common/adjust_lon');
                var asinz = _dereq_('../common/asinz');
                exports.init = function () {
                    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
                        return;
                    }
                    this.temp = this.b / this.a;
                    this.es = 1 - Math.pow(this.temp, 2);
                    this.e3 = Math.sqrt(this.es);
                    this.sin_po = Math.sin(this.lat1);
                    this.cos_po = Math.cos(this.lat1);
                    this.t1 = this.sin_po;
                    this.con = this.sin_po;
                    this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
                    this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
                    this.sin_po = Math.sin(this.lat2);
                    this.cos_po = Math.cos(this.lat2);
                    this.t2 = this.sin_po;
                    this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
                    this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
                    this.sin_po = Math.sin(this.lat0);
                    this.cos_po = Math.cos(this.lat0);
                    this.t3 = this.sin_po;
                    this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
                    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
                        this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
                    } else {
                        this.ns0 = this.con;
                    }
                    this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
                    this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    this.sin_phi = Math.sin(lat);
                    this.cos_phi = Math.cos(lat);
                    var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
                    var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
                    var theta = this.ns0 * adjust_lon(lon - this.long0);
                    var x = rh1 * Math.sin(theta) + this.x0;
                    var y = this.rh - rh1 * Math.cos(theta) + this.y0;
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    var rh1, qs, con, theta, lon, lat;
                    p.x -= this.x0;
                    p.y = this.rh - p.y + this.y0;
                    if (this.ns0 >= 0) {
                        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
                        con = 1;
                    } else {
                        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
                        con = -1;
                    }
                    theta = 0;
                    if (rh1 !== 0) {
                        theta = Math.atan2(con * p.x, con * p.y);
                    }
                    con = rh1 * this.ns0 / this.a;
                    if (this.sphere) {
                        lat = Math.asin((this.c - con * con) / (2 * this.ns0));
                    } else {
                        qs = (this.c - con * con) / this.ns0;
                        lat = this.phi1z(this.e3, qs);
                    }
                    lon = adjust_lon(theta / this.ns0 + this.long0);
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.phi1z = function (eccent, qs) {
                    var sinphi, cosphi, con, com, dphi;
                    var phi = asinz(0.5 * qs);
                    if (eccent < EPSLN) {
                        return phi;
                    }
                    var eccnts = eccent * eccent;
                    for (var i = 1; i <= 25; i++) {
                        sinphi = Math.sin(phi);
                        cosphi = Math.cos(phi);
                        con = eccent * sinphi;
                        com = 1 - con * con;
                        dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
                        phi = phi + dphi;
                        if (Math.abs(dphi) <= 1e-7) {
                            return phi;
                        }
                    }
                    return null;
                };
                exports.names = [
                    'Albers_Conic_Equal_Area',
                    'Albers',
                    'aea'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/asinz': 6,
                '../common/msfnz': 15,
                '../common/qsfnz': 20
            }
        ],
        40: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                var HALF_PI = Math.PI / 2;
                var EPSLN = 1e-10;
                var mlfn = _dereq_('../common/mlfn');
                var e0fn = _dereq_('../common/e0fn');
                var e1fn = _dereq_('../common/e1fn');
                var e2fn = _dereq_('../common/e2fn');
                var e3fn = _dereq_('../common/e3fn');
                var gN = _dereq_('../common/gN');
                var asinz = _dereq_('../common/asinz');
                var imlfn = _dereq_('../common/imlfn');
                exports.init = function () {
                    this.sin_p12 = Math.sin(this.lat0);
                    this.cos_p12 = Math.cos(this.lat0);
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var sinphi = Math.sin(p.y);
                    var cosphi = Math.cos(p.y);
                    var dlon = adjust_lon(lon - this.long0);
                    var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
                    if (this.sphere) {
                        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
                            p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
                            p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
                            return p;
                        } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
                            p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
                            p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
                            return p;
                        } else {
                            cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
                            c = Math.acos(cos_c);
                            kp = c / Math.sin(c);
                            p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
                            p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
                            return p;
                        }
                    } else {
                        e0 = e0fn(this.es);
                        e1 = e1fn(this.es);
                        e2 = e2fn(this.es);
                        e3 = e3fn(this.es);
                        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
                            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                            Ml = this.a * mlfn(e0, e1, e2, e3, lat);
                            p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
                            p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
                            return p;
                        } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
                            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                            Ml = this.a * mlfn(e0, e1, e2, e3, lat);
                            p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
                            p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
                            return p;
                        } else {
                            tanphi = sinphi / cosphi;
                            Nl1 = gN(this.a, this.e, this.sin_p12);
                            Nl = gN(this.a, this.e, sinphi);
                            psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
                            Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
                            if (Az === 0) {
                                s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
                            } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
                                s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
                            } else {
                                s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
                            }
                            G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
                            H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
                            GH = G * H;
                            Hs = H * H;
                            s2 = s * s;
                            s3 = s2 * s;
                            s4 = s3 * s;
                            s5 = s4 * s;
                            c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
                            p.x = this.x0 + c * Math.sin(Az);
                            p.y = this.y0 + c * Math.cos(Az);
                            return p;
                        }
                    }
                };
                exports.inverse = function (p) {
                    p.x -= this.x0;
                    p.y -= this.y0;
                    var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
                    if (this.sphere) {
                        rh = Math.sqrt(p.x * p.x + p.y * p.y);
                        if (rh > 2 * HALF_PI * this.a) {
                            return;
                        }
                        z = rh / this.a;
                        sinz = Math.sin(z);
                        cosz = Math.cos(z);
                        lon = this.long0;
                        if (Math.abs(rh) <= EPSLN) {
                            lat = this.lat0;
                        } else {
                            lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
                            con = Math.abs(this.lat0) - HALF_PI;
                            if (Math.abs(con) <= EPSLN) {
                                if (this.lat0 >= 0) {
                                    lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
                                } else {
                                    lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
                                }
                            } else {
                                lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
                            }
                        }
                        p.x = lon;
                        p.y = lat;
                        return p;
                    } else {
                        e0 = e0fn(this.es);
                        e1 = e1fn(this.es);
                        e2 = e2fn(this.es);
                        e3 = e3fn(this.es);
                        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
                            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                            rh = Math.sqrt(p.x * p.x + p.y * p.y);
                            M = Mlp - rh;
                            lat = imlfn(M / this.a, e0, e1, e2, e3);
                            lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
                            p.x = lon;
                            p.y = lat;
                            return p;
                        } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
                            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                            rh = Math.sqrt(p.x * p.x + p.y * p.y);
                            M = rh - Mlp;
                            lat = imlfn(M / this.a, e0, e1, e2, e3);
                            lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
                            p.x = lon;
                            p.y = lat;
                            return p;
                        } else {
                            rh = Math.sqrt(p.x * p.x + p.y * p.y);
                            Az = Math.atan2(p.x, p.y);
                            N1 = gN(this.a, this.e, this.sin_p12);
                            cosAz = Math.cos(Az);
                            tmp = this.e * this.cos_p12 * cosAz;
                            A = -tmp * tmp / (1 - this.es);
                            B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
                            D = rh / N1;
                            Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
                            F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
                            psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
                            lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
                            lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
                            p.x = lon;
                            p.y = lat;
                            return p;
                        }
                    }
                };
                exports.names = [
                    'Azimuthal_Equidistant',
                    'aeqd'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/asinz': 6,
                '../common/e0fn': 7,
                '../common/e1fn': 8,
                '../common/e2fn': 9,
                '../common/e3fn': 10,
                '../common/gN': 11,
                '../common/imlfn': 12,
                '../common/mlfn': 14
            }
        ],
        41: [
            function (_dereq_, module, exports) {
                var mlfn = _dereq_('../common/mlfn');
                var e0fn = _dereq_('../common/e0fn');
                var e1fn = _dereq_('../common/e1fn');
                var e2fn = _dereq_('../common/e2fn');
                var e3fn = _dereq_('../common/e3fn');
                var gN = _dereq_('../common/gN');
                var adjust_lon = _dereq_('../common/adjust_lon');
                var adjust_lat = _dereq_('../common/adjust_lat');
                var imlfn = _dereq_('../common/imlfn');
                var HALF_PI = Math.PI / 2;
                var EPSLN = 1e-10;
                exports.init = function () {
                    if (!this.sphere) {
                        this.e0 = e0fn(this.es);
                        this.e1 = e1fn(this.es);
                        this.e2 = e2fn(this.es);
                        this.e3 = e3fn(this.es);
                        this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
                    }
                };
                exports.forward = function (p) {
                    var x, y;
                    var lam = p.x;
                    var phi = p.y;
                    lam = adjust_lon(lam - this.long0);
                    if (this.sphere) {
                        x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
                        y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
                    } else {
                        var sinphi = Math.sin(phi);
                        var cosphi = Math.cos(phi);
                        var nl = gN(this.a, this.e, sinphi);
                        var tl = Math.tan(phi) * Math.tan(phi);
                        var al = lam * Math.cos(phi);
                        var asq = al * al;
                        var cl = this.es * cosphi * cosphi / (1 - this.es);
                        var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
                        x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
                        y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
                    }
                    p.x = x + this.x0;
                    p.y = y + this.y0;
                    return p;
                };
                exports.inverse = function (p) {
                    p.x -= this.x0;
                    p.y -= this.y0;
                    var x = p.x / this.a;
                    var y = p.y / this.a;
                    var phi, lam;
                    if (this.sphere) {
                        var dd = y + this.lat0;
                        phi = Math.asin(Math.sin(dd) * Math.cos(x));
                        lam = Math.atan2(Math.tan(x), Math.cos(dd));
                    } else {
                        var ml1 = this.ml0 / this.a + y;
                        var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
                        if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
                            p.x = this.long0;
                            p.y = HALF_PI;
                            if (y < 0) {
                                p.y *= -1;
                            }
                            return p;
                        }
                        var nl1 = gN(this.a, this.e, Math.sin(phi1));
                        var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
                        var tl1 = Math.pow(Math.tan(phi1), 2);
                        var dl = x * this.a / nl1;
                        var dsq = dl * dl;
                        phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
                        lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
                    }
                    p.x = adjust_lon(lam + this.long0);
                    p.y = adjust_lat(phi);
                    return p;
                };
                exports.names = [
                    'Cassini',
                    'Cassini_Soldner',
                    'cass'
                ];
                return exports;
            },
            {
                '../common/adjust_lat': 4,
                '../common/adjust_lon': 5,
                '../common/e0fn': 7,
                '../common/e1fn': 8,
                '../common/e2fn': 9,
                '../common/e3fn': 10,
                '../common/gN': 11,
                '../common/imlfn': 12,
                '../common/mlfn': 14
            }
        ],
        42: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                var qsfnz = _dereq_('../common/qsfnz');
                var msfnz = _dereq_('../common/msfnz');
                var iqsfnz = _dereq_('../common/iqsfnz');
                exports.init = function () {
                    if (!this.sphere) {
                        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
                    }
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var x, y;
                    var dlon = adjust_lon(lon - this.long0);
                    if (this.sphere) {
                        x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
                        y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
                    } else {
                        var qs = qsfnz(this.e, Math.sin(lat));
                        x = this.x0 + this.a * this.k0 * dlon;
                        y = this.y0 + this.a * qs * 0.5 / this.k0;
                    }
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    p.x -= this.x0;
                    p.y -= this.y0;
                    var lon, lat;
                    if (this.sphere) {
                        lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
                        lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
                    } else {
                        lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
                        lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = ['cea'];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/iqsfnz': 13,
                '../common/msfnz': 15,
                '../common/qsfnz': 20
            }
        ],
        43: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                var adjust_lat = _dereq_('../common/adjust_lat');
                exports.init = function () {
                    this.x0 = this.x0 || 0;
                    this.y0 = this.y0 || 0;
                    this.lat0 = this.lat0 || 0;
                    this.long0 = this.long0 || 0;
                    this.lat_ts = this.lat_ts || 0;
                    this.title = this.title || 'Equidistant Cylindrical (Plate Carre)';
                    this.rc = Math.cos(this.lat_ts);
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var dlon = adjust_lon(lon - this.long0);
                    var dlat = adjust_lat(lat - this.lat0);
                    p.x = this.x0 + this.a * dlon * this.rc;
                    p.y = this.y0 + this.a * dlat;
                    return p;
                };
                exports.inverse = function (p) {
                    var x = p.x;
                    var y = p.y;
                    p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
                    p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
                    return p;
                };
                exports.names = [
                    'Equirectangular',
                    'Equidistant_Cylindrical',
                    'eqc'
                ];
                return exports;
            },
            {
                '../common/adjust_lat': 4,
                '../common/adjust_lon': 5
            }
        ],
        44: [
            function (_dereq_, module, exports) {
                var e0fn = _dereq_('../common/e0fn');
                var e1fn = _dereq_('../common/e1fn');
                var e2fn = _dereq_('../common/e2fn');
                var e3fn = _dereq_('../common/e3fn');
                var msfnz = _dereq_('../common/msfnz');
                var mlfn = _dereq_('../common/mlfn');
                var adjust_lon = _dereq_('../common/adjust_lon');
                var adjust_lat = _dereq_('../common/adjust_lat');
                var imlfn = _dereq_('../common/imlfn');
                var EPSLN = 1e-10;
                exports.init = function () {
                    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
                        return;
                    }
                    this.lat2 = this.lat2 || this.lat1;
                    this.temp = this.b / this.a;
                    this.es = 1 - Math.pow(this.temp, 2);
                    this.e = Math.sqrt(this.es);
                    this.e0 = e0fn(this.es);
                    this.e1 = e1fn(this.es);
                    this.e2 = e2fn(this.es);
                    this.e3 = e3fn(this.es);
                    this.sinphi = Math.sin(this.lat1);
                    this.cosphi = Math.cos(this.lat1);
                    this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
                    this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
                    if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
                        this.ns = this.sinphi;
                    } else {
                        this.sinphi = Math.sin(this.lat2);
                        this.cosphi = Math.cos(this.lat2);
                        this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
                        this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
                        this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
                    }
                    this.g = this.ml1 + this.ms1 / this.ns;
                    this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
                    this.rh = this.a * (this.g - this.ml0);
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var rh1;
                    if (this.sphere) {
                        rh1 = this.a * (this.g - lat);
                    } else {
                        var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
                        rh1 = this.a * (this.g - ml);
                    }
                    var theta = this.ns * adjust_lon(lon - this.long0);
                    var x = this.x0 + rh1 * Math.sin(theta);
                    var y = this.y0 + this.rh - rh1 * Math.cos(theta);
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    p.x -= this.x0;
                    p.y = this.rh - p.y + this.y0;
                    var con, rh1, lat, lon;
                    if (this.ns >= 0) {
                        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
                        con = 1;
                    } else {
                        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
                        con = -1;
                    }
                    var theta = 0;
                    if (rh1 !== 0) {
                        theta = Math.atan2(con * p.x, con * p.y);
                    }
                    if (this.sphere) {
                        lon = adjust_lon(this.long0 + theta / this.ns);
                        lat = adjust_lat(this.g - rh1 / this.a);
                        p.x = lon;
                        p.y = lat;
                        return p;
                    } else {
                        var ml = this.g - rh1 / this.a;
                        lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
                        lon = adjust_lon(this.long0 + theta / this.ns);
                        p.x = lon;
                        p.y = lat;
                        return p;
                    }
                };
                exports.names = [
                    'Equidistant_Conic',
                    'eqdc'
                ];
                return exports;
            },
            {
                '../common/adjust_lat': 4,
                '../common/adjust_lon': 5,
                '../common/e0fn': 7,
                '../common/e1fn': 8,
                '../common/e2fn': 9,
                '../common/e3fn': 10,
                '../common/imlfn': 12,
                '../common/mlfn': 14,
                '../common/msfnz': 15
            }
        ],
        45: [
            function (_dereq_, module, exports) {
                var FORTPI = Math.PI / 4;
                var srat = _dereq_('../common/srat');
                var HALF_PI = Math.PI / 2;
                var MAX_ITER = 20;
                exports.init = function () {
                    var sphi = Math.sin(this.lat0);
                    var cphi = Math.cos(this.lat0);
                    cphi *= cphi;
                    this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
                    this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
                    this.phic0 = Math.asin(sphi / this.C);
                    this.ratexp = 0.5 * this.C * this.e;
                    this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
                    p.x = this.C * lon;
                    return p;
                };
                exports.inverse = function (p) {
                    var DEL_TOL = 1e-14;
                    var lon = p.x / this.C;
                    var lat = p.y;
                    var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
                    for (var i = MAX_ITER; i > 0; --i) {
                        lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
                        if (Math.abs(lat - p.y) < DEL_TOL) {
                            break;
                        }
                        p.y = lat;
                    }
                    if (!i) {
                        return null;
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = ['gauss'];
                return exports;
            },
            { '../common/srat': 22 }
        ],
        46: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                var EPSLN = 1e-10;
                var asinz = _dereq_('../common/asinz');
                exports.init = function () {
                    this.sin_p14 = Math.sin(this.lat0);
                    this.cos_p14 = Math.cos(this.lat0);
                    this.infinity_dist = 1000 * this.a;
                    this.rc = 1;
                };
                exports.forward = function (p) {
                    var sinphi, cosphi;
                    var dlon;
                    var coslon;
                    var ksp;
                    var g;
                    var x, y;
                    var lon = p.x;
                    var lat = p.y;
                    dlon = adjust_lon(lon - this.long0);
                    sinphi = Math.sin(lat);
                    cosphi = Math.cos(lat);
                    coslon = Math.cos(dlon);
                    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
                    ksp = 1;
                    if (g > 0 || Math.abs(g) <= EPSLN) {
                        x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
                        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
                    } else {
                        x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
                        y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
                    }
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    var rh;
                    var sinc, cosc;
                    var c;
                    var lon, lat;
                    p.x = (p.x - this.x0) / this.a;
                    p.y = (p.y - this.y0) / this.a;
                    p.x /= this.k0;
                    p.y /= this.k0;
                    if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
                        c = Math.atan2(rh, this.rc);
                        sinc = Math.sin(c);
                        cosc = Math.cos(c);
                        lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
                        lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
                        lon = adjust_lon(this.long0 + lon);
                    } else {
                        lat = this.phic0;
                        lon = 0;
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = ['gnom'];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/asinz': 6
            }
        ],
        47: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                exports.init = function () {
                    this.a = 6377397.155;
                    this.es = 0.006674372230614;
                    this.e = Math.sqrt(this.es);
                    if (!this.lat0) {
                        this.lat0 = 0.863937979737193;
                    }
                    if (!this.long0) {
                        this.long0 = 0.7417649320975901 - 0.308341501185665;
                    }
                    if (!this.k0) {
                        this.k0 = 0.9999;
                    }
                    this.s45 = 0.785398163397448;
                    this.s90 = 2 * this.s45;
                    this.fi0 = this.lat0;
                    this.e2 = this.es;
                    this.e = Math.sqrt(this.e2);
                    this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
                    this.uq = 1.04216856380474;
                    this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
                    this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
                    this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
                    this.k1 = this.k0;
                    this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
                    this.s0 = 1.37008346281555;
                    this.n = Math.sin(this.s0);
                    this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
                    this.ad = this.s90 - this.uq;
                };
                exports.forward = function (p) {
                    var gfi, u, deltav, s, d, eps, ro;
                    var lon = p.x;
                    var lat = p.y;
                    var delta_lon = adjust_lon(lon - this.long0);
                    gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
                    u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
                    deltav = -delta_lon * this.alfa;
                    s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
                    d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
                    eps = this.n * d;
                    ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
                    p.y = ro * Math.cos(eps) / 1;
                    p.x = ro * Math.sin(eps) / 1;
                    if (!this.czech) {
                        p.y *= -1;
                        p.x *= -1;
                    }
                    return p;
                };
                exports.inverse = function (p) {
                    var u, deltav, s, d, eps, ro, fi1;
                    var ok;
                    var tmp = p.x;
                    p.x = p.y;
                    p.y = tmp;
                    if (!this.czech) {
                        p.y *= -1;
                        p.x *= -1;
                    }
                    ro = Math.sqrt(p.x * p.x + p.y * p.y);
                    eps = Math.atan2(p.y, p.x);
                    d = eps / Math.sin(this.s0);
                    s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
                    u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
                    deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
                    p.x = this.long0 - deltav / this.alfa;
                    fi1 = u;
                    ok = 0;
                    var iter = 0;
                    do {
                        p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
                        if (Math.abs(fi1 - p.y) < 1e-10) {
                            ok = 1;
                        }
                        fi1 = p.y;
                        iter += 1;
                    } while (ok === 0 && iter < 15);
                    if (iter >= 15) {
                        return null;
                    }
                    return p;
                };
                exports.names = [
                    'Krovak',
                    'krovak'
                ];
                return exports;
            },
            { '../common/adjust_lon': 5 }
        ],
        48: [
            function (_dereq_, module, exports) {
                var HALF_PI = Math.PI / 2;
                var FORTPI = Math.PI / 4;
                var EPSLN = 1e-10;
                var qsfnz = _dereq_('../common/qsfnz');
                var adjust_lon = _dereq_('../common/adjust_lon');
                exports.S_POLE = 1;
                exports.N_POLE = 2;
                exports.EQUIT = 3;
                exports.OBLIQ = 4;
                exports.init = function () {
                    var t = Math.abs(this.lat0);
                    if (Math.abs(t - HALF_PI) < EPSLN) {
                        this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
                    } else if (Math.abs(t) < EPSLN) {
                        this.mode = this.EQUIT;
                    } else {
                        this.mode = this.OBLIQ;
                    }
                    if (this.es > 0) {
                        var sinphi;
                        this.qp = qsfnz(this.e, 1);
                        this.mmf = 0.5 / (1 - this.es);
                        this.apa = this.authset(this.es);
                        switch (this.mode) {
                        case this.N_POLE:
                            this.dd = 1;
                            break;
                        case this.S_POLE:
                            this.dd = 1;
                            break;
                        case this.EQUIT:
                            this.rq = Math.sqrt(0.5 * this.qp);
                            this.dd = 1 / this.rq;
                            this.xmf = 1;
                            this.ymf = 0.5 * this.qp;
                            break;
                        case this.OBLIQ:
                            this.rq = Math.sqrt(0.5 * this.qp);
                            sinphi = Math.sin(this.lat0);
                            this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
                            this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
                            this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
                            this.ymf = (this.xmf = this.rq) / this.dd;
                            this.xmf *= this.dd;
                            break;
                        }
                    } else {
                        if (this.mode === this.OBLIQ) {
                            this.sinph0 = Math.sin(this.lat0);
                            this.cosph0 = Math.cos(this.lat0);
                        }
                    }
                };
                exports.forward = function (p) {
                    var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
                    var lam = p.x;
                    var phi = p.y;
                    lam = adjust_lon(lam - this.long0);
                    if (this.sphere) {
                        sinphi = Math.sin(phi);
                        cosphi = Math.cos(phi);
                        coslam = Math.cos(lam);
                        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                            y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
                            if (y <= EPSLN) {
                                return null;
                            }
                            y = Math.sqrt(2 / y);
                            x = y * cosphi * Math.sin(lam);
                            y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
                        } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                            if (this.mode === this.N_POLE) {
                                coslam = -coslam;
                            }
                            if (Math.abs(phi + this.phi0) < EPSLN) {
                                return null;
                            }
                            y = FORTPI - phi * 0.5;
                            y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
                            x = y * Math.sin(lam);
                            y *= coslam;
                        }
                    } else {
                        sinb = 0;
                        cosb = 0;
                        b = 0;
                        coslam = Math.cos(lam);
                        sinlam = Math.sin(lam);
                        sinphi = Math.sin(phi);
                        q = qsfnz(this.e, sinphi);
                        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                            sinb = q / this.qp;
                            cosb = Math.sqrt(1 - sinb * sinb);
                        }
                        switch (this.mode) {
                        case this.OBLIQ:
                            b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
                            break;
                        case this.EQUIT:
                            b = 1 + cosb * coslam;
                            break;
                        case this.N_POLE:
                            b = HALF_PI + phi;
                            q = this.qp - q;
                            break;
                        case this.S_POLE:
                            b = phi - HALF_PI;
                            q = this.qp + q;
                            break;
                        }
                        if (Math.abs(b) < EPSLN) {
                            return null;
                        }
                        switch (this.mode) {
                        case this.OBLIQ:
                        case this.EQUIT:
                            b = Math.sqrt(2 / b);
                            if (this.mode === this.OBLIQ) {
                                y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
                            } else {
                                y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
                            }
                            x = this.xmf * b * cosb * sinlam;
                            break;
                        case this.N_POLE:
                        case this.S_POLE:
                            if (q >= 0) {
                                x = (b = Math.sqrt(q)) * sinlam;
                                y = coslam * (this.mode === this.S_POLE ? b : -b);
                            } else {
                                x = y = 0;
                            }
                            break;
                        }
                    }
                    p.x = this.a * x + this.x0;
                    p.y = this.a * y + this.y0;
                    return p;
                };
                exports.inverse = function (p) {
                    p.x -= this.x0;
                    p.y -= this.y0;
                    var x = p.x / this.a;
                    var y = p.y / this.a;
                    var lam, phi, cCe, sCe, q, rho, ab;
                    if (this.sphere) {
                        var cosz = 0, rh, sinz = 0;
                        rh = Math.sqrt(x * x + y * y);
                        phi = rh * 0.5;
                        if (phi > 1) {
                            return null;
                        }
                        phi = 2 * Math.asin(phi);
                        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                            sinz = Math.sin(phi);
                            cosz = Math.cos(phi);
                        }
                        switch (this.mode) {
                        case this.EQUIT:
                            phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
                            x *= sinz;
                            y = cosz * rh;
                            break;
                        case this.OBLIQ:
                            phi = Math.abs(rh) <= EPSLN ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
                            x *= sinz * this.cosph0;
                            y = (cosz - Math.sin(phi) * this.sinph0) * rh;
                            break;
                        case this.N_POLE:
                            y = -y;
                            phi = HALF_PI - phi;
                            break;
                        case this.S_POLE:
                            phi -= HALF_PI;
                            break;
                        }
                        lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
                    } else {
                        ab = 0;
                        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                            x /= this.dd;
                            y *= this.dd;
                            rho = Math.sqrt(x * x + y * y);
                            if (rho < EPSLN) {
                                p.x = 0;
                                p.y = this.phi0;
                                return p;
                            }
                            sCe = 2 * Math.asin(0.5 * rho / this.rq);
                            cCe = Math.cos(sCe);
                            x *= sCe = Math.sin(sCe);
                            if (this.mode === this.OBLIQ) {
                                ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
                                q = this.qp * ab;
                                y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
                            } else {
                                ab = y * sCe / rho;
                                q = this.qp * ab;
                                y = rho * cCe;
                            }
                        } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                            if (this.mode === this.N_POLE) {
                                y = -y;
                            }
                            q = x * x + y * y;
                            if (!q) {
                                p.x = 0;
                                p.y = this.phi0;
                                return p;
                            }
                            ab = 1 - q / this.qp;
                            if (this.mode === this.S_POLE) {
                                ab = -ab;
                            }
                        }
                        lam = Math.atan2(x, y);
                        phi = this.authlat(Math.asin(ab), this.apa);
                    }
                    p.x = adjust_lon(this.long0 + lam);
                    p.y = phi;
                    return p;
                };
                exports.P00 = 0.3333333333333333;
                exports.P01 = 0.17222222222222222;
                exports.P02 = 0.10257936507936508;
                exports.P10 = 0.06388888888888888;
                exports.P11 = 0.0664021164021164;
                exports.P20 = 0.016415012942191543;
                exports.authset = function (es) {
                    var t;
                    var APA = [];
                    APA[0] = es * this.P00;
                    t = es * es;
                    APA[0] += t * this.P01;
                    APA[1] = t * this.P10;
                    t *= es;
                    APA[0] += t * this.P02;
                    APA[1] += t * this.P11;
                    APA[2] = t * this.P20;
                    return APA;
                };
                exports.authlat = function (beta, APA) {
                    var t = beta + beta;
                    return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
                };
                exports.names = [
                    'Lambert Azimuthal Equal Area',
                    'Lambert_Azimuthal_Equal_Area',
                    'laea'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/qsfnz': 20
            }
        ],
        49: [
            function (_dereq_, module, exports) {
                var EPSLN = 1e-10;
                var msfnz = _dereq_('../common/msfnz');
                var tsfnz = _dereq_('../common/tsfnz');
                var HALF_PI = Math.PI / 2;
                var sign = _dereq_('../common/sign');
                var adjust_lon = _dereq_('../common/adjust_lon');
                var phi2z = _dereq_('../common/phi2z');
                exports.init = function () {
                    if (!this.lat2) {
                        this.lat2 = this.lat1;
                    }
                    if (!this.k0) {
                        this.k0 = 1;
                    }
                    this.x0 = this.x0 || 0;
                    this.y0 = this.y0 || 0;
                    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
                        return;
                    }
                    var temp = this.b / this.a;
                    this.e = Math.sqrt(1 - temp * temp);
                    var sin1 = Math.sin(this.lat1);
                    var cos1 = Math.cos(this.lat1);
                    var ms1 = msfnz(this.e, sin1, cos1);
                    var ts1 = tsfnz(this.e, this.lat1, sin1);
                    var sin2 = Math.sin(this.lat2);
                    var cos2 = Math.cos(this.lat2);
                    var ms2 = msfnz(this.e, sin2, cos2);
                    var ts2 = tsfnz(this.e, this.lat2, sin2);
                    var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
                    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
                        this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
                    } else {
                        this.ns = sin1;
                    }
                    if (isNaN(this.ns)) {
                        this.ns = sin1;
                    }
                    this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
                    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
                    if (!this.title) {
                        this.title = 'Lambert Conformal Conic';
                    }
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
                        lat = sign(lat) * (HALF_PI - 2 * EPSLN);
                    }
                    var con = Math.abs(Math.abs(lat) - HALF_PI);
                    var ts, rh1;
                    if (con > EPSLN) {
                        ts = tsfnz(this.e, lat, Math.sin(lat));
                        rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
                    } else {
                        con = lat * this.ns;
                        if (con <= 0) {
                            return null;
                        }
                        rh1 = 0;
                    }
                    var theta = this.ns * adjust_lon(lon - this.long0);
                    p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
                    p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
                    return p;
                };
                exports.inverse = function (p) {
                    var rh1, con, ts;
                    var lat, lon;
                    var x = (p.x - this.x0) / this.k0;
                    var y = this.rh - (p.y - this.y0) / this.k0;
                    if (this.ns > 0) {
                        rh1 = Math.sqrt(x * x + y * y);
                        con = 1;
                    } else {
                        rh1 = -Math.sqrt(x * x + y * y);
                        con = -1;
                    }
                    var theta = 0;
                    if (rh1 !== 0) {
                        theta = Math.atan2(con * x, con * y);
                    }
                    if (rh1 !== 0 || this.ns > 0) {
                        con = 1 / this.ns;
                        ts = Math.pow(rh1 / (this.a * this.f0), con);
                        lat = phi2z(this.e, ts);
                        if (lat === -9999) {
                            return null;
                        }
                    } else {
                        lat = -HALF_PI;
                    }
                    lon = adjust_lon(theta / this.ns + this.long0);
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Lambert Tangential Conformal Conic Projection',
                    'Lambert_Conformal_Conic',
                    'Lambert_Conformal_Conic_2SP',
                    'lcc'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/msfnz': 15,
                '../common/phi2z': 16,
                '../common/sign': 21,
                '../common/tsfnz': 24
            }
        ],
        50: [
            function (_dereq_, module, exports) {
                exports.init = function () {
                };
                function identity(pt) {
                    return pt;
                }
                exports.forward = identity;
                exports.inverse = identity;
                exports.names = [
                    'longlat',
                    'identity'
                ];
                return exports;
            },
            {}
        ],
        51: [
            function (_dereq_, module, exports) {
                var msfnz = _dereq_('../common/msfnz');
                var HALF_PI = Math.PI / 2;
                var EPSLN = 1e-10;
                var R2D = 57.29577951308232;
                var adjust_lon = _dereq_('../common/adjust_lon');
                var FORTPI = Math.PI / 4;
                var tsfnz = _dereq_('../common/tsfnz');
                var phi2z = _dereq_('../common/phi2z');
                exports.init = function () {
                    var con = this.b / this.a;
                    this.es = 1 - con * con;
                    if (!('x0' in this)) {
                        this.x0 = 0;
                    }
                    if (!('y0' in this)) {
                        this.y0 = 0;
                    }
                    this.e = Math.sqrt(this.es);
                    if (this.lat_ts) {
                        if (this.sphere) {
                            this.k0 = Math.cos(this.lat_ts);
                        } else {
                            this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
                        }
                    } else {
                        if (!this.k0) {
                            if (this.k) {
                                this.k0 = this.k;
                            } else {
                                this.k0 = 1;
                            }
                        }
                    }
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
                        return null;
                    }
                    var x, y;
                    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
                        return null;
                    } else {
                        if (this.sphere) {
                            x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
                            y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
                        } else {
                            var sinphi = Math.sin(lat);
                            var ts = tsfnz(this.e, lat, sinphi);
                            x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
                            y = this.y0 - this.a * this.k0 * Math.log(ts);
                        }
                        p.x = x;
                        p.y = y;
                        return p;
                    }
                };
                exports.inverse = function (p) {
                    var x = p.x - this.x0;
                    var y = p.y - this.y0;
                    var lon, lat;
                    if (this.sphere) {
                        lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
                    } else {
                        var ts = Math.exp(-y / (this.a * this.k0));
                        lat = phi2z(this.e, ts);
                        if (lat === -9999) {
                            return null;
                        }
                    }
                    lon = adjust_lon(this.long0 + x / (this.a * this.k0));
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Mercator',
                    'Popular Visualisation Pseudo Mercator',
                    'Mercator_1SP',
                    'Mercator_Auxiliary_Sphere',
                    'merc'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/msfnz': 15,
                '../common/phi2z': 16,
                '../common/tsfnz': 24
            }
        ],
        52: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                exports.init = function () {
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var dlon = adjust_lon(lon - this.long0);
                    var x = this.x0 + this.a * dlon;
                    var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    p.x -= this.x0;
                    p.y -= this.y0;
                    var lon = adjust_lon(this.long0 + p.x / this.a);
                    var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Miller_Cylindrical',
                    'mill'
                ];
                return exports;
            },
            { '../common/adjust_lon': 5 }
        ],
        53: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                var EPSLN = 1e-10;
                exports.init = function () {
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var delta_lon = adjust_lon(lon - this.long0);
                    var theta = lat;
                    var con = Math.PI * Math.sin(lat);
                    for (var i = 0; true; i++) {
                        var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
                        theta += delta_theta;
                        if (Math.abs(delta_theta) < EPSLN) {
                            break;
                        }
                    }
                    theta /= 2;
                    if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
                        delta_lon = 0;
                    }
                    var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
                    var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    var theta;
                    var arg;
                    p.x -= this.x0;
                    p.y -= this.y0;
                    arg = p.y / (1.4142135623731 * this.a);
                    if (Math.abs(arg) > 0.999999999999) {
                        arg = 0.999999999999;
                    }
                    theta = Math.asin(arg);
                    var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
                    if (lon < -Math.PI) {
                        lon = -Math.PI;
                    }
                    if (lon > Math.PI) {
                        lon = Math.PI;
                    }
                    arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
                    if (Math.abs(arg) > 1) {
                        arg = 1;
                    }
                    var lat = Math.asin(arg);
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Mollweide',
                    'moll'
                ];
                return exports;
            },
            { '../common/adjust_lon': 5 }
        ],
        54: [
            function (_dereq_, module, exports) {
                var SEC_TO_RAD = 0.00000484813681109536;
                exports.iterations = 1;
                exports.init = function () {
                    this.A = [];
                    this.A[1] = 0.6399175073;
                    this.A[2] = -0.1358797613;
                    this.A[3] = 0.063294409;
                    this.A[4] = -0.02526853;
                    this.A[5] = 0.0117879;
                    this.A[6] = -0.0055161;
                    this.A[7] = 0.0026906;
                    this.A[8] = -0.001333;
                    this.A[9] = 0.00067;
                    this.A[10] = -0.00034;
                    this.B_re = [];
                    this.B_im = [];
                    this.B_re[1] = 0.7557853228;
                    this.B_im[1] = 0;
                    this.B_re[2] = 0.249204646;
                    this.B_im[2] = 0.003371507;
                    this.B_re[3] = -0.001541739;
                    this.B_im[3] = 0.04105856;
                    this.B_re[4] = -0.10162907;
                    this.B_im[4] = 0.01727609;
                    this.B_re[5] = -0.26623489;
                    this.B_im[5] = -0.36249218;
                    this.B_re[6] = -0.6870983;
                    this.B_im[6] = -1.1651967;
                    this.C_re = [];
                    this.C_im = [];
                    this.C_re[1] = 1.3231270439;
                    this.C_im[1] = 0;
                    this.C_re[2] = -0.577245789;
                    this.C_im[2] = -0.007809598;
                    this.C_re[3] = 0.508307513;
                    this.C_im[3] = -0.112208952;
                    this.C_re[4] = -0.15094762;
                    this.C_im[4] = 0.18200602;
                    this.C_re[5] = 1.01418179;
                    this.C_im[5] = 1.64497696;
                    this.C_re[6] = 1.9660549;
                    this.C_im[6] = 2.5127645;
                    this.D = [];
                    this.D[1] = 1.5627014243;
                    this.D[2] = 0.5185406398;
                    this.D[3] = -0.03333098;
                    this.D[4] = -0.1052906;
                    this.D[5] = -0.0368594;
                    this.D[6] = 0.007317;
                    this.D[7] = 0.0122;
                    this.D[8] = 0.00394;
                    this.D[9] = -0.0013;
                };
                exports.forward = function (p) {
                    var n;
                    var lon = p.x;
                    var lat = p.y;
                    var delta_lat = lat - this.lat0;
                    var delta_lon = lon - this.long0;
                    var d_phi = delta_lat / SEC_TO_RAD * 0.00001;
                    var d_lambda = delta_lon;
                    var d_phi_n = 1;
                    var d_psi = 0;
                    for (n = 1; n <= 10; n++) {
                        d_phi_n = d_phi_n * d_phi;
                        d_psi = d_psi + this.A[n] * d_phi_n;
                    }
                    var th_re = d_psi;
                    var th_im = d_lambda;
                    var th_n_re = 1;
                    var th_n_im = 0;
                    var th_n_re1;
                    var th_n_im1;
                    var z_re = 0;
                    var z_im = 0;
                    for (n = 1; n <= 6; n++) {
                        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
                        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
                        th_n_re = th_n_re1;
                        th_n_im = th_n_im1;
                        z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
                        z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
                    }
                    p.x = z_im * this.a + this.x0;
                    p.y = z_re * this.a + this.y0;
                    return p;
                };
                exports.inverse = function (p) {
                    var n;
                    var x = p.x;
                    var y = p.y;
                    var delta_x = x - this.x0;
                    var delta_y = y - this.y0;
                    var z_re = delta_y / this.a;
                    var z_im = delta_x / this.a;
                    var z_n_re = 1;
                    var z_n_im = 0;
                    var z_n_re1;
                    var z_n_im1;
                    var th_re = 0;
                    var th_im = 0;
                    for (n = 1; n <= 6; n++) {
                        z_n_re1 = z_n_re * z_re - z_n_im * z_im;
                        z_n_im1 = z_n_im * z_re + z_n_re * z_im;
                        z_n_re = z_n_re1;
                        z_n_im = z_n_im1;
                        th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
                        th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
                    }
                    for (var i = 0; i < this.iterations; i++) {
                        var th_n_re = th_re;
                        var th_n_im = th_im;
                        var th_n_re1;
                        var th_n_im1;
                        var num_re = z_re;
                        var num_im = z_im;
                        for (n = 2; n <= 6; n++) {
                            th_n_re1 = th_n_re * th_re - th_n_im * th_im;
                            th_n_im1 = th_n_im * th_re + th_n_re * th_im;
                            th_n_re = th_n_re1;
                            th_n_im = th_n_im1;
                            num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
                            num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
                        }
                        th_n_re = 1;
                        th_n_im = 0;
                        var den_re = this.B_re[1];
                        var den_im = this.B_im[1];
                        for (n = 2; n <= 6; n++) {
                            th_n_re1 = th_n_re * th_re - th_n_im * th_im;
                            th_n_im1 = th_n_im * th_re + th_n_re * th_im;
                            th_n_re = th_n_re1;
                            th_n_im = th_n_im1;
                            den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
                            den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
                        }
                        var den2 = den_re * den_re + den_im * den_im;
                        th_re = (num_re * den_re + num_im * den_im) / den2;
                        th_im = (num_im * den_re - num_re * den_im) / den2;
                    }
                    var d_psi = th_re;
                    var d_lambda = th_im;
                    var d_psi_n = 1;
                    var d_phi = 0;
                    for (n = 1; n <= 9; n++) {
                        d_psi_n = d_psi_n * d_psi;
                        d_phi = d_phi + this.D[n] * d_psi_n;
                    }
                    var lat = this.lat0 + d_phi * SEC_TO_RAD * 100000;
                    var lon = this.long0 + d_lambda;
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'New_Zealand_Map_Grid',
                    'nzmg'
                ];
                return exports;
            },
            {}
        ],
        55: [
            function (_dereq_, module, exports) {
                var tsfnz = _dereq_('../common/tsfnz');
                var adjust_lon = _dereq_('../common/adjust_lon');
                var phi2z = _dereq_('../common/phi2z');
                var HALF_PI = Math.PI / 2;
                var FORTPI = Math.PI / 4;
                var EPSLN = 1e-10;
                exports.init = function () {
                    this.no_off = this.no_off || false;
                    this.no_rot = this.no_rot || false;
                    if (isNaN(this.k0)) {
                        this.k0 = 1;
                    }
                    var sinlat = Math.sin(this.lat0);
                    var coslat = Math.cos(this.lat0);
                    var con = this.e * sinlat;
                    this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
                    this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
                    var t0 = tsfnz(this.e, this.lat0, sinlat);
                    var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
                    if (dl * dl < 1) {
                        dl = 1;
                    }
                    var fl;
                    var gl;
                    if (!isNaN(this.longc)) {
                        if (this.lat0 >= 0) {
                            fl = dl + Math.sqrt(dl * dl - 1);
                        } else {
                            fl = dl - Math.sqrt(dl * dl - 1);
                        }
                        this.el = fl * Math.pow(t0, this.bl);
                        gl = 0.5 * (fl - 1 / fl);
                        this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
                        this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;
                    } else {
                        var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
                        var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
                        if (this.lat0 >= 0) {
                            this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
                        } else {
                            this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
                        }
                        var hl = Math.pow(t1, this.bl);
                        var ll = Math.pow(t2, this.bl);
                        fl = this.el / hl;
                        gl = 0.5 * (fl - 1 / fl);
                        var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
                        var pl = (ll - hl) / (ll + hl);
                        var dlon12 = adjust_lon(this.long1 - this.long2);
                        this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * dlon12) / pl) / this.bl;
                        this.long0 = adjust_lon(this.long0);
                        var dlon10 = adjust_lon(this.long1 - this.long0);
                        this.gamma0 = Math.atan(Math.sin(this.bl * dlon10) / gl);
                        this.alpha = Math.asin(dl * Math.sin(this.gamma0));
                    }
                    if (this.no_off) {
                        this.uc = 0;
                    } else {
                        if (this.lat0 >= 0) {
                            this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
                        } else {
                            this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
                        }
                    }
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var dlon = adjust_lon(lon - this.long0);
                    var us, vs;
                    var con;
                    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
                        if (lat > 0) {
                            con = -1;
                        } else {
                            con = 1;
                        }
                        vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
                        us = -1 * con * HALF_PI * this.al / this.bl;
                    } else {
                        var t = tsfnz(this.e, lat, Math.sin(lat));
                        var ql = this.el / Math.pow(t, this.bl);
                        var sl = 0.5 * (ql - 1 / ql);
                        var tl = 0.5 * (ql + 1 / ql);
                        var vl = Math.sin(this.bl * dlon);
                        var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
                        if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
                            vs = Number.POSITIVE_INFINITY;
                        } else {
                            vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
                        }
                        if (Math.abs(Math.cos(this.bl * dlon)) <= EPSLN) {
                            us = this.al * this.bl * dlon;
                        } else {
                            us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
                        }
                    }
                    if (this.no_rot) {
                        p.x = this.x0 + us;
                        p.y = this.y0 + vs;
                    } else {
                        us -= this.uc;
                        p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
                        p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
                    }
                    return p;
                };
                exports.inverse = function (p) {
                    var us, vs;
                    if (this.no_rot) {
                        vs = p.y - this.y0;
                        us = p.x - this.x0;
                    } else {
                        vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
                        us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
                        us += this.uc;
                    }
                    var qp = Math.exp(-1 * this.bl * vs / this.al);
                    var sp = 0.5 * (qp - 1 / qp);
                    var tp = 0.5 * (qp + 1 / qp);
                    var vp = Math.sin(this.bl * us / this.al);
                    var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
                    var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
                    if (Math.abs(up - 1) < EPSLN) {
                        p.x = this.long0;
                        p.y = HALF_PI;
                    } else if (Math.abs(up + 1) < EPSLN) {
                        p.x = this.long0;
                        p.y = -1 * HALF_PI;
                    } else {
                        p.y = phi2z(this.e, ts);
                        p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
                    }
                    return p;
                };
                exports.names = [
                    'Hotine_Oblique_Mercator',
                    'Hotine Oblique Mercator',
                    'Hotine_Oblique_Mercator_Azimuth_Natural_Origin',
                    'Hotine_Oblique_Mercator_Azimuth_Center',
                    'omerc'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/phi2z': 16,
                '../common/tsfnz': 24
            }
        ],
        56: [
            function (_dereq_, module, exports) {
                var e0fn = _dereq_('../common/e0fn');
                var e1fn = _dereq_('../common/e1fn');
                var e2fn = _dereq_('../common/e2fn');
                var e3fn = _dereq_('../common/e3fn');
                var adjust_lon = _dereq_('../common/adjust_lon');
                var adjust_lat = _dereq_('../common/adjust_lat');
                var mlfn = _dereq_('../common/mlfn');
                var EPSLN = 1e-10;
                var gN = _dereq_('../common/gN');
                var MAX_ITER = 20;
                exports.init = function () {
                    this.temp = this.b / this.a;
                    this.es = 1 - Math.pow(this.temp, 2);
                    this.e = Math.sqrt(this.es);
                    this.e0 = e0fn(this.es);
                    this.e1 = e1fn(this.es);
                    this.e2 = e2fn(this.es);
                    this.e3 = e3fn(this.es);
                    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var x, y, el;
                    var dlon = adjust_lon(lon - this.long0);
                    el = dlon * Math.sin(lat);
                    if (this.sphere) {
                        if (Math.abs(lat) <= EPSLN) {
                            x = this.a * dlon;
                            y = -1 * this.a * this.lat0;
                        } else {
                            x = this.a * Math.sin(el) / Math.tan(lat);
                            y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
                        }
                    } else {
                        if (Math.abs(lat) <= EPSLN) {
                            x = this.a * dlon;
                            y = -1 * this.ml0;
                        } else {
                            var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
                            x = nl * Math.sin(el);
                            y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
                        }
                    }
                    p.x = x + this.x0;
                    p.y = y + this.y0;
                    return p;
                };
                exports.inverse = function (p) {
                    var lon, lat, x, y, i;
                    var al, bl;
                    var phi, dphi;
                    x = p.x - this.x0;
                    y = p.y - this.y0;
                    if (this.sphere) {
                        if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
                            lon = adjust_lon(x / this.a + this.long0);
                            lat = 0;
                        } else {
                            al = this.lat0 + y / this.a;
                            bl = x * x / this.a / this.a + al * al;
                            phi = al;
                            var tanphi;
                            for (i = MAX_ITER; i; --i) {
                                tanphi = Math.tan(phi);
                                dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
                                phi += dphi;
                                if (Math.abs(dphi) <= EPSLN) {
                                    lat = phi;
                                    break;
                                }
                            }
                            lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
                        }
                    } else {
                        if (Math.abs(y + this.ml0) <= EPSLN) {
                            lat = 0;
                            lon = adjust_lon(this.long0 + x / this.a);
                        } else {
                            al = (this.ml0 + y) / this.a;
                            bl = x * x / this.a / this.a + al * al;
                            phi = al;
                            var cl, mln, mlnp, ma;
                            var con;
                            for (i = MAX_ITER; i; --i) {
                                con = this.e * Math.sin(phi);
                                cl = Math.sqrt(1 - con * con) * Math.tan(phi);
                                mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
                                mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
                                ma = mln / this.a;
                                dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
                                phi -= dphi;
                                if (Math.abs(dphi) <= EPSLN) {
                                    lat = phi;
                                    break;
                                }
                            }
                            cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
                            lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
                        }
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Polyconic',
                    'poly'
                ];
                return exports;
            },
            {
                '../common/adjust_lat': 4,
                '../common/adjust_lon': 5,
                '../common/e0fn': 7,
                '../common/e1fn': 8,
                '../common/e2fn': 9,
                '../common/e3fn': 10,
                '../common/gN': 11,
                '../common/mlfn': 14
            }
        ],
        57: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                var adjust_lat = _dereq_('../common/adjust_lat');
                var pj_enfn = _dereq_('../common/pj_enfn');
                var MAX_ITER = 20;
                var pj_mlfn = _dereq_('../common/pj_mlfn');
                var pj_inv_mlfn = _dereq_('../common/pj_inv_mlfn');
                var HALF_PI = Math.PI / 2;
                var EPSLN = 1e-10;
                var asinz = _dereq_('../common/asinz');
                exports.init = function () {
                    if (!this.sphere) {
                        this.en = pj_enfn(this.es);
                    } else {
                        this.n = 1;
                        this.m = 0;
                        this.es = 0;
                        this.C_y = Math.sqrt((this.m + 1) / this.n);
                        this.C_x = this.C_y / (this.m + 1);
                    }
                };
                exports.forward = function (p) {
                    var x, y;
                    var lon = p.x;
                    var lat = p.y;
                    lon = adjust_lon(lon - this.long0);
                    if (this.sphere) {
                        if (!this.m) {
                            lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
                        } else {
                            var k = this.n * Math.sin(lat);
                            for (var i = MAX_ITER; i; --i) {
                                var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
                                lat -= V;
                                if (Math.abs(V) < EPSLN) {
                                    break;
                                }
                            }
                        }
                        x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
                        y = this.a * this.C_y * lat;
                    } else {
                        var s = Math.sin(lat);
                        var c = Math.cos(lat);
                        y = this.a * pj_mlfn(lat, s, c, this.en);
                        x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
                    }
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    var lat, temp, lon, s;
                    p.x -= this.x0;
                    lon = p.x / this.a;
                    p.y -= this.y0;
                    lat = p.y / this.a;
                    if (this.sphere) {
                        lat /= this.C_y;
                        lon = lon / (this.C_x * (this.m + Math.cos(lat)));
                        if (this.m) {
                            lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
                        } else if (this.n !== 1) {
                            lat = asinz(Math.sin(lat) / this.n);
                        }
                        lon = adjust_lon(lon + this.long0);
                        lat = adjust_lat(lat);
                    } else {
                        lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
                        s = Math.abs(lat);
                        if (s < HALF_PI) {
                            s = Math.sin(lat);
                            temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
                            lon = adjust_lon(temp);
                        } else if (s - EPSLN < HALF_PI) {
                            lon = this.long0;
                        }
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Sinusoidal',
                    'sinu'
                ];
                return exports;
            },
            {
                '../common/adjust_lat': 4,
                '../common/adjust_lon': 5,
                '../common/asinz': 6,
                '../common/pj_enfn': 17,
                '../common/pj_inv_mlfn': 18,
                '../common/pj_mlfn': 19
            }
        ],
        58: [
            function (_dereq_, module, exports) {
                exports.init = function () {
                    var phy0 = this.lat0;
                    this.lambda0 = this.long0;
                    var sinPhy0 = Math.sin(phy0);
                    var semiMajorAxis = this.a;
                    var invF = this.rf;
                    var flattening = 1 / invF;
                    var e2 = 2 * flattening - Math.pow(flattening, 2);
                    var e = this.e = Math.sqrt(e2);
                    this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
                    this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
                    this.b0 = Math.asin(sinPhy0 / this.alpha);
                    var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
                    var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
                    var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
                    this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
                };
                exports.forward = function (p) {
                    var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
                    var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
                    var S = -this.alpha * (Sa1 + Sa2) + this.K;
                    var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
                    var I = this.alpha * (p.x - this.lambda0);
                    var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
                    var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
                    p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
                    p.x = this.R * rotI + this.x0;
                    return p;
                };
                exports.inverse = function (p) {
                    var Y = p.x - this.x0;
                    var X = p.y - this.y0;
                    var rotI = Y / this.R;
                    var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
                    var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
                    var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
                    var lambda = this.lambda0 + I / this.alpha;
                    var S = 0;
                    var phy = b;
                    var prevPhy = -1000;
                    var iteration = 0;
                    while (Math.abs(phy - prevPhy) > 1e-7) {
                        if (++iteration > 20) {
                            return;
                        }
                        S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
                        prevPhy = phy;
                        phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
                    }
                    p.x = lambda;
                    p.y = phy;
                    return p;
                };
                exports.names = ['somerc'];
                return exports;
            },
            {}
        ],
        59: [
            function (_dereq_, module, exports) {
                var HALF_PI = Math.PI / 2;
                var EPSLN = 1e-10;
                var sign = _dereq_('../common/sign');
                var msfnz = _dereq_('../common/msfnz');
                var tsfnz = _dereq_('../common/tsfnz');
                var phi2z = _dereq_('../common/phi2z');
                var adjust_lon = _dereq_('../common/adjust_lon');
                exports.ssfn_ = function (phit, sinphi, eccen) {
                    sinphi *= eccen;
                    return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
                };
                exports.init = function () {
                    this.coslat0 = Math.cos(this.lat0);
                    this.sinlat0 = Math.sin(this.lat0);
                    if (this.sphere) {
                        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
                            this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
                        }
                    } else {
                        if (Math.abs(this.coslat0) <= EPSLN) {
                            if (this.lat0 > 0) {
                                this.con = 1;
                            } else {
                                this.con = -1;
                            }
                        }
                        this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
                        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
                            this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
                        }
                        this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
                        this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
                        this.cosX0 = Math.cos(this.X0);
                        this.sinX0 = Math.sin(this.X0);
                    }
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var sinlat = Math.sin(lat);
                    var coslat = Math.cos(lat);
                    var A, X, sinX, cosX, ts, rh;
                    var dlon = adjust_lon(lon - this.long0);
                    if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
                        p.x = NaN;
                        p.y = NaN;
                        return p;
                    }
                    if (this.sphere) {
                        A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
                        p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
                        p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
                        return p;
                    } else {
                        X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
                        cosX = Math.cos(X);
                        sinX = Math.sin(X);
                        if (Math.abs(this.coslat0) <= EPSLN) {
                            ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
                            rh = 2 * this.a * this.k0 * ts / this.cons;
                            p.x = this.x0 + rh * Math.sin(lon - this.long0);
                            p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
                            return p;
                        } else if (Math.abs(this.sinlat0) < EPSLN) {
                            A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
                            p.y = A * sinX;
                        } else {
                            A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
                            p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
                        }
                        p.x = A * cosX * Math.sin(dlon) + this.x0;
                    }
                    return p;
                };
                exports.inverse = function (p) {
                    p.x -= this.x0;
                    p.y -= this.y0;
                    var lon, lat, ts, ce, Chi;
                    var rh = Math.sqrt(p.x * p.x + p.y * p.y);
                    if (this.sphere) {
                        var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
                        lon = this.long0;
                        lat = this.lat0;
                        if (rh <= EPSLN) {
                            p.x = lon;
                            p.y = lat;
                            return p;
                        }
                        lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
                        if (Math.abs(this.coslat0) < EPSLN) {
                            if (this.lat0 > 0) {
                                lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
                            } else {
                                lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
                            }
                        } else {
                            lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
                        }
                        p.x = lon;
                        p.y = lat;
                        return p;
                    } else {
                        if (Math.abs(this.coslat0) <= EPSLN) {
                            if (rh <= EPSLN) {
                                lat = this.lat0;
                                lon = this.long0;
                                p.x = lon;
                                p.y = lat;
                                return p;
                            }
                            p.x *= this.con;
                            p.y *= this.con;
                            ts = rh * this.cons / (2 * this.a * this.k0);
                            lat = this.con * phi2z(this.e, ts);
                            lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
                        } else {
                            ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
                            lon = this.long0;
                            if (rh <= EPSLN) {
                                Chi = this.X0;
                            } else {
                                Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
                                lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
                            }
                            lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
                        }
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = ['stere'];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/msfnz': 15,
                '../common/phi2z': 16,
                '../common/sign': 21,
                '../common/tsfnz': 24
            }
        ],
        60: [
            function (_dereq_, module, exports) {
                var gauss = _dereq_('./gauss');
                var adjust_lon = _dereq_('../common/adjust_lon');
                exports.init = function () {
                    gauss.init.apply(this);
                    if (!this.rc) {
                        return;
                    }
                    this.sinc0 = Math.sin(this.phic0);
                    this.cosc0 = Math.cos(this.phic0);
                    this.R2 = 2 * this.rc;
                    if (!this.title) {
                        this.title = 'Oblique Stereographic Alternative';
                    }
                };
                exports.forward = function (p) {
                    var sinc, cosc, cosl, k;
                    p.x = adjust_lon(p.x - this.long0);
                    gauss.forward.apply(this, [p]);
                    sinc = Math.sin(p.y);
                    cosc = Math.cos(p.y);
                    cosl = Math.cos(p.x);
                    k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
                    p.x = k * cosc * Math.sin(p.x);
                    p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
                    p.x = this.a * p.x + this.x0;
                    p.y = this.a * p.y + this.y0;
                    return p;
                };
                exports.inverse = function (p) {
                    var sinc, cosc, lon, lat, rho;
                    p.x = (p.x - this.x0) / this.a;
                    p.y = (p.y - this.y0) / this.a;
                    p.x /= this.k0;
                    p.y /= this.k0;
                    if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
                        var c = 2 * Math.atan2(rho, this.R2);
                        sinc = Math.sin(c);
                        cosc = Math.cos(c);
                        lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
                        lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
                    } else {
                        lat = this.phic0;
                        lon = 0;
                    }
                    p.x = lon;
                    p.y = lat;
                    gauss.inverse.apply(this, [p]);
                    p.x = adjust_lon(p.x + this.long0);
                    return p;
                };
                exports.names = [
                    'Stereographic_North_Pole',
                    'Oblique_Stereographic',
                    'Polar_Stereographic',
                    'sterea',
                    'Oblique Stereographic Alternative'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                './gauss': 45
            }
        ],
        61: [
            function (_dereq_, module, exports) {
                var e0fn = _dereq_('../common/e0fn');
                var e1fn = _dereq_('../common/e1fn');
                var e2fn = _dereq_('../common/e2fn');
                var e3fn = _dereq_('../common/e3fn');
                var mlfn = _dereq_('../common/mlfn');
                var adjust_lon = _dereq_('../common/adjust_lon');
                var HALF_PI = Math.PI / 2;
                var EPSLN = 1e-10;
                var sign = _dereq_('../common/sign');
                var asinz = _dereq_('../common/asinz');
                exports.init = function () {
                    this.e0 = e0fn(this.es);
                    this.e1 = e1fn(this.es);
                    this.e2 = e2fn(this.es);
                    this.e3 = e3fn(this.es);
                    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var delta_lon = adjust_lon(lon - this.long0);
                    var con;
                    var x, y;
                    var sin_phi = Math.sin(lat);
                    var cos_phi = Math.cos(lat);
                    if (this.sphere) {
                        var b = cos_phi * Math.sin(delta_lon);
                        if (Math.abs(Math.abs(b) - 1) < 1e-10) {
                            return 93;
                        } else {
                            x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));
                            con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));
                            if (lat < 0) {
                                con = -con;
                            }
                            y = this.a * this.k0 * (con - this.lat0);
                        }
                    } else {
                        var al = cos_phi * delta_lon;
                        var als = Math.pow(al, 2);
                        var c = this.ep2 * Math.pow(cos_phi, 2);
                        var tq = Math.tan(lat);
                        var t = Math.pow(tq, 2);
                        con = 1 - this.es * Math.pow(sin_phi, 2);
                        var n = this.a / Math.sqrt(con);
                        var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);
                        x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;
                        y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;
                    }
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    var con, phi;
                    var delta_phi;
                    var i;
                    var max_iter = 6;
                    var lat, lon;
                    if (this.sphere) {
                        var f = Math.exp(p.x / (this.a * this.k0));
                        var g = 0.5 * (f - 1 / f);
                        var temp = this.lat0 + p.y / (this.a * this.k0);
                        var h = Math.cos(temp);
                        con = Math.sqrt((1 - h * h) / (1 + g * g));
                        lat = asinz(con);
                        if (temp < 0) {
                            lat = -lat;
                        }
                        if (g === 0 && h === 0) {
                            lon = this.long0;
                        } else {
                            lon = adjust_lon(Math.atan2(g, h) + this.long0);
                        }
                    } else {
                        var x = p.x - this.x0;
                        var y = p.y - this.y0;
                        con = (this.ml0 + y / this.k0) / this.a;
                        phi = con;
                        for (i = 0; true; i++) {
                            delta_phi = (con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0 - phi;
                            phi += delta_phi;
                            if (Math.abs(delta_phi) <= EPSLN) {
                                break;
                            }
                            if (i >= max_iter) {
                                return 95;
                            }
                        }
                        if (Math.abs(phi) < HALF_PI) {
                            var sin_phi = Math.sin(phi);
                            var cos_phi = Math.cos(phi);
                            var tan_phi = Math.tan(phi);
                            var c = this.ep2 * Math.pow(cos_phi, 2);
                            var cs = Math.pow(c, 2);
                            var t = Math.pow(tan_phi, 2);
                            var ts = Math.pow(t, 2);
                            con = 1 - this.es * Math.pow(sin_phi, 2);
                            var n = this.a / Math.sqrt(con);
                            var r = n * (1 - this.es) / con;
                            var d = x / (n * this.k0);
                            var ds = Math.pow(d, 2);
                            lat = phi - n * tan_phi * ds / r * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));
                            lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi);
                        } else {
                            lat = HALF_PI * sign(y);
                            lon = this.long0;
                        }
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Transverse_Mercator',
                    'Transverse Mercator',
                    'tmerc'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/asinz': 6,
                '../common/e0fn': 7,
                '../common/e1fn': 8,
                '../common/e2fn': 9,
                '../common/e3fn': 10,
                '../common/mlfn': 14,
                '../common/sign': 21
            }
        ],
        62: [
            function (_dereq_, module, exports) {
                var D2R = 0.017453292519943295;
                var tmerc = _dereq_('./tmerc');
                exports.dependsOn = 'tmerc';
                exports.init = function () {
                    if (!this.zone) {
                        return;
                    }
                    this.lat0 = 0;
                    this.long0 = (6 * Math.abs(this.zone) - 183) * D2R;
                    this.x0 = 500000;
                    this.y0 = this.utmSouth ? 10000000 : 0;
                    this.k0 = 0.9996;
                    tmerc.init.apply(this);
                    this.forward = tmerc.forward;
                    this.inverse = tmerc.inverse;
                };
                exports.names = [
                    'Universal Transverse Mercator System',
                    'utm'
                ];
                return exports;
            },
            { './tmerc': 61 }
        ],
        63: [
            function (_dereq_, module, exports) {
                var adjust_lon = _dereq_('../common/adjust_lon');
                var HALF_PI = Math.PI / 2;
                var EPSLN = 1e-10;
                var asinz = _dereq_('../common/asinz');
                exports.init = function () {
                    this.R = this.a;
                };
                exports.forward = function (p) {
                    var lon = p.x;
                    var lat = p.y;
                    var dlon = adjust_lon(lon - this.long0);
                    var x, y;
                    if (Math.abs(lat) <= EPSLN) {
                        x = this.x0 + this.R * dlon;
                        y = this.y0;
                    }
                    var theta = asinz(2 * Math.abs(lat / Math.PI));
                    if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
                        x = this.x0;
                        if (lat >= 0) {
                            y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
                        } else {
                            y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
                        }
                    }
                    var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
                    var asq = al * al;
                    var sinth = Math.sin(theta);
                    var costh = Math.cos(theta);
                    var g = costh / (sinth + costh - 1);
                    var gsq = g * g;
                    var m = g * (2 / sinth - 1);
                    var msq = m * m;
                    var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
                    if (dlon < 0) {
                        con = -con;
                    }
                    x = this.x0 + con;
                    var q = asq + g;
                    con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
                    if (lat >= 0) {
                        y = this.y0 + con;
                    } else {
                        y = this.y0 - con;
                    }
                    p.x = x;
                    p.y = y;
                    return p;
                };
                exports.inverse = function (p) {
                    var lon, lat;
                    var xx, yy, xys, c1, c2, c3;
                    var a1;
                    var m1;
                    var con;
                    var th1;
                    var d;
                    p.x -= this.x0;
                    p.y -= this.y0;
                    con = Math.PI * this.R;
                    xx = p.x / con;
                    yy = p.y / con;
                    xys = xx * xx + yy * yy;
                    c1 = -Math.abs(yy) * (1 + xys);
                    c2 = c1 - 2 * yy * yy + xx * xx;
                    c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
                    d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
                    a1 = (c1 - c2 * c2 / 3 / c3) / c3;
                    m1 = 2 * Math.sqrt(-a1 / 3);
                    con = 3 * d / a1 / m1;
                    if (Math.abs(con) > 1) {
                        if (con >= 0) {
                            con = 1;
                        } else {
                            con = -1;
                        }
                    }
                    th1 = Math.acos(con) / 3;
                    if (p.y >= 0) {
                        lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
                    } else {
                        lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
                    }
                    if (Math.abs(xx) < EPSLN) {
                        lon = this.long0;
                    } else {
                        lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
                    }
                    p.x = lon;
                    p.y = lat;
                    return p;
                };
                exports.names = [
                    'Van_der_Grinten_I',
                    'VanDerGrinten',
                    'vandg'
                ];
                return exports;
            },
            {
                '../common/adjust_lon': 5,
                '../common/asinz': 6
            }
        ],
        64: [
            function (_dereq_, module, exports) {
                var D2R = 0.017453292519943295;
                var R2D = 57.29577951308232;
                var PJD_3PARAM = 1;
                var PJD_7PARAM = 2;
                var datum_transform = _dereq_('./datum_transform');
                var adjust_axis = _dereq_('./adjust_axis');
                var proj = _dereq_('./Proj');
                var toPoint = _dereq_('./common/toPoint');
                module.exports = function transform(source, dest, point) {
                    var wgs84;
                    if (Array.isArray(point)) {
                        point = toPoint(point);
                    }
                    function checkNotWGS(source, dest) {
                        return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84';
                    }
                    if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {
                        wgs84 = new proj('WGS84');
                        transform(source, wgs84, point);
                        source = wgs84;
                    }
                    if (source.axis !== 'enu') {
                        adjust_axis(source, false, point);
                    }
                    if (source.projName === 'longlat') {
                        point.x *= D2R;
                        point.y *= D2R;
                    } else {
                        if (source.to_meter) {
                            point.x *= source.to_meter;
                            point.y *= source.to_meter;
                        }
                        source.inverse(point);
                    }
                    if (source.from_greenwich) {
                        point.x += source.from_greenwich;
                    }
                    point = datum_transform(source.datum, dest.datum, point);
                    if (dest.from_greenwich) {
                        point.x -= dest.from_greenwich;
                    }
                    if (dest.projName === 'longlat') {
                        point.x *= R2D;
                        point.y *= R2D;
                    } else {
                        dest.forward(point);
                        if (dest.to_meter) {
                            point.x /= dest.to_meter;
                            point.y /= dest.to_meter;
                        }
                    }
                    if (dest.axis !== 'enu') {
                        adjust_axis(dest, true, point);
                    }
                    return point;
                };
                return exports;
            },
            {
                './Proj': 2,
                './adjust_axis': 3,
                './common/toPoint': 23,
                './datum_transform': 30
            }
        ],
        65: [
            function (_dereq_, module, exports) {
                var D2R = 0.017453292519943295;
                var extend = _dereq_('./extend');
                function mapit(obj, key, v) {
                    obj[key] = v.map(function (aa) {
                        var o = {};
                        sExpr(aa, o);
                        return o;
                    }).reduce(function (a, b) {
                        return extend(a, b);
                    }, {});
                }
                function sExpr(v, obj) {
                    var key;
                    if (!Array.isArray(v)) {
                        obj[v] = true;
                        return;
                    } else {
                        key = v.shift();
                        if (key === 'PARAMETER') {
                            key = v.shift();
                        }
                        if (v.length === 1) {
                            if (Array.isArray(v[0])) {
                                obj[key] = {};
                                sExpr(v[0], obj[key]);
                            } else {
                                obj[key] = v[0];
                            }
                        } else if (!v.length) {
                            obj[key] = true;
                        } else if (key === 'TOWGS84') {
                            obj[key] = v;
                        } else {
                            obj[key] = {};
                            if ([
                                    'UNIT',
                                    'PRIMEM',
                                    'VERT_DATUM'
                                ].indexOf(key) > -1) {
                                obj[key] = {
                                    name: v[0].toLowerCase(),
                                    convert: v[1]
                                };
                                if (v.length === 3) {
                                    obj[key].auth = v[2];
                                }
                            } else if (key === 'SPHEROID') {
                                obj[key] = {
                                    name: v[0],
                                    a: v[1],
                                    rf: v[2]
                                };
                                if (v.length === 4) {
                                    obj[key].auth = v[3];
                                }
                            } else if ([
                                    'GEOGCS',
                                    'GEOCCS',
                                    'DATUM',
                                    'VERT_CS',
                                    'COMPD_CS',
                                    'LOCAL_CS',
                                    'FITTED_CS',
                                    'LOCAL_DATUM'
                                ].indexOf(key) > -1) {
                                v[0] = [
                                    'name',
                                    v[0]
                                ];
                                mapit(obj, key, v);
                            } else if (v.every(function (aa) {
                                    return Array.isArray(aa);
                                })) {
                                mapit(obj, key, v);
                            } else {
                                sExpr(v, obj[key]);
                            }
                        }
                    }
                }
                function rename(obj, params) {
                    var outName = params[0];
                    var inName = params[1];
                    if (!(outName in obj) && inName in obj) {
                        obj[outName] = obj[inName];
                        if (params.length === 3) {
                            obj[outName] = params[2](obj[outName]);
                        }
                    }
                }
                function d2r(input) {
                    return input * D2R;
                }
                function cleanWKT(wkt) {
                    if (wkt.type === 'GEOGCS') {
                        wkt.projName = 'longlat';
                    } else if (wkt.type === 'LOCAL_CS') {
                        wkt.projName = 'identity';
                        wkt.local = true;
                    } else {
                        if (typeof wkt.PROJECTION === 'object') {
                            wkt.projName = Object.keys(wkt.PROJECTION)[0];
                        } else {
                            wkt.projName = wkt.PROJECTION;
                        }
                    }
                    if (wkt.UNIT) {
                        wkt.units = wkt.UNIT.name.toLowerCase();
                        if (wkt.units === 'metre') {
                            wkt.units = 'meter';
                        }
                        if (wkt.UNIT.convert) {
                            wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
                        }
                    }
                    if (wkt.GEOGCS) {
                        if (wkt.GEOGCS.DATUM) {
                            wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
                        } else {
                            wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
                        }
                        if (wkt.datumCode.slice(0, 2) === 'd_') {
                            wkt.datumCode = wkt.datumCode.slice(2);
                        }
                        if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
                            wkt.datumCode = 'nzgd49';
                        }
                        if (wkt.datumCode === 'wgs_1984') {
                            if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
                                wkt.sphere = true;
                            }
                            wkt.datumCode = 'wgs84';
                        }
                        if (wkt.datumCode.slice(-6) === '_ferro') {
                            wkt.datumCode = wkt.datumCode.slice(0, -6);
                        }
                        if (wkt.datumCode.slice(-8) === '_jakarta') {
                            wkt.datumCode = wkt.datumCode.slice(0, -8);
                        }
                        if (~wkt.datumCode.indexOf('belge')) {
                            wkt.datumCode = 'rnb72';
                        }
                        if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
                            wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
                            if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
                                wkt.ellps = 'intl';
                            }
                            wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
                            wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
                        }
                        if (~wkt.datumCode.indexOf('osgb_1936')) {
                            wkt.datumCode = 'osgb36';
                        }
                    }
                    if (wkt.b && !isFinite(wkt.b)) {
                        wkt.b = wkt.a;
                    }
                    function toMeter(input) {
                        var ratio = wkt.to_meter || 1;
                        return parseFloat(input, 10) * ratio;
                    }
                    var renamer = function (a) {
                        return rename(wkt, a);
                    };
                    var list = [
                        [
                            'standard_parallel_1',
                            'Standard_Parallel_1'
                        ],
                        [
                            'standard_parallel_2',
                            'Standard_Parallel_2'
                        ],
                        [
                            'false_easting',
                            'False_Easting'
                        ],
                        [
                            'false_northing',
                            'False_Northing'
                        ],
                        [
                            'central_meridian',
                            'Central_Meridian'
                        ],
                        [
                            'latitude_of_origin',
                            'Latitude_Of_Origin'
                        ],
                        [
                            'scale_factor',
                            'Scale_Factor'
                        ],
                        [
                            'k0',
                            'scale_factor'
                        ],
                        [
                            'latitude_of_center',
                            'Latitude_of_center'
                        ],
                        [
                            'lat0',
                            'latitude_of_center',
                            d2r
                        ],
                        [
                            'longitude_of_center',
                            'Longitude_Of_Center'
                        ],
                        [
                            'longc',
                            'longitude_of_center',
                            d2r
                        ],
                        [
                            'x0',
                            'false_easting',
                            toMeter
                        ],
                        [
                            'y0',
                            'false_northing',
                            toMeter
                        ],
                        [
                            'long0',
                            'central_meridian',
                            d2r
                        ],
                        [
                            'lat0',
                            'latitude_of_origin',
                            d2r
                        ],
                        [
                            'lat0',
                            'standard_parallel_1',
                            d2r
                        ],
                        [
                            'lat1',
                            'standard_parallel_1',
                            d2r
                        ],
                        [
                            'lat2',
                            'standard_parallel_2',
                            d2r
                        ],
                        [
                            'alpha',
                            'azimuth',
                            d2r
                        ],
                        [
                            'srsCode',
                            'name'
                        ]
                    ];
                    list.forEach(renamer);
                    if (!wkt.long0 && wkt.longc && (wkt.PROJECTION === 'Albers_Conic_Equal_Area' || wkt.PROJECTION === 'Lambert_Azimuthal_Equal_Area')) {
                        wkt.long0 = wkt.longc;
                    }
                }
                module.exports = function (wkt, self) {
                    var lisp = JSON.parse((',' + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]'));
                    var type = lisp.shift();
                    var name = lisp.shift();
                    lisp.unshift([
                        'name',
                        name
                    ]);
                    lisp.unshift([
                        'type',
                        type
                    ]);
                    lisp.unshift('output');
                    var obj = {};
                    sExpr(lisp, obj);
                    cleanWKT(obj.output);
                    return extend(self, obj.output);
                };
                return exports;
            },
            { './extend': 33 }
        ],
        66: [
            function (_dereq_, module, exports) {
                var NUM_100K_SETS = 6;
                var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
                var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
                var A = 65;
                var I = 73;
                var O = 79;
                var V = 86;
                var Z = 90;
                exports.forward = function (ll, accuracy) {
                    accuracy = accuracy || 5;
                    return encode(LLtoUTM({
                        lat: ll[1],
                        lon: ll[0]
                    }), accuracy);
                };
                exports.inverse = function (mgrs) {
                    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
                    return [
                        bbox.left,
                        bbox.bottom,
                        bbox.right,
                        bbox.top
                    ];
                };
                exports.toPoint = function (mgrsStr) {
                    var llbbox = exports.inverse(mgrsStr);
                    return [
                        (llbbox[2] + llbbox[0]) / 2,
                        (llbbox[3] + llbbox[1]) / 2
                    ];
                };
                function degToRad(deg) {
                    return deg * (Math.PI / 180);
                }
                function radToDeg(rad) {
                    return 180 * (rad / Math.PI);
                }
                function LLtoUTM(ll) {
                    var Lat = ll.lat;
                    var Long = ll.lon;
                    var a = 6378137;
                    var eccSquared = 0.00669438;
                    var k0 = 0.9996;
                    var LongOrigin;
                    var eccPrimeSquared;
                    var N, T, C, A, M;
                    var LatRad = degToRad(Lat);
                    var LongRad = degToRad(Long);
                    var LongOriginRad;
                    var ZoneNumber;
                    ZoneNumber = Math.floor((Long + 180) / 6) + 1;
                    if (Long === 180) {
                        ZoneNumber = 60;
                    }
                    if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
                        ZoneNumber = 32;
                    }
                    if (Lat >= 72 && Lat < 84) {
                        if (Long >= 0 && Long < 9) {
                            ZoneNumber = 31;
                        } else if (Long >= 9 && Long < 21) {
                            ZoneNumber = 33;
                        } else if (Long >= 21 && Long < 33) {
                            ZoneNumber = 35;
                        } else if (Long >= 33 && Long < 42) {
                            ZoneNumber = 37;
                        }
                    }
                    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
                    LongOriginRad = degToRad(LongOrigin);
                    eccPrimeSquared = eccSquared / (1 - eccSquared);
                    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
                    T = Math.tan(LatRad) * Math.tan(LatRad);
                    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
                    A = Math.cos(LatRad) * (LongRad - LongOriginRad);
                    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
                    var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120) + 500000;
                    var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720));
                    if (Lat < 0) {
                        UTMNorthing += 10000000;
                    }
                    return {
                        northing: Math.round(UTMNorthing),
                        easting: Math.round(UTMEasting),
                        zoneNumber: ZoneNumber,
                        zoneLetter: getLetterDesignator(Lat)
                    };
                }
                function UTMtoLL(utm) {
                    var UTMNorthing = utm.northing;
                    var UTMEasting = utm.easting;
                    var zoneLetter = utm.zoneLetter;
                    var zoneNumber = utm.zoneNumber;
                    if (zoneNumber < 0 || zoneNumber > 60) {
                        return null;
                    }
                    var k0 = 0.9996;
                    var a = 6378137;
                    var eccSquared = 0.00669438;
                    var eccPrimeSquared;
                    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
                    var N1, T1, C1, R1, D, M;
                    var LongOrigin;
                    var mu, phi1Rad;
                    var x = UTMEasting - 500000;
                    var y = UTMNorthing;
                    if (zoneLetter < 'N') {
                        y -= 10000000;
                    }
                    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
                    eccPrimeSquared = eccSquared / (1 - eccSquared);
                    M = y / k0;
                    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
                    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
                    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
                    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
                    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
                    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
                    D = x / (N1 * k0);
                    var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
                    lat = radToDeg(lat);
                    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
                    lon = LongOrigin + radToDeg(lon);
                    var result;
                    if (utm.accuracy) {
                        var topRight = UTMtoLL({
                            northing: utm.northing + utm.accuracy,
                            easting: utm.easting + utm.accuracy,
                            zoneLetter: utm.zoneLetter,
                            zoneNumber: utm.zoneNumber
                        });
                        result = {
                            top: topRight.lat,
                            right: topRight.lon,
                            bottom: lat,
                            left: lon
                        };
                    } else {
                        result = {
                            lat: lat,
                            lon: lon
                        };
                    }
                    return result;
                }
                function getLetterDesignator(lat) {
                    var LetterDesignator = 'Z';
                    if (84 >= lat && lat >= 72) {
                        LetterDesignator = 'X';
                    } else if (72 > lat && lat >= 64) {
                        LetterDesignator = 'W';
                    } else if (64 > lat && lat >= 56) {
                        LetterDesignator = 'V';
                    } else if (56 > lat && lat >= 48) {
                        LetterDesignator = 'U';
                    } else if (48 > lat && lat >= 40) {
                        LetterDesignator = 'T';
                    } else if (40 > lat && lat >= 32) {
                        LetterDesignator = 'S';
                    } else if (32 > lat && lat >= 24) {
                        LetterDesignator = 'R';
                    } else if (24 > lat && lat >= 16) {
                        LetterDesignator = 'Q';
                    } else if (16 > lat && lat >= 8) {
                        LetterDesignator = 'P';
                    } else if (8 > lat && lat >= 0) {
                        LetterDesignator = 'N';
                    } else if (0 > lat && lat >= -8) {
                        LetterDesignator = 'M';
                    } else if (-8 > lat && lat >= -16) {
                        LetterDesignator = 'L';
                    } else if (-16 > lat && lat >= -24) {
                        LetterDesignator = 'K';
                    } else if (-24 > lat && lat >= -32) {
                        LetterDesignator = 'J';
                    } else if (-32 > lat && lat >= -40) {
                        LetterDesignator = 'H';
                    } else if (-40 > lat && lat >= -48) {
                        LetterDesignator = 'G';
                    } else if (-48 > lat && lat >= -56) {
                        LetterDesignator = 'F';
                    } else if (-56 > lat && lat >= -64) {
                        LetterDesignator = 'E';
                    } else if (-64 > lat && lat >= -72) {
                        LetterDesignator = 'D';
                    } else if (-72 > lat && lat >= -80) {
                        LetterDesignator = 'C';
                    }
                    return LetterDesignator;
                }
                function encode(utm, accuracy) {
                    var seasting = '' + utm.easting, snorthing = '' + utm.northing;
                    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
                }
                function get100kID(easting, northing, zoneNumber) {
                    var setParm = get100kSetForZone(zoneNumber);
                    var setColumn = Math.floor(easting / 100000);
                    var setRow = Math.floor(northing / 100000) % 20;
                    return getLetter100kID(setColumn, setRow, setParm);
                }
                function get100kSetForZone(i) {
                    var setParm = i % NUM_100K_SETS;
                    if (setParm === 0) {
                        setParm = NUM_100K_SETS;
                    }
                    return setParm;
                }
                function getLetter100kID(column, row, parm) {
                    var index = parm - 1;
                    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
                    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
                    var colInt = colOrigin + column - 1;
                    var rowInt = rowOrigin + row;
                    var rollover = false;
                    if (colInt > Z) {
                        colInt = colInt - Z + A - 1;
                        rollover = true;
                    }
                    if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
                        colInt++;
                    }
                    if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
                        colInt++;
                        if (colInt === I) {
                            colInt++;
                        }
                    }
                    if (colInt > Z) {
                        colInt = colInt - Z + A - 1;
                    }
                    if (rowInt > V) {
                        rowInt = rowInt - V + A - 1;
                        rollover = true;
                    } else {
                        rollover = false;
                    }
                    if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
                        rowInt++;
                    }
                    if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
                        rowInt++;
                        if (rowInt === I) {
                            rowInt++;
                        }
                    }
                    if (rowInt > V) {
                        rowInt = rowInt - V + A - 1;
                    }
                    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
                    return twoLetter;
                }
                function decode(mgrsString) {
                    if (mgrsString && mgrsString.length === 0) {
                        throw 'MGRSPoint coverting from nothing';
                    }
                    var length = mgrsString.length;
                    var hunK = null;
                    var sb = '';
                    var testChar;
                    var i = 0;
                    while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
                        if (i >= 2) {
                            throw 'MGRSPoint bad conversion from: ' + mgrsString;
                        }
                        sb += testChar;
                        i++;
                    }
                    var zoneNumber = parseInt(sb, 10);
                    if (i === 0 || i + 3 > length) {
                        throw 'MGRSPoint bad conversion from: ' + mgrsString;
                    }
                    var zoneLetter = mgrsString.charAt(i++);
                    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
                        throw 'MGRSPoint zone letter ' + zoneLetter + ' not handled: ' + mgrsString;
                    }
                    hunK = mgrsString.substring(i, i += 2);
                    var set = get100kSetForZone(zoneNumber);
                    var east100k = getEastingFromChar(hunK.charAt(0), set);
                    var north100k = getNorthingFromChar(hunK.charAt(1), set);
                    while (north100k < getMinNorthing(zoneLetter)) {
                        north100k += 2000000;
                    }
                    var remainder = length - i;
                    if (remainder % 2 !== 0) {
                        throw 'MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters' + mgrsString;
                    }
                    var sep = remainder / 2;
                    var sepEasting = 0;
                    var sepNorthing = 0;
                    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
                    if (sep > 0) {
                        accuracyBonus = 100000 / Math.pow(10, sep);
                        sepEastingString = mgrsString.substring(i, i + sep);
                        sepEasting = parseFloat(sepEastingString) * accuracyBonus;
                        sepNorthingString = mgrsString.substring(i + sep);
                        sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
                    }
                    easting = sepEasting + east100k;
                    northing = sepNorthing + north100k;
                    return {
                        easting: easting,
                        northing: northing,
                        zoneLetter: zoneLetter,
                        zoneNumber: zoneNumber,
                        accuracy: accuracyBonus
                    };
                }
                function getEastingFromChar(e, set) {
                    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
                    var eastingValue = 100000;
                    var rewindMarker = false;
                    while (curCol !== e.charCodeAt(0)) {
                        curCol++;
                        if (curCol === I) {
                            curCol++;
                        }
                        if (curCol === O) {
                            curCol++;
                        }
                        if (curCol > Z) {
                            if (rewindMarker) {
                                throw 'Bad character: ' + e;
                            }
                            curCol = A;
                            rewindMarker = true;
                        }
                        eastingValue += 100000;
                    }
                    return eastingValue;
                }
                function getNorthingFromChar(n, set) {
                    if (n > 'V') {
                        throw 'MGRSPoint given invalid Northing ' + n;
                    }
                    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
                    var northingValue = 0;
                    var rewindMarker = false;
                    while (curRow !== n.charCodeAt(0)) {
                        curRow++;
                        if (curRow === I) {
                            curRow++;
                        }
                        if (curRow === O) {
                            curRow++;
                        }
                        if (curRow > V) {
                            if (rewindMarker) {
                                throw 'Bad character: ' + n;
                            }
                            curRow = A;
                            rewindMarker = true;
                        }
                        northingValue += 100000;
                    }
                    return northingValue;
                }
                function getMinNorthing(zoneLetter) {
                    var northing;
                    switch (zoneLetter) {
                    case 'C':
                        northing = 1100000;
                        break;
                    case 'D':
                        northing = 2000000;
                        break;
                    case 'E':
                        northing = 2800000;
                        break;
                    case 'F':
                        northing = 3700000;
                        break;
                    case 'G':
                        northing = 4600000;
                        break;
                    case 'H':
                        northing = 5500000;
                        break;
                    case 'J':
                        northing = 6400000;
                        break;
                    case 'K':
                        northing = 7300000;
                        break;
                    case 'L':
                        northing = 8200000;
                        break;
                    case 'M':
                        northing = 9100000;
                        break;
                    case 'N':
                        northing = 0;
                        break;
                    case 'P':
                        northing = 800000;
                        break;
                    case 'Q':
                        northing = 1700000;
                        break;
                    case 'R':
                        northing = 2600000;
                        break;
                    case 'S':
                        northing = 3500000;
                        break;
                    case 'T':
                        northing = 4400000;
                        break;
                    case 'U':
                        northing = 5300000;
                        break;
                    case 'V':
                        northing = 6200000;
                        break;
                    case 'W':
                        northing = 7000000;
                        break;
                    case 'X':
                        northing = 7900000;
                        break;
                    default:
                        northing = -1;
                    }
                    if (northing >= 0) {
                        return northing;
                    } else {
                        throw 'Invalid zone letter: ' + zoneLetter;
                    }
                }
                return exports;
            },
            {}
        ],
        67: [
            function (_dereq_, module, exports) {
                module.exports = {
                    'name': 'proj4',
                    'version': '2.2.1',
                    'description': 'Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.',
                    'main': 'lib/index.js',
                    'directories': {
                        'test': 'test',
                        'doc': 'docs'
                    },
                    'scripts': { 'test': './node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js' },
                    'repository': {
                        'type': 'git',
                        'url': 'git://github.com/proj4js/proj4js.git'
                    },
                    'author': '',
                    'license': 'MIT',
                    'jam': {
                        'main': 'dist/proj4.js',
                        'include': [
                            'dist/proj4.js',
                            'README.md',
                            'AUTHORS',
                            'LICENSE.md'
                        ]
                    },
                    'devDependencies': {
                        'grunt-cli': '~0.1.13',
                        'grunt': '~0.4.2',
                        'grunt-contrib-connect': '~0.6.0',
                        'grunt-contrib-jshint': '~0.8.0',
                        'chai': '~1.8.1',
                        'mocha': '~1.17.1',
                        'grunt-mocha-phantomjs': '~0.4.0',
                        'browserify': '~3.24.5',
                        'grunt-browserify': '~1.3.0',
                        'grunt-contrib-uglify': '~0.3.2',
                        'curl': 'git://github.com/cujojs/curl.git',
                        'istanbul': '~0.2.4',
                        'tin': '~0.4.0'
                    },
                    'dependencies': { 'mgrs': '0.0.0' }
                };
                return exports;
            },
            {}
        ],
        './includedProjections': [
            function (_dereq_, module, exports) {
                module.exports = _dereq_('gWUPNW');
                return exports;
            },
            {}
        ],
        'gWUPNW': [
            function (_dereq_, module, exports) {
                var projs = [
                    _dereq_('./lib/projections/tmerc'),
                    _dereq_('./lib/projections/utm'),
                    _dereq_('./lib/projections/sterea'),
                    _dereq_('./lib/projections/stere'),
                    _dereq_('./lib/projections/somerc'),
                    _dereq_('./lib/projections/omerc'),
                    _dereq_('./lib/projections/lcc'),
                    _dereq_('./lib/projections/krovak'),
                    _dereq_('./lib/projections/cass'),
                    _dereq_('./lib/projections/laea'),
                    _dereq_('./lib/projections/aea'),
                    _dereq_('./lib/projections/gnom'),
                    _dereq_('./lib/projections/cea'),
                    _dereq_('./lib/projections/eqc'),
                    _dereq_('./lib/projections/poly'),
                    _dereq_('./lib/projections/nzmg'),
                    _dereq_('./lib/projections/mill'),
                    _dereq_('./lib/projections/sinu'),
                    _dereq_('./lib/projections/moll'),
                    _dereq_('./lib/projections/eqdc'),
                    _dereq_('./lib/projections/vandg'),
                    _dereq_('./lib/projections/aeqd')
                ];
                module.exports = function (proj4) {
                    projs.forEach(function (proj) {
                        proj4.Proj.projections.add(proj);
                    });
                };
                return exports;
            },
            {
                './lib/projections/aea': 39,
                './lib/projections/aeqd': 40,
                './lib/projections/cass': 41,
                './lib/projections/cea': 42,
                './lib/projections/eqc': 43,
                './lib/projections/eqdc': 44,
                './lib/projections/gnom': 46,
                './lib/projections/krovak': 47,
                './lib/projections/laea': 48,
                './lib/projections/lcc': 49,
                './lib/projections/mill': 52,
                './lib/projections/moll': 53,
                './lib/projections/nzmg': 54,
                './lib/projections/omerc': 55,
                './lib/projections/poly': 56,
                './lib/projections/sinu': 57,
                './lib/projections/somerc': 58,
                './lib/projections/stere': 59,
                './lib/projections/sterea': 60,
                './lib/projections/tmerc': 61,
                './lib/projections/utm': 62,
                './lib/projections/vandg': 63
            }
        ]
    }, {}, [35])(35);
});
CommonUtilsRegister = function (proj4) {
    var Register = {
        isLoaded: false,
        get: function (name) {
            if (name === '' || name === null || typeof name === 'undefined') {
                return;
            }
            var s = name.split(':');
            if (s.length !== 2) {
                return;
            }
            var register = s[0];
            var code = s[1];
            if (!this.hasOwnProperty(register)) {
                return;
            }
            if (!this[register].hasOwnProperty(code)) {
                return;
            }
            return this[register][code];
        },
        load: function () {
            if (!this.isLoaded) {
                var registers = [
                    'IGNF',
                    'EPSG',
                    'CRS'
                ];
                for (var i = 0; i < registers.length; i++) {
                    var register = registers[i];
                    var codes = this[register];
                    for (var code in codes) {
                        if (codes.hasOwnProperty(code)) {
                            var name = register + ':' + code;
                            proj4.defs(name, this.get(name));
                        }
                    }
                }
                this.isLoaded = true;
            }
        },
        EPSG: {
            4149: '+title=CH1903 +proj=longlat +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +no_defs ',
            4150: '+title=CH1903plus +proj=longlat +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +no_defs ',
            4151: '+title=CHTRF95 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4171: '+title=RGF93 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4230: '+title=ED50 +proj=longlat +ellps=intl +no_defs ',
            4235: '+title=Guyane Francaise +proj=longlat +ellps=intl +no_defs ',
            4258: '+title=ETRS89 +proj=longlat +ellps=GRS80 +no_defs ',
            4275: '+title=NTF +proj=longlat +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +no_defs ',
            4322: '+title=WGS 72 +proj=longlat +ellps=WGS72 +no_defs ',
            4326: '+title=WGS 84 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ',
            4467: '+proj=utm +zone=21 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            4470: '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4471: '+proj=utm +zone=38 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            4474: '+proj=utm +zone=38 +south +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +units=m +no_defs ',
            4558: '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4559: '+proj=utm +zone=20 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            4621: '+title=Fort Marigot +proj=longlat +ellps=intl +towgs84=137,248,-430,0,0,0,0 +no_defs ',
            4622: '+title=Guadeloupe 1948 +proj=longlat +ellps=intl +no_defs ',
            4623: '+title=CSG67 +proj=longlat +ellps=intl +towgs84=-186,230,110,0,0,0,0 +no_defs ',
            4624: '+title=RGFG95 +proj=longlat +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +no_defs ',
            4625: '+title=Martinique 1938 +proj=longlat +ellps=intl +no_defs ',
            4626: '+title=Reunion 1947 +proj=longlat +ellps=intl +no_defs ',
            4627: '+title=RGR92 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4628: '+title=Tahiti 52 +proj=longlat +ellps=intl +towgs84=162,117,154,0,0,0,0 +no_defs ',
            4629: '+title=Tahaa 54 +proj=longlat +ellps=intl +no_defs ',
            4630: '+title=IGN72 Nuku Hiva +proj=longlat +ellps=intl +no_defs ',
            4632: '+title=Combani 1950 +proj=longlat +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +no_defs ',
            4633: '+title=IGN56 Lifou +proj=longlat +ellps=intl +no_defs ',
            4634: '+title=IGN72 Grand Terre +proj=longlat +ellps=intl +no_defs ',
            4637: '+title=Perroud 1950 +proj=longlat +ellps=intl +towgs84=325,154,172,0,0,0,0 +no_defs ',
            4638: '+title=Saint Pierre et Miquelon 1950 +proj=longlat +ellps=clrk66 +towgs84=30,430,368,0,0,0,0 +no_defs ',
            4640: '+title=RRAF 1991 +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4641: '+title=IGN53 Mare +proj=longlat +ellps=intl +no_defs ',
            4645: '+title=RGNC 1991 +proj=longlat +ellps=intl +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4687: '+proj=longlat +ellps=GRS80 +no_defs ',
            4662: '+title=IGN72 Grande Terre +proj=longlat +ellps=intl +no_defs ',
            4689: '+title=IGN63 Hiva Oa +proj=longlat +ellps=intl +no_defs ',
            4690: '+title=Tahiti 79 +proj=longlat +ellps=intl +no_defs ',
            4691: '+title=Moorea 87 +proj=longlat +ellps=intl +towgs84=215.525,149.593,176.229,-3.2624,-1.692,-1.1571,10.4773 +no_defs ',
            4692: '+title=Maupiti 83 +proj=longlat +ellps=intl +towgs84=217.037,86.959,23.956,0,0,0,0 +no_defs ',
            4698: '+title=IGN 1962 Kerguelen +proj=longlat +ellps=intl +towgs84=145,-187,103,0,0,0,0 +no_defs ',
            4749: '+title=RGNC91-93 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ',
            4750: '+title=ST87 Ouvea +proj=longlat +ellps=WGS84 +towgs84=-56.263,16.136,-22.856,0,0,0,0 +no_defs ',
            4807: '+title=NTF (Paris) +proj=longlat +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +no_defs ',
            2056: '+title=CH1903+ / LV95 +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ',
            2154: '+title=RGF93 / Lambert-93 +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            2213: '+title=ETRS89 / TM 30 NE +proj=tmerc +lat_0=0 +lon_0=30 +k=0.9996 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs ',
            2969: '+title=Fort Marigot / UTM zone 20N +proj=utm +zone=20 +ellps=intl +towgs84=137,248,-430,0,0,0,0 +units=m +no_defs ',
            2970: '+title=Guadeloupe 1948 / UTM zone 20N +proj=utm +zone=20 +ellps=intl +units=m +no_defs ',
            2971: '+title=CSG67 / UTM zone 22N +proj=utm +zone=22 +ellps=intl +towgs84=-186,230,110,0,0,0,0 +units=m +no_defs ',
            2972: '+title=RGFG95 / UTM zone 22N +proj=utm +zone=22 +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +units=m +no_defs ',
            2973: '+title=Martinique 1938 / UTM zone 20N +proj=utm +zone=20 +ellps=intl +units=m +no_defs ',
            2975: '+title=RGR92 / UTM zone 40S +proj=utm +zone=40 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            2976: '+title=Tahiti 52 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +towgs84=162,117,154,0,0,0,0 +units=m +no_defs ',
            2977: '+title=Tahaa 54 / UTM zone 5S +proj=utm +zone=5 +south +ellps=intl +units=m +no_defs ',
            2978: '+title=IGN72 Nuku Hiva / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +units=m +no_defs ',
            2980: '+title=Combani 1950 / UTM zone 38S +proj=utm +zone=38 +south +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +units=m +no_defs ',
            2981: '+title=IGN56 Lifou / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ',
            2982: '+title=IGN72 Grand Terre / UTM zone 58S (deprecated) +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ',
            2984: '+title=RGNC 1991 / Lambert New Caledonia (deprecated) +proj=lcc +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5 +lon_0=166 +x_0=400000 +y_0=300000 +ellps=intl +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            2986: '+title=Terre Adelie 1950 +proj=stere +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-90.000000000 +lon_0=140.000000000 +lat_ts=-67.000000000 +k=0.96027295 +x_0=300000.000 +y_0=-2299363.482 +units=m +no_defs',
            2987: '+title=Saint Pierre et Miquelon 1950 / UTM zone 21N +proj=utm +zone=21 +ellps=clrk66 +towgs84=30,430,368,0,0,0,0 +units=m +no_defs ',
            2989: '+title=RRAF 1991 / UTM zone 20N +proj=utm +zone=20 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            2990: '+title=Reunion 1947 / TM Reunion (deprecated) +proj=tmerc +lat_0=-21.11666666666667 +lon_0=55.53333333333333 +k=1 +x_0=50000 +y_0=160000 +ellps=intl +units=m +no_defs ',
            2995: '+title=IGN53 Mare / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ',
            3038: '+proj=utm +zone=26 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3039: '+proj=utm +zone=27 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3040: '+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3041: '+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3045: '+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3046: '+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3047: '+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3048: '+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3049: '+proj=utm +zone=37 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3050: '+proj=utm +zone=38 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3051: '+proj=utm +zone=39 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3034: '+title=ETRS89 / ETRS-LCC +proj=lcc +lat_1=35 +lat_2=65 +lat_0=52 +lon_0=10 +x_0=4000000 +y_0=2800000 +ellps=GRS80 +units=m +no_defs ',
            3035: '+title=ETRS89 / ETRS-LAEA +proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ',
            3042: '+title=ETRS89 / ETRS-TM30 +proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs ',
            3043: '+title=ETRS89 / ETRS-TM31 +proj=utm +zone=31 +ellps=GRS80 +units=m +no_defs ',
            3044: '+title=ETRS89 / ETRS-TM32 +proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs ',
            25828: '+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            25829: '+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            25833: '+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            25834: '+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            25835: '+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            25836: '+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            25837: '+proj=utm +zone=37 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            25838: '+proj=utm +zone=38 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3060: '+title=IGN72 Grande Terre / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ',
            3163: '+title=RGNC91-93 / Lambert New Caledonia +proj=lcc +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5 +lon_0=166 +x_0=400000 +y_0=300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3164: '+title=ST87 Ouvea / UTM zone 58S +proj=utm +zone=58 +south +ellps=WGS84 +towgs84=-56.263,16.136,-22.856,0,0,0,0 +units=m +no_defs ',
            3165: '+title=NEA74 Noumea / Noumea Lambert +proj=lcc +lat_1=-22.24469175 +lat_2=-22.29469175 +lat_0=-22.26969175 +lon_0=166.44242575 +x_0=0.66 +y_0=1.02 +ellps=intl +units=m +no_defs ',
            3166: '+title=NEA74 Noumea / Noumea Lambert 2 +proj=lcc +lat_1=-22.24472222222222 +lat_2=-22.29472222222222 +lat_0=-22.26972222222222 +lon_0=166.4425 +x_0=8.313000000000001 +y_0=-2.354 +ellps=intl +units=m +no_defs ',
            3169: '+title=RGNC91-93 / UTM zone 57S +proj=utm +zone=57 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3170: '+title=RGNC91-93 / UTM zone 58S +proj=utm +zone=58 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3171: '+title=RGNC91-93 / UTM zone 59S +proj=utm +zone=59 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ',
            3172: '+title=IGN53 Mare / UTM zone 59S +proj=utm +zone=59 +south +ellps=intl +units=m +no_defs ',
            3296: '+title=RGPF / UTM zone 5S +proj=utm +zone=5 +south +ellps=GRS80 +units=m +no_defs ',
            3297: '+title=RGPF / UTM zone 6S +proj=utm +zone=6 +south +ellps=GRS80 +units=m +no_defs ',
            3298: '+title=RGPF / UTM zone 7S +proj=utm +zone=7 +south +ellps=GRS80 +units=m +no_defs ',
            3299: '+title=RGPF / UTM zone 8S +proj=utm +zone=8 +south +ellps=GRS80 +units=m +no_defs ',
            3302: '+title=IGN63 Hiva Oa / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +units=m +no_defs ',
            3303: '+title=Fatu Iva 72 / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +towgs84=347.103,1078.12,2623.92,-33.8875,70.6773,-9.3943,186.074 +units=m +no_defs ',
            3304: '+title=Tahiti 79 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +units=m +no_defs ',
            3305: '+title=Moorea 87 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +towgs84=215.525,149.593,176.229,-3.2624,-1.692,-1.1571,10.4773 +units=m +no_defs ',
            3306: '+title=Maupiti 83 / UTM zone 5S +proj=utm +zone=5 +south +ellps=intl +towgs84=217.037,86.959,23.956,0,0,0,0 +units=m +no_defs ',
            3312: '+title=CSG67 / UTM zone 21N +proj=utm +zone=21 +ellps=intl +towgs84=-186,230,110,0,0,0,0 +units=m +no_defs ',
            3313: '+title=RGFG95 / UTM zone 21N +proj=utm +zone=21 +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +units=m +no_defs ',
            3336: '+title=IGN 1962 Kerguelen / UTM zone 42S +proj=utm +zone=42 +south +ellps=intl +towgs84=145,-187,103,0,0,0,0 +units=m +no_defs ',
            3395: '+title=WGS 84 / World Mercator +proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            3727: '+title=Reunion 1947 / TM Reunion +proj=tmerc +lat_0=-21.11666666666667 +lon_0=55.53333333333333 +k=1 +x_0=160000 +y_0=50000 +ellps=intl +units=m +no_defs ',
            21781: '+title=CH1903 / LV03 +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ',
            25830: '+title=ETRS89 / UTM zone 30N +proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs ',
            25831: '+title=ETRS89 / UTM zone 31N +proj=utm +zone=31 +ellps=GRS80 +units=m +no_defs ',
            25832: '+title=ETRS89 / UTM zone 32N +proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs ',
            27561: '+title=NTF (Paris) / Lambert Nord France +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27562: '+title=NTF (Paris) / Lambert Centre France +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27563: '+title=NTF (Paris) / Lambert Sud France +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27564: '+title=NTF (Paris) / Lambert Corse +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27571: '+title=NTF (Paris) / Lambert zone I +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=1200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27572: '+title=NTF (Paris) / Lambert zone II +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27573: '+title=NTF (Paris) / Lambert zone III +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=3200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27574: '+title=NTF (Paris) / Lambert zone IV +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=4185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27581: '+title=NTF (Paris) / France I (deprecated) +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=1200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27582: '+title=NTF (Paris) / France II (deprecated) +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27583: '+title=NTF (Paris) / France III (deprecated) +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=3200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27584: '+title=NTF (Paris) / France IV (deprecated) +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=4185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27591: '+title=NTF (Paris) / Nord France (deprecated) +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27592: '+title=NTF (Paris) / Centre France (deprecated) +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27593: '+title=NTF (Paris) / Sud France (deprecated) +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            27594: '+title=NTF (Paris) / Corse (deprecated) +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ',
            32601: '+proj=utm +zone=1 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32602: '+proj=utm +zone=2 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32603: '+proj=utm +zone=3 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32604: '+proj=utm +zone=4 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32605: '+proj=utm +zone=5 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32606: '+proj=utm +zone=6 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32607: '+proj=utm +zone=7 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32608: '+proj=utm +zone=8 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32609: '+proj=utm +zone=9 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32610: '+proj=utm +zone=10 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32611: '+proj=utm +zone=11 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32612: '+proj=utm +zone=12 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32613: '+proj=utm +zone=13 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32614: '+proj=utm +zone=14 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32615: '+proj=utm +zone=15 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32616: '+proj=utm +zone=16 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32617: '+proj=utm +zone=17 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32618: '+proj=utm +zone=18 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32619: '+proj=utm +zone=19 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32620: '+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32621: '+proj=utm +zone=21 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32622: '+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32623: '+proj=utm +zone=23 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32624: '+proj=utm +zone=24 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32625: '+proj=utm +zone=25 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32626: '+proj=utm +zone=26 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32627: '+proj=utm +zone=27 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32628: '+proj=utm +zone=28 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32629: '+proj=utm +zone=29 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32630: '+proj=utm +zone=30 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32631: '+proj=utm +zone=31 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32632: '+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32633: '+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32634: '+proj=utm +zone=34 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32635: '+proj=utm +zone=35 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32636: '+proj=utm +zone=36 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32637: '+proj=utm +zone=37 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32638: '+proj=utm +zone=38 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32639: '+proj=utm +zone=39 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32640: '+proj=utm +zone=40 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32641: '+proj=utm +zone=41 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32642: '+proj=utm +zone=42 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32643: '+proj=utm +zone=43 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32644: '+proj=utm +zone=44 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32645: '+proj=utm +zone=45 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32646: '+proj=utm +zone=46 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32647: '+proj=utm +zone=47 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32648: '+proj=utm +zone=48 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32649: '+proj=utm +zone=49 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32650: '+proj=utm +zone=50 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32651: '+proj=utm +zone=51 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32652: '+proj=utm +zone=52 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32653: '+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32654: '+proj=utm +zone=54 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32655: '+proj=utm +zone=55 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32656: '+proj=utm +zone=56 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32657: '+proj=utm +zone=57 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32658: '+proj=utm +zone=58 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32659: '+proj=utm +zone=59 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32660: '+proj=utm +zone=60 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32661: '+proj=stere +lat_0=90 +lat_ts=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32662: '+title=WGS 84 / Plate Carree +proj=eqc +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32701: '+proj=utm +zone=1 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32702: '+proj=utm +zone=2 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32703: '+proj=utm +zone=3 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32704: '+proj=utm +zone=4 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32705: '+proj=utm +zone=5 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32706: '+proj=utm +zone=6 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32707: '+proj=utm +zone=7 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32708: '+proj=utm +zone=8 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32709: '+proj=utm +zone=9 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32710: '+proj=utm +zone=10 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32711: '+proj=utm +zone=11 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32712: '+proj=utm +zone=12 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32713: '+proj=utm +zone=13 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32714: '+proj=utm +zone=14 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32715: '+proj=utm +zone=15 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32716: '+proj=utm +zone=16 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32717: '+proj=utm +zone=17 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32718: '+proj=utm +zone=18 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32719: '+proj=utm +zone=19 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32720: '+proj=utm +zone=20 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32721: '+proj=utm +zone=21 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32722: '+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32723: '+proj=utm +zone=23 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32724: '+proj=utm +zone=24 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32725: '+proj=utm +zone=25 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32726: '+proj=utm +zone=26 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32727: '+proj=utm +zone=27 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32728: '+proj=utm +zone=28 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32729: '+proj=utm +zone=29 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32730: '+proj=utm +zone=30 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32731: '+proj=utm +zone=31 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32732: '+proj=utm +zone=32 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32733: '+proj=utm +zone=33 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32734: '+proj=utm +zone=34 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32735: '+proj=utm +zone=35 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32736: '+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32737: '+proj=utm +zone=37 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32738: '+proj=utm +zone=38 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32739: '+proj=utm +zone=39 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32740: '+proj=utm +zone=40 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32741: '+proj=utm +zone=41 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32742: '+proj=utm +zone=42 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32743: '+proj=utm +zone=43 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32744: '+proj=utm +zone=44 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32745: '+proj=utm +zone=45 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32746: '+proj=utm +zone=46 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32747: '+proj=utm +zone=47 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32748: '+proj=utm +zone=48 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32749: '+proj=utm +zone=49 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32750: '+proj=utm +zone=50 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32751: '+proj=utm +zone=51 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32752: '+proj=utm +zone=52 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32753: '+proj=utm +zone=53 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32754: '+proj=utm +zone=54 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32755: '+proj=utm +zone=55 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32756: '+proj=utm +zone=56 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32757: '+proj=utm +zone=57 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32758: '+proj=utm +zone=58 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32759: '+proj=utm +zone=59 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32760: '+proj=utm +zone=60 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            32761: '+proj=stere +lat_0=-90 +lat_ts=-90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ',
            310024802: '+title=Geoportail - France metropolitaine +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=46.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310915814: '+title=Geoportail - Antilles francaises +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310486805: '+title=Geoportail - Guyane +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=4.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310700806: '+title=Geoportail - Reunion et dependances +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-21.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310702807: '+title=Geoportail - Mayotte +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-12.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310706808: '+title=Geoportail - Saint-Pierre et Miquelon +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=47.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310547809: '+title=Geoportail - Nouvelle-Caledonie +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-22.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310642810: '+title=Geoportail - Wallis et Futuna +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.000000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-14.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310032811: '+title=Geoportail - Polynesie francaise +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310642812: '+title=Geoportail - Kerguelen +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-49.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310642801: '+title=Geoportail - Crozet +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-46.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310642813: '+title=Geoportail - Amsterdam et Saint-Paul +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-38.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            310642901: '+title=Geoportail - Monde +proj=mill +towgs84=0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.000000 +a=6378137.0000 +rf=298.2572221010000 +lon_0=0.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            5489: '+title=RGAF09 geographiques (dms) +proj=longlat +nadgrids=@null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137 +rf=298.257222101 +units=m +no_defs',
            5490: '+title=RGAF09 UTM Nord Fuseau 20 +proj=tmerc +nadgrids=@null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137 +rf=298.257222101 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs'
        },
        CRS: { 84: '+title=WGS 84 longitude-latitude +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ' },
        IGNF: {
            AMST63: '+title=Amsterdam 1963 +proj=geocent +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            CROZ63: '+title=Crozet 1963 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            CSG67: '+title=Guyane CSG67 +proj=geocent +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            ED50: '+title=ED50 +proj=geocent +towgs84=-84.0000,-97.0000,-117.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            ETRS89: '+title=Systeme de reference terrestre Europeen (1989) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            GUAD48: '+title=Guadeloupe Ste Anne +proj=geocent +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            GUADFM49: '+title=Guadeloupe Fort Marigot +proj=geocent +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            IGN63: '+title=IGN 1963 (Hiva Oa, Tahuata, Mohotani) +proj=geocent +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            IGN72: '+title=IGN 1972 Grande-Terre / Ile des Pins +proj=geocent +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            KERG62CAR: '+title=Kerguelen - K0 +proj=geocent +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            MART38: '+title=Martinique Fort-Desaix +proj=geocent +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            MAYO50: '+title=Mayotte Combani +proj=geocent +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            MOOREA87: '+title=Moorea 1987 +proj=geocent +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            NTF: '+title=Nouvelle Triangulation Francaise +proj=geocent +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +units=m +no_defs',
            NUKU72: '+title=IGN 1972 Nuku Hiva +proj=geocent +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            REUN47: '+title=Reunion 1947 +proj=geocent +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            RGF93: '+title=Reseau geodesique francais 1993 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGFG95: '+title=Reseau geodesique francais de Guyane 1995 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGM04: '+title=RGM04 (Reseau Geodesique de Mayotte 2004) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGNC: '+title=Reseau Geodesique de Nouvelle-Caledonie +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGPF: '+title=RGPF (Reseau Geodesique de Polynesie Francaise) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGR92: '+title=Reseau geodesique Reunion 1992 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGSPM06: '+title=Reseau Geodesique Saint-Pierre-et-Miquelon (2006) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGTAAF07: '+title=Reseau Geodesique des TAAF (2007) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RRAF91: '+title=RRAF 1991 (Reseau de Reference des Antilles Francaises) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            STPL69: '+title=Saint-Paul 1969 +proj=geocent +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            STPM50: '+title=St Pierre et Miquelon 1950 +proj=geocent +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +units=m +no_defs',
            TAHAA: '+title=Raiatea - Tahaa 51-54 (Tahaa, Base Terme Est) +proj=geocent +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            TAHI79: '+title=IGN79 (Tahiti) Iles de la Societe +proj=geocent +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            TERA50: '+title=Pointe Geologie - Perroud 1950 +proj=geocent +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            WALL78: '+title=Wallis-Uvea 1978 (MOP78) +proj=geocent +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            WGS72: '+title=World Geodetic System 1972 +proj=geocent +towgs84=0.0000,12.0000,6.0000 +a=6378135.0000 +rf=298.2600000000000 +units=m +no_defs',
            WGS84: '+title=World Geodetic System 1984 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            AMST63GEO: '+title=Amsterdam 1963 +proj=longlat +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            CROZ63GEO: '+title=Crozet 1963 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            CSG67GEO: '+title=Guyane CSG67 +proj=longlat +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            ED50G: '+title=ED50 +proj=longlat +towgs84=-84.0000,-97.0000,-117.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            GUAD48GEO: '+title=Guadeloupe Ste Anne +proj=longlat +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            GUADFM49GEO: '+title=Guadeloupe Fort Marigot +proj=longlat +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            IGN63GEO: '+title=IGN 1963 (Hiva Oa, Tahuata, Mohotani) +proj=longlat +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            IGN72GEO: '+title=IGN 1972 Grande-Terre / Ile des Pins +proj=longlat +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            KERG62GEO: '+title=Kerguelen - K0 +proj=longlat +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            MART38GEO: '+title=Martinique Fort-Desaix +proj=longlat +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            MAYO50GEO: '+title=Mayotte Combani +proj=longlat +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            MOOREA87GEO: '+title=Moorea 1987 +proj=longlat +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            NTFG: '+title=Nouvelle Triangulation Francaise Greenwich degres sexagesimaux +proj=longlat +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +units=m +no_defs',
            NTFP: '+title=Nouvelle Triangulation Francaise Paris grades +proj=longlat +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +units=m +no_defs',
            NUKU72GEO: '+title=IGN 1972 Nuku Hiva +proj=longlat +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            REUN47GEO: '+title=Reunion 1947 +proj=longlat +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            RGF93G: '+title=Reseau geodesique francais 1993 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGFG95GEO: '+title=Reseau geodesique francais de Guyane 1995 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGM04GEO: '+title=RGM04 (Reseau Geodesique de Mayotte 2004) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGNCGEO: '+title=Reseau Geodesique de Nouvelle-Caledonie +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGPFGEO: '+title=RGPF (Reseau Geodesique de Polynesie Francaise) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGR92GEO: '+title=Reseau geodesique de la Reunion 1992 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGSPM06GEO: '+title=Saint-Pierre-et-Miquelon (2006) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            RGTAAF07G: '+title=Reseau Geodesique des TAAF (2007) (dms) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            STPL69GEO: '+title=Saint-Paul 1969 +proj=longlat +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            STPM50GEO: '+title=St Pierre et Miquelon 1950  +proj=longlat +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +units=m +no_defs',
            TAHAAGEO: '+title=Raiatea - Tahaa 51-54 (Tahaa, Base Terme Est) +proj=longlat +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            TAHI79GEO: '+title=IGN79 (Tahiti) Iles de la Societe +proj=longlat +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            TERA50G: '+title=Pointe Geologie - Perroud 1950 +proj=longlat +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            WALL78GEO: '+title=Wallis - Uvea 1978 (MOP78) +proj=longlat +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs',
            WGS72G: '+title=WGS72 +proj=longlat +towgs84=0.0000,12.0000,6.0000 +a=6378135.0000 +rf=298.2600000000000 +units=m +no_defs',
            WGS84G: '+title=World Geodetic System 1984 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            WGS84RRAFGEO: '+title=Reseau de reference des Antilles francaises (1988-1991) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            XGEO: '+title=Systeme CIO-BIH +proj=longlat +towgs84=0.0000,0.0000,0.5000,0.0000,0.0000,0.0140,-0.100000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            AMST63UTM43S: '+title=Amsterdam 1963 UTM fuseau 43 Sud +proj=tmerc +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            CROZ63UTM39S: '+title=Crozet 1963 +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            CSG67UTM21: '+title=Guyane CSG67 UTM fuseau 21 +proj=tmerc +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            CSG67UTM22: '+title=Guyane CSG67 UTM fuseau 22 +proj=tmerc +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALANF: '+title=Geoportail - Antilles francaises +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALASP: '+title=Geoportail - Amsterdam et Saint-Paul +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-38.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALCRZ: '+title=Geoportail - Crozet +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-46.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALFXX: '+title=Geoportail - France metropolitaine +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=46.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALGUF: '+title=Geoportail - Guyane +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=4.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALKER: '+title=Geoportail - Kerguelen +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-49.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALMYT: '+title=Geoportail - Mayotte +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-12.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALNCL: '+title=Geoportail - Nouvelle-Caledonie +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-22.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALPYF: '+title=Geoportail - Polynesie francaise +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALREU: '+title=Geoportail - Reunion et dependances +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-21.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALSPM: '+title=Geoportail - Saint-Pierre et Miquelon +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=47.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GEOPORTALWLF: '+title=Geoportail - Wallis et Futuna +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-14.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            GUAD48UTM20: '+title=Guadeloupe Ste Anne +proj=tmerc +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            GUADFM49U20: '+title=Guadeloupe Fort Marigot  +proj=tmerc +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            IGN63UTM7S: '+title=IGN 1963 - Hiva Oa, Tahuata, Mohotani - UTM fuseau 7 Sud +proj=tmerc +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            IGN72UTM58S: '+title=IGN 1972 - UTM fuseau 58 Sud +proj=tmerc +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=165.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            KERG62UTM42S: '+title=Kerguelen 1962 +proj=tmerc +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=69.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            LAMB1: '+title=Lambert I +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=49.500000000 +lon_0=0.000000000 +k_0=0.99987734 +lat_1=49.500000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs',
            LAMB1C: '+title=Lambert I Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=49.500000000 +lon_0=0.000000000 +k_0=0.99987734 +lat_1=49.500000000 +x_0=600000.000 +y_0=1200000.000 +units=m +no_defs',
            LAMB2: '+title=Lambert II +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs',
            LAMB2C: '+title=Lambert II Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=2200000.000 +units=m +no_defs',
            LAMB3: '+title=Lambert III +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=44.100000000 +lon_0=0.000000000 +k_0=0.99987750 +lat_1=44.100000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs',
            LAMB3C: '+title=Lambert III Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=44.100000000 +lon_0=0.000000000 +k_0=0.99987750 +lat_1=44.100000000 +x_0=600000.000 +y_0=3200000.000 +units=m +no_defs',
            LAMB4: '+title=Lambert IV +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=42.165000000 +lon_0=0.000000000 +k_0=0.99994471 +lat_1=42.165000000 +x_0=234.358 +y_0=185861.369 +units=m +no_defs',
            LAMB4C: '+title=Lambert IV Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=42.165000000 +lon_0=0.000000000 +k_0=0.99994471 +lat_1=42.165000000 +x_0=234.358 +y_0=4185861.369 +units=m +no_defs',
            LAMB93: '+title=Lambert 93 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=46.500000000 +lon_0=3.000000000 +lat_1=44.000000000 +lat_2=49.000000000 +x_0=700000.000 +y_0=6600000.000 +units=m +no_defs',
            RGF93CC42: '+title=Lambert conique conforme Zone 1 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=42.000000000 +lon_0=3.000000000 +lat_1=41.200000000 +lat_2=42.800000000 +x_0=1700000.000 +y_0=1200000.000 +units=m +no_defs',
            RGF93CC43: '+title=Lambert conique conforme Zone 2 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=43.000000000 +lon_0=3.000000000 +lat_1=42.200000000 +lat_2=43.800000000 +x_0=1700000.000 +y_0=2200000.000 +units=m +no_defs',
            RGF93CC44: '+title=Lambert conique conforme Zone 3 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=44.000000000 +lon_0=3.000000000 +lat_1=43.200000000 +lat_2=44.800000000 +x_0=1700000.000 +y_0=3200000.000 +units=m +no_defs',
            RGF93CC45: '+title=Lambert conique conforme Zone 4 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=45.000000000 +lon_0=3.000000000 +lat_1=44.200000000 +lat_2=45.800000000 +x_0=1700000.000 +y_0=4200000.000 +units=m +no_defs',
            RGF93CC46: '+title=Lambert conique conforme Zone 5 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=46.000000000 +lon_0=3.000000000 +lat_1=45.200000000 +lat_2=46.800000000 +x_0=1700000.000 +y_0=5200000.000 +units=m +no_defs',
            RGF93CC47: '+title=Lambert conique conforme Zone 6 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=47.000000000 +lon_0=3.000000000 +lat_1=46.200000000 +lat_2=47.800000000 +x_0=1700000.000 +y_0=6200000.000 +units=m +no_defs',
            RGF93CC48: '+title=Lambert conique conforme Zone 7 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=48.000000000 +lon_0=3.000000000 +lat_1=47.200000000 +lat_2=48.800000000 +x_0=1700000.000 +y_0=7200000.000 +units=m +no_defs',
            RGF93CC49: '+title=Lambert conique conforme Zone 8 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=49.000000000 +lon_0=3.000000000 +lat_1=48.200000000 +lat_2=49.800000000 +x_0=1700000.000 +y_0=8200000.000 +units=m +no_defs',
            RGF93CC50: '+title=Lambert conique conforme Zone 9 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=50.000000000 +lon_0=3.000000000 +lat_1=49.200000000 +lat_2=50.800000000 +x_0=1700000.000 +y_0=9200000.000 +units=m +no_defs',
            LAMBE: '+title=Lambert II etendu +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=2200000.000 +units=m +no_defs',
            MART38UTM20: '+title=Martinique Fort-Desaix +proj=tmerc +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            MAYO50UTM38S: '+title=Mayotte Combani +proj=tmerc +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            MILLER: '+title=Geoportail - Monde +proj=mill +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lon_0=0.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs',
            MOOREA87U6S: '+title=Moorea 1987 - UTM fuseau 6 Sud +proj=tmerc +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            NUKU72U7S: '+title=IGN 1972 Nuku Hiva - UTM fuseau 7 Sud +proj=tmerc +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            REUN47GAUSSL: '+title=Reunion Gauss Laborde +proj=gstmerc +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-21.116666667 +lon_0=55.533333333 +k_0=1.00000000 +x_0=160000.000 +y_0=50000.000 +units=m +no_defs',
            RGM04UTM38S: '+title=UTM fuseau 38 Sud (Reseau Geodesique de Mayotte 2004) +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGNCUTM57S: '+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 57 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=159.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGNCUTM58S: '+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 58 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=165.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGNCUTM59S: '+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 59 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=171.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGPFUTM5S: '+title=RGPF - UTM fuseau 5 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-153.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGPFUTM6S: '+title=RGPF - UTM fuseau 6 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGPFUTM7S: '+title=RGPF - UTM fuseau 7 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGR92UTM40S: '+title=RGR92 UTM fuseau 40 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            RGSPM06U21: '+title=Saint-Pierre-et-Miquelon (2006) UTM Fuseau 21 Nord +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            STPL69UTM43S: '+title=Saint-Paul 1969 UTM fuseau 43 Sud +proj=tmerc +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            STPM50UTM21: '+title=St Pierre et Miquelon 1950 +proj=tmerc +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            TAHAAUTM05S: '+title=Tahaa 1951 +proj=tmerc +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-153.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            TAHI51UTM06S: '+title=Tahiti-Terme Nord UTM fuseau 6 Sud +proj=tmerc +towgs84=162.0000,117.0000,154.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            TAHI79UTM6S: '+title=Tahiti 1979 +proj=tmerc +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            TERA50STEREO: '+title=Terre Adelie 1950 +proj=stere +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-90.000000000 +lon_0=140.000000000 +lat_ts=-67 +k=0.96027295 +x_0=300000.000 +y_0=-2299363.482 +units=m +no_defs',
            UTM01SW84: '+title=World Geodetic System 1984 UTM fuseau 01 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-177.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            UTM20W84GUAD: '+title=World Geodetic System 1984 UTM fuseau 20 Nord-Guadeloupe +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM20W84MART: '+title=World Geodetic System 1984 UTM fuseau 20 Nord-Martinique +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM22RGFG95: '+title=RGFG95 UTM fuseau 22 Nord-Guyane +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM39SW84: '+title=World Geodetic System 1984 UTM fuseau 39 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            UTM42SW84: '+title=World Geodetic System 1984 UTM fuseau 42 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=69.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            UTM43SW84: '+title=World Geodetic System 1984 UTM fuseau 43 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            WALL78UTM1S: '+title=Wallis-Uvea 1978 (MOP78) UTM 1 SUD +proj=tmerc +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-177.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs',
            ETRS89GEO: '+title=ETRS89 geographiques (dms) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs',
            ETRS89LAEA: '+title=ETRS89 Lambert Azimutal Equal Area +proj=laea +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=52.000000000 +lon_0=10.000000000 +x_0=4321000.000 +y_0=3210000.000 +units=m +no_defs',
            ETRS89LCC: '+title=ETRS89 Lambert Conformal Conic +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=52.000000000 +lon_0=9.999999995 +lat_1=35.000000000 +lat_2=65.000000000 +x_0=4000000.000 +y_0=2800000.000 +units=m +no_defs',
            UTM26ETRS89: '+title=Europe - de 30d a 24d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-27.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM27ETRS89: '+title=Europe - de 24d a 18d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-21.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM28ETRS89: '+title=Europe - de 18d a 12d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-15.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM29ETRS89: '+title=Europe - de 12d a 6d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-9.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM30ETRS89: '+title=Europe - de -6d a 0d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-3.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM31ETRS89: '+title=Europe - de 0d a 6d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=3.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM32ETRS89: '+title=Europe - de 6d a 12d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=9.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM33ETRS89: '+title=Europe - de 12d a 18d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=15.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM34ETRS89: '+title=Europe - de 18d a 24d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=21.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM35ETRS89: '+title=Europe - de 24d a 30d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=27.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM36ETRS89: '+title=Europe - de 30d a 36d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=33.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM37ETRS89: '+title=Europe - de 36d a 42d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=39.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs',
            UTM38ETRS89: '+title=Europe - de 42d a 48d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs'
        }
    };
    return Register;
}(proj4);
CommonUtilsProxyUtils = function (woodman) {
    var ProxyUtils = {
        proxifyUrl: function (url, proxyOptions) {
            if (!proxyOptions || !proxyOptions.hasOwnProperty('proxyUrl') || proxyOptions.proxyUrl.trim().length == 0) {
                return url;
            }
            if (proxyOptions.noProxyDomains && Array.isArray(proxyOptions.noProxyDomains) && proxyOptions.noProxyDomains.length > 0) {
                for (var i in proxyOptions.noProxyDomains) {
                    if (url.indexOf(proxyOptions.noProxyDomains[i]) !== -1) {
                        return url;
                    }
                }
            }
            return proxyOptions.proxyUrl + encodeURIComponent(url);
        }
    };
    return ProxyUtils;
}({});
Ol3GfiUtils = function (ol, Gp, woodman, ProxyUtils) {
    var GfiUtils = {
        getLayerFormat: function (l) {
            var source = l.getSource();
            if (source instanceof ol.source.TileWMS || source instanceof ol.source.ImageWMS) {
                return 'wms';
            }
            if (source instanceof ol.source.WMTS) {
                return 'wmts';
            }
            if (source instanceof ol.source.Vector) {
                return 'vector';
            }
            return 'unknown';
        },
        displayInfo: function (map, coords, content, contentType) {
            if (!contentType) {
                contentType = 'text/html';
            }
            if (content === null) {
                return;
            }
            var _htmlDoc = null;
            var _parser = null;
            var _content = content;
            _content = _content.replace(/\n/g, '');
            _content = _content.replace(/(>)\s*(<)/g, '$1$2');
            var scope = typeof window !== 'undefined' ? window : null;
            if (typeof exports === 'object' && window === null) {
                var DOMParser = xmldom.DOMParser;
                _parser = new DOMParser();
                _htmlDoc = _parser.parseFromString(_content, contentType);
            } else if (scope.DOMParser) {
                _parser = new scope.DOMParser();
                _htmlDoc = _parser.parseFromString(_content, contentType);
            } else if (scope.ActiveXObject) {
                _htmlDoc = new scope.ActiveXObject('Microsoft.XMLDOM');
                _htmlDoc.async = false;
                _htmlDoc.loadXML(_content);
            } else {
                console.log('Incompatible environment for DOM Parser !');
                return false;
            }
            var body = _htmlDoc.getElementsByTagName('body');
            if (body && body.length === 1) {
                if (!body[0].hasChildNodes()) {
                    return false;
                }
            }
            var element = document.createElement('div');
            element.className = 'gp-feature-info-div';
            var closer = document.createElement('input');
            closer.type = 'button';
            closer.className = 'gp-styling-button closer';
            closer.onclick = function () {
                if (map.featuresOverlay) {
                    map.removeOverlay(map.featuresOverlay);
                    map.featuresOverlay = null;
                }
                return false;
            };
            var contentDiv = document.createElement('div');
            contentDiv.className = 'gp-features-content-div';
            contentDiv.innerHTML = content;
            element.appendChild(contentDiv);
            element.appendChild(closer);
            if (map.featuresOverlay) {
                map.removeOverlay(map.featuresOverlay);
                map.featuresOverlay = null;
            }
            map.featuresOverlay = new ol.Overlay({
                element: element,
                positioning: 'bottom-center',
                insertFirst: false,
                stopEvent: true
            });
            map.addOverlay(map.featuresOverlay);
            map.featuresOverlay.setPosition(coords);
            map.featuresOverlay.render();
            return true;
        },
        features2html: function (map, features) {
            var content = document.createElement('div');
            features.forEach(function (f) {
                var props = f.getProperties();
                if (props.hasOwnProperty('name')) {
                    var nameDiv = document.createElement('div');
                    nameDiv.className = 'gp-att-name-div';
                    nameDiv.insertAdjacentHTML('afterbegin', props['name']);
                    content.appendChild(nameDiv);
                }
                if (props.hasOwnProperty('description')) {
                    var descDiv = document.createElement('div');
                    descDiv.className = 'gp-att-description-div';
                    descDiv.insertAdjacentHTML('afterbegin', props['description']);
                    content.appendChild(descDiv);
                }
                var p = null;
                var others = false;
                var oDiv = null;
                var ul = null;
                var li = null;
                for (p in props) {
                    if (p == 'geometry' || p == 'value' || p == 'name' || p == 'description' || p == 'styleUrl') {
                        continue;
                    }
                    if (p == 'extensionsNode_' && props[p] === undefined) {
                        continue;
                    }
                    if (!others) {
                        oDiv = document.createElement('div');
                        oDiv.className = 'gp-att-others-div';
                        ul = document.createElement('ul');
                        others = true;
                    }
                    li = document.createElement('li');
                    var span = document.createElement('span');
                    span.className = 'gp-attname-others-span';
                    span.appendChild(document.createTextNode(p + ' : '));
                    li.appendChild(span);
                    li.appendChild(document.createTextNode(props[p]));
                    ul.appendChild(li);
                }
                if (ul) {
                    oDiv.appendChild(ul);
                    content.appendChild(oDiv);
                }
            }, map);
            if (!content.hasChildNodes()) {
                content = null;
            }
            return content;
        },
        layerGetFeatureAtCoordinates: function (map, olLayer, olCoordinate) {
            var pixel = map.getPixelFromCoordinate(olCoordinate);
            return map.hasFeatureAtPixel(pixel, function (layer) {
                if (layer === olLayer) {
                    return true;
                }
                return false;
            });
        },
        displayVectorFeatureInfo: function (map, olCoordinate, olLayers) {
            var pixel = map.getPixelFromCoordinate(olCoordinate);
            var features = [];
            map.forEachFeatureAtPixel(pixel, function (feature, layer) {
                if (!olLayers || olLayers.indexOf(layer) > -1) {
                    features.push(feature);
                }
            });
            if (features.length == 0) {
                return false;
            }
            var content = this.features2html(map, features);
            if (content === null) {
                return false;
            }
            this.displayInfo(map, olCoordinate, content.innerHTML);
            return true;
        },
        displayFeatureInfo: function (map, olCoordinate, gfiLayers, proxyOptions) {
            var layersOrdered = {};
            for (var j = 0; j < gfiLayers.length; j++) {
                var layer = gfiLayers[j];
                var position = layer.obj.getZIndex();
                if (!layersOrdered[position]) {
                    layersOrdered[position] = [];
                }
                layersOrdered[position].push(layer);
            }
            var requests = [];
            var positions = Object.keys(layersOrdered);
            positions.sort(function (a, b) {
                return b - a;
            });
            var foundFeature = false;
            for (var k = 0; k < positions.length; k++) {
                var p = positions[k];
                for (var h = 0; h < layersOrdered[p].length; ++h) {
                    var l = layersOrdered[p][h].obj;
                    var infoFormat = layersOrdered[p].infoFormat || 'text/html';
                    var minMaxResolutionOk = true;
                    if (l.minResolution && l.minResolution > map.getResolution()) {
                        minMaxResolutionOk = false;
                    }
                    if (minMaxResolutionOk && l.maxResolution && l.maxResolution < map.getResolution()) {
                        minMaxResolutionOk = false;
                    }
                    if (l.getVisible() && minMaxResolutionOk) {
                        var format = this.getLayerFormat(l);
                        if (format == 'vector') {
                            if (!foundFeature && this.layerGetFeatureAtCoordinates(map, l, olCoordinate)) {
                                requests.push({
                                    format: format,
                                    scope: this,
                                    coordinate: olCoordinate
                                });
                            }
                            continue;
                        } else if (format != 'wms' && format != 'wmts') {
                            console.log('[ERROR] DisplayFeatureInfo - layer format \'' + format + '\' not allowed');
                            continue;
                        }
                        var _res = map.getView().getResolution();
                        var _url = null;
                        if (format == 'wmts') {
                            _url = l.getSource().getGetFeatureInfoUrl(olCoordinate, _res, map.getView().getProjection(), { INFOFORMAT: infoFormat });
                        } else {
                            _url = l.getSource().getGetFeatureInfoUrl(olCoordinate, _res, map.getView().getProjection(), { INFO_FORMAT: infoFormat });
                        }
                        requests.push({
                            format: infoFormat,
                            url: ProxyUtils.proxifyUrl(_url, proxyOptions),
                            scope: this,
                            coordinate: olCoordinate
                        });
                    }
                }
            }
            var vectorLayersOrdered = null;
            function requestsSync(list, iterator, callback) {
                if (list.length === 0) {
                    return;
                }
                var nextItemIndex = 0;
                function report(displayed) {
                    nextItemIndex++;
                    if (displayed || nextItemIndex === list.length) {
                        callback();
                    } else {
                        iterator(list[nextItemIndex], report);
                    }
                }
                iterator(list[0], report);
            }
            var context = this;
            requestsSync(requests, function (data, report) {
                if (data.format == 'vector') {
                    if (!vectorLayersOrdered) {
                        vectorLayersOrdered = [];
                        for (var m = 0; m < positions.length; m++) {
                            var p = positions[m];
                            for (var n = 0; n < layersOrdered[p].length; ++n) {
                                vectorLayersOrdered.push(layersOrdered[p][n].obj);
                            }
                        }
                    }
                    report(data.scope.displayVectorFeatureInfo(map, data.coordinate, vectorLayersOrdered));
                } else {
                    Gp.Protocols.XHR.call({
                        url: data.url,
                        method: 'GET',
                        scope: data.scope,
                        onResponse: function (resp) {
                            var exception = false;
                            if (resp.trim().length === 0 || resp.indexOf('java.lang.NullPointerException') !== -1 || resp.indexOf('not queryable') !== -1) {
                                exception = true;
                            }
                            var displayed = !exception && context.displayInfo(map, data.coordinate, resp);
                            report(displayed);
                        },
                        onFailure: function (error) {
                            console.log(error);
                            report(false);
                        }
                    });
                }
            }, function () {
            });
        },
        getPosition: function (e, map) {
            if (e.coordinate) {
                return e.coordinate;
            }
            var pixel = [
                0,
                0
            ];
            if (e.offsetX || e.offsetY) {
                pixel[0] = e.offsetX;
                pixel[1] = e.offsetY;
            } else if (e.pointerType === 'touch') {
                var p = e.pointers[0];
                pixel[0] = p.pageX;
                pixel[1] = p.pageY;
            }
            var coordinate = map.getCoordinateFromPixel(pixel);
            return coordinate;
        },
        onDisplayFeatureInfo: function (e, gfiObj) {
            if (!gfiObj.isActive()) {
                return;
            }
            var map = gfiObj.getMap();
            if (e.type == 'contextmenu' || e.type == 'dblclick') {
                e.preventDefault();
            } else if (e.type == 'singleclick') {
                var interactions = map.getInteractions().getArray();
                for (var i = 0; i < interactions.length; i++) {
                    if (interactions[i].getActive() && (interactions[i] instanceof ol.interaction.Select || interactions[i] instanceof ol.interaction.Modify || interactions[i] instanceof ol.interaction.Draw)) {
                        return;
                    }
                }
            }
            var proxyOptions = {};
            if (gfiObj._proxyUrl) {
                proxyOptions.proxyUrl = gfiObj._proxyUrl;
            }
            if (gfiObj._noProxyDomains) {
                proxyOptions.noProxyDomains = gfiObj._noProxyDomains;
            }
            var eventLayers = [];
            for (var j = 0; j < gfiObj._layers.length; ++j) {
                var event = gfiObj._layers[j].event ? gfiObj._layers[j].event : gfiObj._defaultEvent;
                if (event == e.type) {
                    var ind = eventLayers.push(gfiObj._layers[j]) - 1;
                    if (!eventLayers[ind].infoFormat) {
                        eventLayers[ind].infoFormat = gfiObj._defaultInfoFormat;
                    }
                }
            }
            var coords = this.getPosition(e, map);
            this.displayFeatureInfo(map, coords, eventLayers, proxyOptions);
        }
    };
    return GfiUtils;
}(ol, gp, {}, CommonUtilsProxyUtils);
Ol3Utils = function () {
    var Utils = {
        assign: function (dest, source) {
            dest = dest || {};
            for (var prop in source) {
                if (source.hasOwnProperty(prop)) {
                    dest[prop] = source[prop];
                }
            }
            return dest;
        },
        mergeParams: function (dest, source) {
            if (!dest || !source) {
                return;
            }
            for (var param in source) {
                if (source.hasOwnProperty(param)) {
                    if (typeof source[param] === 'object') {
                        if (dest.hasOwnProperty(param)) {
                            this.mergeParams(dest[param], source[param]);
                        } else {
                            dest[param] = source[param];
                        }
                    } else {
                        dest[param] = source[param];
                    }
                }
            }
        },
        detectSupport: function () {
            var isDesktop = true;
            var userAgent = window.navigator.userAgent.toLowerCase();
            if (userAgent.indexOf('iphone') !== -1 || userAgent.indexOf('ipod') !== -1 || userAgent.indexOf('ipad') !== -1 || userAgent.indexOf('android') !== -1 || userAgent.indexOf('mobile') !== -1 || userAgent.indexOf('blackberry') !== -1 || userAgent.indexOf('tablet') !== -1 || userAgent.indexOf('phone') !== -1 || userAgent.indexOf('touch') !== -1) {
                isDesktop = false;
            }
            if (userAgent.indexOf('msie') !== -1 || userAgent.indexOf('trident') !== -1) {
                isDesktop = true;
            }
            return isDesktop;
        },
        getOL3ObjectId: function (ol3obj) {
            var id = null;
            if (!ol3obj) {
                return;
            }
            for (var key in ol3obj) {
                if (typeof key !== 'string' || key.indexOf('closure_uid') < 0) {
                    continue;
                }
                return ol3obj[key];
            }
            return id;
        }
    };
    return Utils;
}();
Ol3FormatsKML = function (woodman, ol, Utils) {
    function KML(options) {
        if (!(this instanceof KML)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        ol.format.KML.call(this, options);
        this.options = options || {};
    }
    ol.inherits(KML, ol.format.KML);
    KML.prototype = Object.create(ol.format.KML.prototype, {});
    KML.prototype.constructor = KML;
    function _kmlFormattedToString(xml) {
        var reg = /(>)\s*(<)(\/*)/g;
        var wsexp = / *(.*) +\n/g;
        var contexp = /(<.+>)(.+\n)/g;
        xml = xml.replace(reg, '$1\n$2$3').replace(wsexp, '$1\n').replace(contexp, '$1\n$2');
        var formatted = '';
        var lines = xml.split('\n');
        var indent = 0;
        var lastType = 'other';
        var transitions = {
            'single->single': 0,
            'single->closing': -1,
            'single->opening': 0,
            'single->other': 0,
            'closing->single': 0,
            'closing->closing': -1,
            'closing->opening': 0,
            'closing->other': 0,
            'opening->single': 1,
            'opening->closing': 0,
            'opening->opening': 1,
            'opening->other': 1,
            'other->single': 0,
            'other->closing': -1,
            'other->opening': 0,
            'other->other': 0
        };
        for (var i = 0; i < lines.length; i++) {
            var ln = lines[i];
            var single = Boolean(ln.match(/<.+\/>/));
            var closing = Boolean(ln.match(/<\/.+>/));
            var opening = Boolean(ln.match(/<[^!].*>/));
            var type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';
            var fromTo = lastType + '->' + type;
            lastType = type;
            var padding = '';
            indent += transitions[fromTo];
            for (var j = 0; j < indent; j++) {
                padding += '\t';
            }
            if (fromTo == 'opening->closing') {
                formatted = formatted.substr(0, formatted.length - 1) + ln + '\n';
            } else {
                formatted += padding + ln + '\n';
            }
        }
        return formatted;
    }
    function _kmlParse(kmlString) {
        var kmlDoc = null;
        var parser = null;
        var scope = typeof window !== 'undefined' ? window : null;
        if (typeof exports === 'object' && window === null) {
            var DOMParser = xmldom.DOMParser;
            parser = new DOMParser();
            kmlDoc = parser.parseFromString(kmlString, 'text/xml');
        } else if (scope.DOMParser) {
            parser = new scope.DOMParser();
            kmlDoc = parser.parseFromString(kmlString, 'text/xml');
        } else if (scope.ActiveXObject) {
            kmlDoc = new scope.ActiveXObject('Microsoft.XMLDOM');
            kmlDoc.async = false;
            kmlDoc.loadXML(kmlString);
        } else {
            console.log('Incompatible environment for DOM Parser !');
        }
        return kmlDoc;
    }
    function _kmlToString(kmlDoc) {
        var oSerializer = new XMLSerializer();
        var kmlStringExtended = oSerializer.serializeToString(kmlDoc);
        return kmlStringExtended;
    }
    function _kmlRead(kmlDoc, features, process) {
        var root = kmlDoc.documentElement;
        var firstNodeLevel = root.childNodes;
        var nodes = firstNodeLevel;
        if (firstNodeLevel.length === 1 && firstNodeLevel[0].nodeName === 'Document') {
            nodes = firstNodeLevel[0].childNodes;
        }
        var stylesUrl = {};
        var index = -1;
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            switch (node.nodeName) {
            case 'Style':
                var id = node.attributes[0];
                if (id.nodeName === 'id') {
                    var _k = id.nodeValue;
                    var _v = node;
                    stylesUrl[_k] = _v;
                }
                break;
            case 'Placemark':
                index++;
                var types = node.childNodes;
                var point = false;
                var styles = null;
                var extend = null;
                var name = node;
                for (var j = 0; j < types.length; j++) {
                    switch (types[j].nodeName) {
                    case 'Point':
                        point = true;
                        break;
                    case 'Style':
                        styles = types[j].childNodes;
                        break;
                    case 'styleUrl':
                        var _idStyle = types[j].textContent.slice(1);
                        if (stylesUrl[_idStyle]) {
                            styles = stylesUrl[_idStyle].childNodes;
                        }
                        break;
                    case 'ExtendedData':
                        extend = types[j].childNodes;
                        break;
                    case 'name':
                        name = null;
                        break;
                    default:
                    }
                }
                if (extend) {
                    var fctExtend = process.extendedData;
                    if (fctExtend && typeof fctExtend === 'function') {
                        fctExtend(features[index], extend);
                    }
                }
                if (name) {
                    var fctName = process.nameData;
                    if (fctName && typeof fctName === 'function') {
                        fctName(features[index], name);
                    }
                }
                if (point && styles) {
                    if (styles.length) {
                        var labelStyle = null;
                        var iconStyle = null;
                        for (var k = 0; k < styles.length; k++) {
                            switch (styles[k].nodeName) {
                            case 'LabelStyle':
                                labelStyle = styles[k];
                                break;
                            case 'IconStyle':
                                iconStyle = styles[k];
                                break;
                            default:
                            }
                        }
                        var labelName = features[index].getProperties().name;
                        var labelDescription = features[index].getProperties().description;
                        var value = labelName || labelDescription;
                        if (!iconStyle && labelStyle) {
                            var fctLabel = process.labelStyle;
                            if (fctLabel && typeof fctLabel === 'function') {
                                fctLabel(features[index], labelStyle);
                            }
                        } else if (iconStyle && !labelStyle) {
                            var fctIcon = process.iconStyle;
                            if (fctIcon && typeof fctIcon === 'function') {
                                fctIcon(features[index], iconStyle);
                            }
                        } else if (iconStyle && labelStyle) {
                            var fctIconLabel = process.iconLabelStyle;
                            if (fctIconLabel && typeof fctIconLabel === 'function') {
                                fctIconLabel(features[index], iconStyle, labelStyle);
                            }
                        }
                    }
                }
                break;
            default:
            }
        }
    }
    KML.prototype.writeFeatures = function (features, options) {
        var kmlString = this._writeExtendStylesFeatures(features, options);
        return kmlString;
    };
    KML.prototype._writeExtendStylesFeatures = function (features, options) {
        var kmlString = ol.format.KML.prototype.writeFeatures.call(this, features, options);
        var kmlDoc = _kmlParse(kmlString);
        if (kmlDoc === null) {
            return kmlString;
        }
        var __createExtensionStyleLabel = function (feature, style) {
            if (!feature) {
                return;
            }
            var labelName = feature.getProperties().name;
            if (!labelName) {
                return;
            }
            function __convertRGBColorsToKML(data) {
                var strColor = data.toString(16);
                if (strColor.charAt(0) === '#') {
                    strColor = strColor.slice(1);
                }
                var opacity = 1;
                opacity = parseInt(opacity * 255, 10);
                opacity = opacity.toString(16);
                var color = opacity;
                color = color + strColor.substr(4, 2);
                color = color + strColor.substr(2, 2);
                color = color + strColor.substr(0, 2);
                return color.toLowerCase();
            }
            if (feature.getStyle() instanceof ol.style.Style) {
                var fTextStyle = feature.getStyle().getText().getStroke();
                if (!fTextStyle) {
                    return;
                }
                var _haloColor = __convertRGBColorsToKML(fTextStyle.getColor()) || __convertRGBColorsToKML('#FFFFFF');
                var _haloRadius = fTextStyle.getWidth() || '0';
                var _haloOpacity = '1';
                var _font = 'Sans';
                if (style && style.getElementsByTagName('LabelStyleSimpleExtensionGroup').length === 0) {
                    var labelextend = kmlDoc.createElement('LabelStyleSimpleExtensionGroup');
                    labelextend.setAttribute('fontFamily', _font);
                    labelextend.setAttribute('haloColor', _haloColor);
                    labelextend.setAttribute('haloRadius', _haloRadius);
                    labelextend.setAttribute('haloOpacity', _haloOpacity);
                    style.appendChild(labelextend);
                }
            }
        };
        var __createHotSpotStyleIcon = function (feature, style) {
            if (!feature) {
                return;
            }
            var proxy = feature.getProperties().proxyUrl;
            if (proxy) {
            }
            if (feature.getStyle() instanceof ol.style.Style) {
                var fImageStyle = feature.getStyle().getImage();
                if (!fImageStyle) {
                    return;
                }
                var x = 0;
                var y = 0;
                var xunits = 'pixels';
                var yunits = 'pixels';
                var size = fImageStyle.getSize();
                var anchor = fImageStyle.getAnchor();
                if (anchor.length) {
                    x = anchor[0];
                    y = anchor[1];
                    if (yunits === 'fraction') {
                        y = anchor[1] === 1 ? 0 : 1 - anchor[1];
                    } else {
                        y = yunits === 'pixels' && anchor[1] === size[1] ? 0 : size[1] - anchor[1];
                    }
                }
                if (style && style.getElementsByTagName('hotSpot').length === 0) {
                    var hotspot = kmlDoc.createElement('hotSpot');
                    hotspot.setAttribute('x', x);
                    hotspot.setAttribute('y', y);
                    hotspot.setAttribute('xunits', xunits);
                    hotspot.setAttribute('yunits', yunits);
                    style.appendChild(hotspot);
                }
            }
        };
        var __createStyleToFeatureIconLabel = function (feature, iconStyle, labelStyle) {
            __createHotSpotStyleIcon(feature, iconStyle);
            __createExtensionStyleLabel(feature, labelStyle);
        };
        var __setNameData = function (feature, tags) {
            for (var i = 0; i < tags.length; i++) {
                var tag = tags[i];
                if (tag.nodeName === 'name') {
                    return;
                }
            }
            var labelName = feature.getProperties().name;
            if (labelName) {
                var name = kmlDoc.createElement('name');
                name.innerHTML = labelName;
                tags.appendChild(name);
            }
        };
        _kmlRead(kmlDoc, features, {
            labelStyle: __createExtensionStyleLabel,
            iconStyle: __createHotSpotStyleIcon,
            iconLabelStyle: __createStyleToFeatureIconLabel,
            nameData: __setNameData
        });
        var kmlStringExtended = _kmlToString(kmlDoc);
        if (kmlStringExtended === null) {
            kmlStringExtended = kmlString;
        }
        var kmlStringFormatted = _kmlFormattedToString(kmlStringExtended);
        if (kmlStringFormatted === null) {
            kmlStringFormatted = kmlString;
        }
        return kmlStringFormatted;
    };
    KML.prototype.readFeatures = function (source, options) {
        var features = this._readExtendStylesFeatures(source, options);
        return features;
    };
    KML.prototype._readExtendStylesFeatures = function (source, options) {
        var features = ol.format.KML.prototype.readFeatures.call(this, source, options);
        var kmlDoc = null;
        var kmlString = '';
        if (typeof source === 'string') {
            kmlString = source;
        } else {
            kmlString = source.documentElement.outerHTML;
        }
        kmlString = kmlString.replace(/\n/g, '');
        kmlString = kmlString.replace(/(>)\s*(<)/g, '$1$2');
        kmlDoc = _kmlParse(kmlString);
        if (kmlDoc === null) {
            return features;
        }
        var proxy = this.options.proxyUrl || null;
        var __getExtensionStyleToFeatureLabel = function (feature, style) {
            if (!feature) {
                return;
            }
            function __convertKMLColorsToRGB(data) {
                var color = '';
                color = color + data.substr(6, 2);
                color = color + data.substr(4, 2);
                color = color + data.substr(2, 2);
                var hex = parseInt(color, 16).toString(16);
                var comp = '';
                var len = hex.length || 0;
                for (var i = 0; i < 6 - len; i++) {
                    comp += '0';
                }
                hex = '#' + comp + hex;
                return hex.toString(16);
            }
            var _text = feature.getProperties().name || '---';
            var _color = __convertKMLColorsToRGB('ff000000');
            var _colorHalo = '#FFFFFF';
            var _radiusHalo = 0;
            var _font = 'Sans';
            var _fontSize = '16px';
            var bLabelStyleSimpleExtensionGroup = false;
            var styles = style.childNodes;
            for (var k = 0; k < styles.length; k++) {
                switch (styles[k].nodeName) {
                case 'scale':
                    break;
                case 'colorMode':
                    break;
                case 'color':
                    _color = __convertKMLColorsToRGB(styles[k].textContent);
                    break;
                case 'LabelStyleSimpleExtensionGroup':
                    bLabelStyleSimpleExtensionGroup = true;
                    var attributs = styles[k].attributes;
                    for (var l = 0; l < attributs.length; l++) {
                        switch (attributs[l].nodeName) {
                        case 'fontFamily':
                            break;
                        case 'haloColor':
                            _colorHalo = __convertKMLColorsToRGB(attributs[l].nodeValue);
                            break;
                        case 'haloRadius':
                            _radiusHalo = parseInt(attributs[l].nodeValue, 10);
                            break;
                        case 'haloOpacity':
                            break;
                        default:
                        }
                    }
                    break;
                default:
                }
            }
            if (!bLabelStyleSimpleExtensionGroup) {
                return;
            }
            feature.setStyle(new ol.style.Style({
                image: new ol.style.Icon({
                    src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=',
                    size: [
                        51,
                        38
                    ],
                    anchor: [
                        25.5,
                        38
                    ],
                    anchorOrigin: 'top-left',
                    anchorXUnits: 'pixels',
                    anchorYUnits: 'pixels'
                }),
                text: new ol.style.Text({
                    font: _fontSize + ' ' + _font,
                    textAlign: 'left',
                    text: _text,
                    fill: new ol.style.Fill({ color: _color }),
                    stroke: new ol.style.Stroke({
                        color: _colorHalo,
                        width: _radiusHalo
                    })
                })
            }));
        };
        var __getHotSpotStyleToFeatureIcon = function (feature, style) {
            var _src = null;
            var _scale = null;
            var _bSizeIcon = false;
            var _sizeW = 51;
            var _sizeH = 38;
            var _bHotSpot = false;
            var _anchorX = 25.5;
            var _anchorXUnits = 'pixels';
            var _anchorY = 38;
            var _anchorYUnits = 'pixels';
            var styles = style.childNodes;
            for (var k = 0; k < styles.length; k++) {
                switch (styles[k].nodeName) {
                case 'Icon':
                    var nodes = styles[k].childNodes;
                    for (var i = 0; i < nodes.length; i++) {
                        switch (nodes[i].nodeName) {
                        case 'href':
                            _src = nodes[i].textContent;
                            break;
                        case 'gx:w':
                            _bSizeIcon = true;
                            _sizeW = parseFloat(nodes[i].textContent);
                            break;
                        case 'gx:h':
                            _bSizeIcon = true;
                            _sizeH = parseFloat(nodes[i].textContent);
                            break;
                        default:
                        }
                    }
                    break;
                case 'hotSpot':
                    _bHotSpot = true;
                    var attributs = styles[k].attributes;
                    for (var l = 0; l < attributs.length; l++) {
                        switch (attributs[l].nodeName) {
                        case 'x':
                            _anchorX = parseFloat(attributs[l].nodeValue);
                            break;
                        case 'y':
                            _anchorY = parseFloat(attributs[l].nodeValue);
                            break;
                        case 'yunits':
                            _anchorXUnits = attributs[l].nodeValue;
                            break;
                        case 'xunits':
                            _anchorYUnits = attributs[l].nodeValue;
                            break;
                        default:
                        }
                    }
                    break;
                case 'scale':
                    _scale = parseFloat(styles[k].textContent);
                    break;
                default:
                }
            }
            if (proxy && /^https?:\/\//.test(_src)) {
                if (_src.indexOf(proxy) === -1) {
                    _src = proxy + _src;
                    feature.setProperties({ proxyUrl: proxy });
                }
            }
            var _options = {
                src: _src,
                crossOrigin: 'anonymous',
                scale: _scale || 1
            };
            if (_bSizeIcon) {
                Utils.mergeParams(_options, {
                    size: [
                        _sizeW,
                        _sizeH
                    ]
                });
            }
            if (_bHotSpot) {
                Utils.mergeParams(_options, {
                    anchor: [
                        _anchorX,
                        _anchorY
                    ],
                    anchorOrigin: 'bottom-left',
                    anchorXUnits: _anchorXUnits || 'pixels',
                    anchorYUnits: _anchorYUnits || 'pixels'
                });
            }
            var featureStyleFunction = feature.getStyleFunction();
            if (featureStyleFunction) {
                var _styles = featureStyleFunction.call(feature, 0);
                if (_styles && _styles.length !== 0) {
                    var _style = _styles.length === 1 ? _styles[0] : _styles[_styles.length - 1];
                    feature.setStyle(new ol.style.Style({
                        image: new ol.style.Icon(_options),
                        text: _style.getText()
                    }));
                }
            }
        };
        var __getExtendedData = function (feature, extend) {
            if (!feature) {
                return;
            }
            var _fname = feature.getProperties().name || '';
            var _fdescription = feature.getProperties().description || '';
            var _ftitle = null;
            for (var i = 0; i < extend.length; i++) {
                var data = extend[i];
                var name = data.attributes[0];
                var nodes = data.childNodes;
                if (name.nodeName === 'name') {
                    switch (name.nodeValue) {
                    case 'label':
                        _fname = data.textContent;
                        break;
                    case 'title':
                    case 'attributetitle':
                        for (var j = 0; j < nodes.length; j++) {
                            if (nodes[j].nodeName === 'value') {
                                _ftitle = nodes[j].textContent;
                            }
                        }
                        break;
                    default:
                    }
                }
            }
            if (_ftitle) {
                _fdescription = _fdescription ? _ftitle + ' : ' + _fdescription : _ftitle;
            }
            feature.setProperties({
                name: _fname,
                description: _fdescription
            });
        };
        var __getStyleToFeatureIconLabel = function (feature, iconStyle, labelStyle) {
            __getExtensionStyleToFeatureLabel(feature, labelStyle);
            __getHotSpotStyleToFeatureIcon(feature, iconStyle);
        };
        _kmlRead(kmlDoc, features, {
            labelStyle: this.options.showPointNames ? __getExtensionStyleToFeatureLabel : null,
            iconStyle: __getHotSpotStyleToFeatureIcon,
            iconLabelStyle: this.options.showPointNames ? __getStyleToFeatureIconLabel : __getHotSpotStyleToFeatureIcon,
            extendedData: __getExtendedData
        });
        return features;
    };
    return KML;
}({}, ol, Ol3Utils);
Ol3SourcesWMTS = function (Gp, ol, Utils) {
    function WMTS(options) {
        if (!(this instanceof WMTS)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        ol.source.WMTS.call(this, options);
    }
    ol.inherits(WMTS, ol.source.WMTS);
    WMTS.prototype = Object.create(ol.source.WMTS.prototype, {});
    WMTS.prototype.constructor = WMTS;
    WMTS.prototype.getGetFeatureInfoUrl = function (coordinate, resolution, projection, params) {
        var pixelRatio = this.option && this.options.tilePixelRatio ? this.options.tilePixelRatio : 1;
        var tileGrid = this.tileGrid;
        var tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
        var getTransformedTileCoord = function (tileCoord, tileGrid, projection) {
            var tmpTileCoord = [
                0,
                0,
                0
            ];
            var tmpExtent = ol.extent.createEmpty();
            var x = tileCoord[1];
            var y = -tileCoord[2] - 1;
            var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
            var projectionExtent = projection.getExtent();
            var extent = projectionExtent;
            if (extent != null && projection.isGlobal() && extent[0] === projectionExtent[0] && extent[2] === projectionExtent[2]) {
                var numCols = Math.ceil(ol.extent.getWidth(extent) / ol.extent.getWidth(tileExtent));
                x = x % numCols;
                tmpTileCoord[0] = tileCoord[0];
                tmpTileCoord[1] = x;
                tmpTileCoord[2] = tileCoord[2];
                tileExtent = tileGrid.getTileCoordExtent(tmpTileCoord, tmpExtent);
            }
            if (!ol.extent.intersects(tileExtent, extent)) {
                return null;
            }
            return [
                tileCoord[0],
                x,
                y
            ];
        };
        var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
        var transformedTileCoord = getTransformedTileCoord(tileCoord, tileGrid, projection);
        if (tileGrid.getResolutions().length <= tileCoord[0]) {
            return undefined;
        }
        var tileResolution = tileGrid.getResolution(tileCoord[0]);
        var tileMatrix = tileGrid.getMatrixIds()[tileCoord[0]];
        var baseParams = {
            SERVICE: 'WMTS',
            VERSION: '1.0.0',
            REQUEST: 'GetFeatureInfo',
            LAYER: this.getLayer(),
            TILECOL: transformedTileCoord[1],
            TILEROW: transformedTileCoord[2],
            TILEMATRIX: tileMatrix,
            TILEMATRIXSET: this.getMatrixSet(),
            FORMAT: this.getFormat() || 'image/png',
            STYLE: this.getStyle() || 'normal'
        };
        Utils.assign(baseParams, params);
        var x = Math.floor((coordinate[0] - tileExtent[0]) / (tileResolution / pixelRatio));
        var y = Math.floor((tileExtent[3] - coordinate[1]) / (tileResolution / pixelRatio));
        baseParams['I'] = x;
        baseParams['J'] = y;
        var url = this.urls[0];
        var featureInfoUrl = Gp.Helper.normalyzeUrl(url, baseParams);
        return featureInfoUrl;
    };
    return WMTS;
}(gp, ol, Ol3Utils);
Ol3CRSCRS = function (proj4, ol, Register) {
    (function () {
        Register.load();
        if (!ol.proj.proj4_ && ol.proj.setProj4) {
            ol.proj.setProj4(proj4);
        } else {
            console.log('WARNING : OpenLayers library should manage proj4 dependency in order to add custom projections (Lambert 93 for instance)');
        }
    }());
    var CRS = {
        overloadTransformExtent: function () {
            ol.proj.transformExtent = function (extent, source, destination) {
                if (destination === 'EPSG:2154') {
                    if (source === 'EPSG:4326') {
                        if (extent[0] < -9.62) {
                            extent[0] = -9.62;
                        }
                        if (extent[1] < 41.18) {
                            extent[1] = 41.18;
                        }
                        if (extent[2] > 10.3) {
                            extent[2] = 10.3;
                        }
                        if (extent[3] > 51.54) {
                            extent[3] = 51.54;
                        }
                    }
                }
                var transformFn = ol.proj.getTransform(source, destination);
                var transformedExtent = ol.extent.applyTransform(extent, transformFn);
                return transformedExtent;
            };
        },
        overload: function () {
            this.overloadTransformExtent();
        }
    };
    return CRS;
}(proj4, ol, CommonUtilsRegister);
CommonUtilsConfig = function () {
    var Config = {
        configuration: null,
        isConfigLoaded: function () {
            var scope = typeof window !== 'undefined' ? window : {};
            if (scope.Gp && scope.Gp.Config && Object.keys(scope.Gp.Config).length !== 0) {
                this.configuration = scope.Gp.Config;
                return true;
            }
            return false;
        },
        getLayerId: function (layerName, service) {
            var layerId = null;
            if (this.configuration) {
                var layers = this.configuration['layers'];
                for (var key in layers) {
                    if (layers.hasOwnProperty(key)) {
                        var parts = key.split('$');
                        if (layerName === parts[0]) {
                            if (parts[1]) {
                                var servicePartsLayer = parts[1].split(':');
                                var servicePartsService = parts[1].split(';');
                                if (servicePartsService[1] === service) {
                                    layerId = key;
                                    break;
                                }
                                if (servicePartsLayer[2] === service) {
                                    layerId = key;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            if (!layerId) {
                console.log('ERROR layer id (' + layerName + ' / ' + service + ') was not found !?');
            }
            return layerId;
        },
        getLayerParams: function (layerName, service, apiKey) {
            var params = {};
            if (this.configuration) {
                var layerId = this.getLayerId(layerName, service);
                if (layerId) {
                    var layerConf = this.configuration.layers[layerId];
                    var key = layerConf.apiKeys[0];
                    if (apiKey) {
                        if (apiKey !== key) {
                            console.log('ERROR different keys (' + apiKey + ' !== ' + key + ') !?');
                            return;
                        }
                    }
                    apiKey = apiKey || key;
                    params.key = apiKey;
                    params.url = layerConf.getServerUrl(apiKey);
                    params.version = layerConf.getServiceParams().version;
                    params.styles = layerConf.getDefaultStyle();
                    params.format = layerConf.getDefaultFormat();
                    params.projection = layerConf.getDefaultProjection();
                    params.minScale = layerConf.getMinScaleDenominator();
                    params.maxScale = layerConf.getMaxScaleDenominator();
                    params.extent = layerConf.getBBOX();
                    params.legends = layerConf.getLegends();
                    params.metadata = layerConf.getMetadata();
                    params.originators = layerConf.getOriginators();
                    params.title = layerConf.getTitle();
                    params.description = layerConf.getDescription();
                    params.quicklookUrl = layerConf.getQuicklookUrl();
                    if (layerConf.wmtsOptions) {
                        params.tileMatrixSetLimits = layerConf.wmtsOptions.tileMatrixSetLimits;
                    }
                    var TMSLink = layerConf.getTMSID();
                    if (TMSLink) {
                        params.TMSLink = TMSLink;
                        var tmsConf = this.configuration.getTMSConf(TMSLink);
                        params.matrixOrigin = tmsConf.getTopLeftCorner();
                        params.nativeResolutions = tmsConf.nativeResolutions;
                        params.matrixIds = tmsConf.matrixIds;
                        params.tileMatrices = tmsConf.tileMatrices;
                    }
                }
            }
            return params;
        },
        getServiceParams: function (resource, service, apiKey) {
            var params = {};
            if (this.configuration) {
                var layerId = this.getLayerId(resource, service);
                if (layerId) {
                    var layerConf = this.configuration.layers[layerId];
                    var key = layerConf.apiKeys[0];
                    if (apiKey) {
                        if (apiKey !== key) {
                            return;
                        }
                    }
                    apiKey = apiKey || key;
                    params.key = apiKey;
                    params.url = layerConf.getServerUrl(apiKey);
                    params.version = layerConf.getServiceParams().version;
                    params.extent = layerConf.getBBOX();
                    params.title = layerConf.getTitle();
                    params.description = layerConf.getDescription();
                }
            }
            return params;
        },
        getResolutions: function () {
            var resolutions = [];
            if (this.configuration) {
                resolutions = this.configuration['generalOptions']['wgs84Resolutions'];
            }
            return resolutions;
        },
        getTileMatrix: function (tmsName) {
            var tms = {};
            if (this.configuration) {
                if (tmsName) {
                    tms = this.configuration['tileMatrixSets'][tmsName.toUpperCase()];
                }
            }
            return tms;
        },
        getGlobalConstraints: function (layerId) {
            var params = {};
            if (layerId) {
                var layerConf = this.configuration.layers[layerId];
                params.projection = layerConf.getDefaultProjection();
                params.minScale = layerConf.getMinScaleDenominator();
                params.maxScale = layerConf.getMaxScaleDenominator();
                params.extent = layerConf.getBBOX();
            }
            return params;
        }
    };
    return Config;
}();
Ol3LayersSourceWMTS = function (ol, WMTSExtended, Gp, GfiUtils, Utils, Config, LayerUtils) {
    function SourceWMTS(options) {
        if (!(this instanceof SourceWMTS)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        if (!options.layer) {
            throw new Error('ERROR PARAM_MISSING : layer');
        }
        if (typeof options.layer !== 'string') {
            throw new Error('ERROR WRONG TYPE : layer');
        }
        if (!Config.isConfigLoaded()) {
            throw new Error('ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html');
        }
        var layerId = Config.getLayerId(options.layer, 'WMTS');
        if (layerId && Config.configuration.getLayerConf(layerId)) {
            var wmtsParams = Config.getLayerParams(options.layer, 'WMTS', options.apiKey);
            this._originators = wmtsParams.originators;
            this._legends = wmtsParams.legends;
            this._metadata = wmtsParams.metadata;
            var wmtsSourceOptions = {
                url: Gp.Helper.normalyzeUrl(wmtsParams.url, { 'gp-ol3-ext': '0.12.0' }, false),
                version: wmtsParams.version,
                style: wmtsParams.styles,
                format: wmtsParams.format,
                projection: wmtsParams.projection,
                maxZoom: LayerUtils.getZoomLevelFromScaleDenominator(wmtsParams.minScale),
                layer: options.layer,
                matrixSet: wmtsParams.TMSLink,
                tileGrid: new ol.tilegrid.WMTS({
                    resolutions: wmtsParams.nativeResolutions,
                    matrixIds: wmtsParams.matrixIds,
                    origin: [
                        wmtsParams.matrixOrigin.x,
                        wmtsParams.matrixOrigin.y
                    ]
                })
            };
            Utils.mergeParams(wmtsSourceOptions, options.olParams);
            WMTSExtended.call(this, wmtsSourceOptions);
            this._originators = wmtsParams.originators;
            this._legends = wmtsParams.legends;
            this._metadata = wmtsParams.metadata;
            this._description = wmtsParams.description;
            this._title = wmtsParams.title;
            this._quicklookUrl = wmtsParams.quicklookUrl;
        } else {
            console.log('[source WMTS] ERROR : ' + options.layer + ' cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.');
            return new WMTSExtended({});
        }
    }
    ol.inherits(SourceWMTS, WMTSExtended);
    SourceWMTS.prototype = Object.create(WMTSExtended.prototype, {});
    SourceWMTS.prototype.constructor = SourceWMTS;
    return SourceWMTS;
}(ol, Ol3SourcesWMTS, gp, Ol3GfiUtils, Ol3Utils, CommonUtilsConfig, CommonUtilsLayerUtils);
Ol3LayersSourceWMS = function (ol, Gp, Utils, Config) {
    function SourceWMS(options) {
        if (!(this instanceof SourceWMS)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        if (!options.layer) {
            throw new Error('ERROR PARAM_MISSING : layer');
        }
        if (typeof options.layer !== 'string') {
            throw new Error('ERROR WRONG TYPE : layer');
        }
        if (!Config.isConfigLoaded()) {
            throw new Error('ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html');
        }
        var layerId = Config.getLayerId(options.layer, 'WMS');
        if (layerId && Config.configuration.getLayerConf(layerId)) {
            var wmsParams = Config.getLayerParams(options.layer, 'WMS', options.apiKey);
            var wmsSourceOptions = {
                url: Gp.Helper.normalyzeUrl(wmsParams.url, { 'gp-ol3-ext': '0.12.0' }, false),
                params: {
                    SERVICE: 'WMS',
                    LAYERS: options.layer,
                    VERSION: wmsParams.version,
                    STYLES: wmsParams.styles,
                    FORMAT: wmsParams.format
                }
            };
            Utils.mergeParams(wmsSourceOptions, options.olParams);
            ol.source.TileWMS.call(this, wmsSourceOptions);
            this._originators = wmsParams.originators;
            this._legends = wmsParams.legends;
            this._metadata = wmsParams.metadata;
            this._title = wmsParams.title;
            this._description = wmsParams.description;
            this._quicklookUrl = wmsParams.quicklookUrl;
        } else {
            console.log('[source WMS] ERROR : ' + options.layer + ' cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.');
            return new ol.source.TileWMS({});
        }
    }
    ol.inherits(SourceWMS, ol.source.TileWMS);
    SourceWMS.prototype = Object.create(ol.source.TileWMS.prototype, {});
    SourceWMS.prototype.constructor = SourceWMS;
    return SourceWMS;
}(ol, gp, Ol3Utils, CommonUtilsConfig);
Ol3LayersLayerWMTS = function (ol, Utils, Config, LayerUtils, SourceWMTS) {
    function LayerWMTS(options) {
        if (!(this instanceof LayerWMTS)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        if (!options.layer) {
            throw new Error('ERROR PARAM_MISSING : layer');
        }
        if (typeof options.layer !== 'string') {
            throw new Error('ERROR WRONG TYPE : layer');
        }
        if (!Config.isConfigLoaded()) {
            throw new Error('ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html');
        }
        var olSourceParams;
        if (options.olParams && options.olParams.sourceParams) {
            olSourceParams = options.olParams.sourceParams;
        }
        var wmtsSource = new SourceWMTS({
            layer: options.layer,
            apiKey: options.apiKey,
            olParams: olSourceParams
        });
        var layerTileOptions = { source: wmtsSource };
        if (wmtsSource.getLayer() !== undefined) {
            var layerId = Config.getLayerId(options.layer, 'WMTS');
            var globalConstraints = Config.getGlobalConstraints(layerId);
            if (globalConstraints && globalConstraints.projection) {
                var p;
                if (typeof globalConstraints.projection === 'string') {
                    p = ol.proj.get(globalConstraints.projection);
                }
                if (p && p.getUnits()) {
                    if (p.getUnits() === 'm') {
                        layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028;
                        layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028;
                    } else if (p.getUnits() === 'degrees') {
                        layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028 * 180 / (Math.PI * 6378137);
                        layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028 * 180 / (Math.PI * 6378137);
                    }
                }
            }
        }
        Utils.mergeParams(layerTileOptions, options.olParams);
        ol.layer.Tile.call(this, layerTileOptions);
    }
    ol.inherits(LayerWMTS, ol.layer.Tile);
    LayerWMTS.prototype = Object.create(ol.layer.Tile.prototype, {});
    LayerWMTS.prototype.constructor = LayerWMTS;
    return LayerWMTS;
}(ol, Ol3Utils, CommonUtilsConfig, CommonUtilsLayerUtils, Ol3LayersSourceWMTS);
Ol3LayersLayerWMS = function (ol, Utils, Config, LayerUtils, SourceWMS) {
    function LayerWMS(options) {
        if (!(this instanceof LayerWMS)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        if (!options.layer) {
            throw new Error('ERROR PARAM_MISSING : layer');
        }
        if (typeof options.layer !== 'string') {
            throw new Error('ERROR WRONG TYPE : layer');
        }
        if (!Config.isConfigLoaded()) {
            throw new Error('ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html');
        }
        var olSourceParams;
        if (options.olParams && options.olParams.sourceParams) {
            olSourceParams = options.olParams.sourceParams;
        }
        var wmsSource = new SourceWMS({
            layer: options.layer,
            apiKey: options.apiKey,
            olParams: olSourceParams
        });
        var layerTileOptions = { source: wmsSource };
        if (wmsSource.getParams().LAYERS !== undefined) {
            var layerId = Config.getLayerId(options.layer, 'WMS');
            var globalConstraints = Config.getGlobalConstraints(layerId);
            if (olSourceParams && olSourceParams.projection) {
                var geobbox = [
                    globalConstraints.extent.left,
                    globalConstraints.extent.bottom,
                    globalConstraints.extent.right,
                    globalConstraints.extent.top
                ];
                layerTileOptions.extent = ol.proj.transformExtent(geobbox, 'EPSG:4326', olSourceParams.projection);
                var p;
                if (typeof olSourceParams.projection === 'string') {
                    p = ol.proj.get(olSourceParams.projection);
                } else if (typeof olSourceParams.projection === 'object' && olSourceParams.projection.getCode()) {
                    p = ol.proj.get(olSourceParams.projection.getCode());
                }
                if (p && p.getUnits()) {
                    if (p.getUnits() === 'm') {
                        layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028;
                        layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028;
                    } else if (p.getUnits() === 'degrees') {
                        layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028 * 180 / (Math.PI * 6378137);
                        layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028 * 180 / (Math.PI * 6378137);
                    }
                }
            }
        }
        Utils.mergeParams(layerTileOptions, options.olParams);
        ol.layer.Tile.call(this, layerTileOptions);
    }
    ol.inherits(LayerWMS, ol.layer.Tile);
    LayerWMS.prototype = Object.create(ol.layer.Tile.prototype, {});
    LayerWMS.prototype.constructor = LayerWMS;
    return LayerWMS;
}(ol, Ol3Utils, CommonUtilsConfig, CommonUtilsLayerUtils, Ol3LayersSourceWMS);
CommonUtilsSelectorID = function () {
    var SelectorID = {
        generate: function () {
            var timestamp = Math.floor(Date.now());
            return function () {
                return timestamp++;
            };
        }(),
        name: function (id) {
            var name = null;
            var i = id.lastIndexOf('-');
            if (i === -1) {
                name = id;
            } else {
                name = id.substring(0, i);
            }
            return name;
        },
        index: function (id) {
            var index = null;
            var name = this.name(id);
            var i = name.lastIndexOf('_');
            if (i !== -1) {
                index = name.substring(i + 1);
            }
            return index;
        },
        uuid: function (id) {
            var uuid = null;
            var i = id.lastIndexOf('-');
            if (i !== -1) {
                uuid = parseInt(id.substring(i + 1), 10);
            }
            return uuid;
        }
    };
    return SelectorID;
}();
(function (factory) {
    'use strict';
    if (true) {
        sortable = function () {
            return typeof factory === 'function' ? factory() : factory;
        }();
    } else if (typeof module != 'undefined' && typeof module.exports != 'undefined') {
        module.exports = factory();
    } else if (typeof Package !== 'undefined') {
        Sortable = factory();
    } else {
        window['Sortable'] = factory();
    }
}(function () {
    'use strict';
    if (typeof window == 'undefined' || typeof window.document == 'undefined') {
        return function () {
            throw new Error('Sortable.js requires a window with a document');
        };
    }
    var dragEl, parentEl, ghostEl, cloneEl, rootEl, nextEl, scrollEl, scrollParentEl, lastEl, lastCSS, lastParentCSS, oldIndex, newIndex, activeGroup, autoScroll = {}, tapEvt, touchEvt, moved, RSPACE = /\s+/g, expando = 'Sortable' + new Date().getTime(), win = window, document = win.document, parseInt = win.parseInt, supportDraggable = !!('draggable' in document.createElement('div')), supportCssPointerEvents = function (el) {
            el = document.createElement('x');
            el.style.cssText = 'pointer-events:auto';
            return el.style.pointerEvents === 'auto';
        }(), _silent = false, abs = Math.abs, slice = [].slice, touchDragOverListeners = [], _autoScroll = _throttle(function (evt, options, rootEl) {
            if (rootEl && options.scroll) {
                var el, rect, sens = options.scrollSensitivity, speed = options.scrollSpeed, x = evt.clientX, y = evt.clientY, winWidth = window.innerWidth, winHeight = window.innerHeight, vx, vy;
                if (scrollParentEl !== rootEl) {
                    scrollEl = options.scroll;
                    scrollParentEl = rootEl;
                    if (scrollEl === true) {
                        scrollEl = rootEl;
                        do {
                            if (scrollEl.offsetWidth < scrollEl.scrollWidth || scrollEl.offsetHeight < scrollEl.scrollHeight) {
                                break;
                            }
                        } while (scrollEl = scrollEl.parentNode);
                    }
                }
                if (scrollEl) {
                    el = scrollEl;
                    rect = scrollEl.getBoundingClientRect();
                    vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
                    vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
                }
                if (!(vx || vy)) {
                    vx = (winWidth - x <= sens) - (x <= sens);
                    vy = (winHeight - y <= sens) - (y <= sens);
                    (vx || vy) && (el = win);
                }
                if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
                    autoScroll.el = el;
                    autoScroll.vx = vx;
                    autoScroll.vy = vy;
                    clearInterval(autoScroll.pid);
                    if (el) {
                        autoScroll.pid = setInterval(function () {
                            if (el === win) {
                                win.scrollTo(win.pageXOffset + vx * speed, win.pageYOffset + vy * speed);
                            } else {
                                vy && (el.scrollTop += vy * speed);
                                vx && (el.scrollLeft += vx * speed);
                            }
                        }, 24);
                    }
                }
            }
        }, 30), _prepareGroup = function (options) {
            var group = options.group;
            if (!group || typeof group != 'object') {
                group = options.group = { name: group };
            }
            [
                'pull',
                'put'
            ].forEach(function (key) {
                if (!(key in group)) {
                    group[key] = true;
                }
            });
            options.groups = ' ' + group.name + (group.put.join ? ' ' + group.put.join(' ') : '') + ' ';
        };
    function Sortable(el, options) {
        if (!(el && el.nodeType && el.nodeType === 1)) {
            throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
        }
        this.el = el;
        this.options = options = _extend({}, options);
        el[expando] = this;
        var defaults = {
            group: Math.random(),
            sort: true,
            disabled: false,
            store: null,
            handle: null,
            scroll: true,
            scrollSensitivity: 30,
            scrollSpeed: 10,
            draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
            ghostClass: 'sortable-ghost',
            chosenClass: 'sortable-chosen',
            ignore: 'a, img',
            filter: null,
            animation: 0,
            setData: function (dataTransfer, dragEl) {
                dataTransfer.setData('Text', dragEl.textContent);
            },
            dropBubble: false,
            dragoverBubble: false,
            dataIdAttr: 'data-id',
            delay: 0,
            forceFallback: false,
            fallbackClass: 'sortable-fallback',
            fallbackOnBody: false
        };
        for (var name in defaults) {
            !(name in options) && (options[name] = defaults[name]);
        }
        _prepareGroup(options);
        for (var fn in this) {
            if (fn.charAt(0) === '_') {
                this[fn] = this[fn].bind(this);
            }
        }
        this.nativeDraggable = options.forceFallback ? false : supportDraggable;
        _on(el, 'mousedown', this._onTapStart);
        _on(el, 'touchstart', this._onTapStart);
        if (this.nativeDraggable) {
            _on(el, 'dragover', this);
            _on(el, 'dragenter', this);
        }
        touchDragOverListeners.push(this._onDragOver);
        options.store && this.sort(options.store.get(this));
    }
    Sortable.prototype = {
        constructor: Sortable,
        _onTapStart: function (evt) {
            var _this = this, el = this.el, options = this.options, type = evt.type, touch = evt.touches && evt.touches[0], target = (touch || evt).target, originalTarget = target, filter = options.filter;
            if (type === 'mousedown' && evt.button !== 0 || options.disabled) {
                return;
            }
            target = _closest(target, options.draggable, el);
            if (!target) {
                return;
            }
            oldIndex = _index(target, options.draggable);
            if (typeof filter === 'function') {
                if (filter.call(this, evt, target, this)) {
                    _dispatchEvent(_this, originalTarget, 'filter', target, el, oldIndex);
                    evt.preventDefault();
                    return;
                }
            } else if (filter) {
                filter = filter.split(',').some(function (criteria) {
                    criteria = _closest(originalTarget, criteria.trim(), el);
                    if (criteria) {
                        _dispatchEvent(_this, criteria, 'filter', target, el, oldIndex);
                        return true;
                    }
                });
                if (filter) {
                    evt.preventDefault();
                    return;
                }
            }
            if (options.handle && !_closest(originalTarget, options.handle, el)) {
                return;
            }
            this._prepareDragStart(evt, touch, target);
        },
        _prepareDragStart: function (evt, touch, target) {
            var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
            if (target && !dragEl && target.parentNode === el) {
                tapEvt = evt;
                rootEl = el;
                dragEl = target;
                parentEl = dragEl.parentNode;
                nextEl = dragEl.nextSibling;
                activeGroup = options.group;
                dragStartFn = function () {
                    _this._disableDelayedDrag();
                    dragEl.draggable = true;
                    _toggleClass(dragEl, _this.options.chosenClass, true);
                    _this._triggerDragStart(touch);
                };
                options.ignore.split(',').forEach(function (criteria) {
                    _find(dragEl, criteria.trim(), _disableDraggable);
                });
                _on(ownerDocument, 'mouseup', _this._onDrop);
                _on(ownerDocument, 'touchend', _this._onDrop);
                _on(ownerDocument, 'touchcancel', _this._onDrop);
                if (options.delay) {
                    _on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
                    _on(ownerDocument, 'touchend', _this._disableDelayedDrag);
                    _on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
                    _on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
                    _on(ownerDocument, 'touchmove', _this._disableDelayedDrag);
                    _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
                } else {
                    dragStartFn();
                }
            }
        },
        _disableDelayedDrag: function () {
            var ownerDocument = this.el.ownerDocument;
            clearTimeout(this._dragStartTimer);
            _off(ownerDocument, 'mouseup', this._disableDelayedDrag);
            _off(ownerDocument, 'touchend', this._disableDelayedDrag);
            _off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
            _off(ownerDocument, 'mousemove', this._disableDelayedDrag);
            _off(ownerDocument, 'touchmove', this._disableDelayedDrag);
        },
        _triggerDragStart: function (touch) {
            if (touch) {
                tapEvt = {
                    target: dragEl,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                this._onDragStart(tapEvt, 'touch');
            } else if (!this.nativeDraggable) {
                this._onDragStart(tapEvt, true);
            } else {
                _on(dragEl, 'dragend', this);
                _on(rootEl, 'dragstart', this._onDragStart);
            }
            try {
                if (document.selection) {
                    document.selection.empty();
                } else {
                    window.getSelection().removeAllRanges();
                }
            } catch (err) {
            }
        },
        _dragStarted: function () {
            if (rootEl && dragEl) {
                _toggleClass(dragEl, this.options.ghostClass, true);
                Sortable.active = this;
                _dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
            }
        },
        _emulateDragOver: function () {
            if (touchEvt) {
                if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
                    return;
                }
                this._lastX = touchEvt.clientX;
                this._lastY = touchEvt.clientY;
                if (!supportCssPointerEvents) {
                    _css(ghostEl, 'display', 'none');
                }
                var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY), parent = target, groupName = ' ' + this.options.group.name + '', i = touchDragOverListeners.length;
                if (parent) {
                    do {
                        if (parent[expando] && parent[expando].options.groups.indexOf(groupName) > -1) {
                            while (i--) {
                                touchDragOverListeners[i]({
                                    clientX: touchEvt.clientX,
                                    clientY: touchEvt.clientY,
                                    target: target,
                                    rootEl: parent
                                });
                            }
                            break;
                        }
                        target = parent;
                    } while (parent = parent.parentNode);
                }
                if (!supportCssPointerEvents) {
                    _css(ghostEl, 'display', '');
                }
            }
        },
        _onTouchMove: function (evt) {
            if (tapEvt) {
                if (!Sortable.active) {
                    this._dragStarted();
                }
                this._appendGhost();
                var touch = evt.touches ? evt.touches[0] : evt, dx = touch.clientX - tapEvt.clientX, dy = touch.clientY - tapEvt.clientY, translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';
                moved = true;
                touchEvt = touch;
                _css(ghostEl, 'webkitTransform', translate3d);
                _css(ghostEl, 'mozTransform', translate3d);
                _css(ghostEl, 'msTransform', translate3d);
                _css(ghostEl, 'transform', translate3d);
                evt.preventDefault();
            }
        },
        _appendGhost: function () {
            if (!ghostEl) {
                var rect = dragEl.getBoundingClientRect(), css = _css(dragEl), options = this.options, ghostRect;
                ghostEl = dragEl.cloneNode(true);
                _toggleClass(ghostEl, options.ghostClass, false);
                _toggleClass(ghostEl, options.fallbackClass, true);
                _css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
                _css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
                _css(ghostEl, 'width', rect.width);
                _css(ghostEl, 'height', rect.height);
                _css(ghostEl, 'opacity', '0.8');
                _css(ghostEl, 'position', 'fixed');
                _css(ghostEl, 'zIndex', '100000');
                _css(ghostEl, 'pointerEvents', 'none');
                options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
                ghostRect = ghostEl.getBoundingClientRect();
                _css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
                _css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
            }
        },
        _onDragStart: function (evt, useFallback) {
            var dataTransfer = evt.dataTransfer, options = this.options;
            this._offUpEvents();
            if (activeGroup.pull == 'clone') {
                cloneEl = dragEl.cloneNode(true);
                _css(cloneEl, 'display', 'none');
                rootEl.insertBefore(cloneEl, dragEl);
            }
            if (useFallback) {
                if (useFallback === 'touch') {
                    _on(document, 'touchmove', this._onTouchMove);
                    _on(document, 'touchend', this._onDrop);
                    _on(document, 'touchcancel', this._onDrop);
                } else {
                    _on(document, 'mousemove', this._onTouchMove);
                    _on(document, 'mouseup', this._onDrop);
                }
                this._loopId = setInterval(this._emulateDragOver, 50);
            } else {
                if (dataTransfer) {
                    dataTransfer.effectAllowed = 'move';
                    options.setData && options.setData.call(this, dataTransfer, dragEl);
                }
                _on(document, 'drop', this);
                setTimeout(this._dragStarted, 0);
            }
        },
        _onDragOver: function (evt) {
            var el = this.el, target, dragRect, revert, options = this.options, group = options.group, groupPut = group.put, isOwner = activeGroup === group, canSort = options.sort;
            if (evt.preventDefault !== void 0) {
                evt.preventDefault();
                !options.dragoverBubble && evt.stopPropagation();
            }
            moved = true;
            if (activeGroup && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) : activeGroup.pull && groupPut && (activeGroup.name === group.name || groupPut.indexOf && ~groupPut.indexOf(activeGroup.name))) && (evt.rootEl === void 0 || evt.rootEl === this.el)) {
                _autoScroll(evt, options, this.el);
                if (_silent) {
                    return;
                }
                target = _closest(evt.target, options.draggable, el);
                dragRect = dragEl.getBoundingClientRect();
                if (revert) {
                    _cloneHide(true);
                    if (cloneEl || nextEl) {
                        rootEl.insertBefore(dragEl, cloneEl || nextEl);
                    } else if (!canSort) {
                        rootEl.appendChild(dragEl);
                    }
                    return;
                }
                if (el.children.length === 0 || el.children[0] === ghostEl || el === evt.target && (target = _ghostIsLast(el, evt))) {
                    if (target) {
                        if (target.animated) {
                            return;
                        }
                        targetRect = target.getBoundingClientRect();
                    }
                    _cloneHide(isOwner);
                    if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect) !== false) {
                        if (!dragEl.contains(el)) {
                            el.appendChild(dragEl);
                            parentEl = el;
                        }
                        this._animate(dragRect, dragEl);
                        target && this._animate(targetRect, target);
                    }
                } else if (target && !target.animated && target !== dragEl && target.parentNode[expando] !== void 0) {
                    if (lastEl !== target) {
                        lastEl = target;
                        lastCSS = _css(target);
                        lastParentCSS = _css(target.parentNode);
                    }
                    var targetRect = target.getBoundingClientRect(), width = targetRect.right - targetRect.left, height = targetRect.bottom - targetRect.top, floating = /left|right|inline/.test(lastCSS.cssFloat + lastCSS.display) || lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0, isWide = target.offsetWidth > dragEl.offsetWidth, isLong = target.offsetHeight > dragEl.offsetHeight, halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5, nextSibling = target.nextElementSibling, moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect), after;
                    if (moveVector !== false) {
                        _silent = true;
                        setTimeout(_unsilent, 30);
                        _cloneHide(isOwner);
                        if (moveVector === 1 || moveVector === -1) {
                            after = moveVector === 1;
                        } else if (floating) {
                            var elTop = dragEl.offsetTop, tgTop = target.offsetTop;
                            if (elTop === tgTop) {
                                after = target.previousElementSibling === dragEl && !isWide || halfway && isWide;
                            } else {
                                after = tgTop > elTop;
                            }
                        } else {
                            after = nextSibling !== dragEl && !isLong || halfway && isLong;
                        }
                        if (!dragEl.contains(el)) {
                            if (after && !nextSibling) {
                                el.appendChild(dragEl);
                            } else {
                                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                            }
                        }
                        parentEl = dragEl.parentNode;
                        this._animate(dragRect, dragEl);
                        this._animate(targetRect, target);
                    }
                }
            }
        },
        _animate: function (prevRect, target) {
            var ms = this.options.animation;
            if (ms) {
                var currentRect = target.getBoundingClientRect();
                _css(target, 'transition', 'none');
                _css(target, 'transform', 'translate3d(' + (prevRect.left - currentRect.left) + 'px,' + (prevRect.top - currentRect.top) + 'px,0)');
                target.offsetWidth;
                _css(target, 'transition', 'all ' + ms + 'ms');
                _css(target, 'transform', 'translate3d(0,0,0)');
                clearTimeout(target.animated);
                target.animated = setTimeout(function () {
                    _css(target, 'transition', '');
                    _css(target, 'transform', '');
                    target.animated = false;
                }, ms);
            }
        },
        _offUpEvents: function () {
            var ownerDocument = this.el.ownerDocument;
            _off(document, 'touchmove', this._onTouchMove);
            _off(ownerDocument, 'mouseup', this._onDrop);
            _off(ownerDocument, 'touchend', this._onDrop);
            _off(ownerDocument, 'touchcancel', this._onDrop);
        },
        _onDrop: function (evt) {
            var el = this.el, options = this.options;
            clearInterval(this._loopId);
            clearInterval(autoScroll.pid);
            clearTimeout(this._dragStartTimer);
            _off(document, 'mousemove', this._onTouchMove);
            if (this.nativeDraggable) {
                _off(document, 'drop', this);
                _off(el, 'dragstart', this._onDragStart);
            }
            this._offUpEvents();
            if (evt) {
                if (moved) {
                    evt.preventDefault();
                    !options.dropBubble && evt.stopPropagation();
                }
                ghostEl && ghostEl.parentNode.removeChild(ghostEl);
                if (dragEl) {
                    if (this.nativeDraggable) {
                        _off(dragEl, 'dragend', this);
                    }
                    _disableDraggable(dragEl);
                    _toggleClass(dragEl, this.options.ghostClass, false);
                    _toggleClass(dragEl, this.options.chosenClass, false);
                    if (rootEl !== parentEl) {
                        newIndex = _index(dragEl, options.draggable);
                        if (newIndex >= 0) {
                            _dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
                            _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
                            _dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);
                            _dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);
                        }
                    } else {
                        cloneEl && cloneEl.parentNode.removeChild(cloneEl);
                        if (dragEl.nextSibling !== nextEl) {
                            newIndex = _index(dragEl, options.draggable);
                            if (newIndex >= 0) {
                                _dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
                                _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
                            }
                        }
                    }
                    if (Sortable.active) {
                        if (newIndex === null || newIndex === -1) {
                            newIndex = oldIndex;
                        }
                        _dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);
                        this.save();
                    }
                }
            }
            this._nulling();
        },
        _nulling: function () {
            rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = scrollEl = scrollParentEl = tapEvt = touchEvt = moved = newIndex = lastEl = lastCSS = activeGroup = Sortable.active = null;
        },
        handleEvent: function (evt) {
            var type = evt.type;
            if (type === 'dragover' || type === 'dragenter') {
                if (dragEl) {
                    this._onDragOver(evt);
                    _globalDragOver(evt);
                }
            } else if (type === 'drop' || type === 'dragend') {
                this._onDrop(evt);
            }
        },
        toArray: function () {
            var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
            for (; i < n; i++) {
                el = children[i];
                if (_closest(el, options.draggable, this.el)) {
                    order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
                }
            }
            return order;
        },
        sort: function (order) {
            var items = {}, rootEl = this.el;
            this.toArray().forEach(function (id, i) {
                var el = rootEl.children[i];
                if (_closest(el, this.options.draggable, rootEl)) {
                    items[id] = el;
                }
            }, this);
            order.forEach(function (id) {
                if (items[id]) {
                    rootEl.removeChild(items[id]);
                    rootEl.appendChild(items[id]);
                }
            });
        },
        save: function () {
            var store = this.options.store;
            store && store.set(this);
        },
        closest: function (el, selector) {
            return _closest(el, selector || this.options.draggable, this.el);
        },
        option: function (name, value) {
            var options = this.options;
            if (value === void 0) {
                return options[name];
            } else {
                options[name] = value;
                if (name === 'group') {
                    _prepareGroup(options);
                }
            }
        },
        destroy: function () {
            var el = this.el;
            el[expando] = null;
            _off(el, 'mousedown', this._onTapStart);
            _off(el, 'touchstart', this._onTapStart);
            if (this.nativeDraggable) {
                _off(el, 'dragover', this);
                _off(el, 'dragenter', this);
            }
            Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
                el.removeAttribute('draggable');
            });
            touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);
            this._onDrop();
            this.el = el = null;
        }
    };
    function _cloneHide(state) {
        if (cloneEl && cloneEl.state !== state) {
            _css(cloneEl, 'display', state ? 'none' : '');
            !state && cloneEl.state && rootEl.insertBefore(cloneEl, dragEl);
            cloneEl.state = state;
        }
    }
    function _closest(el, selector, ctx) {
        if (el) {
            ctx = ctx || document;
            do {
                if (selector === '>*' && el.parentNode === ctx || _matches(el, selector)) {
                    return el;
                }
            } while (el !== ctx && (el = el.parentNode));
        }
        return null;
    }
    function _globalDragOver(evt) {
        if (evt.dataTransfer) {
            evt.dataTransfer.dropEffect = 'move';
        }
        evt.preventDefault();
    }
    function _on(el, event, fn) {
        el.addEventListener(event, fn, false);
    }
    function _off(el, event, fn) {
        el.removeEventListener(event, fn, false);
    }
    function _toggleClass(el, name, state) {
        if (el) {
            if (el.classList) {
                el.classList[state ? 'add' : 'remove'](name);
            } else {
                var className = (' ' + el.className + ' ').replace(RSPACE, ' ').replace(' ' + name + ' ', ' ');
                el.className = (className + (state ? ' ' + name : '')).replace(RSPACE, ' ');
            }
        }
    }
    function _css(el, prop, val) {
        var style = el && el.style;
        if (style) {
            if (val === void 0) {
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    val = document.defaultView.getComputedStyle(el, '');
                } else if (el.currentStyle) {
                    val = el.currentStyle;
                }
                return prop === void 0 ? val : val[prop];
            } else {
                if (!(prop in style)) {
                    prop = '-webkit-' + prop;
                }
                style[prop] = val + (typeof val === 'string' ? '' : 'px');
            }
        }
    }
    function _find(ctx, tagName, iterator) {
        if (ctx) {
            var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
            if (iterator) {
                for (; i < n; i++) {
                    iterator(list[i], i);
                }
            }
            return list;
        }
        return [];
    }
    function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
        var evt = document.createEvent('Event'), options = (sortable || rootEl[expando]).options, onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
        evt.initEvent(name, true, true);
        evt.to = rootEl;
        evt.from = fromEl || rootEl;
        evt.item = targetEl || rootEl;
        evt.clone = cloneEl;
        evt.oldIndex = startIndex;
        evt.newIndex = newIndex;
        rootEl.dispatchEvent(evt);
        if (options[onName]) {
            options[onName].call(sortable, evt);
        }
    }
    function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect) {
        var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
        evt = document.createEvent('Event');
        evt.initEvent('move', true, true);
        evt.to = toEl;
        evt.from = fromEl;
        evt.dragged = dragEl;
        evt.draggedRect = dragRect;
        evt.related = targetEl || toEl;
        evt.relatedRect = targetRect || toEl.getBoundingClientRect();
        fromEl.dispatchEvent(evt);
        if (onMoveFn) {
            retVal = onMoveFn.call(sortable, evt);
        }
        return retVal;
    }
    function _disableDraggable(el) {
        el.draggable = false;
    }
    function _unsilent() {
        _silent = false;
    }
    function _ghostIsLast(el, evt) {
        var lastEl = el.lastElementChild, rect = lastEl.getBoundingClientRect();
        return (evt.clientY - (rect.top + rect.height) > 5 || evt.clientX - (rect.right + rect.width) > 5) && lastEl;
    }
    function _generateId(el) {
        var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
        while (i--) {
            sum += str.charCodeAt(i);
        }
        return sum.toString(36);
    }
    function _index(el, selector) {
        var index = 0;
        if (!el || !el.parentNode) {
            return -1;
        }
        while (el && (el = el.previousElementSibling)) {
            if (el.nodeName.toUpperCase() !== 'TEMPLATE' && _matches(el, selector)) {
                index++;
            }
        }
        return index;
    }
    function _matches(el, selector) {
        if (el) {
            selector = selector.split('.');
            var tag = selector.shift().toUpperCase(), re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');
            return (tag === '' || el.nodeName.toUpperCase() == tag) && (!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length);
        }
        return false;
    }
    function _throttle(callback, ms) {
        var args, _this;
        return function () {
            if (args === void 0) {
                args = arguments;
                _this = this;
                setTimeout(function () {
                    if (args.length === 1) {
                        callback.call(_this, args[0]);
                    } else {
                        callback.apply(_this, args);
                    }
                    args = void 0;
                }, ms);
            }
        };
    }
    function _extend(dst, src) {
        if (dst && src) {
            for (var key in src) {
                if (src.hasOwnProperty(key)) {
                    dst[key] = src[key];
                }
            }
        }
        return dst;
    }
    Sortable.utils = {
        on: _on,
        off: _off,
        css: _css,
        find: _find,
        is: function (el, selector) {
            return !!_closest(el, selector, el);
        },
        extend: _extend,
        throttle: _throttle,
        closest: _closest,
        toggleClass: _toggleClass,
        index: _index
    };
    Sortable.create = function (el, options) {
        return new Sortable(el, options);
    };
    Sortable.version = '1.4.2';
    return Sortable;
}));
CommonControlsLayerSwitcherDOM = function (Sortable) {
    var LayerSwitcherDOM = {
        _createDraggableElement: function (elementDraggable, context) {
            Sortable.create(elementDraggable, {
                handle: '.GPlayerName',
                draggable: '.draggable-layer',
                ghostClass: 'GPghostLayer',
                animation: 200,
                onEnd: function (e) {
                    context._onDragAndDropLayerClick(e);
                }
            });
        },
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPlayerSwitcher');
            container.className = 'GPwidget';
            return container;
        },
        _createMainLayersShowElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowLayersList');
            input.type = 'checkbox';
            return input;
        },
        _createMainLayersElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPlayersList');
            div.className = 'GPpanel';
            return div;
        },
        _createMainPictoElement: function () {
            var self = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowLayersListPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowLayersList');
            label.title = 'Afficher/masquer le gestionnaire de couches';
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowLayersListOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            spanOpen.addEventListener('click', function () {
                if (document.getElementById(self._addUID('GPshowLayersList')).checked) {
                    var layers = document.getElementsByClassName('GPlayerInfoOpened');
                    for (var i = 0; i < layers.length; i++) {
                        layers[i].className = 'GPlayerInfo';
                    }
                    document.getElementById(self._addUID('GPlayerInfoPanel')).className = 'GPlayerInfoPanelClosed';
                }
            });
            label.appendChild(spanOpen);
            var spanClose = document.createElement('span');
            spanClose.addEventListener('click', function () {
                if (document.getElementById(self._addUID('GPshowLayersList')).checked) {
                    var layers = document.getElementsByClassName('GPlayerInfoOpened');
                    for (var i = 0; i < layers.length; i++) {
                        layers[i].className = 'GPlayerInfo';
                    }
                    document.getElementById(self._addUID('GPlayerInfoPanel')).className = 'GPlayerInfoPanelClosed';
                }
            });
            spanClose.id = self._addUID('GPshowLayersListClose');
            label.appendChild(spanClose);
            return label;
        },
        _createMainInfoElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPlayerInfoPanel');
            div.className = 'GPpanel GPlayerInfoPanelClosed';
            return div;
        },
        _createContainerLayerElement: function (obj) {
            var container = document.createElement('div');
            container.id = this._addUID('GPlayerSwitcher_ID_' + obj.id);
            container.className = 'GPlayerSwitcher_layer draggable-layer';
            container.appendChild(this._createBasicToolElement(obj));
            var array = this._createAdvancedToolShowElement(obj);
            for (var i = 0; i < array.length; i++) {
                container.appendChild(array[i]);
            }
            container.appendChild(this._createAdvancedToolElement(obj));
            return container;
        },
        _createBasicToolElement: function (obj) {
            var div = document.createElement('div');
            div.id = this._addUID('GPbasicTools_ID_' + obj.id);
            div.className = 'GPlayerBasicTools';
            div.appendChild(this._createBasicToolNameElement(obj));
            var array = this._createBasicToolVisibilityElement(obj);
            for (var i = 0; i < array.length; i++) {
                div.appendChild(array[i]);
            }
            return div;
        },
        _createBasicToolNameElement: function (obj) {
            var span = document.createElement('span');
            span.id = this._addUID('GPname_ID_' + obj.id);
            span.className = 'GPlayerName';
            span.title = obj.description || obj.title;
            span.innerHTML = obj.title;
            return span;
        },
        _createBasicToolVisibilityElement: function (obj) {
            var list = [];
            var checked = typeof obj.visibility !== 'undefined' ? obj.visibility : true;
            var id = this._addUID('GPvisibility_ID_' + obj.id);
            var input = document.createElement('input');
            input.id = id;
            input.type = 'checkbox';
            input.checked = checked;
            var label = document.createElement('label');
            label.htmlFor = id;
            label.id = this._addUID('GPvisibilityPicto_ID_' + obj.id);
            label.className = 'GPlayerVisibility';
            label.title = 'Afficher/masquer la couche';
            var context = this;
            if (input.addEventListener) {
                input.addEventListener('click', function (e) {
                    context._onVisibilityLayerClick.call(context, e);
                });
            } else if (input.attachEvent) {
                input.attachEvent('onclick', function (e) {
                    context._onVisibilityLayerClick.call(context, e);
                });
            }
            list.push(input);
            list.push(label);
            return list;
        },
        _createAdvancedToolShowElement: function (obj) {
            var list = [];
            var label = document.createElement('label');
            label.id = this._addUID('GPshowAdvancedToolsPicto_ID_' + obj.id);
            label.htmlFor = this._addUID('GPshowAdvancedTools_ID_' + obj.id);
            label.title = 'Plus d\'outils';
            label.className = 'GPshowMoreOptions GPshowLayerAdvancedTools';
            var input = document.createElement('input');
            input.type = 'checkbox';
            input.id = this._addUID('GPshowAdvancedTools_ID_' + obj.id);
            list.push(input);
            list.push(label);
            return list;
        },
        _createAdvancedToolElement: function (obj) {
            var container = document.createElement('div');
            container.id = this._addUID('GPadvancedTools_ID_' + obj.id);
            container.className = 'GPlayerAdvancedTools';
            container.appendChild(this._createAdvancedToolDeleteElement(obj));
            if (obj.title && obj.description) {
                container.appendChild(this._createAdvancedToolInformationElement(obj));
            }
            if (obj.type !== 'feature') {
                var array = this._createAdvancedToolOpacityElement(obj);
                for (var i = 0; i < array.length; i++) {
                    container.appendChild(array[i]);
                }
            }
            return container;
        },
        _createAdvancedToolDeleteElement: function (obj) {
            var div = document.createElement('div');
            div.id = this._addUID('GPremove_ID_' + obj.id);
            div.className = 'GPlayerRemove';
            div.title = 'Supprimer la couche';
            div.layerId = obj.id;
            var context = this;
            if (div.addEventListener) {
                div.addEventListener('click', function (e) {
                    context._onDropLayerClick.call(context, e);
                });
            } else if (div.attachEvent) {
                div.attachEvent('onclick', function (e) {
                    context._onDropLayerClick.call(context, e);
                });
            }
            return div;
        },
        _createAdvancedToolInformationElement: function (obj) {
            var div = document.createElement('div');
            div.id = this._addUID('GPinfo_ID_' + obj.id);
            div.className = 'GPlayerInfo';
            div.title = 'Informations/lgende';
            div.layerId = obj.id;
            var context = this;
            if (div.addEventListener) {
                div.addEventListener('click', function (e) {
                    context._onOpenLayerInfoClick.call(context, e);
                });
            } else if (div.attachEvent) {
                div.attachEvent('onclick', function (e) {
                    context._onOpenLayerInfoClick.call(context, e);
                });
            }
            return div;
        },
        _createAdvancedToolOpacityElement: function (obj) {
            var list = [];
            var divO = document.createElement('div');
            divO.id = this._addUID('GPopacity_ID_' + obj.id);
            divO.className = 'GPlayerOpacity';
            divO.title = 'Opacit';
            var opacity = typeof obj.opacity !== 'undefined' ? obj.opacity : 1;
            opacity = Math.round(opacity * 100);
            var input = document.createElement('input');
            input.id = this._addUID('GPopacityValueDiv_ID_' + obj.id);
            input.type = 'range';
            input.value = opacity;
            var context = this;
            if (input.addEventListener) {
                input.addEventListener('change', function (e) {
                    context._onChangeLayerOpacity.call(context, e);
                });
            } else if (input.attachEvent) {
                input.attachEvent('onchange', function (e) {
                    context._onChangeLayerOpacity.call(context, e);
                });
            }
            if (input.addEventListener) {
                input.addEventListener('input', function (e) {
                    context._onChangeLayerOpacity.call(context, e);
                });
            } else if (input.attachEvent) {
                input.attachEvent('oninput', function (e) {
                    context._onChangeLayerOpacity.call(context, e);
                });
            }
            divO.appendChild(input);
            var divC = document.createElement('div');
            divC.id = this._addUID('GPopacityValueDiv_ID_' + obj.id);
            divC.className = 'GPlayerOpacityValue';
            var span = document.createElement('span');
            span.id = this._addUID('GPopacityValue_ID_' + obj.id);
            span.innerHTML = opacity + '%';
            divC.appendChild(span);
            list.push(divO);
            list.push(divC);
            return list;
        },
        _createContainerLayerInfoElement: function (obj) {
            var container = document.createElement('div');
            container.id = this._addUID('GPlayerInfoContent');
            var title = document.createElement('div');
            title.id = this._addUID('GPlayerInfoTitle');
            title.innerHTML = obj.title;
            container.appendChild(title);
            if (obj.quicklookUrl) {
                var quick = document.createElement('div');
                quick.id = this._addUID('GPlayerInfoQuicklook');
                quick.title = 'Afficher un aperu de la couche';
                var refquick = document.createElement('a');
                refquick.href = obj.quicklookUrl;
                refquick.appendChild(quick);
                container.appendChild(refquick);
            }
            var close = document.createElement('div');
            close.id = this._addUID('GPlayerInfoClose');
            close.title = 'Fermer la fentre';
            var self = this;
            var onCloseClick = function () {
                document.getElementById(self._addUID('GPlayerInfoPanel')).className = 'GPlayerInfoPanelClosed';
                var layers = document.getElementsByClassName('GPlayerInfoOpened');
                for (var i = 0; i < layers.length; i++) {
                    layers[i].className = 'GPlayerInfo';
                }
            };
            if (close.addEventListener) {
                close.addEventListener('click', onCloseClick);
            } else if (close.attachEvent) {
                close.attachEvent('onclick', onCloseClick);
            }
            container.appendChild(close);
            var desc = document.createElement('div');
            desc.id = this._addUID('GPlayerInfoDescription');
            desc.innerHTML = obj.description;
            container.appendChild(desc);
            if (obj.metadata) {
                var mtd = document.createElement('div');
                mtd.id = this._addUID('GPlayerInfoMetadata');
                var mtdtitle = document.createElement('div');
                mtdtitle.className = 'GPlayerInfoSubtitle';
                mtdtitle.innerHTML = 'Mtadonnes';
                mtd.appendChild(mtdtitle);
                for (var i = 0; i < obj.metadata.length; i++) {
                    var urlmtd = obj.metadata[i].url;
                    var mtdlink = document.createElement('div');
                    mtdlink.className = 'GPlayerInfoLink';
                    var refmtd = document.createElement('a');
                    refmtd.href = urlmtd;
                    refmtd.innerHTML = urlmtd;
                    mtdlink.appendChild(refmtd);
                    mtd.appendChild(mtdlink);
                }
                if (obj.metadata.length !== 0) {
                    container.appendChild(mtd);
                }
            }
            if (obj.legends) {
                var lgd = document.createElement('div');
                lgd.id = this._addUID('GPlayerInfoLegend');
                var lgdtitle = document.createElement('div');
                lgdtitle.className = 'GPlayerInfoSubtitle';
                lgdtitle.innerHTML = 'Lgende';
                lgd.appendChild(lgdtitle);
                var legends = {};
                var maxScale = obj.maxScaleDenominator || 560000000;
                for (var k = 0; k < obj.legends.length; k++) {
                    var minScale = obj.legends[k].minScaleDenominator;
                    if (minScale) {
                        var s = minScale.toString();
                        minScale = Math.round(parseInt(s.substring(0, 3), 10) / 10) * Math.pow(10, s.length - 2);
                    } else {
                        minScale = 270;
                    }
                    legends[minScale] = obj.legends[k];
                }
                for (var scale in legends) {
                    if (legends.hasOwnProperty(scale)) {
                        var urllgd = legends[scale].url;
                        if (typeof urllgd === 'string' && urllgd.toLowerCase().indexOf('nolegend.jpg') == -1) {
                            var lgdlink = document.createElement('div');
                            lgdlink.className = 'GPlayerInfoLink';
                            maxScale = legends[scale].maxScaleDenominator || maxScale;
                            var reflgd = document.createElement('a');
                            reflgd.href = urllgd;
                            reflgd.innerHTML = 'Du 1/' + scale + ' au 1/' + maxScale;
                            lgdlink.appendChild(reflgd);
                            lgd.appendChild(lgdlink);
                        } else {
                            delete legends[scale];
                        }
                    }
                }
                if (Object.keys(legends).length !== 0) {
                    container.appendChild(lgd);
                }
            }
            return container;
        }
    };
    return LayerSwitcherDOM;
}(sortable);
Ol3ControlsLayerSwitcher = function (ol, Utils, SelectorID, LayerSwitcherDOM) {
    function LayerSwitcher(lsOptions) {
        lsOptions = lsOptions || {};
        var options = lsOptions.options || {};
        var layers = lsOptions.layers || [];
        if (!(this instanceof LayerSwitcher)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        if (layers && !Array.isArray(layers)) {
            throw new Error('ERROR WRONG_TYPE : layers should be an array');
        }
        if (options && typeof options !== 'object') {
            throw new Error('ERROR WRONG_TYPE : options should be an object');
        }
        this._initialize(options, layers);
        var container = this._initContainer(options);
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(LayerSwitcher, ol.control.Control);
    LayerSwitcher.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(LayerSwitcher.prototype, LayerSwitcherDOM);
    LayerSwitcher.prototype.constructor = LayerSwitcher;
    LayerSwitcher.prototype.setMap = function (map) {
        if (map) {
            this._addMapLayers(map);
            map.on('moveend', function () {
                this._onMapMoveEnd.call(this, map);
            }, this);
            map.getLayers().on('add', function (evt) {
                var layer = evt.element;
                var id;
                if (!layer.hasOwnProperty('gpLayerId')) {
                    id = this._layerId;
                    layer.gpLayerId = id;
                    this._layerId++;
                } else {
                    id = layer.gpLayerId;
                }
                if (!this._layers[id]) {
                    this.addLayer(layer);
                }
            }, this);
            map.getLayers().on('remove', function (evt) {
                var layer = evt.element;
                var id = layer.gpLayerId;
                if (this._layers[id]) {
                    this.removeLayer(layer);
                }
            }, this);
        }
        ol.control.Control.prototype.setMap.call(this, map);
    };
    LayerSwitcher.prototype.addLayer = function (layer, config) {
        var map = this.getMap();
        config = config || {};
        if (!layer) {
            console.log('[ERROR] LayerSwitcher:addLayer - missing layer parameter');
            return;
        }
        var id = layer.gpLayerId;
        if (id === 'undefined') {
            console.log('[ERROR] LayerSwitcher:addLayer - configuration cannot be set for ' + layer + ' layer (layer id not found)');
            return;
        }
        var isLayerInMap = false;
        map.getLayers().forEach(function (lyr) {
            if (lyr.gpLayerId === id) {
                isLayerInMap = true;
            }
        }, this);
        if (!isLayerInMap) {
            console.log('[ERROR] LayerSwitcher:addLayer - configuration cannot be set for ', layer, ' layer (layer is not in map.getLayers() )');
            return;
        }
        if (!this._layers[id]) {
            var layerInfos = this.getLayerInfo(layer) || {};
            var opacity = layer.getOpacity();
            var visibility = layer.getVisible();
            var isInRange = this.isInRange(layer, map);
            var layerOptions = {
                layer: layer,
                id: id,
                opacity: opacity != null ? opacity : 1,
                visibility: visibility != null ? visibility : true,
                inRange: isInRange != null ? isInRange : true,
                title: config.title != null ? config.title : layerInfos._title || id,
                description: config.description || layerInfos._description || null,
                legends: config.legends || layerInfos._legends || [],
                metadata: config.metadata || layerInfos._metadata || [],
                quicklookUrl: config.quicklookUrl || layerInfos._quicklookUrl || null
            };
            this._layers[id] = layerOptions;
            var layerDiv = this._createLayerDiv(layerOptions);
            this._layers[id].div = layerDiv;
            if (layer.getZIndex && layer.getZIndex() !== 0 || layer._forceNullzIndex) {
                this._updateLayersOrder(map);
            } else {
                this._layersOrder.unshift(layerOptions);
                this._lastZIndex++;
                layer.setZIndex(this._lastZIndex);
                this._layerListContainer.insertBefore(layerDiv, this._layerListContainer.firstChild);
            }
            layer.on('change:opacity', this._updateLayerOpacity, this);
            layer.on('change:visible', this._updateLayerVisibility, this);
            var context = this;
            var updateLayersOrder = function (e) {
                context._updateLayersOrder.call(context, e);
            };
            if (this._layers[id].onZIndexChangeEvent == null) {
                this._layers[id].onZIndexChangeEvent = layer.on('change:zIndex', updateLayersOrder);
            }
        } else if (this._layers[id] && config) {
            for (var prop in config) {
                if (config.hasOwnProperty(prop)) {
                    this._layers[id][prop] = config[prop];
                }
            }
            if (config.title) {
                var nameDiv = document.getElementById(this._addUID('GPname_ID_' + id));
                if (nameDiv) {
                    nameDiv.innerHTML = config.title;
                    nameDiv.title = config.description || config.title;
                }
            }
            var infodiv = document.getElementById(this._addUID('GPinfo_ID_' + id));
            if (!document.getElementById(this._addUID('GPinfo_ID_' + id)) && config.description) {
                var advancedTools = document.getElementById(this._addUID('GPadvancedTools_ID_' + id));
                if (advancedTools) {
                    advancedTools.appendChild(this._createAdvancedToolInformationElement({ id: id }));
                }
            }
            if (infodiv && infodiv.className === 'GPlayerInfoOpened') {
                document.getElementById(this._addUID('GPlayerInfoPanel')).className = 'GPlayerInfoPanelClosed';
                infodiv.className === 'GPlayerInfo';
            }
        }
    };
    LayerSwitcher.prototype.removeLayer = function (layer) {
        var layerID = layer.gpLayerId;
        var layerList = document.getElementById(this._addUID('GPlayersList'));
        var infodiv = document.getElementById(this._addUID('GPinfo_ID_' + layerID));
        if (infodiv && infodiv.className === 'GPlayerInfoOpened') {
            document.getElementById(this._addUID('GPlayerInfoPanel')).className = 'GPlayerInfoPanelClosed';
            infodiv.className === 'GPlayerInfo';
        }
        var layerDiv = document.getElementById(this._addUID('GPlayerSwitcher_ID_' + layerID));
        layerList.removeChild(layerDiv);
        var layerIndex = Math.abs(layer.getZIndex() - this._lastZIndex);
        this._layersOrder.splice(layerIndex, 1);
        this._lastZIndex--;
        var layerOrderTemp = this._layersOrder;
        for (var i = 0; i < layerOrderTemp.length; i++) {
            layerOrderTemp[i].layer.setZIndex(this._lastZIndex - i);
        }
        delete this._layers[layerID];
    };
    LayerSwitcher.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] LayerSwitcher:setCollapsed - missing collapsed parameter');
            return;
        }
        var isCollapsed = !document.getElementById(this._addUID('GPshowLayersList')).checked;
        if (collapsed && isCollapsed || !collapsed && !isCollapsed) {
            return;
        }
        if (!isCollapsed) {
            var layers = document.getElementsByClassName('GPlayerInfoOpened');
            for (var i = 0; i < layers.length; i++) {
                layers[i].className = 'GPlayerInfo';
            }
            document.getElementById(this._addUID('GPlayerInfoPanel')).className = 'GPlayerInfoPanelClosed';
        }
        document.getElementById(this._addUID('GPshowLayersList')).checked = !collapsed;
    };
    LayerSwitcher.prototype.getCollapsed = function () {
        return this.collapsed;
    };
    LayerSwitcher.prototype.setRemovable = function (layer, removable) {
        if (!layer) {
            return;
        }
        var layerID = layer.gpLayerId;
        if (layerID == null) {
            console.log('[LayerSwitcher:setRemovable] layer should be added to map before calling setRemovable method');
            return;
        }
        var removalDiv = document.getElementById(this._addUID('GPremove_ID_' + layerID));
        console.log(removalDiv.style.display);
        if (removalDiv) {
            if (removable === false) {
                removalDiv.style.display = 'none';
            } else if (removable === true) {
                removalDiv.style.display = 'block';
            } else {
                return;
            }
        }
    };
    LayerSwitcher.prototype._initialize = function (options, layers) {
        this._uid = SelectorID.generate();
        this._layers = {};
        this._layersOrder = [];
        this._layersIndex = {};
        this._lastZIndex = 0;
        this._layerId = 0;
        this.collapsed = options.collapsed !== undefined ? options.collapsed : true;
        this._layerListContainer = null;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i].layer;
            if (layer) {
                var id;
                if (!layer.hasOwnProperty('gpLayerId')) {
                    id = this._layerId;
                    layer.gpLayerId = id;
                    this._layerId++;
                } else {
                    id = layer.gpLayerId;
                }
                var conf = layers[i].config || {};
                var opacity = layer.getOpacity();
                var visibility = layer.getVisible();
                var layerOptions = {
                    layer: layer,
                    id: id,
                    opacity: opacity != null ? opacity : 1,
                    visibility: visibility != null ? visibility : true,
                    title: conf.title != null ? conf.title : id,
                    description: conf.description || null,
                    legends: conf.legends || [],
                    metadata: conf.metadata || [],
                    quicklookUrl: conf.quicklookUrl || null
                };
                this._layers[id] = layerOptions;
            }
        }
    };
    LayerSwitcher.prototype._initContainer = function () {
        var container = this._createMainContainerElement();
        var input = this._createMainLayersShowElement();
        container.appendChild(input);
        if (!this.collapsed) {
            input.checked = 'checked';
            this.collapsed = false;
        } else {
            this.collapsed = true;
        }
        var context = this;
        var changeCollapsed = function (e) {
            this.collapsed = !e.target.checked;
            this.dispatchEvent('change:collapsed');
        };
        input.addEventListener('click', function (e) {
            changeCollapsed.call(context, e);
        });
        var divL = this._layerListContainer = this._createMainLayersElement();
        container.appendChild(divL);
        this._createDraggableElement(divL, this);
        var picto = this._createMainPictoElement();
        container.appendChild(picto);
        var divI = this._createMainInfoElement();
        container.appendChild(divI);
        return container;
    };
    LayerSwitcher.prototype._addMapLayers = function (map) {
        this._layersIndex = {};
        var context = this;
        map.getLayers().forEach(function (layer) {
            var id;
            if (!layer.hasOwnProperty('gpLayerId')) {
                id = this._layerId;
                layer.gpLayerId = id;
                this._layerId++;
            } else {
                id = layer.gpLayerId;
            }
            var layerInfos = this.getLayerInfo(layer) || {};
            if (!this._layers[id]) {
                var opacity = layer.getOpacity();
                var visibility = layer.getVisible();
                var isInRange = this.isInRange(layer, map);
                var layerOptions = {
                    layer: layer,
                    id: id,
                    opacity: opacity != null ? opacity : 1,
                    visibility: visibility != null ? visibility : true,
                    inRange: isInRange != null ? isInRange : true,
                    title: layerInfos._title || id,
                    description: layerInfos._description || null,
                    legends: layerInfos._legends || [],
                    metadata: layerInfos._metadata || [],
                    quicklookUrl: layerInfos._quicklookUrl || null
                };
                this._layers[id] = layerOptions;
            } else {
                this._layers[id].opacity = layer.getOpacity();
                this._layers[id].visibility = layer.getVisible();
                this._layers[id].inRange = this.isInRange(layer, map);
            }
            layer.on('change:opacity', this._updateLayerOpacity, this);
            layer.on('change:visible', this._updateLayerVisibility, this);
            var layerIndex = null;
            if (layer.getZIndex !== undefined) {
                layerIndex = layer.getZIndex();
                if (!this._layersIndex[layerIndex] || !Array.isArray(this._layersIndex[layerIndex])) {
                    this._layersIndex[layerIndex] = [];
                }
                this._layersIndex[layerIndex].push(this._layers[id]);
            }
        }, this);
        var updateLayersOrder = function (e) {
            context._updateLayersOrder.call(context, e);
        };
        for (var zindex in this._layersIndex) {
            if (this._layersIndex.hasOwnProperty(zindex)) {
                var layers = this._layersIndex[zindex];
                for (var l = 0; l < layers.length; l++) {
                    this._layersOrder.unshift(layers[l]);
                    this._lastZIndex++;
                    layers[l].layer.setZIndex(this._lastZIndex);
                    if (this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent == null) {
                        this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent = layers[l].layer.on('change:zIndex', updateLayersOrder);
                    }
                }
            }
        }
        for (var j = 0; j < this._layersOrder.length; j++) {
            var layerOptions = this._layersOrder[j];
            var layerDiv = this._createLayerDiv(layerOptions);
            this._layerListContainer.appendChild(layerDiv);
            this._layers[layerOptions.id].div = layerDiv;
        }
    };
    LayerSwitcher.prototype._createLayerDiv = function (layerOptions) {
        var isLegends = layerOptions.legends && layerOptions.legends.length !== 0;
        var isMetadata = layerOptions.metadata && layerOptions.metadata.length !== 0;
        var isQuicklookUrl = layerOptions.quicklookUrl;
        if (isLegends || isMetadata || isQuicklookUrl) {
            layerOptions.displayInformationElement = true;
        }
        var layerDiv = this._createContainerLayerElement(layerOptions);
        if (!layerOptions.inRange) {
            layerDiv.classList.add('outOfRange');
        }
        return layerDiv;
    };
    LayerSwitcher.prototype._onChangeLayerOpacity = function (e) {
        var divId = e.target.id;
        var layerID = SelectorID.index(divId);
        var layer = this._layers[layerID].layer;
        var opacityValue = e.target.value;
        var opacityId = document.getElementById(this._addUID('GPopacityValue_ID_' + layerID));
        opacityId.innerHTML = opacityValue + '%';
        layer.setOpacity(opacityValue / 100);
    };
    LayerSwitcher.prototype._updateLayerOpacity = function (e) {
        var opacity = e.target.getOpacity();
        if (opacity > 1) {
            opacity = 1;
        }
        if (opacity < 0) {
            opacity = 0;
        }
        var id = e.target.gpLayerId;
        var layerOpacityInput = document.getElementById(this._addUID('GPopacityValueDiv_ID_' + id));
        layerOpacityInput.value = Math.round(opacity * 100);
        var layerOpacitySpan = document.getElementById(this._addUID('GPopacityValue_ID_' + id));
        layerOpacitySpan.innerHTML = Math.round(opacity * 100) + '%';
    };
    LayerSwitcher.prototype._onVisibilityLayerClick = function (e) {
        var divId = e.target.id;
        var layerID = SelectorID.index(divId);
        var layer = this._layers[layerID].layer;
        layer.setVisible(e.target.checked);
    };
    LayerSwitcher.prototype._updateLayerVisibility = function (e) {
        var visible = e.target.getVisible();
        var id = e.target.gpLayerId;
        var layerVisibilityInput = document.getElementById(this._addUID('GPvisibility_ID_' + id));
        layerVisibilityInput.checked = visible;
    };
    LayerSwitcher.prototype._updateLayersOrder = function () {
        var map = this.getMap();
        if (!map) {
            return;
        }
        this._layersIndex = {};
        var layerIndex;
        var id;
        map.getLayers().forEach(function (layer) {
            id = layer.gpLayerId;
            ol.Observable.unByKey(this._layers[id].onZIndexChangeEvent);
            this._layers[id].onZIndexChangeEvent = null;
            layerIndex = null;
            if (layer.getZIndex !== undefined) {
                layerIndex = layer.getZIndex();
                if (!this._layersIndex[layerIndex] || !Array.isArray(this._layersIndex[layerIndex])) {
                    this._layersIndex[layerIndex] = [];
                }
                this._layersIndex[layerIndex].push(this._layers[id]);
            }
        }, this);
        this._lastZIndex = 0;
        var context = this;
        var updateLayersOrder = function (e) {
            context._updateLayersOrder.call(context, e);
        };
        this._layersOrder = [];
        for (var zindex in this._layersIndex) {
            if (this._layersIndex.hasOwnProperty(zindex)) {
                var layers = this._layersIndex[zindex];
                for (var l = 0; l < layers.length; l++) {
                    this._layersOrder.unshift(layers[l]);
                    this._lastZIndex++;
                    if (this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent == null) {
                        this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent = layers[l].layer.on('change:zIndex', updateLayersOrder);
                    }
                }
            }
        }
        if (this._layerListContainer) {
            while (this._layerListContainer.firstChild) {
                this._layerListContainer.removeChild(this._layerListContainer.firstChild);
            }
            for (var j = 0; j < this._layersOrder.length; j++) {
                var layerOptions = this._layersOrder[j];
                this._layerListContainer.appendChild(layerOptions.div);
            }
        } else {
            console.log('[ol.control.LayerSwitcher] _updateLayersOrder : layer list container not found to update layers order ?!');
        }
    };
    LayerSwitcher.prototype._onOpenLayerInfoClick = function (e) {
        var divId = e.target.id;
        var layerID = SelectorID.index(divId);
        var layerOptions = this._layers[layerID];
        var panel;
        var info;
        divId = document.getElementById(e.target.id);
        if (divId.className === 'GPlayerInfoOpened') {
            if (divId.classList !== undefined) {
                divId.classList.remove('GPlayerInfoOpened');
                divId.classList.add('GPlayerInfo');
            }
            panel = document.getElementById(this._addUID('GPlayerInfoPanel'));
            if (panel.classList !== undefined) {
                panel.classList.remove('GPpanel');
                panel.classList.remove('GPlayerInfoPanelOpened');
                panel.classList.add('GPlayerInfoPanelClosed');
            }
            info = document.getElementById(this._addUID('GPlayerInfoContent'));
            panel.removeChild(info);
            return;
        }
        var layers = document.getElementsByClassName('GPlayerInfoOpened');
        for (var i = 0; i < layers.length; i++) {
            layers[i].className = 'GPlayerInfo';
        }
        if (divId.classList !== undefined) {
            divId.classList.remove('GPlayerInfo');
            divId.classList.add('GPlayerInfoOpened');
        }
        panel = document.getElementById(this._addUID('GPlayerInfoPanel'));
        if (panel.classList !== undefined) {
            panel.classList.add('GPpanel');
            panel.classList.remove('GPlayerInfoPanelClosed');
            panel.classList.add('GPlayerInfoPanelOpened');
        }
        info = document.getElementById(this._addUID('GPlayerInfoContent'));
        if (info) {
            panel.removeChild(info);
        }
        var obj = {
            title: layerOptions.title,
            description: layerOptions.description,
            quicklookUrl: layerOptions.quicklookUrl,
            metadata: layerOptions.metadata,
            legends: layerOptions.legends
        };
        var maxResolution = layerOptions.layer.getMaxResolution();
        if (maxResolution === Infinity) {
            obj._maxScaleDenominator = 560000000;
        } else {
            obj._maxScaleDenominator = Math.round(maxResolution / 0.00028);
        }
        var infoLayer = this._createContainerLayerInfoElement(obj);
        panel.appendChild(infoLayer);
    };
    LayerSwitcher.prototype._onDropLayerClick = function (e) {
        var divId = e.target.id;
        var layerID = SelectorID.index(divId);
        var layer = this._layers[layerID].layer;
        this.getMap().getLayers().remove(layer);
    };
    LayerSwitcher.prototype._onDragAndDropLayerClick = function () {
        var map = this.getMap();
        var context = this;
        var updateLayersOrder = function (e) {
            context._updateLayersOrder.call(context, e);
        };
        var matchesLayers = document.querySelectorAll('div.GPlayerSwitcher_layer');
        var maxZIndex = matchesLayers.length;
        this._layersOrder = [];
        for (var i = 0; i < matchesLayers.length; i++) {
            var tag = matchesLayers[i].id;
            var id = SelectorID.index(tag);
            var layer = this._layers[id].layer;
            ol.Observable.unByKey(this._layers[id].onZIndexChangeEvent);
            this._layers[id].onZIndexChangeEvent = null;
            if (layer.setZIndex) {
                layer.setZIndex(maxZIndex);
                this._layersOrder.push(this._layers[id]);
                maxZIndex--;
            }
            if (this._layers[id].onZIndexChangeEvent == null) {
                this._layers[id].onZIndexChangeEvent = layer.on('change:zIndex', updateLayersOrder);
            }
        }
        map.updateSize();
    };
    LayerSwitcher.prototype._onMapMoveEnd = function (map) {
        map.getLayers().forEach(function (layer) {
            var id = layer.gpLayerId;
            if (this._layers[id]) {
                var layerOptions = this._layers[id];
                var layerDiv;
                if (this.isInRange(layer, map) && !layerOptions.inRange) {
                    layerOptions.inRange = true;
                    layerDiv = document.getElementById(this._addUID('GPlayerSwitcher_ID_' + id));
                    layerDiv.classList.remove('outOfRange');
                } else if (!this.isInRange(layer, map) && layerOptions.inRange) {
                    layerOptions.inRange = false;
                    layerDiv = document.getElementById(this._addUID('GPlayerSwitcher_ID_' + id));
                    layerDiv.classList.add('outOfRange');
                }
            }
        }, this);
    };
    LayerSwitcher.prototype.getLayerDOMId = function (olLayer) {
        var foundId = null;
        this.getMap().getLayers().forEach(function (layer) {
            if (layer == olLayer) {
                foundId = layer.hasOwnProperty('gpLayerId') ? layer.gpLayerId : null;
            }
        }, this);
        return foundId !== null ? this._addUID('GPlayerSwitcher_ID_' + foundId) : null;
    };
    LayerSwitcher.prototype.isInRange = function (layer, map) {
        if (!map) {
            return;
        }
        var mapResolution = map.getView().getResolution();
        if (mapResolution > layer.getMaxResolution() || mapResolution < layer.getMinResolution()) {
            return false;
        }
        var mapExtent = map.getView().calculateExtent(map.getSize());
        var layerExtent = layer.getExtent();
        if (layerExtent && !ol.extent.intersects(mapExtent, layerExtent)) {
            return false;
        }
        return true;
    };
    LayerSwitcher.prototype.getLayerInfo = function (layer) {
        var layerInfo = {};
        if (layer.getSource !== undefined) {
            var src = layer.getSource();
            layerInfo._title = src._title || '';
            layerInfo._description = src._description || '';
            layerInfo._quicklookUrl = src._quicklookUrl || '';
            layerInfo._metadata = src._metadata || [];
            layerInfo._legends = src._legends || [];
        }
        return layerInfo;
    };
    return LayerSwitcher;
}(ol, Ol3Utils, CommonUtilsSelectorID, CommonControlsLayerSwitcherDOM);
CommonControlsGetFeatureInfoDOM = function () {
    var GetFeatureInfoDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPgetFeatureInfo');
            container.className = 'GPwidget';
            return container;
        },
        _createActivateGetFeatureInfoElement: function (activate) {
            var context = this;
            var input = document.createElement('input');
            input.id = this._addUID('GPactivateGetFeatureInfo');
            input.type = 'checkbox';
            input.checked = activate;
            input.addEventListener('change', function (e) {
                context.onActivateGetFeatureInfoElementChange(e);
            });
            return input;
        },
        _createMainPictoElement: function () {
            var self = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPgetFeatureInfoPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPactivateGetFeatureInfo');
            label.title = 'activer/desactiver l\'interrogation des couches';
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPgetFeatureInfoActivate');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            var spanClose = document.createElement('span');
            spanClose.id = self._addUID('GPgetFeatureInfoDeactivate');
            label.appendChild(spanClose);
            return label;
        }
    };
    return GetFeatureInfoDOM;
}();
Ol3ControlsGetFeatureInfo = function (ol, proj4, Gp, Utils, GfiUtils, SelectorID, GetFeatureInfoDOM) {
    function GetFeatureInfo(gfiOptions) {
        gfiOptions = gfiOptions || {};
        var options = gfiOptions.options || {};
        var layers = gfiOptions.layers || [];
        if (!(this instanceof GetFeatureInfo)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        if (layers && !Array.isArray(layers)) {
            throw new Error('ERROR WRONG_TYPE : layers should be an array');
        }
        if (options && typeof options !== 'object') {
            throw new Error('ERROR WRONG_TYPE : options should be an object');
        }
        this._initialize(options, layers);
        var container = this._initContainer(options);
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(GetFeatureInfo, ol.control.Control);
    GetFeatureInfo.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(GetFeatureInfo.prototype, GetFeatureInfoDOM);
    GetFeatureInfo.prototype.constructor = GetFeatureInfo;
    GetFeatureInfo.prototype._events = {
        dblclick: false,
        singleclick: false,
        contextmenu: false
    };
    GetFeatureInfo.prototype._eventsHandler = {};
    GetFeatureInfo.prototype._initialize = function (options, layers) {
        this._uid = SelectorID.generate();
        if (typeof options.auto !== 'undefined' && typeof options.auto !== 'boolean') {
            console.log('[ERROR] GetFeatureInfo:_initialize - auto parameter should be a boolean');
            return;
        }
        this._auto = options.auto || false;
        if (typeof options.active !== 'undefined' && typeof options.active !== 'boolean') {
            console.log('[ERROR] GetFeatureInfo:_initialize - active parameter should be a boolean');
            return;
        }
        this._active = typeof options.active === 'undefined' ? true : options.active;
        if (options.defaultEvent && typeof options.defaultEvent !== 'string') {
            console.log('[ERROR] GetFeatureInfo:_initialize - defaultEvent parameter should be a string');
            return;
        }
        this._defaultEvent = options.defaultEvent || 'singleclick';
        if (!this._isValidEvent(this._defaultEvent)) {
            console.log('[ERROR] GetFeatureInfo:_initialize - _defaultEvent \'' + this._defaultEvent + '\' is not a valid event');
            return;
        }
        if (options.defaultInfoFormat && typeof options.defaultInfoFormat !== 'string') {
            console.log('[ERROR] GetFeatureInfo:_initialize - defaultInfoFormat parameter should be a string');
            return;
        }
        this._defaultInfoFormat = options.defaultInfoFormat || 'text/html';
        if (options.cursorStyle && typeof options.cursorStyle !== 'string') {
            console.log('[ERROR] GetFeatureInfo:_initialize - cursorStyle parameter should be a string');
            return;
        }
        this._cursorStyle = options.cursorStyle || 'pointer';
        if (options.proxyUrl) {
            if (typeof options.proxyUrl !== 'string') {
                console.log('[ERROR] GetFeatureInfo:_initialize - proxyUrl parameter should be a string');
                return;
            }
            this._proxyUrl = options.proxyUrl;
        }
        if (options.noProxyDomains) {
            if (!Array.isArray(options.noProxyDomains)) {
                console.log('[ERROR] GetFeatureInfo:_initialize - noProxyDomains parameter should be a array');
                return;
            }
            this._noProxyDomains = options.noProxyDomains;
        }
        if (!Array.isArray(layers)) {
            console.log('[ERROR] GetFeatureInfo:_initialize - layers parameter should be an array');
            return;
        }
        this._setLayers(layers);
        this._activateGetFeatureInfoContainer = null;
    };
    GetFeatureInfo.prototype.setMap = function (map) {
        ol.control.Control.prototype.setMap.call(this, map);
        this._updateEvents();
        if (map == null) {
            return;
        }
        if (this._cursorStyle && this._active) {
            this._activateCursor(true);
        }
        map.getLayers().on('remove', function (evt) {
            for (var i = 0; i < this._layers.length; ++i) {
                if (this._layers[i].obj === evt.element) {
                    this._layers.splice(i, 1);
                    break;
                }
            }
            this._updateEvents();
        }, this);
        if (this._auto) {
            var updated = false;
            map.getLayers().forEach(function (olLayer) {
                var layerFormat = GfiUtils.getLayerFormat(olLayer);
                if (!this._hasLayer(olLayer) && layerFormat == 'vector') {
                    this._layers.push({ obj: olLayer });
                    updated = true;
                }
            }, this);
            if (updated) {
                this._updateEvents();
            }
            map.getLayers().on('add', function (evt) {
                var layerFormat = GfiUtils.getLayerFormat(evt.element);
                if (layerFormat == 'vector') {
                    this._layers.push({ obj: evt.element });
                }
                this._updateEvents();
            }, this);
        }
    };
    GetFeatureInfo.prototype.getLayers = function () {
        return this._layers;
    };
    GetFeatureInfo.prototype.setDefaultEvent = function (eventName) {
        if (typeof eventName !== 'string') {
            console.log('[ERROR] GetFeatureInfo:setDefaultEvent - eventName parameter should be a string');
            return;
        }
        if (!eventName || !this._isValidEvent(eventName)) {
            console.log('[ERROR] GetFeatureInfo:setDefaultEvent - event \'' + eventName + '\' is not allowed.');
            return;
        }
        this._defaultEvent = eventName;
        this._updateEvents();
    };
    GetFeatureInfo.prototype.setCursorStyle = function (cursorStyle) {
        if (typeof cursorStyle !== 'string') {
            console.log('[ERROR] GetFeatureInfo:setCursorStyle - cursorStyle parameter should be a string');
            return;
        }
        if (this._active) {
            if (!this._cursorStyle && cursorStyle) {
                this._activateCursor(true);
            } else if (this._cursorStyle && !cursorStyle) {
                this._activateCursor(false);
            }
        }
        this._cursorStyle = cursorStyle;
    };
    GetFeatureInfo.prototype.setActive = function (active) {
        this._setActive(active);
        var element = document.getElementById(this._addUID('GPactivateGetFeatureInfo'));
        if (element) {
            element.checked = active;
        }
    };
    GetFeatureInfo.prototype._setActive = function (active) {
        if (typeof active !== 'boolean') {
            console.log('[ERROR] GetFeatureInfo:_setActive - active parameter should be a boolean');
            return;
        }
        if (this._active === active) {
            return;
        }
        this._active = active;
        if (this._cursorStyle) {
            this._activateCursor(active);
        }
    };
    GetFeatureInfo.prototype.isActive = function () {
        return this._active;
    };
    GetFeatureInfo.prototype.setHidden = function (hidden) {
        this.element.style.visibility = hidden ? 'hidden' : '';
    };
    GetFeatureInfo.prototype.isHidden = function () {
        return this.element.style.visibility == 'hidden';
    };
    GetFeatureInfo.prototype.setLayers = function (gfiLayers) {
        this._setLayers(gfiLayers);
        this._updateEvents();
    };
    GetFeatureInfo.prototype._isValidEvent = function (eventName) {
        return Object.keys(this._events).indexOf(eventName) > -1;
    };
    GetFeatureInfo.prototype._activateEvent = function (eventName) {
        var map = this.getMap();
        var gfiObj = this;
        var getFeatureInfoHandler = function (e) {
            GfiUtils.onDisplayFeatureInfo(e, gfiObj);
        };
        if (eventName == 'contextmenu') {
            map.getViewport().addEventListener(eventName, getFeatureInfoHandler);
        } else {
            map.on(eventName, getFeatureInfoHandler);
        }
        this._eventsHandler[eventName] = getFeatureInfoHandler;
        this._events[eventName] = true;
    };
    GetFeatureInfo.prototype._deactivateEvent = function (eventName) {
        var map = this.getMap();
        if (eventName == 'contextmenu') {
            map.getViewport().removeEventListener(eventName, this._eventsHandler[eventName]);
        } else {
            map.un(eventName, this._eventsHandler[eventName]);
        }
        delete this._eventsHandler[eventName];
        this._events[eventName] = false;
    };
    GetFeatureInfo.prototype._updateEvents = function () {
        var sEvent = [];
        for (var i = 0; i < this._layers.length; ++i) {
            var event = this._layers[i].event ? this._layers[i].event : this._defaultEvent;
            if (sEvent.indexOf(event) < 0) {
                sEvent.push(event);
            }
        }
        for (var eventName in this._events) {
            if (!this._events[eventName] && sEvent.indexOf(eventName) >= 0) {
                this._activateEvent(eventName);
            } else if (this._events[eventName] && sEvent.indexOf(eventName) < 0) {
                this._deactivateEvent(eventName);
            }
        }
    };
    GetFeatureInfo.prototype._hasLayer = function (olLayer) {
        for (var i = 0; i < this._layers.length; ++i) {
            if (this._layers[i].obj === olLayer) {
                return true;
            }
        }
        return false;
    };
    GetFeatureInfo.prototype._activateCursor = function (activate) {
        var map = this.getMap();
        if (activate) {
            if (this._eventsHandler.hasOwnProperty('pointermove')) {
                console.log('[ERROR] _activateCursor - inconsistent state: pointermove event handler already registered');
                return;
            }
            var gfiObj = this;
            var displayCursor = function (evt) {
                var hit = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {
                    var gfiLayers = gfiObj.getLayers();
                    for (var m = 0; m < gfiLayers.length; ++m) {
                        if (gfiLayers[m].obj === layer) {
                            return true;
                        }
                    }
                });
                if (hit) {
                    map.getTargetElement().style.cursor = gfiObj._cursorStyle;
                } else {
                    map.getTargetElement().style.cursor = '';
                }
            };
            this._eventsHandler['pointermove'] = displayCursor;
            map.on('pointermove', displayCursor);
        } else {
            map.un('pointermove', this._eventsHandler['pointermove']);
            delete this._eventsHandler['pointermove'];
            map.getTargetElement().style.cursor = '';
        }
    };
    GetFeatureInfo.prototype._setLayers = function (gfiLayers) {
        if (!gfiLayers || !Array.isArray(gfiLayers)) {
            console.log('[ERROR] GetFeatureInfo:setLayers - gfiLayers parameter should be a array');
            return;
        }
        this._layers = [];
        for (var i = 0; i < gfiLayers.length; ++i) {
            var ind = this._layers.push({}) - 1;
            if (gfiLayers[i].event) {
                if (!this._isValidEvent(gfiLayers[i].event)) {
                    console.log('[ERROR] GetFeatureInfo:setLayers - layer event \'' + this._layers[i].event + '\' is not allowed.');
                } else {
                    this._layers[ind].event = gfiLayers[i].event;
                }
            }
            if (gfiLayers[i].infoFormat) {
                this._layers[ind].infoFormat = gfiLayers[i].infoFormat;
            }
            this._layers[ind].obj = gfiLayers[i].obj;
        }
    };
    GetFeatureInfo.prototype.onActivateGetFeatureInfoElementChange = function (e) {
        this._setActive(e.target.checked);
    };
    GetFeatureInfo.prototype._initContainer = function (options) {
        var container = this._createMainContainerElement();
        var inputActivate = this._activateGetFeatureInfoContainer = this._createActivateGetFeatureInfoElement(this.isActive());
        container.appendChild(inputActivate);
        var picto = this._createMainPictoElement();
        container.appendChild(picto);
        if (typeof options.hidden !== 'undefined') {
            if (typeof options.hidden !== 'boolean') {
                console.log('[ERROR] GetFeatureInfo:_initContainer - hidden parameter should be a boolean');
                return;
            }
            if (options.hidden) {
                container.style.visibility = 'hidden';
            }
        }
        return container;
    };
    return GetFeatureInfo;
}(ol, proj4, gp, Ol3Utils, Ol3GfiUtils, CommonUtilsSelectorID, CommonControlsGetFeatureInfoDOM);
Ol3ControlsUtilsMarkers = function () {
    var Marker = {
        lightOrange: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARDSURBVFiF3ZndaxxVGMZ/Z/YjX00Nadpo1qrFBgu56D9QbAtiLoRC7ywSNK1NURRREBKRFlSwFBW0gnSrJXY1CmISgyjFiyYSFC9ajE3MmpjdjWlMUtNos9lN9mteLzbRuCbZmTMTBB+Yi51znvd5n3nPnjnnjBIR/i/wuh4xpCpI0ojiENAA1AE1wCzwKzCE0EM5l2iShJvSyrXKnFVb8dOK4hmg3AIjifAmaU7ztMy7kYI7Zs6rQwjvka+AXcyiOMZx6XGahuE0AEHVitCFnhGAGoQugqrVaSrOKpNP4FWnSaxCGy1yWpesbyY/tLpwo7p/w0RxWHfI6Zk5q7ZSwhj6Q2sjzJLiXp1JQe+p+mllc4wA1CzHtw37lQmpCha5gbXpVxdJythh9z1kvzJJGrFixPBmOXixl+Z4mONmguZ4mIMXezG8WQsq5cs6tmDfTP7NXiSqN0vTzBD1TQfwbdmDUhX4tuyhvukATTNDlgxZ0SmUtUsgv0TZGPsv9FNSvXfNtpLqvey/0O+KTgF0zNQV7XHP4dsdtVvVKYCOmeqiPbwVOx21W9UpgI6ZWNEe2cSEo3arOgWwb0YYLp5G17Sjdqs6BdCZzYqL9B3dR2puYM221NwAfUf3uaJTAB0zaye5GmbWS6i2gdFQL5mFMCIJMgthRkO9hGobMLPFN4VWdAoptlcAQeUDRoG77YrZwDhQT4tk7JDsV6ZFMggv2+bZwyt2jYDuQnOa94GIFrc4IkzRrkPUM3NKsijatLjF0copsbJ++xec7TTPqw6EI/oB/glT+PC+13Y/aSQNv/Is+tNer09lMn7DMHwAYppp8fvTIpISkVQsFrslqww4M9OuqkgzANzl1MhCyrjZGAycm573pK1yFCyi5FoWvo/FYlPOT2fOqftRXMbB9lkEs+3zbe2f/FD5i3YMj2p3vn8/IV8DZ5yE+Gqkot+JEQCPada5dRhxEriiQ5ya90w+272916F+KpnJDLhjpkUy5HgESNqhZU2Vfr5ne+dSFtOBeso06J6cnEy6d0z0hPwEPGeH8sGVykvfjpfe1NZUci2+mHg7Go2G8z/d/goQVJ9B8S1veMYffujduo/thl+ZwUzDuBqJRGZWt7n/FcDH46lFNVLilar1uiTTxsJTnTssH/QpJVlMNQa5wbGJiWERya3Vz30zzfLb3OveY3dU5j5dp4e80Xdbd3TOu/H/yyAtpjnqgeGS8crRQRks+v5xf5gtY/KM/6NAVebhwvv90bLvHu2o/XId2pJSMmIaxo/RaHRMxN6yZtPM0K5K/7hl/FxVZgZWbs0mPDceeKcuGE95/kpSKUmaImHDNIfHrl+PiIj2zOb+MFvBY7IUOVl2ZG9g6bJH4ckJuRe/2NYZT3myKIkrGM4pNRyLjY+LW09URDb1+uaF0pfm3zJ+7zhRGdq1c9eDuwOBOzdLa/OG2X+APwE8DU64Y/5gfAAAAABJRU5ErkJggg==',
        darkOrange: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQ+SURBVFiF3ZlLaFxlGIaf/5zJpJNpaoxpYieoCxULEYK7Lqp0IWQhFLooKNKEtNIULxWlQoJgQQWLFMEg0lQMuXgD0dRSkNJFgoy0IrYNSTpj08xMmoxNYhLUyUwyt/O5mFbjmGTOLS58d3O+y/u95/vnvx0lIvxf4HE9Y7PyU0ETwl6gAQgANcA88AswhuIsKc7TJ0k3qZVrnTmqtpGhHeFloMJERArF+3g5Qaf84UYJ7og5rPai+JhCB6xiHuEQp+Ws0zI0pwloU+0oBrAnBKAGxQBtqt1pKc46UyjgHadFrEIHXXLCbrB9MYWhNYAb3f0bBsI+u0POnpijahtpJrA/tDbCPOU8aGdSsPdWM7SzOUIAam7ntwzrnWlWfnzMYW76tYsUy9RaXYesd6aCJswI0Tw5WvuG6EyEOWUk6UyEae0bQvPkTLEUeCzBupjCyl4iqyfHydkxdh3YQ/nWnSjlp3zrTnYd2MPJ2TFTgszwFNNaDaCwRdkYLd1B/NWNa9r81Y20dAdd4SmCHTGBkh6P7bvXkd0sTxHsiKku6eH13+fIbpanCHbExEp6ZJJTjuxmeYpgXYwiVNLnysCMI7tZniLYmc1Kk/Qe3E1ycXhNW3JxmN6Du13hKYIdMWsXuRpGzsOxugYu9Q+RXgojkiS9FOZS/xDH6howcqUPhWZ4imB9B9CmyoBx4AGrZBYwCTxMl2StBFnvTJdkUbxlOc4a3rYqBOxuNHfQC0RsxZZGhAA9dgLtiTkuOYQOW7Gl0c5xMbN/+xecnTQPq89QPGM/wT9hCJ8+MvjQ81pK8yp92ZvxeMpUNuvVNK0MQAwjI15vRkTSIpKOxWK/yyoBzsS0qiq8DAP3OxWylNMWmoL1XTMresZsjIJllIzk4GosFrvl/HbmiHoCYRAHx2cBo2Pknp4v45U3befQVY/z8/sp+Q5410mKC7P+oBMhALphBNy6jHgDxU92Am+t6PFXhrcPOeRPp7LZYXfEdEkWjWeBlJWwnKEyr41s/3rFwHDAnjY0zsTj8ZR710Qfys/Aq1ZCPrlZef7iwpYF25xKRhLLyQ+i0Wi48NPtrwBt6hsofeQNJ7zhp74PfGE1/Z0ZzNC0y5FIZHa1zf2vAFmeS2vqerkuVeu5pPLa0otXa01f9CklOQw1AfnRiampkIjk1/JzX0y3/LrY7Dm0w5f/ah0Pee/GXWeiSc/G/y+NjBjGuA6h8snK8VEZLbn+uD/MbiPe7P283pd9uvh5cMH3Q8uPdd+uE7ailFw3NO1aNBqdELG2rdk0MbSqLb8p7UZVmVF/59F8Wp97Mhg4ncjqfxWplKQMkbBmGKGJ6emIiNie2TZPDHB5v+/xxrtXBnWFnhfyL1yp/ejCXMUMShIKQnmlQrFYbFJcKmJTxQBc3O9789FtmZfOzfjPvT5S068bmWvj09PTm8G16WL+S/wJLybNu1V6htkAAAAASUVORK5CYII=',
        red: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQxSURBVFiF3ZldaBxVFMd/d2ayTRtjQpo2mlilWBEMshoj+FAERZIHIdA3iw+V1icRREFIQAKNgsUHQfBFwZI2WgWxqYUiVTDBBj9ILC5Nu2tjdjemsR+mSZNNNvsxO8eHTTRuk+zMnQmCf9iHnXvO+Z//nDvn3rmjRIT/C6zAI4ZVFRbtKDpQNCM0AvXANIo/EC4inMbmLBFZDJJaBVaZJ9Sd2HQCrwDbXHikgfewOMKPMh9ECsGIeVx1IHxEsQJeMY3iEMNy2m8aht8AtKpOhH70hADUI/TTqjr9puKvMsUE3vabxCp0MSJHdJ31xRSnVj9BVPcfOCj26U45PTHFh30c/am1EaaxuF+nKejd1WLX2gwhAPXL8T3De2XCqooKbuCu/eoiTZ6dXtch75WxaMeNENOyOXx8kHOpGMPOIudSMQ4fH8S0bBcs25Z5PMF7ZVpVL3BgQxvTsvn6+kVq6sK3jc3NRGhraKZgl9t9HGNEXvCSmvfKKJrL2nQfHVpTCEBNXZjuo0OB8JTAu5jiXmtjPL3vLl/jbnlKoNPN6spaVFbt8jXulqcEOmKSZS0yi5O+xt3ylEBHTLSsxbf913yNu+UpgU4DKE/Sc3AvczORNcfmZiL0HNwbCE8JvItxWDvJ1SjYFm0NzZzpG2RpIYbIIksLMc70Dbpsy+54SqCzzlQAY8B9Xsk8YAJ4gBHJe3HyXpkRyaN407OfN7zlVQjobjTv4BgQ1/ItjzjV9Oo46okZEBuhS8u3PDoZEDf7t9vg903zBLBfP8C/4cAnD87teclIGyFlLoVyllWh8vmQYRgVAOI4OQmFciKSFZFsMpmck1UC/Il5VNViEgHu9StkQYyb7bNNH1wrmDm3PgqWUHLBhl+SyeRV/6czLepJDAbw8fos4HTNb+/9PFv9u3YMU/X6f38/L98B7/gJ8U2uasiPEADTcRqDOozoBn7WcbzqmFOvpnYM+uTPpvP5SDBiimvP8xRPKV3DFpV7fX7HyYyD44M96xicmpqaSgd3TDQsv6J4zYvLx5nqsz/kK29qcyq5kFpafD+RSMSKf4P+CvCY+hJFRzmzmB2KPTvb+JnX8CsdzDGM8/F4/PrqseC/AggvZlGXtyipXc8kLcbCy6mdrg/6lBIbR41DYXR8cjIqIoW17IIXc17+nHnEOnS3VfhiHQt5d7HmVMK2Nn6+DHLiOGMmRLdMVI+NymjZ9Sf4abaMqZbQp01G/rnS60P5rT8duNXw1TpuGaXksmMYlxKJxLiIt23NponhKVV5a874rdZwmlYuTTvmjWdmGj9Mifl3kkpJ2hGJGY4THb9yJS4i2p0t+Gm2ggHJxMNb94eNzIAJZgEKbyxsP5kS00ZJSkG0oFQ0mZyYkKDuqIhs6u/7hyt75luM2RMPVfft3rW7bU9T0z2bxbV50+w/wF8f81R5OpwBhwAAAABJRU5ErkJggg==',
        turquoiseBlue: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASxSURBVFiF3ZhdbBRVGIafc2Z2210hbeWnpcQVUC8kwBUJXJBIgwkgBEPEC1GMxhgE4gUJJsYERMWI3orYaiqgrYSWH/mvMaQLciE1RAKUkrLbbhMobQ20/LT7N3OOF0CC0O7szGwv9L3c73u/93vnnD3zzYH/EUTBKx6sHUvQWgR6GTAdmASMA26A6AYuofUhQnYTVevuFlK6cGaObC9DGh8i9PtAKA/GEIKvSRZtZfnbA4VooTBmjlWvQFADPOmBfRN4l8Xv7ffbhvTF1lpwrHoTgga8GeE+by9NNRvR2tfDNfyQmVv5MYJP8L/CAqgidtai/sgpP0W84d7WavBV43Eo0CtYvOaAF7K3Rg7sKKU4Hcf71sqFfmz1DEvX9rslevvPFKc/YnSMAJRhyA+8EN2vzMHasQSzveR3/HrFEMV2udv3kOlaJmgtIg8jYcMcqpu1oGXJhMi0oJQVGaV6Dvd1day62DwnaWWd+GHSciGwz01rHraZXuaUETbMoe6qVR3Ly6fMD0oZAYJBKSOvVEyd3z3/jVjIDCSddYSjzqPwYEY875RRN2tBS4kZnDFcrNQMztw144UzjjKa6W4787IylU4ZSyZEpuWKv1w+dWohdB6Fl9NsnFNCUMqKnHGRO34PYnz+Ld2DFzN3nBIySvXkjGt1PQ+d23l3dB9ezPQ6JRzu6+rIFT/Q25lwVNHkfCDDwYuZFqeEVReb5wxYmQvDxfqz6QtvnW+e69yZcNR5jOKWgKbZKSVpZUOV0bpnG3vi0YxWXUAmo1XXnp54tLL5p+dSyi52FlJRt625nwCavxlDyrgKlLjm5o9byPBkFr456IbkfmWq1t1FsMM1zx1q3RoBr4OmpT4F+jxxndGHrbZ4IXozs3RtP0Ks98R1ghDrvYz/4PfD6ti39Qix0leNh6H07siaL9ZJKYuKtA6lhSgKaC0sWwYATENlLSmVECIZTKcHZ167NtAI9gO6PzO/1ZRg6XPAFF91AJnKDES21NaYN26l8uVoLWyhSZhS/345kUj4/+Q9XjMPdBR/9wl6Qn3TjyWnzyW88i3Y5e92BmDx6tPAV35KjDnXftqHEQBhKDXZvxmA4p5NCJzH+mFg3rxzvXzn0ZN+5BUoW8p4YcxUbbZQ4nXyGEIfhrDt7MS6o/tEOm07Z48ArTPCMPYnEomewpgBeGl1HMQGN5SSk381hdsSNzwqag1tRbZdHY/HL8JoXJwfr24AXnVKK7rae/mpz3fs8aCQ1FqfxzTPxuPxf7243V9oOMESa4XOvqgDZtlIKTKVHpz4w6Ej+ZbUWlgIHdNStkYikbZoNGoNl1f4lQGM3V8us0tLfhmhvh6/98Tu0hN/XslVQ2uRlahOIWWrMozLsVgs7aQ7KmYAAnVb67PjSh+bDsKtHX9Ubmv4dQRaEiE6JLQHwuG21tbWjBvNwm+z+8hmU+/Iu8l5akwo8uA34/bg3+W1B088nKdhCK2vmFJemjV7dqyxsdHzyTZqKwMQ2r55bmpK+SktRABb2ZO+2//9E+djvcAthIgZ0P5aZ+eVzaAKoTeqZgCKt238LP10xYaxZy7tq/j5+E5Ms629vb0b0KOt/Z/GP4jqqfL5oxVsAAAAAElFTkSuQmCC',
        defaultOffset: [
            -25.5,
            -38
        ]
    };
    return Marker;
}();
CommonUtilsCheckRightManagement = function (woodman, Config) {
    return {
        check: function (options) {
            if (!options) {
                return;
            }
            var _key = options.key;
            var _resources = options.resources || [];
            var _services = options.services || [];
            if (!_resources || _resources.length === 0) {
                return;
            }
            if (!_services || _services.length === 0) {
                return;
            }
            var _rightManagement = {};
            if (!_key) {
                if (!Config.isConfigLoaded()) {
                    console.log('WARNING : ' + 'The \'apiKey\' parameter is missing, ' + 'and the contract key configuration has not been loaded, ' + 'so impossible to check yours rights !');
                    return;
                } else {
                    _key = Object.keys(Config.configuration.generalOptions.apiKeys)[0];
                }
            }
            if (_key) {
                if (!Config.isConfigLoaded()) {
                    console.log('WARNING : ' + 'the contract key configuration has not been loaded, ' + 'so be carefull !');
                    var _noRightManagement = {};
                    for (var i = 0; i < _services.length; i++) {
                        var service = _services[i];
                        _noRightManagement[service] = [];
                        for (var j = 0; j < _resources.length; j++) {
                            var resource = _resources[j];
                            _noRightManagement[service].push(resource);
                        }
                    }
                    _noRightManagement.key = _key;
                    return _noRightManagement;
                } else {
                    for (var k = 0; k < _resources.length; k++) {
                        var _resource = _resources[k];
                        for (var l = 0; l < _services.length; l++) {
                            var _service = _services[l];
                            var params = Config.getServiceParams(_resource, _service, _key);
                            if (!params || Object.keys(params).length === 0) {
                                console.log('WARNING : ' + 'The contract key configuration has no rights to load this geoportal ' + 'resource (' + _resource + ') ' + 'for this service (' + _service + ') ');
                                continue;
                            }
                            if (!_rightManagement[_service]) {
                                _rightManagement[_service] = [];
                            }
                            _rightManagement[_service].push(_resource);
                        }
                    }
                    if (!_rightManagement || Object.keys(_rightManagement).length === 0) {
                        console.log('WARNING : ' + 'The contract key configuration has been loaded, ' + 'and the \'apiKey\' parameter has been set, ' + 'but, there is a problem on the mapping between the contract and the key !');
                        return;
                    }
                    _rightManagement.key = _key;
                    return _rightManagement;
                }
            }
        }
    };
}({}, CommonUtilsConfig);
CommonControlsSearchEngineDOM = function (ID) {
    var SearchEngineDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPsearchEngine');
            container.className = 'GPwidget';
            return container;
        },
        _createShowSearchEngineElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowSearchEngine');
            input.type = 'checkbox';
            return input;
        },
        _createShowSearchEnginePictoElement: function () {
            var self = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowSearchEnginePicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowSearchEngine');
            label.title = 'Afficher/masquer la recherche par lieux';
            label.addEventListener('click', function () {
                document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'none';
                document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                var showAdvancedSearch = document.getElementById(self._addUID('GPshowAdvancedSearch'));
                if (showAdvancedSearch) {
                    showAdvancedSearch.style.display = null;
                    document.getElementById(self._addUID('GPadvancedSearchPanel')).style.display = 'none';
                }
                var id = '#GPsearchInput-' + self._uid;
                document.querySelector(id + ' input').disabled = false;
                self.onShowSearchEngineClick();
            });
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowSearchEngineOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createSearchInputElement: function () {
            var self = this;
            var form = document.createElement('form');
            form.id = this._addUID('GPsearchInput');
            form.addEventListener('submit', function (e) {
                e.preventDefault();
                document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'block';
                document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'none';
                self.onGeocodingSearchSubmit(e);
                return false;
            });
            var input = document.createElement('input');
            input.id = this._addUID('GPsearchInputText');
            input.type = 'text';
            input.placeholder = 'Rechercher un lieu, une adresse';
            input.autocomplete = 'off';
            input.addEventListener('keyup', function (e) {
                var charCode = e.which || e.keyCode;
                if (charCode === 13 || charCode === 10 || charCode === 38 || charCode === 40) {
                    return;
                }
                document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                if (input.value.length > 2) {
                    document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'block';
                } else {
                    document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'none';
                }
                self.onAutoCompleteSearchText(e);
            });
            input.addEventListener('keydown', function (e) {
                if (true) {
                    return;
                }
                var charCode = e.which || e.keyCode;
                var container = document.getElementById(self._addUID('GPautocompleteResults'));
                if (!container) {
                    return;
                }
                var curr = container.getElementsByClassName('GPautoCompleteProposal current');
                var list = container.getElementsByClassName('GPautoCompleteProposal');
                var length = list.length;
                if (!length) {
                    return;
                }
                var current = null;
                if (!curr.length) {
                    current = list[0];
                    current.className = 'GPautoCompleteProposal current';
                    current.style.color = '#000000';
                    current.style['background-color'] = '#CEDBEF';
                    return;
                } else {
                    current = curr[0];
                }
                var index = parseInt(ID.index(current.id), 10);
                var next = index === length - 1 ? list[0] : list[index + 1];
                var prev = index === 0 ? list[length - 1] : list[index - 1];
                current.style['background-color'] = '';
                current.style.color = '';
                prev.style['background-color'] = '';
                prev.style.color = '';
                next.style['background-color'] = '';
                next.style.color = '';
                switch (charCode) {
                case 38:
                    current.className = 'GPautoCompleteProposal';
                    prev.className = 'GPautoCompleteProposal current';
                    prev.style.color = '#000000';
                    prev.style['background-color'] = '#CEDBEF';
                    break;
                case 40:
                    current.className = 'GPautoCompleteProposal';
                    next.className = 'GPautoCompleteProposal current';
                    next.style.color = '#000000';
                    next.style['background-color'] = '#CEDBEF';
                    break;
                case 13:
                    current.click(e);
                    break;
                }
                current.focus();
            });
            form.appendChild(input);
            var div = document.createElement('div');
            div.id = this._addUID('GPsearchInputReset');
            div.addEventListener('click', function () {
                document.getElementById(self._addUID('GPsearchInputText')).value = '';
                document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'none';
                document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                self.onSearchResetClick();
            });
            form.appendChild(div);
            return form;
        },
        _createShowAdvancedSearchElement: function () {
            var self = this;
            var div = document.createElement('div');
            div.id = this._addUID('GPshowAdvancedSearch');
            div.className = 'GPshowAdvancedToolPicto';
            div.title = 'Ouvrir la recherche avance';
            div.addEventListener('click', function () {
                var id = '#GPsearchInput-' + self._uid;
                document.querySelector(id + ' input').disabled = true;
                document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'none';
                document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                document.getElementById(self._addUID('GPshowAdvancedSearch')).style.display = 'none';
                document.getElementById(self._addUID('GPadvancedSearchPanel')).style.display = 'inline-block';
            });
            var span = document.createElement('span');
            span.id = this._addUID('GPshowAdvancedSearchOpen');
            span.className = 'GPshowAdvancedToolOpen';
            div.appendChild(span);
            return div;
        },
        _createAdvancedSearchPanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPadvancedSearchPanel');
            div.className = 'GPpanel';
            div.style.display = 'none';
            return div;
        },
        _createGeocodeResultsElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPgeocodeResultsList');
            div.className = 'GPpanel';
            div.style.display = 'none';
            div.appendChild(this._createGeocodeResultsHeaderElement());
            return div;
        },
        _createAutoCompleteElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPautoCompleteList');
            div.className = 'GPautoCompleteList';
            div.style.display = 'none';
            return div;
        },
        _createAutoCompleteListElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.id = this._addUID('GPautocompleteResults');
            if (container.addEventListener) {
                container.addEventListener('click', function (e) {
                    self.onAutoCompletedResultsItemClick(e);
                    document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'none';
                }, false);
            } else if (container.attachEvent) {
                container.attachEvent('onclick', function (e) {
                    self.onAutoCompletedResultsItemClick(e);
                    document.getElementById(self._addUID('GPautoCompleteList')).style.display = 'none';
                });
            }
            return container;
        },
        _createAutoCompletedLocationElement: function (location, id) {
            var container = document.getElementById(this._addUID('GPautocompleteResults'));
            var div = document.createElement('div');
            div.id = this._addUID('AutoCompletedLocation_' + id);
            div.className = 'GPautoCompleteProposal';
            div.innerHTML = location.fullText;
            if (div.addEventListener) {
                div.addEventListener('click', function (e) {
                    container.click(e);
                }, false);
            } else if (div.attachEvent) {
                div.attachEvent('onclick', function (e) {
                    container.click(e);
                });
            }
            container.appendChild(div);
        },
        _createAdvancedSearchPanelHeaderElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var divTitle = document.createElement('div');
            divTitle.className = 'GPpanelTitle';
            divTitle.innerHTML = 'Recherche avance';
            container.appendChild(divTitle);
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GPadvancedSearchClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer la recherche avance';
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    var id = '#GPsearchInput-' + self._uid;
                    document.querySelector(id + ' input').disabled = false;
                    document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                    document.getElementById(self._addUID('GPshowAdvancedSearch')).style.display = 'inline-block';
                    document.getElementById(self._addUID('GPadvancedSearchPanel')).style.display = 'none';
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    var id = '#GPsearchInput-' + self._uid;
                    document.querySelector(id + ' input').disabled = false;
                    document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                    document.getElementById(self._addUID('GPshowAdvancedSearch')).style.display = 'inline-block';
                    document.getElementById(self._addUID('GPadvancedSearchPanel')).style.display = 'none';
                });
            }
            container.appendChild(divClose);
            return container;
        },
        _createAdvancedSearchPanelFormElement: function (advancedSearchCodes) {
            var self = this;
            var form = document.createElement('form');
            form.id = this._addUID('GPadvancedSearchForm');
            form.addEventListener('submit', function (e) {
                e.preventDefault();
                var data = [];
                var id = '#GPadvancedSearchFilters-' + self._uid;
                var matchesFilters = document.querySelectorAll(id + ' > div > div > input');
                for (var i = 0; i < matchesFilters.length; i++) {
                    var element = matchesFilters[i];
                    data.push({
                        key: element.name,
                        value: element.value
                    });
                }
                self.onGeocodingAdvancedSearchSubmit(e, data);
                document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'block';
                return false;
            });
            var div = document.createElement('div');
            div.className = 'GPflexInput';
            var label = document.createElement('label');
            label.className = 'GPadvancedSearchCodeLabel';
            label.innerHTML = 'Recherche par';
            div.appendChild(label);
            var select = this._createAdvancedSearchFormCodeElement(advancedSearchCodes);
            div.appendChild(select);
            form.appendChild(div);
            return form;
        },
        _createAdvancedSearchFormCodeElement: function (codes) {
            var self = this;
            var select = document.createElement('select');
            select.id = this._addUID('GPadvancedSearchCode');
            select.className = 'GPadvancedSearchCode';
            select.addEventListener('change', function (e) {
                self.onGeocodingAdvancedSearchCodeChange(e);
            }, false);
            if (!codes) {
                codes = [
                    {
                        id: 'PositionOfInterest',
                        title: 'Lieux/toponymes'
                    },
                    {
                        id: 'StreetAddress',
                        title: 'Adresses'
                    },
                    {
                        id: 'CadastralParcel',
                        title: 'Parcelles cadastrales'
                    },
                    {
                        id: 'Administratif',
                        title: 'Administratif'
                    }
                ];
            }
            for (var i = 0; i < codes.length; i++) {
                var option = document.createElement('option');
                option.value = codes[i].id;
                option.text = codes[i].title;
                select.appendChild(option);
            }
            return select;
        },
        _createAdvancedSearchFormInputElement: function () {
            var input = document.createElement('input');
            input.type = 'submit';
            input.id = this._addUID('GPadvancedSearchSubmit');
            input.className = 'GPinputSubmit';
            input.value = 'Chercher';
            return input;
        },
        _createAdvancedSearchFormFiltersElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPadvancedSearchFilters');
            return container;
        },
        _createAdvancedSearchFiltersTableElement: function (code, display) {
            var container = document.createElement('div');
            container.id = this._addUID(code);
            if (!display) {
                container.style.display = 'none';
            }
            return container;
        },
        _createAdvancedSearchFiltersAttributElement: function (filterAttributes) {
            var container = null;
            var name = filterAttributes.name;
            var title = filterAttributes.title;
            var description = filterAttributes.description;
            var code = filterAttributes.code;
            var value = filterAttributes.value;
            var div = document.createElement('div');
            div.className = 'GPflexInput';
            var label = document.createElement('label');
            label.className = 'GPadvancedSearchFilterLabel';
            label.htmlFor = name;
            label.title = description || title;
            label.innerHTML = title;
            div.appendChild(label);
            var input = document.createElement('input');
            input.id = name;
            input.className = 'GPadvancedSearchFilterInput';
            input.type = 'text';
            input.name = name;
            if (value) {
                input.value = value;
            }
            div.appendChild(input);
            container = document.getElementById(this._addUID(code));
            if (container) {
                container.appendChild(div);
            } else {
                container = div;
            }
            return container;
        },
        _createGeocodeResultsHeaderElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var divTitle = document.createElement('div');
            divTitle.className = 'GPpanelTitle';
            divTitle.innerHTML = 'Rsultats de la recherche';
            container.appendChild(divTitle);
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GPgeocodeResultsClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer la fentre de rsultats';
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                });
            }
            container.appendChild(divClose);
            return container;
        },
        _createGeocodeResultsListElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.id = this._addUID('GPgeocodeResults');
            if (container.addEventListener) {
                container.addEventListener('click', function (e) {
                    if (!e.ctrlKey) {
                        document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                    }
                    self.onGeocodedResultsItemClick(e);
                }, false);
            } else if (container.attachEvent) {
                container.attachEvent('onclick', function (e) {
                    if (!e.ctrlKey) {
                        document.getElementById(self._addUID('GPgeocodeResultsList')).style.display = 'none';
                    }
                    self.onGeocodedResultsItemClick(e);
                });
            }
            return container;
        },
        _createGeocodedLocationElement: function (location, id) {
            var container = document.getElementById(this._addUID('GPgeocodeResults'));
            var div = document.createElement('div');
            div.id = this._addUID('GeocodedLocation_' + id);
            div.className = 'GPautoCompleteProposal';
            if (typeof location === 'string') {
                div.innerHTML = location;
            } else {
                var places = location.placeAttributes;
                if (places.freeform) {
                    div.innerHTML = places.freeform;
                } else if (places.postalCode) {
                    div.innerHTML = places.postalCode + ' ' + places.commune;
                } else if (places.cadastralParcel) {
                    div.innerHTML = places.cadastralParcel;
                } else {
                    div.innerHTML = '...';
                }
            }
            container.appendChild(div);
        }
    };
    return SearchEngineDOM;
}(CommonUtilsSelectorID);
CommonControlsSearchEngineUtils = function () {
    var SearchEngineUtils = {
        advancedSearchFiltersByDefault: {
            PositionOfInterest: [
                {
                    name: 'importance',
                    title: 'Importance'
                },
                {
                    name: 'nature',
                    title: 'Nature'
                },
                {
                    name: 'territory',
                    title: 'Territoire'
                },
                {
                    name: 'insee',
                    title: 'Code INSEE'
                },
                {
                    name: 'municipality',
                    title: 'Ville'
                },
                {
                    name: 'department',
                    title: 'Dpartement'
                }
            ],
            StreetAddress: [
                {
                    name: 'territory',
                    title: 'Territoire'
                },
                {
                    name: 'insee',
                    title: 'Code INSEE'
                },
                {
                    name: 'municipality',
                    title: 'Ville'
                },
                {
                    name: 'department',
                    title: 'Dpartement'
                }
            ],
            CadastralParcel: [
                {
                    name: 'department',
                    title: 'Dpartement',
                    description: 'Numro du dpartement (ex: 01, 94)'
                },
                {
                    name: 'commune',
                    title: 'Code commune (INSEE)',
                    description: 'Code commune (INSEE) : 3 chiffres (ex: 067)'
                },
                {
                    name: 'absorbedCity',
                    title: 'Commune absorbe',
                    description: 'Commune absorbe : 3 chiffres (ex: 000, 001)'
                },
                {
                    name: 'section',
                    title: 'Section',
                    description: 'Section : 2 caractres (ex: AA, 0D)'
                },
                {
                    name: 'number',
                    title: 'Numro',
                    description: 'Numro de la parcelle : 4 chiffres (ex: 0041, 0250)'
                }
            ],
            Administratif: [
                {
                    name: 'prefecture',
                    title: 'Prfecture'
                },
                {
                    name: 'inseeRegion',
                    title: 'Code rgion (INSEE)'
                },
                {
                    name: 'inseeDepartment',
                    title: 'Code dpartement (INSEE)'
                },
                {
                    name: 'municipality',
                    title: 'Ville'
                }
            ]
        },
        zoomToResultsByDefault: function (info) {
            var zoom = 15;
            var service = info.service;
            var fields = info.fields;
            var type = info.type;
            var importance = {
                1: 11,
                2: 12,
                3: 13,
                4: 14,
                5: 15,
                6: 16,
                7: 17,
                8: 17
            };
            if (service === 'SuggestedLocation') {
                if (type === 'PositionOfInterest') {
                    zoom = importance[fields.classification];
                }
            }
            if (service === 'DirectGeocodedLocation') {
                if (type === 'PositionOfInterest') {
                    zoom = importance[fields.importance] || 14;
                }
            }
            if (type === 'StreetAddress') {
                zoom = 17;
            }
            if (type === 'CadastralParcel') {
                zoom = 17;
            }
            if (type === 'Administratif') {
                zoom = 12;
            }
            return zoom;
        }
    };
    return SearchEngineUtils;
}();
Ol3ControlsSearchEngine = function (ol, Gp, woodman, Utils, Markers, RightManagement, SelectorID, SearchEngineDOM, SearchEngineUtils) {
    function SearchEngine(options) {
        options = options || {};
        if (!(this instanceof SearchEngine)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.initialize(options);
        this._container = this._initContainer();
        this._containerElement = null;
        if (options.element && options.element.appendChild) {
            options.element.appendChild(this._container);
            this._containerElement = options.element;
        }
        ol.control.Control.call(this, {
            element: this._containerElement || this._container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(SearchEngine, ol.control.Control);
    SearchEngine.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(SearchEngine.prototype, SearchEngineDOM);
    SearchEngine.prototype.constructor = SearchEngine;
    SearchEngine.prototype.setMap = function (map) {
        if (!map) {
            this._clearResults();
        }
        ol.control.Control.prototype.setMap.call(this, map);
    };
    SearchEngine.prototype.getCollapsed = function () {
        return this.collapsed;
    };
    SearchEngine.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] SearchEngine:setCollapsed - missing collapsed parameter');
            return;
        }
        if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
            return;
        }
        if (collapsed) {
            this._showSearchEngineInput.click();
        } else {
            this._showSearchEngineInput.click();
        }
        this.collapsed = collapsed;
    };
    SearchEngine.prototype.initialize = function (options) {
        this._checkInputOptions(options);
        this.options = {
            collapsed: true,
            zoomTo: '',
            resources: {
                geocode: [],
                autocomplete: []
            },
            displayAdvancedSearch: true,
            advancedSearch: {},
            geocodeOptions: {},
            autocompleteOptions: {}
        };
        Utils.mergeParams(this.options, options);
        if (this.options.resources.geocode.length === 0) {
            this.options.resources.geocode = [
                'PositionOfInterest',
                'StreetAddress'
            ];
        }
        if (this.options.resources.autocomplete.length === 0) {
            this.options.resources.autocomplete = [
                'PositionOfInterest',
                'StreetAddress'
            ];
        }
        this.collapsed = this.options.collapsed;
        this._uid = SelectorID.generate();
        this._showSearchEngineInput = null;
        this._inputSearchContainer = null;
        this._autocompleteContainer = null;
        this._suggestedContainer = null;
        this._suggestedLocations = [];
        this._geocodedContainer = null;
        this._geocodedLocations = [];
        this._filterContainer = null;
        this._currentGeocodingCode = null;
        this._currentGeocodingLocation = null;
        this._advancedSearchFilters = {};
        this._initAdvancedSearchFilters();
        this._advancedSearchCodes = [];
        this._initAdvancedSearchCodes();
        this._marker = null;
        this._markerUrl = Markers['lightOrange'];
        this._popupContent = null;
        this._popupDiv = this._initPopupDiv();
        this._popupOverlay = null;
        this._servicesRightManagement = {};
        this._noRightManagement = false;
        this._checkRightsManagement();
    };
    SearchEngine.prototype._checkInputOptions = function (options) {
        var i;
        if (options.resources) {
            if (typeof options.resources === 'object') {
                var geocodeResources = options.resources.geocode;
                if (geocodeResources) {
                    if (!Array.isArray(geocodeResources)) {
                        console.log('[SearchEngine] \'options.resources.geocode\' parameter should be an array');
                        geocodeResources = null;
                    }
                    var geocodeResourcesList = [
                        'StreetAddress',
                        'PositionOfInterest',
                        'CadastralParcel',
                        'Administratif'
                    ];
                    for (i = 0; i < geocodeResources.length; i++) {
                        if (geocodeResourcesList.indexOf(geocodeResources[i]) === -1) {
                            console.log('[SearchEngine] options.resources.geocode : ' + geocodeResources[i] + ' is not a resource for geocode');
                        }
                    }
                }
                var autocompleteResources = options.resources.autocomplete;
                if (autocompleteResources) {
                    if (!Array.isArray(autocompleteResources)) {
                        console.log('[SearchEngine] \'options.resources.autocomplete\' parameter should be an array');
                        autocompleteResources = null;
                    }
                    var autocompleteResourcesList = [
                        'StreetAddress',
                        'PositionOfInterest'
                    ];
                    for (i = 0; i < autocompleteResources.length; i++) {
                        if (autocompleteResourcesList.indexOf(autocompleteResources[i]) === -1) {
                            console.log('[SearchEngine] options.resources.autocomplete : ' + autocompleteResources[i] + ' is not a resource for autocomplete');
                        }
                    }
                }
            } else {
                console.log('[SearchEngine] \'resources\' parameter should be an object');
                options.resources = null;
            }
        }
    };
    SearchEngine.prototype._initAdvancedSearchCodes = function () {
        var geocodeResources = this.options.resources.geocode;
        for (var i = 0; i < geocodeResources.length; i++) {
            switch (geocodeResources[i]) {
            case 'PositionOfInterest':
                this._advancedSearchCodes.push({
                    id: 'PositionOfInterest',
                    title: 'Lieux/toponymes'
                });
                break;
            case 'StreetAddress':
                this._advancedSearchCodes.push({
                    id: 'StreetAddress',
                    title: 'Adresses'
                });
                break;
            case 'CadastralParcel':
                this._advancedSearchCodes.push({
                    id: 'CadastralParcel',
                    title: 'Parcelles cadastrales'
                });
                break;
            case 'Administratif':
                this._advancedSearchCodes.push({
                    id: 'Administratif',
                    title: 'Administratif'
                });
                break;
            default:
                break;
            }
        }
        if (this._advancedSearchCodes.length === 0) {
            this._advancedSearchCodes = [
                {
                    id: 'StreetAddress',
                    title: 'Adresses'
                },
                {
                    id: 'PositionOfInterest',
                    title: 'Lieux/toponymes'
                }
            ];
        }
    };
    SearchEngine.prototype._initAdvancedSearchFilters = function () {
        this._advancedSearchFilters = SearchEngineUtils.advancedSearchFiltersByDefault;
        var advancedSearchFiltersCustom = this.options.advancedSearch;
        Utils.assign(this._advancedSearchFilters, advancedSearchFiltersCustom);
    };
    SearchEngine.prototype._initPopupDiv = function () {
        var context = this;
        var element = document.createElement('div');
        element.className = 'gp-feature-info-div';
        var closer = document.createElement('input');
        closer.type = 'button';
        closer.className = 'gp-styling-button closer';
        closer.onclick = function () {
            if (context._popupOverlay != null) {
                context._popupOverlay.setPosition(undefined);
            }
            return false;
        };
        this._popupContent = document.createElement('div');
        this._popupContent.className = 'gp-features-content-div';
        this._popupContent.style['min-width'] = '200px';
        element.appendChild(this._popupContent);
        element.appendChild(closer);
        return element;
    };
    SearchEngine.prototype._initContainer = function () {
        var container = this._createMainContainerElement();
        var inputShow = this._showSearchEngineInput = this._createShowSearchEngineElement();
        container.appendChild(inputShow);
        if (!this.options.collapsed) {
            inputShow.checked = true;
        }
        var picto = this._createShowSearchEnginePictoElement();
        container.appendChild(picto);
        var search = this._inputSearchContainer = this._createSearchInputElement();
        var context = this;
        if (search.addEventListener) {
            search.addEventListener('click', function () {
                context.onAutoCompleteInputClick();
            });
        } else if (search.attachEvent) {
            search.attachEvent('onclick', function () {
                context.onAutoCompleteInputClick();
            });
        }
        container.appendChild(search);
        if (this.options.displayAdvancedSearch) {
            var advancedShow = this._createShowAdvancedSearchElement();
            container.appendChild(advancedShow);
            var advancedPanel = this._createAdvancedSearchPanelElement();
            var advancedHeader = this._createAdvancedSearchPanelHeaderElement();
            var advancedForm = this._createAdvancedSearchPanelFormElement(this._advancedSearchCodes);
            var advancedFormFilters = this._filterContainer = this._createAdvancedSearchFormFiltersElement();
            this._setFilter(this._advancedSearchCodes[0].id);
            var advancedFormInput = this._createAdvancedSearchFormInputElement();
            advancedForm.appendChild(advancedFormFilters);
            advancedForm.appendChild(advancedFormInput);
            advancedPanel.appendChild(advancedHeader);
            advancedPanel.appendChild(advancedForm);
            container.appendChild(advancedPanel);
        }
        var autocomplete = this._autocompleteContainer = this._createAutoCompleteElement();
        var autocompleteList = this._suggestedContainer = this._createAutoCompleteListElement();
        autocomplete.appendChild(autocompleteList);
        container.appendChild(autocomplete);
        var geocode = this._createGeocodeResultsElement();
        var geocodeList = this._geocodedContainer = this._createGeocodeResultsListElement();
        geocode.appendChild(geocodeList);
        container.appendChild(geocode);
        return container;
    };
    SearchEngine.prototype._setFilter = function (code) {
        var container = this._filterContainer;
        var codeFound = false;
        for (var i = 0; i < this._advancedSearchCodes.length; i++) {
            if (this._advancedSearchCodes[i].id === code) {
                codeFound = true;
                break;
            }
        }
        if (!codeFound) {
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            return;
        }
        this._currentGeocodingCode = code;
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        var lstAttributs = this._advancedSearchFilters[code];
        if (!lstAttributs || lstAttributs.length === 0) {
            return;
        }
        var divTable = this._createAdvancedSearchFiltersTableElement(code, true);
        for (var j = 0; j < lstAttributs.length; j++) {
            var divFilter = this._createAdvancedSearchFiltersAttributElement(lstAttributs[j]);
            divTable.appendChild(divFilter);
        }
        container.appendChild(divTable);
        return container;
    };
    SearchEngine.prototype._checkRightsManagement = function () {
        var _resources = [];
        var _key;
        var _opts = null;
        _key = this.options.autocompleteOptions.apiKey;
        _opts = this.options.autocompleteOptions.filterOptions;
        _resources = _opts ? _opts.type : [];
        if (!_resources || _resources.length === 0) {
            _resources = this.options.resources.autocomplete;
        }
        if (!_resources || _resources.length === 0) {
            _resources = [
                'StreetAddress',
                'PositionOfInterest'
            ];
        }
        var rightManagementAutoComplete = RightManagement.check({
            key: _key || this.options.apiKey,
            resources: _resources,
            services: ['AutoCompletion']
        });
        _key = this.options.geocodeOptions.apiKey;
        _opts = this.options.geocodeOptions.filterOptions;
        _resources = _opts ? _opts.type : [];
        if (!_resources || _resources.length === 0) {
            _resources = this.options.resources.geocode;
        }
        if (!_resources || _resources.length === 0) {
            _resources = [
                'StreetAddress',
                'PositionOfInterest'
            ];
        }
        var rightManagementGeocode = RightManagement.check({
            key: _key || this.options.apiKey,
            resources: _resources,
            services: ['Geocode']
        });
        if (!rightManagementAutoComplete && !rightManagementGeocode) {
            this._noRightManagement = true;
            return;
        }
        if (!this.options.apiKey) {
            if (rightManagementGeocode) {
                this.options.apiKey = rightManagementGeocode.key;
            } else {
                this.options.apiKey = rightManagementAutoComplete.key;
            }
        }
        if (rightManagementAutoComplete) {
            this._servicesRightManagement['AutoCompletion'] = rightManagementAutoComplete['AutoCompletion'];
        }
        if (rightManagementGeocode) {
            this._servicesRightManagement['Geocode'] = rightManagementGeocode['Geocode'];
        }
    };
    SearchEngine.prototype._requestAutoComplete = function (settings) {
        if (!settings || typeof settings === 'object' && Object.keys(settings).length === 0) {
            return;
        }
        if (!settings.text) {
            return;
        }
        var options = {};
        Utils.assign(options, this.options.autocompleteOptions);
        Utils.assign(options, settings);
        var resources = this.options.resources.autocomplete;
        if (resources && Array.isArray(resources)) {
            if (!options.filterOptions) {
                options.filterOptions = {};
            }
            if (!options.filterOptions.type) {
                options.filterOptions.type = resources;
            }
        }
        options.apiKey = options.apiKey || this.options.apiKey;
        Gp.Services.autoComplete(options);
    };
    SearchEngine.prototype._fillAutoCompletedLocationListContainer = function (locations) {
        if (!locations || locations.length === 0) {
            return;
        }
        var element = this._suggestedContainer;
        if (element.childElementCount) {
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
        this._displaySuggestedLocation();
        for (var i = 0; i < locations.length; i++) {
            this._createAutoCompletedLocationElement(locations[i], i);
        }
    };
    SearchEngine.prototype._requestGeocoding = function (settings) {
        if (!settings || typeof settings === 'object' && Object.keys(settings).length === 0) {
            return;
        }
        if (!settings.location) {
            return;
        }
        var options = {};
        options.returnFreeForm = true;
        Utils.assign(options, this.options.geocodeOptions);
        Utils.assign(options, settings);
        var resources = this.options.resources.geocode;
        if (resources && Array.isArray(resources)) {
            if (!options.filterOptions) {
                options.filterOptions = {};
            }
            if (!options.filterOptions.type) {
                options.filterOptions.type = resources;
            }
        }
        options.apiKey = options.apiKey || this.options.apiKey;
        Gp.Services.geocode(options);
    };
    SearchEngine.prototype._fillGeocodedLocationListContainer = function (locations) {
        if (!locations || locations.length === 0) {
            this._clearGeocodedLocation();
            return;
        }
        var element = this._geocodedContainer;
        if (element.childElementCount) {
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
        for (var i = 0; i < locations.length; i++) {
            this._createGeocodedLocationElement(locations[i], i);
        }
        this._geocodedLocations = locations;
    };
    SearchEngine.prototype._setLabel = function (label) {
        document.getElementById('GPsearchInputText-' + this._uid).value = label;
    };
    SearchEngine.prototype._setPosition = function (position, zoom) {
        var view = this.getMap().getView();
        console.log(position);
        view.setCenter(position);
        view.setZoom(zoom);
    };
    SearchEngine.prototype._setMarker = function (position, info) {
        var map = this.getMap();
        var context = this;
        if (this._marker != null) {
            map.removeOverlay(this._marker);
            this._marker = null;
        }
        if (position) {
            var markerDiv = document.createElement('img');
            markerDiv.src = this._markerUrl;
            if (markerDiv.addEventListener) {
                markerDiv.addEventListener('click', function () {
                    context._onResultMarkerSelect(info);
                });
            } else if (markerDiv.attachEvent) {
                markerDiv.attachEvent('onclick', function () {
                    context._onResultMarkerSelect(info);
                });
            }
            this._marker = new ol.Overlay({
                position: position,
                offset: [
                    -25.5,
                    -38
                ],
                element: markerDiv,
                stopEvent: false
            });
            map.addOverlay(this._marker);
        }
    };
    SearchEngine.prototype._getZoom = function (info) {
        var map = this.getMap();
        var key = this.options.zoomTo;
        var zoom = null;
        if (typeof key === 'function') {
            zoom = key.call(this, info);
        }
        if (typeof key === 'number') {
            zoom = key;
        }
        if (typeof key === 'string') {
            if (key === 'auto') {
                zoom = SearchEngineUtils.zoomToResultsByDefault(info);
            } else {
                var value = parseInt(key, 10);
                if (!isNaN(value)) {
                    zoom = value;
                }
            }
        }
        Number.isInteger = Number.isInteger || function (value) {
            return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
        };
        if (!zoom || zoom === '' || !Number.isInteger(zoom)) {
            zoom = map.getView().getZoom();
        }
        var min = map.minZoom;
        var max = map.maxZoom;
        if (zoom < min) {
            zoom = min;
        }
        if (zoom > max) {
            zoom = max;
        }
        return zoom;
    };
    SearchEngine.prototype._onResultMarkerSelect = function (information) {
        var map = this.getMap();
        var popupContent = '';
        if (information.attributes) {
            popupContent = '<ul>';
            var attributes = information.attributes;
            for (var attr in attributes) {
                if (attributes.hasOwnProperty(attr)) {
                    if (attr !== 'bbox') {
                        popupContent += '<li>';
                        popupContent += '<span class="gp-attname-others-span">' + attr.toUpperCase() + ' : </span>';
                        popupContent += attributes[attr];
                        popupContent += ' </li>';
                    }
                }
            }
            popupContent += ' </ul>';
        } else {
            popupContent = information.label;
        }
        this._popupContent.innerHTML = popupContent;
        if (!this._popupOverlay) {
            this._popupOverlay = new ol.Overlay({
                element: this._popupDiv,
                positioning: 'bottom-center',
                position: this._marker.getPosition(),
                offset: [
                    0,
                    -42
                ]
            });
            map.addOverlay(this._popupOverlay);
        } else {
            this._popupOverlay.setPosition(this._marker.getPosition());
        }
    };
    SearchEngine.prototype.onShowSearchEngineClick = function () {
        this.collapsed = this._showSearchEngineInput.checked;
        this.dispatchEvent('change:collapsed');
    };
    SearchEngine.prototype.onSearchResetClick = function () {
        this._clearResults();
    };
    SearchEngine.prototype.onAutoCompleteInputClick = function () {
        var inputSearchTextContainer = document.getElementById('GPsearchInputText-' + this._uid);
        if (inputSearchTextContainer && !inputSearchTextContainer.disabled && inputSearchTextContainer.value.length > 2) {
            this._displaySuggestedLocation();
        }
    };
    SearchEngine.prototype.onAutoCompleteSearchText = function (e) {
        var value = e.target.value;
        if (!value) {
            return;
        }
        if (this._noRightManagement) {
            console.log('no rights for this service !');
            return;
        }
        this._currentGeocodingLocation = value;
        if (value.length < 3) {
            this._clearSuggestedLocation();
            return;
        }
        var context = this;
        this._requestAutoComplete({
            text: value,
            onSuccess: function (results) {
                if (results) {
                    context._suggestedLocations = results.suggestedLocations;
                    var locationsToBeDisplayed = [];
                    for (var i = 0; i < context._suggestedLocations.length; i++) {
                        var ilocation = context._suggestedLocations[i];
                        if (ilocation.position && ilocation.position.x === 0 && ilocation.position.y === 0 && ilocation.fullText) {
                            context._getGeocodeCoordinatesFromFullText(ilocation, i);
                        } else {
                            locationsToBeDisplayed.push(ilocation);
                        }
                    }
                    context._fillAutoCompletedLocationListContainer(locationsToBeDisplayed);
                }
            },
            onFailure: function (error) {
                context._clearSuggestedLocation();
            }
        });
        var map = this.getMap();
        map.on('click', this._hideSuggestedLocation, this);
        map.on('pointerdrag', this._hideSuggestedLocation, this);
    };
    SearchEngine.prototype._getGeocodeCoordinatesFromFullText = function (suggestedLocation, i) {
        var context = this;
        Gp.Services.geocode({
            apiKey: this.options.apiKey,
            location: suggestedLocation.fullText,
            filterOptions: { type: suggestedLocation.type },
            onSuccess: function (response) {
                if (response.locations && response.locations.length !== 0 && response.locations[0].position) {
                    if (context._suggestedLocations && context._suggestedLocations[i]) {
                        context._suggestedLocations[i].position = {
                            x: response.locations[0].position.y,
                            y: response.locations[0].position.x
                        };
                        context._createAutoCompletedLocationElement(context._suggestedLocations[i], i);
                    }
                }
            },
            onFailure: function () {
                if (context._suggestedLocations && context._suggestedLocations[i]) {
                    context._createAutoCompletedLocationElement(context._suggestedLocations[i], i);
                }
            }
        });
    };
    SearchEngine.prototype.onAutoCompletedResultsItemClick = function (e) {
        var idx = SelectorID.index(e.target.id);
        if (!idx) {
            return;
        }
        var position = [
            this._suggestedLocations[idx].position.x,
            this._suggestedLocations[idx].position.y
        ];
        var info = {
            service: 'SuggestedLocation',
            type: this._suggestedLocations[idx].type,
            fields: this._suggestedLocations[idx]
        };
        var label = this._suggestedLocations[idx].fullText;
        this._setLabel(label);
        info.label = label;
        var view = this.getMap().getView();
        var mapProj = view.getProjection().getCode();
        if (mapProj !== 'EPSG:4326') {
            position = ol.proj.transform(position, 'EPSG:4326', mapProj);
        }
        var zoom = this._getZoom(info);
        this._setPosition(position, zoom);
        this._setMarker(position, info);
    };
    SearchEngine.prototype.onGeocodingSearchSubmit = function (e) {
        var value = e.target[0].value;
        if (!value) {
            return;
        }
        if (this._noRightManagement) {
            console.log('no rights for this service !');
            return;
        }
        this._currentGeocodingLocation = value;
        var context = this;
        this._requestGeocoding({
            location: value,
            onSuccess: function (results) {
                if (results) {
                    var locations = results.locations;
                    context._fillGeocodedLocationListContainer(locations);
                }
            },
            onFailure: function (error) {
                context._clearGeocodedLocation();
            }
        });
    };
    SearchEngine.prototype.onGeocodedResultsItemClick = function (e) {
        var idx = SelectorID.index(e.target.id);
        if (!idx) {
            return;
        }
        var position = [
            this._geocodedLocations[idx].position.y,
            this._geocodedLocations[idx].position.x
        ];
        var attributes = this._geocodedLocations[idx].placeAttributes;
        var info = {
            service: 'DirectGeocodedLocation',
            type: this._geocodedLocations[idx].type,
            fields: this._geocodedLocations[idx]
        };
        var label;
        if (attributes.freeform) {
            label = attributes.freeform;
        } else if (attributes.postalCode) {
            label = attributes.postalCode + ' ' + attributes.commune;
            info.attributes = attributes;
        } else if (attributes.cadastralParcel) {
            label = attributes.cadastralParcel;
            info.attributes = attributes;
        } else {
            label = '...';
        }
        this._setLabel(label);
        info.label = label;
        var view = this.getMap().getView();
        var mapProj = view.getProjection().getCode();
        if (mapProj !== 'EPSG:4326') {
            position = ol.proj.transform(position, 'EPSG:4326', mapProj);
        }
        var zoom = this._getZoom(info);
        this._setPosition(position, zoom);
        this._setMarker(position, info);
    };
    SearchEngine.prototype.onGeocodingAdvancedSearchCodeChange = function (e) {
        var idx = e.target.selectedIndex;
        var value = e.target.options[idx].value;
        if (!value) {
            return;
        }
        this._setFilter(value);
    };
    SearchEngine.prototype.onGeocodingAdvancedSearchSubmit = function (e, data) {
        if (!data || data.length === 0) {
            return;
        }
        var _location;
        var _filterOptions = {};
        var filter;
        _filterOptions.type = [this._currentGeocodingCode];
        for (var i = 0; i < data.length; i++) {
            filter = data[i];
            _filterOptions[filter.key] = filter.value;
        }
        if (this._currentGeocodingCode === 'CadastralParcel') {
            _location = this._getCadastralParcelRequestParams(_filterOptions);
            _filterOptions = { type: [this._currentGeocodingCode] };
        } else {
            _location = this._currentGeocodingLocation;
        }
        var context = this;
        this._requestGeocoding({
            location: _location,
            filterOptions: _filterOptions,
            onSuccess: function (results) {
                if (results) {
                    var locations = results.locations;
                    context._fillGeocodedLocationListContainer(locations);
                }
            },
            onFailure: function (error) {
                context._clearGeocodedLocation();
            }
        });
    };
    SearchEngine.prototype._getCadastralParcelRequestParams = function (filterOptions) {
        var _location = '';
        var l;
        var dep = filterOptions.department;
        if (dep) {
            l = dep.length;
            if (l === 2) {
                _location = dep;
            } else if (l === 1) {
                _location = '0' + dep;
            } else {
                _location = dep.substring(0, 2);
            }
        } else {
            _location = '__';
        }
        var commune = filterOptions.commune;
        if (commune) {
            l = commune.length;
            if (l === 3) {
                _location += commune;
            } else if (l == 2) {
                _location += '_' + commune;
            } else if (l == 1) {
                _location += '__' + commune;
            } else {
                _location += commune.substring(0, 3);
            }
        } else {
            _location += '___';
        }
        var insee = filterOptions.insee;
        if (insee) {
            if (insee.length === 5) {
                _location = insee;
            }
        }
        var absorbedCity = filterOptions.absorbedCity;
        if (absorbedCity) {
            l = absorbedCity.length;
            if (l === 3) {
                _location += absorbedCity;
            } else if (l < 3) {
                if (l === 2) {
                    _location += '_' + absorbedCity;
                } else if (l === 1) {
                    _location += '__' + absorbedCity;
                }
            } else {
                _location += absorbedCity.substring(0, 3);
            }
        } else {
            _location += '___';
        }
        var section = filterOptions.section;
        if (section) {
            l = section.length;
            if (l === 2) {
                _location += section;
            } else if (l === 1) {
                _location += '_' + section;
            } else {
                _location += section.substring(0, 2);
            }
        } else {
            _location += '__';
        }
        var number = filterOptions.number;
        if (number) {
            l = number.length;
            if (l === 4) {
                _location += number;
            } else if (l === 3) {
                _location += '_' + number;
            } else if (l === 2) {
                _location += '__' + number;
            } else if (l === 1) {
                _location += '___' + number;
            } else {
                _location += number.substring(0, 4);
            }
        } else {
            _location += '___';
        }
        return _location;
    };
    SearchEngine.prototype._clearResults = function () {
        var map = this.getMap();
        this._currentGeocodingLocation = null;
        this._clearSuggestedLocation();
        this._clearGeocodedLocation();
        this._setMarker();
        if (this._popupOverlay != null) {
            map.removeOverlay(this._popupOverlay);
            this._popupOverlay = null;
        }
    };
    SearchEngine.prototype._clearSuggestedLocation = function () {
        this._suggestedLocations = [];
        if (this._suggestedContainer) {
            while (this._suggestedContainer.firstChild) {
                this._suggestedContainer.removeChild(this._suggestedContainer.firstChild);
            }
        }
    };
    SearchEngine.prototype._hideSuggestedLocation = function () {
        if (this._autocompleteContainer) {
            this._autocompleteContainer.style.display = 'none';
        }
    };
    SearchEngine.prototype._displaySuggestedLocation = function () {
        if (this._autocompleteContainer) {
            this._autocompleteContainer.style.display = 'block';
        }
    };
    SearchEngine.prototype._clearGeocodedLocation = function () {
        this._geocodedLocations = [];
        if (this._geocodedContainer) {
            while (this._geocodedContainer.firstChild) {
                this._geocodedContainer.removeChild(this._geocodedContainer.firstChild);
            }
        }
    };
    return SearchEngine;
}(ol, gp, {}, Ol3Utils, Ol3ControlsUtilsMarkers, CommonUtilsCheckRightManagement, CommonUtilsSelectorID, CommonControlsSearchEngineDOM, CommonControlsSearchEngineUtils);
CommonUtilsMathUtils = function () {
    var MathUtils = {
        modulo: function (a, b) {
            var r = a % b;
            return r * b < 0 ? r + b : r;
        },
        decimalToDMS: function (degrees, hemispheres, numDigits) {
            var normalizedDegrees = this.modulo(degrees + 180, 360) - 180;
            var x = Math.abs(3600 * normalizedDegrees);
            var dflPrecision = numDigits || 0;
            var precision = Math.pow(10, dflPrecision);
            var deg = Math.floor(x / 3600);
            var min = Math.floor((x - deg * 3600) / 60);
            var sec = x - deg * 3600 - min * 60;
            sec = Math.ceil(sec * precision) / precision;
            if (sec >= 60) {
                sec = 0;
                min += 1;
            }
            if (min >= 60) {
                min = 0;
                deg += 1;
            }
            var direction = hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
            return {
                d: deg,
                m: min,
                s: sec,
                direction: direction
            };
        },
        toInteger: function (s, base) {
            var _base = base || 10;
            var n = parseInt(s, _base);
            if (!isNaN(n) && isFinite(n)) {
                return n;
            }
            return null;
        },
        isInteger: function (s) {
            if (isNaN(s)) {
                return false;
            }
            var v = parseFloat(s);
            return (v | 0) === v;
        },
        toFloat: function (s) {
            var n = parseFloat(s);
            if (!isNaN(n) && isFinite(n)) {
                return n;
            }
            return null;
        }
    };
    return MathUtils;
}();
CommonControlsMousePositionDOM = function () {
    var MousePositionDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPmousePosition');
            container.className = 'GPwidget';
            return container;
        },
        _createShowMousePositionElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowMousePosition');
            input.type = 'checkbox';
            return input;
        },
        _createShowMousePositionPictoElement: function (isDesktop) {
            var self = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowMousePositionPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowMousePosition');
            label.title = 'Afficher les coordonnes du curseur';
            label.addEventListener('click', function (e) {
                var mapCenterClass = '';
                if (!document.getElementById(self._addUID('GPshowMousePosition')).checked && !isDesktop) {
                    mapCenterClass = 'GPmapCenterVisible';
                }
                document.getElementById('GPmapCenter').className = mapCenterClass;
                self.onShowMousePositionClick(e);
            });
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowMousePositionOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createMousePositionPanelElement: function (displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits) {
            displayAltitude = typeof displayAltitude === 'undefined' ? true : displayAltitude;
            displayCoordinates = typeof displayCoordinates === 'undefined' ? true : displayCoordinates;
            editCoordinates = typeof editCoordinates === 'undefined' ? false : editCoordinates;
            var div = document.createElement('div');
            div.id = this._addUID('GPmousePositionPanel');
            div.className = 'GPpanel';
            div.appendChild(this._createMousePositionPanelHeaderElement());
            div.appendChild(this._createMousePositionPanelBasicElement(displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits));
            var arraySettings = this._createShowMousePositionSettingsElement(displayCoordinates);
            for (var j = 0; j < arraySettings.length; j++) {
                div.appendChild(arraySettings[j]);
            }
            return div;
        },
        _createMapCenter: function () {
            var div = document.createElement('div');
            div.id = 'GPmapCenter';
            div.className = '';
            return div;
        },
        _createMousePositionPanelHeaderElement: function () {
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var divTitle = document.createElement('div');
            divTitle.className = 'GPpanelTitle';
            divTitle.innerHTML = 'Coordonnes';
            container.appendChild(divTitle);
            var divClose = document.createElement('div');
            divClose.id = 'GPmousePositionPanelClose';
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer le panneau';
            var self = this;
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPshowMousePositionPicto')).click();
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPshowMousePositionPicto')).click();
                });
            }
            container.appendChild(divClose);
            return container;
        },
        _createMousePositionPanelBasicElement: function (displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits) {
            var container = document.createElement('div');
            container.id = this._addUID('GPmousePositionBasicPanel');
            container.appendChild(this._createMousePositionPanelBasicCoordinateElement(displayCoordinates, editCoordinates, currentProjectionUnits));
            container.appendChild(this._createMousePositionPanelEditToolsElement(editCoordinates));
            container.appendChild(this._createMousePositionPanelBasicAltitudeElement(displayAltitude));
            return container;
        },
        _createCoordinateElement: function (coordType, editCoordinates) {
            var context = this;
            if ([
                    'Lon',
                    'Lat'
                ].indexOf(coordType) === -1) {
                return [];
            }
            var list = [];
            var input = document.createElement('input');
            input.id = this._addUID('GPmousePosition' + coordType);
            input.title = editCoordinates === true ? 'Cliquer pour saisir des coordonnes' : '';
            input.readOnly = true;
            if (editCoordinates) {
                input.addEventListener('click', function () {
                    context.onMousePositionEditModeClick(true);
                });
                input.addEventListener('change', function (e) {
                    this.classList.remove('error');
                    var valid = context.validateExtentCoordinate(coordType, this.value, e);
                    valid ? this.classList.remove('error') : this.classList.add('error');
                });
            }
            list.push(input);
            var span = document.createElement('span');
            span.className = 'GPmousePositionUnits';
            list.push(span);
            return list;
        },
        _createDMSCoordinateElement: function (coordType, editCoordinates) {
            if ([
                    'Lon',
                    'Lat'
                ].indexOf(coordType) === -1) {
                return [];
            }
            var context = this;
            var list = [];
            var input = document.createElement('input');
            input.id = this._addUID('GPmousePosition' + coordType + 'Degrees');
            input.className = 'GPSexagesimal';
            input.setAttribute('name', 'degrees');
            input.title = editCoordinates === true ? 'Cliquer pour saisir des coordonnes' : '';
            input.readOnly = true;
            input.dataset.min = 0;
            input.dataset.max = coordType === 'Lon' ? 180 : 90;
            if (editCoordinates) {
                input.addEventListener('click', function () {
                    context.onMousePositionEditModeClick(true);
                });
                input.addEventListener('change', function () {
                    this.classList.remove('error');
                    var valid = context._checkDMSDegrees(coordType, this);
                    valid ? this.classList.remove('error') : this.classList.add('error');
                });
            }
            list.push(input);
            var span = document.createElement('span');
            span.className = 'GPmousePositionSexagesimalLabel';
            span.innerHTML = '\xB0';
            list.push(span);
            var input1 = document.createElement('input');
            input1.id = this._addUID('GPmousePosition' + coordType + 'Minutes');
            input1.className = 'GPSexagesimal';
            input1.setAttribute('name', 'minutes');
            input1.title = editCoordinates === true ? 'Cliquer pour saisir des coordonnes' : '';
            input1.readOnly = true;
            input1.dataset.min = 0;
            input1.dataset.max = 59;
            if (editCoordinates) {
                input1.addEventListener('click', function () {
                    context.onMousePositionEditModeClick(true);
                });
                input1.addEventListener('change', function () {
                    this.classList.remove('error');
                    var valid = context._checkDMSElement(this);
                    valid ? this.classList.remove('error') : this.classList.add('error');
                });
            }
            list.push(input1);
            var span1 = document.createElement('span');
            span1.className = 'GPmousePositionSexagesimalLabel';
            span1.innerHTML = '\'';
            list.push(span1);
            var input2 = document.createElement('input');
            input2.id = this._addUID('GPmousePosition' + coordType + 'Seconds');
            input2.className = 'GPSexagesimalsec';
            input2.setAttribute('name', 'seconds');
            input2.title = editCoordinates === true ? 'Cliquer pour saisir des coordonnes' : '';
            input2.readOnly = true;
            input2.dataset.min = 0;
            input2.dataset.max = 59;
            if (editCoordinates) {
                input2.addEventListener('click', function () {
                    context.onMousePositionEditModeClick(true);
                });
                input2.addEventListener('change', function () {
                    this.classList.remove('error');
                    var valid = context._checkDMSElement(this, true);
                    valid ? this.classList.remove('error') : this.classList.add('error');
                });
            }
            list.push(input2);
            var span2 = document.createElement('span');
            span2.className = 'GPmousePositionSexagesimalLabel';
            span2.innerHTML = '\'\'';
            list.push(span2);
            var select = document.createElement('select');
            select.id = this._addUID('GPmousePosition' + coordType + 'Direction');
            select.className = 'GPmousePositionDirection';
            select.setAttribute('name', 'direction');
            select.disabled = true;
            var option = document.createElement('option');
            option.value = coordType === 'Lon' ? 'E' : 'N';
            option.innerHTML = coordType === 'Lon' ? 'E' : 'N';
            select.appendChild(option);
            var option1 = document.createElement('option');
            option1.value = coordType === 'Lon' ? 'O' : 'S';
            option1.innerHTML = coordType === 'Lon' ? 'O' : 'S';
            select.appendChild(option1);
            list.push(select);
            return list;
        },
        _createMousePositionPanelBasicCoordinateElement: function (display, editCoordinates, currentProjectionUnits) {
            var div = document.createElement('div');
            div.id = this._addUID('GPmousePositionCoordinate');
            div.style.display = display ? 'block' : 'none';
            var divLat = document.createElement('div');
            var spanLat = document.createElement('span');
            spanLat.className = 'GPmousePositionLabel';
            spanLat.id = this._addUID('GPmousePositionLatLabel');
            spanLat.innerHTML = 'Latitude : ';
            divLat.appendChild(spanLat);
            var span = document.createElement('span');
            span.id = this._addUID('GPmousePositionLatCoordinate');
            var arrayCoords;
            if (currentProjectionUnits === 'DMS') {
                arrayCoords = this._createDMSCoordinateElement('Lat', editCoordinates);
            } else {
                arrayCoords = this._createCoordinateElement('Lat', editCoordinates);
            }
            for (var i = 0; i < arrayCoords.length; i++) {
                span.appendChild(arrayCoords[i]);
            }
            divLat.appendChild(span);
            div.appendChild(divLat);
            var divLon = document.createElement('div');
            var spanLon = document.createElement('span');
            spanLon.className = 'GPmousePositionLabel';
            spanLon.id = this._addUID('GPmousePositionLonLabel');
            spanLon.innerHTML = 'Longitude : ';
            divLon.appendChild(spanLon);
            var span1 = document.createElement('span');
            span1.id = this._addUID('GPmousePositionLonCoordinate');
            var arrayCoords1;
            if (currentProjectionUnits === 'DMS') {
                arrayCoords1 = this._createDMSCoordinateElement('Lon', editCoordinates);
            } else {
                arrayCoords1 = this._createCoordinateElement('Lon', editCoordinates);
            }
            for (var j = 0; j < arrayCoords1.length; j++) {
                span1.appendChild(arrayCoords1[j]);
            }
            divLon.appendChild(span1);
            div.appendChild(divLon);
            return div;
        },
        _createMousePositionPanelBasicAltitudeElement: function (display) {
            var div = document.createElement('div');
            div.id = this._addUID('GPmousePositionAltitude');
            div.style.display = display ? 'block' : 'none';
            var spanLabel = document.createElement('span');
            spanLabel.className = 'GPmousePositionLabel';
            spanLabel.innerHTML = 'Altitude : ';
            div.appendChild(spanLabel);
            var spanAlt = document.createElement('span');
            spanAlt.className = 'GPmousePositionCoords';
            spanAlt.id = this._addUID('GPmousePositionAlt');
            spanAlt.innerHTML = '...';
            div.appendChild(spanAlt);
            var spanUnits = document.createElement('span');
            spanUnits.className = 'GPmousePositionAltitudeUnits';
            spanUnits.innerHTML = 'm';
            div.appendChild(spanUnits);
            return div;
        },
        _createMousePositionPanelEditToolsElement: function (editCoordinates) {
            var context = this;
            var div = document.createElement('div');
            div.className = 'GPmousePositionPanelEditTools';
            div.id = this._addUID('GPmousePositionPanelEditTools');
            if (!editCoordinates) {
                div.style.display = 'none';
            }
            var span1 = document.createElement('span');
            span1.className = 'GPmousePositionEditTool';
            span1.id = this._addUID('GPmousePositionLocate');
            span1.title = editCoordinates === true ? 'Cliquer pour saisir des coordonnes' : '';
            if (editCoordinates) {
                span1.addEventListener('click', function () {
                    context.onMousePositionEditModeLocateClick();
                });
            }
            div.appendChild(span1);
            var span2 = document.createElement('span');
            span2.className = 'GPmousePositionEditTool';
            span2.id = this._addUID('GPmousePositionCloseEdit');
            span2.title = 'Quitter la saisie des coordonnes';
            span2.style.display = 'none';
            if (editCoordinates) {
                span2.addEventListener('click', function () {
                    context.onMousePositionEditModeClick(false);
                });
            }
            div.appendChild(span2);
            return div;
        },
        _createShowMousePositionSettingsElement: function (display) {
            var list = [];
            var input = document.createElement('input');
            input.type = 'checkbox';
            input.id = this._addUID('GPshowMousePositionSettings');
            var label = document.createElement('label');
            label.id = this._addUID('GPshowMousePositionSettingsPicto');
            label.htmlFor = this._addUID('GPshowMousePositionSettings');
            label.title = 'Rglages';
            label.className = 'GPshowMoreOptions GPshowMousePositionSettingsPicto';
            label.style.display = display ? 'block' : 'none';
            list.push(input);
            list.push(label);
            return list;
        },
        _createMousePositionSettingsElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPmousePositionSettings');
            var span = document.createElement('span');
            span.className = 'GPmousePositionSettingsLabel';
            span.innerHTML = 'Systme de rfrence';
            container.appendChild(span);
            return container;
        },
        _createMousePositionSettingsSystemsElement: function (systems) {
            var context = this;
            var selectSystem = document.createElement('select');
            selectSystem.id = this._addUID('GPmousePositionProjectionSystem');
            selectSystem.className = 'GPinputSelect GPmousePositionSettingsSelect';
            selectSystem.addEventListener('change', function (e) {
                context.onMousePositionProjectionSystemChange(e);
            });
            selectSystem.addEventListener('mouseover', function (e) {
                context.onMousePositionProjectionSystemMouseOver(e);
            });
            for (var i = 0; i < systems.length; i++) {
                var obj = systems[i];
                var option = document.createElement('option');
                option.value = obj.code;
                option.text = obj.label || i;
                selectSystem.appendChild(option);
            }
            return selectSystem;
        },
        _createMousePositionSettingsUnitsElement: function (units) {
            var context = this;
            var selectUnits = document.createElement('select');
            selectUnits.id = this._addUID('GPmousePositionProjectionUnits');
            selectUnits.className = 'GPinputSelect GPmousePositionSettingsSelect';
            selectUnits.addEventListener('change', function (e) {
                context.onMousePositionProjectionUnitsChange(e);
            });
            for (var j = 0; j < units.length; j++) {
                var obj = units[j];
                var option = document.createElement('option');
                option.value = obj.code ? obj.code : j;
                option.text = obj.label || j;
                selectUnits.appendChild(option);
            }
            return selectUnits;
        },
        _resetLabelElements: function (currentProjectionType) {
            var spanLat = document.getElementById(this._addUID('GPmousePositionLatLabel'));
            spanLat.innerHTML = currentProjectionType === 'Geographical' ? 'Latitude :' : 'X :';
            var spanLon = document.getElementById(this._addUID('GPmousePositionLonLabel'));
            spanLon.innerHTML = currentProjectionType === 'Geographical' ? 'Longitude :' : 'Y :';
        },
        _resetUnitElements: function (currentProjectionUnits) {
            var value = '';
            if (currentProjectionUnits === 'M' || currentProjectionUnits === 'KM') {
                value = currentProjectionUnits.toLowerCase();
            }
            var elts = document.getElementsByClassName('GPmousePositionUnits');
            for (var e = 0; e < elts.length; e++) {
                elts[e].innerHTML = value;
            }
        },
        _resetCoordinateElements: function (editCoordinates, currentProjectionType, currentProjectionUnits) {
            var latElt = document.getElementById(this._addUID('GPmousePositionLatCoordinate'));
            while (latElt.firstChild) {
                latElt.removeChild(latElt.firstChild);
            }
            var arrayCoords;
            if (currentProjectionUnits === 'DMS') {
                arrayCoords = this._createDMSCoordinateElement('Lat', editCoordinates);
            } else {
                arrayCoords = this._createCoordinateElement('Lat', editCoordinates);
            }
            for (var i = 0; i < arrayCoords.length; i++) {
                latElt.appendChild(arrayCoords[i]);
            }
            var lonElt = document.getElementById(this._addUID('GPmousePositionLonCoordinate'));
            while (lonElt.firstChild) {
                lonElt.removeChild(lonElt.firstChild);
            }
            var arrayCoords1;
            if (currentProjectionUnits === 'DMS') {
                arrayCoords1 = this._createDMSCoordinateElement('Lon', editCoordinates);
            } else {
                arrayCoords1 = this._createCoordinateElement('Lon', editCoordinates);
            }
            for (var j = 0; j < arrayCoords1.length; j++) {
                lonElt.appendChild(arrayCoords1[j]);
            }
            this.onMapMove();
        },
        _setEditMode: function (editing) {
            var locateElt = document.getElementById(this._addUID('GPmousePositionLocate'));
            locateElt.title = editing ? 'Aller  la position ...' : 'Cliquer pour saisir des coordonnes';
            var closeEditElt = document.getElementById(this._addUID('GPmousePositionCloseEdit'));
            closeEditElt.style.display = editing ? 'inline-block' : 'none';
            var selector = 'div[id^=' + this._addUID('GPmousePositionCoordinate') + ']';
            var inputs = document.querySelectorAll(selector + ' input');
            for (var i = 0; i < inputs.length; i++) {
                inputs[i].readOnly = !editing;
                if (editing) {
                    inputs[i].value = '';
                    inputs[i].classList.remove('error');
                }
            }
            var selects = document.querySelectorAll(selector + ' select');
            for (var j = 0; j < selects.length; j++) {
                selects[j].disabled = !editing;
            }
        },
        _checkDMSElement: function (input, isFloat) {
            var b = isFloat === undefined ? false : true;
            var value = input.value;
            if (b) {
                value = value.replace(',', '.');
            }
            if (isNaN(value)) {
                return false;
            }
            var v = parseFloat(value);
            if (!b && (v | 0) !== v) {
                return false;
            }
            var min = Number(input.dataset.min);
            var max = Number(input.dataset.max);
            return v >= min && v <= max;
        },
        _checkDMSDegrees: function (coordType, input) {
            if (isNaN(input.value)) {
                return false;
            }
            var v = parseFloat(input.value);
            if ((v | 0) !== v) {
                return false;
            }
            var min = Number(input.dataset.min);
            var max = Number(input.dataset.max);
            if (v < min || v > max) {
                return false;
            }
            var inputMinutes = document.getElementById(this._addUID('GPmousePosition' + coordType + 'Minutes'));
            var inputSeconds = document.getElementById(this._addUID('GPmousePosition' + coordType + 'Seconds'));
            if (v >= max) {
                inputMinutes.dataset.max = 0;
                inputSeconds.dataset.max = 0;
            } else {
                inputMinutes.dataset.max = 59;
                inputSeconds.dataset.max = 59.9999;
            }
            return true;
        },
        GPdisplayCoords: function (coordinate) {
            if (coordinate && coordinate != null) {
                var labelLon = document.getElementById(this._addUID('GPmousePositionLonLabel'));
                var labelLat = document.getElementById(this._addUID('GPmousePositionLatLabel'));
                if (coordinate.x || coordinate.y) {
                    labelLat.innerHTML = 'X : ';
                    labelLon.innerHTML = 'Y : ';
                } else if (coordinate.e || coordinate.n) {
                    labelLat.innerHTML = 'E : ';
                    labelLon.innerHTML = 'N : ';
                } else {
                    labelLat.innerHTML = 'Latitude : ';
                    labelLon.innerHTML = 'Longitude : ';
                }
                if (typeof coordinate.lat === 'object' && typeof coordinate.lng === 'object') {
                    var parts = {
                        lng: 'Lon',
                        lat: 'Lat'
                    };
                    var units = [
                        'Degrees',
                        'Minutes',
                        'Seconds'
                    ];
                    for (var p in parts) {
                        for (var u = 0; u < units.length; ++u) {
                            var selector = 'GPmousePosition' + parts[p] + units[u];
                            var elt = document.getElementById(this._addUID(selector));
                            var key = units[u].charAt(0).toLowerCase();
                            elt.value = coordinate[p][key];
                        }
                    }
                    document.getElementById(this._addUID('GPmousePositionLonDirection')).value = coordinate.lng.direction;
                    document.getElementById(this._addUID('GPmousePositionLatDirection')).value = coordinate.lat.direction;
                } else {
                    var elLat = document.getElementById(this._addUID('GPmousePositionLat'));
                    var elLon = document.getElementById(this._addUID('GPmousePositionLon'));
                    elLat.value = coordinate.x || coordinate.lat || coordinate.e || '0';
                    elLon.value = coordinate.y || coordinate.lng || coordinate.lon || coordinate.n || '0';
                    var unit = coordinate.unit === undefined ? '' : coordinate.unit;
                    var elements = document.getElementsByClassName('GPmousePositionUnits');
                    for (var n = 0; n < elements.length; ++n) {
                        elements[n].innerHTML = unit;
                    }
                }
            }
        },
        GPdisplayElevation: function (coordinate, altitudeTimeoutDelay, noDataValue, noDataValueTolerance) {
            var self = this;
            var altitudeTimeout;
            if (!altitudeTimeoutDelay) {
                altitudeTimeoutDelay = 500;
            }
            clearTimeout(altitudeTimeout);
            document.getElementById(this._addUID('GPmousePositionAlt')).innerHTML = '...';
            if (noDataValue == null) {
                noDataValue = -99999;
            }
            if (noDataValueTolerance == null) {
                noDataValueTolerance = 99980;
            }
            var maxThreshold = noDataValue + noDataValueTolerance;
            var minThreshold = noDataValue - noDataValueTolerance;
            if (coordinate && coordinate != null) {
                if (document.getElementById(this._addUID('GPmousePositionAltitude'))) {
                    altitudeTimeout = setTimeout(function () {
                        self.onRequestAltitude(coordinate, function (z) {
                            var elt = document.getElementById(self._addUID('GPmousePositionAlt'));
                            if (elt) {
                                if (minThreshold < z && z < maxThreshold) {
                                    elt.innerHTML = '---';
                                } else {
                                    elt.innerHTML = z;
                                }
                            }
                        });
                    }, altitudeTimeoutDelay);
                }
            }
        }
    };
    return MousePositionDOM;
}();
Ol3ControlsMousePosition = function (ol, proj4, woodman, Gp, Utils, Markers, RightManagement, SelectorID, MathUtils, MousePositionDOM) {
    function MousePosition(options) {
        options = options || {};
        if (!(this instanceof MousePosition)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this._initialize(options);
        var container = this._initContainer(options);
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(MousePosition, ol.control.Control);
    MousePosition.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(MousePosition.prototype, MousePositionDOM);
    MousePosition.prototype.constructor = MousePosition;
    MousePosition.prototype.setMap = function (map) {
        var context = this;
        if (map) {
            var center = this._createMapCenter();
            map.getViewport().appendChild(center);
            if (!this.collapsed && !this._isDesktop) {
                center.className = 'GPmapCenterVisible';
            }
            if (!this.collapsed) {
                if (this._isDesktop) {
                    map.on('pointermove', this.onMouseMove, this);
                } else {
                    map.on('moveend', this.onMapMove, this);
                }
            }
            if (this.options.editCoordinates) {
                var markerDiv = document.createElement('img');
                markerDiv.id = this._addUID('GPmousePositionMarker');
                markerDiv.src = this._markerUrl;
                markerDiv.title = 'Cliquer pour supprimer';
                markerDiv.addEventListener('click', function () {
                    context._markerOverlay.setPosition(undefined);
                });
                this._markerOverlay = new ol.Overlay({
                    offset: this._markerOffset,
                    element: markerDiv,
                    stopEvent: false
                });
                map.addOverlay(this._markerOverlay);
            }
        }
        ol.control.Control.prototype.setMap.call(this, map);
        if (map == null) {
            return;
        }
        if (!this.collapsed) {
            var inputShow = document.getElementById('GPshowMousePosition-' + this._uid);
            inputShow.checked = 'checked';
            this._setElevationPanel(this.options.displayAltitude);
            this._setCoordinatesPanel(this.options.displayCoordinates);
            if (!this.options.displayCoordinates) {
                this._setSettingsPanel(false);
            }
        }
    };
    MousePosition.prototype.addSystem = function (system) {
        if (typeof system !== 'object') {
            console.log('[ERROR] MousePosition:addSystem - system parameter should be an object');
            return;
        }
        if (!system.crs) {
            return;
        }
        if (!system.label) {
            system.label = system.crs;
        }
        if (!system.type) {
            system.type = 'Metric';
        }
        var found = false;
        for (var j = 0; j < this._projectionSystems.length; j++) {
            var obj = this._projectionSystems[j];
            if (system.crs === obj.crs) {
                found = true;
            }
        }
        system.code = this._projectionSystems.length;
        this._projectionSystems.push(system);
        var selectSystem = document.getElementById('GPmousePositionProjectionSystem-' + this._uid);
        if (selectSystem) {
            var option = document.createElement('option');
            option.value = system.code;
            option.text = system.label;
            selectSystem.appendChild(option);
        }
    };
    MousePosition.prototype.addSystems = function (systems) {
        if (!systems) {
            return;
        }
        if (!Array.isArray(systems)) {
            console.log('[ERROR] MousePosition:addSystems - systems parameter should be an array');
            return;
        }
        for (var i = 0; i < systems.length; i++) {
            this.addSystem(systems[i]);
        }
    };
    MousePosition.prototype.removeSystem = function (systemCrs) {
        if (!systemCrs || typeof systemCrs !== 'string') {
            console.log('[ERROR] MousePosition:removeSystem - systemCode parameter should be a string');
            return;
        }
        var systemList = document.getElementById('GPmousePositionProjectionSystem-' + this._uid);
        var systemCode = null;
        for (var i = 0; i < this._projectionSystems.length; i++) {
            var proj = this._projectionSystems[i];
            if (systemCrs === proj.crs) {
                systemCode = proj.code;
                this._projectionSystems.splice(i, 1);
                break;
            }
        }
        if (systemCode == null) {
            console.log('[WARN] MousePosition:removeSystem - system not found');
            return;
        }
        var oldNewCodeMap = [];
        for (var j = 0; j < this._projectionSystems.length; j++) {
            oldNewCodeMap[Number(this._projectionSystems[j].code)] = j;
            this._projectionSystems[j].code = j;
        }
        var indexChildToRemove = null;
        for (var k = 0; k < systemList.childNodes.length; k++) {
            if (systemCode == systemList.childNodes[j].value) {
                indexChildToRemove = k;
                continue;
            }
            systemList.childNodes[j].value = oldNewCodeMap[Number(systemList.childNodes[j].value)];
        }
        if (indexChildToRemove != null) {
            systemList.removeChild(systemList.childNodes[indexChildToRemove]);
        }
        if (this._currentProjectionSystems.code == systemCode) {
            systemList.childNodes[0].setAttribute('selected', 'selected');
            this._setCurrentSystem(systemList.childNodes[0].value);
        }
    };
    MousePosition.prototype.setUnits = function (units) {
        if (!units || !Array.isArray(units)) {
            return;
        }
        this.options.units = units;
        this._projectionUnits = [];
        this._initProjectionUnits();
        if (this._currentProjectionType) {
            this._setTypeUnitsPanel(this._currentProjectionType);
        }
    };
    MousePosition.prototype.setAltitudeOptions = function (options) {
        if (!options || typeof options !== 'object') {
            return;
        }
        this.options.altitude.triggerDelay = options.triggerDelay;
        this.options.altitude.responseDelay = options.responseDelay;
        if (options.serviceOptions) {
            for (var opt in options.serviceOptions) {
                if (options.serviceOptions.hasOwnProperty(opt)) {
                    this.options.altitude.serviceOptions[opt] = options.serviceOptions[opt];
                }
            }
        }
    };
    MousePosition.prototype.displayAltitude = function (displayAltitude) {
        if (displayAltitude === undefined) {
            return;
        }
        this.options.displayAltitude = displayAltitude;
        this._setElevationPanel(displayAltitude);
    };
    MousePosition.prototype.displayCoordinates = function (displayCoordinates) {
        if (displayCoordinates === undefined) {
            return;
        }
        this.options.displayCoordinates = displayCoordinates;
        this._setCoordinatesPanel(displayCoordinates);
        this._setSettingsPanel(displayCoordinates);
    };
    MousePosition.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] MousePosition:setCollapsed - missing collapsed parameter');
            return;
        }
        if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
            return;
        }
        if (!this._isDesktop) {
            document.getElementById('GPmapCenter').className = collapsed ? '' : 'GPmapCenterVisible';
        }
        this.onShowMousePositionClick();
        this._showMousePositionContainer.checked = !collapsed;
    };
    MousePosition.prototype._initialize = function (options) {
        this.options = options || {};
        this.options.collapsed = options.collapsed !== undefined ? options.collapsed : true;
        this.collapsed = this.options.collapsed;
        this.options.editCoordinates = options.editCoordinates !== undefined ? options.editCoordinates : false;
        this.editing = false;
        this._markerOverlay = null;
        this._markerUrl = null;
        this._markerOffset = [
            0,
            0
        ];
        this._hideMarker = false;
        this._initMarker(options.positionMarker);
        this.options.units = options.units || [];
        this.options.displayAltitude = options.displayAltitude !== undefined ? options.displayAltitude : true;
        this.options.displayCoordinates = options.displayCoordinates !== undefined ? options.displayCoordinates : true;
        this.options.systems = options.systems || [];
        if (options.altitude) {
            var altitude = options.altitude;
            this.options.altitude = {
                triggerDelay: altitude.triggerDelay !== undefined ? altitude.triggerDelay : 200,
                responseDelay: altitude.responseDelay !== undefined ? altitude.responseDelay : 500,
                serviceOptions: altitude.serviceOptions || {},
                noDataValue: altitude.noDataValue !== undefined ? altitude.noDataValue : -99999,
                noDataValueTolerance: altitude.noDataValueTolerance !== undefined ? altitude.noDataValueTolerance : 90000
            };
        } else {
            this.options.altitude = {
                triggerDelay: 200,
                responseDelay: 500,
                serviceOptions: {}
            };
        }
        this._uid = SelectorID.generate();
        this._projectionSystems = [];
        this._initProjectionSystems();
        this._projectionUnits = {};
        this._initProjectionUnits();
        this._isDesktop = Utils.detectSupport();
        if (this.options.altitude.triggerDelay < 100) {
            this.options.altitude.triggerDelay = 100;
        }
        this._timer = this.options.altitude.triggerDelay;
        this._currentProjectionSystems = this._projectionSystems[0];
        this._currentProjectionType = this._projectionSystems[0].type;
        this._currentProjectionUnits = this._projectionUnits[this._currentProjectionType][0].code;
        this._projectionUnitsContainer = null;
        this._showMousePositionContainer = null;
        if (!this.options.displayAltitude && !this.options.displayCoordinates) {
            this.options.displayCoordinates = true;
        }
        if (this.options.displayAltitude) {
            this._checkRightsManagement();
        }
    };
    MousePosition.prototype._initMarker = function (option) {
        if (!this.options.editCoordinates) {
            return;
        }
        if (!option) {
            this._markerUrl = Markers['lightOrange'];
            this._markerOffset = Markers.defaultOffset;
            return;
        }
        this._hideMarker = option.hide !== undefined ? option.hide : false;
        if (option.offset) {
            if (Array.isArray(option.offset) && option.offset.length === 2) {
                this._markerOffset = option.offset;
            } else {
                console.log('positionMarker.offset should be an array. e.g. : [0,0]');
                this._markerOffset = Markers.defaultOffset;
            }
        } else {
            this._markerOffset = Markers.defaultOffset;
        }
        var url = option.url;
        if (!url) {
            this._markerUrl = Markers['lightOrange'];
        } else if (url.match(/^[a-zA-Z]+$/)) {
            this._markerUrl = Markers[url] !== undefined ? Markers[url] : Markers['lightOrange'];
        } else {
            this._markerUrl = url;
        }
    };
    MousePosition.prototype._initProjectionSystems = function () {
        var projectionSystemsByDefault = [
            {
                label: 'Gographique',
                crs: ol.proj.get('EPSG:4326').getCode(),
                type: 'Geographical'
            },
            {
                label: 'Web Mercator',
                crs: ol.proj.get('EPSG:3857').getCode(),
                type: 'Metric'
            },
            {
                label: 'Lambert 93',
                crs: ol.proj.get('EPSG:2154').getCode(),
                type: 'Metric',
                geoBBox: {
                    left: -9.86,
                    bottom: 41.15,
                    right: 10.38,
                    top: 51.56
                }
            },
            {
                label: 'Lambert II tendu',
                crs: ol.proj.get('EPSG:27572'),
                type: 'Metric',
                geoBBox: {
                    left: -4.87,
                    bottom: 42.33,
                    right: 8.23,
                    top: 51.14
                }
            }
        ];
        var systems = this.options.systems;
        for (var i = 0; i < systems.length; i++) {
            var sys = systems[i];
            this.addSystem(sys);
        }
        if (this._projectionSystems.length === 0) {
            for (var j = 0; j < projectionSystemsByDefault.length; j++) {
                this.addSystem(projectionSystemsByDefault[j]);
            }
        }
    };
    MousePosition.prototype._initProjectionUnits = function () {
        var projectionUnitsByDefault = {
            Geographical: [
                {
                    code: 'DEC',
                    label: 'degrs dcimaux',
                    format: this._displayDEC
                },
                {
                    code: 'DMS',
                    label: 'degrs sexagsimaux',
                    format: this._displayDMS
                },
                {
                    code: 'RAD',
                    label: 'radians',
                    format: this._displayRAD
                },
                {
                    code: 'GON',
                    label: 'grades',
                    format: this._displayGON
                }
            ],
            Metric: [
                {
                    code: 'M',
                    label: 'mtres',
                    format: this._displayMeter
                },
                {
                    code: 'KM',
                    label: 'kilomtres',
                    format: this._displayKMeter
                }
            ]
        };
        var units = this.options.units;
        for (var type in projectionUnitsByDefault) {
            if (projectionUnitsByDefault.hasOwnProperty(type)) {
                var found = false;
                for (var j = 0; j < projectionUnitsByDefault[type].length; j++) {
                    var obj = projectionUnitsByDefault[type][j];
                    for (var i = 0; i < units.length; i++) {
                        var unit = units[i];
                        if (obj.code === unit) {
                            found = true;
                            if (!this._projectionUnits[type]) {
                                this._projectionUnits[type] = [];
                            }
                            this._projectionUnits[type].push(obj);
                        }
                    }
                }
                if (!found) {
                    this._projectionUnits[type] = projectionUnitsByDefault[type];
                }
            }
        }
        if (typeof this._projectionUnits === 'object' && Object.keys(this._projectionUnits).length === 0) {
            this._projectionUnits = projectionUnitsByDefault;
        }
    };
    MousePosition.prototype._getCurrentProjectionInformation = function () {
        var systemInfo = [
            this._currentProjectionSystems.label,
            'en'
        ];
        var units = this._projectionUnits[this._currentProjectionType];
        for (var u = 0; u < units.length; ++u) {
            if (units[u].code === this._currentProjectionUnits) {
                systemInfo.push(units[u].label);
                break;
            }
        }
        return systemInfo.join(' ');
    };
    MousePosition.prototype._checkRightsManagement = function () {
        var rightManagement = RightManagement.check({
            key: this.options.apiKey,
            resources: ['SERVICE_CALCUL_ALTIMETRIQUE_RSC'],
            services: ['Elevation']
        });
        if (!rightManagement) {
            this._noRightManagement = true;
        }
        if (!this.options.apiKey) {
            this.options.apiKey = rightManagement.key;
        }
    };
    MousePosition.prototype._initContainer = function () {
        var container = this._createMainContainerElement();
        var inputShow = this._showMousePositionContainer = this._createShowMousePositionElement();
        container.appendChild(inputShow);
        var picto = this._createShowMousePositionPictoElement(this._isDesktop);
        container.appendChild(picto);
        var panel = this._createMousePositionPanelElement(this.options.displayAltitude, this.options.displayCoordinates, this.options.editCoordinates, this._currentProjectionUnits);
        var settings = this._createMousePositionSettingsElement();
        var systems = this._projectionSystemsContainer = this._createMousePositionSettingsSystemsElement(this._projectionSystems);
        var units = this._projectionUnitsContainer = this._createMousePositionSettingsUnitsElement(this._projectionUnits[this._currentProjectionType]);
        settings.appendChild(systems);
        settings.appendChild(units);
        panel.appendChild(settings);
        container.appendChild(panel);
        return container;
    };
    MousePosition.prototype._setElevationPanel = function (active) {
        var div = null;
        if (!active) {
            div = document.getElementById('GPmousePositionAltitude-' + this._uid);
            div.style.display = 'none';
        } else {
            if (this._noRightManagement) {
                div = document.getElementById('GPmousePositionAlt-' + this._uid);
                div.innerHTML = 'No rights!';
            } else {
                div = document.getElementById('GPmousePositionAltitude-' + this._uid);
                div.style.display = '';
            }
        }
    };
    MousePosition.prototype._setCoordinatesPanel = function (active) {
        var div = document.getElementById('GPmousePositionCoordinate-' + this._uid);
        if (!active) {
            div.style.display = 'none';
        } else {
            div.style.display = '';
        }
    };
    MousePosition.prototype._setSettingsPanel = function (active) {
        var divPicto = document.getElementById('GPshowMousePositionSettingsPicto-' + this._uid);
        var divPanel = document.getElementById('GPmousePositionSettings-' + this._uid);
        if (!active) {
            divPicto.style.display = 'none';
            divPanel.style.display = 'none';
        } else {
            divPicto.style.display = '';
            divPanel.style.display = '';
        }
    };
    MousePosition.prototype._setTypeUnitsPanel = function (type) {
        var container = this._projectionUnitsContainer;
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        var units = this._projectionUnits[type];
        for (var j = 0; j < units.length; j++) {
            var obj = units[j];
            var option = document.createElement('option');
            option.value = obj.code ? obj.code : j;
            option.text = obj.label || j;
            container.appendChild(option);
        }
        var projectionUnits = this._projectionUnits[type][0].code;
        if (this._currentProjectionUnits === 'DMS' || projectionUnits === 'DMS') {
            this._resetCoordinateElements(this.options.editCoordinates, type, projectionUnits);
            this._setEditMode(this.editing);
        }
        this._currentProjectionType = type;
        this._resetLabelElements(type);
        this._resetUnitElements(projectionUnits);
        this._currentProjectionUnits = projectionUnits;
    };
    MousePosition.prototype._displayDEC = function (olCoordinate) {
        var coordinate = {};
        coordinate.lat = olCoordinate[1].toFixed(6);
        coordinate.lng = olCoordinate[0].toFixed(6);
        coordinate.unit = '\xB0';
        return coordinate;
    };
    MousePosition.prototype._displayDMS = function (olCoordinate) {
        return {
            lng: MathUtils.decimalToDMS(olCoordinate[0], 'EO', 2),
            lat: MathUtils.decimalToDMS(olCoordinate[1], 'NS', 2),
            unit: 'DMS'
        };
    };
    MousePosition.prototype._displayRAD = function (olCoordinate) {
        var coordinate = {};
        var d = 0.017453292519943295;
        coordinate.lng = olCoordinate[0] * d;
        coordinate.lng = coordinate.lng.toFixed(8);
        coordinate.lat = olCoordinate[1] * d;
        coordinate.lat = coordinate.lat.toFixed(8);
        coordinate.unit = 'rad';
        return coordinate;
    };
    MousePosition.prototype._displayGON = function (olCoordinate) {
        var coordinate = {};
        var d = 1.1111111111111112;
        coordinate.lng = olCoordinate[0] * d;
        coordinate.lng = coordinate.lng.toFixed(8);
        coordinate.lat = olCoordinate[1] * d;
        coordinate.lat = coordinate.lat.toFixed(8);
        coordinate.unit = 'gon';
        return coordinate;
    };
    MousePosition.prototype._displayMeter = function (olCoordinate) {
        var coordinate = {};
        coordinate.x = olCoordinate[0].toFixed(2);
        coordinate.y = olCoordinate[1].toFixed(2);
        coordinate.unit = 'm';
        return coordinate;
    };
    MousePosition.prototype._displayKMeter = function (olCoordinate) {
        var coordinate = {};
        coordinate.x = (olCoordinate[0] / 1000).toFixed(2);
        coordinate.y = (olCoordinate[1] / 1000).toFixed(2);
        coordinate.unit = 'km';
        return coordinate;
    };
    MousePosition.prototype._setCoordinate = function (olCoordinate, crs) {
        var coordinate = {};
        var oSrs = this._currentProjectionSystems.crs;
        if (!oSrs) {
            console.log('ERROR : system crs not found');
            return;
        }
        olCoordinate = ol.proj.transform(olCoordinate, crs, oSrs);
        var type = this._currentProjectionSystems.type;
        var format = null;
        var units = this._projectionUnits[type];
        for (var i = 0; i < units.length; i++) {
            if (units[i].code === this._currentProjectionUnits) {
                format = units[i].format;
                break;
            }
        }
        if (!format || typeof format !== 'function') {
            console.log('WARNING : coordinates format function not found');
            return;
        } else {
            coordinate = format(olCoordinate);
        }
        if (!coordinate || Object.keys(coordinate).length === 0) {
            return;
        }
        this.GPdisplayCoords(coordinate);
    };
    MousePosition.prototype._setElevation = function (olCoordinate) {
        var delay = this.options.altitude.responseDelay;
        var noDataValue = this.options.altitude.noDataValue;
        var noDataValueTolerance = this.options.altitude.noDataValueTolerance;
        this.GPdisplayElevation(olCoordinate, delay, noDataValue, noDataValueTolerance);
    };
    MousePosition.prototype.onMoveStopped = function (olCoordinate, crs) {
        var oLatLng = ol.proj.transform(olCoordinate, crs, 'EPSG:4326');
        this._setElevation(oLatLng);
    };
    MousePosition.prototype.onMouseMove = function (e) {
        var self = this;
        var coordinate = e.coordinate;
        if (!e.map || !e.map.getView()) {
            return;
        }
        var crs = e.map.getView().getProjection();
        this._setCoordinate(coordinate, crs);
        clearTimeout(this._timer);
        this._timer = setTimeout(function () {
            self.onMoveStopped(coordinate, crs);
        }, this.options.altitude.triggerDelay);
    };
    MousePosition.prototype.onMapMove = function () {
        var self = this;
        var map = this.getMap();
        if (!map || !map.getView()) {
            return;
        }
        var view = map.getView();
        var coordinate = view.getCenter();
        var crs = view.getProjection();
        this._setCoordinate(coordinate, crs);
        clearTimeout(this._timer);
        this._timer = setTimeout(function () {
            self.onMoveStopped(coordinate, crs);
        }, this.options.altitude.triggerDelay);
    };
    MousePosition.prototype.onRequestAltitude = function (coordinate, callback) {
        if (!coordinate || Object.keys(coordinate).length === 0) {
            return;
        }
        if (!this.options.displayAltitude) {
            return;
        }
        if (this._noRightManagement) {
            console.log('[WARNING] contract key configuration has no rights to load geoportal elevation ');
            document.getElementById('GPmousePositionAlt-' + this._uid).innerHTML = 'No rights!';
            return;
        }
        var options = this.options.altitude.serviceOptions || {};
        var _protocol = options.protocol || 'XHR';
        var _timeout = options.timeOut || 0;
        if (_protocol === 'JSONP' && _timeout === 0) {
            _timeout = 15000;
        }
        var _zonly = true;
        var _positions = [{
                lon: coordinate[0],
                lat: coordinate[1]
            }];
        var _scope = this;
        var _rawResponse = options.rawResponse || false;
        var _onSuccess = null;
        var _onFailure = null;
        if (!_rawResponse) {
            _onSuccess = function (results) {
                if (results && Object.keys(results)) {
                    callback.call(this, results.elevations[0].z);
                }
            };
        } else {
            _onSuccess = function (results) {
                console.log('alti service raw response : ', results);
            };
        }
        _onFailure = function (error) {
            console.log('[getAltitude] ERROR : ' + error.message);
        };
        var _apiKey = options.apiKey || this.options.apiKey;
        Gp.Services.getAltitude({
            apiKey: _apiKey,
            protocol: _protocol,
            timeOut: _timeout,
            scope: _scope,
            rawResponse: _rawResponse,
            onSuccess: _onSuccess,
            onFailure: _onFailure,
            zonly: _zonly,
            positions: _positions
        });
    };
    MousePosition.prototype.onShowMousePositionClick = function () {
        var map = this.getMap();
        this.collapsed = this._showMousePositionContainer.checked;
        this.dispatchEvent('change:collapsed');
        if (this._showMousePositionContainer.checked) {
            if (this._isDesktop) {
                map.un('pointermove', this.onMouseMove, this);
            } else {
                map.un('moveend', this.onMapMove, this);
            }
        } else if (!this.editing) {
            if (this._isDesktop) {
                map.on('pointermove', this.onMouseMove, this);
            } else {
                map.on('moveend', this.onMapMove, this);
                this.onMapMove();
            }
        }
        this._setElevationPanel(this.options.displayAltitude);
        this._setCoordinatesPanel(this.options.displayCoordinates);
        if (!this.options.displayCoordinates) {
            this._setSettingsPanel(false);
        }
    };
    MousePosition.prototype.onMousePositionEditModeClick = function (editing) {
        if (!this.options.editCoordinates) {
            return;
        }
        if (this.editing === editing) {
            return;
        }
        this.editing = editing;
        this._setEditMode(this.editing);
        var map = this.getMap();
        if (this._isDesktop) {
            if (this.editing) {
                map.un('pointermove', this.onMouseMove, this);
            } else {
                map.on('pointermove', this.onMouseMove, this);
                this.onMapMove();
            }
        } else {
            if (this.editing) {
                map.un('moveend', this.onMapMove, this);
            } else {
                map.on('moveend', this.onMapMove, this);
                this.onMapMove();
            }
        }
        if (!this.editing && this._markerOverlay) {
            this._markerOverlay.setPosition(undefined);
        }
    };
    MousePosition.prototype.getCoordinate = function (coordType) {
        var inputDegrees = document.getElementById(this._addUID('GPmousePosition' + coordType + 'Degrees'));
        var degrees = inputDegrees.value;
        if (!degrees) {
            return null;
        }
        degrees = degrees.replace(',', '.');
        if (!MathUtils.isInteger(degrees)) {
            return null;
        }
        var result = MathUtils.toInteger(degrees);
        if (result < Number(inputDegrees.dataset.min) || result > Number(inputDegrees.dataset.max)) {
            return null;
        }
        var direction = document.getElementById(this._addUID('GPmousePosition' + coordType + 'Direction')).value;
        var inputMinutes = document.getElementById(this._addUID('GPmousePosition' + coordType + 'Minutes'));
        var minutes = inputMinutes.value;
        if (minutes) {
            minutes = minutes.replace(',', '.');
            if (MathUtils.isInteger(minutes)) {
                var mins = MathUtils.toInteger(minutes);
                if (mins >= Number(inputMinutes.dataset.min) && mins <= Number(inputMinutes.dataset.max)) {
                    result += mins / 60;
                }
            }
        }
        var inputSeconds = document.getElementById(this._addUID('GPmousePosition' + coordType + 'Seconds'));
        var seconds = inputSeconds.value;
        if (seconds) {
            seconds = seconds.replace(',', '.');
            var secs = MathUtils.toFloat(seconds);
            if (secs && secs >= Number(inputSeconds.dataset.min) && secs <= Number(inputSeconds.dataset.max)) {
                result += secs / 3600;
            }
        }
        if (direction === 'O' || direction === 'S') {
            result = -result;
        }
        return result;
    };
    MousePosition.prototype.locateDMSCoordinates = function () {
        var lonlat = [
            this.getCoordinate('Lon'),
            this.getCoordinate('Lat')
        ];
        if (lonlat[0] === null || lonlat[1] === null) {
            return;
        }
        var oSrs = this._currentProjectionSystems.crs;
        if (!oSrs) {
            console.log('ERROR : system crs not found');
            return;
        }
        var view = this.getMap().getView();
        var coordinate = ol.proj.transform(lonlat, oSrs, view.getProjection());
        view.setCenter(coordinate);
        if (this._markerOverlay && !this._hideMarker) {
            this._markerOverlay.setPosition(coordinate);
        }
    };
    MousePosition.prototype.locateCoordinates = function () {
        var lon = document.getElementById(this._addUID('GPmousePositionLon')).value;
        lon = lon.replace(',', '.');
        lon = MathUtils.toFloat(lon);
        if (lon === null) {
            return;
        }
        var lat = document.getElementById(this._addUID('GPmousePositionLat')).value;
        lat = lat.replace(',', '.');
        lat = MathUtils.toFloat(lat);
        if (lat === null) {
            return;
        }
        var oSrs = this._currentProjectionSystems.crs;
        if (!oSrs) {
            console.log('ERROR : system crs not found');
            return;
        }
        var xy;
        if (this._currentProjectionSystems.type === 'Geographical') {
            xy = [
                this.convert(lon),
                this.convert(lat)
            ];
        } else {
            xy = [
                this.convert(lat),
                this.convert(lon)
            ];
        }
        var xyWGS84 = ol.proj.transform(xy, this._currentProjectionSystems.crs, 'EPSG:4326');
        var geoBBox = this._currentProjectionSystems.geoBBox;
        if (geoBBox) {
            var extent = [
                geoBBox.left,
                geoBBox.bottom,
                geoBBox.right,
                geoBBox.top
            ];
            if (xyWGS84[0] < extent[0] || xyWGS84[0] > extent[2]) {
                return;
            }
            if (xyWGS84[1] < extent[1] || xyWGS84[1] > extent[3]) {
                return;
            }
        }
        var view = this.getMap().getView();
        var coordinate = ol.proj.transform(xy, oSrs, view.getProjection());
        view.setCenter(coordinate);
        if (this._markerOverlay && !this._hideMarker) {
            this._markerOverlay.setPosition(coordinate);
        }
    };
    MousePosition.prototype.onMousePositionEditModeLocateClick = function () {
        if (!this.options.editCoordinates) {
            return;
        }
        if (!this.editing) {
            this.onMousePositionEditModeClick(true);
            return;
        }
        if (this._currentProjectionUnits === 'DMS') {
            this.locateDMSCoordinates();
        } else {
            this.locateCoordinates();
        }
    };
    MousePosition.prototype.onMousePositionProjectionSystemChange = function (e) {
        var idx = e.target.selectedIndex;
        var value = e.target.options[idx].value;
        this._setCurrentSystem(value);
    };
    MousePosition.prototype._setCurrentSystem = function (systemCode) {
        var type = null;
        for (var i = 0; i < this._projectionSystems.length; ++i) {
            if (this._projectionSystems[i].code == systemCode) {
                type = this._projectionSystems[i].type;
                break;
            }
        }
        if (!type) {
            return;
        }
        this._currentProjectionSystems = this._projectionSystems[Number(systemCode)];
        if (type !== this._currentProjectionType) {
            this._setTypeUnitsPanel(type);
        }
        if (!this._isDesktop) {
            this.onMapMove();
        }
    };
    MousePosition.prototype.onMousePositionProjectionSystemMouseOver = function (e) {
        var map = this.getMap();
        if (!map || !map.getView()) {
            return;
        }
        var view = map.getView();
        var crs = view.getProjection();
        var mapExtent = view.calculateExtent(map.getSize());
        mapExtent = ol.proj.transformExtent(mapExtent, crs, 'EPSG:4326');
        var systemList = document.getElementById(this._addUID('GPmousePositionProjectionSystem'));
        systemList.innerHTML = '';
        for (var j = 0; j < this._projectionSystems.length; j++) {
            var proj = this._projectionSystems[j];
            var option = null;
            if (proj.geoBBox) {
                if (mapExtent[0] > proj.geoBBox.right || mapExtent[1] > proj.geoBBox.top || mapExtent[2] < proj.geoBBox.left || mapExtent[3] < proj.geoBBox.bottom) {
                    if (proj === this._currentProjectionSystems) {
                        option = document.createElement('option');
                        option.value = proj.code;
                        option.text = proj.label || j;
                        option.setAttribute('selected', 'selected');
                        option.setAttribute('disabled', 'disabled');
                        systemList.appendChild(option);
                    }
                    continue;
                }
            }
            var optionElement = document.createElement('option');
            optionElement.value = proj.code;
            optionElement.text = proj.label || j;
            if (proj === this._currentProjectionSystems) {
                optionElement.setAttribute('selected', 'selected');
            }
            systemList.appendChild(optionElement);
        }
    };
    MousePosition.prototype.onMousePositionProjectionUnitsChange = function (e) {
        var idx = e.target.selectedIndex;
        var value = e.target.options[idx].value;
        var oldProjectionUnits = this._currentProjectionUnits;
        this._currentProjectionUnits = value;
        this._resetLabelElements(this._currentProjectionType);
        this._resetUnitElements(this._currentProjectionUnits);
        if (oldProjectionUnits === 'DMS' || this._currentProjectionUnits === 'DMS') {
            this._resetCoordinateElements(this.options.editCoordinates, this._currentProjectionType, this._currentProjectionUnits);
            this._setEditMode(this.editing);
        }
        if (!this._isDesktop) {
            this.onMapMove();
        }
    };
    MousePosition.prototype.convert = function (value) {
        var result;
        if (this._currentProjectionUnits === 'M' || this._currentProjectionUnits === 'DEC') {
            result = value;
        } else if (this._currentProjectionUnits === 'KM') {
            result = value * 1000;
        } else if (this._currentProjectionUnits === 'RAD') {
            var rd = (180 / Math.PI).toFixed(20);
            result = (value * rd).toFixed(20);
        } else if (this._currentProjectionUnits === 'GON') {
            var d = (9 / 10).toFixed(20);
            result = (value * d).toFixed(20);
        }
        return result;
    };
    MousePosition.prototype.validateExtentCoordinate = function (coordType, value) {
        if ([
                'Lon',
                'Lat'
            ].indexOf(coordType) === -1) {
            return false;
        }
        var coord = value.replace(',', '.');
        coord = MathUtils.toFloat(coord);
        if (coord === null) {
            return false;
        }
        coord = this.convert(coord);
        var geoBBox = this._currentProjectionSystems.geoBBox;
        if (geoBBox === undefined) {
            return true;
        }
        var extent = [
            geoBBox.left,
            geoBBox.bottom,
            geoBBox.right,
            geoBBox.top
        ];
        extent = ol.proj.transformExtent(extent, 'EPSG:4326', this._currentProjectionSystems.crs);
        if (coordType === 'Lat' && (coord < extent[0] || coord > extent[2])) {
            return false;
        }
        if (coordType === 'Lon' && (coord < extent[1] || coord > extent[3])) {
            return false;
        }
        return true;
    };
    return MousePosition;
}(ol, proj4, {}, gp, Ol3Utils, Ol3ControlsUtilsMarkers, CommonUtilsCheckRightManagement, CommonUtilsSelectorID, CommonUtilsMathUtils, CommonControlsMousePositionDOM);
Ol3ControlsUtilsInteractions = function (ol, woodman, Utils) {
    var Interactions = {
        _extensions: [
            'Measures',
            'ElevationPath',
            'Drawing'
        ],
        _options: {
            current: null,
            clean: null
        },
        unset: function (map, options) {
            var opts = {};
            Utils.mergeParams(opts, this._options);
            Utils.mergeParams(opts, options);
            var interactions = map.getInteractions().getArray();
            for (var i = 0; i < interactions.length; i++) {
                if (interactions[i].getActive() && interactions[i] instanceof ol.interaction.Draw) {
                    var prop = interactions[i].getProperties();
                    var name = prop.name;
                    if (typeof name !== 'undefined' && this._extensions.indexOf(name) > -1) {
                        if (opts.current && opts.current === name) {
                            continue;
                        }
                        interactions[i].setActive(false);
                        var source = prop.source;
                        if (typeof source !== 'undefined' && source instanceof ol.control.Control) {
                            for (var action in opts) {
                                if (opts.hasOwnProperty(action)) {
                                    if (action === 'current') {
                                        continue;
                                    }
                                    if (typeof source[action] === 'function') {
                                        var args = Array.isArray(opts[action]) ? opts[action] : [opts[action]];
                                        source[action].apply(source, args);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    return Interactions;
}(ol, {}, Ol3Utils);
CommonControlsDrawingDOM = function () {
    var DrawingDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPdrawing');
            container.className = 'GPwidget';
            return container;
        },
        _createShowDrawingElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowDrawing');
            input.className = 'GPshowDrawing';
            input.type = 'checkbox';
            return input;
        },
        _createShowDrawingPictoElement: function () {
            var self = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowDrawingPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowDrawing');
            label.title = this.options.labels.control;
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    self.onShowDrawingClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    self.onShowDrawingClick(e);
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowDrawingOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createDrawingPanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPdrawingPanel');
            div.className = 'GPpanel';
            div.appendChild(this._createDrawingPanelHeaderElement());
            this.dtOptions = {};
            if (this.options.tools.points) {
                this.dtOptions.points = {
                    label: this.options.labels.points,
                    active: false,
                    panel: 'draw',
                    id: 'point'
                };
            }
            if (this.options.tools.lines) {
                this.dtOptions.lines = {
                    label: this.options.labels.lines,
                    active: false,
                    panel: 'draw',
                    id: 'line'
                };
            }
            if (this.options.tools.polygons) {
                this.dtOptions.polygons = {
                    label: this.options.labels.polygons,
                    active: false,
                    panel: 'draw',
                    id: 'polygon'
                };
            }
            if (this.options.tools.text) {
                this.dtOptions.text = {
                    label: this.options.labels.text,
                    active: false,
                    panel: 'draw',
                    id: 'text'
                };
            }
            if (this.options.tools.edit) {
                this.dtOptions.edit = {
                    label: this.options.labels.edit,
                    active: false,
                    panel: 'edit',
                    id: 'edit'
                };
            }
            if (this.options.tools.display) {
                this.dtOptions.display = {
                    label: this.options.labels.display,
                    active: false,
                    panel: 'edit',
                    id: 'display'
                };
            }
            if (this.options.tools.tooltip) {
                this.dtOptions.tooltip = {
                    label: this.options.labels.tooltip,
                    active: false,
                    panel: 'edit',
                    id: 'tooltip'
                };
            }
            if (this.options.tools.remove) {
                this.dtOptions.remove = {
                    label: this.options.labels.remove,
                    active: false,
                    panel: 'edit',
                    id: 'remove'
                };
            }
            if (this.dtOptions.points || this.dtOptions.lines || this.dtOptions.polygons || this.dtOptions.text) {
                div.appendChild(this._createDrawingToolSection(this.options.labels.creatingTools, 'draw'));
            }
            if (this.dtOptions.edit || this.dtOptions.display || this.dtOptions.tooltip || this.dtOptions.remove) {
                div.appendChild(this._createDrawingToolSection(this.options.labels.editingTools, 'edit'));
            }
            if (this.options.tools.export) {
                div.appendChild(this._createSavingSection(this.options.labels.export, this.options.labels.exportTitle));
            }
            return div;
        },
        _createDrawingPanelHeaderElement: function () {
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var divTitle = document.createElement('div');
            divTitle.className = 'GPpanelTitle';
            divTitle.innerHTML = this.options.controlLabel || 'Annoter la carte';
            container.appendChild(divTitle);
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GPdrawingPanelClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer le panneau';
            var dtObj = this;
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(dtObj._addUID('GPshowDrawingPicto')).click();
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(dtObj._addUID('GPshowDrawingPicto')).click();
                });
            }
            container.appendChild(divClose);
            return container;
        },
        _createDrawingToolSection: function (sectionLabel, panelType) {
            var container = document.createElement('div');
            container.className = 'drawing-tool-section';
            var p = document.createElement('p');
            p.className = 'drawing-tool-section-title';
            p.innerHTML = sectionLabel;
            container.appendChild(p);
            var ul = document.createElement('ul');
            ul.className = 'drawing-tools-flex-display';
            var context = this;
            function liClickHandler(e) {
                context._handleDOMToolClick(e, this.id, context);
                context._handleToolClick(e, this.id, context);
            }
            for (var type in this.dtOptions) {
                if (this.dtOptions[type].panel != panelType) {
                    continue;
                }
                var li = document.createElement('li');
                li.className = 'drawing-tool';
                li.id = this._addUID('drawing-tool-' + this.dtOptions[type].id);
                li.title = this.dtOptions[type].label;
                li.addEventListener('click', liClickHandler);
                ul.appendChild(li);
            }
            container.appendChild(ul);
            return container;
        },
        _createSavingSection: function (buttonLabel, buttonTitle) {
            var container = document.createElement('div');
            container.className = 'drawing-tool-section drawing-tools-flex-display';
            var button = document.createElement('button');
            button.title = buttonTitle;
            button.className = 'tool-form-submit drawing-button';
            button.id = this._addUID('drawing-export');
            button.type = 'button';
            button.textContent = buttonLabel;
            var context = this;
            button.onclick = function () {
                context.onExportFeatureClick();
            };
            container.appendChild(button);
            return container;
        },
        rgbaToHex: function (rgba) {
            function hex(number) {
                if (number > 255) {
                    throw '\'' + number + '\'\' is greater than 255(0xff);';
                }
                var str = Number(number).toString(16);
                return ('0' + str).slice(-2);
            }
            var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
            var parsed = regex.exec(rgba);
            if (!parsed) {
                throw 'Invalid format: ' + rgba;
            }
            var red = parsed[1];
            var green = parsed[2];
            var blue = parsed[3];
            var alpha = parsed[4];
            var elems = [
                hex(red),
                hex(green),
                hex(blue)
            ];
            var result = {};
            result.hex = '#' + elems.join('');
            if (alpha) {
                result.opacity = parseFloat(alpha);
            }
            return result;
        },
        hexToRgba: function (hex, opacity) {
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            rgb = rgb ? {
                r: parseInt(rgb[1], 16),
                g: parseInt(rgb[2], 16),
                b: parseInt(rgb[3], 16)
            } : null;
            var result = rgb ? 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + opacity + ')' : null;
            return result;
        },
        _createMarkersChooser: function (options) {
            var li = document.createElement('li');
            li.className = options.className;
            for (var i = 0; i < this.options.markersList.length; i++) {
                var inputElem = document.createElement('input');
                inputElem.type = 'radio';
                inputElem.name = 'marker';
                inputElem.id = this._addUID('marker-' + i);
                inputElem.value = this.options.markersList[i].src;
                inputElem.className = 'marker-input-radio';
                if (options.defaultValue == inputElem.value) {
                    inputElem.checked = true;
                }
                li.appendChild(inputElem);
                var labelElem = document.createElement('label');
                labelElem.className = 'marker-label';
                labelElem.setAttribute('for', inputElem.id);
                var imgElem = document.createElement('img');
                imgElem.src = inputElem.value;
                labelElem.appendChild(imgElem);
                li.appendChild(labelElem);
            }
            return li;
        },
        _createStylingElement: function (options) {
            var li = document.createElement('li');
            li.className = options.className;
            var textNode = document.createTextNode(options.label);
            li.appendChild(textNode);
            var inputElem = document.createElement('input');
            try {
                inputElem.type = options.type;
            } catch (e) {
                inputElem.type = 'text';
            }
            inputElem.id = options.id;
            inputElem.value = options.defaultValue;
            if (options.title) {
                inputElem.title = options.title;
            }
            if (options.min !== undefined) {
                inputElem.min = options.min;
            }
            if (options.max !== undefined) {
                inputElem.max = options.max;
            }
            if (options.step !== undefined) {
                inputElem.step = options.step;
            }
            li.appendChild(inputElem);
            return li;
        },
        _createStylingDiv: function (options) {
            var div = document.createElement('div');
            div.className = 'gp-styling-div';
            var ul = document.createElement('ul');
            var li = null;
            switch (options.geomType.toLowerCase()) {
            case 'point':
                li = this._createMarkersChooser({
                    className: 'gp-styling-option',
                    defaultValue: options.initValues.markerSrc
                });
                ul.appendChild(li);
                break;
            case 'text':
                li = this._createStylingElement({
                    type: 'color',
                    className: 'gp-styling-option',
                    label: this.options.labels.fillColor,
                    id: this._addUID('fillColor'),
                    defaultValue: options.initValues.fillColor
                });
                ul.appendChild(li);
                li = this._createStylingElement({
                    type: 'color',
                    className: 'gp-styling-option',
                    label: this.options.labels.strokeColor,
                    id: this._addUID('strokeColor'),
                    defaultValue: options.initValues.strokeColor
                });
                ul.appendChild(li);
                break;
            case 'line':
                li = this._createStylingElement({
                    type: 'color',
                    className: 'gp-styling-option',
                    label: this.options.labels.strokeColor,
                    id: this._addUID('strokeColor'),
                    defaultValue: options.initValues.strokeColor
                });
                ul.appendChild(li);
                li = this._createStylingElement({
                    type: 'range',
                    className: 'gp-styling-option',
                    label: this.options.labels.strokeWidth,
                    title: '1  10 pixels',
                    id: this._addUID('strokeWidth'),
                    min: 1,
                    max: 10,
                    step: 1,
                    defaultValue: options.initValues.strokeWidth
                });
                ul.appendChild(li);
                break;
            case 'polygon':
                li = this._createStylingElement({
                    type: 'color',
                    className: 'gp-styling-option',
                    label: this.options.labels.strokeColor,
                    id: this._addUID('strokeColor'),
                    defaultValue: options.initValues.strokeColor
                });
                ul.appendChild(li);
                li = this._createStylingElement({
                    type: 'range',
                    className: 'gp-styling-option',
                    label: this.options.labels.strokeWidth,
                    title: '1  10 pixels',
                    id: this._addUID('strokeWidth'),
                    min: 1,
                    max: 10,
                    step: 1,
                    defaultValue: options.initValues.strokeWidth
                });
                ul.appendChild(li);
                li = this._createStylingElement({
                    type: 'color',
                    className: 'gp-styling-option',
                    label: this.options.labels.fillColor,
                    id: this._addUID('fillColor'),
                    defaultValue: options.initValues.fillColor
                });
                ul.appendChild(li);
                li = this._createStylingElement({
                    type: 'range',
                    className: 'gp-styling-option',
                    label: this.options.labels.fillOpacity,
                    title: '0 (transparent)  100% (opaque)',
                    id: this._addUID('fillOpacity'),
                    min: 0,
                    max: 10,
                    step: 1,
                    defaultValue: options.initValues.fillOpacity * 10
                });
                ul.appendChild(li);
                break;
            default:
                console.log('Unhandled geometry type for styling.');
            }
            div.appendChild(ul);
            var applyButton = document.createElement('input');
            applyButton.type = 'button';
            applyButton.className = 'gp-styling-button';
            applyButton.value = this.options.labels.applyToObject;
            applyButton.onclick = function () {
                options.applyFunc.call(this, 'apply');
            };
            div.appendChild(applyButton);
            var setDefaultButton = document.createElement('input');
            setDefaultButton.type = 'button';
            setDefaultButton.value = this.options.labels.setAsDefault;
            setDefaultButton.className = 'gp-styling-button';
            setDefaultButton.onclick = function () {
                options.applyFunc.call(this, 'default');
            };
            div.appendChild(setDefaultButton);
            var cancelButton = document.createElement('input');
            cancelButton.type = 'button';
            cancelButton.className = 'gp-styling-button closer';
            cancelButton.onclick = function () {
                options.applyFunc.call(this, 'cancel');
            };
            div.appendChild(cancelButton);
            return div;
        },
        _createLabelDiv: function (options) {
            var popup = document.createElement('div');
            popup.className = 'gp-label-div';
            var inputLabel = null;
            if (options.geomType == 'Text') {
                inputLabel = document.createElement('input');
                inputLabel.type = 'text';
                inputLabel.className = 'gp-input-label-style';
            } else {
                inputLabel = document.createElement('textArea');
                inputLabel.rows = 2;
                inputLabel.cols = 40;
                inputLabel.className = 'gp-textarea-att-label-style';
            }
            if (options.text) {
                inputLabel.value = options.text;
            }
            inputLabel.autocomplete = 'off';
            inputLabel.placeholder = options.placeholder;
            inputLabel.id = options.inputId;
            popup.appendChild(inputLabel);
            inputLabel.onblur = function () {
                options.applyFunc.call(this, inputLabel.value, true);
            };
            inputLabel.onkeyup = function (evtk) {
                if (options.geomType == 'Text' && evtk.keyCode == 13) {
                    options.applyFunc.call(this, inputLabel.value, true);
                }
                if (evtk.keyCode == 27) {
                    options.applyFunc.call(this, inputLabel.value, false);
                }
            };
            if (options.geomType != 'Text') {
                var applyButton = document.createElement('input');
                applyButton.type = 'button';
                applyButton.className = 'gp-styling-button';
                applyButton.value = this.options.labels.saveDescription;
                applyButton.onclick = function () {
                    options.applyFunc.call(this, inputLabel.value, true);
                };
                popup.appendChild(applyButton);
                var cancelButton = document.createElement('input');
                cancelButton.type = 'button';
                cancelButton.className = 'gp-styling-button closer';
                cancelButton.onclick = function () {
                    options.applyFunc.call(this, inputLabel.value, false);
                };
                popup.appendChild(cancelButton);
            }
            return popup;
        },
        _handleDOMToolClick: function (e, toolId, context) {
            for (var availType in context.dtOptions) {
                var availToolId = context._addUID('drawing-tool-' + context.dtOptions[availType].id);
                var li = document.getElementById(availToolId);
                if (availToolId != toolId) {
                    li.className = 'drawing-tool';
                    context.dtOptions[availType].active = false;
                    continue;
                }
                if (context.dtOptions[availType].active) {
                    li.className = 'drawing-tool';
                } else {
                    li.className = 'drawing-tool drawing-tool-active';
                }
                context.dtOptions[availType].active = !context.dtOptions[availType].active;
            }
        }
    };
    return DrawingDOM;
}();
Ol3ControlsDrawing = function (woodman, ol, Gp, SelectorID, Interactions, DrawingDOM, Utils, KMLExtended) {
    function Drawing(options) {
        options = options || {};
        if (!(this instanceof Drawing)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this._initialize(options);
        var container = this._initContainer();
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(Drawing, ol.control.Control);
    Drawing.DefaultTools = {
        points: true,
        lines: true,
        polygons: true,
        text: true,
        remove: true,
        display: true,
        tooltip: true,
        edit: true,
        export: true
    };
    Drawing.DefaultLabels = {
        control: 'Annoter la carte',
        creatingTools: 'Outils de cration',
        points: 'Placer des points',
        lines: 'Dessiner des lignes',
        polygons: 'Dessiner des polygones',
        text: 'Ecrire sur la carte',
        editingTools: 'Outils d\'dition',
        edit: 'Editer les tracs',
        display: 'Modifier l\'apparence des objets',
        tooltip: 'Modifier les textes / infos-bulles',
        remove: 'Supprimer des objets',
        export: 'Exporter',
        exportTitle: 'Exporter en KML',
        applyToObject: 'Appliquer  l\'objet',
        saveDescription: 'Enregistrer',
        setAsDefault: 'Dfinir par dfaut',
        strokeColor: 'Couleur du trait : ',
        strokeWidth: 'Epaisseur du trait : ',
        fillColor: 'Couleur de remplissage : ',
        fillOpacity: 'Opacit du remplissage : '
    };
    Drawing.DefaultStyles = {
        textFillColor: '#000000',
        textStrokeColor: '#FFFFFF',
        textIcon1x1: {
            src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=',
            anchor: [
                0,
                0
            ]
        },
        polyFillColor: '#ffffff',
        polyFillOpacity: 0.4,
        polyStrokeColor: '#ffcc33',
        polyStrokeWidth: 4,
        strokeColor: '#ffcc33',
        strokeWidth: 4
    };
    Drawing.DefaultCursorStyle = {
        radius: 6,
        strokeColor: '#FFF',
        strokeWidth: 1,
        fillColor: 'rgba(0, 153, 255, 1)'
    };
    Drawing.prototype = Object.create(ol.control.Control.prototype, {});
    Drawing.prototype.assign = function (source) {
        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                this[prop] = source[prop];
            }
        }
    };
    Drawing.prototype.assign(DrawingDOM);
    Drawing.prototype.constructor = Drawing;
    Drawing.prototype.setMap = function (map) {
        ol.control.Control.prototype.setMap.call(this, map);
        if (this.getMap() && this.eventKey) {
            ol.Observable.unByKey(this.eventKey);
        }
        if (map == null) {
            return;
        }
        if (!this.collapsed) {
            var inputShow = document.getElementById(this._addUID('GPshowDrawing'));
            inputShow.checked = 'checked';
        }
        if (this.layer) {
            this.setLayer(this.layer);
        }
        this.eventKey = this.getMap().getLayers().on('remove', function (evtRm) {
            if (evtRm.element == this.layer) {
                this.layer = null;
                if (this.interaction) {
                    this.getMap().removeInteraction(this.interaction);
                    this.interaction = null;
                }
            }
        }, this);
    };
    Drawing.prototype.exportFeatures = function () {
        var result = null;
        if (ol.control.Control.prototype.getMap.call(this) == null) {
            console.log('Impossible to export : control isn\'t attached to any map.');
            return result;
        }
        if (!this.layer) {
            console.log('Impossible to export : no layer is hosting features.');
            return result;
        }
        if (!this.layer.getSource() || !this.layer.getSource().getFeatures() || !this.layer.getSource().getFeatures().length) {
            console.log('Impossible to export : no features found.');
            return result;
        }
        var featProj = this.layer.getSource().getProjection();
        featProj = featProj || this.getMap().getView().getProjection();
        var kmlFormat = new KMLExtended({ writeStyles: true });
        result = kmlFormat.writeFeatures(this.layer.getSource().getFeatures(), {
            dataProjection: 'EPSG:4326',
            featureProjection: featProj
        });
        return result;
    };
    Drawing.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] Drawing:setCollapsed - missing collapsed parameter');
            return;
        }
        if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
            return;
        }
        this.onShowDrawingClick();
        this._showDrawingContainer.checked = !collapsed;
    };
    Drawing.prototype.setExportName = function (name) {
        this._exportName = name;
    };
    Drawing.prototype.getExportName = function () {
        return this._exportName;
    };
    Drawing.prototype._getsMarkersOptionsFromSrc = function (src) {
        var markerOptions = null;
        for (var i = 0; i < this.options.markersList.length; i++) {
            if (this.options.markersList[i].src == src) {
                markerOptions = this.options.markersList[i];
                return markerOptions;
            }
        }
        return markerOptions;
    };
    Drawing.prototype._getIconStyleOptions = function (markerElement) {
        var iconOptions = {};
        Object.keys(markerElement).forEach(function (key) {
            switch (key) {
            case 'src':
            case 'size':
            case 'anchor':
            case 'anchorOrigin':
            case 'anchorXUnits':
            case 'anchorYUnits':
                iconOptions[key] = markerElement[key];
                break;
            }
        }, this);
        return iconOptions;
    };
    Drawing.prototype._initialize = function (options) {
        this._uid = SelectorID.generate();
        this._exportName = 'Croquis';
        this._exportFormat = '.kml';
        this.options = options || {};
        if (!this.options.tools) {
            this.options.tools = {};
        }
        Object.keys(Drawing.DefaultTools).forEach(function (key) {
            if (!this.options.tools.hasOwnProperty(key)) {
                this.options.tools[key] = Drawing.DefaultTools[key];
            }
        }, this);
        if (!this.options.cursorStyle) {
            this.options.cursorStyle = {};
        }
        Object.keys(Drawing.DefaultCursorStyle).forEach(function (key) {
            if (!this.options.cursorStyle.hasOwnProperty(key)) {
                this.options.cursorStyle[key] = Drawing.DefaultCursorStyle[key];
            }
        }, this);
        this.options.collapsed = options.collapsed !== undefined ? options.collapsed : true;
        this.collapsed = this.options.collapsed;
        this.options.markersList = options.markersList || [
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARfSURBVFiF3ZhfbBRVGMV/d2Z3212tbSkCbuNaqzaRiL6QyAMPjSFoYqgx4oOiRmMFUzQG479o2lQ0QXk1EhYFgmlD2mIRkYhRwqLEaA2GiKWV7rZLQ0sLwbZId7t/Zq4PFK1125m5s/vCedz7nXO+M9/N3jsD1xFEvgXlTkrI8hBQBywFbgEqgEvAMHAayZcYHBYbuZJP77yFkdsoR+ct4GXAb4OSQPARXj4QzzGejx7yEkZuZy2CMLBAgf4nkhfEi3S67UNzQ5YSIXfQhKAdtSAACxDsk2EapXT3cF2FYQdNSN7F/YQFsJkw77gVUcL01mp3o5EDJoK1Yj37VchKjcjdlJEmhvrWmg9jGNwhGhhzSlTbZmnepjBBAMrReF2F6Hgy0+fIKPb+flWRIMtip+eQ88lcPRCtg3gCCVZ3RqhPDbJepqlPDbJ6XwSvP2nDJYCXB522prLN6iwrPIEETw33U/VoLZovBPjQfCGqHqtl3XDUZiBrn1lQCXO3ZcUDLV34Su/JueYrW0btnp8tNSRLnTamEiZoWRF6uHre9dseuT0vPrOgEqbCWtW3xNX6VSy02c+/sk4JwF+WFWZ6xGL9vA2fyzb7+QcqYUYtKwYP9s+7PrA/bsNn/geSA87DSLosa44+fT/p8VM511Jjp4g8u8KGk7XPLKhM5qhlRSbppzV4JwMdEcz0WSCNmT5LrC1CS/AujKliSw1BxGljzm8AH3MjHs4BpU65DjCBn0rxDJNOSI4nM33F2O2U58yEnU6DgOpF02AzcEGJa40LZHlfhagUZvp6vkmFawObVK7/4PLFSoZpBZ50ozEThsne6i2hjZqmFRVJ6U8JUeSVUmQNzQvg0c1MVtNMIUTSl0pNLhsaGu8A4xrfbZhS4CRQ5SoFcCWtja/5NBg+N+GZsu0vhSEkcY8mf+iNx+OuX3llmJVABNCVNUA2fl3xWdvJkriqRBb2uPugAYgNHEey1Y3Gt3/ccNxFEAChm2al6zAAjNAEWF/rc1Ev6+ffOLTwmBt7E0xD02J5CSOayQLrsHMJnYGMITJvHrr588mUMKyr54CUaaHrnfF4fCQ/kwHEBmLAa044rb+WHP4xXnxJ0VJK6CkyjO2xWOx3KMSH8zDtwONWdb2jvt41u4JtChZJKeVveDwnYrHYfw5uj4KYFRpSWbGqyCPL5ypIpMTkKwcWfWVXUEqRRcio1LTuUCjUE4lEsrnq8j4ZgKEP9bpgmfHFHPpyy3fle3f9Uto3n4aUIqNhDghN6zZ1vTcajaasfAsSBmBwq7f11tLM/24Hx2L+n+rbF38zBy2JEP0anPEGAj3d3d1pJ56F2GYAGInM82M+bWW53wxd++3ipH7x1QMLj8ysk5BAyj6Ppp2+d/nyaEdHh/I/W8EmA3Ci2b/iviVT3+tCerMmxkudiz450hcYBSYQIqrDmScGBvqawSxkH3lDV2Pxe6ltItnWcFNLTXX1qpqamkoK/BCvC/wNB+l5MdQKNHsAAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS7SURBVFiF3VhNTFxVFP7OfTNvOjMtM9AoJSSYEEVMCv6kJi5NoCa1TRqNxDTaFhcWNSmxaaxNQ0w3mqgLdGeRhKFYXVC7qDU2BhVt/YdqEQRhRgYTKD8VZqAMzM+7xwVCcIR58+6b2fRb3nO+853v3fvuu+8CtxEo1wX5pTu2IpasBfEeSFSCUAygCMAsgEkAQyD6DClXF3VMLeZSO2dmuN7vB+MYiBsAbDEn8BIIZ6BrzdQyF81FDzkxw8/594P5HQCFCvQ5QDRSYO4Tu30IO2QGiA/5XgVzAGpGsMKTZ/mw7wTbfLi2yFzvOwngpJ0aaXidAtG3VcnKZv5dWgE7Nf5fFBJCHqK2hUsqdKVG+EihDwn5K9SXViZEAHqAApGIVaLaO5Pg48iPEQDwg2WjCtHyzKx8RxJBZLP9qoJ5CdJ9t9XvkPWZiSVrkY0R3b2MxnM9aJ2Ooi3iRut0FEc/6IHuiZtyidwQ8RqrrVk3Q7zHNEd3L6N5eAYP7q2BppcB0KHpZXhoXw2aB6eyM8SPW23NuhnGvaY5L7T2w7Nt54Yxj68KDS19WSiZ66RBZQPYYZpRvfuejPH7H8scX0FJlv2sQcVMkWmGpmc2bBbPVicNKsvslmmOkZg0id/IQmkhy47WoLABYNo05/rnIxnjv1wOmtbgLHTSoDIz10xzzhypQiz624axWLQPLQ3V5kLUa7U1la35G9OcRMyFY/cV49qlLhiJMQAJGIkx9FzswsuVO5BccpnryKuWW7NK4IPFXmjLgwAKrHItYB66t5JaJmJWSJZnhjqmFiFxzirPIjqsGgFUD5qC3gRjRolrBsYMQEr/NEpmKBCJgHBKhWteHKdUjv8rVBvgw773QaizU2M9DMb58q98rwghXC5md5zI5WSmlCGcAODQZDIlhCSiJT0eX6waH490AsYq356ZZ4oK4DSuAihT4UuGYIaQILGQ4vknen2BibhYzlqfySBG2CH4ylA4HLb9y8v1BY8A9CkAzVwcZDA0BgkG0+oFBjP49Ij3o48n9b9U20gB7bZuZwCAAvM/gPndTDmSIZKS9CRDNwCHBIv1NzFdfzu/t2EEAEiTstS2GQDA2PwbAHrSh9ebSDewihtxMdn0h/dbO/ISkIYQoZyYoW6kYOD59YdQg8mRYjgleFONpKRk07D34qJBxmY5pmBOkKZdCIfDk7mZGQDUER0FUROwaoQdZpd6H07oXT/OOWYVJZmBQZdhvBcKhfqBfFyc1xcEEpKeNjMytOgYfqp32wUFiSVm7oPD0RsKhf5zsnYoFMsMyccTUtvtFHL7ZimxFC2eGPJezrYkM6VAHGQhBsrKyga7u7tTG+XlfGYAIFxXuLfEzZ288fvCb4U858+Ou0KZajBTUkCOkhADUtOGgsGg6SVIXswAQKiuqK3UbRxIH78yq//8Yr/3i01oSyD6UwDDTo9ncGBgIGFFM29mRh/FFm+J/3qBk+9aHbsZFzf39WwN3DK0tWXCQAzMIw4hfq/etSvY2dmpvLPlzQwA/PTk9od3eowvhWCnZEodHfC2fz3rnAEQBVFQA4YPjI6OnAZkPvvIGb7bX/Ta/LP+SEftne0V5eW1FRUVpcjzQ7wt8A+9at5zXMB2DQAAAABJRU5ErkJggg==',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAP0SURBVFiF3ZnLbxtVFIe/e8eOPU5DapI2whEWyiILJGDTBQuWSGTTSkVlQRGs2MGSh4RoQWLB4x/gpVIViNokJUV0U4RQXKgQr0ookCYkdjONSJtQJTGltjO2Zw6LJlEbkszLTgQ/6Ww859xzPt97556Zgf+RVKMHFGgD+oADwP3APUAHsABcBS4BXwDnFNxsdP6GSCAt8LZAWUB8WEngLYHdO137HRI4JLDgE2K9LQg8vtMMCCiBowJuSJBVcwWOSBOWfRCY1yJCrLdXdwrkUANmZL05Age3G2R3hD3iZYsC6TB16ZA8rwB3h4z1Uhp4MUxg4A23co7MA2aYhD5VBrqCnkNhZqYPPyCpVJnh4Ry2PYNIFdue4fTpHKZZ8ZEjBTwWorZgEvjEc92nUiUpFn+VjbS0NCqm6edgPbEdMD97FjI8PLIhyKoGB0d8wPy0HTBXPQux7Stbwti25QNmNmhtYW4ANtCytZNUPXxslEp4pKoq8PK5Q2FuAH97elSrcx7Xr/nIc8NnPWsKAzPv6XH27OUtr585Y/nIs/Uf0ggJHPdc76ZZlqWl0Q33y+LiqCSTFR975th2wDzjqy0xzbIMDo6IbVsiYottW3Lq1IhPEBF4ejtgdgkUm9SXrVpRoDVobYH3zEqLcTxoXEAdU1Bqco5bkluPyPNNmpV5Cdk1RwE63CSYw2FrivSYKtBPhOTr5cDJnmz2Oa11IiFi2kol4iKq7ug4QMxwa3WtXaVUpcW2Sw/MzhaHwFmNjwrTDvwC3BeJAripdXF/JvP+H7HYsu/8ohwlWDEt305YlhX5BYLAI0AOMCKMIUc6Oj4eaGuzwg5RhxNhnzTXpOAC8E6UMb5qbb0QAQRAGa7bHRlmRUeBH8IEzhnGtZc6O89HSe6C62hdaAiMgjrwFH6a0NtUU6r28p49n5WUcry9N5FIVRnGsGVZc42aGRQUgBeCxPS3tZ37LplcCJlSBMYTjvNeoVD4baWGxkpgEHjCy2+ipWVifyYzECJFRURGicUuFgqFP2+/0AyYTlupyYTIpqd4WanSwe7udy/HYr5aFhFVR0letB7LZrPjuVyuvpFfU97tzhrGgYzjfL7J+PJmOn3yo/b2qa3GEFE1jTuttB5zDWMin8/bXnmb9qJ6Jh7vv7dW+1d3cN40v3+2q+vLTcIqKHVZw2Q8lRofGxurBsnZNJhpSLZr/XvadbOrv103jOt9mcwHNwxjbZkIlBGZiml96cF9+/JDQ0Oh72xN/YRw0TQffmh5+RtDJF4H5/m9ez/8OpWaB/5CqbwBk09OT0+9Dm4z62iYfkwm37CVqgzsuuvT3p6eR3t7e7vZye8w/xX9A0ynxee2hlfFAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASKSURBVFiF3ZhdbBRVHMV/9+5uPwikFExEiCtWbSKCCEsCiU1EJIEXeMIHxZgYPzBUYzB+RUPlwwTl1UhYFIiGhrQVFCMRAoQFidGaEgIuVLrbLgSkhWBb2N3uzs7M3weBILadnZndF87j3P8553/m3ty5c+Eugiq1oDy5dRw5czGKpQjTgPuAicBV4C+E02j5gSFrn4o3pkvpXbIwMmNTLaHAByjeBKqLoGRBfY4V+lSdeGmgFD2UJIzM2bwMUVFgggf634i8qo6/vttvH9oPWRAlkS1NiGrFWxCACSj1rUSiqwXx9XJ9hWH2liaQtfifYQWsIxL9yK+IJ9xYWq1+NIaBjahl6vhr33khe2pEntg+noCRxPvSGg39GNZD6tTKfrdEb8ssaHxIeYIA1FKh3/VCdD0zN74jfRS3/XpFlpx5r9vvUNC1Tc5cTDFBqoJZ1i9opyFcR0hPomD3cvR8N02H55IvOPHHUB1aBOxy05r7ZaZY6lhTFcyy74Vunp46n5AOAxWEdJhnps5n//IElaEhRw0pwucOuA8jPOpYs35BO2Mrpg87NrZiBmvn/+aooWSa29a8bACTHSsawnWjjj/1wIOOGlKEzx3wEmaiY0VIT/I1/i/uKbKfW/AS5rpjRcHudRi/VITPtSL7uQUvYfocK46e7x51PNaTKsJn9BcyDDyEkXbHkqbDc0kbp4Ydu54/xcexec42OPvcAS9b82HHmnyhmkXND3OwJ0bBPgcYFOxzHEjGWLTjEQyryrkzFXPfmkvIY1+MpSp4Aahxy3WBQQrVU9TJFzNuSK5nRsUb0yi2u+W5dNnqNgh4PWjmrXXAZU9cZ1zGMD/xQvQU5sbxfJUXbhFY5eX4Dz5/rCQSbQae96NxOyzsnXVXNjRqrSsrRarzSlWGRJRp6RBAMGAXTK1tpdRQRT6fmXHx4kAbWDf5fsPUACeAqb5SAGkxBpYMfBW9YA/mivYXZSkhFdTyc2cqlfL9yyuRaAMQAwKeNUBWZ376piV3IuVVwoSv/V1oAKpjxTGQjX40Dhh/HvMRBEAFbHuK7zAAjOttApyP9cOg17526b303iN+7G2wLa2TJQmjYmtMYDnFHEJvQwGr8H5m766M5C3n6hEgYqhAYHcqleotzcwAqmNFEuEdN5zm3PF9vxipqx4tReBMpWVtTiaTf0A5Ls4j0VbgWae6TrOvc8ngthYPFkMicpJgsCOZTP7nw+3+QsMZK/NiLqxUwdqRCrJ2PvNWes+PxQqKKBMlCdE6Hg6Hz8RiMXO4upLPDMDFWZ8tnazHfz+CvmzIHNy5Lfd712gaIqqgsXuU1nE7EOhMJBJ5J9+yhAE4P2tj8/265n+ngyNG8tdXrrfuH4E2hFLdGs6Gxow5E4/HDTee5VhmAFj92Zf7J1Q01Krq8M1nV+zMlbfTew7dXieQRaQrqPXpx+fMSbS1tXne2co2MwAds9fMm6kmHQ2gQia29ca13V8eKnT1AYMolQjA2ed6errWgF3OPkqG9pmr1+cjm4ZapjfuqK+rW1hfXz+FMr/EuwL/AGOdsbn1H7gQAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATNSURBVFiF3VhZTFxlFP7Of+8Mi12Eot2Sia36IIJCIWmT0lhSK30wfaoaNcampBhrfGhSl5hIW9HE5VFTpWilNpUI0hrTh1YwjJSkthFEcABhBoZ0YekCFGa72/FBSLAF7jY86Pc453znO9/9//nvuT/wPwIlu2DLns1Lo3J8hwDtZHA2gNUAVgC4SYRrzNxFJH6UpNjZ4iOBqWRqJ83MmVdzM7y6520CvQ4gzQIlSoxPJVX/sLi6fTwZPSTFTOMrhbuYuRJApgP6LRDv3V7ZdsptH8INmQH6aW9BOTPXwpkRAMgE0/eNZQXvssuHK7khF5VtOEhEh+F+hQlAcX/hGu1E61CzmyKOML21at3UmAMGM+96qqrttBOyo0aadufdq3mlEJxvrXlBwFhcUh58+vPOMbtcR/8ZzSu/g0UwAgAMZHgN7xtOuLZXpmXP5qUxOT4Ca8evU0RlOb7S7ntItq8S30EWjEje1GhOacWlrNyi9SR5VrGuDo92NPd3HSvfqCsJM366pqaVAKi305vtbSZAO81yJG9qdMsnZ/vvyyveSpLHB8BLkse3Mn/b1i0fnQtK3pSYuRKb6tzdm10QP2KWklNacUlOXZIzV0xOX5KbvfvwRXMdyrbbmm0zzFhjlpOVW7R+ofj9eU+ss6BkqnMnnJxmK8wSSPKschOfRpbljqbhxMykWQLr6rBJfMiCzm3LHU3DiZkRs4TRjub+BeO/+8MWdBZ8IHPBthkiXDLL6TpWvlGLTnXOFVOjk52B6oObzJXYVOdO2D8AQE1mObqSSDv/VslDI62NftbVQQAK6+rgyG8N/vNvljxsqEqqqQ4Lv93ebE8ATfseXaJpqVcALLfLtYEJI6auLTnREbFDsr0y/4wY9LVdnh0w4yu7RgCHg2ZCSrwHYNQJ1wJGFVl53wnRkZnp8Xy/E64F7Hcy/gMuP6waygpOAnjBTY3Z0Bk1ZeeuvyaESElhTksQpXiYSdOFBwBkyVA1IQwiinkTiUju1avjdYA+w3drZjkB7Qw84NIH4hqPV1wYr7wVM+JWOcykEyMsCz7fEw6HXX/yNpQVFAHww819AoNP9kS+abkcDzutoAHHXd3OAMD2o60tTPjYTY3260qLCyMAQJJhrHVtBgA8q5eWAzAf6+fAeNwYqu6c+sWNvgEYuhChpJgpPuTXBPAiLAyhs6Ez1ONdkfqEzrp59jxgVkiSToXD4eGkmAGAbUdbQ0R8wA7Hfzl+tueGctOhJDPQnaLrX4RCoT+BRbg4bywrqGXgGbO8K5NazwcXJr5zIBFj5g7IcmsoFPrXi9v2hYYZJGBfzOAnPYIy5stJaEbky86pM1ZrMpMG4iALEfD5fN1+v1+bKy/pKwMAtS/n78xIET/MU5/r/4rUNA7G+xaqwUyqgDFAQgQMSeoJBoMJM91FMQMANS/ln8xKE3dNB4Ebyq+ftU2em4cWA1G/AHo96endgUBAsaOZ9G02g7g0VhpRMovu8ZJv5rcJxbh+rHPq59l5DETB3CcL0fVYYWGwrq7O8cm2aCsDAFXPbdjkW0bNguDRDehV7ber/rihjgCYAFFQAnqfHxjoOwQYydBbVDMAcOTZxyvWLZMPXBxS6r/tjlRDlrt7e3uvAeDF1v5P42/pFun0pc2xBwAAAABJRU5ErkJggg==',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARrSURBVFiF3ZhNbFRVFMd/985H26m1VEoL0zj0Ayqi6IZElpiQ2MSgIeJCDZGFuEEXJH4bG9QN6spoImiMIaExbREEYoIxhgEb1CZNjFg6lHnTacNHW8QW7Mx0pjPvuKDVprR9X1MX/Jfvnv/5n/89N++d++AOgip2QolRQZAWhCeA9cAqYDlwHbiCcB7NcTKcVA8wUUztopmRQarI8wbwMlBmg5IGPkGzTzUwXowaimJGEmxHOADc44L+F7BLNXHEax3aC1kEJQatCB24M8I077DEeUfE2+Z6MkOCVuBdvHdYoXgPg7e9JXGJ6aPV4SXHPDARtqs1HHVDdlWIDLAMEwP3R2sxjOGnSa1mzCnR3TET3mJpjABUkedVN0THnZEYFQQYwd7r1y3STFLr9DvkvDNBWrBjRIfS1B6J0pAdolFyNGSHqD0cRZVlbKiEKOUxp6U5N3Pry26RNZRm9ZUE5ds2o4IRIIgKRih/ajOrr8RtGVI2dObKOiUA91tGrDjUjap8cH7FZRuoOfirZQ5hvdPC3JgJW0aEHm9cfP3JBsscYkNnDtyYWW4ZoYIrPa0DKKptVzQN52YUf1vGSG548YDcVRtKN+0V9B/cvABGLGPSJxKLrqeOJm0oWWzI7XBzzLotI0Z3PII5fm7eNXPsHKM7NxVFZw7cdOaUdUymjMHwGlKdUSQ3COSQ3CCp9iiD4bXIZKllDkXUaWnOJ4Be7qKUS0ClU64D3KCcOrWSlBOS485MjxhfOeU5xJdOjYDbqfnWFTkG1LjhW2AUP+v+t6l5WmiPG64N7HFjBDxerMSgDXjWS47ZKBT4unFLZLfWuqREpCyrVElAROULOgDg95lTea1NpVQmmM2mNly+PN4JhRm+VzOVwG9AvScXwERaj2/dFT5wadg/aVtfVEEJSb+Wn2LJZNLTPwDVxA1gB7N2xw1EkH37q445MQKglPjQ0pSH5+vr6+u9/dAAVBNdwIdecvzQVd7V/l1F0ksZPtOs82wGgCFaAeuxfh4MX/Ndfe2D6tNe5E0wC1obRTGjHiWPyXNgYwidhakpNfX6Ryu+SWWU+2MqklM+35FkMjlcnM4Aai0GwitOOG0nKk6e7Sm97lJSBPpKCoX9hmH8AUvx49ygA3jaKi5mBGNbXwy3u5DIiMjv+P09hmGMzl4ovpkLVGcLqr+kRKoWikmnVWrb7rrPEkN+WyOLiMqjJC5a90Yikb5oNJqfL87vtuiFoO7jz8s/653hmsK3zL9Z8vHBZcesjIioKY05oLTuNf2+WDwezwIkEgtflYremRkMdQXa7l01ddt0cLq77JcX3qz9fgFaBqUSGvoDoVBfb29vzonmkpkZOEVpZaW+UFVpRmaeXRvzXWvZGf785oTv32MikEbkol/r8w9t3Bjv7Ox0/WZbMjMAPcfLNj28bvKMzyeBfIHCS3trvvjxbGgEuIFScR/0PzMwcHEvmEtZR9HQfaz0/WxMZdo/vftQc2Pjlubm5jqWeBPvCPwD/KOH+jnO5aMAAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASxSURBVFiF3ZhdbBRVGIafc2Z2210hbeWnpcQVUC8kwBUJXJBIgwkgBEPEC1GMxhgE4gUJJsYERMWI3orYaiqgrYSWH/mvMaQLciE1RAKUkrLbbhMobQ20/LT7N3OOF0CC0O7szGwv9L3c73u/93vnnD3zzYH/EUTBKx6sHUvQWgR6GTAdmASMA26A6AYuofUhQnYTVevuFlK6cGaObC9DGh8i9PtAKA/GEIKvSRZtZfnbA4VooTBmjlWvQFADPOmBfRN4l8Xv7ffbhvTF1lpwrHoTgga8GeE+by9NNRvR2tfDNfyQmVv5MYJP8L/CAqgidtai/sgpP0W84d7WavBV43Eo0CtYvOaAF7K3Rg7sKKU4Hcf71sqFfmz1DEvX9rslevvPFKc/YnSMAJRhyA+8EN2vzMHasQSzveR3/HrFEMV2udv3kOlaJmgtIg8jYcMcqpu1oGXJhMi0oJQVGaV6Dvd1day62DwnaWWd+GHSciGwz01rHraZXuaUETbMoe6qVR3Ly6fMD0oZAYJBKSOvVEyd3z3/jVjIDCSddYSjzqPwYEY875RRN2tBS4kZnDFcrNQMztw144UzjjKa6W4787IylU4ZSyZEpuWKv1w+dWohdB6Fl9NsnFNCUMqKnHGRO34PYnz+Ld2DFzN3nBIySvXkjGt1PQ+d23l3dB9ezPQ6JRzu6+rIFT/Q25lwVNHkfCDDwYuZFqeEVReb5wxYmQvDxfqz6QtvnW+e69yZcNR5jOKWgKbZKSVpZUOV0bpnG3vi0YxWXUAmo1XXnp54tLL5p+dSyi52FlJRt625nwCavxlDyrgKlLjm5o9byPBkFr456IbkfmWq1t1FsMM1zx1q3RoBr4OmpT4F+jxxndGHrbZ4IXozs3RtP0Ks98R1ghDrvYz/4PfD6ti39Qix0leNh6H07siaL9ZJKYuKtA6lhSgKaC0sWwYATENlLSmVECIZTKcHZ167NtAI9gO6PzO/1ZRg6XPAFF91AJnKDES21NaYN26l8uVoLWyhSZhS/345kUj4/+Q9XjMPdBR/9wl6Qn3TjyWnzyW88i3Y5e92BmDx6tPAV35KjDnXftqHEQBhKDXZvxmA4p5NCJzH+mFg3rxzvXzn0ZN+5BUoW8p4YcxUbbZQ4nXyGEIfhrDt7MS6o/tEOm07Z48ArTPCMPYnEomewpgBeGl1HMQGN5SSk381hdsSNzwqag1tRbZdHY/HL8JoXJwfr24AXnVKK7rae/mpz3fs8aCQ1FqfxzTPxuPxf7243V9oOMESa4XOvqgDZtlIKTKVHpz4w6Ej+ZbUWlgIHdNStkYikbZoNGoNl1f4lQGM3V8us0tLfhmhvh6/98Tu0hN/XslVQ2uRlahOIWWrMozLsVgs7aQ7KmYAAnVb67PjSh+bDsKtHX9Ubmv4dQRaEiE6JLQHwuG21tbWjBvNwm+z+8hmU+/Iu8l5akwo8uA34/bg3+W1B088nKdhCK2vmFJemjV7dqyxsdHzyTZqKwMQ2r55bmpK+SktRABb2ZO+2//9E+djvcAthIgZ0P5aZ+eVzaAKoTeqZgCKt238LP10xYaxZy7tq/j5+E5Ms629vb0b0KOt/Z/GP4jqqfL5oxVsAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS8SURBVFiF3VhdTBxVGD3f3Rl2oRAstZXaBGxpoxaxhSVpE0ha0ib0qU/1QX009UHjQ5Oa+BO3pdTEn0QffNDGGH+SprGUqlUTSGtcKfGHBELALYTuwGJsSyEVKLuz87Mzny80sQjMzp3lQc/j3O+c8525N3fuXOB/BCq0YNNoU5lRZBwipsMM3glgM4ANAO4AuMnM14QQl7LZbFeiNpEupHfBwtRN1q1Xc+orBHoJQHEeFB3AB45w3hrcOjhXiB4KEqZxvPEIM58BUCFB/4vBRwdqBi4G7UMEYjMoqkVjzHweckEAoIJAF6LJ6BvgYC83UJiG8YYYgDYEn2EC4VRUi74eTEQSi0vrfBCNZeAy85GB7QNfyZClGtk9sfuBkBvSIL+0VsOspVg1w9XDs36JUstMYeU1rE0QAFhflCt6WYboe2aaRpvKDNW4jfy2X1nohmE85Pc7pPh1MYqMQ2DvIBER0ds3tvc1lzRvU0mttNme6tF7xmPTsT0mm178kuJIcSuATj+9+V5mxHTYqyYiInpXddd4y7qW/SqpVQCKVFKrDqw7sL+7ujsZpnDWS4OJPX2WwncYBj/uVdO+sb2vlEqfWG6sVJTWtW1q+81Lg5h2+u1NZgN42KuguaR522rj+0r2bfXSYGZPn6WQCbPBq0AltTLIOACA8KCPngDIhCEseJXYbE+tOg77Vh5Od/PuaRH+wzBue5X06D3jq43HM/FUHk6rvpDlILPM+rwKYtOxPWk3Pbzc2IK7MHxi+sReLw0Ge/oshczW/KNXjclmcetk6/YrmStxm+1JAJbN9uTlzOV462TrDoutiGdjJOK+e/NLqE3UlkYikT8BlPvl+sC8vc7eMlQ5lPFD8j0zidpEmkCf+uX5xCd+gwCSB01TMU8BmJbh5oFpS7FOyxClwiwez4/JcPPAMZnjPxDwxyqqRc8CeCaIxn1wcG7m4MyLQohwmLnYJAqrzJRzhAoASsi1c0K4RJQtMs1M3Y0bcx2Ac48eNEw5gEEAjwQKAYB1nksfnTvjTrlG3hwmhxgpRfDV0VQqFfiXN6pFmwHEAYSkRRisv5/5wv7eSMkq5IDPg93OAOiv6e8F8E4QDbvX6g0QBAAo5LpbAocBgLI/ymIAPI/1y4Fn3FvZt9M/BfF3AdcRQitImHhLPAcXzwLeh9D7YMPW3810cpYd7+IVwGxRKHQxlUpNFSQMAPTv6NeY+bgfjvmt0ZXrt+5IWjIDI2HH+UjTtN+BNbg4j2rR8wCe8qpztdzowvPzX0pYZJl5CIrSr2nafR9u3xcansjhBXb4IIVp/UolrLuZ9On0d/lKMlMOxEkWIlFVVTUSj8dzy9UVfGYAoP6X+sNik/h6BX02PsycMy8Y11fTYCZbwJ0gIRJuKDSaTCZNL981CQMA9b31Z8Vm8a/Tgd1n/aq/utC9Ai0LonEBjKklJSOJRMLy41n4ZbaIWXv2uYr5imYqp6p7z9xZdyb7ZvqHf9YxoIP5uiLEtScbG5MdHR3SO9uazQwANFxq2EuPUQ9CUOHA0U/e/dj+2b4NYB5EyRAw9vTExPWTgFsIvzUNAwC7vtnVrjyqHLeuWJ3me5nPoCgjY2NjNwHwWnv/p/E3iQfm3w9KV7kAAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATaSURBVFiF3VhbbBRVGP7+M9NddtmyvcYKSbGoAYn4REJNIGmRpMREfMEH5YEYY6ptfCCBxEgEvMR4eeCBtBYa1EIIsbVAFAIIsis0og1GpJbWdrdsiUBLuXQp3e3MzpzfB23Cpe3pzGwf9Huc83/f939z5nLOAf5HoGwL7m4ryjWssdVgWkPEi5npURAKwbgJ4CoYF5n4WyBwrLZy6G42vbMWpv5MOJ9s+TYz3gIQUDtzCkw7DGgfb6gcHs5GD1kJUxcJrSWinWAUuOjgFkt+vXbl3QNe+xBeyMyg+lOhLQRqdhUEABgFRPTN59HQu8zebq7mhVxSEdoKovfgfYYJoMpzCZ91pMk87UHEHeoiobUEavai8RAYkgTWvlkxctAN3VUj2yN5eX6y464fralxG7p4vGZF8rZToqt3xs/2OzMUBADykZGb3BAdz8zutqJcI2MMYjqfX7cgTjEHHnH6H9Kd+hjW2GqAlEF0PZhataixfX5h1QJBvhLJ5kD/jaN9J7url1l2amo+U1BwugpAq5PenD9mTGtUJboeTK0v7+0rK3qhQpCvFIBPkK+0rPjFivXP/hnTtWBaaSPUPg/CzTvzlKpg1aLGdp+e+/REYz49vGTlooZfVBrMWOy0MTdh5qoK5hdWLZhqvKzo+TKVBpHa50E4D0MoVIqSr8TL+L8omnZP47pOCWCMqEokmwOK8WvT8LnjoCsA7mZmUFXSf+No31TjfTeOJKbhNOUNmQiOwxCjXVVzsrt6mWklOyYaMzLDHae63ihXaTCpfR6E4zCSKaKqsexUoOnswifiQ4eiks1+AKZksz82dDDadHbhk7ZMz1I3RlGnvTleAdRFikOEsb8AhJ1yHSA5agbnbaoaHHVCcjwz/ywx+EunPEcg7HYaBHC7OdO190G47oqrAuE6NPGhG6qrMDUrkrchaYMbrhKSNrhZ/gMeN1b10dA+ML3iReNe2JL3f/ZqQa0Qwu9nDhhE/hxmsmyRAwC6JjOWEJKI0j7DGF1y5cpwC2CP8z2F2XkiP2zr1nkAj3mLAZhpMbx3a3hnckiMTZfDTDYxErrgM92JRMLzlrcukrucgCi8nCcw+MSe2Xs6orMSbhUsoMnT6QwA1FaOtIHxqReN2G/+Ng9BAIA0Ked5DgMA12lkCwDlsn4ijNyia8d3zf7Ri78EpC1EPCthtlXC0qRYB6gXofc1YSNz/Is5rYZBtrp6EjCbpGkHEonEQFbCAED1c8k4GBudcM6fmnXscqd+06UlM9Dlt+2GeDz+BzADB+f1kTnNAL+kqhu6rHfv3Rr+2oVFmpkvQNd/jcfj9/24HR9oqKCBawyTVuk+zp+sxhyj0cMNocPT1WQmC8QxFqKztLS0KxqNWhPVZX1mAOCT1rw1uQX2oUn0+fT+4P5z3wd6p9JgpoyAvERCdEpN647FYobKd0bCAMBHzeF9ecXyodVB4kLOzwe2zzk+CS0Noj4B9OQEg12dnZ2mE8+sP2bjMEeTr6UD4eWBkCwdvzZ6Rwwd2TX7h3vrGEiBuVcX4uIzS5fGWlpaXH/ZZmxmAGBzY0H53AXWaRKcI23Y3+0INcZ/9w8CSIIopgE9L1+61LsNkNnwm9EwALB5V8EHJWWZjV0/BVpPNoW+gq539fT0XAXAM+39n8bfE7XcWzV66JYAAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAR4SURBVFiF3ZhbbBRVGMd/58x2u7vQbmtvssSNAjaRiE8k8oAPBowkVTAGTVAJJMYXiTGYNFxisHiJ7ZMPQiIxxhRLCG1tjSBRubiAJEhiNDaFSlu6baRQELsI7e7sZY4PlKT2sjNzZvvC/3HO9//+33++M2e+GbiPIAqesYkSLNYgWAssBRYAFcBNYBjFBSTfkuR7GrhTSOnCmfmYcgTbgbeAoAPGOIJP8dPIVhKFKKEwZppYj2If8IAG+x8Eb7CNDq9lGJ7YCkGQXcBeIKSZJQi8zDNYHOMMu/XL8WYmxHvAbrx3WABPc5YsxzntJYke7m6tVk85psNCsZ4ddOqQ9Qr5hDJM+tF7RuwwimIxOxh1S5Racml2MjdGAMqBeh2i+840UYJiBGfHry7GSVHj9j3kvjMWa3BgJOQPjXe82BEz680htU2lzXpzqP2F9ljQF0w6UAlRzLNuS3PfmUa+Al7LW4k/ND68Zfhy2B9+fOpawkx0RfZEliSzSbsbsp/tbHJTms4z85hdQMtzLednMgJQVly2rLmu+RcHOkvdFqZjJmIXULe4blG+9XW16x4phM5U6JipsAvwS/+DXtYnUOm4ognomLltF5C20tds1q860PnXcUUT0DEzYhdwuPfw5XzrnZc647Yqgrw3ZCbomDlvF7DxyMYnE2aia6a10dRo1+bvNq+wVVH2OlOhY+Ynu4BkNhmM7Iksaetpi6Wt9CCQTlvpwUM9h2KRvZFHU9lUwFZFEHNbmPv3TAPzCfAXEHbNdY5bGCyknjE3JPeduTtifOma5w5fuDUCuoOm4n3guhbXHtdRfKhD1DNzdzzfqsW1x1ad8R+8flg1cgB4xVOOybA4GP0sukVKWVysVNAUorhIKZHNySIAn2FlslJaQoik3zTHll25kmiD3D26VzNh4HfgYU95AJmRiWhrZJ/vti/llKOUyAlF3CfVmZ54PO79k7eRlUAMb/8TVNWpiv3hiyVxXX4Wmr390AA4zhCrCCB4SjfF/IF5P1eeK//NQxVCWNYNvQNgKkx2AU7G+mnw3TGu1pysPOVF3gIrJ2V/Ycw0kEXyKg6G0MkQlshUn6r6WmREzj56FiiVFobREY/Hr3nfZvdwjFFWcRPB804pZV2lR8PdJXmH0jxQCnoCuVzrn4ODgzA3P85bUbxkF1b8t7/nofbIIQ2FpFLqD3y+X/v7+//34vZpJMsPgzeFKVYrQ5XPFiIzYqz6ZPURpymVElmE6lNSdkej0YuxWCw7U1zhOwMY7xprc/Nz38ySX1WeLT9Y1hXuzZdDKZGRWANCym7LMHr6+vpMO905MQNQtLPoQKY0M206CA0Fz0WO1vwwCy2JEJclXCoKhS52d3en3WgWfptNIOPPvC5TcqUVsKL3rhnjxo2aE5UnJscpGEepXp+UF55Yvryvra1N+2Sbs84ABN8JrkhVpU4roYqwyC34sfrzefHQCHALIfoMuLRhYKC3Aay5rKNgCLwd+EB8JJKlm0pbahctWl1bW7uQOb6J9wX+A8zucxGCTS9IAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARZSURBVFiF3ZhbbFRVFIa/vedSZkTbClJow1irNpGIvpDIAw+NIYghqTHig6JGIoLSGEK8xEhoKpKovBoJg1aCaVNpsYhIRINh1D5oDYaIvUhn2qGhNwi2RabtXM7ZPrQk0Ns5Z5+ZF/7Hs9e//vXvtXP2OgduI4isZ1S1d0JmPVAJrACWAYuAq0A/0A7qWzBOIaquZ1M6e2bU/kLwvAu8AQRsMMZAfAK+jxCbR7JRQnbMqAMbQYSBuzXY/4J6FfFas9sypCu2UgJ1sBpEI3pGmOSJo6jwbpRytbnuzHCwGtT7uO+wAPZAeJfbJHqYPFqNrnLMhAliI2LrMR2yXiHqUAGkYugfrfkwDMb9iO3DTomaxyz1HrkxAlAI8m0dovPOTN4jQ9h7/epiDDJFTu8hjc5k1mPDSBDvWDPrIkm29Cq2ppJs6T3KukgA37gNkSD4nnBamc4xq7SuxDvWzwvdT1Na4UeGAL8fGXqG0op+NkVtGrLUmQ4dMw9ZBdTxeGs+/odnWyvAv/IwFb9by6gVTgvTMVNsFbCBUNl8609x733Z0JkOHTOLrAL8yKVu1qew2HZFU9Ax859VQApz0GJ9wIbONdsVTUHHzJBVwAl6u+dbP0ZP3IbOvBsyGzTMqFariBc589gIqfOzrQ2TPP8ykdU2hCx1pkOnM2esAsZJB4qpf6CJnkgK8yKQSmFePEIsUkzdgxMYC6xlRMRpYRoTwKcLwXsJyHfMtY9RCJQgXko4ITnvzOSIccgxz5lIrVMjoD1oGnuAy3pcS1yGzF4dop6ZyfF8pxbXGjt1xn9w+2GlwvXA865y3AzDbAiVfVglpczLUyqQFCLPp5TIGNIH4PWY6YyUphBi3J9MJlb29Y00gXGD7tZMPnAOKHWVB5DXUyOhJz8Pey+NTtiWV8IQirhXql874/G4+09eFV4DRACPfg7UPbu+/zK/4VxcN0MGDrv8oQGIbS2g9rlJsfDHf1pcGAEQHtMscW8GgMFqwMZYPxPegWsDRW+e/NmNugmmIWUsO2ZETQbYhI0h9BZa2kgveefk1yKRNKyj54BSKeHxNMfj8cEsdQYQ22LAW04o+XV/ngq2xK9qKioFHXmGcSAWi/0NOflxHm4EnrUKy2sf6ly+4YsjGgrjSqm/8HrPxmKxWy5ur0YyK2wXycxalectnCtAJpKJJTuOf2c3oVIig1BRJWVbKBTqiEQimdnist8ZwNP3caVRXPDNHPnV4r2nGwpq/+iaL4dSIi0xe4SUbabH0xmNRpNWujkxA+Dr3VefXp4/YzoIRmK/FW9u/GEO2jhCdEu44AsGO9ra2lJONHNxzABIG2OvyGH/GrMwELrxzHMlcaVox/Gfbo5TMIZSXV4p2x9ZtSra1NSk/WbLWWcAAmdrVk88uvQX5RE+Mqax7PXmz+443TUEjCJE1AMXnuvp6aoBM5d1ZA0LWnd/IJL7x+/6qqquvKxsbXl5eQk53sTbAv8DzFJ5Mvw8/r8AAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQLSURBVFiF3ZnPT1xVHMU/983QYcbqlNZoCmEkqCxMtJsm+gfQ2KaJqaYurDHaZeO2dmH8lZg06qZLtYY0RhqkKFrd1KYJE2VhqiQG5YftDAwEShFpARmGN8y84wIxhQLvx8xA0pPczbzv955z7u97B+4hmLLXKN0PHASeA54A9gJ7gGngBtAPfAdcwpj5svOXBVIN0odIC0jyULJIHyDt2m7pqyEdRZr2aGJtmUZ6YbstgGSQ3kFyAhpZKQ7S20jlH/Y+zLxboom15a3tMnK0DD2ythSRnt9qI7tKmCNu5RZSTRBZVkA7bwK7A+a6oQZ4I0ii/wm3vI9MAtEghB6xADzsdx8K0jMH8WAkBgudkLRhVJC3YfQrSEYh54EjBjwbQJtPSF+4jfuYlJ2Rftc6uC31Rr1trJ9vhZlf3YR0Sl3rGVnBBanLg5lftsLMDTchtjSymRlbyngwM+5XWpAFwAZ2bBoCeZcY20DEhSmPMW4xqxBkAfjHLSAPN12+T3jgmfOs6D8EMTPpFvA9DG32/RvIeODZtEHKA+mc23iPSgu3pd715sstqbdaynmYMy1+pQXpmS63gBxEa+GxDkjmYQTI52GkHZK18PgiVHvgSfoVFmQB2AmMAXHfud4xC9RhTNZPkv+eWT5inPOd5w8tfo0Ex/IVebJCp+bJoKfmUgwdq5CZY0EllXZNlc4DgcnvQrHYlmhsfN2yrEhEitrGRKokUyhaVQDhkLNUsCzHGJPbYdvZJ8fHZzqguJJeqpk48BvQUFI9gDU/P5M4dOjT8NjYond6UzQiE7b002Amkwl6OVuGMbPAK9zROoEgac/p0xf9GFmmVwhLjxbg1YaGhobSzCzX2A18VEoVOy9f7o63tWVKURFynLryPO1IYaAbeNpvanhiYuKRAwdaTDYbuHcdcBw4W3rPABhTAF7GwyF0VdrS0tJDp059XYoRpLwJhTozmczN8pgBMCYNnPSTEm9tvRTr7p4OyCjBQKRY/CSdTv8BlXk4vwC86BYW6e8frD98uD0AQ05SL+FwTzqd/uvOD5Uw86Cx7WuKRDbcxa1sNlt35MjHkVTK05FFMgWMUrKsvkQiMZBMJgvrxYWDat4QxvxtjY+/Vqyt/Zb1G0u7z5y56GZEMksWzrCxrD4nHBpMpVI2wNDQxlelij1UV42Onl+qr7/rdBBLJn+uPX78hw3SchgzZMG1qlhsoK+vL++Hs3Kv7sPD1VY8/qdTU5NY+Sk0NTWVaG4+G5qb+3+YCBaQroctq/+p/ftTHR0dgVe2iv6FEO3peWZx374fFQpVUSgU95448dl9V65MArMYkwrBtZeGh6+/B04ldZQN1Vevvm9sO/fAl+2tTY2NzU1NTXVUuBHvCfwLna16k1MlopgAAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATaSURBVFiF3VhdbBRVFP7Ondlddvqz/aERARtFMUos4YFIH3iAxESICfCABtqkCRiJtjGRBBODivhH1PigEovFGKhJXWktpdgQfDCugEFrCEhbitvdditSKIhtge52d3bu8YE2AWx7d2a2D/o97jnf+c43996Zsxf4H4GyXXD25ta8MSOxiiWvAWERCPeCUQzCNYAGwHyOGIf90I5erX3mZja1s2Ym8EJDYZq0V0D8IgB/BpQ4gN0ez9h7wx9tGs5GD1kxk1sdXM+EOgBFDuh/E9NzN2s3HHTbh3BHZzJqvt7BhEY4MwIARUz8jVEdfB1gVw9Xc0M2qh95gwhvwv0KExFWeh7vTJu/Nh9zXMQpcXxrNbqpMQmkBNYnPt3Y4oTsqJGCl/YVmOasKJxvrekwpEv54MieyiG7REdnxjR92zEzRgCgMC3Ey06Itldm9ubWvIQ/PojMXr9OETdYu8fud0i3qzJmJFaB1UZyvHp8b1V5++qyuQu8mpiTsuTlIx0DvVvqTy6Lm5aKbyRE+kkAzXZ6s73NWPIaVU6OV4+Hd63tXbtk/gqvJkoBeL2aKF23ZP6K8LvrIoZHSyh1AKXO3bB/ZgQ9qkrZW1XeHpjleWyyWIHhKaurKv9FqcO0yHZrdgkAz1VlrC6bu2C6+FOL5z2QgZBS527YN8MoVqV4NTHHTXwcszPuaRxOXs03VAkpS15WxC9loHM9447G4WSbDaoyjnQM9E4X//bMhZhShjDtA5kMDsxQuypjS/3JZcNxs2Oy2HA81fF8Q3u5Uoah1LkbDs4M/aBKiZuW/+FXDz3UcvpCKGXJfgCplCX7m0/1hxa+1rowkbJmZaAUstua7QmgpLoxN07WnwACdrk2MDLqN+fhw6pROyTbK3NrxKB9dnn2wF/YNQI4HDR1ab0F4IoTbga4okt+xwnRkZmRPZVDIGx1wlWCsNXJ+H+L6gI5NcEGABVuatwBtoLFbdtrhBA+H7M/SeTzMFPaEh4A0DVppoWQRJTwJpOjZRcvDjcB1gTdlZnCLY2BlMc6A+B+dy4AkU4Olxz7uE4khsYy5TCTRYyYLvj4+Vgs5vovb171V8slUQhu7hMYHOhs+dL4oz3mtEIaqHd5OwPcqK04AeADNzX8g10nXBgBANKknOfaDACMlszZAUA91k8CbWzkUuBs049u9CUgLSGiWTGDnSvTuqBKgJVD6O0gaZmB35qbyUxa6uwpwJwiTTsYi8UuZ8cMgJHdG6JMYpsdjr//5FHfXz3XHEoyA90+y/osGo12AjNwcZ5TE2wE8LQqz3v90vni458ccCCRYOaz0PVT0Wj0jg+37QsNFYTJ1axZT7DQC6fOSY7mnw62ZVqTmdIgjrAQXaWlpd2hUCg9WV7WVwYA8jbXrpH+wkNT1Of8c23BnL6feqarwUymgOwjIbqkpp2PRCJJle6MmAGA/E21DZZR+K/pwHf195+L2vd/NwUtAaJeAYQ9htHd1dWVsqOZ9W02gevsfzY3NbqcvTmlE7+J5M2rgdMHvr89j4E4mHt0Ic4tXro00tTU5PjNNmMrAwBFle+XpwLzjzEJD6RlFZ1q+Nx3pXsQwAiIIhoQ3tjX17MTkNnQm1EzAFBQsettM3DfNv/FM81FnS37oevd4XB4AADPtPZ/Gv8AkvXQkIP4nXQAAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASpSURBVFiF3ZhbbBRlFMd/3ze7bXdp0yKlQI2NIqZlK8YHjDxgFEIikVhKAibeooH4otFIosFLgvdEn9QQHojxAkoIFChRMWBCXC5GxRgb6sJSWrrlDgXbUrrbndmZ44Mlwdru7MxsH/T/ON/5n//5z5n55swH/yOoomesb6rAMBaDNAExYAYwBbiC4hxwFORrKNlDouVaMaWLZ2bOksk44VeA5xEiBTDSiFpHqbxP267+YpRQHDONS5cjagNwkw/2n2j1DH+07gxahhGQr2hcthZhPRD1mSOC8Ag1DQ69yYNBiglmJtb8BvAWwTusgAVUN+S4nDzgN4l/M41Ll4NaTzHfO8UDVNe3c/l40h/dD+5ursKkC3/viBv6MKzbad/d55WofclZ8hoTYwRgMnb4ZT9E752pb6ogpC8WuP36RRoVnub1O+S9M4axuBAj0bLS9M6P18SzbdtPSaLVzLZtP7X9ozXxSKQkU4BKFKwHvZbmvTOx5i+BJ/JWUlaaPrf/s5OV5dE7R6/1Dw611y5YOSuTMfPfEKU2kWh9yktp3jujmO0W8tUHLx4eywhAVcWkORvfe+EXVx1HYl5L825GqHULWXL/PTPzrS9dOO82Vx3lrjMafnazKW4BJWFjepD1EVQXXNEI/JgZdAswLfuCy/r5AnSuFlzRCPyYuegW8E3815P51lv3/ZQqQCfvDRkLfswcdgt48tUP7+0fHGofa61v4Fr706+vm1cMndHwsQHID24hmYwZqV2wclbL3h/jpmX3AKZp2T1b9xyK1y5cdcfwsFnmrkPca2nevzONK8rBOoNQ6ZlbKBQDGOmbOfL9kBea9878PWJ87pnnBcKnXo2A30FTW28Dl3xx3XEJw3rXD9GfmfbdfShZ7YvrBiWr/Yz/EPTHKta8GXgsUI4bIc6WuqG257TWpaUikaxSpWERlbN1GCBkOFZOa0cplSnJZofmnD3b3wL2dXowMzNXVFJmtQG3BsoDaJz+uuHkhpBjDhfKEVG2ElIhLQeTqVQq+C9v47L5IHEkyHmCyFTrzKZK60rKb4IcbAx6OgO9yVNMbSgD7vObotweOFRtnv89QBVKOU6vvw1gNGr61wLuY/0YCIl5fpp5en8QeQccW+uu4piJx3NoHqeAIfRGKLBqzNM7lNi2e/Q4EDGVYexMpVIXgj9m13Ep2UdNwxXg4UIpVVbvd5W5y3mH0jwQgWSZbW873tPTAxNxcB5r3gascAsrdTLJW4aPb/WhkBGRI4RCv3V1df3jwx3ykSw/cvazKqQWCXryeCFa7KEaq+fbQlOKqBxKOkXrRF1d3bF4PJ4bK674nQGM+iVNthHeNU5+qTbPbqnK9Z7Il0NEWRqnW2mdcAwj2dnZmXXTnRAzAOHYQ5stSv41HURzgz/Xml17x6FlUOqkho5wNHoskUiYXjSL/5iNwEqnV+mInu+oUN31a4bkeqdlU/tuvIUCaUROhLQ+etfcuZ0tLS2+d7YJ6wxAZPaiecO6/IAIYUTsGWb3J5PsqxeBAZTqNKDj0e7uE2+CUwy9CTUDUFa/6J2sEX2pwurfMd0+8wWh0LGOjo5zgEy09n8afwEcs7T5cvn0GwAAAABJRU5ErkJggg==',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS2SURBVFiF3VhbTBxVGP7+szPscmkq1FZqE2pvUYvYwpK0SUla0ib0iaf6oD6a+qDxoUlNvMTthZp4ifHBB22M8ZI0jVCqVk0gbeOKxAsJpAG3ENiBxdiWSypQdmd3Znbm9wGaCAKzc2b3Qb/HOf/3ff835+TMmQP8j0D5FjxwYGhdJlN0lIibmbEbwGYAGwDcBXCbmW8KIa6k0+mOWKw6mU/vvIWpqRkvV9XsK0R4CUBxDhQdwAe2Ld66cWPbbD56yEuY+vrRY8x8HkCFBP0vZhzv69tx2W8fwh+dKRzWIszcCrkgAFBBhEvhcPwNgH29XF9h6upGIwDOwP8ME0Bnw2HtdZ8iclhcWq1+NFaAw8zH+vp2fiVDlmpk796xBwIBR4P80loLM6ap7BgY2DrjlSi1zBSFX0NhggBAeVFR9mUZoueZWfiOqJPIbfuVhZ7JZB7y+h1SvLpkMkVHAXYNEgoJvaVlY09DQ8l2VaVKy+KJri59NBKZ2mcYrvyS4uJQE4B2L715XmZE3OxWEwoJvaNj62hjY+khVaUqAEWqSlWHD5ce6uzcGg8GKe2mwUyuPsvhOQwzHneraWnZ2FNWRk+sNFZWJmrOnNn0m5sGEe/22pvMBvCwW0FDQ8n2tcYPHizZ5qbBzK4+yyETZoNbgapSpZ/xBdCDube0AIkwNO9WYVk8sfY47uRgdC/nlhYhEYYn3Sq6uvTRtcaj0VQiB6M1X8hKkFlmPW4FkcjUvmTSGVhpbH7eGTh1amq/mwazu89yyGzNP7jVGAYXNzWN77x2LRW1LB4HYFoWj1+9moo2NY3vMk0OuTYmKOq5N6+E6upYWSgU+hPAeq9cD5izrNIt/f2VKS8kzzMTi1UnifCpV55HfOI1CCB50DQM5SyAKRluDpgyTeWcDFEqzOLx/IQMNweckDn+Az5/rMJh7QKAZ/xoLIV9cXr6yItCiGCQudggCqrMlLWFCgBKwLGyQjhElC4yjFTNrVuzbYB9n+03zHoANwA84isDAGZ9Njl7/LzjTGRy55BNjIQi+KehRCLh+5c3HNYaAEQBBORVmPXU+19Yme8TsgJZ4HOftzNAb++ObgDv+NGwzO5uH0EAgAKOs8V3GABYt+6PCADXY/1KYGf6Tjr59o9+/B3AsYXQ8hImGm3MAs6zAFwPoUthWXrq3XbmtO1euwqYTQoELicSiYm8hAGA3t5dGjOf9MIxMt92ZM3eu5KWzMBg0LY/0jTtd6AAF+fhsNYK4Cm3OierDc3PPf+lhEWamfuhKL2api35cHu+0HBH9gVm+whRsHy1Cnb0VDJ57rtcFZkpC+I4CxGrqqoajEaj2ZXq8j4zAFBb+0uzEJu+XkWfM6kPLxqZSyNraTCTJeCMkRAxJxAYisfjhptvQcIAQG1t9wUhNv/rdGCZPb/q8692rkJLg2hUAMNqSclgLBYzvXgWYJktYGbGeq6iYq6BaH3V/WeOMzOdTr55/Z91DOhgHlGEuPlkfX28ra1Nemcr2MwAQF3dlf1Ej3UBARWwbf3e6Y8t6+dJAHMgigeA4afHxkZOA04+/AoaBgD27PmmRVEePWka19sN/b3PoCiDw8PDtwFwob3/0/gbh/Lm30zcQi4AAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASdSURBVFiF3ZhbbBRVHMZ/58xeSgNCqRegsamt1EhEXwjw4AMmJGpAEhNoVOItxgdFQ1C5qqQiKiVRHtQIGuKDXNItFJGSoFFYpIltExIj9EK7WxbTUi7BFqHbTndm/r60CWDp7MxsX/ge9/y/7/t/55ydOXPgDoLKtWDVQZnkDPGUgiUIs4DpQCFwBTgv0KLhpwE4UlmhrufSO2dhPtstBSrEOhRvAxOyoKSV4stIiC2rnlV9ueghJ2GqYrJUYAcw1Qf9H6V4fe0yVRu0Dx2ELCJqS0w2CsTwFwRgqgj7qqrlQxEJNLmBwmzdx0bgI4KvsBLFpqp9vB9IxC9xeGvFgmiMAkdg6foKdcAP2Vcj2w7IFDNDEv9bayz0Soay9ctVr1eir202lGED4xMEoIAQq/0QPa9M1UGZJCYXye7x6xfpQbjP63so5NVl+IXoGiQSIr14Lk1l0ynVmmmOw4WOHjrrGpln2a78/KjwJLDfS2+et5mCJW41kRDpFYvpnFnEAq0pBiJaU/xQEQveeoZEyGAgFz63wvt/RnjYrWTxXJoiYR4ZbSwaZvaiuTS6+ihmeW3NzwNghltB2XRKxxovn8EDufC5FX7CFLqKaqYFGR/G3Vl3NKLrlQBccytwHC6MOS70ZOHzb9YdDcNPmItuBR09dI413t5Nyk1DMfaEjAY/YZrcCuoamWdmODXa2OAQpw43Md9NQ5S7z63wHkZxzK3Espnw1SEebOsi7jicA4Ych3NtXcS/rmOmZZPnaiPEvbfmEZUxmZgHXcBkr1wPuGoMUrT6JdXvheR5ZSor1HWE773yPGKn1yDg86ApFpuAS364WeCSZNjsh+grzPDxfJUfbhZY5ef4DwE/rLbEZDfwQhCNG+HY9t7ta0tXaK2jUZEJplLRsIiybB0GCBlOxtLaUUoNREyzf3Z3d18N2CP8oGEmA38CJYFSABnzel/tF0/vuNbbNZgtR0TZSkiFtJxoS6VSge4A1lWoq8CL3DA7/iDScPjTg16CACglBlrKLHi5pKSkJFAYgHUVql6ErUE0Uqd/qT/TsDcVQEIZjlMUOAyAeS8bIYtj/Sjo7+vpOV797vEg/g44ttbJnISpfEJZ2mE5WRxCb2rCzmSO16zZnzH7/W9TkSFlGLWpVOpCTsIArHlOJQXe88Jp+WPXkfMd9Vd8WopAa9S2tyeTydMwHhfnMYkJLHOru9LT0nZg26JqHxYDIvIXodDJZDJ504vb84WGGwyLN00xFxrhaMHtaiyzv//onpV12WqKKAslCdG6ubi4uDUej1uj1eV8ZQA++LZ7ycQpM368jb40HNq89/SJnR1jaYiojMY5q7RudgyjLZFImG6+4xIGYMM3f+++q/D+/50Ous7EG47sfPXn29AGUKpTQ3s4P7+1ubl5yItnzrfZCCJ59muD6d7H8/ILikd+S1+7fPnYnpW/3VgnkEakI6R1y6Nz5iRqamp8P9nGbWUA3vn85Px7ih77XWkj7NiWffSHN75Ltfx6EbiKUgkD2p8/e7ajEpzx7CNnWLm16eNP9pgDr6yu3lVeWrqwvLy8iHGexDsC/wHqq7fSQTg4DwAAAABJRU5ErkJggg==',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARmSURBVFiF3ZhfbBRVFMZ/d2Z3y1aatoCAbVyxahON6AuJPPDQGIIakhojPihqJCIoxBDinxgJTUUSlVcjYTENYNo0UCiKRKrRdFUetJGEWAuE7rZLA+VPg22Fbdk/M8cHtkmtbWfmzu4L3+Pc833nfPfczD0zcAdBFVqwCSnLwdNAPfAIcA8wH7gODAJnBI5Z0LEZdbOQuQtmZjdSacIHwNtA2AVlTMHnQfh0HWqkEDUUxMweZI2CKDBPg/63wBtvotr91mH4IQui9iINCg6hZwRgnoLDUWS7IL4215eZvdAg8BH+O6yAHVHY5ldEC/mjdciPxjSwFazZgDqqQ9YqZB9SkYEE+kdrNgxb8MAm1LBXotYxy8CHFMcIQKUB7+kQPXcmf49cxd3rVxdjOVjk9R7y3Jn8hehoJFDK2Kp2YuvTDGwQMuvTDKw6TCwYZtxFmtIgPOW1Np1jVu8UEChl7OVB+pY8R50RIgKEjBCRJc9Tt3aQuEtDjnmmQsfMw04BTzbTFSrn0enWQhUsrTvA704acnsU8gQdM1VOAZHV1My2ft+z3F+IPFOhY2a+o2iIxX7W81jguqIJXa8E4IZTgJ3hisP6ZRd5/nFdUR46Zq46BQx8S99s6/1HSbrIM+uGTAfPZgS6nGI6X+GJzAjd062lh+mOvcZyF6kc80yFTmc6nQKy44Rbqniwv42YneECkLEzXEgcJNZcxUPWLeY4aSiIeS3M8wTwBTI3ABeBcq9cDxgNQ/WrqJQXkufO5EeMfV55XqCgyasR0Bw0LdgBXNPhusC1HOzUIWqZyY/nW3W4LrBVZ/wHnx9WUaQFeMmPxmTYWK2fRGo2G4ZRUiISTitVEhRROcsIAgRMO5szDFspNR5Kp1NLL10aaQNrgu/XTDlwGljiywWQMW6O7K96JjoauHjLLUdEWUpIBgz59VwymfT9yRtFVnD7NWrqq4h0zN/2VXdZa1JXIAcHfP3QANiIOimwy49G710/nPRhBECZtl3t2wzAFWgA57F+OtwwL18+seCdn/3kt8G2DCNREDONqBywFhdD6GRYKpv97u73j6RVynKOngEiGWWa7clk8kpBzABsRCWAd71wTpc1dwzMOXldM6UInC2xrD2JROIvKMKP8yhyCHjBKW4odObc/qrVBzVSjIvInwQCpxKJxH8u7oCGmBM25VR6ZUBKKmcKyKhU6puFW467FRRROZTExTB6IpHI2VgslpsuruCdAfjMvFRfYVV9PYO+dFbubP2jvKl3Ng0RlTWw+5Vh9NimeS4ej6ed8hbFDMCu4EBLefbe/00HfeHYb0cWrft+Bto4SvUZcD5YWnq2p6cn4yVnMY4ZAGNZ6/WQMbwibFdGJp6lzKGh4wu2/DQ5TmAMkd6AYZx5bNmyeFtbm/abrWidAWgMn1q++NbjvygxgzY569jCt77sLf3xKjCKUnETzr/Y39/bCHYx6ygYts/p+ni3So9vnnuwubamZmVtbW01Rd7EOwL/Ai1BeTIkgAbWAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQMSURBVFiF3ZnLT1xlGIef78zAMFgCeGscLCGoLEy0myb6B9SIMTXW1IU1Rk3cGF16SYy3xMRUN8aVWkMaY0lDUbS6qbcwKjGmSmKwXKQzMBAoINICMgxnLufnoqWhCJzLzEDSX/Ju5rzved/nu39n4BqSKfULhWqAVuAh4E7gFuAGYA44DwwAXwGnDWap1PlLIqF6oXeEloXkwdJCR4Tqdrr2qyR0SGjOI8R6mxN6ZKcZEDJCrws5AUFWzRF6Tajkw94PzBtFQqy3V3cK5FAJemS9FYQObjdIXRFzxM0uCNUHqcsKyPMKcH3AWDfVAy8GCfQ94S7vIzNANEhCj1oGdvvdh4L0TCteQKpZpos4NuOILDbjfEacKBkPOaqB+wPU5k9Cn7qO+2qlNa8/tZEuqk9RTxvrJ9sB87trIV3q3hBkVSfV7QHmt+2AOe9aiK2xLWFspTzATPqtLcgCYAOVLk5ZFx8bQ8QlVdZg3HyuUpAF4F9XjyzTLs+nPORZ9FjPFQWBmXH1+JqRLZ9/QcpDnq0bpBQSOuY63qNa1kX1bThfLqhPVcp4mDNtfmsL0jPdrh4ZosS4nU7iZBkDsmQZo4M4Me5ghSoPeeJ+CwuyAOwCJoBav7E+tAA0GEzaT5Dvnrl8xDjmN86n2vyCBJYuXZFnynRqngl6ai4G6HCZYA4Hramoa6pQOxA4+XoVKJxobmx+zrKsSESK2sZEKiSTL1gVAOGQk8tblmOMyVTadvquycn5TiisxhcLUwv8ATQVRQEsWUvzB2IPfDQRnljxnF+mYEQqbOnnoVQqFfRyBoDBLABPsKZ1gkhIR+rfPuUHBMAYhbB0Wx6ebGpqaioKBsBgeoB3i3nHd9d929NRcyJVTBkhx2koyacdoTDQA9zjN3Y6NDXVeut9bWmTDty7DjgOHC26ZwAMJg88jpdD6BrlTC738k0vfV4MCFLWhEJdqVRquiQwAAaTBF7wE9Nec/z0L1U9cwFTSjAYKRQ+TCaTZy/VUGIJnQQedfMbqhwYOhB7sCNAioykPsLh3mQy+ffaB+WAudE29nBEkU138WWTTh9sePiDkXDC05FFMnmMErKs/sbGxsF4PJ7fyC8ctOjNZDD/TFqTT8UKsS/ZuLH0ft17p9xAJJOzcEaNZfU74dBQIpGwAUZGNr8qle1D9XjFePue3J7/nQ5+jMZ/fWb3099sEpbBmBELhiuqqwf7+/uzfnKWDWaU0apaq/aveqe+cfW32dDsbGts/9HF0OKVYSJYRjoXtqyBu/ftS3R2dgZe2cr6F0JvtPfevSt7fwopVJEnX3j+5mc//qH6+xlgAWMSIRh+bHT03JvglLOOkulM1Zm3bGNnOnZ1HG9pbt7f0tLSQJkb8ZrQf5kyepAtajIBAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASoSURBVFiF3VhNbFRVFP7OffMY6EjnvYGMrW2atmijRNyUBJcsTGRFQkJTKwpuXBliSDQxGolVEo0rjAuBhLCRGFuL4AoXTauWaBtNTHHoD/NHImXoOH2vY9+Uzvs5blpSoO37m7rgW777feec794zb867wGMEqnXAYrG4XQhxgIgOAtgNoBHADgAlADMAbjDzD7ZtX00mkwu1zF0zM7quq47jvAfgOIBtHiQVAF8S0Weqquq1qKEmZkql0mEiOgsgEUA+R0Rvqqp6KWwdIoyYmUnTtJNE1IdgRgAgwczfaZr2ITOH2txQZnRdP8nMvQh/wsTMH+u6/kGoIEGFy63VFybGGnCI6LCqqt8HEQcqRNM0hZkzCN5aG4YXQuxSFEXzKwzUZsz8PjbHCACojuO8G0To+2SKxeJ2SZLuwtvrNygqlmU96fd/KOI3ixDiADwYIaJKLBYbk2W5HUADgIJpmlnDMPYxs5u+TpKklwEM+KrND3m5yIMeOJV4PJ6VZXk/gBYAWwC0yLK8Px6Pp4losRZ5HkaQ38xzboRYLDZGRM+vtUZEe2Kx2KhbDGbe7bewIGaeciMst9ZG621uMYjINc/DCGJmhwdOQ8h1ANjpgfMAgpj51wOn4LJ+x0OMsgfOAwhi5q4bwTTNrMt63kMetw15BL7NMPOYG2f59Xt9Hf31SqXyolsMInLN8zB8mxFCDLlxmHnb/Pz806ZpDgO4BaAK4JZpmsPlcvkZx3G2ekg17Lc23xPA7OzsE5FI5G8Acb9aH5ivVqtNDQ0Nhh+R75NJJpMLzHzBr84PiOi8XyNAwKlZ13XVtu1JIkoG0W8EZp6VJOnZ/21qVhRFI6ITQbRuIKITQYwAIT+s5ubmLgJ4NUyM1bBt+5vOzs63hBDRKPO2JaKozEyWLWQAiEiOaQnhENHilqUlY8/t23o/YK/ow5qJA/gTQGsoFwAMw9CPdHefnZmZuedVw0w2MfIRwb9M5vP5UHcAiURiHsDrWLU7QcDM/MXp01f8GAEAIpYgeJcFHGttbW0NZQYAEonECIDPw8T4aWho5PLAQD5ECJIcp6kmlxHMHNE0bQTAPr/au4XCnVe6us4bhhH4dB3AcYBzoU8GAIjIEkIcgbch9D4syzJ7e3sHwhgBc5Uk6VI+ny/UxAwAKIqSAfCOH01/X9/V30dHSwFTMgMTUds+k8lk/gI24eJc07Q+Zu5y401PTU2+1tPzbYAUi8w8jkjkj0wmM7t6oeZmyuXyTsMwpqPRqLpuNZWKcezo0a/y2aynkYWZLBCnWYhUS0vLxPDwsLUWz/ftjBvq6+v/SaVSbzQ2Nl7G2pvF586cueJmhJlMASdHQqSciDSZTqeXACCbXf9TqeYns4Lx8fGLzc3Nj0wHv1679tvbx4//uI5sEURZAUzLdXUTqVSq6ifnppnJ5XJbmXlKUZSWlWelUqnYdejQuYWFhfttwkAFzDcjQtx4Ye/edH9/f+A3W83bbAVtbW33hoaGuuvr638WQsiWZdmfnjo1sGxkHkRpCZjuyeVufgQ4ADCVy21WObXB4ODgJ4VCYfHC+Qtfd7S3v9TR0dGETeyIxwb/Abxf6DIUZxAeAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS9SURBVFiF3VhNbFRVFP7Ond9OlBnApihJM1N0EqltQzoJLFxAQiKrruhCjXFh3GhcEGowGomiJEhYUJtUiTFCGEJsBX9CU2pQqzZB6WtLOgw0MNN5TUSggtNp6Tw6fe8dNyWp0Pa9d9/Mhm8593zfOd+9J/educAjBCq34MDAwOPBYHAHM7cQ0UYATwJYC+AOgL+J6LJpmj+EQqGz9fX1d8uZu2xmRkdHV8/Pz7/DzG8BqLJBKQLo8Hg8BzZt2jRVjhrKYmZwcHAnER0BsEaC/i8Rvd7c3HzabR3CDZmZSVGUvUTUBTkjALCGmb9RFOV9Zna1ua7MDA8P7wXwIdyfMAHYNzQ09J5bESkstFaXG40lYBLRzubm5m9lyFKFjIyMRAzDyEK+tVZC3u/3b2hsbMw7JUq1ma7r76IyRgBgdalUeluG6PhkFr4jt2Dv+pVFsaqqqsbpd8jrNEswGNwBG0aEEMVYLHYhHA7XEdE6Zr5ZKBTGc7ncZtM0rfihYrH4AoBTTmpz3GbM3GIpKkSxqalpPBKJbCWiWgB+IqqNRCJbGxoaMkIIzUqDiCzzPJTXKYGInrWKicViF4QQzy215vV6G6LR6J9WGsy80WltMhfAU1YB4XC4bqX1SCQSs9IgIss8D0LGzFobhaxzs76AJ2xXtAAZMzNWAcx802L9ho0807YrWoCMmVtWAYVCYXyl9ampKdVGnhU3ZCnImLlgFZDL5Tbrup5aak3X9ZSqqlusNIjIMs+DkLmaf7GKMU2zKpVKPZ3P5/uZeQJAiZkn8vl8fyqVesY0zaANjX6ntTmeANLp9GOapv0FIOyU6wAFn8+3vqmpadYJyfHJ1NfX32Xmr5zyHOJLp0YAyUEzEAjsAzApw7WBSb/f/7EMUcrMwni+S4ZrA7tkxn/A5R8rRVFOAHjJjcZiGIZxsrW19U0hRCDAXDVHFPAxk24IHwB4Pea8LoRJRJp/bm624fr1qW7AuM93ayYM4CKAqCsXADRNm9qze/eRycnJe3Y5zGQQQ/UK/n1MVVVXbwCJRKIA4BUs2h0ZMDMfP3bseydGAICIPRC8QQdejUajUVdmACCRSAwAOOhGQxkcHPj53DnVhQR5THO9azMAMDMzsxeA5Vi/FO7cvn2js6PjVzf5TcA0hMiWxcy2bdt0AC/DxhC6GLquz3/W2XlK0zT5NmUukcdzWlXVm2UxAwCJRCJLRG1OOD/29Z29NDp6RzIlM3AlYBifZ7PZS0AFHs4VRekC0GoVN6GqY3va2r6WSKEx8yi83qFsNvu/D7fjBw0beKNUKm33+/2rlwu4p2mz7e3tZ+wKMpMO4gwLka6trb3S39+vLxVX9pMBgN7e3pbq6urvltHn40ePnuw5c+baShrMNC9g5kiItOnxjGUymTmrvBUxAwA9PT0nampqHpoOLo6M/HFg//6+ZWgaiMYFcNUXCl1Jp9MlJzkr0WYAgFAo9Nr09PTzq1atqr3/W6FQ+OfTw4d/WhzHQBHM17xCXG5MJDLd3d3SN1vFTgYAksnklng8/psQwqfrunH40KEvFEW5BaAAoowHuPpiLnftA8CsZB1lQzKZ/Oj8+fPawU8OJuN1ddvj8fh6VHgTHwn8B/S71Ufd4vUbAAAAAElFTkSuQmCC',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATTSURBVFiF3VhPTBRXHP7e2xmBTYwgDXVdQ6m2hxrsyaweeoCkSXtQExOZ0JLSQ9NLmx5MbGya1P49NCRoQg9UG1MTA5RZEbegsYemVE1gMU1JBRZhF9dkccHGAkUXZmfe/HooJJTCzs6b5dB+yV7m/b7v9/veezvvNw/4H4EVWjASiWzNZrOvAjhCRHsBBACUA3gE4AGAUQDfA7iuadrjQuYumJm2trYyRVE+YIy9B6AkD0qGMfaVoihfHj16dK4QNRTEjK7rxwCcBbBdgv4HY+zturq6y17r4F7IRMR0XT8FQIecEQDYTkSXOjs7PyIiT5Pr80Kurq7+GMCn8L7CjDFWG4vFrHA4fENaRJa4vLV0LxrrwAZwTNO0bhmyVCHd3d2lpmkmIL+1cmHWNM09DQ0Ns26JUv8Z0zQ/xOYYAYAyRVHelyG6XplIJLLVMIwZ5Pf6lUUGwNNuzyHFbZblA9HRiKIomVAoNBgIBHZzznfYtj2dTqcno9HoASGEE99PRK8A6HJTm8w2O+IUoChK5tChQ5PBYLCGc14JYAvnvDIYDNYcPnw47vP5FguRZy1cmyGiF5xiQqHQoKqq1euNqaq6LxQKRZ00GGN73dYmszI7nQICgcDunAI7dz5biDxrIWOm3FGU8x1expfxVN4Vrei6JQBYcAqwbXs61zgRpfPI82feFS1DxsyMU0A6nZ7MNT41NZXMI0/OCVkPMmYGnQKi0egB0zTvrDeWzWbvDA4OHnTSYIw55lkL12YYYz85xQghSnp6ep5LpVJ9tm3fB5C1bft+KpXq6+3tfV4IUeykQUR9bmtzfWgS0WUALQC25YoTQpT09/fXrHr0zPIvH8wvLS25/r5xvTKapj0mom/d8lzifGNj4xO3JKlG07KszwA8lOHmgYemaX4hQ5Qys9yeH5fh5oHjMu0/4PHDStf1NgCve9FYDSFEx8mTJ9/lnBcVEZUYjBWpRMwSXAUAxWebFuc2Y2xxi2E82Tc1NRcGxArfq5ltAIYAVHlyAcAwjLmW06fPzs7OLuXLIWKCEZIKp5tjyWTS04WGpmnzAN7AqtmRBF27ejXixggAMEY+cNpjAW9WVVVVeTIDAJqm3SKiJi8ao8PDt24PDCQ9SDCfbQc9mwGAioqKUwAc2/r1MD83lw53dv7sJb8N2ILzREHM1NbWWrZtNyCPJnQ1hBDmpXC4yzAM+W1KlGU+3+VkMjldEDMAUF9fnwBwwg0n2t9/PTEx8UgyJREQKxLi60QiMQxswsW5rus6gDqnuOl0eqzlzJlOiRSLRPQbFOWXRCLxj4PbdW/mBMuy3iGil1VVLdsoJmsYTzra23vz1SRiFhjFifORysrKWF9fn7VeXMFXBgDOnTt3pLS09MoG+nStp6fj1s2bE7k0iJjJYd9jnI/YPt9YPB43nPJuihkAaG1tbSsvL/9XdzB+9+7AhfPnf9iAtgjGJjkwrvr9sZGRkaybnAXfZisoLi5+K5PJvOT3+ytXni0sLPz+XXv7j6vjCMiAaELhfPTF/fvj4XBY+s22aSsDAM3NzQeDweANzrkqhBAdFy9+Mzo6OgNgHozFfcD4a/fuTXzy94W5Z2yqGQBoamr6fNeuXSeGfh3qutJ16QIUJTY+Pv4AAG127v80/gIGr+iWe+FGsAAAAABJRU5ErkJggg==',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAToSURBVFiF3VhdbFNlGH7ec05/F6IUE9GLIYgXXYpXJBBZE0xM9EausIl6ObzBGSHRdnEJ1p+RhnBBNF4YY/xJFigNaIwxLpFYB2WwMWCW0bG1W7eEdUBwQ0fb7fy83nQJjK3nnO90F/okvTnf+7zP+/Q75/ve7wP+R6BGJ4xGo+skSXqFmfcAaAHwFIANAO4CmCai64Zh/OT3+3+Nx+PzjdRumJmOjo71zNwB4B0APguUMjN/vri4mDh27NhcI2poiJloNLqXiL4EEBCg/8XMbx05cuS00zpkh3yKxWKHiOgLAH7BHD4iiuzatcvIZDJnnRTjyEw0Gv2QiD6C8xkmInqxtbVVy2QyvcJJRIm1V+ukkxwrwCCivYlE4gcRslAhBw4ceNzj8RQg9o2YYZaInk0kErN2iZKImtvt/gBrYwQA1gN4X4Roe2ai0eg6IroFa8uvKMo+n+9Ju/uQYleltiGaGnG73eVIJNIfDAa3yLK8Udf1mVwuN55MJneoqmrG91er1ZcBnLJVm51gAKjt7HXhdrvLnZ2d46FQaLcsy80A3LIsN4dCod2dnZ15l8tVaYTOcoh8M0GzgEgk0u/xeEIrjXm93m2RSOSiBZ0Wu4WJmHnaLCAYDG6pN97S0rK5ETrLIWJmg1mALMsbnYzX8ITlimoQMfOPWYCu6zMm4yULOn9brqgGETO3zAJyudx4vfFr164VzXIwc90/ZCWImOk3C0gmkzuq1Wp2pbFyuZxNpVI7zXIQkanOcoiY+d0sQFVVX1dX19ZsNpvWdX0SwKKu65NDQ0Ppw4cPP6dpmtcsBzOn7RZme9P0+XynK5XKZwAeqxenqqqvu7t79wOPNtV+VnDPMAzb5xvbM1NrMb6xy7OJr48ePXrfLkmo0SSijwHcFuFawG0i+lSEKGSm1p4fFOFawEGR9h9weLCKxWLdAN5wkuNBMPPxEydOvC1JksfD7Fsg8riYSdMlFwAosqFqkmQQUcW9sHB/282bcylAX+LbXgCWYT+AFwA84zAPVFWdO9PTM+WWpHcBQCeCAoCJICsMAGAQZGaAGZrLhcubNutbGUVF4rMjxWLR8ZE3Fou1AkjDwX0CM/OVwcHvJwqFomgKDfjO6e0MMpnMVDgc9gIIi+YoTU+fyw4NXXFQBpFh3BFaAJbD6/UeAmClrX8ElXK5dOnixT+c6BuAoUtSoSFm4vG4ZhjGm7DQhD5UhGGoAwMDp1RV1c2jVwHzIsny6WKxOOP4NVvC+fPnZ8Ph8F0Ar1rlFPL5X8bHxuo2pXXADIx4df3kjcnJSWANLs5jsdhJAK+Zxd2bmxv5racnKSBRYeY/oSiDhULhoY3b6dL8CDRN209EL8myvH7VGFW9f6Gv72erOZlJA3GeJWm4ubk5l06ntZXiGj4zANDe3r6nqanpx1Xyc/bq1eOjN26M1cvBTKoEY4IkadiQ5ZF8Pr9gprsmZgCgvb29u6mp6ZHuYKZUupDp7e1ZhVYB0bgEjLr8/tzw8PCiHc2Gv2ZLmJ+fb1MUpdXj8TQvPatWq3f6+/rOPBjHQBnMY4okXX9++/Z8KpUSXtnWbGYAYN++fTsDgUAvEbkMw9AvnDv3ValUugXgHojyMjD6+sTEWBwwGqG3pmYAoK2t7ZNAIPDe1OTUqSuXBr6FouRGR0enAfBaa/+n8S8PPeWMetb8+wAAAABJRU5ErkJggg==',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATISURBVFiF3VhNbBtFGH0z3vXGbqpSikQBKSIOHKgop0quYtMadSsqVfRCoQo9IjiAuAXJ4lB+D0Q5Ig4VQvxIVZREKQhRRNoiNi2VcBECUaUNjmM7VRPHcdP81HGc/ZmPSyKVNMnuzjoHeEfPe9/73s54dnaA/xFYowsmEont0Wj0iBDiGGNsD4BHAOwCMANgEsB1IvrOcZwfDcOoNtK7YWGOHj260zTNNBG9BSDiQVID8Ilt2x8bhjHXiB4aEubQoUPHGWOnATwoIb8D4LWLFy+eDdpHKKCeHT58+BSATwFEJWtEALzc2toqCoXC5SDNBAqj6/q7AN5H8BlmjLHnYrGYnc/nL0kXkRWuLK2+IDXWgWCMHb9w4cI3MmKpRlKp1AOKooxB7j/ihllN09rOnTs361fIZdwURXkHWxMEAHaapvm2jND3zCQSie2RSKQMb9uvLGq2bT/s9z2k+HWJRqNHiMg1iKZptXQ6fTUej8dUVd1tWdZUJpPJd3V1xev1ups+qijK8wAG/PTme5kJIY65cTRNq/X29uaTyWRKVdUWAGFVVVuSyWSqp6cn19TUtOTBytVnLXyHYYw95cZJp9NXt23b9vR6Y83NzXs7OzszHqz2+O1NZgN41I0Qj8djm423t7e3NsJnLWTC7HIjqKq6O8j4Ch7y3NEKZMLcdSNYljXlMl7y4LPguaMVyIQpuxEymUx+s/ErV64UPfhs+kDWg+8wRHTVjdPV1RWvVqvX1hurVqvXuru793uwcvVZC5nd7Gc3Tr1ej3R0dDwxNDRkWJY1DsC0LGvcMAzjxIkTT5qm2eTBx/Ddm19BKpVqVhTlFoAdfrU+MM85f+z8+fOLfkS+Z2bliPGFX50fMMY+9xsEkDxoapr2AYBpGa0HTIfD4Y9khFIfZ6Ojo/VYLDYJ4EUZvQteHxwc/E1GGOjDStf1MwBeCVJjDXqy2eybnHNNI4osM6apRMx2uAoASkhYNueCMbYUXl5e3DsxMdcPOKvioGF2ENGfjLHHg2UAhBBzpVu3TlumWfeqIWIOIxQVTpdHisVi4E9eXdeTAAwEuE8gIpqpVL6uLiwUZUvYwFdBb2eQz+dvtrW1NQF4VrbGUq32y+zMzB8B2mBMiIrUbrYWlmWdAuDlWH8fbMsqzUxPDwXxF4BwOB9rSBjDMGwhxEl4OITeCyKyKpXKgOM4jjt7wyImC4XOFovFqcDLbBWFQmE2FovNAHjBq+buwsIP1fn5TQ+lm4AIGGlynL6/x8fHgS24ONd1vQ/AS248yzRHJm7e7JWwWCKiv6Aov4+Njf3rxe37QsMNtm2/wTnXOec7N+KQEIvlcvl7rzWJmA1GOeJ8uKWl5YZhGPZ6vIbPDAAcOHDgWDgc/naD+jR7+3bP/Nzc6GY1iJjFIQqM82ERCo3kcrllN98tCQMABw8ePKOq6n2ng6Va7dfy5OTgBrIlMJbnQFaNRm8MDw+bfjwbvsxWwRh71XGcZCgUaln9zXGcynSp9NO9PAJqIBpVOL/+zL59uf7+fumdbctmBgASicT+SCRyCYBKRE6lVPqsVquVAcyDsVwIyHYUCqPvAaIRflsaBgCSyeSHmqZ1Lt5dHLhze/pLKMqNbDY7CYC22vs/jX8A/Nff8x41WYEAAAAASUVORK5CYII=',
                anchor: [
                    0.5,
                    1
                ]
            },
            {
                src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAPjSURBVFiF3ZlNbxtVFIafe2cceyZxEitfqiMs1EUWSLDqggXskOiGSqCyoAj+AH8BChISAv5ABahCBaoGJziISAhWMR8LECBQUNo0cZpJpLQNVWMDTZxre+ayMIGQOp7J2DMFXuls5p57zvver7lzBv5HEBHETAMngVPAA8AxYAi4DVwHLgOfAJ8BdyLI3xVkgDeAHUAHsG3gdWDwXpBth9M0Rz6IiIN2G3gqfsp3QwBnAY9wQvbMA14immUfGC/TmYiD9mK89P/GaTqfkYPmAk/GKQKamzbsHvGzLZqHSWx4MwIR++21uISkCX78hrVtoO+oxGQIMScBy8/Jtu2dQqFQVEqta61rSqn16enpomVZ1QA5bODxENyOjPfxGVnbtrcrlcrPugXK5fK8ZVlBZvZCHGK+9yNSKBTmWgnZQz6fnwsg5rs4xFz3I6KUWmsnRinlBBCzcVRiYd64Cuhp56C1rvn4KCFE0idPDfDz+QfCHAC/+znUarWbPu03AuT5LTCjPxFGzKafw+zs7LV27TMzM06APG0HpFt4F5/1blnWTrlcnm+1X7a2tuZTqVTVLwZwPg4xzwcgoi3L2snn83NKKae555UzOTk5F1CIBp6LQ0wfUAlIKKxVgN6jEguzZ+7QXGpR4jzNK00syNA8CKKYlU1ivjUDnOkC8VZ2JiyhTj9TL3aSvAUu5XK5F6SUyaTWlhIimdBaNFyZADANr96Q0hNCVHuU2n5wY6My1fygAzoXMwD8BNzfYRyklJVcNvuWaZq7QftoLVyhcUypv1p0HKcbBYRHgCJgdBBDjwwNvTeQTjth+zfgQicE9rAOpIBHwwbo6+39ejiT+bEDDkJ43q0wR3MrnAW+DdPRNIwbY8PDX3SS3APPlXKlW2IawLMEuITuhxCiPjoy8pEQwvX3PgRa14RhFBzHudmNZbaHMs2KzRNBOwz29386kE63vZS2gdawmHLd/NW1tTWIpoKYB572c0r29Czel81+GCJ+VWs9j2n+sLKy8sv+hijEDAshlrTWh77FpRDb4+Pj55KmGejKorVoIHRJS7mQy+WuFIvFRiu/SGq7hmGccl3340Pi6+FM5tLgwMByuxhai7rEWxVSLniGsVgqlZRf3sgK1YlE4mK9Xr/rdmBb1jfZsbHPD+lWRYhrEpYStn1lYWGhdpScUVbdU1LKq57n5fYeGIZxK5fNvm0Yxl/LRMMOWi+bUl5+6MSJ0tTUVOiTLdJfCJZlPby7u/ul1joBuMdGR9/pte1N4FeEKBmw9Mzq6vIrzQL8vx+pVOpVIUS1v6//g4njxx+bmJgY5x7/h/lP4A+AJ7grnrOyCgAAAABJRU5ErkJggg==',
                anchor: [
                    0.5,
                    1
                ]
            }
        ];
        if (!this.options.labels) {
            this.options.labels = {};
        }
        Object.keys(Drawing.DefaultLabels).forEach(function (key) {
            if (!this.options.labels.hasOwnProperty(key)) {
                this.options.labels[key] = Drawing.DefaultLabels[key];
            }
        }, this);
        if (!this.options.defaultStyles) {
            this.options.defaultStyles = {};
        }
        Object.keys(Drawing.DefaultStyles).forEach(function (key) {
            if (!options.defaultStyles.hasOwnProperty(key)) {
                this.options.defaultStyles[key] = Drawing.DefaultStyles[key];
                return;
            }
            if (key == 'polyFillOpacity' && (options.defaultStyles[key] < 0 || options.defaultStyles[key] > 1)) {
                console.log('Wrong value (' + options.defaultStyles[key] + ') for defaultStyles.polyFillOpactity. Must be between 0 and 1');
                this.options.defaultStyles[key] = Drawing.DefaultStyles[key];
                return;
            }
            if (key == 'strokeWidth' || key == 'polyStrokeWidth') {
                var intValue = parseInt(options.defaultStyles[key], 10);
                if (isNaN(intValue) || intValue < 0) {
                    console.log('Wrong value (' + options.defaultStyles[key] + ') for defaultStyles.strokeWidth. Must be a positive interger value.');
                    this.options.defaultStyles[key] = Drawing.DefaultStyles[key];
                    return;
                }
                this.options.defaultStyles[key] = intValue;
            }
        }, this);
        this.interaction = null;
        this.stylingOvl = null;
        this.layer = null;
        if (this.options.layer && this.options.layer instanceof ol.layer.Vector) {
            this.layer = this.options.layer;
        }
        this._isDesktop = this._detectSupport();
    };
    Drawing.prototype._createEmptyLayer = function () {
        var features = new ol.Collection();
        var layer = new ol.layer.Vector({ source: new ol.source.Vector({ features: features }) });
        layer.gpResultLayerId = 'drawing';
        this.setLayer(layer);
    };
    Drawing.prototype.setLayer = function (vlayer) {
        if (!vlayer) {
            this.layer = null;
            return;
        }
        if (!(vlayer instanceof ol.layer.Vector)) {
            console.log('no valid layer given for hosting drawn features.');
            return;
        }
        var layers = this.getMap().getLayers();
        if (layers) {
            var found = false;
            layers.forEach(function (mapLayer) {
                if (mapLayer == vlayer) {
                    found = true;
                }
            }, this);
            if (!found) {
                this.getMap().addLayer(vlayer);
            }
            vlayer.getSource().getFeatures().forEach(function (feature) {
                var featureStyleFunction = feature.getStyleFunction();
                if (featureStyleFunction) {
                    var styles = featureStyleFunction.call(feature, 0);
                    if (styles && styles.length !== 0) {
                        feature.setStyle(styles[0]);
                    }
                }
            });
        }
        this.layer = vlayer;
    };
    Drawing.prototype._detectSupport = function () {
        var isDesktop = true;
        var userAgent = window.navigator.userAgent.toLowerCase();
        if (userAgent.indexOf('iphone') !== -1 || userAgent.indexOf('ipod') !== -1 || userAgent.indexOf('ipad') !== -1 || userAgent.indexOf('android') !== -1 || userAgent.indexOf('mobile') !== -1 || userAgent.indexOf('blackberry') !== -1 || userAgent.indexOf('tablet') !== -1 || userAgent.indexOf('phone') !== -1 || userAgent.indexOf('touch') !== -1) {
            isDesktop = false;
        }
        if (userAgent.indexOf('msie') !== -1 || userAgent.indexOf('trident') !== -1) {
            isDesktop = true;
        }
        return isDesktop;
    };
    Drawing.prototype._initContainer = function () {
        var container = this._createMainContainerElement();
        var inputShow = this._showDrawingContainer = this._createShowDrawingElement();
        container.appendChild(inputShow);
        var picto = this._createShowDrawingPictoElement();
        container.appendChild(picto);
        var panel = this._createDrawingPanelElement();
        container.appendChild(panel);
        return container;
    };
    Drawing.prototype._drawEndFeature = function (feature, geomType) {
        var style = null;
        switch (geomType) {
        case 'Point':
            style = new ol.style.Style({ image: new ol.style.Icon(this._getIconStyleOptions(this.options.markersList[0])) });
            break;
        case 'LineString':
            style = new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: this.options.defaultStyles.strokeColor,
                    width: this.options.defaultStyles.strokeWidth
                })
            });
            break;
        case 'Polygon':
            style = new ol.style.Style({
                fill: new ol.style.Fill({ color: this.hexToRgba(this.options.defaultStyles.polyFillColor, this.options.defaultStyles.polyFillOpacity) }),
                stroke: new ol.style.Stroke({
                    color: this.options.defaultStyles.polyStrokeColor,
                    width: this.options.defaultStyles.polyStrokeWidth
                })
            });
            break;
        }
        feature.setStyle(style);
        var popupOvl = null;
        var context = this;
        var setAttValue = function (value, save) {
            context.getMap().removeOverlay(popupOvl);
            if (save && value && value.trim().length > 0) {
                var formated = value.replace(/\n/g, '<br>');
                feature.setProperties({ description: formated });
            }
        };
        var popup = this._createLabelDiv({
            applyFunc: setAttValue,
            inputId: this._addUID('att-input'),
            placeholder: 'Saisir une description...',
            geomType: geomType
        });
        popupOvl = new ol.Overlay({
            element: popup,
            positioning: 'top-center'
        });
        this.getMap().addOverlay(popupOvl);
        var geomExtent = feature.getGeometry().getExtent();
        popupOvl.setPosition([
            (geomExtent[0] + geomExtent[2]) / 2,
            (geomExtent[1] + geomExtent[3]) / 2
        ]);
        document.getElementById(this._addUID('att-input')).focus();
    };
    Drawing.prototype._createRemoveInteraction = function () {
        var interaction = new ol.interaction.Select({ layers: [this.layer] });
        interaction.on('select', function (seEv) {
            if (!seEv || !seEv.selected || seEv.selected.length == 0) {
                return;
            }
            this.layer.getSource().removeFeature(seEv.selected[0]);
            this.getMap().removeInteraction(this.interaction);
            this.interaction = this._createRemoveInteraction();
            this.getMap().addInteraction(this.interaction);
        }, this);
        return interaction;
    };
    Drawing.prototype._createStylingInteraction = function () {
        var interaction = new ol.interaction.Select({ layers: [this.layer] });
        interaction.on('select', function (seEv) {
            if (this.stylingOvl) {
                this.getMap().removeOverlay(this.stylingOvl);
            }
            if (!seEv || !seEv.selected || seEv.selected.length == 0) {
                return;
            }
            var valuesColor = null;
            var hexColor = null;
            var popupOvl = null;
            var geomType = null;
            var initValues = {};
            if (seEv.selected[0].getGeometry() instanceof ol.geom.Point) {
                var _label = seEv.selected[0].getProperties().name;
                if (seEv.selected[0].getStyle().getText() && _label) {
                    geomType = 'Text';
                    if (seEv.selected[0].getStyle().getText().getStroke() && seEv.selected[0].getStyle().getText().getStroke().getColor()) {
                        valuesColor = seEv.selected[0].getStyle().getText().getStroke().getColor();
                        if (Array.isArray(valuesColor)) {
                            valuesColor = 'rgba(' + valuesColor.join() + ')';
                            hexColor = this.rgbaToHex(valuesColor);
                            initValues.strokeColor = hexColor.hex;
                            initValues.strokeOpacity = hexColor.opacity;
                        } else {
                            initValues.strokeColor = valuesColor;
                        }
                    }
                    if (seEv.selected[0].getStyle().getText().getFill() && seEv.selected[0].getStyle().getText().getFill().getColor()) {
                        valuesColor = seEv.selected[0].getStyle().getText().getFill().getColor();
                        if (Array.isArray(valuesColor)) {
                            valuesColor = 'rgba(' + valuesColor.join() + ')';
                            hexColor = this.rgbaToHex(valuesColor);
                            initValues.fillColor = hexColor.hex;
                            initValues.fillOpacity = hexColor.opacity;
                        } else {
                            initValues.fillColor = valuesColor;
                        }
                    }
                    initValues.strokeColor = initValues.hasOwnProperty('strokeColor') ? initValues.strokeColor : this.options.defaultStyles.textStrokeColor;
                    initValues.fillColor = initValues.hasOwnProperty('fillColor') ? initValues.fillColor : this.options.defaultStyles.textFillColor;
                } else if (seEv.selected[0].getStyle() && seEv.selected[0].getStyle().getImage()) {
                    geomType = 'Point';
                    if (seEv.selected[0].getStyle().getImage().getSrc()) {
                        initValues.markerSrc = seEv.selected[0].getStyle().getImage().getSrc();
                    } else {
                        initValues.markerSrc = this.options.markersList[0].src;
                    }
                }
            } else if (seEv.selected[0].getGeometry() instanceof ol.geom.LineString) {
                geomType = 'Line';
                if (seEv.selected[0].getStyle() && seEv.selected[0].getStyle().getStroke()) {
                    if (seEv.selected[0].getStyle().getStroke().getWidth()) {
                        initValues.strokeWidth = seEv.selected[0].getStyle().getStroke().getWidth();
                    }
                    if (seEv.selected[0].getStyle().getStroke().getColor()) {
                        valuesColor = seEv.selected[0].getStyle().getStroke().getColor();
                        if (Array.isArray(valuesColor)) {
                            valuesColor = 'rgba(' + valuesColor.join() + ')';
                            hexColor = this.rgbaToHex(valuesColor);
                            initValues.strokeColor = hexColor.hex;
                            initValues.fillOpacity = hexColor.opacity;
                        } else {
                            initValues.strokeColor = valuesColor;
                        }
                    }
                }
                initValues.strokeWidth = initValues.hasOwnProperty('strokeWidth') ? initValues.strokeWidth : this.options.defaultStyles.strokeWidth;
                initValues.strokeColor = initValues.hasOwnProperty('strokeColor') ? initValues.strokeColor : this.options.defaultStyles.strokeColor;
            } else if (seEv.selected[0].getGeometry() instanceof ol.geom.Polygon) {
                geomType = 'Polygon';
                if (seEv.selected[0].getStyle() && seEv.selected[0].getStyle().getStroke()) {
                    if (seEv.selected[0].getStyle().getStroke().getWidth()) {
                        initValues.strokeWidth = seEv.selected[0].getStyle().getStroke().getWidth();
                    }
                    if (seEv.selected[0].getStyle().getStroke().getColor()) {
                        valuesColor = seEv.selected[0].getStyle().getStroke().getColor();
                        if (Array.isArray(valuesColor)) {
                            valuesColor = 'rgba(' + valuesColor.join() + ')';
                            hexColor = this.rgbaToHex(valuesColor);
                            initValues.strokeColor = hexColor.hex;
                            initValues.strokeOpacity = hexColor.opacity;
                        } else {
                            initValues.strokeColor = valuesColor;
                        }
                    }
                }
                if (seEv.selected[0].getStyle() && seEv.selected[0].getStyle().getFill()) {
                    if (seEv.selected[0].getStyle().getFill().getColor()) {
                        valuesColor = seEv.selected[0].getStyle().getFill().getColor();
                        if (Array.isArray(valuesColor)) {
                            valuesColor = 'rgba(' + valuesColor.join() + ')';
                        }
                        hexColor = this.rgbaToHex(valuesColor);
                        initValues.fillColor = hexColor.hex;
                        initValues.fillOpacity = hexColor.opacity;
                    }
                }
                initValues.strokeWidth = initValues.hasOwnProperty('strokeWidth') ? initValues.strokeWidth : this.options.defaultStyles.polyStrokeWidth;
                initValues.strokeColor = initValues.hasOwnProperty('strokeColor') ? initValues.strokeColor : this.options.defaultStyles.polyStrokeColor;
                initValues.fillColor = initValues.hasOwnProperty('fillColor') ? initValues.fillColor : this.options.defaultStyles.polyFillColor;
                initValues.fillOpacity = initValues.hasOwnProperty('fillOpacity') ? initValues.fillOpacity : this.options.defaultStyles.polyFillOpacity;
            }
            if (!geomType) {
                console.log('Unhandled geometry type for styling.');
                return;
            }
            var dtObj = this;
            var applyStyle = function (action) {
                if (action == 'cancel') {
                    dtObj.getMap().removeOverlay(popupOvl);
                    return;
                }
                var setDefault = action == 'apply' ? false : true;
                var fillColorElem = document.getElementById(dtObj._addUID('fillColor'));
                var fillOpacityElem = document.getElementById(dtObj._addUID('fillOpacity'));
                var strokeColorElem = document.getElementById(dtObj._addUID('strokeColor'));
                var strokeWidthElem = document.getElementById(dtObj._addUID('strokeWidth'));
                switch (geomType.toLowerCase()) {
                case 'text':
                    if (setDefault) {
                        dtObj.options.defaultStyles.textStrokeColor = strokeColorElem.value;
                        dtObj.options.defaultStyles.textFillColor = fillColorElem.value;
                    } else {
                        seEv.selected[0].setStyle(new ol.style.Style({
                            text: new ol.style.Text({
                                font: '16px sans',
                                textAlign: 'left',
                                text: seEv.selected[0].getStyle().getText().getText(),
                                fill: new ol.style.Fill({ color: fillColorElem.value }),
                                stroke: new ol.style.Stroke({
                                    color: strokeColorElem.value,
                                    width: 3
                                })
                            })
                        }));
                    }
                    break;
                case 'point':
                    var markerSelected = dtObj._getsMarkersOptionsFromSrc(document.querySelector('input[name=\'marker\']:checked').value);
                    if (setDefault) {
                        if (dtObj.options.markersList.length > 1) {
                            var idxMarker = dtObj.options.markersList.findIndex(function (mrk) {
                                if (mrk == markerSelected) {
                                    return true;
                                }
                                return false;
                            });
                            if (idxMarker > 0) {
                                dtObj.options.markersList.splice(idxMarker, 1);
                                dtObj.options.markersList.splice(0, 0, markerSelected);
                            }
                        }
                    } else {
                        seEv.selected[0].setStyle(new ol.style.Style({ image: new ol.style.Icon(dtObj._getIconStyleOptions(markerSelected)) }));
                    }
                    break;
                case 'line':
                    if (setDefault) {
                        dtObj.options.defaultStyles.strokeColor = strokeColorElem.value;
                        dtObj.options.defaultStyles.strokeWidth = parseInt(strokeWidthElem.value, 10);
                    } else {
                        seEv.selected[0].setStyle(new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                width: parseInt(strokeWidthElem.value, 10),
                                color: strokeColorElem.value
                            })
                        }));
                    }
                    break;
                case 'polygon':
                    var opacity = parseInt(fillOpacityElem.value, 10) / 10;
                    if (setDefault) {
                        dtObj.options.defaultStyles.polyStrokeColor = strokeColorElem.value;
                        dtObj.options.defaultStyles.polyFillColor = fillColorElem.value;
                        dtObj.options.defaultStyles.polyFillOpacity = opacity;
                        dtObj.options.defaultStyles.polyStrokeWidth = parseInt(strokeWidthElem.value, 10);
                    } else {
                        seEv.selected[0].setStyle(new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                width: parseInt(strokeWidthElem.value, 10),
                                color: strokeColorElem.value
                            }),
                            fill: new ol.style.Fill({ color: dtObj.hexToRgba(fillColorElem.value, opacity) })
                        }));
                    }
                    break;
                }
                if (!setDefault) {
                    dtObj.getMap().removeOverlay(popupOvl);
                }
            };
            var popupDiv = this._createStylingDiv({
                geomType: geomType,
                initValues: initValues,
                applyFunc: applyStyle
            });
            popupOvl = new ol.Overlay({
                element: popupDiv,
                positioning: 'top-center'
            });
            this.getMap().addOverlay(popupOvl);
            popupOvl.setPosition(seEv.mapBrowserEvent.coordinate);
            this.stylingOvl = popupOvl;
            this.getMap().removeInteraction(this.interaction);
            this.interaction = this._createStylingInteraction();
            this.getMap().addInteraction(this.interaction);
        }, this);
        return interaction;
    };
    Drawing.prototype._createLabelInteraction = function () {
        var interaction = new ol.interaction.Select({ layers: [this.layer] });
        interaction.on('select', function (seEv) {
            if (this.labelOvl) {
                this.getMap().removeOverlay(this.labelOvl);
            }
            if (!seEv || !seEv.selected || seEv.selected.length == 0) {
                return;
            }
            var popupOvl = null;
            var geomType = null;
            var textValue = null;
            if (seEv.selected[0].getGeometry() instanceof ol.geom.Point) {
                var _label = seEv.selected[0].getProperties().name;
                if (seEv.selected[0].getStyle() && seEv.selected[0].getStyle().getText() && _label) {
                    geomType = 'Text';
                } else if (seEv.selected[0].getStyle() && seEv.selected[0].getStyle().getImage()) {
                    geomType = 'Point';
                }
            } else if (seEv.selected[0].getGeometry() instanceof ol.geom.LineString) {
                geomType = 'Line';
            } else if (seEv.selected[0].getGeometry() instanceof ol.geom.Polygon) {
                geomType = 'Polygon';
            }
            if (!geomType) {
                console.log('Unhandled geometry type for styling.');
                return;
            }
            if (geomType == 'Text') {
                textValue = seEv.selected[0].getStyle().getText().getText();
            } else {
                var featProps = seEv.selected[0].getProperties();
                if (featProps && featProps.hasOwnProperty('description')) {
                    textValue = featProps['description'];
                }
            }
            var context = this;
            var setTextValue = function (value, save) {
                context.getMap().removeOverlay(popupOvl);
                if (!save) {
                    return;
                }
                var feature = seEv.selected[0];
                if (geomType == 'Text') {
                    var style = feature.getStyle();
                    style.getText().setText(value);
                    feature.setProperties({ name: value });
                    feature.setStyle(style);
                    return;
                }
                var formated = value.replace(/\n/g, '<br>');
                feature.setProperties({ description: formated });
            };
            var popupDiv = this._createLabelDiv({
                applyFunc: setTextValue,
                inputId: this._addUID('label-input'),
                placeholder: geomType == 'Text' ? 'Saisir un label...' : 'Saisir une description...',
                text: textValue,
                geomType: geomType
            });
            popupOvl = new ol.Overlay({
                element: popupDiv,
                positioning: 'top-center'
            });
            this.getMap().addOverlay(popupOvl);
            popupOvl.setPosition(seEv.mapBrowserEvent.coordinate);
            document.getElementById(this._addUID('label-input')).focus();
            this.labelOvl = popupOvl;
            this.getMap().removeInteraction(this.interaction);
            this.interaction = this._createLabelInteraction();
            this.getMap().addInteraction(this.interaction);
        }, this);
        return interaction;
    };
    Drawing.prototype._handleToolClick = function (clickEvent, toolId, context) {
        var map = context.getMap();
        if (!map) {
            return;
        }
        Interactions.unset(map, { current: 'Drawing' });
        if (context.interaction) {
            map.removeInteraction(context.interaction);
            context.interaction = null;
        }
        if (!this.layer) {
            this._createEmptyLayer();
        }
        switch (toolId) {
        case this._addUID('drawing-tool-point'):
            if (context.dtOptions['points'].active) {
                context.interaction = new ol.interaction.Draw({
                    features: context.layer.getSource().getFeaturesCollection(),
                    style: new ol.style.Style({ image: new ol.style.Icon(this._getIconStyleOptions(this.options.markersList[0])) }),
                    type: 'Point'
                });
                context.interaction.on('drawend', function (deEv) {
                    context._drawEndFeature(deEv.feature, 'Point');
                }, context);
            }
            break;
        case this._addUID('drawing-tool-line'):
            if (context.dtOptions['lines'].active) {
                context.interaction = new ol.interaction.Draw({
                    features: context.layer.getSource().getFeaturesCollection(),
                    style: new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: this.options.cursorStyle.radius,
                            stroke: new ol.style.Stroke({
                                color: this.options.cursorStyle.strokeColor,
                                width: this.options.cursorStyle.strokeWidth
                            }),
                            fill: new ol.style.Fill({ color: this.options.cursorStyle.fillColor })
                        }),
                        stroke: new ol.style.Stroke({
                            color: this.options.defaultStyles.strokeColor,
                            width: this.options.defaultStyles.strokeWidth
                        })
                    }),
                    type: 'LineString'
                });
                context.interaction.on('drawend', function (deEv) {
                    context._drawEndFeature(deEv.feature, 'LineString');
                }, context);
            }
            break;
        case this._addUID('drawing-tool-polygon'):
            if (context.dtOptions['polygons'].active) {
                context.interaction = new ol.interaction.Draw({
                    features: context.layer.getSource().getFeaturesCollection(),
                    style: new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: this.options.cursorStyle.radius,
                            stroke: new ol.style.Stroke({
                                color: this.options.cursorStyle.strokeColor,
                                width: this.options.cursorStyle.strokeWidth
                            }),
                            fill: new ol.style.Fill({ color: this.options.cursorStyle.fillColor })
                        }),
                        stroke: new ol.style.Stroke({
                            color: this.options.defaultStyles.polyStrokeColor,
                            width: this.options.defaultStyles.polyStrokeWidth
                        }),
                        fill: new ol.style.Fill({ color: this.hexToRgba(this.options.defaultStyles.polyFillColor, this.options.defaultStyles.polyFillOpacity) })
                    }),
                    type: 'Polygon'
                });
                context.interaction.on('drawend', function (deEv) {
                    context._drawEndFeature(deEv.feature, 'Polygon');
                }, context);
            }
            break;
        case this._addUID('drawing-tool-text'):
            if (context.dtOptions['text'].active) {
                context.interaction = new ol.interaction.Draw({
                    features: context.layer.getSource().getFeaturesCollection(),
                    style: new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: this.options.cursorStyle.radius,
                            stroke: new ol.style.Stroke({
                                color: this.options.cursorStyle.strokeColor,
                                width: this.options.cursorStyle.strokeWidth
                            }),
                            fill: new ol.style.Fill({ color: this.options.cursorStyle.fillColor })
                        })
                    }),
                    type: 'Point'
                });
                context.interaction.on('drawend', function (deEv) {
                    var popupOvl = null;
                    var setTextValue = function (value, save) {
                        context.getMap().removeOverlay(popupOvl);
                        if (!save) {
                            context.layer.getSource().removeFeature(deEv.feature);
                            return;
                        }
                        deEv.feature.setProperties({ name: value });
                        deEv.feature.setStyle(new ol.style.Style({
                            image: new ol.style.Icon(context._getIconStyleOptions(context.options.defaultStyles.textIcon1x1)),
                            text: new ol.style.Text({
                                textAlign: 'left',
                                font: '16px sans',
                                text: value,
                                fill: new ol.style.Fill({ color: context.options.defaultStyles.textFillColor }),
                                stroke: new ol.style.Stroke({
                                    color: context.options.defaultStyles.textStrokeColor,
                                    width: 3
                                })
                            })
                        }));
                    };
                    var popup = this._createLabelDiv({
                        applyFunc: setTextValue,
                        inputId: context._addUID('label-input'),
                        geomType: 'Text',
                        placeholder: 'Saisir un label...'
                    });
                    popupOvl = new ol.Overlay({
                        element: popup,
                        positioning: 'top-center'
                    });
                    context.getMap().addOverlay(popupOvl);
                    popupOvl.setPosition(deEv.feature.getGeometry().getCoordinates());
                    document.getElementById(this._addUID('label-input')).focus();
                }, context);
            }
            break;
        case this._addUID('drawing-tool-edit'):
            if (context.dtOptions['edit'].active) {
                context.interaction = new ol.interaction.Modify({
                    features: context.layer.getSource().getFeaturesCollection(),
                    style: new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: this.options.cursorStyle.radius,
                            stroke: new ol.style.Stroke({
                                color: this.options.cursorStyle.strokeColor,
                                width: this.options.cursorStyle.strokeWidth
                            }),
                            fill: new ol.style.Fill({ color: this.options.cursorStyle.fillColor })
                        })
                    }),
                    deleteCondition: function () {
                        return false;
                    }
                });
            }
            break;
        case this._addUID('drawing-tool-display'):
            if (context.dtOptions['display'].active) {
                context.interaction = this._createStylingInteraction();
            }
            break;
        case this._addUID('drawing-tool-tooltip'):
            if (context.dtOptions['tooltip'].active) {
                context.interaction = this._createLabelInteraction();
            }
            break;
        case this._addUID('drawing-tool-remove'):
            if (context.dtOptions['remove'].active) {
                context.interaction = context._createRemoveInteraction();
            }
            break;
        default:
        }
        if (context.interaction) {
            context.interaction.setProperties({
                name: 'Drawing',
                source: this
            });
            map.addInteraction(context.interaction);
        }
    };
    Drawing.prototype.onShowDrawingClick = function () {
        var map = this.getMap();
        Interactions.unset(map);
        this.collapsed = this._showDrawingContainer.checked;
        this.dispatchEvent('change:collapsed');
    };
    Drawing.prototype.onExportFeatureClick = function () {
        var content = this.exportFeatures();
        if (!content) {
            return;
        }
        var link = document.createElement('a');
        var charset = 'utf-8';
        link.setAttribute('href', 'data:application/vnd.google-earth.kml+xml;charset=' + charset + ',' + encodeURIComponent(content));
        link.setAttribute('download', this.getExportName() + '.kml');
        if (document.createEvent) {
            var event = document.createEvent('MouseEvents');
            event.initEvent('click', true, true);
            link.dispatchEvent(event);
        } else {
            link.click();
        }
    };
    return Drawing;
}({}, ol, gp, CommonUtilsSelectorID, Ol3ControlsUtilsInteractions, CommonControlsDrawingDOM, Ol3Utils, Ol3FormatsKML);
CommonControlsLocationSelectorDOM = function (ID) {
    var LocationSelectorDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.className = this._addUID('GPlocationPoint');
            container.className += ' GPwidget';
            return container;
        },
        _createLocationPointElement: function (id, display) {
            var div = document.createElement('div');
            div.id = this._addUID('GPlocationPoint_' + id);
            div.className = display ? 'GPflexInput GPlocationStageFlexInput' : 'GPflexInput GPlocationStageFlexInputHidden';
            div.style.cssText = '';
            return div;
        },
        _createLocationPointLabelElement: function (id, text) {
            var self = this;
            var labelOrigin = document.createElement('label');
            labelOrigin.id = this._addUID('GPlocationOriginLabel_' + id);
            labelOrigin.htmlFor = 'GPlocationOrigin_' + id;
            labelOrigin.innerHTML = text;
            labelOrigin.addEventListener('click', function (e) {
                var i = ID.index(this.id);
                var points = document.getElementsByClassName(self._addUID('GPlocationPoint'));
                for (var j = 0; j < points.length; j++) {
                    var tag = points[j].childNodes[0].id;
                    var id = ID.index(tag);
                    document.getElementById(self._addUID('GPlocationPoint_' + id)).style.cssText = '';
                }
                document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).value = '';
                document.getElementById(self._addUID('GPlocationOrigin_' + i)).value = '';
                document.getElementById(self._addUID('GPlocationPoint_' + i)).style.cssText = '';
                document.getElementById(self._addUID('GPlocationOriginPointer_' + i)).checked = false;
                document.getElementById(self._addUID('GPlocationOrigin_' + i)).className = 'GPlocationOriginVisible';
                document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).className = 'GPlocationOriginHidden';
                if (document.getElementById(self._addUID('GPlocationStageRemove_' + i))) {
                    document.getElementById(self._addUID('GPlocationStageRemove_' + i)).className = 'GPlocationStageRemove';
                }
                if (document.getElementById(self._addUID('GPlocationStageAdd'))) {
                    document.getElementById(self._addUID('GPlocationStageAdd')).className = '';
                }
                self.onLocationClearPointClick(e);
            });
            return labelOrigin;
        },
        _createLocationAutoCompleteteInputElement: function (id) {
            var self = this;
            var inputOrigin = document.createElement('input');
            inputOrigin.id = this._addUID('GPlocationOrigin_' + id);
            inputOrigin.className = 'GPlocationOriginVisible';
            inputOrigin.type = 'text';
            inputOrigin.placeholder = 'Saisir une adresse';
            inputOrigin.autocomplete = 'off';
            inputOrigin.addEventListener('keyup', function (e) {
                var charCode = e.which || e.keyCode;
                if (charCode === 13 || charCode === 10 || charCode === 38 || charCode === 40) {
                    return;
                }
                var i = ID.index(this.id);
                if (document.getElementById(self._addUID('GPlocationOrigin_' + i)).value.length > 2) {
                    document.getElementById(self._addUID('GPlocationAutoCompleteList_' + i)).style.display = 'block';
                } else {
                    document.getElementById(self._addUID('GPlocationAutoCompleteList_' + i)).style.display = 'none';
                }
                self.onAutoCompleteSearchText(e);
            });
            inputOrigin.addEventListener('keydown', function (e) {
                var charCode = e.which || e.keyCode;
                var container = document.getElementById(self._addUID('GPlocationAutoCompleteList_' + id));
                if (!container) {
                    return;
                }
                var curr = container.getElementsByClassName('GPautoCompleteProposal current');
                var list = container.getElementsByClassName('GPautoCompleteProposal');
                var length = list.length;
                if (!length) {
                    return;
                }
                var current = null;
                if (!curr.length) {
                    current = list[0];
                    current.className = 'GPautoCompleteProposal current';
                    current.style.color = '#000000';
                    current.style['background-color'] = '#CEDBEF';
                    return;
                } else {
                    current = curr[0];
                }
                var index = parseInt(ID.index(current.id), 10);
                var next = index === length - 1 ? list[0] : list[index + 1];
                var prev = index === 0 ? list[length - 1] : list[index - 1];
                current.style['background-color'] = '';
                current.style.color = '';
                prev.style['background-color'] = '';
                prev.style.color = '';
                next.style['background-color'] = '';
                next.style.color = '';
                switch (charCode) {
                case 38:
                    console.log('arrow up');
                    current.className = 'GPautoCompleteProposal';
                    prev.className = 'GPautoCompleteProposal current';
                    prev.style.color = '#000000';
                    prev.style['background-color'] = '#CEDBEF';
                    break;
                case 40:
                    console.log('arrow down');
                    current.className = 'GPautoCompleteProposal';
                    next.className = 'GPautoCompleteProposal current';
                    next.style.color = '#000000';
                    next.style['background-color'] = '#CEDBEF';
                    break;
                case 13:
                    console.log('enter');
                    current.click(e);
                    break;
                }
                current.focus();
            });
            return inputOrigin;
        },
        _createLocationCoordinateInputElement: function (id) {
            var self = this;
            var inputOriginCoord = document.createElement('input');
            inputOriginCoord.id = this._addUID('GPlocationOriginCoords_' + id);
            inputOriginCoord.className = 'GPlocationOriginHidden';
            inputOriginCoord.type = 'text';
            inputOriginCoord.disabled = false;
            inputOriginCoord.addEventListener('click', function () {
                var i = ID.index(this.id);
                document.getElementById(self._addUID('GPlocationOriginLabel_' + i)).click();
            });
            return inputOriginCoord;
        },
        _createLocationPointerShowInputElement: function (id) {
            var inputOriginPointer = document.createElement('input');
            inputOriginPointer.id = this._addUID('GPlocationOriginPointer_' + id);
            inputOriginPointer.type = 'checkbox';
            return inputOriginPointer;
        },
        _createLocationPointerInputElement: function (id) {
            var self = this;
            var labelOriginPointer = document.createElement('label');
            labelOriginPointer.id = this._addUID('GPlocationOriginPointerImg_' + id);
            labelOriginPointer.htmlFor = 'GPlocationOriginPointer_' + id;
            labelOriginPointer.className = 'GPlocationOriginPointerImg';
            labelOriginPointer.title = 'Pointer un lieu sur la carte';
            labelOriginPointer.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                var i = ID.index(this.id);
                var points = document.getElementsByClassName(self._addUID('GPlocationPoint'));
                var j;
                var tag;
                var id;
                for (j = 0; j < points.length; j++) {
                    tag = points[j].childNodes[0].id;
                    id = ID.index(tag);
                    if (i != id) {
                        document.getElementById(self._addUID('GPlocationOriginPointer_' + id)).checked = false;
                        if (document.getElementById(self._addUID('GPlocationOriginCoords_' + id)).value == 'Pointer un lieu sur la carte') {
                            document.getElementById(self._addUID('GPlocationOriginCoords_' + id)).value = '';
                            document.getElementById(self._addUID('GPlocationOrigin_' + id)).className = 'GPlocationOriginVisible';
                            document.getElementById(self._addUID('GPlocationOriginCoords_' + id)).className = 'GPlocationOriginHidden';
                        }
                    }
                }
                if (document.getElementById(self._addUID('GPlocationOriginPointer_' + i)).checked) {
                    document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).value = '';
                    for (j = 0; j < points.length; j++) {
                        tag = points[j].childNodes[0].id;
                        id = ID.index(tag);
                        document.getElementById(self._addUID('GPlocationPoint_' + id)).style.cssText = '';
                    }
                    if (document.getElementById(self._addUID('GPlocationStageRemove_' + i))) {
                        document.getElementById(self._addUID('GPlocationStageRemove_' + i)).className = 'GPlocationStageRemove';
                    }
                    if (document.getElementById(self._addUID('GPlocationStageAdd'))) {
                        document.getElementById(self._addUID('GPlocationStageAdd')).className = '';
                    }
                    document.getElementById(self._addUID('GPlocationOriginPointer_' + i)).checked = false;
                    document.getElementById(self._addUID('GPlocationOrigin_' + i)).className = 'GPlocationOriginVisible';
                    document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).className = 'GPlocationOriginHidden';
                } else {
                    document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).value = 'Pointer un lieu sur la carte';
                    for (j = 0; j < points.length; j++) {
                        tag = points[j].childNodes[0].id;
                        id = ID.index(tag);
                        if (i == id) {
                            document.getElementById(self._addUID('GPlocationPoint_' + id)).style.cssText = '';
                        } else {
                            document.getElementById(self._addUID('GPlocationPoint_' + id)).style.display = 'none';
                        }
                    }
                    if (document.getElementById(self._addUID('GPlocationStageRemove_' + i))) {
                        document.getElementById(self._addUID('GPlocationStageRemove_' + i)).className = 'GPlocationOriginHidden';
                    }
                    if (document.getElementById(self._addUID('GPlocationStageAdd'))) {
                        document.getElementById(self._addUID('GPlocationStageAdd')).className = 'GPlocationOriginHidden';
                    }
                    document.getElementById(self._addUID('GPlocationOriginPointer_' + i)).checked = true;
                    document.getElementById(self._addUID('GPlocationOrigin_' + i)).className = 'GPlocationOriginHidden';
                    document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).className = 'GPlocationOriginVisible';
                    document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).disabled = true;
                }
                self.onActivateMapPointClick(e);
            });
            return labelOriginPointer;
        },
        _createLocationRemovePointElement: function (id) {
            var self = this;
            var divRm = document.createElement('div');
            divRm.id = this._addUID('GPlocationStageRemove_' + id);
            divRm.className = 'GPlocationStageRemove';
            divRm.title = 'Supprimer l\'tape';
            divRm.addEventListener('click', function (e) {
                var points = document.getElementsByClassName(self._addUID('GPlocationPoint'));
                var last = points.length - 1;
                var start = points[0].childNodes[0].id;
                var end = points[last].childNodes[0].id;
                var startID = ID.index(start);
                var endID = ID.index(end);
                if (id != startID && id != endID) {
                    var i = ID.index(this.id);
                    document.getElementById(self._addUID('GPlocationPoint_' + i)).className = 'GPflexInput GPlocationStageFlexInputHidden';
                    document.getElementById(self._addUID('GPlocationOrigin_' + i)).value = '';
                    document.getElementById(self._addUID('GPlocationOrigin_' + i)).className = 'GPlocationOriginVisible';
                    document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).value = '';
                    document.getElementById(self._addUID('GPlocationOriginCoords_' + i)).className = 'GPlocationOriginHidden';
                    document.getElementById(self._addUID('GPlocationStageAdd')).style.display = '';
                    self.onLocationRemovePointClick(e);
                }
            });
            return divRm;
        },
        _createLocationAddPointElement: function () {
            var self = this;
            var divAdd = document.createElement('div');
            divAdd.id = this._addUID('GPlocationStageAdd');
            divAdd.title = 'Ajouter une tape';
            divAdd.addEventListener('click', function (e) {
                var lastStage = 1;
                var nbStages = 0;
                var points = document.getElementsByClassName(self._addUID('GPlocationPoint'));
                for (var i = 1; i < points.length - 1; i++) {
                    var tag = points[i].childNodes[0].id;
                    var id = ID.index(tag);
                    if (document.getElementById(self._addUID('GPlocationPoint_' + id))) {
                        if (document.getElementById(self._addUID('GPlocationPoint_' + id)).className == 'GPflexInput GPlocationStageFlexInputHidden') {
                            if (lastStage == 1) {
                                lastStage = id;
                            }
                        } else {
                            nbStages++;
                        }
                    }
                }
                if (lastStage < points.length) {
                    document.getElementById(self._addUID('GPlocationPoint_' + lastStage)).className = 'GPflexInput GPlocationStageFlexInput';
                }
                if (nbStages == 4) {
                    document.getElementById(self._addUID('GPlocationStageAdd')).style.display = 'none';
                }
                self.onLocationAddPointClick(e);
            });
            return divAdd;
        },
        _createLocationAutoCompleteResultElement: function (id) {
            var self = this;
            var div = document.createElement('div');
            div.id = this._addUID('GPlocationAutoCompleteList_' + id);
            div.className = 'GPadvancedAutoCompleteList';
            if (div.addEventListener) {
                div.addEventListener('click', function (e) {
                    self.onAutoCompletedResultsItemClick(e);
                    document.getElementById(self._addUID('GPlocationAutoCompleteList_' + id)).style.display = 'none';
                }, false);
            } else if (div.attachEvent) {
                div.attachEvent('onclick', function (e) {
                    self.onAutoCompletedResultsItemClick(e);
                    document.getElementById(self._addUID('GPlocationAutoCompleteList_' + id)).style.display = 'none';
                });
            }
            return div;
        },
        _createLocationAutoCompletedLocationElement: function (id, location, n) {
            var container = document.getElementById(this._addUID('GPlocationAutoCompleteList_' + id));
            var div = document.createElement('div');
            div.id = this._addUID('AutoCompletedLocation_' + n);
            div.className = 'GPautoCompleteProposal';
            div.innerHTML = location.fullText;
            container.appendChild(div);
        },
        GPdisplayCoordinate: function (value) {
            var points = document.getElementsByClassName(this._addUID('GPlocationPoint'));
            for (var i = 0; i < points.length; i++) {
                var tag = points[i].childNodes[0].id;
                var id1 = ID.index(tag);
                if (document.getElementById(this._addUID('GPlocationOriginPointer_' + id1)).checked) {
                    document.getElementById(this._addUID('GPlocationOriginCoords_' + id1)).value = value;
                    document.getElementById(this._addUID('GPlocationOriginCoords_' + id1)).disabled = false;
                    for (var j = 0; j < points.length; j++) {
                        tag = points[j].childNodes[0].id;
                        var id2 = ID.index(tag);
                        document.getElementById(this._addUID('GPlocationPoint_' + id2)).style.cssText = '';
                        if (document.getElementById(this._addUID('GPlocationStageRemove_' + id2))) {
                            document.getElementById(this._addUID('GPlocationStageRemove_' + id2)).className = 'GPlocationStageRemove';
                        }
                    }
                    document.getElementById(this._addUID('GPlocationOriginPointer_' + id1)).checked = false;
                    if (document.getElementById(this._addUID('GPlocationStageAdd'))) {
                        document.getElementById(this._addUID('GPlocationStageAdd')).className = '';
                    }
                    return;
                }
            }
        }
    };
    return LocationSelectorDOM;
}(CommonUtilsSelectorID);
Ol3ControlsLocationSelector = function (ol, Utils, woodman, Gp, RightManagement, SelectorID, LocationSelectorDOM, Markers) {
    function LocationSelector(options) {
        options = options || {};
        if (!(this instanceof LocationSelector)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.initialize(options);
        this._container = this._initContainer();
        if (options.element && options.element.appendChild) {
            options.element.appendChild(this._container);
            this._container = options.element;
        }
        ol.control.Control.call(this, {
            element: this._container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(LocationSelector, ol.control.Control);
    LocationSelector.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(LocationSelector.prototype, LocationSelectorDOM);
    LocationSelector.prototype.constructor = LocationSelector;
    LocationSelector.prototype.initialize = function (options) {
        this.options = {
            tag: {
                id: 1,
                groupId: null,
                label: '>',
                display: true,
                addOption: false,
                removeOption: false
            },
            displayInfo: true,
            autocompleteOptions: {}
        };
        Utils.mergeParams(this.options, options);
        this._uid = this.options.tag.groupId || SelectorID.generate();
        this._map = null;
        this._inputsContainer = null;
        this._inputLabelContainer = null;
        this._inputAutoCompleteContainer = null;
        this._inputShowPointerContainer = null;
        this._inputShowPointer = null;
        this._inputCoordinateContainer = null;
        this._addPointElement = null;
        this._removePointElement = null;
        this._coordinate = null;
        this._suggestedContainer = null;
        this._suggestedLocations = [];
        this._currentLocation = null;
        this._initMarker();
        this._resources = {};
        this._noRightManagement = false;
        this._checkRightsManagement();
    };
    LocationSelector.prototype._initMarker = function () {
        this._marker = null;
        this._markerUrl = '';
        this._markerOffset = [
            0,
            0
        ];
        if (this.options.tag.markerOpts && this.options.tag.markerOpts.url) {
            this._markerUrl = this.options.tag.markerOpts.url;
            var offset = this.options.tag.markerOpts.offset;
            if (offset) {
                if (Array.isArray(offset) && offset.length === 2) {
                    this._markerOffset = offset;
                } else {
                    console.log('markerOpts.offset should be an array. e.g. : [0,0]');
                }
            }
        } else {
            this._markerUrl = Markers['lightOrange'];
            this._markerOffset = Markers.defaultOffset;
        }
    };
    LocationSelector.prototype.getCoordinate = function () {
        return this._coordinate;
    };
    LocationSelector.prototype.clear = function () {
        this._clearResults();
        this._inputLabelContainer.click();
    };
    LocationSelector.prototype._checkRightsManagement = function () {
        var _opts = this.options.autocompleteOptions.filterOptions;
        var _res = _opts ? _opts.type : [];
        if (!_res || _res.length === 0) {
            _res = [
                'PositionOfInterest',
                'StreetAddress'
            ];
        }
        var rightManagement = RightManagement.check({
            key: this.options.apiKey,
            resources: _res,
            services: ['AutoCompletion']
        });
        if (!rightManagement) {
            this._noRightManagement = true;
        }
        if (!this.options.apiKey) {
            this.options.apiKey = rightManagement.key;
        }
        Utils.assign(this._resources, rightManagement);
    };
    LocationSelector.prototype._initContainer = function () {
        var id = this.options.tag.id;
        var container = this._createMainContainerElement();
        var inputs = this._inputsContainer = this._createLocationPointElement(id, this.options.tag.display);
        container.appendChild(inputs);
        var _inputLabel = this._inputLabelContainer = this._createLocationPointLabelElement(id, this.options.tag.label);
        inputs.appendChild(_inputLabel);
        var _inputAutoComplete = this._inputAutoCompleteContainer = this._createLocationAutoCompleteteInputElement(id);
        var context = this;
        if (_inputAutoComplete.addEventListener) {
            _inputAutoComplete.addEventListener('click', function () {
                context.onAutoCompleteInputClick();
            });
        } else if (_inputAutoComplete.attachEvent) {
            _inputAutoComplete.attachEvent('onclick', function () {
                context.onAutoCompleteInputClick();
            });
        }
        inputs.appendChild(_inputAutoComplete);
        var _inputCoordinate = this._inputCoordinateContainer = this._createLocationCoordinateInputElement(id);
        inputs.appendChild(_inputCoordinate);
        var _inputShowPointer = this._inputShowPointerContainer = this._createLocationPointerShowInputElement(id);
        inputs.appendChild(_inputShowPointer);
        var _inputPointer = this._inputShowPointer = this._createLocationPointerInputElement(id);
        inputs.appendChild(_inputPointer);
        if (this.options.tag.addOption) {
            var _inputAddStage = this._addPointElement = this._createLocationAddPointElement();
            inputs.appendChild(_inputAddStage);
        }
        if (this.options.tag.removeOption) {
            var _inputRemoveStage = this._removePointElement = this._createLocationRemovePointElement(id);
            inputs.appendChild(_inputRemoveStage);
        }
        var results = this._suggestedContainer = this._createLocationAutoCompleteResultElement(id);
        container.appendChild(results);
        return container;
    };
    LocationSelector.prototype.onAutoCompleteInputClick = function () {
        if (this._inputAutoCompleteContainer && this._inputAutoCompleteContainer.value.length > 2) {
            this._displaySuggestedLocation();
        }
    };
    LocationSelector.prototype.onAutoCompleteSearchText = function (e) {
        var value = e.target.value;
        if (!value) {
            return;
        }
        if (this._noRightManagement) {
            console.log('no rights for this service !?');
            return;
        }
        this._currentLocation = value;
        if (value.length < 3) {
            this._clearSuggestedLocation();
            return;
        }
        var context = this;
        this._requestAutoComplete({
            text: value,
            maximumResponses: 5,
            onSuccess: function (results) {
                if (results) {
                    var locations = results.suggestedLocations;
                    context._fillAutoCompletedLocationListContainer(locations);
                }
            },
            onFailure: function (error) {
                context._clearSuggestedLocation();
            }
        });
        var map = this.getMap();
        map.on('click', this._hideSuggestedLocation, this);
        map.on('pointerdrag', this._hideSuggestedLocation, this);
    };
    LocationSelector.prototype.onAutoCompletedResultsItemClick = function (e) {
        var idx = SelectorID.index(e.target.id);
        if (!idx) {
            return;
        }
        var position = [
            this._suggestedLocations[idx].position.x,
            this._suggestedLocations[idx].position.y
        ];
        this._coordinate = position;
        var info = {
            type: this._suggestedLocations[idx].type,
            fields: this._suggestedLocations[idx]
        };
        var label = this._suggestedLocations[idx].fullText;
        this._setLabel(label);
        var view = this.getMap().getView();
        var mapProj = view.getProjection().getCode();
        if (mapProj !== 'EPSG:4326') {
            position = ol.proj.transform(position, 'EPSG:4326', mapProj);
        }
        this._setPosition(position);
        this._setMarker(position, info, this.options.displayInfo);
    };
    LocationSelector.prototype.onActivateMapPointClick = function () {
        var map = this.getMap();
        if (this._inputShowPointerContainer.checked) {
            this._clearResults();
            map.on('click', this.onMouseMapClick, this);
            this._setCursor('crosshair');
        } else {
            map.un('click', this.onMouseMapClick, this);
            this._setCursor();
        }
    };
    LocationSelector.prototype.onLocationClearPointClick = function () {
        this._setCursor();
        this._clearResults();
    };
    LocationSelector.prototype.onLocationRemovePointClick = function () {
        this._setCursor();
        this._clearResults();
    };
    LocationSelector.prototype.onLocationAddPointClick = function (e) {
    };
    LocationSelector.prototype.onMouseMapClick = function (e) {
        var coordinate = e.coordinate;
        if (!e.map || !e.map.getView()) {
            return;
        }
        var crs = e.map.getView().getProjection();
        this._setCoordinate(coordinate, crs);
        this._setMarker([
            coordinate[0],
            coordinate[1]
        ], null, false);
        this.onActivateMapPointClick(e);
    };
    LocationSelector.prototype._setLabel = function (label) {
        this._inputAutoCompleteContainer.value = label;
    };
    LocationSelector.prototype._setCursor = function (cursor) {
        var map = this.getMap();
        var div = map.getTargetElement();
        if (cursor) {
            div.style.cursor = cursor;
        } else {
            div.style.cursor = null;
        }
    };
    LocationSelector.prototype._setCoordinate = function (olCoordinate, crs) {
        this._coordinate = ol.proj.transform(olCoordinate, crs, 'EPSG:4326');
        var lat = this._coordinate[0].toFixed(4);
        var lng = this._coordinate[1].toFixed(4);
        var value = lat + ' / ' + lng;
        this.GPdisplayCoordinate(value);
    };
    LocationSelector.prototype._setPosition = function (position) {
        var view = this.getMap().getView();
        view.setCenter(position);
    };
    LocationSelector.prototype._setMarker = function (position, information, display) {
        var map = this.getMap();
        if (this._marker != null) {
            map.removeOverlay(this._marker);
            this._marker = null;
        }
        if (position) {
            var markerDiv = document.createElement('img');
            markerDiv.src = this._markerUrl;
            this._marker = new ol.Overlay({
                position: position,
                offset: this._markerOffset,
                element: markerDiv,
                stopEvent: false
            });
            map.addOverlay(this._marker);
            if (display) {
            }
        }
    };
    LocationSelector.prototype._clearResults = function () {
        var map = this.getMap();
        this._currentLocation = null;
        this._coordinate = null;
        this._hideSuggestedLocation();
        this._clearSuggestedLocation();
        this._setMarker();
        map.un('click', this.onMouseMapClick, this);
    };
    LocationSelector.prototype._clearSuggestedLocation = function () {
        this._suggestedLocations = [];
        if (this._suggestedContainer) {
            while (this._suggestedContainer.firstChild) {
                this._suggestedContainer.removeChild(this._suggestedContainer.firstChild);
            }
        }
    };
    LocationSelector.prototype._hideSuggestedLocation = function () {
        if (this._suggestedContainer) {
            this._suggestedContainer.style.display = 'none';
        }
    };
    LocationSelector.prototype._displaySuggestedLocation = function () {
        if (this._suggestedContainer) {
            this._suggestedContainer.style.display = 'block';
        }
    };
    LocationSelector.prototype._requestAutoComplete = function (settings) {
        if (!settings || Object.keys(settings).length === 0) {
            return;
        }
        if (!settings.text) {
            return;
        }
        var options = {};
        Utils.assign(options, this.options.autocompleteOptions);
        Utils.assign(options, settings);
        var resources = this._resources['AutoCompletion'] || null;
        if (resources && Array.isArray(resources)) {
            if (!options.filterOptions) {
                options.filterOptions = {};
            }
            options.filterOptions.type = resources;
        }
        options.apiKey = options.apiKey || this.options.apiKey;
        Gp.Services.autoComplete(options);
    };
    LocationSelector.prototype._fillAutoCompletedLocationListContainer = function (locations) {
        if (!locations || locations.length === 0) {
            return;
        }
        var element = this._suggestedContainer;
        if (element.childElementCount) {
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
        for (var i = 0; i < locations.length; i++) {
            this._createLocationAutoCompletedLocationElement(this.options.tag.id, locations[i], i);
        }
        this._suggestedLocations = locations;
    };
    return LocationSelector;
}(ol, Ol3Utils, {}, gp, CommonUtilsCheckRightManagement, CommonUtilsSelectorID, CommonControlsLocationSelectorDOM, Ol3ControlsUtilsMarkers);
CommonControlsRouteDOM = function (ID) {
    var RouteDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GProute');
            container.className = 'GPwidget';
            return container;
        },
        _createShowRouteElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowRoute');
            input.type = 'checkbox';
            return input;
        },
        _createShowRoutePictoElement: function () {
            var context = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowRoutePicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowRoute');
            label.title = 'Ouvrir le calcul d\'itinraire';
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    context.onShowRoutePanelClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    context.onShowRoutePanelClick(e);
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowRouteOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createRoutePanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GProutePanel');
            div.className = 'GPpanel';
            return div;
        },
        _createRoutePanelHeaderElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var div = document.createElement('div');
            div.className = 'GPpanelTitle';
            div.innerHTML = 'Calcul d\'itinraire';
            container.appendChild(div);
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GProutePanelClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Masquer le panneau';
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPshowRoutePicto')).click();
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPshowRoutePicto')).click();
                });
            }
            container.appendChild(divClose);
            return container;
        },
        _createRoutePanelFormElement: function () {
            var self = this;
            var form = document.createElement('form');
            form.id = this._addUID('GProuteForm');
            form.setAttribute('onkeypress', 'return event.keyCode != 13;');
            form.addEventListener('submit', function (e) {
                console.log(e);
                e.preventDefault();
                var points = document.getElementsByClassName(self._addUID('GPlocationPoint'));
                var start = points[0].childNodes[0].id;
                var end = points[points.length - 1].childNodes[0].id;
                var startID = ID.index(start);
                var endID = ID.index(end);
                if (document.getElementById(self._addUID('GPlocationOrigin_' + startID)).value == '' && document.getElementById(self._addUID('GPlocationOriginCoords_' + startID)).value == '' || document.getElementById(self._addUID('GPlocationOrigin_' + endID)).value == '' && document.getElementById(self._addUID('GPlocationOriginCoords_' + endID)).value == '') {
                    return false;
                }
                var id;
                document.getElementById(self._addUID('GProuteResultsStages')).innerHTML = '';
                for (var i = 0; i < points.length; i++) {
                    var tag = points[i].childNodes[0].id;
                    id = ID.index(tag);
                    if (document.getElementById(self._addUID('GPlocationPoint_' + id)).className == 'GPflexInput GPlocationStageFlexInput') {
                        var resultStage = document.createElement('div');
                        resultStage.className = 'GProuteResultsStages';
                        var resultStageLabel = document.createElement('div');
                        resultStageLabel.className = 'GProuteResultStageLabel';
                        resultStageLabel.innerHTML = document.getElementById(self._addUID('GPlocationOriginLabel_' + id)).innerHTML + ' :';
                        resultStage.appendChild(resultStageLabel);
                        var resultStageValue = document.createElement('div');
                        resultStageValue.className = 'GProuteResultStageValue';
                        var elementCoords = document.getElementById(self._addUID('GPlocationOriginCoords_' + id));
                        var stageCoords = elementCoords.value;
                        var visible = elementCoords.className === 'GPlocationOriginVisible' ? true : false;
                        if (stageCoords != null && stageCoords != '' && visible) {
                            resultStageValue.innerHTML = stageCoords;
                        } else {
                            resultStageValue.innerHTML = document.getElementById(self._addUID('GPlocationOrigin_' + id)).value;
                        }
                        resultStage.appendChild(resultStageValue);
                        if (resultStageValue.innerHTML != '') {
                            document.getElementById(self._addUID('GProuteResultsStages')).appendChild(resultStage);
                        }
                    }
                }
                var modeComputation = null;
                if (document.getElementById(self._addUID('GProuteComputationSelect'))) {
                    var select = document.getElementById(self._addUID('GProuteResultsComputationSelect'));
                    select.selectedIndex = document.getElementById(self._addUID('GProuteComputationSelect')).selectedIndex;
                    modeComputation = select.options[select.selectedIndex].value;
                }
                var modeTransport = null;
                if (document.getElementById(self._addUID('GProuteTransportCar'))) {
                    if (document.getElementById(self._addUID('GProuteTransportCar')).checked) {
                        modeTransport = document.getElementById(self._addUID('GProuteTransportCar')).value;
                    }
                }
                if (document.getElementById(self._addUID('GProuteTransportPedestrian'))) {
                    if (document.getElementById(self._addUID('GProuteTransportPedestrian')).checked) {
                        modeTransport = document.getElementById(self._addUID('GProuteTransportPedestrian')).value;
                    }
                }
                var exclusions = [];
                var exclusionsElement = document.getElementsByClassName('GProuteExclusionsOption');
                for (var j = 0; j < exclusionsElement.length; j++) {
                    id = exclusionsElement[j].htmlFor;
                    var el = document.getElementById(id);
                    if (!el.checked) {
                        exclusions.push(el.value);
                    }
                }
                self.onRouteComputationSubmit({
                    computation: modeComputation,
                    transport: modeTransport,
                    exclusions: exclusions
                });
                return false;
            });
            return form;
        },
        _createRoutePanelResultsElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GProuteResultsPanel');
            container.className = 'GProuteComponentHidden';
            container.appendChild(this._createRouteResultsStagesElement());
            container.appendChild(this._createRouteResultsElement());
            var divBorderUp = document.createElement('div');
            divBorderUp.className = 'GPfakeBorder GPfakeBorderLeft';
            container.appendChild(divBorderUp);
            container.appendChild(this._createRouteShowResultsDetailsElement());
            var labelShow = document.createElement('label');
            labelShow.htmlFor = this._addUID('GProuteResultsShowDetails');
            labelShow.innerHTML = 'Afficher le dtail';
            container.appendChild(labelShow);
            var labelHide = document.createElement('label');
            labelHide.htmlFor = this._addUID('GProuteResultsShowDetails');
            labelHide.innerHTML = 'Masquer le dtail';
            container.appendChild(labelHide);
            var divBorderDown = document.createElement('div');
            divBorderDown.className = 'GPfakeBorder';
            container.appendChild(divBorderDown);
            container.appendChild(this._createRouteResultsDetailsElement());
            return container;
        },
        _createRouteWaitingElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GProuteCalcWaitingContainer');
            div.className = 'GProuteCalcWaitingContainerHidden';
            var p = document.createElement('p');
            p.className = 'GProuteCalcWaiting';
            p.innerHTML = 'Calcul en cours...';
            div.appendChild(p);
            return div;
        },
        _createRouteResultsStagesElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GProuteResultsStages');
            return div;
        },
        _createRouteResultsElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.id = this._addUID('GProuteResults');
            var divValue = document.createElement('div');
            divValue.id = this._addUID('GProuteResultsValues');
            container.appendChild(divValue);
            var divMode = document.createElement('div');
            divMode.id = this._addUID('GProuteResultsMode');
            var select = document.createElement('select');
            select.id = this._addUID('GProuteResultsComputationSelect');
            select.className = 'GPinputSelect';
            select.addEventListener('change', function (e) {
                self.onRouteModeComputationChangeAndRun(e);
            });
            var computes = [
                {
                    code: 'fastest',
                    label: 'Plus rapide'
                },
                {
                    code: 'shortest',
                    label: 'Plus court'
                }
            ];
            for (var i = 0; i < computes.length; i++) {
                var option = document.createElement('option');
                option.value = computes[i].code;
                option.text = computes[i].label;
                select.appendChild(option);
            }
            divMode.appendChild(select);
            container.appendChild(divMode);
            var divNew = document.createElement('div');
            divNew.id = this._addUID('GProuteResultsNew');
            divNew.title = 'Modifier le calcul';
            divNew.addEventListener('click', function (e) {
                document.getElementById(self._addUID('GProuteResultsPanel')).className = 'GProuteComponentHidden';
                document.getElementById(self._addUID('GProuteForm')).className = '';
                self.onShowRouteResultsNewClick(e);
            });
            container.appendChild(divNew);
            return container;
        },
        _addRouteResultsValuesElement: function (distance, duration, fconvert) {
            var div = document.getElementById(this._addUID('GProuteResultsValues'));
            if (div.childElementCount) {
                while (div.firstChild) {
                    div.removeChild(div.firstChild);
                }
            }
            var containerDistance = document.createElement('div');
            containerDistance.className = 'GProuteResultsValue';
            var labelDistance = document.createElement('label');
            labelDistance.className = 'GProuteResultsValueLabel';
            labelDistance.innerHTML = 'Distance :';
            containerDistance.appendChild(labelDistance);
            var distanceLabel = 0;
            var isKm = parseInt(distance / 1000, 10);
            if (!isKm) {
                distanceLabel = Math.round(distance) + ' m';
            } else {
                var distanceArrondi = Math.round(distance);
                distanceArrondi = distanceArrondi / 1000;
                distanceLabel = distanceArrondi + ' km';
            }
            var divDistance = document.createElement('div');
            divDistance.id = this._addUID('GProuteResultsValueDist');
            divDistance.innerHTML = distanceLabel;
            containerDistance.appendChild(divDistance);
            div.appendChild(containerDistance);
            var containerDuration = document.createElement('div');
            containerDuration.className = 'GProuteResultsValue';
            var labelDuration = document.createElement('label');
            labelDuration.className = 'GProuteResultsValueLabel';
            labelDuration.innerHTML = 'Dure :';
            containerDuration.appendChild(labelDuration);
            var divDuration = document.createElement('div');
            divDuration.id = this._addUID('GProuteResultsValueDist');
            divDuration.innerHTML = fconvert(duration);
            containerDuration.appendChild(divDuration);
            div.appendChild(containerDuration);
            return div;
        },
        _createRouteShowResultsDetailsElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GProuteResultsShowDetails');
            input.type = 'checkbox';
            return input;
        },
        _createRouteResultsDetailsElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GProuteResultsDetails');
            return div;
        },
        _addRouteResultsDetailsElement: function (instructions, fconvert) {
            var context = this;
            var div = document.getElementById(this._addUID('GProuteResultsDetails'));
            if (div.childElementCount) {
                while (div.firstChild) {
                    div.removeChild(div.firstChild);
                }
            }
            var distanceCumul = 0;
            var durationCumul = 0;
            for (var i = 0; i < instructions.length; i++) {
                var id = i + 1;
                var o = instructions[i];
                var divNum = document.createElement('div');
                divNum.className = 'GProuteResultsDetailsNumber';
                divNum.innerHTML = id + '.';
                div.appendChild(divNum);
                durationCumul += parseFloat(o.duration);
                distanceCumul += parseFloat(o.distance);
                var distance = 0;
                var isCumulKm = parseInt(distanceCumul / 1000, 10);
                if (!isCumulKm) {
                    distance = Math.round(distanceCumul) + ' m';
                } else {
                    var distanceArrondi = Math.round(distanceCumul);
                    distanceArrondi = distanceArrondi / 1000;
                    distance = distanceArrondi + ' km';
                }
                var divIns = document.createElement('div');
                divIns.className = 'GProuteResultsDetailsInstruction';
                divIns.id = this._addUID('GProuteResultsDetailsInstruction_' + id);
                divIns.title = 'distance : ' + distance + ' / ' + 'temps : ' + fconvert(durationCumul);
                divIns.innerHTML = o.instruction;
                divIns.addEventListener('mouseover', function (e) {
                    context.onRouteResultsDetailsMouseOver(e);
                });
                divIns.addEventListener('mouseout', function (e) {
                    context.onRouteResultsDetailsMouseOut(e);
                });
                divIns.addEventListener('click', function (e) {
                    if (typeof context.onRouteResultsDetailsClick === 'function') {
                        context.onRouteResultsDetailsClick(e);
                    }
                });
                div.appendChild(divIns);
            }
            return div;
        },
        _createRoutePanelFormPointElement: function (n, text, visibility) {
            var context = this;
            var div = document.createElement('div');
            div.id = 'GProutePoint' + n;
            div.className = visibility ? 'GPflexInput GProuteStageFlexInput' : 'GPflexInput GProuteStageFlexInputHidden';
            var labelOrigin = document.createElement('label');
            labelOrigin.id = 'GProuteOriginLabel' + n;
            labelOrigin.htmlFor = 'GProuteOrigin' + n;
            labelOrigin.innerHTML = text;
            labelOrigin.addEventListener('click', function () {
                var i = this.id.charAt(this.id.length - 1);
                document.getElementById('GProuteOriginCoords' + i).value = '';
                for (var j = 1; j < 8; j++) {
                    document.getElementById('GProutePoint' + j).style.display = 'flex';
                }
                document.getElementById('GProuteForm').className = '';
                document.getElementById('GProuteOriginPointer' + i).checked = false;
                document.getElementById('GProuteOrigin' + i).className = 'GProuteOriginVisible';
                document.getElementById('GProuteOriginCoords' + i).className = 'GProuteOriginHidden';
            });
            div.appendChild(labelOrigin);
            var inputOrigin = document.createElement('input');
            inputOrigin.id = 'GProuteOrigin' + n;
            inputOrigin.className = 'GProuteOriginVisible';
            inputOrigin.type = 'text';
            inputOrigin.placeholder = 'Saisir une adresse';
            inputOrigin.addEventListener('keyup', function (e) {
                var charCode = e.which || e.keyCode;
                if (charCode === 13 || charCode === 10) {
                    return;
                }
                var i = this.id.charAt(this.id.length - 1);
                if (document.getElementById('GProuteOrigin' + i).value.length > 2) {
                    document.getElementById('GProuteAutoCompleteList' + i).style.display = 'block';
                } else {
                    document.getElementById('GProuteAutoCompleteList' + i).style.display = 'none';
                }
                context.onAutoCompleteSearchText(e);
            });
            inputOrigin.addEventListener('blur', function () {
                var i = this.id.charAt(this.id.length - 1);
                document.getElementById('GProuteAutoCompleteList' + i).style.display = 'none';
            });
            div.appendChild(inputOrigin);
            var inputOriginCoord = document.createElement('input');
            inputOriginCoord.id = 'GProuteOriginCoords' + n;
            inputOriginCoord.className = 'GProuteOriginHidden';
            inputOriginCoord.type = 'text';
            inputOriginCoord.disabled = true;
            div.appendChild(inputOriginCoord);
            var inputOriginPointer = document.createElement('input');
            inputOriginPointer.id = 'GProuteOriginPointer' + n;
            inputOriginPointer.type = 'checkbox';
            div.appendChild(inputOriginPointer);
            var labelOriginPointer = document.createElement('label');
            labelOriginPointer.id = 'GProuteOriginPointerImg' + n;
            labelOriginPointer.htmlFor = 'GProuteOriginPointer' + n;
            labelOriginPointer.className = 'GProuteOriginPointerImg';
            labelOriginPointer.title = 'Pointer un lieu sur la carte';
            labelOriginPointer.addEventListener('click', function (evt) {
                evt.preventDefault();
                evt.stopPropagation();
                var i = this.id.charAt(this.id.length - 1);
                var j;
                for (j = 1; j < 8; j++) {
                    if (i != j) {
                        document.getElementById('GProuteOriginPointer' + j).checked = false;
                        if (document.getElementById('GProuteOriginCoords' + j).value == 'Pointer un lieu sur la carte') {
                            document.getElementById('GProuteOriginCoords' + j).value = '';
                            document.getElementById('GProuteOrigin' + j).className = 'GProuteOriginVisible';
                            document.getElementById('GProuteOriginCoords' + j).className = 'GProuteOriginHidden';
                        }
                    }
                }
                if (document.getElementById('GProuteOriginPointer' + i).checked) {
                    document.getElementById('GProuteOriginCoords' + i).value = '';
                    for (j = 1; j < 8; j++) {
                        document.getElementById('GProutePoint' + j).style.display = 'flex';
                    }
                    document.getElementById('GProuteForm').className = '';
                    document.getElementById('GProuteOriginPointer' + i).checked = false;
                    document.getElementById('GProuteOrigin' + i).className = 'GProuteOriginVisible';
                    document.getElementById('GProuteOriginCoords' + i).className = 'GProuteOriginHidden';
                } else {
                    document.getElementById('GProuteOriginCoords' + i).value = 'Pointer un lieu sur la carte';
                    for (j = 1; j < 8; j++) {
                        if (i == j) {
                            document.getElementById('GProutePoint' + j).style.display = 'flex';
                        } else {
                            document.getElementById('GProutePoint' + j).style.display = 'none';
                        }
                    }
                    document.getElementById('GProuteForm').className = 'GProuteFormMini';
                    document.getElementById('GProuteOriginPointer' + i).checked = true;
                    document.getElementById('GProuteOrigin' + i).className = 'GProuteOriginHidden';
                    document.getElementById('GProuteOriginCoords' + i).className = 'GProuteOriginVisible';
                }
                context.onRouteMapPointClick(evt);
            });
            div.appendChild(labelOriginPointer);
            return div;
        },
        _createRoutePanelFormRemoveStageElement: function (n) {
            var context = this;
            var divRm = document.createElement('div');
            divRm.id = 'GProuteStageRemove' + n;
            divRm.className = 'GProuteStageRemove';
            divRm.title = 'Supprimer l\'tape';
            if (n != 1 && n != 7) {
                divRm.addEventListener('click', function (e) {
                    var i = this.id.charAt(this.id.length - 1);
                    document.getElementById('GProutePoint' + i).className = 'GPflexInput GProuteStageFlexInputHidden';
                    document.getElementById('GProuteOrigin' + i).value = '';
                    document.getElementById('GProuteOrigin' + i).className = 'GProuteOriginVisible';
                    document.getElementById('GProuteOriginCoords' + i).value = '';
                    document.getElementById('GProuteOriginCoords' + i).className = 'GProuteOriginHidden';
                    document.getElementById('GProuteStageAdd').style.display = '';
                    var exclusionsPictoTop = document.getElementById('GPshowRouteExclusionsPicto').style.top;
                    document.getElementById('GPshowRouteExclusionsPicto').style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + 'px';
                    context.onRouteRemovePointClick(e);
                });
            }
            return divRm;
        },
        _createRoutePanelFormAddStageElement: function () {
            var context = this;
            var divAdd = document.createElement('div');
            divAdd.id = 'GProuteStageAdd';
            divAdd.title = 'Ajouter une tape';
            divAdd.addEventListener('click', function (e) {
                var lastStage = 1;
                var nbStages = 0;
                for (var i = 2; i < 7; i++) {
                    if (document.getElementById('GProutePoint' + i).className == 'GPflexInput GProuteStageFlexInputHidden') {
                        if (lastStage == 1) {
                            lastStage = i;
                        }
                    } else {
                        nbStages++;
                    }
                }
                if (lastStage < 7) {
                    document.getElementById('GProutePoint' + lastStage).className = 'GPflexInput GProuteStageFlexInput';
                    var exclusionsPictoTop = document.getElementById('GPshowRouteExclusionsPicto').style.top;
                    document.getElementById('GPshowRouteExclusionsPicto').style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + 'px';
                }
                if (nbStages == 4) {
                    document.getElementById('GProuteStageAdd').style.display = 'none';
                }
                context.onRouteAddPointClick(e);
            });
            return divAdd;
        },
        _createRoutePanelFormAutoCompleteListElement: function (n) {
            var context = this;
            var div = document.createElement('div');
            div.id = 'GProuteAutoCompleteList' + n;
            div.className = 'GPadvancedAutoCompleteList';
            if (div.addEventListener) {
                div.addEventListener('click', function (e) {
                    context.onAutoCompletedResultsItemClick(e);
                    document.getElementById('GProuteAutoCompleteList' + n).style.display = 'none';
                }, false);
            } else if (div.attachEvent) {
                div.attachEvent('onclick', function (e) {
                    context.onAutoCompletedResultsItemClick(e);
                    document.getElementById('GProuteAutoCompleteList' + n).style.display = 'none';
                });
            }
            return div;
        },
        _createRouteAutoCompletedLocationElement: function (location, n, id) {
            var container = document.getElementById('GProuteAutoCompleteList' + n);
            var div = document.createElement('div');
            div.id = 'AutoCompletedLocation' + id;
            div.className = 'GPautoCompleteProposal';
            div.innerHTML = location.fullText;
            container.appendChild(div);
        },
        _createRoutePanelFormModeChoiceElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GProuteModeChoice');
            return div;
        },
        _createRoutePanelFormModeChoiceTransportElement: function (transports) {
            var context = this;
            var div = document.createElement('div');
            div.id = this._addUID('GProuteTransportChoice');
            var span = document.createElement('span');
            span.className = 'GProuteModeLabel';
            span.innerHTML = 'Mode de transport';
            div.appendChild(span);
            for (var i = 0; i < transports.length; i++) {
                var transport = transports[i];
                if (transport === 'Voiture') {
                    var inputCar = document.createElement('input');
                    inputCar.id = this._addUID('GProuteTransportCar');
                    inputCar.type = 'radio';
                    inputCar.name = 'GProuteTransport';
                    inputCar.value = 'Voiture';
                    if (i === 0) {
                        inputCar.checked = true;
                    }
                    if (inputCar.addEventListener) {
                        inputCar.addEventListener('change', function (e) {
                            context.onRouteModeTransportChange(e);
                        });
                    } else if (inputCar.attachEvent) {
                        inputCar.attachEvent('onchange', function (e) {
                            context.onRouteModeTransportChange(e);
                        });
                    }
                    div.appendChild(inputCar);
                    var labelCar = document.createElement('label');
                    labelCar.className = 'GProuteTransportImg';
                    labelCar.htmlFor = this._addUID('GProuteTransportCar');
                    labelCar.title = 'Voiture';
                    div.appendChild(labelCar);
                }
                if (transport === 'Pieton') {
                    var inputPedestrian = document.createElement('input');
                    inputPedestrian.id = this._addUID('GProuteTransportPedestrian');
                    inputPedestrian.type = 'radio';
                    inputPedestrian.name = 'GProuteTransport';
                    inputPedestrian.value = 'Pieton';
                    if (i === 0) {
                        inputPedestrian.checked = true;
                    }
                    if (inputPedestrian.addEventListener) {
                        inputPedestrian.addEventListener('change', function (e) {
                            context.onRouteModeTransportChange(e);
                        });
                    } else if (inputPedestrian.attachEvent) {
                        inputPedestrian.attachEvent('onchange', function (e) {
                            context.onRouteModeTransportChange(e);
                        });
                    }
                    div.appendChild(inputPedestrian);
                    var labelPedestrian = document.createElement('label');
                    labelPedestrian.className = 'GProuteTransportImg';
                    labelPedestrian.htmlFor = this._addUID('GProuteTransportPedestrian');
                    labelPedestrian.title = 'Piton';
                    div.appendChild(labelPedestrian);
                }
            }
            return div;
        },
        _createRoutePanelFormModeChoiceComputeElement: function () {
            var context = this;
            var div = document.createElement('div');
            div.id = this._addUID('GProuteComputationChoice');
            var span = document.createElement('span');
            span.className = 'GProuteModeLabel';
            span.innerHTML = 'Mode de calcul';
            div.appendChild(span);
            var select = document.createElement('select');
            select.id = this._addUID('GProuteComputationSelect');
            select.className = 'GPinputSelect';
            select.addEventListener('change', function (e) {
                context.onRouteModeComputationChange(e);
            });
            var computes = [
                {
                    code: 'fastest',
                    label: 'Plus rapide'
                },
                {
                    code: 'shortest',
                    label: 'Plus court'
                }
            ];
            for (var i = 0; i < computes.length; i++) {
                var option = document.createElement('option');
                option.value = computes[i].code;
                option.text = computes[i].label;
                select.appendChild(option);
            }
            div.appendChild(select);
            return div;
        },
        _createShowRouteExclusionsElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowRouteExclusions');
            input.type = 'checkbox';
            return input;
        },
        _createShowRouteExclusionsPictoElement: function () {
            var context = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowRouteExclusionsPicto');
            label.className = 'GPshowMoreOptions GPshowRouteExclusionsPicto';
            label.htmlFor = this._addUID('GPshowRouteExclusions');
            label.title = 'Exclusions';
            label.style.top = '185px';
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    context.onShowRouteExclusionsClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    context.onShowRouteExclusionsClick(e);
                });
            }
            return label;
        },
        _createRoutePanelFormExclusionsElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GProuteExclusions');
            var span = document.createElement('span');
            span.className = 'GProuteExclusionsLabel';
            span.innerHTML = 'Passages autoriss';
            div.appendChild(span);
            return div;
        },
        _createRoutePanelFormExclusionOptionsElement: function (exclusions) {
            var context = this;
            var div = document.createElement('div');
            div.className = 'GProuteExclusionsOptions';
            for (var value in exclusions) {
                if (exclusions.hasOwnProperty(value)) {
                    var status = exclusions[value];
                    switch (value) {
                    case 'toll':
                        var inputToll = document.createElement('input');
                        inputToll.id = this._addUID('GProuteExclusionsToll');
                        inputToll.type = 'checkbox';
                        inputToll.value = 'Toll';
                        inputToll.checked = !status;
                        if (inputToll.addEventListener) {
                            inputToll.addEventListener('change', function (e) {
                                context.onRouteExclusionsChange(e);
                            });
                        } else if (inputToll.attachEvent) {
                            inputToll.attachEvent('onchange', function (e) {
                                context.onRouteExclusionsChange(e);
                            });
                        }
                        div.appendChild(inputToll);
                        var labelToll = document.createElement('label');
                        labelToll.className = 'GProuteExclusionsOption';
                        labelToll.htmlFor = this._addUID('GProuteExclusionsToll');
                        labelToll.innerHTML = 'Pages';
                        div.appendChild(labelToll);
                        break;
                    case 'tunnel':
                        var inputTunnel = document.createElement('input');
                        inputTunnel.id = this._addUID('GProuteExclusionsTunnel');
                        inputTunnel.type = 'checkbox';
                        inputTunnel.value = 'Tunnel';
                        inputTunnel.checked = !status;
                        if (inputTunnel.addEventListener) {
                            inputTunnel.addEventListener('change', function (e) {
                                context.onRouteExclusionsChange(e);
                            });
                        } else if (inputTunnel.attachEvent) {
                            inputTunnel.attachEvent('onchange', function (e) {
                                context.onRouteExclusionsChange(e);
                            });
                        }
                        div.appendChild(inputTunnel);
                        var labelTunnel = document.createElement('label');
                        labelTunnel.className = 'GProuteExclusionsOption';
                        labelTunnel.htmlFor = this._addUID('GProuteExclusionsTunnel');
                        labelTunnel.innerHTML = 'Tunnels';
                        div.appendChild(labelTunnel);
                        break;
                    case 'bridge':
                        var inputBridge = document.createElement('input');
                        inputBridge.id = this._addUID('GProuteExclusionsBridge');
                        inputBridge.type = 'checkbox';
                        inputBridge.value = 'Bridge';
                        inputBridge.checked = !status;
                        if (inputBridge.addEventListener) {
                            inputBridge.addEventListener('change', function (e) {
                                context.onRouteExclusionsChange(e);
                            });
                        } else if (inputBridge.attachEvent) {
                            inputBridge.attachEvent('onchange', function (e) {
                                context.onRouteExclusionsChange(e);
                            });
                        }
                        div.appendChild(inputBridge);
                        var labelBridge = document.createElement('label');
                        labelBridge.className = 'GProuteExclusionsOption';
                        labelBridge.htmlFor = this._addUID('GProuteExclusionsBridge');
                        labelBridge.innerHTML = 'Ponts';
                        div.appendChild(labelBridge);
                        break;
                    }
                }
            }
            return div;
        },
        _createRouteSubmitFormElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GProuteSubmit');
            input.className = 'GPinputSubmit';
            input.type = 'submit';
            input.value = 'Calculer';
            return input;
        },
        _createRouteFormResetElement: function () {
            var self = this;
            var divReset = document.createElement('div');
            divReset.id = this._addUID('GProuteReset');
            divReset.title = 'Rinitialiser les paramtres';
            divReset.addEventListener('click', function (e) {
                self.onRouteResetClick(e);
            });
            return divReset;
        }
    };
    return RouteDOM;
}(CommonUtilsSelectorID);
Ol3ControlsRoute = function (ol, Gp, Utils, woodman, RightManagement, SelectorID, LocationSelector, LayerSwitcher, Markers, RouteDOM) {
    function Route(options) {
        options = options || {};
        if (!(this instanceof Route)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.initialize(options);
        this._container = this._createMainContainerElement();
        this._containerElement = null;
        if (options.element && options.element.appendChild) {
            options.element.appendChild(this._container);
            this._containerElement = options.element;
        }
        ol.control.Control.call(this, {
            element: this._containerElement || this._container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(Route, ol.control.Control);
    Route.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(Route.prototype, RouteDOM);
    Route.prototype.constructor = Route;
    Route.prototype.getCollapsed = function () {
        return this.collapsed;
    };
    Route.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] Route:setCollapsed - missing collapsed parameter');
            return;
        }
        if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
            return;
        }
        if (collapsed) {
            document.getElementById('GProutePanelClose-' + this._uid).click();
        } else {
            document.getElementById('GPshowRoute-' + this._uid).click();
        }
        this.collapsed = collapsed;
    };
    Route.prototype.getLayer = function () {
        return this._geojsonSections;
    };
    Route.prototype.setMap = function (map) {
        if (map) {
            this._container = this._initContainer(map);
        }
        ol.control.Control.prototype.setMap.call(this, map);
    };
    Route.prototype.initialize = function (options) {
        this._checkInputOptions(options);
        this.options = {
            collapsed: true,
            graphs: [
                'Voiture',
                'Pieton'
            ],
            exclusions: {
                toll: false,
                tunnel: false,
                bridge: false
            },
            routeOptions: {},
            autocompleteOptions: {}
        };
        Utils.assign(this.options, options);
        var defaultMarkersOpts = {
            departure: {
                url: Markers['red'],
                offset: Markers.defaultOffset
            },
            stages: {
                url: Markers['lightOrange'],
                offset: Markers.defaultOffset
            },
            arrival: {
                url: Markers['darkOrange'],
                offset: Markers.defaultOffset
            }
        };
        this.options.markersOpts = Utils.assign(defaultMarkersOpts, options.markersOpts);
        this.collapsed = this.options.collapsed;
        this._uid = SelectorID.generate();
        this._waitingContainer = null;
        this._formRouteContainer = null;
        this._resultsRouteContainer = null;
        this._showRouteExclusionsElement = null;
        this._currentPoints = [];
        this._currentTransport = null;
        this._initTransport();
        this._currentComputation = null;
        this._initComputation();
        this._currentExclusions = [];
        this._initExclusions();
        this._waiting = false;
        this._timer = null;
        this._geojsonRoute = null;
        this._geojsonSections = null;
        this._popupContent = null;
        this._popupDiv = this._initPopupDiv();
        this._popupOverlay = null;
        this._resultsSelectInteraction = null;
        this._resultsHoverInteraction = null;
        this._defaultFeatureStyle = new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: 'rgba(0,183,152,0.9)',
                width: 12
            })
        });
        this._selectedFeatureStyle = new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: 'rgba(255,102,0,0.9)',
                width: 12
            })
        });
        this._currentRouteInformations = null;
        this._resources = {};
        this._noRightManagement = false;
        this._checkRightsManagement();
    };
    Route.prototype._checkInputOptions = function (options) {
        if (options.graphs) {
            if (Array.isArray(options.graphs)) {
                if (options.graphs.length === 0) {
                    options.graphs = null;
                } else {
                    for (var i = 0; i < options.graphs.length; i++) {
                        if (typeof options.graphs[i] !== 'string') {
                            console.log('[ol.control.Route] ERROR : parameter \'graphs\' elements should be of type \'string\'');
                            options.graphs = null;
                        } else {
                            if (options.graphs[i].toLowerCase() === 'pieton') {
                                options.graphs[i] = 'Pieton';
                            }
                            if (options.graphs[i].toLowerCase() === 'voiture') {
                                options.graphs[i] = 'Voiture';
                            }
                        }
                    }
                }
            } else {
                options.graphs = null;
            }
        }
        if (options.collapsed === 'true') {
            options.collapsed = true;
        }
        if (options.collapsed === 'false') {
            options.collapsed = false;
        }
    };
    Route.prototype._checkRightsManagement = function () {
        var _opts = null;
        var _res = [];
        var _key = null;
        _key = this.options.routeOptions.apiKey;
        _opts = this.options.routeOptions.filterOptions;
        _res = _opts ? _opts.type : [];
        if (!_res || _res.length === 0) {
            _res = [
                'Voiture',
                'Pieton'
            ];
        }
        var rightManagementRoute = RightManagement.check({
            key: _key || this.options.apiKey,
            resources: _res,
            services: ['Itineraire']
        });
        _key = this.options.autocompleteOptions.apiKey;
        _opts = this.options.autocompleteOptions.filterOptions;
        _res = _opts ? _opts.type : [];
        if (!_res || _res.length === 0) {
            _res = [
                'PositionOfInterest',
                'StreetAddress'
            ];
        }
        var rightManagementAutoComplete = RightManagement.check({
            key: _key || this.options.apiKey,
            resources: _res,
            services: ['AutoCompletion']
        });
        if (!rightManagementRoute && !rightManagementAutoComplete) {
            this._noRightManagement = true;
        }
        if (rightManagementAutoComplete) {
            this._resources['AutoCompletion'] = {};
            this._resources['AutoCompletion']['resources'] = rightManagementAutoComplete['AutoCompletion'];
            this._resources['AutoCompletion']['key'] = rightManagementAutoComplete['key'];
        }
        if (rightManagementRoute) {
            this._resources['Itineraire'] = {};
            this._resources['Itineraire']['resources'] = rightManagementRoute['Itineraire'];
            this._resources['Itineraire']['key'] = rightManagementRoute['key'];
        }
    };
    Route.prototype._initContainer = function (map) {
        var container = this._container;
        var inputShow = this._showRouteContainer = this._createShowRouteElement();
        container.appendChild(inputShow);
        if (!this.collapsed) {
            inputShow.checked = true;
        }
        var picto = this._createShowRoutePictoElement();
        container.appendChild(picto);
        var routePanel = this._createRoutePanelElement();
        var routeHeader = this._createRoutePanelHeaderElement();
        routePanel.appendChild(routeHeader);
        var routeForm = this._formRouteContainer = this._createRoutePanelFormElement();
        var points = this._createRoutePanelFormPointsElement(map);
        for (var i = 0; i < points.length; i++) {
            routeForm.appendChild(points[i]);
        }
        var choice = this._createRoutePanelFormModeChoiceElement();
        choice.appendChild(this._createRoutePanelFormModeChoiceTransportElement(this.options.graphs));
        choice.appendChild(this._createRoutePanelFormModeChoiceComputeElement());
        routeForm.appendChild(choice);
        routeForm.appendChild(this._createShowRouteExclusionsElement());
        this._showRouteExclusionsElement = this._createShowRouteExclusionsPictoElement();
        routeForm.appendChild(this._showRouteExclusionsElement);
        var exclusion = this._createRoutePanelFormExclusionsElement();
        exclusion.appendChild(this._createRoutePanelFormExclusionOptionsElement(this.options.exclusions));
        routeForm.appendChild(exclusion);
        var divReset = this._createRouteFormResetElement();
        routeForm.appendChild(divReset);
        var submit = this._createRouteSubmitFormElement();
        routeForm.appendChild(submit);
        routePanel.appendChild(routeForm);
        var routeResults = this._resultsRouteContainer = this._createRoutePanelResultsElement();
        routePanel.appendChild(routeResults);
        var waiting = this._waitingContainer = this._createRouteWaitingElement();
        routePanel.appendChild(waiting);
        container.appendChild(routePanel);
        var context = this;
        if (container.addEventListener) {
            container.addEventListener('click', function (e) {
                context._hideRouteSuggestedLocations.call(context, e);
            });
        }
        return container;
    };
    Route.prototype._initTransport = function () {
        this._currentTransport = 'Voiture';
        var transport = this.options.graphs;
        if (!transport || transport.length === 0) {
            this.options.graphs = [
                'Voiture',
                'Pieton'
            ];
        }
        if (Array.isArray(transport) && transport.length) {
            if (transport[0] === 'Voiture' || transport[0] === 'Pieton') {
                this._currentTransport = transport[0];
            }
        }
        var serviceOptions = this.options.routeOptions;
        if (serviceOptions.graph) {
            this._currentTransport = serviceOptions.graph;
        }
    };
    Route.prototype._initComputation = function () {
        this._currentComputation = 'fastest';
        var serviceOptions = this.options.routeOptions;
        if (serviceOptions.routePreference) {
            this._currentComputation = serviceOptions.routePreference;
        }
    };
    Route.prototype._initExclusions = function () {
        this._currentExclusions = [];
        var exclusion = this.options.exclusions;
        if (!exclusion || typeof exclusion === 'object' && Object.keys(exclusion).length === 0) {
            this.options.exclusions = {
                toll: false,
                tunnel: false,
                bridge: false
            };
        }
        if (exclusion && typeof exclusion === 'object' && Object.keys(exclusion).length) {
            for (var k in exclusion) {
                if (exclusion.hasOwnProperty(k)) {
                    if (exclusion[k]) {
                        this._currentExclusions.push(k);
                    }
                }
            }
        }
        var serviceOptions = this.options.routeOptions;
        if (Array.isArray(serviceOptions.exclusions)) {
            this._currentExclusions = serviceOptions.exclusions;
        }
    };
    Route.prototype._initPopupDiv = function () {
        var context = this;
        var element = document.createElement('div');
        element.className = 'gp-feature-info-div';
        var closer = document.createElement('input');
        closer.type = 'button';
        closer.className = 'gp-styling-button closer';
        closer.onclick = function () {
            if (context._popupOverlay != null) {
                context._popupOverlay.setPosition(undefined);
            }
            return false;
        };
        this._popupContent = document.createElement('div');
        this._popupContent.className = 'gp-features-content-div';
        element.appendChild(this._popupContent);
        element.appendChild(closer);
        return element;
    };
    Route.prototype._createRoutePanelFormPointsElement = function (map) {
        var points = [];
        var count = 1;
        var start = new LocationSelector({
            apiKey: this.options.apiKey || null,
            tag: {
                id: count,
                groupId: this._uid,
                markerOpts: this.options.markersOpts['departure'],
                label: 'Dpart',
                display: true
            },
            autocompleteOptions: this.options.autocompleteOptions || null
        });
        start.setMap(map);
        this._addFormPointsEventListeners(start);
        points.push(start._container);
        this._currentPoints.push(start);
        for (count = 2; count < 7; count++) {
            var step = new LocationSelector({
                apiKey: this.options.apiKey || null,
                tag: {
                    id: count,
                    groupId: this._uid,
                    label: 'Etape',
                    markerOpts: this.options.markersOpts['stages'],
                    display: false,
                    removeOption: true
                },
                autocompleteOptions: this.options.autocompleteOptions || null
            });
            step.setMap(map);
            this._addFormPointsEventListeners(step);
            points.push(step._container);
            this._currentPoints.push(step);
        }
        var end = new LocationSelector({
            apiKey: this.options.apiKey || null,
            tag: {
                id: count,
                groupId: this._uid,
                markerOpts: this.options.markersOpts['arrival'],
                label: 'Arrive',
                display: true,
                addOption: true
            },
            autocompleteOptions: this.options.autocompleteOptions || null
        });
        end.setMap(map);
        this._addFormPointsEventListeners(end);
        points.push(end._container);
        this._currentPoints.push(end);
        return points;
    };
    Route.prototype._addFormPointsEventListeners = function (formPoint) {
        if (!formPoint) {
            return;
        }
        var context = this;
        if (formPoint._inputLabelContainer.addEventListener) {
            formPoint._inputLabelContainer.addEventListener('click', function () {
                context.onRouteOriginLabelClick.call(this, context);
            });
            formPoint._inputShowPointer.addEventListener('click', function () {
                context.onRouteOriginPointerClick.call(this, context, formPoint);
            });
            if (formPoint._removePointElement) {
                formPoint._removePointElement.addEventListener('click', function () {
                    var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
                    context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + 'px';
                });
            }
            if (formPoint._addPointElement) {
                formPoint._addPointElement.addEventListener('click', function () {
                    var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
                    context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + 'px';
                });
            }
        } else if (formPoint._inputLabelContainer.attachEvent) {
            formPoint._inputLabelContainer.attachEvent('onclick', function () {
                context.onRouteOriginLabelClick.call(this, context);
            });
            formPoint._inputShowPointer.attachEvent('onclick', function () {
                context.onRouteOriginPointerClick.call(this, context, formPoint);
            });
            if (formPoint._removePointElement) {
                formPoint._removePointElement.attachEvent('onclick', function () {
                    var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
                    context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + 'px';
                });
            }
            if (formPoint._addPointElement) {
                formPoint._addPointElement.attachEvent('onclick', function () {
                    var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
                    context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + 'px';
                });
            }
        }
    };
    Route.prototype.onRouteComputationSubmit = function (options) {
        var points = this._currentPoints;
        var start;
        if (points[0] && points[0].getCoordinate) {
            var startCoordinate = points[0].getCoordinate();
            start = {
                x: startCoordinate[0],
                y: startCoordinate[1]
            };
        }
        var end;
        var endPoint = points[points.length - 1];
        if (endPoint && endPoint.getCoordinate) {
            var endCoordinate = endPoint.getCoordinate();
            end = {
                x: endCoordinate[0],
                y: endCoordinate[1]
            };
        }
        var step = [];
        for (var i = 1; i < points.length - 1; i++) {
            if (points[i] && points[i].getCoordinate) {
                var iCoordinate = points[i].getCoordinate();
                if (iCoordinate) {
                    var coordinate = {
                        x: iCoordinate[0],
                        y: iCoordinate[1]
                    };
                    step.push(coordinate);
                }
            }
        }
        if (this._noRightManagement) {
            return;
        }
        this._currentTransport = options.transport;
        this._currentComputation = options.computation;
        this._currentExclusions = options.exclusions;
        var routeOptions = this.options.routeOptions;
        var _protocol = routeOptions.protocol || 'XHR';
        var _timeout = routeOptions.timeOut || 0;
        if (_protocol === 'JSONP' && _timeout === 0) {
            _timeout = 15000;
        }
        var context = this;
        this._requestRouting({
            startPoint: start,
            endPoint: end,
            viaPoints: step,
            graph: routeOptions.graph || this._currentTransport,
            routePreference: routeOptions.routePreference || this._currentComputation,
            exclusions: routeOptions.exclusions || this._currentExclusions,
            geometryInInstructions: true,
            distanceUnit: 'm',
            timeOut: _timeout,
            protocol: _protocol,
            onSuccess: function (results) {
                if (results) {
                    context._fillRouteResultsDetails(results);
                }
            },
            onFailure: function (error) {
                context._hideWaitingContainer();
                context._clearRouteResultsDetails();
            }
        });
    };
    Route.prototype.onRouteOriginLabelClick = function (routeControl) {
        var map = routeControl.getMap();
        routeControl._formRouteContainer.className = '';
        map.un('click', function () {
            if (routeControl._formRouteContainer.className === 'GProuteFormMini') {
                routeControl._formRouteContainer.className = '';
            }
        });
    };
    Route.prototype.onRouteOriginPointerClick = function (routeControl, locationSelector) {
        var map = routeControl.getMap();
        if (locationSelector._inputShowPointerContainer.checked) {
            routeControl._formRouteContainer.className = 'GProuteFormMini';
            map.on('click', function () {
                if (routeControl._formRouteContainer.className === 'GProuteFormMini') {
                    routeControl._formRouteContainer.className = '';
                }
            });
        } else {
            routeControl._formRouteContainer.className = '';
            map.un('click', function () {
                if (routeControl._formRouteContainer.className === 'GProuteFormMini') {
                    routeControl._formRouteContainer.className = '';
                }
            });
        }
    };
    Route.prototype.onShowRoutePanelClick = function () {
        if (!this._geojsonSections && !this._waiting) {
            this._clear();
        }
        this.collapsed = document.getElementById('GPshowRoute-' + this._uid).checked;
        this.dispatchEvent('change:collapsed');
    };
    Route.prototype.onRouteModeComputationChange = function (e) {
        var idx = e.target.selectedIndex;
        var value = e.target.options[idx].value;
        if (!value) {
            return;
        }
        this._currentComputation = value;
    };
    Route.prototype.onRouteModeComputationChangeAndRun = function (e) {
        this.onRouteModeComputationChange(e);
        this._clearRouteResultsDetails();
        this._clearRouteResultsGeometry();
        this._clearRouteResultsFeatureGeometry();
        this.onRouteComputationSubmit({
            computation: this._currentComputation,
            transport: this._currentTransport,
            exclusions: this._currentExclusions
        });
    };
    Route.prototype.onRouteModeTransportChange = function (e) {
        var value = e.target.value;
        if (!value) {
            return;
        }
        this._currentTransport = value;
    };
    Route.prototype.onShowRouteExclusionsClick = function (e) {
    };
    Route.prototype.onRouteExclusionsChange = function (e) {
        var value = e.target.value;
        var checked = e.target.checked;
        if (!value || typeof value !== 'string') {
            return;
        }
        value = value.toLowerCase();
        var bFound = false;
        var iFound = null;
        for (var i = 0; i < this._currentExclusions.length; i++) {
            if (this._currentExclusions[i] === value) {
                iFound = i;
                bFound = true;
            }
        }
        if (!bFound && !checked) {
            this._currentExclusions.push(value);
        }
        if (bFound && checked) {
            this._currentExclusions.splice(iFound, 1);
        }
    };
    Route.prototype.onRouteResetClick = function () {
        var currentPoints = this._currentPoints;
        for (var i = 0; i < currentPoints.length; i++) {
            currentPoints[i].clear();
        }
        this._clear();
        this._clearRouteInputOptions();
    };
    Route.prototype.onShowRouteResultsNewClick = function () {
        this._clearRouteResultsDetails();
        this._clearRouteResultsGeometry();
        this._clearRouteResultsFeatureGeometry();
    };
    Route.prototype.onRouteResultsDetailsMouseOver = function (e) {
        var tagid = e.target.id;
        var idx = tagid.substring(tagid.indexOf('_') + 1);
        if (e.target.classList) {
            e.target.classList.add('GProuteResultsDetailsInstructionHighlight');
        }
        if (!this._geojsonSections) {
            return;
        }
        var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10));
        f.setStyle(this._selectedFeatureStyle);
    };
    Route.prototype.onRouteResultsDetailsMouseOut = function (e) {
        var tagid = e.target.id;
        var idx = tagid.substring(tagid.indexOf('_') + 1);
        if (e.target.classList) {
            e.target.classList.remove('GProuteResultsDetailsInstructionHighlight');
        }
        if (!this._geojsonSections) {
            return;
        }
        var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10));
        f.setStyle(null);
    };
    Route.prototype._requestRouting = function (options) {
        if (!options || typeof options === 'object' && Object.keys(options).length === 0) {
            return;
        }
        if (!options.startPoint) {
            return;
        }
        if (!options.endPoint) {
            return;
        }
        if (this._noRightManagement || !this._resources['Itineraire']) {
            return;
        }
        var resources = this._resources['Itineraire'].resources;
        if (!resources || typeof resources === 'object' && Object.keys(resources).length === 0) {
            return;
        }
        var key = this._resources['Itineraire']['key'];
        var bFound = false;
        for (var i = 0; i < resources.length; i++) {
            if (resources[i] === options.graph) {
                bFound = true;
            }
        }
        if (!bFound) {
            console.log('no rights for this service !?');
            return;
        }
        options.apiKey = this.options.routeOptions.apiKey || this.options.apiKey || key;
        this._displayWaitingContainer();
        Gp.Services.route(options);
    };
    Route.prototype._fillRouteResultsDetails = function (results) {
        var distance = results.totalDistance;
        var duration = results.totalTime;
        var instructions = this._simplifiedInstructions(results.routeInstructions);
        if (instructions) {
            this._fillRouteResultsDetailsContainer(distance, duration, instructions);
        }
        var geometry = results.routeGeometry;
        if (geometry) {
            this._fillRouteResultsDetailsGeometry(geometry, this._defaultFeatureStyle);
        }
        if (instructions && instructions[0].geometry) {
            this._fillRouteResultsDetailsFeatureGeometry(instructions, this._defaultFeatureStyle);
        }
        var bbox = results.bbox;
        if (bbox) {
            var map = this.getMap();
            var bounds = [
                bbox.left,
                bbox.bottom,
                bbox.right,
                bbox.top
            ];
            var mapProj = map.getView().getProjection().getCode();
            if (mapProj !== 'EPSG:4326') {
                bounds = ol.proj.transformExtent(bounds, 'EPSG:4326', mapProj);
            }
            map.getView().fit(bounds, map.getSize());
        }
        this._currentRouteInformations = results;
        this._formRouteContainer.className = 'GProuteComponentHidden';
        this._hideWaitingContainer();
        this._resultsRouteContainer.className = '';
    };
    Route.prototype._fillRouteResultsDetailsContainer = function (distance, duration, instructions) {
        this._resultsRouteValuesContainer = this._addRouteResultsValuesElement(distance, duration, this._convertSecondsToTime);
        this._resultsRouteDetailsContainer = this._addRouteResultsDetailsElement(instructions, this._convertSecondsToTime);
    };
    Route.prototype._fillRouteResultsDetailsGeometry = function (geometry, style) {
        this._clearRouteResultsGeometry();
        var map = this.getMap();
        if (!geometry) {
            return;
        }
        var geojsonObject = {
            type: 'Feature',
            crs: {
                type: 'name',
                properties: { name: 'EPSG:4326' }
            },
            geometry: geometry
        };
        var geojsonformat = new ol.format.GeoJSON({ defaultDataProjection: 'EPSG:4326' });
        var features = geojsonformat.readFeatures(geojsonObject, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:3857'
        });
        this._geojsonRoute = new ol.layer.Vector({
            source: new ol.source.Vector({ features: features }),
            style: style
        });
        map.addLayer(this._geojsonRoute);
    };
    Route.prototype._fillRouteResultsDetailsFeatureGeometry = function (instructions, style) {
        this._clearRouteResultsFeatureGeometry();
        var map = this.getMap();
        var geojsonObject = {
            type: 'FeatureCollection',
            crs: {
                type: 'name',
                properties: { name: 'EPSG:4326' }
            },
            features: []
        };
        for (var i = 0; i < instructions.length; i++) {
            var o = instructions[i];
            var id = i + 1;
            var coords = o.geometry.coordinates;
            for (var j = 0; j < coords.length; j++) {
                if (typeof coords[j][0] === 'string') {
                    coords[j][0] = parseFloat(coords[j][0]);
                    coords[j][1] = parseFloat(coords[j][1]);
                }
            }
            geojsonObject.features.push({
                type: 'Feature',
                geometry: o.geometry,
                properties: { popupContent: '(' + id + ') distance : ' + this._convertDistance(o.distance) + ' / temps : ' + this._convertSecondsToTime(o.duration) },
                id: id
            });
        }
        var geojsonformat = new ol.format.GeoJSON({ defaultDataProjection: 'EPSG:4326' });
        var mapProj = this.getMap().getView().getProjection().getCode();
        var features = geojsonformat.readFeatures(geojsonObject, {
            dataProjection: 'EPSG:4326',
            featureProjection: mapProj
        });
        this._geojsonSections = new ol.layer.Vector({
            source: new ol.source.Vector({ features: features }),
            style: style,
            opacity: 0.9
        });
        var graph;
        if (this._currentTransport === 'Pieton') {
            graph = 'piton';
            this._geojsonSections.gpResultLayerId = 'Pieton$OGC:OPENLS;Itineraire';
        } else {
            graph = 'voiture';
            this._geojsonSections.gpResultLayerId = 'Voiture$OGC:OPENLS;Itineraire';
        }
        map.addLayer(this._geojsonSections);
        map.getControls().forEach(function (control) {
            if (control instanceof LayerSwitcher) {
                var layerId = this._geojsonSections.gpLayerId;
                if (control._layers[layerId].title === layerId) {
                    control.addLayer(this._geojsonSections, {
                        title: ' Itinraire ' + graph,
                        description: ' Itinraire bas sur un graphe ' + graph
                    });
                }
            }
        }, this);
        this._resultsHoverInteraction = new ol.interaction.Select({
            condition: ol.events.condition.pointerMove,
            layers: [this._geojsonSections],
            style: this._selectedFeatureStyle
        });
        this._resultsHoverInteraction.on('select', this._onResultsFeatureMouseOver, this);
        map.addInteraction(this._resultsHoverInteraction);
        this._resultsSelectInteraction = new ol.interaction.Select({
            layers: [this._geojsonSections],
            style: this._selectedFeatureStyle
        });
        this._resultsSelectInteraction.on('select', this._onResultsFeatureSelect, this);
        map.addInteraction(this._resultsSelectInteraction);
    };
    Route.prototype._onResultsFeatureMouseOver = function (e) {
        if (e.selected.length !== 0) {
            var f = e.selected[0];
            var selectedInstruction = document.getElementById('GProuteResultsDetailsInstruction_' + f.getId() + '-' + this._uid);
            if (selectedInstruction && selectedInstruction.classList) {
                selectedInstruction.classList.add('GProuteResultsDetailsInstructionHighlight');
            }
        }
        if (e.deselected.length !== 0) {
            var deselectedFeature = e.deselected[0];
            var deSelectedInstruction = document.getElementById('GProuteResultsDetailsInstruction_' + deselectedFeature.getId() + '-' + this._uid);
            if (deSelectedInstruction && deSelectedInstruction.classList) {
                deSelectedInstruction.classList.remove('GProuteResultsDetailsInstructionHighlight');
            }
        }
    };
    Route.prototype._onResultsFeatureSelect = function (e) {
        var map = this.getMap();
        if (e.selected.length !== 0) {
            var f = e.selected[0];
            this._popupContent.innerHTML = f.getProperties().popupContent;
            if (!this._popupOverlay) {
                this._popupOverlay = new ol.Overlay({
                    element: this._popupDiv,
                    positioning: 'bottom-center',
                    position: e.mapBrowserEvent.coordinate
                });
                map.addOverlay(this._popupOverlay);
            } else {
                this._popupOverlay.setPosition(e.mapBrowserEvent.coordinate);
            }
        } else {
            if (this._popupOverlay != null) {
                this._popupOverlay.setPosition(undefined);
            }
        }
    };
    Route.prototype._clear = function () {
        this._currentTransport = null;
        this._currentExclusions = [];
        this._currentComputation = null;
        this._clearRouteResultsDetails();
        this._clearRouteResultsGeometry();
        this._clearRouteResultsFeatureGeometry();
        for (var i = 0; i < this._currentPoints.length; i++) {
            this._currentPoints[i].clear();
        }
        this._removeRouteStepLocations();
    };
    Route.prototype._clearRouteInputOptions = function () {
        this._initTransport();
        this._initComputation();
        this._initExclusions();
        var transportdiv;
        if (this._currentTransport === 'Pieton') {
            transportdiv = document.getElementById('GProuteTransportPedestrian-' + this._uid);
            if (transportdiv) {
                transportdiv.checked = 'true';
            }
        } else {
            transportdiv = document.getElementById('GProuteTransportCar-' + this._uid);
            if (transportdiv) {
                transportdiv.checked = 'true';
            }
        }
        var computationdiv = document.getElementById('GProuteComputationSelect-' + this._uid);
        if (computationdiv) {
            computationdiv.value = this._currentComputation;
        }
        var tollInput = document.getElementById('GProuteExclusionsToll-' + this._uid);
        if (tollInput) {
            if (this._currentExclusions.indexOf('toll') !== -1) {
                tollInput.checked = false;
            } else {
                tollInput.checked = true;
            }
        }
        var tunnelInput = document.getElementById('GProuteExclusionsTunnel-' + this._uid);
        if (tunnelInput) {
            if (this._currentExclusions.indexOf('tunnel') !== -1) {
                tunnelInput.checked = false;
            } else {
                tunnelInput.checked = true;
            }
        }
        var bridgeInput = document.getElementById('GProuteExclusionsBridge-' + this._uid);
        if (bridgeInput) {
            if (this._currentExclusions.indexOf('bridge') !== -1 && bridgeInput) {
                bridgeInput.checked = false;
            } else {
                bridgeInput.checked = true;
            }
        }
    };
    Route.prototype._removeRouteStepLocations = function () {
        var points = document.querySelectorAll('div[id^="GPlocationPoint"]');
        var stepPoints = 0;
        if (points.length !== 0) {
            for (var i = 1; i < points.length - 1; i++) {
                var classList = points[i].classList;
                if (classList.length !== 0) {
                    for (var j = 0; j < classList.length; j++) {
                        if (classList[j] === 'GPlocationStageFlexInput') {
                            document.getElementById(this._addUID('GPlocationStageRemove_' + (i + 1))).click();
                            stepPoints += 1;
                        }
                    }
                }
            }
        }
    };
    Route.prototype._clearRouteResultsDetails = function () {
        this._currentRouteInformations = null;
        if (this._resultsRouteDetailsContainer) {
            var detailsDiv = this._resultsRouteDetailsContainer;
            if (detailsDiv.childElementCount) {
                while (detailsDiv.firstChild) {
                    detailsDiv.removeChild(detailsDiv.firstChild);
                }
            }
        }
        if (this._resultsRouteValuesContainer) {
            var valuesDiv = this._resultsRouteValuesContainer;
            if (valuesDiv.childElementCount) {
                while (valuesDiv.firstChild) {
                    valuesDiv.removeChild(valuesDiv.firstChild);
                }
            }
        }
    };
    Route.prototype._clearRouteResultsGeometry = function () {
        var map = this.getMap();
        if (this._geojsonRoute != null) {
            map.removeLayer(this._geojsonRoute);
            this._geojsonRoute = null;
        }
    };
    Route.prototype._clearRouteResultsFeatureGeometry = function () {
        var map = this.getMap();
        if (this._geojsonSections != null) {
            map.removeLayer(this._geojsonSections);
            this._geojsonSections = null;
        }
        if (this._popupOverlay != null) {
            map.removeOverlay(this._popupOverlay);
            this._popupOverlay = null;
        }
        if (this._resultsSelectInteraction != null) {
            map.removeInteraction(this._resultsSelectInteraction);
            this._resultsSelectInteraction = null;
        }
        if (this._resultsHoverInteraction != null) {
            map.removeInteraction(this._resultsHoverInteraction);
            this._resultsHoverInteraction = null;
        }
    };
    Route.prototype._hideRouteSuggestedLocations = function (e) {
        if (e.target && e.target.id && e.target.id.indexOf('GPlocationOrigin_') !== -1) {
            var pointId = parseInt(e.target.id.split('_')[1][0], 10) - 1;
            for (var j = 0; j < this._currentPoints.length; j++) {
                if (j !== parseInt(pointId, 10)) {
                    this._currentPoints[j]._hideSuggestedLocation();
                }
            }
        } else {
            for (var i = 0; i < this._currentPoints.length; i++) {
                this._currentPoints[i]._hideSuggestedLocation();
            }
        }
    };
    Route.prototype._displayWaitingContainer = function () {
        this._waitingContainer.className = 'GProuteCalcWaitingContainerVisible';
        this._waiting = true;
        var opts = this.options.routeOptions;
        if (opts && opts.timeOut) {
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }
            var context = this;
            this._timer = setTimeout(function () {
                if (context._waiting === true) {
                    context._hideWaitingContainer();
                } else {
                    if (context._timer) {
                        clearTimeout(context._timer);
                    }
                }
            }, 16000);
        }
    };
    Route.prototype._hideWaitingContainer = function () {
        if (this._waiting) {
            this._waitingContainer.className = 'GProuteCalcWaitingContainerHidden';
            this._waiting = false;
            var opts = this.options.routeOptions;
            if (opts && opts.timeOut) {
                clearTimeout(this._timer);
                this._timer = null;
            }
        }
    };
    Route.prototype._simplifiedInstructions = function (instructions) {
        var newInstructions = [];
        var current = instructions[0];
        if (instructions.length === 1) {
            newInstructions.push(current);
        }
        for (var i = 1; i < instructions.length; i++) {
            var o = instructions[i];
            if (o.instruction === current.instruction) {
                current.distance = (parseFloat(o.distance) + parseFloat(current.distance)).toString();
                current.duration = (parseFloat(o.duration) + parseFloat(current.duration)).toString();
                for (var j = 1; j < o.geometry.coordinates.length; j++) {
                    current.geometry.coordinates.push(o.geometry.coordinates[j]);
                }
            } else {
                newInstructions.push(current);
                current = o;
                if (i === instructions.length - 1) {
                    newInstructions.push(o);
                    current = null;
                }
            }
        }
        return newInstructions;
    };
    Route.prototype._convertSecondsToTime = function (duration) {
        var time = '';
        duration = Math.round(duration);
        var hours = Math.floor(duration / (60 * 60));
        var divisor4minutes = duration % (60 * 60);
        var minutes = Math.floor(divisor4minutes / 60);
        if (hours) {
            time = hours + 'h ';
        }
        time += minutes + ' min';
        return time;
    };
    Route.prototype._convertDistance = function (distance) {
        var d = '';
        var distanceKm = parseInt(distance / 1000, 10);
        if (!distanceKm) {
            d = parseInt(distance, 10) + ' m';
        } else {
            d = distanceKm + ' km';
        }
        return d;
    };
    return Route;
}(ol, gp, Ol3Utils, {}, CommonUtilsCheckRightManagement, CommonUtilsSelectorID, Ol3ControlsLocationSelector, Ol3ControlsLayerSwitcher, Ol3ControlsUtilsMarkers, CommonControlsRouteDOM);
CommonControlsIsoDOM = function () {
    var IsoDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPisochron');
            container.className = 'GPwidget';
            return container;
        },
        _createShowIsoElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowIsochron');
            input.type = 'checkbox';
            return input;
        },
        _createShowIsoPictoElement: function () {
            var context = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowIsochronPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowIsochron');
            label.title = 'Calculer une isochrone';
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    context.onShowIsoPanelClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    context.onShowIsoPanelClick(e);
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowIsochronOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createIsoPanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronPanel');
            div.className = 'GPpanel';
            return div;
        },
        _createIsoPanelHeaderElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var div = document.createElement('div');
            div.className = 'GPpanelTitle';
            div.innerHTML = 'Calcul d\'isochrone';
            container.appendChild(div);
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GPisochronPanelClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer le panneau';
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPshowIsochronPicto')).click();
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPshowIsochronPicto')).click();
                });
            }
            container.appendChild(divClose);
            return container;
        },
        _createIsoPanelFormElement: function () {
            var self = this;
            var form = document.createElement('form');
            form.id = this._addUID('GPisochronForm');
            form.addEventListener('submit', function (e) {
                e.preventDefault();
                self.onIsoComputationSubmit(e);
                return false;
            });
            return form;
        },
        _createIsoWaitingElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronCalcWaitingContainer');
            div.className = 'GPisochronCalcWaitingContainerHidden';
            var p = document.createElement('p');
            p.className = 'GPisochronCalcWaiting';
            p.innerHTML = 'Calcul en cours...';
            div.appendChild(p);
            return div;
        },
        _createIsoPanelFormTypeChoiceElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronChoice');
            return div;
        },
        _createIsoPanelFormTypeChoiceChronElement: function (checked) {
            var self = this;
            var div = document.createElement('div');
            div.className = 'GPisochronChoiceAlt';
            var input = document.createElement('input');
            input.id = this._addUID('GPisochronChoiceAltChron');
            input.name = 'GPisochronChoiceMode';
            input.type = 'radio';
            input.checked = checked ? true : false;
            if (input.addEventListener) {
                input.addEventListener('change', function (e) {
                    document.getElementById(self._addUID('GPisochronValueChron')).className = 'GPflexInput';
                    document.getElementById(self._addUID('GPisochronValueDist')).className = 'GPisochronValueHidden';
                    self.onIsoTypeChoiceChange(e);
                }, false);
            } else if (input.attachEvent) {
                input.attachEvent('onchange', function () {
                    document.getElementById(self._addUID('GPisochronValueChron')).className = 'GPflexInput';
                    document.getElementById(self._addUID('GPisochronValueDist')).className = 'GPisochronValueHidden';
                    self.onIsoTypeChoiceChange();
                });
            }
            input.value = 'isochron';
            div.appendChild(input);
            var label = document.createElement('label');
            label.className = 'GPisochronChoiceAltImg';
            label.htmlFor = this._addUID('GPisochronChoiceAltChron');
            div.appendChild(label);
            var span = document.createElement('span');
            span.id = this._addUID('GPisochronChoiceAltChronTxt');
            span.innerHTML = 'isochrone';
            if (span.addEventListener) {
                span.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPisochronChoiceAltChron')).click();
                }, false);
            } else if (span.attachEvent) {
                span.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPisochronChoiceAltChron')).click();
                });
            }
            div.appendChild(span);
            return div;
        },
        _createIsoPanelFormTypeChoiceDistElement: function (checked) {
            var self = this;
            var div = document.createElement('div');
            div.className = 'GPisochronChoiceAlt';
            var input = document.createElement('input');
            input.id = this._addUID('GPisochronChoiceAltDist');
            input.name = 'GPisochronChoiceMode';
            input.type = 'radio';
            input.checked = checked ? true : false;
            if (input.addEventListener) {
                input.addEventListener('change', function (e) {
                    document.getElementById(self._addUID('GPisochronValueDist')).className = 'GPflexInput';
                    document.getElementById(self._addUID('GPisochronValueChron')).className = 'GPisochronValueHidden';
                    self.onIsoTypeChoiceChange(e);
                }, false);
            } else if (input.attachEvent) {
                input.attachEvent('onchange', function () {
                    document.getElementById(self._addUID('GPisochronValueDist')).className = 'GPflexInput';
                    document.getElementById(self._addUID('GPisochronValueChron')).className = 'GPisochronValueHidden';
                    self.onIsoTypeChoiceChange();
                });
            }
            input.value = 'isodistance';
            div.appendChild(input);
            var label = document.createElement('label');
            label.className = 'GPisochronChoiceAltImg';
            label.htmlFor = this._addUID('GPisochronChoiceAltDist');
            div.appendChild(label);
            var span = document.createElement('span');
            span.id = this._addUID('GPisochronChoiceAltDistTxt');
            span.innerHTML = 'isodistance';
            if (span.addEventListener) {
                span.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPisochronChoiceAltDist')).click();
                }, false);
            } else if (span.attachEvent) {
                span.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPisochronChoiceAltDist')).click();
                });
            }
            div.appendChild(span);
            return div;
        },
        _createIsoPanelFormValueIsochronElement: function (checked) {
            var context = this;
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronValueChron');
            div.className = checked ? 'GPflexInput' : 'GPisochronValueHidden';
            var label = document.createElement('label');
            label.id = this._addUID('GPisochronValueChronLabel');
            label.htmlFor = this._addUID('GPisochronValueChronInput');
            label.innerHTML = 'Temps';
            div.appendChild(label);
            var input1 = document.createElement('input');
            input1.id = this._addUID('GPisochronValueChronInput1');
            input1.min = '0';
            input1.step = '1';
            input1.value = '0';
            input1.type = 'number';
            if (input1.addEventListener) {
                input1.addEventListener('change', function (e) {
                    if (typeof context.onIsoValueChronTimeMinuteChange === 'function') {
                        context.onIsoValueChronTimeHourChange(e);
                    }
                });
            } else if (input1.attachEvent) {
                input1.attachEvent('onchange', function (e) {
                    if (typeof context.onIsoValueChronTimeMinuteChange === 'function') {
                        context.onIsoValueChronTimeHourChange(e);
                    }
                });
            }
            div.appendChild(input1);
            var label1 = document.createElement('label');
            label1.innerHTML = 'h';
            div.appendChild(label1);
            var input2 = document.createElement('input');
            input2.id = this._addUID('GPisochronValueChronInput2');
            input2.min = '0';
            input2.max = '59';
            input2.step = '1';
            input2.value = '0';
            input2.type = 'number';
            if (input2.addEventListener) {
                input2.addEventListener('change', function (e) {
                    if (typeof context.onIsoValueChronTimeMinuteChange === 'function') {
                        context.onIsoValueChronTimeMinuteChange(e);
                    }
                });
            } else if (input2.attachEvent) {
                input2.attachEvent('onchange', function (e) {
                    if (typeof context.onIsoValueChronTimeMinuteChange === 'function') {
                        context.onIsoValueChronTimeMinuteChange(e);
                    }
                });
            }
            div.appendChild(input2);
            var label2 = document.createElement('label');
            label2.innerHTML = 'min';
            div.appendChild(label2);
            return div;
        },
        _createIsoPanelFormValueIsodistanceElement: function (checked) {
            var context = this;
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronValueDist');
            div.className = checked ? 'GPflexInput' : 'GPisochronValueHidden';
            var label = document.createElement('label');
            label.id = this._addUID('GPisochronValueDistLabel');
            label.htmlFor = this._addUID('GPisochronValueDistInput');
            label.innerHTML = 'Distance';
            div.appendChild(label);
            var input1 = document.createElement('input');
            input1.id = this._addUID('GPisochronValueDistInput');
            input1.min = '0';
            input1.step = 'any';
            input1.value = '0';
            input1.type = 'number';
            if (input1.addEventListener) {
                input1.addEventListener('change', function (e) {
                    if (typeof context.onIsoValueDistChange === 'function') {
                        context.onIsoValueDistChange(e);
                    }
                });
            } else if (input1.attachEvent) {
                input1.attachEvent('onchange', function (e) {
                    if (typeof context.onIsoValueDistChange === 'function') {
                        context.onIsoValueDistChange(e);
                    }
                });
            }
            div.appendChild(input1);
            var label1 = document.createElement('label');
            label1.innerHTML = 'km';
            div.appendChild(label1);
            return div;
        },
        _createIsoPanelFormModeChoiceElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronModeChoice');
            return div;
        },
        _createIsoPanelFormModeChoiceTransportElement: function (transports) {
            var context = this;
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronTransportChoice');
            var span = document.createElement('span');
            span.className = 'GPisochronModeLabel';
            span.innerHTML = 'Mode de transport';
            div.appendChild(span);
            for (var i = 0; i < transports.length; i++) {
                var transport = transports[i];
                if (transport === 'Voiture') {
                    var inputCar = document.createElement('input');
                    inputCar.id = this._addUID('GPisochronTransportCar');
                    inputCar.type = 'radio';
                    inputCar.name = 'GPisochronTransport';
                    if (i === 0) {
                        inputCar.checked = true;
                    }
                    if (inputCar.addEventListener) {
                        inputCar.addEventListener('change', function (e) {
                            context.onIsoModeTransportChange(e);
                        });
                    } else if (inputCar.attachEvent) {
                        inputCar.attachEvent('onchange', function (e) {
                            context.onIsoModeTransportChange(e);
                        });
                    }
                    inputCar.value = 'Voiture';
                    div.appendChild(inputCar);
                    var labelCar = document.createElement('label');
                    labelCar.className = 'GPisochronTransportImg';
                    labelCar.htmlFor = this._addUID('GPisochronTransportCar');
                    labelCar.title = 'Voiture';
                    div.appendChild(labelCar);
                }
                if (transport === 'Pieton') {
                    var inputPedestrian = document.createElement('input');
                    inputPedestrian.id = this._addUID('GPisochronTransportPedestrian');
                    inputPedestrian.type = 'radio';
                    inputPedestrian.name = 'GPisochronTransport';
                    if (i === 0) {
                        inputPedestrian.checked = true;
                    }
                    if (inputPedestrian.addEventListener) {
                        inputPedestrian.addEventListener('change', function (e) {
                            context.onIsoModeTransportChange(e);
                        });
                    } else if (inputPedestrian.attachEvent) {
                        inputPedestrian.attachEvent('onchange', function (e) {
                            context.onIsoModeTransportChange(e);
                        });
                    }
                    inputPedestrian.value = 'Pieton';
                    div.appendChild(inputPedestrian);
                    var labelPedestrian = document.createElement('label');
                    labelPedestrian.className = 'GPisochronTransportImg';
                    labelPedestrian.htmlFor = this._addUID('GPisochronTransportPedestrian');
                    labelPedestrian.title = 'Piton';
                    div.appendChild(labelPedestrian);
                }
            }
            return div;
        },
        _createIsoPanelFormModeChoiceDirectionElement: function (directions) {
            var self = this;
            var div = document.createElement('div');
            div.id = this._addUID('GPisochronDirectionChoice');
            var span = document.createElement('span');
            span.className = 'GPisochronModeLabel';
            span.innerHTML = 'Sens de parcours';
            div.appendChild(span);
            var select = document.createElement('select');
            select.id = this._addUID('GPisochronDirectionSelect');
            select.className = 'GPinputSelect';
            select.addEventListener('change', function (e) {
                self.onIsoModeDirectionChange(e);
            });
            for (var i = 0; i < directions.length; i++) {
                var direction = directions[i];
                if (direction.toLowerCase() === 'departure') {
                    var departureOption = document.createElement('option');
                    if (i === 0) {
                        departureOption.selected = 'selected';
                    }
                    departureOption.value = 'departure';
                    departureOption.text = 'Dpart';
                    select.appendChild(departureOption);
                }
                if (direction.toLowerCase() === 'arrival') {
                    var arrivalOption = document.createElement('option');
                    if (i === 0) {
                        arrivalOption.selected = 'selected';
                    }
                    arrivalOption.value = 'arrival';
                    arrivalOption.text = 'Arrive';
                    select.appendChild(arrivalOption);
                }
            }
            div.appendChild(select);
            return div;
        },
        _createShowIsoExclusionsElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowIsoExclusions');
            input.type = 'checkbox';
            return input;
        },
        _createShowIsoExclusionsPictoElement: function () {
            var label = document.createElement('label');
            label.id = this._addUID('GPshowIsoExclusionsPicto');
            label.className = 'GPshowMoreOptions GPshowIsoExclusionsPicto';
            label.htmlFor = this._addUID('GPshowIsoExclusions');
            label.title = 'Exclusions';
            label.style.top = '240px';
            return label;
        },
        _createIsoPanelFormExclusionsElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPisoExclusions');
            var span = document.createElement('span');
            span.className = 'GPisoExclusionsLabel';
            span.innerHTML = 'Passages autoriss';
            div.appendChild(span);
            return div;
        },
        _createIsoPanelFormExclusionOptionsElement: function (exclusions) {
            var context = this;
            var div = document.createElement('div');
            div.className = 'GPisoExclusionsOptions';
            for (var value in exclusions) {
                if (exclusions.hasOwnProperty(value)) {
                    var status = exclusions[value];
                    switch (value) {
                    case 'toll':
                        var inputToll = document.createElement('input');
                        inputToll.id = this._addUID('GPisoExclusionsToll');
                        inputToll.type = 'checkbox';
                        inputToll.checked = !status;
                        if (inputToll.addEventListener) {
                            inputToll.addEventListener('change', function (e) {
                                context.onIsoExclusionsChange(e);
                            });
                        } else if (inputToll.attachEvent) {
                            inputToll.attachEvent('onchange', function (e) {
                                context.onIsoExclusionsChange(e);
                            });
                        }
                        inputToll.value = 'Toll';
                        div.appendChild(inputToll);
                        var labelToll = document.createElement('label');
                        labelToll.className = 'GPisoExclusionsOption';
                        labelToll.htmlFor = this._addUID('GPisoExclusionsToll');
                        labelToll.innerHTML = 'Pages';
                        div.appendChild(labelToll);
                        break;
                    case 'tunnel':
                        var inputTunnel = document.createElement('input');
                        inputTunnel.id = this._addUID('GPisoExclusionsTunnel');
                        inputTunnel.type = 'checkbox';
                        inputTunnel.checked = !status;
                        if (inputTunnel.addEventListener) {
                            inputTunnel.addEventListener('change', function (e) {
                                context.onIsoExclusionsChange(e);
                            });
                        } else if (inputTunnel.attachEvent) {
                            inputTunnel.attachEvent('onchange', function (e) {
                                context.onIsoExclusionsChange(e);
                            });
                        }
                        inputTunnel.value = 'Tunnel';
                        div.appendChild(inputTunnel);
                        var labelTunnel = document.createElement('label');
                        labelTunnel.className = 'GPisoExclusionsOption';
                        labelTunnel.htmlFor = this._addUID('GPisoExclusionsTunnel');
                        labelTunnel.innerHTML = 'Tunnels';
                        div.appendChild(labelTunnel);
                        break;
                    case 'bridge':
                        var inputBridge = document.createElement('input');
                        inputBridge.id = this._addUID('GPisoExclusionsBridge');
                        inputBridge.type = 'checkbox';
                        inputBridge.checked = !status;
                        if (inputBridge.addEventListener) {
                            inputBridge.addEventListener('change', function (e) {
                                context.onIsoExclusionsChange(e);
                            });
                        } else if (inputBridge.attachEvent) {
                            inputBridge.attachEvent('onchange', function (e) {
                                context.onIsoExclusionsChange(e);
                            });
                        }
                        inputBridge.value = 'Bridge';
                        div.appendChild(inputBridge);
                        var labelBridge = document.createElement('label');
                        labelBridge.className = 'GPisoExclusionsOption';
                        labelBridge.htmlFor = this._addUID('GPisoExclusionsBridge');
                        labelBridge.innerHTML = 'Ponts';
                        div.appendChild(labelBridge);
                        break;
                    }
                }
            }
            return div;
        },
        _createIsoSubmitFormElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPisochronSubmit');
            input.className = 'GPinputSubmit';
            input.type = 'submit';
            input.value = 'Calculer';
            return input;
        },
        _createIsoFormResetElement: function () {
            var self = this;
            var divReset = document.createElement('div');
            divReset.id = this._addUID('GPisochronReset');
            divReset.title = 'Rinitialiser les paramtres';
            divReset.addEventListener('click', function (e) {
                self.onIsoResetClick(e);
            });
            return divReset;
        }
    };
    return IsoDOM;
}();
Ol3ControlsIsocurve = function (ol, Gp, Utils, woodman, RightManagement, SelectorID, LocationSelector, LayerSwitcher, Markers, IsoDOM) {
    function Isocurve(options) {
        options = options || {};
        if (!(this instanceof Isocurve)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.initialize(options);
        this._container = this._createMainContainerElement();
        this._containerElement = null;
        if (options.element && options.element.appendChild) {
            options.element.appendChild(this._container);
            this._containerElement = options.element;
        }
        ol.control.Control.call(this, {
            element: this._containerElement || this._container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(Isocurve, ol.control.Control);
    Isocurve.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(Isocurve.prototype, IsoDOM);
    Isocurve.prototype.constructor = Isocurve;
    Isocurve.prototype.getCollapsed = function () {
        return this.collapsed;
    };
    Isocurve.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] Isocurve:setCollapsed - missing collapsed parameter');
            return;
        }
        if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
            return;
        }
        if (collapsed) {
            document.getElementById('GPisochronPanelClose-' + this._uid).click();
        } else {
            document.getElementById('GPshowIsochronPicto-' + this._uid).click();
        }
        this.collapsed = collapsed;
    };
    Isocurve.prototype.getLayer = function () {
        return this._geojsonLayer;
    };
    Isocurve.prototype.setMap = function (map) {
        if (map) {
            this._container = this._initContainer(map);
        }
        ol.control.Control.prototype.setMap.call(this, map);
    };
    Isocurve.prototype.initialize = function (options) {
        this._checkInputOptions(options);
        this.options = {
            collapsed: true,
            methods: [
                'time',
                'distance'
            ],
            graphs: [
                'Voiture',
                'Pieton'
            ],
            exclusions: {
                toll: false,
                tunnel: false,
                bridge: false
            },
            directions: [
                'departure',
                'arrival'
            ],
            markerOpts: {
                url: Markers['lightOrange'],
                offset: Markers.defaultOffset
            },
            isocurveOptions: {},
            autocompleteOptions: {}
        };
        Utils.assign(this.options, options);
        this.collapsed = this.options.collapsed;
        this._uid = SelectorID.generate();
        this._currentTransport = null;
        this._initTransport();
        this._currentComputation = null;
        this._initComputation();
        this._currentExclusions = [];
        this._initExclusions();
        this._currentDirection = null;
        this._initDirection();
        this._originPoint = null;
        this._showIsoContainer = null;
        this._waitingContainer = null;
        this._formContainer = null;
        this._currentIsoResults = null;
        this._geojsonLayer;
        this._waiting = false;
        this._timer = null;
        this._defaultFeatureStyle = new ol.style.Style({ fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.7)' }) });
        this._resources = {};
        this._noRightManagement = false;
        this._checkRightsManagement();
    };
    Isocurve.prototype._checkInputOptions = function (options) {
        var i;
        if (options.methods) {
            if (Array.isArray(options.methods)) {
                if (options.methods.length === 0) {
                    options.methods = null;
                } else {
                    for (i = 0; i < options.methods.length; i++) {
                        if (typeof options.methods[i] !== 'string') {
                            console.log('[ol.control.Isocurve] ERROR : parameter \'methods\' elements should be of type \'string\'');
                        }
                    }
                }
            } else {
                options.methods = null;
            }
        }
        if (options.graphs) {
            if (Array.isArray(options.graphs)) {
                if (options.graphs.length === 0) {
                    options.graphs = null;
                } else {
                    for (i = 0; i < options.graphs.length; i++) {
                        if (typeof options.graphs[i] !== 'string') {
                            console.log('[ol.control.Isocurve] ERROR : parameter \'graphs\' elements should be of type \'string\'');
                        } else {
                            if (options.graphs[i].toLowerCase() === 'pieton') {
                                options.graphs[i] = 'Pieton';
                            }
                            if (options.graphs[i].toLowerCase() === 'voiture') {
                                options.graphs[i] = 'Voiture';
                            }
                        }
                    }
                }
            } else {
                options.graphs = null;
            }
        }
        if (options.directions) {
            if (Array.isArray(options.directions)) {
                if (options.directions.length === 0) {
                    options.directions = null;
                } else {
                    for (i = 0; i < options.directions.length; i++) {
                        if (typeof options.directions[i] !== 'string') {
                            console.log('[ol.control.Isocurve] ERROR : parameter \'directions\' elements should be of type \'string\'');
                        }
                    }
                }
            } else {
                options.directions = null;
            }
        }
        if (options.collapsed === 'true') {
            options.collapsed = true;
        }
        if (options.collapsed === 'false') {
            options.collapsed = false;
        }
    };
    Isocurve.prototype._initTransport = function () {
        this._currentTransport = 'Voiture';
        var transports = this.options.graphs;
        if (!transports || transports.length === 0) {
            this.options.graphs = [
                'Voiture',
                'Pieton'
            ];
        }
        if (Array.isArray(transports) && transports.length) {
            if (transports[0] === 'Voiture' || transports[0] === 'Pieton') {
                this._currentTransport = transports[0];
            }
        }
        var serviceOptions = this.options.isocurveOptions;
        if (serviceOptions.graph) {
            this._currentTransport = serviceOptions.graph;
        }
    };
    Isocurve.prototype._initComputation = function () {
        this._currentComputation = 'time';
        var methods = this.options.methods;
        if (!methods || methods.length === 0) {
            this.options.methods = [
                'time',
                'distance'
            ];
        }
        if (Array.isArray(methods) && methods.length) {
            if (methods[0] === 'time' || methods[0] === 'distance') {
                this._currentComputation = methods[0];
            }
        }
        var serviceOptions = this.options.isocurveOptions;
        if (serviceOptions.method) {
            this._currentComputation = serviceOptions.method;
        }
        if (serviceOptions.time) {
            this._currentComputation = 'time';
        }
        if (serviceOptions.distance) {
            this._currentComputation = 'distance';
        }
    };
    Isocurve.prototype._initDirection = function () {
        this._currentDirection = 'departure';
        var directions = this.options.directions;
        if (!directions || directions.length === 0) {
            this.options.directions = [
                'departure',
                'arrival'
            ];
        }
        if (Array.isArray(directions) && directions.length) {
            if (directions[0] === 'departure' || directions[0] === 'arrival') {
                this._currentDirection = directions[0];
            }
        }
        var serviceOptions = this.options.isocurveOptions;
        if (!serviceOptions.reverse) {
            this._currentDirection = 'departure';
        }
        if (serviceOptions.reverse === true) {
            this._currentDirection = 'arrival';
            this.options.directions = [
                'arrival',
                'departure'
            ];
        }
    };
    Isocurve.prototype._initExclusions = function () {
        this._currentExclusions = [];
        var exclusion = this.options.exclusions;
        if (!exclusion || typeof exclusion === 'object' && Object.keys(exclusion).length === 0) {
            this.options.exclusions = {
                toll: false,
                tunnel: false,
                bridge: false
            };
        }
        if (exclusion && typeof exclusion === 'object' && Object.keys(exclusion).length) {
            for (var k in exclusion) {
                if (exclusion.hasOwnProperty(k)) {
                    if (exclusion.k) {
                        this._currentExclusions.push(k);
                    }
                }
            }
        }
        var serviceOptions = this.options.isocurveOptions;
        if (Array.isArray(serviceOptions.exclusions)) {
            this._currentExclusions = serviceOptions.exclusions;
        }
    };
    Isocurve.prototype._checkRightsManagement = function () {
        var _opts = null;
        var _res = [];
        var _key = null;
        _key = this.options.isocurveOptions.apiKey;
        _opts = this.options.isocurveOptions.filterOptions;
        _res = _opts ? _opts.type : [];
        if (!_res || _res.length === 0) {
            _res = [
                'Voiture',
                'Pieton'
            ];
        }
        var rightManagementIsocurve = RightManagement.check({
            key: _key || this.options.apiKey,
            resources: _res,
            services: ['Isochrone']
        });
        _key = this.options.autocompleteOptions.apiKey;
        _opts = this.options.autocompleteOptions.filterOptions;
        _res = _opts ? _opts.type : [];
        if (!_res || _res.length === 0) {
            _res = [
                'PositionOfInterest',
                'StreetAddress'
            ];
        }
        var rightManagementAutoComplete = RightManagement.check({
            key: _key || this.options.apiKey,
            resources: _res,
            services: ['AutoCompletion']
        });
        if (!rightManagementIsocurve && !rightManagementAutoComplete) {
            this._noRightManagement = true;
        }
        if (rightManagementAutoComplete) {
            this._resources['AutoCompletion'] = {};
            this._resources['AutoCompletion']['resources'] = rightManagementAutoComplete['AutoCompletion'];
            this._resources['AutoCompletion']['key'] = rightManagementAutoComplete['key'];
        }
        if (rightManagementIsocurve) {
            this._resources['Isocurve'] = {};
            this._resources['Isocurve']['resources'] = rightManagementIsocurve['Isochrone'];
            this._resources['Isocurve']['key'] = rightManagementIsocurve['key'];
        }
    };
    Isocurve.prototype._initContainer = function (map) {
        var container = this._container;
        var inputShow = this._showIsoContainer = this._createShowIsoElement();
        container.appendChild(inputShow);
        if (!this.collapsed) {
            inputShow.checked = true;
        }
        var picto = this._createShowIsoPictoElement();
        container.appendChild(picto);
        var panel = this._createIsoPanelElement();
        var header = this._createIsoPanelHeaderElement();
        panel.appendChild(header);
        var form = this._formContainer = this._createIsoPanelFormElement();
        var point = this._createIsoPanelFormPointElement(map);
        form.appendChild(point);
        var isoChronChecked = false;
        var isoDistChecked = false;
        var typeChoice = this._createIsoPanelFormTypeChoiceElement();
        for (var i = 0; i < this.options.methods.length; i++) {
            if (this.options.methods[i] === 'time') {
                isoChronChecked = i === 0 ? true : false;
                typeChoice.appendChild(this._createIsoPanelFormTypeChoiceChronElement(isoChronChecked));
            }
            if (this.options.methods[i] === 'distance') {
                isoDistChecked = i === 0 ? true : false;
                typeChoice.appendChild(this._createIsoPanelFormTypeChoiceDistElement(isoDistChecked));
            }
        }
        form.appendChild(typeChoice);
        form.appendChild(this._createIsoPanelFormValueIsochronElement(isoChronChecked));
        form.appendChild(this._createIsoPanelFormValueIsodistanceElement(isoDistChecked));
        var modeChoice = this._createIsoPanelFormModeChoiceElement();
        modeChoice.appendChild(this._createIsoPanelFormModeChoiceTransportElement(this.options.graphs));
        modeChoice.appendChild(this._createIsoPanelFormModeChoiceDirectionElement(this.options.directions));
        form.appendChild(modeChoice);
        if (this.options.exclusions && typeof this.options.exclusions === 'object' && Object.keys(this.options.exclusions).length !== 0) {
            form.appendChild(this._createShowIsoExclusionsElement());
            form.appendChild(this._createShowIsoExclusionsPictoElement());
            var exclusion = this._createIsoPanelFormExclusionsElement();
            exclusion.appendChild(this._createIsoPanelFormExclusionOptionsElement(this.options.exclusions));
            form.appendChild(exclusion);
        }
        var divReset = this._createIsoFormResetElement();
        form.appendChild(divReset);
        var submit = this._submitContainer = this._createIsoSubmitFormElement();
        form.appendChild(submit);
        panel.appendChild(form);
        var waiting = this._waitingContainer = this._createIsoWaitingElement();
        panel.appendChild(waiting);
        container.appendChild(panel);
        var context = this;
        if (container.addEventListener) {
            container.addEventListener('click', function (e) {
                context._hideIsoSuggestedLocations.call(context, e);
            });
        }
        return container;
    };
    Isocurve.prototype._createIsoPanelFormPointElement = function (map) {
        this._originPoint = new LocationSelector({
            apiKey: this.options.apiKey || null,
            tag: {
                id: 1,
                groupId: this._uid,
                markerOpts: this.options.markerOpts,
                label: 'Dpart',
                display: true
            },
            autocompleteOptions: this.options.autocompleteOptions || null
        });
        this._originPoint.setMap(map);
        var self = this;
        document.getElementById('GPlocationOriginPointerImg_1-' + this._uid).onclick = function () {
            self._clearGeojsonLayer();
            var map = self.getMap();
            if (self._originPoint._inputShowPointerContainer.checked) {
                self._formContainer.className = 'GPisochronFormMini';
                map.on('click', function () {
                    self._formContainer.className = '';
                });
            } else {
                self._formContainer.className = '';
                map.un('click', function () {
                    self._formContainer.className = '';
                });
            }
        };
        document.getElementById('GPlocationOriginLabel_1-' + this._uid).onclick = function () {
            self._clearGeojsonLayer();
            self._formContainer.className = '';
            map.un('click', function () {
                self._formContainer.className = '';
            });
        };
        document.getElementById('GPlocationOrigin_1-' + this._uid).onclick = function () {
            self._clearGeojsonLayer();
        };
        return this._originPoint._container;
    };
    Isocurve.prototype.onIsoComputationSubmit = function () {
        if (!this._originPoint || !this._originPoint.getCoordinate || !this._originPoint.getCoordinate()) {
            console.log('[Isocurve] Missing position parameter to submit isocurve request');
            return;
        }
        var positionCoordinates = this._originPoint.getCoordinate();
        var position = {
            x: positionCoordinates[0],
            y: positionCoordinates[1]
        };
        var time;
        var distance;
        if (this._currentComputation.toLowerCase() === 'time') {
            var timeHourInput = document.getElementById('GPisochronValueChronInput1-' + this._uid);
            var hours = parseInt(timeHourInput.value, 10);
            if (isNaN && isNaN(hours)) {
                hours = 0;
            }
            var timeMinutesInput = document.getElementById('GPisochronValueChronInput2-' + this._uid);
            var minutes = parseInt(timeMinutesInput.value, 10);
            if (isNaN && isNaN(minutes)) {
                minutes = 0;
            }
            time = hours * 3600 + minutes * 60;
        }
        if (this._currentComputation.toLowerCase() === 'distance') {
            var distInput = document.getElementById('GPisochronValueDistInput-' + this._uid);
            distance = parseFloat(distInput.value) * 1000;
        }
        if (!time && !distance) {
            console.log('[Isocurve] Missing time or distance parameter to submit isocurve request');
            return;
        }
        if (this._noRightManagement) {
            console.log('[Isocurve] no rights for this service');
            return;
        }
        var options = this.options.isocurveOptions || {};
        var _protocol = options.protocol || 'XHR';
        var _timeout = options.timeOut || 0;
        if (_protocol === 'JSONP' && _timeout === 0) {
            _timeout = 15000;
        }
        var context = this;
        var isoRequestOptions = {
            position: position,
            graph: options.graph || this._currentTransport,
            exclusions: options.exclusions || this._currentExclusions,
            method: options.method || this._currentComputation,
            smoothing: options.smoothing || true,
            timeOut: _timeout,
            protocol: _protocol,
            onSuccess: function (results) {
                if (results) {
                    context._drawIsoResults(results);
                }
            },
            onFailure: function (error) {
                context._hideWaitingContainer();
            }
        };
        if (this._currentDirection.toLowerCase() === 'arrival' || options.reverse) {
            isoRequestOptions.reverse = true;
        }
        if (time) {
            isoRequestOptions.time = time;
        }
        if (distance) {
            isoRequestOptions.distance = distance;
        }
        this._requestIsoCurve(isoRequestOptions);
    };
    Isocurve.prototype.onShowIsoPanelClick = function () {
        this.collapsed = this._showIsoContainer.checked;
        this.dispatchEvent('change:collapsed');
    };
    Isocurve.prototype.onIsoTypeChoiceChange = function (e) {
        var value = e.target.value;
        if (!value) {
            return;
        }
        if (value === 'isodistance') {
            this._currentComputation = 'distance';
        }
        if (value === 'isochron') {
            this._currentComputation = 'time';
        }
    };
    Isocurve.prototype.onIsoModeTransportChange = function (e) {
        var value = e.target.value;
        if (!value) {
            return;
        }
        this._currentTransport = value;
    };
    Isocurve.prototype.onIsoModeDirectionChange = function (e) {
        var value = e.target.value;
        if (!value) {
            return;
        }
        if (value.toLowerCase() === 'arrival') {
            this._originPoint._inputLabelContainer.innerHTML = 'Arrive';
        } else {
            this._originPoint._inputLabelContainer.innerHTML = 'Dpart';
        }
        this._currentDirection = value;
    };
    Isocurve.prototype.onIsoExclusionsChange = function (e) {
        var value = e.target.value;
        var checked = e.target.checked;
        if (!value) {
            return;
        }
        var bFound = false;
        var iFound = null;
        for (var i = 0; i < this._currentExclusions.length; i++) {
            if (this._currentExclusions[i] === value) {
                iFound = i;
                bFound = true;
            }
        }
        if (!bFound && !checked) {
            this._currentExclusions.push(value);
        }
        if (bFound && checked) {
            this._currentExclusions[iFound] = null;
        }
    };
    Isocurve.prototype.onIsoResetClick = function () {
        this._clear();
    };
    Isocurve.prototype._requestIsoCurve = function (options) {
        if (!options || typeof options === 'object' && Object.keys(options).length === 0) {
            return;
        }
        if (!options.position) {
            return;
        }
        if (this._noRightManagement || !this._resources['Isocurve']) {
            console.log('no rights for this service');
            return;
        }
        var resources = this._resources['Isocurve'].resources;
        if (!resources || typeof resources === 'object' && Object.keys(resources).length === 0) {
            console.log('no rights for this service');
            return;
        }
        var bFound = false;
        for (var i = 0; i < resources.length; i++) {
            if (resources[i] === options.graph) {
                bFound = true;
            }
        }
        if (!bFound) {
            console.log('no rights for this service !?');
            return;
        }
        var key = this._resources['Isocurve']['key'];
        options.apiKey = this.options.isocurveOptions.apiKey || this.options.apiKey || key;
        this._clearGeojsonLayer();
        this._displayWaitingContainer();
        Gp.Services.isoCurve(options);
    };
    Isocurve.prototype._drawIsoResults = function (results) {
        this._currentIsoResults = results;
        this._hideWaitingContainer();
        if (!results.geometry) {
            return;
        }
        var map = this.getMap();
        var geojsonObject = {
            type: 'Feature',
            crs: {
                type: 'name',
                properties: { name: 'EPSG:4326' }
            },
            geometry: results.geometry
        };
        var geojsonformat = new ol.format.GeoJSON({ defaultDataProjection: 'EPSG:4326' });
        var mapProj = map.getView().getProjection().getCode();
        var features = geojsonformat.readFeatures(geojsonObject, {
            dataProjection: 'EPSG:4326',
            featureProjection: mapProj
        });
        this._geojsonLayer = new ol.layer.Vector({
            source: new ol.source.Vector({ features: features }),
            style: this._defaultFeatureStyle,
            opacity: 0.9
        });
        var graph;
        if (this._currentTransport === 'Pieton') {
            graph = 'piton';
            this._geojsonLayer.gpResultLayerId = 'Pieton$GEOPORTAIL:GPP:Isocurve';
        } else {
            graph = 'voiture';
            this._geojsonLayer.gpResultLayerId = 'Voiture$GEOPORTAIL:GPP:Isocurve';
        }
        map.addLayer(this._geojsonLayer);
        if (features[0] && features[0].getGeometry() && features[0].getGeometry().getExtent()) {
            var extent = features[0].getGeometry().getExtent();
            map.getView().fit(extent, map.getSize());
        }
        var method = this._currentComputation === 'time' ? 'Isochrone' : 'Isodistance';
        map.getControls().forEach(function (control) {
            if (control instanceof LayerSwitcher) {
                var layerId = this._geojsonLayer.gpLayerId;
                if (control._layers[layerId].title === layerId) {
                    control.addLayer(this._geojsonLayer, {
                        title: method + ' ' + graph,
                        description: method + ' bas sur un graphe ' + graph
                    });
                }
            }
        }, this);
    };
    Isocurve.prototype._clear = function () {
        this._clearIsoInputs();
        this._originPoint.clear();
        this._clearGeojsonLayer();
        this._currentIsoResults = null;
    };
    Isocurve.prototype._clearIsoInputs = function () {
        var timeHourInput = document.getElementById('GPisochronValueChronInput1-' + this._uid);
        if (timeHourInput) {
            timeHourInput.value = '0';
        }
        var timeMinutesInput = document.getElementById('GPisochronValueChronInput2-' + this._uid);
        if (timeMinutesInput) {
            timeMinutesInput.value = '0';
        }
        var distInput = document.getElementById('GPisochronValueDistInput-' + this._uid);
        if (distInput) {
            distInput.value = '0';
        }
        this._initTransport();
        this._initComputation();
        this._initDirection();
        this._initExclusions();
        var transportdiv;
        if (this._currentTransport === 'Pieton') {
            transportdiv = document.getElementById('GPisochronTransportPedestrian-' + this._uid);
            if (transportdiv) {
                transportdiv.checked = 'true';
            }
        } else {
            transportdiv = document.getElementById('GPisochronTransportCar-' + this._uid);
            if (transportdiv) {
                transportdiv.checked = 'true';
            }
        }
        var computationdiv;
        if (this._currentComputation.toLowerCase() === 'distance') {
            computationdiv = document.getElementById('GPisochronChoiceAltDist-' + this._uid);
            if (computationdiv) {
                computationdiv.checked = 'true';
            }
            if (document.getElementById('GPisochronValueDist-' + this._uid)) {
                document.getElementById('GPisochronValueDist-' + this._uid).className = 'GPflexInput';
            }
            if (document.getElementById('GPisochronValueChron-' + this._uid)) {
                document.getElementById('GPisochronValueChron-' + this._uid).className = 'GPisochronValueHidden';
            }
        } else {
            computationdiv = document.getElementById('GPisochronChoiceAltChron-' + this._uid);
            if (computationdiv) {
                computationdiv.checked = 'true';
            }
            if (document.getElementById('GPisochronValueChron-' + this._uid)) {
                document.getElementById('GPisochronValueChron-' + this._uid).className = 'GPflexInput';
            }
            if (document.getElementById('GPisochronValueDist-' + this._uid)) {
                document.getElementById('GPisochronValueDist-' + this._uid).className = 'GPisochronValueHidden';
            }
        }
        var directionSelect = document.getElementById('GPisochronDirectionSelect-' + this._uid);
        if (directionSelect) {
            directionSelect.value = this._currentDirection;
        }
        if (this._currentDirection === 'arrival') {
            this._originPoint._inputLabelContainer.innerHTML = 'Arrive';
        } else {
            this._originPoint._inputLabelContainer.innerHTML = 'Dpart';
        }
        var tollInput = document.getElementById('GPisoExclusionsToll-' + this._uid);
        if (tollInput) {
            if (this._currentExclusions.indexOf('toll') !== -1) {
                tollInput.checked = false;
            } else {
                tollInput.checked = true;
            }
        }
        var tunnelInput = document.getElementById('GPisoExclusionsTunnel-' + this._uid);
        if (tunnelInput) {
            if (this._currentExclusions.indexOf('tunnel') !== -1) {
                tunnelInput.checked = false;
            } else {
                tunnelInput.checked = true;
            }
        }
        var bridgeInput = document.getElementById('GPisoExclusionsBridge-' + this._uid);
        if (bridgeInput) {
            if (this._currentExclusions.indexOf('bridge') !== -1 && bridgeInput) {
                bridgeInput.checked = false;
            } else {
                bridgeInput.checked = true;
            }
        }
    };
    Isocurve.prototype._clearGeojsonLayer = function () {
        var map = this.getMap();
        if (this._geojsonLayer) {
            map.removeLayer(this._geojsonLayer);
            this._geojsonLayer = null;
        }
    };
    Isocurve.prototype._hideIsoSuggestedLocations = function (e) {
        if (e.target && e.target.id && e.target.id.indexOf('GPlocationOrigin_') !== -1) {
            return;
        } else {
            this._originPoint._hideSuggestedLocation();
        }
    };
    Isocurve.prototype._displayWaitingContainer = function () {
        this._waitingContainer.className = 'GPisochronCalcWaitingContainerVisible';
        this._waiting = true;
        var opts = this.options.isocurveOptions;
        if (opts && opts.timeOut) {
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }
            var context = this;
            this._timer = setTimeout(function () {
                if (context._waiting === true) {
                    context._hideWaitingContainer();
                } else {
                    if (context._timer) {
                        clearTimeout(context._timer);
                    }
                }
            }, 16000);
        }
    };
    Isocurve.prototype._hideWaitingContainer = function () {
        if (this._waiting) {
            this._waitingContainer.className = 'GPisochronCalcWaitingContainerHidden';
            this._waiting = false;
            var opts = this.options.isocurveOptions;
            if (opts && opts.timeOut) {
                clearTimeout(this._timer);
                this._timer = null;
            }
        }
    };
    return Isocurve;
}(ol, gp, Ol3Utils, {}, CommonUtilsCheckRightManagement, CommonUtilsSelectorID, Ol3ControlsLocationSelector, Ol3ControlsLayerSwitcher, Ol3ControlsUtilsMarkers, CommonControlsIsoDOM);
CommonControlsReverseGeocodingDOM = function () {
    var ReverseGeocodingDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPreverseGeocoding');
            container.className = 'GPwidget';
            return container;
        },
        _createShowReverseGeocodingElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowReverseGeocoding');
            input.type = 'checkbox';
            return input;
        },
        _createShowReverseGeocodingPictoElement: function () {
            var self = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowReverseGeocodingPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowReverseGeocoding');
            label.title = 'Ouvrir la recherche inverse';
            if (label.addEventListener) {
                label.addEventListener('click', function () {
                    self.onShowReverseGeocodingClick();
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function () {
                    self.onShowReverseGeocodingClick();
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowReverseGeocodingOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createReverseGeocodingWaitingElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPreverseGeocodingCalcWaitingContainer');
            div.className = 'GPreverseGeocodingCalcWaitingContainerHidden';
            var p = document.createElement('p');
            p.className = 'GPreverseGeocodingCalcWaiting';
            p.innerHTML = 'Recherche en cours...';
            div.appendChild(p);
            return div;
        },
        _createReverseGeocodingResultsPanelElement: function () {
            var resultsPanelDiv = document.createElement('div');
            resultsPanelDiv.id = this._addUID('GPreverseGeocodingResultsPanel');
            resultsPanelDiv.className = 'GPpanel GPreverseGeocodingComponentHidden';
            return resultsPanelDiv;
        },
        _createReverseGeocodingResultsListElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPreverseGeocodingResultsList');
            return container;
        },
        _createReverseGeocodingResultElement: function (locationDescription, id) {
            var context = this;
            var container = document.getElementById(this._addUID('GPreverseGeocodingResultsList'));
            var div = document.createElement('div');
            div.id = this._addUID('ReverseGeocodedLocation_' + id);
            div.className = 'GPautoCompleteProposal';
            div.innerHTML = locationDescription;
            div.title = locationDescription;
            if (div.addEventListener) {
                div.addEventListener('mouseover', function (e) {
                    context.onReverseGeocodingResultMouseOver(e);
                });
                div.addEventListener('mouseout', function (e) {
                    context.onReverseGeocodingResultMouseOut(e);
                });
                div.addEventListener('click', function (e) {
                    if (typeof context.onReverseGeocodingResultClick === 'function') {
                        context.onReverseGeocodingResultClick(e);
                    }
                });
            } else if (div.attachEvent) {
                div.attachEvent('onmouseover', function (e) {
                    context.onReverseGeocodingResultMouseOver(e);
                });
                div.attachEvent('onmouseout', function (e) {
                    context.onReverseGeocodingResultMouseOut(e);
                });
                div.attachEvent('onclick', function (e) {
                    if (typeof context.onReverseGeocodingResultClick === 'function') {
                        context.onReverseGeocodingResultClick(e);
                    }
                });
            }
            container.appendChild(div);
        },
        _createReverseGeocodingPanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPreverseGeocodingPanel');
            div.className = 'GPpanel';
            return div;
        },
        _createReverseGeocodingPanelHeaderElement: function () {
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            return container;
        },
        _createReverseGeocodingPanelReturnPictoElement: function () {
            var self = this;
            var divNew = document.createElement('div');
            divNew.id = this._addUID('GPreverseGeocodingReturnPicto');
            divNew.title = 'Nouvelle recherche';
            divNew.className = 'GPreverseGeocodingReturnPictoHidden';
            if (divNew.addEventListener) {
                divNew.addEventListener('click', function (e) {
                    document.getElementById(self._addUID('GPreverseGeocodingResultsPanel')).className = 'GProuteComponentHidden';
                    document.getElementById(self._addUID('GPreverseGeocodingForm')).className = '';
                    document.getElementById(self._addUID('GPreverseGeocodingHeaderTitle')).innerHTML = 'Recherche inverse';
                    document.getElementById(self._addUID('GPreverseGeocodingReturnPicto')).className = 'GPreverseGeocodingReturnPictoHidden';
                    self.onGPreverseGeocodingReturnPictoClick(e);
                });
            } else if (divNew.attachEvent) {
                divNew.attachEvent('onclick', function (e) {
                    document.getElementById(self._addUID('GPreverseGeocodingResultsPanel')).className = 'GProuteComponentHidden';
                    document.getElementById(self._addUID('GPreverseGeocodingForm')).className = '';
                    document.getElementById(self._addUID('GPreverseGeocodingHeaderTitle')).innerHTML = 'Recherche inverse';
                    document.getElementById(self._addUID('GPreverseGeocodingReturnPicto')).className = 'GPreverseGeocodingReturnPictoHidden';
                    self.onGPreverseGeocodingReturnPictoClick(e);
                });
            }
            return divNew;
        },
        _createReverseGeocodingPanelTitleElement: function () {
            var div = document.createElement('div');
            div.className = 'GPpanelTitle';
            div.id = this._addUID('GPreverseGeocodingHeaderTitle');
            div.innerHTML = 'Recherche inverse';
            return div;
        },
        _createReverseGeocodingPanelCloseElement: function () {
            var self = this;
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GPreverseGeocodingPanelClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer le panneau';
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPshowReverseGeocodingPicto')).click();
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPshowReverseGeocodingPicto')).click();
                });
            }
            return divClose;
        },
        _createReverseGeocodingPanelFormElement: function () {
            var self = this;
            var form = document.createElement('form');
            form.id = this._addUID('GPreverseGeocodingForm');
            if (form.addEventListener) {
                form.addEventListener('submit', function (e) {
                    e.preventDefault();
                    self.onReverseGeocodingSubmit();
                });
            } else if (form.attachEvent) {
                form.attachEvent('onsubmit', function (e) {
                    e.preventDefault();
                    self.onReverseGeocodingSubmit();
                });
            }
            return form;
        },
        _createReverseGeocodingFormModeChoiceGeocodingTypeElement: function (resources) {
            var context = this;
            var div = document.createElement('div');
            div.className = 'GPflexInput';
            var label = document.createElement('label');
            label.className = 'GPreverseGeocodingCodeLabel';
            label.innerHTML = 'Recherche par';
            label.title = 'Recherche par';
            div.appendChild(label);
            var select = document.createElement('select');
            select.className = 'GPreverseGeocodingCode';
            if (select.addEventListener) {
                select.addEventListener('change', function (e) {
                    context.onReverseGeocodingTypeChange(e);
                });
            } else if (select.attachEvent) {
                select.attachEvent('onchange', function (e) {
                    context.onReverseGeocodingTypeChange(e);
                });
            }
            if (!resources || !Array.isArray(resources)) {
                resources = [
                    'StreetAddress',
                    'PositionOfInterest',
                    'CadastralParcel'
                ];
            }
            for (var i = 0; i < resources.length; i++) {
                switch (resources[i]) {
                case 'PositionOfInterest':
                    var POIOption = document.createElement('option');
                    POIOption.value = 'PositionOfInterest';
                    POIOption.text = 'Lieux/toponymes';
                    select.appendChild(POIOption);
                    break;
                case 'StreetAddress':
                    var SAOption = document.createElement('option');
                    SAOption.value = 'StreetAddress';
                    SAOption.text = 'Adresses';
                    select.appendChild(SAOption);
                    break;
                case 'CadastralParcel':
                    var CPOption = document.createElement('option');
                    CPOption.value = 'CadastralParcel';
                    CPOption.text = 'Parcelles cadastrales';
                    select.appendChild(CPOption);
                    break;
                case 'Administratif':
                    var adminOption = document.createElement('option');
                    adminOption.value = 'Administratif';
                    adminOption.text = 'Units administratives';
                    select.appendChild(adminOption);
                    break;
                default:
                    break;
                }
            }
            div.appendChild(select);
            return div;
        },
        _createReverseGeocodingFormModeChoiceGeocodingDelimitationElement: function (delimitations) {
            var context = this;
            var div = document.createElement('div');
            div.className = 'GPflexInput';
            var label = document.createElement('label');
            label.className = 'GPreverseGeocodingCodeLabel';
            label.innerHTML = 'Dlimitation';
            label.title = 'Dlimitation';
            div.appendChild(label);
            var select = document.createElement('select');
            select.className = 'GPreverseGeocodingCode';
            if (select.addEventListener) {
                select.addEventListener('change', function (e) {
                    context.onReverseGeocodingDelimitationChange(e);
                });
            } else if (select.attachEvent) {
                select.attachEvent('onchange', function (e) {
                    context.onReverseGeocodingDelimitationChange(e);
                });
            }
            if (!delimitations || !Array.isArray(delimitations)) {
                delimitations = [
                    'Point',
                    'Circle',
                    'Extent'
                ];
            }
            for (var i = 0; i < delimitations.length; i++) {
                switch (delimitations[i].toLowerCase()) {
                case 'point':
                    var pointOption = document.createElement('option');
                    pointOption.value = 'point';
                    pointOption.text = 'Pointer un lieu';
                    select.appendChild(pointOption);
                    break;
                case 'circle':
                    var circleOption = document.createElement('option');
                    circleOption.value = 'circle';
                    circleOption.text = 'Dessiner un cercle';
                    select.appendChild(circleOption);
                    break;
                case 'extent':
                    var extentOption = document.createElement('option');
                    extentOption.value = 'extent';
                    extentOption.text = 'Dessiner une emprise';
                    select.appendChild(extentOption);
                    break;
                default:
                    break;
                }
            }
            div.appendChild(select);
            return div;
        },
        _createReverseGeocodingSubmitFormElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPreverseGeocodingSubmit');
            input.className = 'GPinputSubmit';
            input.type = 'submit';
            input.value = 'Rechercher';
            return input;
        }
    };
    return ReverseGeocodingDOM;
}();
Ol3ControlsReverseGeocode = function (woodman, ol, Gp, Utils, Markers, LayerSwitcher, RightManagement, SelectorID, ReverseGeocodingDOM) {
    function ReverseGeocode(options) {
        options = options || {};
        if (!(this instanceof ReverseGeocode)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.initialize(options);
        this._container = this._initContainer();
        this._containerElement = null;
        if (options.element && options.element.appendChild) {
            options.element.appendChild(this._container);
            this._containerElement = options.element;
        }
        ol.control.Control.call(this, {
            element: this._containerElement || this._container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(ReverseGeocode, ol.control.Control);
    ReverseGeocode.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(ReverseGeocode.prototype, ReverseGeocodingDOM);
    ReverseGeocode.prototype.constructor = ReverseGeocode;
    ReverseGeocode.prototype.getCollapsed = function () {
        return this.collapsed;
    };
    ReverseGeocode.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] ReverseGeocode:setCollapsed - missing collapsed parameter');
            return;
        }
        if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
            return;
        }
        if (collapsed) {
            document.getElementById('GPreverseGeocodingPanelClose-' + this._uid).click();
        } else {
            document.getElementById('GPshowReverseGeocoding-' + this._uid).click();
        }
        this.collapsed = collapsed;
    };
    ReverseGeocode.prototype.setMap = function (map) {
        if (map) {
            this._activateMapInteraction(map);
        } else {
            var _map = this.getMap();
            this._clearResults();
            this._clearInputFeatures();
            this._removeMapInteraction(_map);
            if (this._inputFeaturesLayer != null) {
                _map.removeLayer(this._inputFeaturesLayer);
                this._inputFeaturesLayer = null;
                this._inputFeaturesSources = null;
                this._inputFeatures = null;
            }
        }
        ol.control.Control.prototype.setMap.call(this, map);
    };
    ReverseGeocode.prototype.initialize = function (options) {
        this._checkInputOptions(options);
        this.options = {
            collapsed: true,
            resources: [
                'StreetAddress',
                'PositionOfInterest',
                'CadastralParcel'
            ],
            delimitations: [
                'Point',
                'Circle',
                'Extent'
            ],
            reverseGeocodeOptions: {}
        };
        Utils.assign(this.options, options);
        this.collapsed = this.options.collapsed;
        this._uid = SelectorID.generate();
        this._servicesRightManagement = {};
        this._noRightManagement = false;
        this._checkRightsManagement();
        this._currentGeocodingType = null;
        this._initGeocodingType();
        this._currentGeocodingDelimitation = null;
        this._initGeocodingDelimitation();
        this._showReverseGeocodingInput = null;
        this._panelHeaderContainer = null;
        this._panelTitleContainer = null;
        this._returnPictoContainer = null;
        this._formContainer = null;
        this._resultsContainer = null;
        this._resultsListContainer = null;
        this._waitingContainer = null;
        this._inputFeatures = null;
        this._inputFeaturesSource = null;
        this._inputFeaturesLayer = null;
        this._mapInteraction = null;
        this._requestOptions = null;
        this._requestPosition = null;
        this._requestCircleFilter = null;
        this._requestBboxFilter = null;
        this._waiting = false;
        this._timer = null;
        this._reverseGeocodingLocations = [];
        this._reverseGeocodingLocationsMarkers = [];
        this._resultsDefaultStyle = new ol.style.Style({
            image: new ol.style.Icon({
                src: Markers['lightOrange'],
                anchor: [
                    0.5,
                    1
                ]
            })
        });
        this._resultsSelectedStyle = new ol.style.Style({
            image: new ol.style.Icon({
                src: Markers['red'],
                anchor: [
                    0.5,
                    1
                ]
            })
        });
        this._resultsHoverInteraction = null;
        this._resultsSelectInteraction = null;
        this._popupContent = null;
        this._popupDiv = this._initPopupDiv();
        this._popupOverlay = null;
    };
    ReverseGeocode.prototype._checkInputOptions = function (options) {
        var i;
        var j;
        if (options.resources) {
            var resources = options.resources;
            if (!Array.isArray(resources)) {
                console.log('[ReverseGeocode] \'options.resources\' parameter should be an array');
                resources = null;
            }
            var resourcesList = [
                'StreetAddress',
                'PositionOfInterest',
                'CadastralParcel',
                'Administratif'
            ];
            var wrongResourcesIndexes = [];
            for (i = 0; i < resources.length; i++) {
                if (resourcesList.indexOf(resources[i]) === -1) {
                    wrongResourcesIndexes.push(i);
                    console.log('[ReverseGeocode] options.resources : ' + resources[i] + ' is not a resource for reverse geocode');
                }
            }
            if (wrongResourcesIndexes.length !== 0) {
                for (j = 0; j < wrongResourcesIndexes.length; j++) {
                    resources.splice(wrongResourcesIndexes[j], 1);
                }
            }
        }
        if (options.delimitations) {
            var delimitations = options.delimitations;
            if (!Array.isArray(delimitations)) {
                console.log('[ReverseGeocode] \'options.delimitations\' parameter should be an array');
                delimitations = null;
            }
            var delimitationsList = [
                'Circle',
                'Point',
                'Extent'
            ];
            var wrongDelimitationsIndexes = [];
            for (i = 0; i < delimitations.length; i++) {
                if (delimitationsList.indexOf(delimitations[i]) === -1) {
                    wrongDelimitationsIndexes.push(i);
                    console.log('[ReverseGeocode] options.delimitations : ' + delimitations[i] + ' is not a delimitation for reverse geocode');
                }
            }
            if (wrongDelimitationsIndexes.length !== 0) {
                for (j = 0; j < wrongDelimitationsIndexes.length; j++) {
                    delimitations.splice(wrongDelimitationsIndexes[j], 1);
                }
            }
        }
    };
    ReverseGeocode.prototype._initGeocodingType = function () {
        this._currentGeocodingType = 'StreetAddress';
        var resources = this.options.resources;
        if (!resources || resources.length === 0) {
            this.options.resources = [
                'StreetAddress',
                'PositionOfInterest',
                'CadastralParcel'
            ];
        }
        if (Array.isArray(resources) && resources.length) {
            var noRightsIndexes = [];
            for (var i = 0; i < resources.length; i++) {
                if (this._servicesRightManagement['Geocode'].indexOf(resources[i]) < 0) {
                    noRightsIndexes.push(i);
                    console.log('[ReverseGeocode] no rights for options.resources : ' + resources[i]);
                }
            }
            if (noRightsIndexes.length !== 0) {
                for (var j = 0; j < noRightsIndexes.length; j++) {
                    resources.splice(noRightsIndexes[j], 1);
                }
            }
            if (resources[0] === 'StreetAddress' || resources[0] === 'PositionOfInterest' || resources[0] === 'CadastralParcel' || resources[0] === 'Administratif') {
                this._currentGeocodingType = resources[0];
            }
        }
        var serviceOptions = this.options.reverseGeocodeOptions;
        if (serviceOptions.filterOptions && Array.isArray(serviceOptions.filterOptions.type) && serviceOptions.filterOptions.type.length !== 0) {
            this._currentGeocodingType = serviceOptions.filterOptions.type[0];
        }
    };
    ReverseGeocode.prototype._initGeocodingDelimitation = function () {
        this._currentGeocodingDelimitation = 'Point';
        var delimitations = this.options.delimitations;
        if (!delimitations || delimitations.length === 0) {
            this.options.delimitations = [
                'Point',
                'Circle',
                'Extent'
            ];
        }
        if (Array.isArray(delimitations) && delimitations.length) {
            var d = delimitations[0].toLowerCase();
            if (d === 'point' || d === 'circle' || d === 'extent') {
                this._currentGeocodingDelimitation = delimitations[0];
            }
        }
    };
    ReverseGeocode.prototype._initPopupDiv = function () {
        var context = this;
        var element = document.createElement('div');
        element.className = 'gp-feature-info-div';
        var closer = document.createElement('input');
        closer.type = 'button';
        closer.className = 'gp-styling-button closer';
        closer.onclick = function () {
            if (context._popupOverlay != null) {
                context._popupOverlay.setPosition(undefined);
            }
            return false;
        };
        this._popupContent = document.createElement('div');
        this._popupContent.className = 'gp-features-content-div';
        element.appendChild(this._popupContent);
        element.appendChild(closer);
        return element;
    };
    ReverseGeocode.prototype._checkRightsManagement = function () {
        var _resources = [];
        var _key;
        var _opts = null;
        _key = this.options.reverseGeocodeOptions.apiKey;
        _opts = this.options.reverseGeocodeOptions.filterOptions;
        _resources = _opts ? _opts.type : [];
        if (!_resources || _resources.length === 0) {
            _resources = this.options.resources;
        }
        if (!_resources || _resources.length === 0) {
            _resources = [
                'StreetAddress',
                'PositionOfInterest'
            ];
        }
        var rightManagementGeocode = RightManagement.check({
            key: _key || this.options.apiKey,
            resources: _resources,
            services: ['Geocode']
        });
        if (!rightManagementGeocode) {
            this._noRightManagement = true;
            return;
        }
        if (!this.options.apiKey) {
            this.options.apiKey = rightManagementGeocode.key;
        }
        if (rightManagementGeocode) {
            this._servicesRightManagement['Geocode'] = rightManagementGeocode['Geocode'];
        }
    };
    ReverseGeocode.prototype._initContainer = function () {
        var container = this._createMainContainerElement();
        var inputShow = this._showReverseGeocodingInput = this._createShowReverseGeocodingElement();
        container.appendChild(inputShow);
        if (!this.collapsed) {
            inputShow.checked = true;
        }
        var picto = this._createShowReverseGeocodingPictoElement();
        container.appendChild(picto);
        var reverseGeocodingPanel = this._createReverseGeocodingPanelElement();
        var panelHeader = this._panelHeaderContainer = this._createReverseGeocodingPanelHeaderElement();
        var returnPicto = this._returnPictoContainer = this._createReverseGeocodingPanelReturnPictoElement();
        panelHeader.appendChild(returnPicto);
        var panelTitle = this._panelTitleContainer = this._createReverseGeocodingPanelTitleElement();
        panelHeader.appendChild(panelTitle);
        var closeDiv = this._createReverseGeocodingPanelCloseElement();
        panelHeader.appendChild(closeDiv);
        reverseGeocodingPanel.appendChild(panelHeader);
        var reverseGeocodingForm = this._formContainer = this._createReverseGeocodingPanelFormElement();
        reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingTypeElement(this.options.resources));
        reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingDelimitationElement(this.options.delimitations));
        var submit = this._createReverseGeocodingSubmitFormElement();
        reverseGeocodingForm.appendChild(submit);
        reverseGeocodingPanel.appendChild(reverseGeocodingForm);
        var waiting = this._waitingContainer = this._createReverseGeocodingWaitingElement();
        reverseGeocodingPanel.appendChild(waiting);
        var resultsPanel = this._resultsContainer = this._createReverseGeocodingResultsPanelElement();
        var reverseGeocodingResultsList = this._resultsListContainer = this._createReverseGeocodingResultsListElement();
        resultsPanel.appendChild(reverseGeocodingResultsList);
        reverseGeocodingPanel.appendChild(resultsPanel);
        container.appendChild(reverseGeocodingPanel);
        return container;
    };
    ReverseGeocode.prototype._activateMapInteraction = function (map) {
        if (!this.collapsed) {
            if (this._inputFeaturesLayer == null) {
                this._inputFeatures = new ol.Collection();
                this._inputFeaturesSource = new ol.source.Vector({ features: this._inputFeatures });
                this._inputFeaturesLayer = new ol.layer.Vector({
                    source: this._inputFeaturesSource,
                    style: new ol.style.Style({
                        fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.3)' }),
                        stroke: new ol.style.Stroke({
                            color: 'rgba(0, 183, 152, 0.8)',
                            width: 3
                        }),
                        image: new ol.style.Icon({
                            src: Markers['turquoiseBlue'],
                            anchor: [
                                0.5,
                                1
                            ]
                        })
                    })
                });
                this._inputFeaturesLayer.gpResultLayerId = 'reverseGeocoding';
                map.addLayer(this._inputFeaturesLayer);
            }
            var delimitation = this._currentGeocodingDelimitation.toLowerCase();
            switch (delimitation) {
            case 'point':
                this._activatePointInteraction(map);
                break;
            case 'circle':
                this._activateCircleInteraction(map);
                break;
            case 'extent':
                this._activateBoxInteraction(map);
                break;
            default:
                break;
            }
            map.getControls().forEach(function (control) {
                if (control instanceof LayerSwitcher) {
                    var layerId = this._inputFeaturesLayer.gpLayerId;
                    if (control._layers[layerId].title === layerId) {
                        control.addLayer(this._inputFeaturesLayer, {
                            title: 'Saisie (recherche inverse)',
                            description: 'Couche de saisie d\'une zone de recherche pour la recherche inverse'
                        });
                        control.setRemovable(this._inputFeaturesLayer, false);
                    }
                }
            }, this);
        }
    };
    ReverseGeocode.prototype._activatePointInteraction = function (map) {
        this._mapInteraction = new ol.interaction.Draw({
            style: new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 0,
                    fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.8)' })
                })
            }),
            type: 'Point',
            source: this._inputFeaturesSource
        });
        this._mapInteraction.on('drawstart', function (e) {
            this._inputFeatures.clear();
            this._onDrawStart(e, 'point');
        }, this);
        map.addInteraction(this._mapInteraction);
        this._setCursor('crosshair', map);
    };
    ReverseGeocode.prototype._activateCircleInteraction = function (map) {
        this._mapInteraction = new ol.interaction.Draw({
            style: new ol.style.Style({
                fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.3)' }),
                stroke: new ol.style.Stroke({
                    color: 'rgba(0, 183, 152, 0.8)',
                    width: 3
                }),
                image: new ol.style.Circle({
                    radius: 4,
                    fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.8)' })
                })
            }),
            type: 'Circle',
            source: this._inputFeaturesSource
        });
        this._mapInteraction.on('drawstart', function (e) {
            this._inputFeatures.clear();
            this._onDrawStart(e, 'circle');
        }, this);
        this._mapInteraction.on('drawend', function (e) {
            if (e.feature && e.feature.getGeometry) {
                var radius = e.feature.getGeometry().getRadius();
                this._requestCircleFilter = {};
                this._requestCircleFilter.radius = radius;
                if (this._requestPosition) {
                    this._requestCircleFilter.x = this._requestPosition.x;
                    this._requestCircleFilter.y = this._requestPosition.y;
                }
            }
        }, this);
        map.addInteraction(this._mapInteraction);
    };
    ReverseGeocode.prototype._activateBoxInteraction = function (map) {
        var geometryFunction = function (coordinates, geometry) {
            if (!geometry) {
                geometry = new ol.geom.Polygon(null);
            }
            var start = coordinates[0];
            var end = coordinates[1];
            geometry.setCoordinates([[
                    start,
                    [
                        start[0],
                        end[1]
                    ],
                    end,
                    [
                        end[0],
                        start[1]
                    ],
                    start
                ]]);
            return geometry;
        };
        this._mapInteraction = new ol.interaction.Draw({
            style: new ol.style.Style({
                fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.3)' }),
                stroke: new ol.style.Stroke({
                    color: 'rgba(0, 183, 152, 0.8)',
                    width: 3
                }),
                image: new ol.style.Circle({
                    radius: 4,
                    fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.8)' })
                })
            }),
            type: 'LineString',
            source: this._inputFeaturesSource,
            maxPoints: 2,
            geometryFunction: geometryFunction
        });
        this._mapInteraction.on('drawstart', function (e) {
            this._inputFeatures.clear();
        }, this);
        this._mapInteraction.on('drawend', function (e) {
            this._onBoxDrawEnd(e);
        }, this);
        map.addInteraction(this._mapInteraction);
    };
    ReverseGeocode.prototype._removeMapInteraction = function (map) {
        if (this._mapInteraction != null) {
            map.removeInteraction(this._mapInteraction);
            this._mapInteraction = null;
        }
        this._setCursor();
    };
    ReverseGeocode.prototype._onDrawStart = function (e, type) {
        var coordinate;
        if (e.feature && e.feature.getGeometry) {
            var geometry = e.feature.getGeometry();
            if (type === 'point') {
                coordinate = geometry.getCoordinates();
            }
            if (type === 'circle') {
                coordinate = geometry.getCenter();
            }
        }
        if (!coordinate) {
            return;
        }
        var crs;
        if (this.options.reverseGeocodeOptions && this.options.reverseGeocodeOptions.srs) {
            crs = this.options.reverseGeocodeOptions.srs;
        } else {
            var map = this.getMap();
            if (!map || !map.getView()) {
                return;
            }
            crs = map.getView().getProjection();
        }
        var geoCoordinate = ol.proj.transform(coordinate, crs, 'EPSG:4326');
        this._requestPosition = {
            x: geoCoordinate[0],
            y: geoCoordinate[1]
        };
    };
    ReverseGeocode.prototype._onBoxDrawEnd = function (e) {
        if (e.feature && e.feature.getGeometry) {
            var coordinates = e.feature.getGeometry().getCoordinates()[0];
            var start = coordinates[0];
            var end = coordinates[2];
            var crs;
            if (this.options.reverseGeocodeOptions && this.options.reverseGeocodeOptions.srs) {
                crs = this.options.reverseGeocodeOptions.srs;
            } else {
                var map = this.getMap();
                if (!map || !map.getView()) {
                    return;
                }
                crs = map.getView().getProjection();
            }
            var startGeoCoordinate = ol.proj.transform(start, crs, 'EPSG:4326');
            var endGeoCoordinate = ol.proj.transform(end, crs, 'EPSG:4326');
            this._requestPosition = {};
            this._requestBboxFilter = {};
            if (startGeoCoordinate[0] < endGeoCoordinate[0]) {
                this._requestBboxFilter.left = startGeoCoordinate[0];
                this._requestBboxFilter.right = endGeoCoordinate[0];
            } else {
                this._requestBboxFilter.left = endGeoCoordinate[0];
                this._requestBboxFilter.right = startGeoCoordinate[0];
            }
            if (startGeoCoordinate[1] < endGeoCoordinate[1]) {
                this._requestBboxFilter.bottom = startGeoCoordinate[1];
                this._requestBboxFilter.top = endGeoCoordinate[1];
            } else {
                this._requestBboxFilter.bottom = endGeoCoordinate[1];
                this._requestBboxFilter.top = startGeoCoordinate[1];
            }
            this._requestPosition.x = (startGeoCoordinate[0] + endGeoCoordinate[0]) / 2;
            this._requestPosition.y = (startGeoCoordinate[1] + endGeoCoordinate[1]) / 2;
        }
    };
    ReverseGeocode.prototype._setCursor = function (cursor, map) {
        map = map || this.getMap();
        if (!map) {
            return;
        }
        var div = map.getTargetElement();
        if (cursor) {
            div.style.cursor = cursor;
        } else {
            div.style.cursor = null;
        }
    };
    ReverseGeocode.prototype._reverseGeocodingRequest = function () {
        var map = this.getMap();
        this._requestOptions = this._getReverseGeocodingRequestOptions();
        this._removeMapInteraction(map);
        this._displayWaitingContainer();
        Gp.Services.reverseGeocode(this._requestOptions);
    };
    ReverseGeocode.prototype._getReverseGeocodingRequestOptions = function () {
        var map = this.getMap();
        var reverseGeocodeOptions = this.options.reverseGeocodeOptions;
        var context = this;
        var requestOptions = {
            apiKey: reverseGeocodeOptions.apiKey || this.options.apiKey,
            position: this._requestPosition,
            filterOptions: { type: [this._currentGeocodingType] },
            srs: 'CRS:84',
            returnFreeForm: false,
            maximumResponses: reverseGeocodeOptions.maximumResponses || 25,
            timeOut: reverseGeocodeOptions.timeOut || 30000,
            protocol: reverseGeocodeOptions.protocol || 'XHR',
            onSuccess: function (response) {
                if (response.locations) {
                    context._displayGeocodedLocations(response.locations);
                }
            },
            onFailure: function (error) {
                context._hideWaitingContainer();
                context._clearResults();
                context._clearInputFeatures();
                context._activateMapInteraction(map);
            }
        };
        if (this._currentGeocodingDelimitation.toLowerCase() === 'circle' && this._requestCircleFilter) {
            if (this._requestCircleFilter.radius > 1000) {
                console.log('INFO : initial circle radius (' + this._requestCircleFilter.radius + ') limited to 1000m.');
                this._requestCircleFilter.radius = 1000;
            }
            requestOptions.filterOptions.circle = this._requestCircleFilter;
        }
        if (this._currentGeocodingDelimitation.toLowerCase() === 'extent' && this._requestBboxFilter) {
            requestOptions.filterOptions.bbox = this._requestBboxFilter;
        }
        return requestOptions;
    };
    ReverseGeocode.prototype._displayGeocodedLocations = function (locations) {
        this._clearResults();
        this._reverseGeocodingLocations = locations;
        this._formContainer.className = 'GPreverseGeocodingComponentHidden';
        this._hideWaitingContainer();
        this._panelTitleContainer.innerHTML = 'Rsultats de la recherche';
        this._returnPictoContainer.className = '';
        this._resultsContainer.className = 'GPpanel';
        this._fillGeocodedLocationListContainer(locations);
        this._displayGeocodedLocationsOnMap(locations);
    };
    ReverseGeocode.prototype._fillGeocodedLocationListContainer = function (locations) {
        for (var i = 0; i < locations.length; i++) {
            var location = locations[i];
            var locationDescription = this._fillGeocodedLocationDescription(location);
            if (locationDescription.length !== 0) {
                this._createReverseGeocodingResultElement(locationDescription, i);
            }
        }
    };
    ReverseGeocode.prototype._fillGeocodedLocationDescription = function (location) {
        if (!location || !location.placeAttributes) {
            return;
        }
        var attr = location.placeAttributes;
        var locationDescription = '';
        switch (location.type) {
        case 'StreetAddress':
            if (attr.street) {
                locationDescription += attr.number ? attr.number + ' ' : '';
                locationDescription += attr.street + ', ';
            }
            locationDescription += attr.postalCode + ' ' + attr.commune;
            break;
        case 'PositionOfInterest':
            if (location.matchType === 'City' && attr.commune) {
                locationDescription += attr.commune;
                locationDescription += attr.postalCode ? ', ' + attr.postalCode : '';
            } else if (location.matchType === 'Dpartement' && attr.municipality) {
                locationDescription += attr.municipality;
                locationDescription += attr.postalCode ? ', ' + attr.postalCode : '';
            } else if (location.matchType === 'Toponym' && attr.municipality) {
                locationDescription += attr.municipality;
                locationDescription += attr.postalCode ? ', ' + attr.postalCode : '';
                locationDescription += attr.commune ? ' ' + attr.commune : '';
            } else {
                locationDescription += attr.municipality ? attr.municipality : '';
            }
            locationDescription += attr.nature ? ' (' + attr.nature + ') ' : '';
            break;
        case 'CadastralParcel':
            locationDescription += attr.cadastralParcel ? attr.cadastralParcel : '';
            locationDescription += attr.municipality ? ' (' + attr.municipality + ')' : '';
            break;
        case 'Administratif':
            locationDescription += attr.municipality ? attr.municipality : '';
            if (attr.inseeDepartment) {
                locationDescription += '(Dpartement)';
            } else if (attr.inseeRegion) {
                locationDescription += '(Rgion)';
            }
            break;
        default:
            locationDescription += attr.municipality ? attr.municipality : '';
            break;
        }
        return locationDescription;
    };
    ReverseGeocode.prototype._displayGeocodedLocationsOnMap = function (locations) {
        if (this._reverseGeocodingLocations.length !== 0) {
            var map = this.getMap();
            this._createResultsLayer();
            for (var i = 0; i < locations.length; i++) {
                this._addResultFeature(locations[i], i);
            }
            if (this._resultsFeatures.getLength() > 1) {
                if (this._resultsFeaturesSource && this._resultsFeaturesSource.getExtent) {
                    var extent = this._resultsFeaturesSource.getExtent();
                    map.getView().fit(extent, map.getSize());
                }
            } else {
                var feature = this._resultsFeatures.item(0);
                var coords = feature.getGeometry().getCoordinates();
                map.getView().setCenter(coords);
                map.getView().setZoom(17);
            }
            this._resultsHoverInteraction = new ol.interaction.Select({
                condition: ol.events.condition.pointerMove,
                layers: [this._resultsFeaturesLayer]
            });
            this._resultsHoverInteraction.on('select', this._onResultsFeatureMouseOver, this);
            map.addInteraction(this._resultsHoverInteraction);
            this._resultsSelectInteraction = new ol.interaction.Select({ layers: [this._resultsFeaturesLayer] });
            this._resultsSelectInteraction.on('select', this._onResultsFeatureSelect, this);
            map.addInteraction(this._resultsSelectInteraction);
            var geocodeType = '';
            switch (this._currentGeocodingType) {
            case 'StreetAddress':
                geocodeType = 'adresses';
                break;
            case 'PositionOfInterest':
                geocodeType = 'toponymes';
                break;
            case 'CadastralParcel':
                geocodeType = 'parcelles cadastrales';
                break;
            case 'Administratif':
                geocodeType = 'units administratives';
                break;
            default:
                break;
            }
            map.getControls().forEach(function (control) {
                if (control instanceof LayerSwitcher) {
                    var layerId = this._resultsFeaturesLayer.gpLayerId;
                    if (control._layers[layerId].title === layerId) {
                        control.addLayer(this._resultsFeaturesLayer, {
                            title: 'Rsultats de la recherche inverse',
                            description: 'Rsultats de la recherche inverse sur les ' + geocodeType
                        });
                        control.setRemovable(this._resultsFeaturesLayer, false);
                    }
                }
            }, this);
        }
    };
    ReverseGeocode.prototype._createResultsLayer = function () {
        var map = this.getMap();
        this._resultsFeatures = new ol.Collection();
        this._resultsFeaturesSource = new ol.source.Vector({ features: this._resultsFeatures });
        this._resultsFeaturesLayer = new ol.layer.Vector({ source: this._resultsFeaturesSource });
        this._resultsFeaturesLayer.gpResultLayerId = 'reverseGeocodingResults';
        map.addLayer(this._resultsFeaturesLayer);
    };
    ReverseGeocode.prototype._addResultFeature = function (location, i) {
        var map = this.getMap();
        var position = [
            location.position.x,
            location.position.y
        ];
        if (!position) {
            return;
        }
        var view = map.getView();
        var mapProj = view.getProjection().getCode();
        if (mapProj !== 'EPSG:4326') {
            position = ol.proj.transform(position, 'EPSG:4326', mapProj);
        }
        var feature = new ol.Feature({ geometry: new ol.geom.Point(position) });
        feature.setStyle(this._resultsDefaultStyle);
        feature.setId(i);
        feature.setProperties({ popupContent: this._fillPopupContent(location) });
        this._resultsFeatures.push(feature);
    };
    ReverseGeocode.prototype._fillPopupContent = function (location) {
        var popupContent = '<ul>';
        var attributes = location.placeAttributes;
        for (var attr in attributes) {
            if (attributes.hasOwnProperty(attr)) {
                if (attr !== 'bbox') {
                    popupContent += '<li>';
                    popupContent += '<span class="gp-attname-others-span">' + attr.toUpperCase() + ' : </span>';
                    popupContent += attributes[attr];
                    popupContent += ' </li>';
                }
            }
        }
        popupContent += ' </ul>';
        return popupContent;
    };
    ReverseGeocode.prototype._onResultsFeatureMouseOver = function (e) {
        var f;
        if (e.selected.length !== 0) {
            f = e.selected[0];
            f.setStyle(this._resultsSelectedStyle);
            if (f.getId() != null) {
                var selectedResultDiv = document.getElementById('ReverseGeocodedLocation_' + f.getId() + '-' + this._uid);
                if (selectedResultDiv && selectedResultDiv.classList) {
                    selectedResultDiv.classList.add('GPreverseGeocodedLocationHighlight');
                }
            }
            document.getElementById('ReverseGeocodedLocation_' + f.getId() + '-' + this._uid);
        }
        if (e.deselected.length !== 0) {
            f = e.deselected[0];
            f.setStyle(this._resultsDefaultStyle);
            var deSelectedResultDiv = document.getElementById('ReverseGeocodedLocation_' + f.getId() + '-' + this._uid);
            if (deSelectedResultDiv && deSelectedResultDiv.classList) {
                deSelectedResultDiv.classList.remove('GPreverseGeocodedLocationHighlight');
            }
        }
    };
    ReverseGeocode.prototype._onResultsFeatureSelect = function (e) {
        var map = this.getMap();
        if (e.selected.length !== 0) {
            var f = e.selected[0];
            this._popupContent.innerHTML = f.getProperties().popupContent;
            if (!this._popupOverlay) {
                this._popupOverlay = new ol.Overlay({
                    element: this._popupDiv,
                    positioning: 'bottom-center',
                    position: e.mapBrowserEvent.coordinate
                });
                map.addOverlay(this._popupOverlay);
            } else {
                this._popupOverlay.setPosition(e.mapBrowserEvent.coordinate);
            }
        } else {
            if (this._popupOverlay != null) {
                this._popupOverlay.setPosition(undefined);
            }
        }
    };
    ReverseGeocode.prototype.onShowReverseGeocodingClick = function () {
        this.collapsed = this._showReverseGeocodingInput.checked;
        this.dispatchEvent('change:collapsed');
        var map = this.getMap();
        if (!this._waiting && !this._reverseGeocodingLocations.length) {
            if (this.collapsed) {
                this._clearResults();
                this._clearInputFeatures();
                this._removeMapInteraction(map);
                if (this._inputFeaturesLayer != null) {
                    map.removeLayer(this._inputFeaturesLayer);
                    this._inputFeaturesLayer = null;
                    this._inputFeaturesSources = null;
                    this._inputFeatures = null;
                }
            } else {
                this._activateMapInteraction(map);
            }
        }
    };
    ReverseGeocode.prototype.onReverseGeocodingTypeChange = function (e) {
        var idx = e.target.selectedIndex;
        var value = e.target.options[idx].value;
        if (!value) {
            return;
        }
        this._currentGeocodingType = value;
    };
    ReverseGeocode.prototype.onReverseGeocodingDelimitationChange = function (e) {
        var idx = e.target.selectedIndex;
        var value = e.target.options[idx].value;
        if (!value) {
            return;
        }
        this._currentGeocodingDelimitation = value;
        var map = this.getMap();
        this._clearInputFeatures();
        this._removeMapInteraction(map);
        this._activateMapInteraction(map);
    };
    ReverseGeocode.prototype.onGPreverseGeocodingReturnPictoClick = function () {
        this._clearResults();
        this._clearInputFeatures();
        this._activateMapInteraction(this.getMap());
    };
    ReverseGeocode.prototype.onReverseGeocodingSubmit = function () {
        if (!this._requestPosition) {
            return;
        }
        if (this._noRightManagement) {
            return;
        }
        this._reverseGeocodingRequest();
    };
    ReverseGeocode.prototype.onReverseGeocodingResultClick = function (e) {
    };
    ReverseGeocode.prototype.onReverseGeocodingResultMouseOver = function (e) {
        var tagid = e.target.id;
        var idx = tagid.substring(tagid.indexOf('_') + 1);
        if (e.target.classList) {
            e.target.classList.add('GPreverseGeocodedLocationHighlight');
        }
        if (!this._resultsFeaturesSource) {
            return;
        }
        var f = this._resultsFeaturesSource.getFeatureById(parseInt(idx, 10));
        f.setStyle(this._resultsSelectedStyle);
    };
    ReverseGeocode.prototype.onReverseGeocodingResultMouseOut = function (e) {
        var tagid = e.target.id;
        var idx = tagid.substring(tagid.indexOf('_') + 1);
        if (e.target.classList) {
            e.target.classList.remove('GPreverseGeocodedLocationHighlight');
        }
        if (!this._resultsFeaturesSource) {
            return;
        }
        var f = this._resultsFeaturesSource.getFeatureById(parseInt(idx, 10));
        f.setStyle(this._resultsDefaultStyle);
    };
    ReverseGeocode.prototype._clearResults = function () {
        var map = this.getMap();
        this._reverseGeocodingLocations = [];
        if (this._resultsListContainer) {
            while (this._resultsListContainer.firstChild) {
                this._resultsListContainer.removeChild(this._resultsListContainer.firstChild);
            }
        }
        if (this._resultsFeaturesLayer) {
            map.removeLayer(this._resultsFeaturesLayer);
            this._resultsFeaturesLayer = null;
        }
        if (this._popupOverlay != null) {
            map.removeOverlay(this._popupOverlay);
            this._popupOverlay = null;
        }
        if (this._resultsSelectInteraction != null) {
            map.removeInteraction(this._resultsSelectInteraction);
            this._resultsSelectInteraction = null;
        }
        if (this._resultsHoverInteraction != null) {
            map.removeInteraction(this._resultsHoverInteraction);
            this._resultsHoverInteraction = null;
        }
    };
    ReverseGeocode.prototype._clearInputFeatures = function () {
        if (this._inputFeatures) {
            this._inputFeatures.clear();
        }
        this._requestPosition = null;
        this._requestCircleFilter = null;
        this._requestBboxFilter = null;
    };
    ReverseGeocode.prototype._displayWaitingContainer = function () {
        this._waitingContainer.className = 'GProuteCalcWaitingContainerVisible';
        this._waiting = true;
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = null;
        }
        var context = this;
        this._timer = setTimeout(function () {
            if (context._waiting === true) {
                context._hideWaitingContainer();
            } else {
                if (context._timer) {
                    clearTimeout(context._timer);
                }
            }
        }, 16000);
    };
    ReverseGeocode.prototype._hideWaitingContainer = function () {
        if (this._waiting) {
            this._waitingContainer.className = 'GProuteCalcWaitingContainerHidden';
            this._waiting = false;
            clearTimeout(this._timer);
            this._timer = null;
        }
    };
    return ReverseGeocode;
}({}, ol, gp, Ol3Utils, Ol3ControlsUtilsMarkers, Ol3ControlsLayerSwitcher, CommonUtilsCheckRightManagement, CommonUtilsSelectorID, CommonControlsReverseGeocodingDOM);
CommonControlsLayerImportDOM = function () {
    var LayerImportDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPimport');
            container.className = 'GPwidget';
            return container;
        },
        _createShowImportElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowImport');
            input.type = 'checkbox';
            return input;
        },
        _createShowImportPictoElement: function () {
            var self = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowImportPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowImport');
            label.title = 'Ouvrir l\'import de couches';
            if (label.addEventListener) {
                label.addEventListener('click', function () {
                    self._onShowImportClick();
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function () {
                    self._onShowImportClick();
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowImportOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createImportPanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportPanel');
            div.className = 'GPpanel';
            return div;
        },
        _createImportPanelHeaderElement: function () {
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var panelTitle = this._createImportPanelTitleElement();
            container.appendChild(panelTitle);
            var closeDiv = this._createImportPanelCloseElement();
            container.appendChild(closeDiv);
            return container;
        },
        _createImportPanelTitleElement: function () {
            var div = document.createElement('div');
            div.className = 'GPpanelTitle';
            div.innerHTML = 'Import de donnes';
            return div;
        },
        _createImportPanelCloseElement: function () {
            var self = this;
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GPimportPanelClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer le panneau';
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPshowImportPicto')).click();
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPshowImportPicto')).click();
                });
            }
            return divClose;
        },
        _createImportPanelFormElement: function () {
            var self = this;
            var form = document.createElement('form');
            form.id = this._addUID('GPimportForm');
            form.className = 'map-tool-box';
            if (form.addEventListener) {
                form.addEventListener('submit', function (e) {
                    e.preventDefault();
                    self._onImportSubmit();
                });
            } else if (form.attachEvent) {
                form.attachEvent('onsubmit', function (e) {
                    e.preventDefault();
                    self._onImportSubmit();
                });
            }
            return form;
        },
        _createImportTypeLineElement: function (importTypes) {
            var context = this;
            var div = document.createElement('div');
            div.id = this._addUID('GPimportTypeLine');
            div.className = 'GPimportInputLine';
            var label = document.createElement('label');
            label.htmlFor = this._addUID('GPimportType');
            label.className = 'GPimportLabel';
            label.innerHTML = 'Type de donne';
            label.title = 'Type de donne';
            div.appendChild(label);
            var select = document.createElement('select');
            select.className = 'GPimportSelect';
            if (select.addEventListener) {
                select.addEventListener('change', function (e) {
                    if (this.value === 'KML' || this.value === 'GPX' || this.value === 'GeoJSON') {
                        document.getElementById(context._addUID('GPimportStaticParams')).className = 'GPimportVisibleParams';
                        document.getElementById(context._addUID('GPimportServiceParams')).className = 'GPimportHiddenParams';
                    } else if (this.value === 'WMS' || this.value === 'WMTS' || this.value === 'WFS') {
                        document.getElementById(context._addUID('GPimportServiceParams')).className = 'GPimportVisibleParams';
                        document.getElementById(context._addUID('GPimportStaticParams')).className = 'GPimportHiddenParams';
                    }
                    context._onImportTypeChange(e);
                });
            } else if (select.attachEvent) {
                select.attachEvent('onchange', function () {
                    if (this.value === 'KML' || this.value === 'GPX' || this.value === 'GeoJSON') {
                        document.getElementById(context._addUID('GPimportStaticParams')).className = 'GPimportVisibleParams';
                        document.getElementById(context._addUID('GPimportServiceParams')).className = 'GPimportHiddenParams';
                    } else if (this.value === 'WMS' || this.value === 'WMTS' || this.value === 'WFS') {
                        document.getElementById(context._addUID('GPimportServiceParams')).className = 'GPimportVisibleParams';
                        document.getElementById(context._addUID('GPimportStaticParams')).className = 'GPimportHiddenParams';
                    }
                    context._onImportTypeChange();
                });
            }
            select.id = this._addUID('GPimportType');
            if (!importTypes || !Array.isArray(importTypes)) {
                importTypes = [
                    'KML',
                    'GPX',
                    'GeoJSON',
                    'WMS',
                    'WMTS',
                    'WFS'
                ];
            }
            var option;
            for (var i = 0; i < importTypes.length; i++) {
                option = document.createElement('option');
                option.value = importTypes[i];
                option.text = importTypes[i];
                select.appendChild(option);
            }
            div.appendChild(select);
            return div;
        },
        _createImportWaitingElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportWaitingContainer');
            div.className = 'GPimportWaitingContainerHidden';
            var p = document.createElement('p');
            p.className = 'GPimportWaiting';
            p.innerHTML = 'Recherche en cours...';
            div.appendChild(p);
            return div;
        },
        _createImportStaticParamsContainer: function (currentType) {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportStaticParams');
            if (currentType === 'KML' || currentType === 'GPX' || currentType === 'GeoJSON') {
                div.className = 'GPimportVisibleParams';
            } else {
                div.className = 'GPimportHiddenParams';
            }
            return div;
        },
        _createStaticNameLabel: function () {
            var div = document.createElement('div');
            div.className = 'GPimportInputLine';
            var label = document.createElement('label');
            label.className = 'GPimportLabel';
            label.htmlFor = this._addUID('GPimportName');
            label.innerHTML = 'Nom';
            label.title = 'Nom';
            div.appendChild(label);
            var input = document.createElement('input');
            input.type = 'text';
            input.id = this._addUID('GPimportName');
            input.className = 'GPimportInput';
            div.appendChild(input);
            return div;
        },
        _createStaticModeChoiceDiv: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportChoice');
            return div;
        },
        _createStaticLocalChoiceDiv: function () {
            var context = this;
            var div = document.createElement('div');
            div.className = 'GPimportChoiceAlt';
            var input = document.createElement('input');
            input.type = 'radio';
            if (input.addEventListener) {
                input.addEventListener('change', function (e) {
                    document.getElementById(context._addUID('GPimportValueLocal')).className = 'GPimportInputLine';
                    document.getElementById(context._addUID('GPimportValueUrl')).className = 'GPimportValueHidden';
                    context._onStaticImportTypeChange(e);
                });
            } else if (input.appendChild) {
                input.appendChild('onchange', function () {
                    document.getElementById(context._addUID('GPimportValueLocal')).className = 'GPimportInputLine';
                    document.getElementById(context._addUID('GPimportValueUrl')).className = 'GPimportValueHidden';
                    context._onStaticImportTypeChange();
                });
            }
            input.name = 'GPimportChoiceMode';
            input.value = 'local';
            input.checked = true;
            input.id = this._addUID('GPimportChoiceAltLocal');
            div.appendChild(input);
            var label = document.createElement('label');
            label.className = 'GPimportChoiceAltTxt';
            label.htmlFor = this._addUID('GPimportChoiceAltLocal');
            label.innerHTML = 'par fichier local';
            label.title = 'par fichier local';
            div.appendChild(label);
            return div;
        },
        _createStaticUrlChoiceDiv: function () {
            var context = this;
            var div = document.createElement('div');
            div.className = 'GPimportChoiceAlt';
            var input = document.createElement('input');
            input.type = 'radio';
            if (input.addEventListener) {
                input.addEventListener('change', function (e) {
                    document.getElementById(context._addUID('GPimportValueUrl')).className = 'GPimportInputLine';
                    document.getElementById(context._addUID('GPimportValueLocal')).className = 'GPimportValueHidden';
                    context._onStaticImportTypeChange(e);
                });
            } else if (input.appendChild) {
                input.appendChild('onchange', function () {
                    document.getElementById(context._addUID('GPimportValueUrl')).className = 'GPimportInputLine';
                    document.getElementById(context._addUID('GPimportValueLocal')).className = 'GPimportValueHidden';
                    context._onStaticImportTypeChange();
                });
            }
            input.id = this._addUID('GPimportChoiceAltUrl');
            input.name = 'GPimportChoiceMode';
            input.value = 'url';
            input.checked = false;
            div.appendChild(input);
            var label = document.createElement('label');
            label.className = 'GPimportChoiceAltTxt';
            label.htmlFor = this._addUID('GPimportChoiceAltUrl');
            label.innerHTML = 'par URL';
            label.title = 'par URL';
            div.appendChild(label);
            return div;
        },
        _createStaticLocalInputDiv: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportValueLocal');
            div.className = 'GPimportInputLine';
            return div;
        },
        _createStaticLocalInputLabel: function () {
            var label = document.createElement('label');
            label.className = 'GPimportLabel';
            label.htmlFor = this._addUID('GPimportFile');
            label.innerHTML = 'Fichier local';
            label.title = 'Fichier local';
            return label;
        },
        _createStaticLocalInput: function () {
            var input = document.createElement('input');
            input.type = 'file';
            input.id = this._addUID('GPimportFile');
            input.className = 'GPimportInputFile';
            return input;
        },
        _createStaticUrlInputDiv: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportValueUrl');
            div.className = 'GPimportValueHidden';
            return div;
        },
        _createStaticUrlInputLabel: function () {
            var label = document.createElement('label');
            label.className = 'GPimportLabel';
            label.htmlFor = this._addUID('GPimportUrl');
            label.innerHTML = 'URL';
            label.title = 'URL';
            return label;
        },
        _createStaticUrlInput: function () {
            var input = document.createElement('input');
            input.type = 'text';
            input.id = this._addUID('GPimportUrl');
            input.className = 'GPimportInput';
            return input;
        },
        _createServiceParamsContainer: function (currentType) {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportServiceParams');
            if (currentType === 'WMS' || currentType === 'WMTS' || currentType === 'WFS') {
                div.className = 'GPimportVisibleParams';
            } else {
                div.className = 'GPimportHiddenParams';
            }
            return div;
        },
        _createServiceUrlDiv: function () {
            var div = document.createElement('div');
            div.className = 'GPimportInputLine';
            return div;
        },
        _createServiceUrlInputLabel: function () {
            var label = document.createElement('label');
            label.className = 'GPimportLabel';
            label.htmlFor = this._addUID('GPimportServiceUrl');
            label.innerHTML = 'URL du service';
            label.title = 'URL du service';
            return label;
        },
        _createServiceUrlInput: function () {
            var input = document.createElement('input');
            input.type = 'text';
            input.id = this._addUID('GPimportServiceUrl');
            input.className = 'GPimportInput';
            return input;
        },
        _createImportSubmitFormElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPimportSubmit');
            input.className = 'GPinputSubmit tool-form-submit';
            input.type = 'submit';
            input.value = 'Importer';
            return input;
        },
        _createImportGetCapPanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPimportGetCapPanel');
            div.className = 'GPpanel';
            return div;
        },
        _createImportGetCapPanelHeaderElement: function () {
            var context = this;
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var panelTitle = document.createElement('div');
            panelTitle.className = 'GPpanelTitle';
            panelTitle.innerHTML = 'Couches accessibles';
            panelTitle.title = 'Couches accessibles';
            container.appendChild(panelTitle);
            var closeDiv = document.createElement('div');
            if (closeDiv.addEventListener) {
                closeDiv.addEventListener('click', function () {
                    document.getElementById(context._addUID('GPimportGetCapPanel')).style.display = 'none';
                    document.getElementById(context._addUID('GPimportPanel')).style.display = '';
                    context._onGetCapPanelClose();
                });
            } else if (closeDiv.attachEvent) {
                closeDiv.attachEvent('click', function () {
                    document.getElementById(context._addUID('GPimportGetCapPanel')).style.display = 'none';
                    document.getElementById(context._addUID('GPimportPanel')).style.display = '';
                    context._onGetCapPanelClose();
                });
            }
            closeDiv.className = 'GPpanelClose';
            closeDiv.title = 'Fermer le panneau';
            closeDiv.id = this._addUID('GPimportGetCapPanelClose');
            container.appendChild(closeDiv);
            return container;
        },
        _createImportGetCapResultsListElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPimportGetCapResults');
            return container;
        },
        _createImportGetCapResultElement: function (layerDescription, id) {
            var div = document.createElement('div');
            div.className = 'GPimportGetCapProposal';
            div.innerHTML = layerDescription;
            div.title = layerDescription;
            var context = this;
            if (div.addEventListener) {
                div.addEventListener('click', function (e) {
                    context._onGetCapResponseLayerClick(e);
                });
            } else if (div.attachEvent) {
                div.attachEvent('onclick', function () {
                    context._onGetCapResponseLayerClick();
                });
            }
            div.id = 'GPimportGetCapProposal_' + id;
            return div;
        }
    };
    return LayerImportDOM;
}();
Ol3ControlsLayerImport = function (ol, Gp, woodman, Utils, Markers, LayerImportDOM, SelectorID, ProxyUtils, KMLExtended) {
    function LayerImport(options) {
        options = options || {};
        if (!(this instanceof LayerImport)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this._initialize(options);
        var container = this._initContainer(options);
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(LayerImport, ol.control.Control);
    LayerImport.DefaultStyles = {
        image: new ol.style.Icon({
            src: Markers['lightOrange'],
            anchor: [
                25.5,
                38
            ],
            anchorOrigin: 'top-left',
            anchorXUnits: 'pixels',
            anchorYUnits: 'pixels'
        }),
        stroke: new ol.style.Stroke({
            color: 'rgba(0,42,80,0.8)',
            width: 4
        }),
        fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.5)' }),
        text: new ol.style.Text({
            font: '16px Sans',
            textAlign: 'left',
            fill: new ol.style.Fill({ color: 'rgba(255, 255, 255, 1)' }),
            stroke: new ol.style.Stroke({
                color: 'rgba(0, 0, 0, 1)',
                width: 2
            })
        })
    };
    LayerImport.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(LayerImport.prototype, LayerImportDOM);
    LayerImport.prototype.constructor = LayerImport;
    LayerImport.prototype.getCollapsed = function () {
        return this.collapsed;
    };
    LayerImport.prototype.setCollapsed = function (collapsed) {
        if (collapsed === undefined) {
            console.log('[ERROR] LayerImport:setCollapsed - missing collapsed parameter');
            return;
        }
        if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
            return;
        }
        if (collapsed) {
            document.getElementById('GPimportPanelClose-' + this._uid).click();
        } else {
            document.getElementById('GPshowImport-' + this._uid).click();
        }
        this.collapsed = collapsed;
    };
    LayerImport.prototype.getStaticImportContent = function () {
        return this.contentStatic;
    };
    LayerImport.prototype.getServiceImportContent = function () {
        return this.contentService;
    };
    LayerImport.prototype._initialize = function (options) {
        this._checkInputOptions(options);
        this.options = {
            collapsed: true,
            layerTypes: [
                'KML',
                'GPX',
                'GeoJSON',
                'WMS',
                'WMTS'
            ],
            webServicesOptions: {},
            vectorStyleOptions: {
                KML: {
                    extractStyles: true,
                    showPointNames: true,
                    defaultStyle: {}
                },
                GPX: { defaultStyle: {} },
                GeoJSON: { defaultStyle: {} }
            }
        };
        if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.extractStyles) {
            this.options.vectorStyleOptions.KML.extractStyles = options.vectorStyleOptions.KML.extractStyles;
        }
        if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.showPointNames) {
            this.options.vectorStyleOptions.KML.showPointNames = options.vectorStyleOptions.KML.showPointNames;
        }
        if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.defaultStyle) {
            this.options.vectorStyleOptions.KML.defaultStyle = options.vectorStyleOptions.KML.defaultStyle;
        } else {
            this.options.vectorStyleOptions.KML.defaultStyle = new ol.style.Style({
                image: LayerImport.DefaultStyles.image,
                stroke: LayerImport.DefaultStyles.stroke,
                fill: LayerImport.DefaultStyles.fill,
                text: LayerImport.DefaultStyles.text
            });
        }
        if (options.vectorStyleOptions && options.vectorStyleOptions.GPX && options.vectorStyleOptions.GPX.defaultStyle) {
            this.options.vectorStyleOptions.GPX.defaultStyle = options.vectorStyleOptions.GPX.defaultStyle;
        } else {
            this.options.vectorStyleOptions.GPX.defaultStyle = new ol.style.Style({
                image: LayerImport.DefaultStyles.image,
                stroke: LayerImport.DefaultStyles.stroke,
                fill: LayerImport.DefaultStyles.fill
            });
        }
        if (options.vectorStyleOptions && options.vectorStyleOptions.GeoJSON && options.vectorStyleOptions.GeoJSON.defaultStyle) {
            this.options.vectorStyleOptions.GeoJSON.defaultStyle = options.vectorStyleOptions.GeoJSON.defaultStyle;
        } else {
            this.options.vectorStyleOptions.GeoJSON.defaultStyle = new ol.style.Style({
                image: LayerImport.DefaultStyles.image,
                stroke: LayerImport.DefaultStyles.stroke,
                fill: LayerImport.DefaultStyles.fill
            });
        }
        if (Array.isArray(options.layerTypes)) {
            var layerTypes = [];
            for (var i = 0; i < options.layerTypes.length; i++) {
                layerTypes.push(options.layerTypes[i]);
            }
            this.options.layerTypes = layerTypes;
        }
        Utils.mergeParams(this.options, options);
        this.collapsed = this.options.collapsed;
        this._uid = SelectorID.generate();
        this._waiting = false;
        this._timer = null;
        this._initImportTypes();
        this._initDefaultStyles();
        this._showImportInput = null;
        this._importPanel = null;
        this._formContainer = null;
        this._staticLocalImportInput = null;
        this._staticUrlImportInput = null;
        this._serviceUrlImportInput = null;
        this._getCapPanel = null;
        this._getCapResultsListContainer = null;
        this._waitingContainer = null;
        this._getCapRequestUrl = null;
        this._getCapResponseWMS = null;
        this._getCapResponseWMSLayers = [];
        this._getCapResponseWMTS = null;
        this._getCapResponseWMTSLayers = [];
    };
    LayerImport.prototype._checkInputOptions = function (options) {
        if (options.layerTypes) {
            var layerTypes = options.layerTypes;
            if (!Array.isArray(layerTypes)) {
                console.log('[ol.control.LayerImport] \'options.layerTypes\' parameter should be an array. Set default values ["KML", "GPX", "GeoJSON", "WMS", "WMTS"]');
                options.layerTypes = [
                    'KML',
                    'GPX',
                    'GeoJSON',
                    'WMS',
                    'WMTS'
                ];
            } else {
                var typesList = [
                    'KML',
                    'GPX',
                    'GEOJSON',
                    'WMS',
                    'WMTS',
                    'WFS'
                ];
                var wrongTypesIndexes = [];
                for (var i = 0; i < layerTypes.length; i++) {
                    if (typeof layerTypes[i] !== 'string') {
                        wrongTypesIndexes.push(i);
                        console.log('[ol.control.LayerImport] \'options.layerTypes\' elements should be of type string (' + layerTypes[i] + ')');
                    } else {
                        layerTypes[i] = layerTypes[i].toUpperCase();
                        if (typesList.indexOf(layerTypes[i]) === -1) {
                            wrongTypesIndexes.push(i);
                            console.log('[ol.control.LayerImport] options.layerTypes : ' + layerTypes[i] + ' is not a supported type');
                        }
                        if (layerTypes[i] === 'GEOJSON') {
                            layerTypes[i] = 'GeoJSON';
                        }
                    }
                }
                if (wrongTypesIndexes.length !== 0) {
                    for (var j = wrongTypesIndexes.length - 1; j >= 0; j--) {
                        layerTypes.splice(wrongTypesIndexes[j], 1);
                    }
                }
            }
        }
    };
    LayerImport.prototype._initDefaultStyles = function () {
        var kmlDefaultStyles = this.options.vectorStyleOptions.KML.defaultStyle;
        this._defaultKMLStyle = new ol.style.Style({
            image: kmlDefaultStyles.image,
            stroke: kmlDefaultStyles.stroke,
            fill: kmlDefaultStyles.fill,
            text: kmlDefaultStyles.text
        });
        var gpxDefaultStyles = this.options.vectorStyleOptions.GPX.defaultStyle;
        this._defaultGPXStyle = new ol.style.Style({
            image: gpxDefaultStyles.image,
            stroke: gpxDefaultStyles.stroke,
            fill: gpxDefaultStyles.fill
        });
        var geoJSONDefaultStyles = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
        this._defaultGeoJSONStyle = new ol.style.Style({
            image: geoJSONDefaultStyles.image,
            stroke: geoJSONDefaultStyles.stroke,
            fill: geoJSONDefaultStyles.fill
        });
    };
    LayerImport.prototype._initImportTypes = function () {
        this._currentImportType = this.options.layerTypes[0] || 'KML';
        if (this._currentImportType === 'KML' || this._currentImportType === 'GPX' || this._currentImportType === 'GeoJSON') {
            this._isCurrentImportTypeStatic = true;
        } else if (this._currentImportType === 'WMS' || this._currentImportType === 'WMTS' || this._currentImportType === 'WFS') {
            this._isCurrentImportTypeStatic = false;
        }
        this._currentStaticImportType = 'local';
    };
    LayerImport.prototype._initContainer = function () {
        var container = this._createMainContainerElement();
        var inputShow = this._showImportInput = this._createShowImportElement();
        container.appendChild(inputShow);
        if (!this.collapsed) {
            inputShow.checked = true;
        }
        var picto = this._createShowImportPictoElement();
        container.appendChild(picto);
        var importPanel = this._importPanel = this._createImportPanelElement();
        var panelHeader = this._createImportPanelHeaderElement();
        importPanel.appendChild(panelHeader);
        var importForm = this._formContainer = this._initInputFormElement();
        importPanel.appendChild(importForm);
        container.appendChild(importPanel);
        var getCapPanel = this._getCapPanel = this._createImportGetCapPanelElement();
        getCapPanel.appendChild(this._createImportGetCapPanelHeaderElement());
        var importGetCapResultsList = this._getCapResultsListContainer = this._createImportGetCapResultsListElement();
        getCapPanel.appendChild(importGetCapResultsList);
        container.appendChild(getCapPanel);
        var waiting = this._waitingContainer = this._createImportWaitingElement();
        container.appendChild(waiting);
        return container;
    };
    LayerImport.prototype._initInputFormElement = function () {
        var importForm = this._createImportPanelFormElement();
        var importTypeChoiceDiv = this._createImportTypeLineElement(this.options.layerTypes);
        importForm.appendChild(importTypeChoiceDiv);
        var importStaticParamsContainer = this._createImportStaticParamsContainer(this.options.layerTypes[0]);
        var staticNameLabel = this._createStaticNameLabel();
        importStaticParamsContainer.appendChild(staticNameLabel);
        var staticImportChoice = this._createStaticModeChoiceDiv();
        var staticLocalImportChoice = this._createStaticLocalChoiceDiv();
        staticImportChoice.appendChild(staticLocalImportChoice);
        var staticUrlImportChoice = this._createStaticUrlChoiceDiv();
        staticImportChoice.appendChild(staticUrlImportChoice);
        importStaticParamsContainer.appendChild(staticImportChoice);
        var staticLocalInputDiv = this._createStaticLocalInputDiv();
        staticLocalInputDiv.appendChild(this._createStaticLocalInputLabel());
        this._staticLocalImportInput = this._createStaticLocalInput();
        staticLocalInputDiv.appendChild(this._staticLocalImportInput);
        importStaticParamsContainer.appendChild(staticLocalInputDiv);
        var staticUrlInputDiv = this._createStaticUrlInputDiv();
        staticUrlInputDiv.appendChild(this._createStaticUrlInputLabel());
        this._staticUrlImportInput = this._createStaticUrlInput();
        staticUrlInputDiv.appendChild(this._staticUrlImportInput);
        importStaticParamsContainer.appendChild(staticUrlInputDiv);
        importForm.appendChild(importStaticParamsContainer);
        var importServiceParamsContainer = this._createServiceParamsContainer(this.options.layerTypes[0]);
        var importServiceUrlDiv = this._createServiceUrlDiv();
        importServiceUrlDiv.appendChild(this._createServiceUrlInputLabel());
        this._serviceUrlImportInput = this._createServiceUrlInput();
        importServiceUrlDiv.appendChild(this._serviceUrlImportInput);
        importServiceParamsContainer.appendChild(importServiceUrlDiv);
        importForm.appendChild(importServiceParamsContainer);
        var submit = this._createImportSubmitFormElement();
        importForm.appendChild(submit);
        return importForm;
    };
    LayerImport.prototype._onShowImportClick = function () {
        this.collapsed = this._showImportInput.checked;
        this.dispatchEvent('change:collapsed');
    };
    LayerImport.prototype._onImportTypeChange = function (e) {
        this._currentImportType = e.target.value;
        if (this._currentImportType === 'KML' || this._currentImportType === 'GPX' || this._currentImportType === 'GeoJSON') {
            this._isCurrentImportTypeStatic = true;
        } else if (this._currentImportType === 'WMS' || this._currentImportType === 'WMTS' || this._currentImportType === 'WFS') {
            this._isCurrentImportTypeStatic = false;
        }
    };
    LayerImport.prototype._onStaticImportTypeChange = function (e) {
        this._currentStaticImportType = e.target.value;
    };
    LayerImport.prototype._onGetCapPanelClose = function () {
        this._clearGetCapParams();
        this._emptyGetCapResultsList();
    };
    LayerImport.prototype._onImportSubmit = function () {
        this.contentStatic = null;
        this.contentService = null;
        if (this._isCurrentImportTypeStatic) {
            this._importStaticLayer();
        } else {
            this._importServiceLayers();
        }
    };
    LayerImport.prototype._importStaticLayer = function () {
        var layerName;
        var staticImportNameInput = document.getElementById(this._addUID('GPimportName'));
        if (staticImportNameInput) {
            layerName = staticImportNameInput.value;
        }
        if (this._currentStaticImportType === 'local') {
            this._importStaticLayerFromLocalFile(layerName);
        } else if (this._currentStaticImportType === 'url') {
            this._importStaticLayerFromUrl(layerName);
        }
    };
    LayerImport.prototype._importStaticLayerFromUrl = function (layerName) {
        layerName = layerName || '';
        var url = this._staticUrlImportInput.value;
        if (url.length === 0) {
            console.log('[ol.control.LayerImport] url parameter is mandatory');
            return;
        }
        if (url.trim) {
            url = url.trim();
        }
        if (!this.options.webServicesOptions || !this.options.webServicesOptions.proxyUrl && !this.options.webServicesOptions.noProxyDomains) {
            console.log('[ol.control.LayerImport] options.webServicesOptions.proxyUrl parameter is mandatory to request resources on another domain (cross-domain)');
            return;
        }
        url = ProxyUtils.proxifyUrl(url, this.options.webServicesOptions);
        var context = this;
        Gp.Protocols.XHR.call({
            url: url,
            method: 'GET',
            timeOut: 15000,
            onResponse: function (response) {
                context._hideWaitingContainer();
                context._addFeaturesFromImportStaticLayer(response, layerName);
            },
            onFailure: function (error) {
                context._hideWaitingContainer();
                console.log('[ol.control.LayerImport] KML/GPX/GeoJSON request failed : ', error);
            }
        });
    };
    LayerImport.prototype._importStaticLayerFromLocalFile = function (layerName) {
        var file = this._staticLocalImportInput.files[0];
        if (!file) {
            console.log('[ol.control.LayerImport] missing file');
            return;
        }
        var fReader = new FileReader();
        var context = this;
        fReader.onerror = function (e) {
            context._hideWaitingContainer();
        };
        fReader.onprogress = function () {
        };
        fReader.onloadstart = function () {
            context._displayWaitingContainer();
        };
        fReader.onabort = function () {
            context._hideWaitingContainer();
        };
        fReader.onloadend = function (e) {
        };
        fReader.onload = function (e) {
            context._hideWaitingContainer();
            context._addFeaturesFromImportStaticLayer(e.target.result, layerName);
        };
        fReader.readAsText(file);
    };
    LayerImport.prototype._addFeaturesFromImportStaticLayer = function (fileContent, layerName) {
        var map = this.getMap();
        if (!map || !fileContent) {
            return;
        }
        this.contentStatic = fileContent;
        var format;
        var vectorStyle;
        if (this._currentImportType === 'KML') {
            format = new KMLExtended({
                showPointNames: this.options.vectorStyleOptions.KML.showPointNames,
                extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
                defaultStyle: [this.options.vectorStyleOptions.KML.defaultStyle]
            });
            vectorStyle = this.options.vectorStyleOptions.KML.defaultStyle;
        } else if (this._currentImportType === 'GPX') {
            format = new ol.format.GPX();
            vectorStyle = this.options.vectorStyleOptions.GPX.defaultStyle;
        } else if (this._currentImportType === 'GeoJSON') {
            format = new ol.format.GeoJSON();
            vectorStyle = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
        }
        var fileProj = format.readProjection(fileContent);
        var mapProj = this._getMapProjectionCode();
        var features = null;
        features = format.readFeatures(fileContent, {
            dataProjection: fileProj,
            featureProjection: mapProj
        });
        var vectorSource = new ol.source.Vector({ features: new ol.Collection() });
        vectorSource.addFeatures(features);
        if (layerName) {
            vectorSource._title = vectorSource._description = layerName;
        } else {
            if (format.readName && format.readName(fileContent)) {
                vectorSource._title = vectorSource._description = format.readName(fileContent);
            } else {
                vectorSource._title = vectorSource._description = 'Import ' + this._currentImportType;
            }
        }
        var vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: vectorStyle
        });
        vectorLayer.gpResultLayerId = 'layerimport:' + this._currentImportType;
        map.addLayer(vectorLayer);
        if (map.getView() && map.getSize() && vectorSource.getExtent) {
            var sourceExtent = vectorSource.getExtent();
            if (sourceExtent && sourceExtent[0] !== Infinity) {
                map.getView().fit(vectorSource.getExtent(), map.getSize());
            }
        }
    };
    LayerImport.prototype._addFeaturesFromImportStaticLayerUrl = function (url, layerName) {
        var map = this.getMap();
        if (!map || !url) {
            return;
        }
        var format;
        if (this._currentImportType === 'KML') {
            format = new KMLExtended({
                showPointNames: true,
                extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
                defaultStyle: [this.options.vectorStyleOptions.KML.defaultStyle]
            });
        } else if (this._currentImportType === 'GPX') {
            format = new ol.format.GPX();
        } else if (this._currentImportType === 'GeoJSON') {
            format = new ol.format.GeoJSON();
        }
        var vectorSource = new ol.source.Vector({
            url: url,
            format: format
        });
        if (this._currentImportType === 'GPX') {
            vectorSource.forEachFeature(function (feature) {
                if (feature.getStyle() == null) {
                    feature.setStyle(this.options.vectorStyleOptions.GPX.defaultStyle);
                }
            });
        }
        if (this._currentImportType === 'GeoJSON') {
            vectorSource.forEachFeature(function (feature) {
                if (feature.getStyle() == null) {
                    feature.setStyle(this.options.vectorStyleOptions.GeoJSON.defaultStyle);
                }
            });
        }
        if (layerName) {
            vectorSource._title = vectorSource._description = layerName;
        } else {
            vectorSource._title = vectorSource._description = 'Import ' + this._currentImportType;
        }
        var vectorLayer = new ol.layer.Vector({ source: vectorSource });
        vectorLayer.gpResultLayerId = 'layerimport:' + this._currentImportType;
        map.addLayer(vectorLayer);
        if (map.getView() && map.getSize() && vectorSource.getExtent) {
            var sourceExtent = vectorSource.getExtent();
            if (sourceExtent && sourceExtent[0] !== Infinity) {
                map.getView().fit(vectorSource.getExtent(), map.getSize());
            }
        }
    };
    LayerImport.prototype._importServiceLayers = function () {
        if (this._currentImportType === 'WFS') {
            console.log('[ol.control.LayerImport] WFS layer import is not implemented yet');
            return;
        }
        this._emptyGetCapResultsList();
        var url = this._getCapRequestUrl = this._serviceUrlImportInput.value;
        if (!url) {
            console.log('[ol.control.LayerImport] url parameter is mandatory');
            return;
        }
        if (url.trim) {
            url = url.trim();
        }
        var questionMarkIndex = url.indexOf('?');
        if (questionMarkIndex < 0) {
            url += '?SERVICE=' + this._currentImportType + '&REQUEST=GetCapabilities';
        } else if (questionMarkIndex === url.length - 1) {
            url += 'SERVICE=' + this._currentImportType + '&REQUEST=GetCapabilities';
        }
        if (!this.options.webServicesOptions || !this.options.webServicesOptions.proxyUrl && !this.options.webServicesOptions.noProxyDomains) {
            console.log('[ol.control.LayerImport] options.webServicesOptions.proxyUrl parameter is mandatory to request web service layers (getcapabilities request)');
            return;
        }
        var proxyUrl = this.options.webServicesOptions.proxyUrl;
        var noProxyDomains = this.options.webServicesOptions.noProxyDomains;
        var bfound = false;
        if (noProxyDomains && Array.isArray(noProxyDomains) && noProxyDomains.length > 0) {
            for (var i in noProxyDomains) {
                if (url.indexOf(noProxyDomains[i]) !== -1) {
                    bfound = true;
                }
            }
        }
        if (bfound === false) {
            url = proxyUrl + encodeURIComponent(url);
        }
        this._displayWaitingContainer();
        var context = this;
        Gp.Protocols.XHR.call({
            url: url,
            method: 'GET',
            timeOut: 15000,
            onResponse: function (response) {
                context._hideWaitingContainer();
                context._displayGetCapResponseLayers.call(context, response);
            },
            onFailure: function (error) {
                context._hideWaitingContainer();
                console.log('[ol.control.LayerImport] getCapabilities request failed : ', error);
            }
        });
    };
    LayerImport.prototype._displayGetCapResponseLayers = function (xmlResponse) {
        var parser;
        var layers;
        var layerDescription;
        var projection;
        this._getCapResponseWMSLayers = [];
        this.contentService = xmlResponse;
        this._importPanel.style.display = 'none';
        this._getCapPanel.style.display = 'block';
        if (this._currentImportType === 'WMS') {
            parser = new ol.format.WMSCapabilities();
            if (!parser) {
                return;
            }
            var getCapResponseWMS = this._getCapResponseWMS = parser.read(xmlResponse);
            if (getCapResponseWMS && getCapResponseWMS.Capability && getCapResponseWMS.Capability.Layer) {
                var getCapLayer = getCapResponseWMS.Capability.Layer;
                if (Array.isArray(getCapLayer)) {
                    for (var i = 0; i < getCapLayer.length; i++) {
                        this._displayGetCapResponseWMSLayer(getCapLayer[i]);
                    }
                } else {
                    this._displayGetCapResponseWMSLayer(getCapLayer);
                }
            }
        } else if (this._currentImportType === 'WMTS') {
            parser = new ol.format.WMTSCapabilities();
            if (!parser) {
                return;
            }
            var getCapResponseWMTS = this._getCapResponseWMTS = parser.read(xmlResponse);
            if (getCapResponseWMTS && getCapResponseWMTS.Contents && getCapResponseWMTS.Contents.Layer) {
                layers = getCapResponseWMTS.Contents.Layer;
                if (Array.isArray(layers)) {
                    this._getCapResponseWMTSLayers = layers;
                    for (var j = 0; j < layers.length; j++) {
                        projection = this._getWMTSLayerProjection(layers[j], getCapResponseWMTS);
                        if (projection && typeof projection === 'string') {
                            if (ol.proj.get(projection) || ol.proj.get(projection.toUpperCase())) {
                                layerDescription = layers[j].Title;
                                if (this._getCapResultsListContainer) {
                                    this._getCapResultsListContainer.appendChild(this._createImportGetCapResultElement(layerDescription, j));
                                }
                            } else {
                                console.log('[ol.control.LayerImport] wmts layer cannot be added to map : unknown projection', layers[j]);
                                continue;
                            }
                        }
                    }
                }
            }
        }
    };
    LayerImport.prototype._displayGetCapResponseWMSLayer = function (layerObj, parentLayersInfos) {
        if (!layerObj) {
            console.log('[ol.control.LayerImport] _displayGetCapResponseWMSLayer : getCapabilities layer object not found');
        } else {
        }
        var mapProjCode = this._getMapProjectionCode();
        var projection;
        var layerDescription;
        if (parentLayersInfos) {
            var key;
            var i;
            var addKeys = [
                'CRS',
                'Style'
            ];
            for (i = 0; i < addKeys.length; i++) {
                key = addKeys[i];
                if (Array.isArray(parentLayersInfos[key]) && parentLayersInfos[key].length !== 0) {
                    if (Array.isArray(layerObj[key]) && layerObj[key].length !== 0) {
                        for (var n = 0; n < parentLayersInfos[key]; n++) {
                            if (layerObj[key].indexOf(parentLayersInfos[key][n]) === -1) {
                                layerObj[key].push(parentLayersInfos[key][n]);
                            }
                        }
                    } else {
                        layerObj[key] = parentLayersInfos[key];
                    }
                }
            }
            var replaceKeys = [
                'BoundingBox',
                'EX_GeographicBoundingBox',
                'MaxScaleDenominator',
                'MinScaleDenominator',
                'Attribution',
                'Dimension',
                'queryable',
                'cascaded',
                'opaque',
                'noSubsets',
                'fixedWidth',
                'fixedHeight'
            ];
            for (i = 0; i < replaceKeys.length; i++) {
                key = replaceKeys[i];
                if (parentLayersInfos[key] && !layerObj[key]) {
                    layerObj[key] = parentLayersInfos[key];
                }
            }
            if (!parentLayersInfos._isRootLayer && parentLayersInfos.Title) {
                layerObj.Title = parentLayersInfos.Title + ' > ' + layerObj.Title;
            }
        } else {
            layerObj._isRootLayer = true;
        }
        if (layerObj.Layer) {
            if (Array.isArray(layerObj.Layer)) {
                for (var j = 0; j < layerObj.Layer.length; j++) {
                    this._displayGetCapResponseWMSLayer(layerObj.Layer[j], layerObj);
                }
            }
        } else {
            var lastIndex = this._getCapResponseWMSLayers.length;
            projection = this._getWMSLayerProjection(layerObj, mapProjCode);
            if (!projection) {
                console.log('[ol.control.LayerImport] wms layer cannot be added to map : unknown projection', layerObj);
            } else {
                layerObj._projection = projection;
                layerDescription = layerObj.Title;
                if (this._getCapResultsListContainer) {
                    this._getCapResultsListContainer.appendChild(this._createImportGetCapResultElement(layerDescription, lastIndex));
                }
                this._getCapResponseWMSLayers[lastIndex] = layerObj;
            }
        }
    };
    LayerImport.prototype._onGetCapResponseLayerClick = function (e) {
        if (e.target && e.target.id) {
            var proposalId = parseInt(e.target.id.substr(23), 10);
            if (proposalId == null) {
                return;
            }
            var layerInfo;
            if (this._currentImportType === 'WMS') {
                layerInfo = this._getCapResponseWMSLayers[proposalId];
                this._addGetCapWMSLayer(layerInfo);
            } else if (this._currentImportType === 'WMTS') {
                layerInfo = this._getCapResponseWMTSLayers[proposalId];
                this._addGetCapWMTSLayer(layerInfo);
            }
        }
    };
    LayerImport.prototype._addGetCapWMSLayer = function (layerInfo) {
        var map = this.getMap();
        if (!map) {
            console.log('[ol.control.LayerImport] _addGetCapWMSLayer error : map is not defined');
            return;
        }
        if (!layerInfo) {
            console.log('[ol.control.LayerImport] _addGetCapWMSLayer error : layerInfo is not defined');
            return;
        }
        var mapProjCode = this._getMapProjectionCode();
        var wmsSourceOptions = {};
        var getMapUrl = this._getWMSLayerGetMapUrl();
        if (getMapUrl) {
            wmsSourceOptions.url = getMapUrl;
        } else {
            var questionMarkIndex = this._getCapRequestUrl.indexOf('?');
            if (questionMarkIndex !== -1) {
                wmsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
            } else {
                wmsSourceOptions.url = this._getCapRequestUrl;
            }
        }
        wmsSourceOptions.params = {};
        if (layerInfo.Name) {
            wmsSourceOptions.params['LAYERS'] = layerInfo.Name;
        } else {
            console.log('[ol.control.LayerImport] unable to add wms layer : mandatory layer \'name\' parameter cannot be found', layerInfo);
            return;
        }
        wmsSourceOptions.params['SERVICE'] = 'WMS';
        if (this._getCapResponseWMS.version) {
            wmsSourceOptions.params['VERSION'] = this._getCapResponseWMS.version;
        }
        var projection = layerInfo._projection;
        if (!projection) {
            console.log('[ol.control.LayerImport] wms layer cannot be added to map : unknown projection');
            return;
        } else if (projection !== mapProjCode) {
            wmsSourceOptions.projection = projection;
        }
        var legend;
        if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
            var style = layerInfo.Style[0];
            wmsSourceOptions.params['STYLES'] = style.Name;
            if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
                legend = style.LegendURL[0].OnlineResource;
            }
        }
        var wmsSource = new ol.source.TileWMS(wmsSourceOptions);
        this._getWMSLayerInfoForLayerSwitcher(layerInfo, legend, wmsSource);
        var layerTileOptions = {};
        layerTileOptions['source'] = wmsSource;
        this._getWMSLayerMinMaxResolution(layerInfo, mapProjCode, layerTileOptions);
        this._getWMSLayerExtent(layerInfo, mapProjCode, layerTileOptions);
        var wmsLayer = new ol.layer.Tile(layerTileOptions);
        wmsLayer.gpResultLayerId = 'layerimport:WMS';
        if (layerInfo.queryable) {
            wmsLayer.gpGFIparams = { queryable: true };
            if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetFeatureInfo && this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format && Array.isArray(this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format)) {
                wmsLayer.gpGFIparams.formats = this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format;
            }
        }
        map.addLayer(wmsLayer);
    };
    LayerImport.prototype._getWMSLayerGetMapUrl = function () {
        var getmapurl;
        if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetMap) {
            var getmap = this._getCapResponseWMS.Capability.Request.GetMap;
            if (getmap.DCPType && Array.isArray(getmap.DCPType) && getmap.DCPType.length !== 0) {
                var url = getmap.DCPType[0];
                if (url && url.HTTP && url.HTTP.Get) {
                    getmapurl = url.HTTP.Get.OnlineResource;
                }
            }
        }
        return getmapurl;
    };
    LayerImport.prototype._getWMSLayerProjection = function (layerInfo, mapProjCode) {
        var projection;
        if (!layerInfo || typeof layerInfo !== 'object') {
            return;
        }
        var CRSList = layerInfo.CRS;
        if (Array.isArray(CRSList)) {
            for (var i = 0; i < CRSList.length; i++) {
                var layerCRS = CRSList[i];
                if (layerCRS === mapProjCode) {
                    projection = layerCRS;
                    break;
                } else {
                    if (layerCRS && typeof layerCRS === 'string') {
                        if (ol.proj.get(layerCRS) || ol.proj.get(layerCRS.toUpperCase())) {
                            projection = layerCRS;
                            break;
                        }
                    }
                }
            }
        }
        return projection;
    };
    LayerImport.prototype._getWMSLayerMinMaxResolution = function (layerInfo, mapProjCode, layerTileOptions) {
        var mapUnits = ol.proj.get(mapProjCode).getUnits();
        if (mapUnits === 'm') {
            if (layerInfo.MinScaleDenominator) {
                layerTileOptions.minResolution = layerInfo.MinScaleDenominator * 0.00028;
            }
            if (layerInfo.MaxScaleDenominator) {
                layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * 0.00028;
            }
        } else if (mapUnits === 'degrees') {
            var cste = 0.00028 * 180 / (Math.PI * 6378137);
            if (layerInfo.MinScaleDenominator) {
                layerTileOptions.minResolution = layerInfo.MinScaleDenominator * cste;
            }
            if (layerInfo.MaxScaleDenominator) {
                layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * cste;
            }
        }
    };
    LayerImport.prototype._getWMSLayerExtent = function (layerInfo, mapProjCode, layerTileOptions) {
        if (!layerInfo) {
            console.log('[ol.control.LayerImport] _getWMSLayerExtent error : layerInfo is not defined');
            return;
        }
        var exGeographicBoundingBox = layerInfo['EX_GeographicBoundingBox'];
        var boundingBox = layerInfo.BoundingBox;
        if (exGeographicBoundingBox && Array.isArray(exGeographicBoundingBox)) {
            if (mapProjCode === 'EPSG:4326') {
                layerTileOptions.extent = exGeographicBoundingBox;
            } else {
                layerTileOptions.extent = ol.proj.transformExtent(exGeographicBoundingBox, 'EPSG:4326', mapProjCode);
            }
        } else if (boundingBox && Array.isArray(boundingBox)) {
            var crs;
            var extent;
            for (var i = 0; i < boundingBox.length; i++) {
                crs = boundingBox[i].crs;
                extent = boundingBox[i].extent;
                if (crs) {
                    if (crs === mapProjCode) {
                        layerTileOptions.extent = extent;
                        break;
                    } else {
                        if (crs && typeof crs === 'string') {
                            var olProj = ol.proj.get(crs) ? ol.proj.get(crs) : ol.proj.get(crs.toUpperCase());
                            if (olProj) {
                                if (olProj.getUnits() === 'degrees' && crs.toUpperCase().indexOf('EPSG') === 0) {
                                    var reversedExtent = [
                                        extent[1],
                                        extent[0],
                                        extent[3],
                                        extent[2]
                                    ];
                                    layerTileOptions.extent = ol.proj.transformExtent(reversedExtent, olProj, mapProjCode);
                                } else {
                                    layerTileOptions.extent = ol.proj.transformExtent(extent, olProj, mapProjCode);
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
    };
    LayerImport.prototype._getWMSLayerInfoForLayerSwitcher = function (layerInfo, legend, wmsSource) {
        if (layerInfo.Title) {
            wmsSource._title = layerInfo.Title;
            wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
        } else {
            wmsSource._title = layerInfo.Name;
            wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Name;
        }
        if (legend) {
            wmsSource._legends = [{ url: legend }];
        }
        if (layerInfo.MetadataURL && Array.isArray(layerInfo.MetadataURL)) {
            wmsSource._metadata = [];
            for (var i = 0; i < layerInfo.MetadataURL.length; i++) {
                var metadata = layerInfo.MetadataURL[i].OnlineResource;
                if (metadata) {
                    wmsSource._metadata.push({ url: metadata });
                }
            }
        }
        if (layerInfo.Attribution) {
            var attribution = layerInfo.Attribution;
            wmsSource._originators = {};
            if (attribution.OnlineResource) {
                wmsSource._originators.url = attribution.OnlineResource;
            }
            if (attribution.Title) {
                wmsSource._originators.name = wmsSource._originators.attribution = attribution.Title;
            }
            if (attribution.LogoURL && attribution.LogoURL.OnlineResource) {
                wmsSource._originators.logo = attribution.LogoURL.OnlineResource;
            }
        }
    };
    LayerImport.prototype._addGetCapWMTSLayer = function (layerInfo) {
        if (!layerInfo || !layerInfo.Identifier) {
            console.log('[ol.control.LayerImport] layer information not found in getCapabilities response for layer ');
            return;
        }
        var map = this.getMap();
        if (!map) {
            return;
        }
        var wmtsSourceOptions = {};
        wmtsSourceOptions.layer = layerInfo.Identifier;
        if (this._getCapResponseWMTS.version) {
            wmtsSourceOptions.version = this._getCapResponseWMTS.version;
        }
        var getMapUrl = this._getWMTSLayerGetTileUrl();
        if (getMapUrl) {
            wmtsSourceOptions.url = getMapUrl;
        } else {
            var questionMarkIndex = this._getCapRequestUrl.indexOf('?');
            if (questionMarkIndex !== -1) {
                wmtsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
            } else {
                wmtsSourceOptions.url = this._getCapRequestUrl;
            }
        }
        var tmsOptions = this._getTMSParams(layerInfo);
        wmtsSourceOptions.matrixSet = tmsOptions.tms;
        wmtsSourceOptions.projection = tmsOptions.projCode;
        wmtsSourceOptions.tileGrid = new ol.tilegrid.WMTS({
            resolutions: tmsOptions.resolutions,
            matrixIds: tmsOptions.matrixIds,
            origin: tmsOptions.origin
        });
        var defaultStyle;
        var legend;
        if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
            var style;
            for (var s = 0; s < layerInfo.Style.length; s++) {
                style = layerInfo.Style[s];
                defaultStyle = style.Identifier;
                if (style.isDefault) {
                    break;
                }
                if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
                    legend = style.LegendURL[0].href;
                }
            }
        }
        if (defaultStyle == null) {
            console.log('[ol.control.LayerImport] style information not found in getCapabilities response for layer ' + layerInfo.Identifier);
        }
        wmtsSourceOptions.style = defaultStyle;
        var format;
        if (layerInfo.Format && Array.isArray(layerInfo.Format)) {
            format = layerInfo.Format[0];
        }
        if (format == null) {
            console.log('[ol.control.LayerImport] format information not found in getCapabilities response for layer ' + layerInfo.Identifier);
        }
        wmtsSourceOptions.format = format;
        var wmtsSource = new ol.source.WMTS(wmtsSourceOptions);
        if (layerInfo.Title) {
            wmtsSource._title = layerInfo.Title;
            wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
        } else {
            wmtsSource._title = layerInfo.Identifier;
            wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Identifier;
        }
        if (legend) {
            wmtsSource._legends = [{ url: legend }];
        }
        var layerTileOptions = {};
        layerTileOptions.source = wmtsSource;
        layerTileOptions.extent = this._getWMTSLayerExtent(layerInfo);
        var wmtsLayer;
        try {
            wmtsLayer = new ol.layer.Tile(layerTileOptions);
        } catch (e) {
            console.log('[ol.control.LayerImport] an error occured while trying to create ol.layer.Tile from getCapabilities information. error : ', e);
            return;
        }
        wmtsLayer.gpResultLayerId = 'layerimport:WMTS';
        map.addLayer(wmtsLayer);
    };
    LayerImport.prototype._getWMTSLayerGetTileUrl = function () {
        var gettileurl;
        if (this._getCapResponseWMTS && this._getCapResponseWMTS.OperationsMetadata && this._getCapResponseWMTS.OperationsMetadata.GetTile) {
            var gettile = this._getCapResponseWMTS.OperationsMetadata.GetTile;
            if (gettile.DCP && gettile.DCP.HTTP && gettile.DCP.HTTP.Get && Array.isArray(gettile.DCP.HTTP.Get) && gettile.DCP.HTTP.Get.length !== 0) {
                gettileurl = gettile.DCP.HTTP.Get[0].href;
            }
        }
        return gettileurl;
    };
    LayerImport.prototype._getWMTSLayerProjection = function (layerInfo, getCapResponseWMTS) {
        var projection;
        if (!layerInfo || typeof layerInfo !== 'object') {
            return;
        }
        if (!getCapResponseWMTS || typeof getCapResponseWMTS !== 'object') {
            return;
        }
        if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
            var tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;
            var crs;
            if (getCapResponseWMTS.Contents && Array.isArray(getCapResponseWMTS.Contents.TileMatrixSet)) {
                var tileMatrixSets = getCapResponseWMTS.Contents.TileMatrixSet;
                for (var i = 0; i < tileMatrixSets.length; i++) {
                    if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
                        var tileMatrixSet = tileMatrixSets[i];
                        crs = tileMatrixSet.SupportedCRS;
                        if (crs && typeof crs === 'string') {
                            if (ol.proj.get(crs) || ol.proj.get(crs.toUpperCase())) {
                                projection = crs;
                            }
                        }
                        break;
                    }
                }
            }
        }
        return projection;
    };
    LayerImport.prototype._getTMSParams = function (layerInfo) {
        var tmsOptions = {};
        var matrixIds = [];
        var resolutions = [];
        var origin = [];
        var tms;
        var projCode;
        var projection;
        var map = this.getMap();
        if (!map) {
            return;
        }
        if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
            tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;
            if (this._getCapResponseWMTS.Contents && Array.isArray(this._getCapResponseWMTS.Contents.TileMatrixSet)) {
                var tileMatrixSets = this._getCapResponseWMTS.Contents.TileMatrixSet;
                for (var i = 0; i < tileMatrixSets.length; i++) {
                    if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
                        var tileMatrixSet = tileMatrixSets[i];
                        var tilematrix;
                        var id;
                        var scaledenominator;
                        var resolution;
                        var units;
                        if (tileMatrixSet.SupportedCRS) {
                            projCode = tileMatrixSet.SupportedCRS;
                            projection = ol.proj.get(projCode);
                        }
                        if (projection && projection.getUnits) {
                            units = projection.getUnits();
                        }
                        if (Array.isArray(tileMatrixSet.TileMatrix)) {
                            for (var j = 0; j < tileMatrixSet.TileMatrix.length; j++) {
                                tilematrix = tileMatrixSet.TileMatrix[j];
                                if (tilematrix.Identifier != null) {
                                    id = parseInt(tilematrix.Identifier, 10);
                                    matrixIds.push(id);
                                }
                                scaledenominator = tilematrix.ScaleDenominator;
                                if (units === 'degrees') {
                                    resolution = scaledenominator * 0.00028 * 180 / (Math.PI * 6378137);
                                } else {
                                    resolution = scaledenominator * 0.00028;
                                }
                                resolutions.push(resolution);
                                origin = tilematrix.TopLeftCorner;
                            }
                        }
                        if (Array.isArray(resolutions) && resolutions.sort !== undefined) {
                            resolutions.sort(function (x, y) {
                                return y - x;
                            });
                        }
                        if (Array.isArray(matrixIds) && matrixIds.sort !== undefined) {
                            matrixIds.sort(function (x, y) {
                                return x - y;
                            });
                        }
                    }
                }
            } else {
                console.log('[ol.control.LayerImport] TileMatrixSet data not found in getCapabilities response for layer ' + layerInfo.Identifier);
            }
        } else {
            return;
        }
        tmsOptions.tms = tms;
        tmsOptions.projCode = projCode;
        tmsOptions.matrixIds = matrixIds;
        tmsOptions.resolutions = resolutions;
        tmsOptions.origin = origin;
        return tmsOptions;
    };
    LayerImport.prototype._getWMTSLayerExtent = function (layerInfo) {
        var extent;
        var mapProjCode = this._getMapProjectionCode();
        if (layerInfo.WGS84BoundingBox && Array.isArray(layerInfo.WGS84BoundingBox)) {
            extent = ol.proj.transformExtent(layerInfo.WGS84BoundingBox, 'EPSG:4326', mapProjCode);
        }
        return extent;
    };
    LayerImport.prototype._getMapProjectionCode = function () {
        var map = this.getMap();
        if (!map || !map.getView || !map.getView().getProjection) {
            return;
        }
        var mapProjCode = map.getView().getProjection().getCode();
        return mapProjCode;
    };
    LayerImport.prototype._displayWaitingContainer = function () {
        this._waitingContainer.className = 'GPimportWaitingContainerVisible';
        this._waiting = true;
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = null;
        }
        var context = this;
        this._timer = setTimeout(function () {
            if (context._waiting === true) {
                context._hideWaitingContainer();
            } else {
                if (context._timer) {
                    clearTimeout(context._timer);
                }
            }
        }, 16000);
    };
    LayerImport.prototype._hideWaitingContainer = function () {
        if (this._waiting) {
            this._waitingContainer.className = 'GPimportWaitingContainerHidden';
            this._waiting = false;
            clearTimeout(this._timer);
            this._timer = null;
        }
    };
    LayerImport.prototype._clearGetCapParams = function () {
        this._getCapRequestUrl = null;
        this._getCapResponseWMS = null;
        this._getCapResponseWMTS = null;
        this._getCapResponseWMSLayers = null;
        this._getCapResponseWMTSLayers = null;
    };
    LayerImport.prototype._emptyGetCapResultsList = function () {
        if (this._getCapResultsListContainer) {
            while (this._getCapResultsListContainer.firstChild) {
                this._getCapResultsListContainer.removeChild(this._getCapResultsListContainer.firstChild);
            }
        }
    };
    return LayerImport;
}(ol, gp, {}, Ol3Utils, Ol3ControlsUtilsMarkers, CommonControlsLayerImportDOM, CommonUtilsSelectorID, CommonUtilsProxyUtils, Ol3FormatsKML);
Ol3ControlsGeoportalAttribution = function (ol, LayerUtils) {
    function GeoportalAttribution(options) {
        if (!(this instanceof GeoportalAttribution)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        ol.control.Attribution.call(this, options);
    }
    ol.inherits(GeoportalAttribution, ol.control.Attribution);
    GeoportalAttribution.prototype = Object.create(ol.control.Attribution.prototype, {});
    GeoportalAttribution.prototype.constructor = GeoportalAttribution;
    GeoportalAttribution.prototype.setMap = function (map) {
        if (map != null) {
            var ctrls = map.getControls();
            ctrls.forEach(function (element) {
                if (element instanceof ol.control.Attribution && !(element instanceof GeoportalAttribution)) {
                    this.remove(element);
                }
            }, ctrls);
            this._updateAttributions(map);
            var context = this;
            map.on('moveend', function () {
                context._updateAttributions(map);
            }, this);
            map.getLayers().on('add', function () {
                context._updateAttributions(map);
            }, this);
            map.getLayers().on('remove', function () {
                context._updateAttributions(map);
            }, this);
        }
        ol.control.Attribution.prototype.setMap.call(this, map);
    };
    GeoportalAttribution.prototype._updateAttributions = function (map) {
        var mapAttributions = {};
        var view = map.getView();
        var extent = view.calculateExtent(map.getSize());
        var mapProjection = view.getProjection().getCode();
        var geoExtent = ol.proj.transformExtent(extent, mapProjection, 'EPSG:4326');
        var standardExtent = [
            geoExtent[3],
            geoExtent[0],
            geoExtent[1],
            geoExtent[2]
        ];
        var zoom = view.getZoom();
        var layers = map.getLayers().getArray();
        for (var i = 0; i < layers.length; i++) {
            if (layers[i].getSource) {
                this._updateLayerAttributions(layers[i], mapAttributions, standardExtent, mapProjection, zoom);
            } else if (layers[i].getLayers) {
                var lyrs = layers[i].getLayers();
                var context = this;
                lyrs.forEach(function (lyr) {
                    if (lyr.getSource) {
                        context._updateLayerAttributions(lyr, mapAttributions, standardExtent, mapProjection, zoom);
                    } else {
                        console.log('cannot find layer source in layergroup ', layers[i]);
                    }
                });
            }
        }
    };
    GeoportalAttribution.prototype._updateLayerAttributions = function (layer, mapAttributions, mapExtent, mapCrs, mapZoom) {
        var src = layer.getSource();
        src.setAttributions();
        var attributions = [];
        var visibility = layer.getVisible();
        var originators = src._originators;
        if (originators && visibility) {
            var layerAttributions = LayerUtils.getAttributions({
                extent: mapExtent,
                crs: mapCrs,
                zoom: mapZoom,
                visibility: visibility,
                originators: originators
            });
            for (var j = 0; j < layerAttributions.length; j++) {
                var attributionj = layerAttributions[j];
                if (!mapAttributions || !mapAttributions[attributionj]) {
                    attributions.push(new ol.Attribution({ html: attributionj }));
                    mapAttributions[attributionj] = true;
                }
            }
            if (attributions.length !== 0) {
                src.setAttributions(attributions);
            }
        }
    };
    return GeoportalAttribution;
}(ol, CommonUtilsLayerUtils);
Ol3ControlsMeasuresMeasures = function (ol, woodman, Interactions) {
    var Measures = {
        DEFAULT_POINTER_STYLE: new ol.style.Circle({
            radius: 5,
            stroke: new ol.style.Stroke({
                color: '#002A50',
                width: 2
            }),
            fill: new ol.style.Fill({ color: 'rgba(255, 155, 0, 0.7)' })
        }),
        DEFAULT_DRAW_START_STYLE: new ol.style.Style({
            fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.2)' }),
            stroke: new ol.style.Stroke({
                color: '#002A50',
                lineDash: [
                    10,
                    10
                ],
                width: 2
            })
        }),
        DEFAULT_DRAW_FINISH_STYLE: new ol.style.Style({
            fill: new ol.style.Fill({ color: 'rgba(0, 183, 152, 0.3)' }),
            stroke: new ol.style.Stroke({
                color: '#002A50',
                width: 3
            })
        }),
        tools: {
            MeasureLength: {
                active: false,
                instance: null
            },
            MeasureArea: {
                active: false,
                instance: null
            },
            MeasureAzimuth: {
                active: false,
                instance: null
            }
        },
        measureDraw: null,
        measureSource: null,
        measureVector: null,
        sketch: null,
        measureTooltipElement: null,
        measureTooltip: null,
        helpTooltipElement: null,
        helpTooltip: null,
        clean: function () {
            var _class = this.CLASSNAME;
            this.clearMeasure();
            this.clearMeasureToolTip();
            this.removeMeasureEvents();
            this._showContainer.checked = false;
        },
        onPointerMoveHandler: function (e) {
            if (e.dragging) {
                return;
            }
            var tooltipCoord = e.coordinate;
            if (this.sketch) {
                var output;
                var geom = this.sketch.getGeometry();
                output = this.format(geom);
                if (geom.getType() === 'LineString') {
                    tooltipCoord = geom.getLastCoordinate();
                } else if (geom.getType() === 'Polygon') {
                    tooltipCoord = geom.getInteriorPoint().getCoordinates();
                } else {
                    return;
                }
                this.measureTooltipElement.innerHTML = output;
                this.measureTooltip.setPosition(tooltipCoord);
            }
        },
        onShowMeasureClick: function (e, type) {
            var self = this.CLASSNAME;
            for (var className in this.tools) {
                if (this.tools.hasOwnProperty(className)) {
                    var o = this.tools[className];
                    if (o.active && className !== self) {
                        o.active = false;
                        if (o.instance !== null) {
                            o.instance.clean();
                        }
                    }
                }
            }
            var map = this.getMap();
            Interactions.unset(map, { current: 'Measures' });
            if (!this._showContainer.checked) {
                this.addMeasureEvents();
                this.initMeasureInteraction();
                this.addMeasureInteraction(type);
                this.tools[self].active = true;
            } else {
                this.clearMeasure();
                this.clearMeasureToolTip();
                this.removeMeasureEvents();
                this.tools[self].active = false;
            }
        },
        clearMeasureToolTip: function () {
            var map = this.getMap();
            if (!map) {
                return;
            }
            var mapContainer = map.getTargetElement();
            var overlays = mapContainer.getElementsByClassName('ol-overlaycontainer-stopevent');
            for (var k = 0; k < overlays.length; k++) {
                var nodes = overlays[k];
                var len = nodes.children.length;
                var nodesToRemove = [];
                for (var i = 0; i < len; i++) {
                    var node = nodes.children[i];
                    var child = node.children[0];
                    if (child.className === 'GPmeasureTooltip GPmeasureTooltip-static' || child.className === 'GPmeasureTooltip GPmeasureTooltip-measure') {
                        nodesToRemove.push(node);
                    }
                }
                for (var j = 0; j < nodesToRemove.length; j++) {
                    nodes.removeChild(nodesToRemove[j]);
                }
            }
        },
        clearMeasure: function () {
            var map = this.getMap();
            if (this.measureVector) {
                map.removeLayer(this.measureVector);
                this.measureVector = null;
            }
            if (this.measureDraw) {
                map.removeInteraction(this.measureDraw);
                this.measureDraw = null;
            }
        },
        createMeasureTooltip: function (map) {
            if (this.measureTooltipElement) {
                this.measureTooltipElement.parentNode.removeChild(this.measureTooltipElement);
            }
            this.measureTooltipElement = document.createElement('div');
            this.measureTooltipElement.className = 'GPmeasureTooltip GPmeasureTooltip-measure';
            this.measureTooltip = new ol.Overlay({
                element: this.measureTooltipElement,
                offset: [
                    0,
                    -15
                ],
                positioning: 'bottom-center'
            });
            map.addOverlay(this.measureTooltip);
        },
        createHelpTooltip: function (map) {
            if (this.helpTooltipElement) {
                this.helpTooltipElement.parentNode.removeChild(this.helpTooltipElement);
            }
            this.helpTooltipElement = document.createElement('div');
            this.helpTooltipElement.className = 'tooltip hidden';
            this.helpTooltip = new ol.Overlay({
                element: this.helpTooltipElement,
                offset: [
                    15,
                    0
                ],
                positioning: 'center-left'
            });
            map.addOverlay(this.helpTooltip);
        },
        createStylingMeasureInteraction: function (styles) {
            this.options.styles = styles || {};
            var startStyleOpts = {
                image: Measures.DEFAULT_POINTER_STYLE,
                fill: Measures.DEFAULT_DRAW_START_STYLE.getFill(),
                stroke: Measures.DEFAULT_DRAW_START_STYLE.getStroke()
            };
            if (this.options.styles.hasOwnProperty('pointer') && this.options.styles.pointer instanceof ol.style.Image) {
                startStyleOpts.image = this.options.styles.pointer;
            }
            if (this.options.styles.hasOwnProperty('start') && this.options.styles.start instanceof ol.style.Style) {
                if (this.options.styles.start.getFill() != null) {
                    startStyleOpts.fill = this.options.styles.start.getFill();
                }
                if (this.options.styles.start.getStroke() != null) {
                    startStyleOpts.stroke = this.options.styles.start.getStroke();
                }
            }
            this.options.styles.start = new ol.style.Style(startStyleOpts);
            var finishStyleOpts = {
                fill: Measures.DEFAULT_DRAW_FINISH_STYLE.getFill(),
                stroke: Measures.DEFAULT_DRAW_FINISH_STYLE.getStroke()
            };
            if (this.options.styles.hasOwnProperty('finish') && this.options.styles.finish instanceof ol.style.Style) {
                if (this.options.styles.finish.getFill() != null) {
                    finishStyleOpts.fill = this.options.styles.finish.getFill();
                }
                if (this.options.styles.finish.getStroke() != null) {
                    finishStyleOpts.stroke = this.options.styles.finish.getStroke();
                }
            }
            this.options.styles.finish = new ol.style.Style(finishStyleOpts);
        },
        addMeasureInteraction: function (type) {
            var map = this.getMap();
            var self = this;
            this.measureDraw = new ol.interaction.Draw({
                source: this.measureSource,
                condition: function (event) {
                    if (event.originalEvent.ctrlKey) {
                        if (self.sketch) {
                            this.removeLastPoint();
                        }
                        return false;
                    }
                    return true;
                },
                type: type,
                style: this.options.styles.start || Measures.DEFAULT_DRAW_START_STYLE
            });
            this.measureDraw.setProperties({
                name: 'Measures',
                source: this
            });
            map.addInteraction(this.measureDraw);
            this.createMeasureTooltip(map);
            this.measureDraw.on('drawstart', function (evt) {
                self.sketch = evt.feature;
            }, this);
            this.measureDraw.on('drawend', function () {
                if (self.sketch) {
                    var output;
                    var tooltipCoord;
                    var geom = self.sketch.getGeometry();
                    output = self.format(geom);
                    if (geom.getType() === 'LineString') {
                        tooltipCoord = geom.getLastCoordinate();
                    } else if (geom.getType() === 'Polygon') {
                        tooltipCoord = geom.getInteriorPoint().getCoordinates();
                    } else {
                        return;
                    }
                    self.measureTooltipElement.innerHTML = output;
                    self.measureTooltip.setPosition(tooltipCoord);
                }
                self.measureTooltipElement.className = 'GPmeasureTooltip GPmeasureTooltip-static';
                self.measureTooltip.setOffset([
                    0,
                    -7
                ]);
                self.sketch = null;
                self.measureTooltipElement = null;
                self.createMeasureTooltip(map);
            }, this);
        },
        initMeasureInteraction: function () {
            var map = this.getMap();
            this.measureSource = new ol.source.Vector();
            this.measureVector = new ol.layer.Vector({
                source: this.measureSource,
                style: this.options.styles.finish || Measures.DEFAULT_DRAW_FINISH_STYLE
            });
            this.measureVector.gpResultLayerId = 'measure';
            map.addLayer(this.measureVector);
        }
    };
    return Measures;
}(ol, {}, Ol3ControlsUtilsInteractions);
CommonControlsMeasureToolBoxDOM = function () {
    var MeasureToolBoxDOM = {
        _toolboxId: 'GPtoolbox-measure-main',
        _buttonId: 'GPtoolbox-measure-button',
        _widgetId: 'GPtoolbox-measure-widget',
        getToolBoxID: function (uid) {
            return uid ? this._toolboxId + '-' + uid : this._toolboxId;
        },
        getButtonID: function (uid) {
            return uid ? this._buttonId + '-' + uid : this._buttonId;
        },
        getWidgetID: function (uid) {
            return uid ? this._widgetId + '-' + uid : this._widgetId;
        },
        _createToolBoxContainerElement: function (uid) {
            var container = document.createElement('div');
            container.id = this.getToolBoxID(uid);
            container.className = 'GPshowAdvancedToolPicto';
            var button = document.createElement('button');
            button.id = this.getButtonID(uid);
            var self = this;
            button.addEventListener('click', function () {
                this.blur();
                var widget = document.getElementById(self.getWidgetID(uid));
                if (widget.style.display === 'block') {
                    widget.style.display = 'none';
                } else {
                    widget.style.display = 'block';
                }
            });
            container.appendChild(button);
            var widget = document.createElement('div');
            widget.id = this.getWidgetID(uid);
            widget.addEventListener('click', function () {
            }, false);
            container.appendChild(widget);
            return container;
        }
    };
    return MeasureToolBoxDOM;
}();
Ol3ControlsMeasureToolBox = function (ol, woodman, Utils, ID, MeasureToolBoxDOM) {
    var MeasureToolBox = {
        _toolbox: {},
        add: function (map, ctrl) {
            if (!map) {
                return;
            }
            var mapContainer = map.getTargetElement();
            var mapDocument = mapContainer.ownerDocument;
            var mapId = mapContainer.id;
            if (!this._toolbox || Object.keys(this._toolbox).length === 0) {
                this._toolbox[mapId] = ID.generate();
            } else {
                if (!this._toolbox[mapId]) {
                    this._toolbox[mapId] = ID.generate();
                }
            }
            var uid = this._toolbox[mapId];
            if (!mapDocument.getElementById(this.getToolBoxID(uid))) {
                var toolboxContainer = this._createToolBoxContainerElement(uid);
                var overlaysContainer = mapContainer.getElementsByClassName('ol-overlaycontainer-stopevent');
                overlaysContainer[0].appendChild(toolboxContainer);
            }
            var widgetContainer = mapDocument.getElementById(this.getWidgetID(uid));
            ctrl.setTarget(widgetContainer);
        }
    };
    Utils.assign(MeasureToolBox, MeasureToolBoxDOM);
    return MeasureToolBox;
}(ol, {}, Ol3Utils, CommonUtilsSelectorID, CommonControlsMeasureToolBoxDOM);
CommonControlsElevationPathDOM = function () {
    var ElevationPathDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPelevationPath');
            container.className = 'GPwidget';
            return container;
        },
        _createShowElevationPathElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowElevationPath');
            input.type = 'checkbox';
            return input;
        },
        _createShowElevationPathPictoElement: function () {
            var context = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowElevationPathPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowElevationPath');
            label.title = 'Calculer un profil';
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    context.onShowElevationPathClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    context.onShowElevationPathClick(e);
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowElevationPathOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        },
        _createElevationPathPanelElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPelevationPathPanel');
            div.className = 'GPpanel';
            return div;
        },
        _createElevationPathPanelHeaderElement: function () {
            var self = this;
            var container = document.createElement('div');
            container.className = 'GPpanelHeader';
            var div = document.createElement('div');
            div.className = 'GPpanelTitle';
            div.innerHTML = 'Profil Altimtrique';
            container.appendChild(div);
            var divReduce = document.createElement('div');
            divReduce.id = this._addUID('GPelevationPathPanelReduce');
            divReduce.className = 'GPpanelReduce';
            divReduce.title = 'Masquer le panneau';
            if (divReduce.addEventListener) {
                divReduce.addEventListener('click', function () {
                    if (typeof self.onReduceElevationPathPanelClick === 'function') {
                        document.getElementById(self._addUID('GPshowElevationPath')).checked = false;
                        self.onReduceElevationPathPanelClick();
                    }
                }, false);
            } else if (divReduce.attachEvent) {
                divReduce.attachEvent('onclick', function () {
                    if (typeof self.onReduceElevationPathPanelClick === 'function') {
                        document.getElementById(self._addUID('GPshowElevationPath')).checked = false;
                        self.onReduceElevationPathPanelClick();
                    }
                });
            }
            container.appendChild(divReduce);
            var divClose = document.createElement('div');
            divClose.id = this._addUID('GPelevationPathPanelClose');
            divClose.className = 'GPpanelClose';
            divClose.title = 'Fermer le panneau';
            if (divClose.addEventListener) {
                divClose.addEventListener('click', function () {
                    document.getElementById(self._addUID('GPshowElevationPathPicto')).click();
                }, false);
            } else if (divClose.attachEvent) {
                divClose.attachEvent('onclick', function () {
                    document.getElementById(self._addUID('GPshowElevationPathPicto')).click();
                });
            }
            container.appendChild(divClose);
            return container;
        },
        _createElevationPathPanelProfilElement: function () {
            var div = document.createElement('div');
            div.id = 'GPelevationPathProfil';
            return div;
        },
        _createElevationPathWaitingElement: function () {
            var div = document.createElement('div');
            div.id = this._addUID('GPelevationPathCalcWaitingContainer');
            div.className = 'GPelevationPathCalcWaitingContainerHidden';
            var p = document.createElement('p');
            p.className = 'GPelevationPathCalcWaiting';
            p.innerHTML = 'Calcul en cours...';
            div.appendChild(p);
            return div;
        }
    };
    return ElevationPathDOM;
}();
Ol3ControlsElevationPath = function (ol, woodman, Gp, Utils, RightManagement, Measures, MeasureToolBox, Interactions, ElevationPathDOM, ID) {
    function ElevationPath(options) {
        options = options || {};
        if (!(this instanceof ElevationPath)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.CLASSNAME = 'ElevationPath';
        this._uid = ID.generate();
        this._showContainer = null;
        this._pictoContainer = null;
        this._panelContainer = null;
        this._profileContainer = null;
        this._waitingContainer = null;
        this._drawStyleStart = null;
        this._drawStyleFinish = null;
        this._markerStyle = null;
        this._profile = null;
        this._measureSource = null;
        this._measureVector = null;
        this._measureDraw = null;
        this._lastSketch = null;
        this._currentSketch = null;
        this._marker = null;
        this._noRightManagement = false;
        this._initialize(options);
        this._checkRightsManagement();
        var container = options.element ? options.element : this._initializeContainer();
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(ElevationPath, ol.control.Control);
    ElevationPath.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(ElevationPath.prototype, ElevationPathDOM);
    ElevationPath.__removeProfilMarker = function (context) {
        var self = context;
        if (self._marker) {
            self._measureSource.removeFeature(self._marker);
            self._marker = null;
        }
    };
    ElevationPath.__updateProfilMarker = function (d, context) {
        var self = context;
        var map = self.getMap();
        var proj = map.getView().getProjection();
        ElevationPath.__removeProfilMarker(self);
        var _coordinate = ol.proj.transform([
            d.lon,
            d.lat
        ], 'EPSG:4326', proj);
        var _geometry = new ol.geom.Point(_coordinate);
        self._marker = new ol.Feature({ geometry: _geometry });
        self._marker.setStyle(self._markerStyle);
        self._measureSource.addFeature(self._marker);
    };
    ElevationPath.DISPLAY_PROFILE_LIB_AMCHARTS = function (data, container, context) {
        if (typeof AmCharts === 'undefined') {
            console.log('Lib. AmCharts is not loaded !');
            return;
        }
        AmCharts.addInitHandler(function () {
        });
        var self = context;
        var _config = {};
        Utils.mergeParams(_config, self.options.styles.profile);
        Utils.mergeParams(_config, { dataProvider: data });
        self._profile = AmCharts.makeChart(container, _config);
        self._profile.addListener('changed', function (e) {
            var obj = e.chart.dataProvider[e.index];
            ElevationPath.__removeProfilMarker(self);
            ElevationPath.__updateProfilMarker(obj, self);
        });
    };
    ElevationPath.DISPLAY_PROFILE_LIB_D3 = function (data, container, context) {
        if (typeof d3 === 'undefined') {
            console.log('Lib. D3 is not loaded !');
            return;
        }
        if (container) {
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
        }
        var margin = {
            top: 20,
            right: 20,
            bottom: 30,
            left: 40
        };
        var h = getComputedStyle(container, null).getPropertyValue('height').replace('px', '');
        var w = getComputedStyle(container, null).getPropertyValue('width').replace('px', '');
        var width = w - margin.left - margin.right;
        var height = h - margin.top - margin.bottom;
        var x = d3.scale.linear().range([
            0,
            width
        ]);
        var y = d3.scale.linear().range([
            height,
            0
        ]);
        var xAxis = d3.svg.axis().scale(x).orient('bottom').ticks(5);
        var yAxis = d3.svg.axis().scale(y).orient('left').ticks(5);
        var line = d3.svg.line().interpolate('basis').x(function (d) {
            return x(d.dist);
        }).y(function (d) {
            return y(d.z);
        });
        var area = d3.svg.area().interpolate('basis').x(function (d) {
            return x(d.dist);
        }).y0(height).y1(function (d) {
            return y(d.z);
        });
        var svg = d3.select(container).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        var xDomain = d3.extent(data, function (d) {
            return d.dist;
        });
        x.domain(xDomain);
        var yDomain = [
            0,
            d3.max(data, function (d) {
                return d.z;
            })
        ];
        y.domain(yDomain);
        svg.append('path').datum(data).attr('class', 'area-d3').attr('d', area);
        svg.append('g').attr('class', 'x axis-d3').attr('transform', 'translate(0,' + height + ')').call(xAxis).append('text').attr('y', -15).attr('dy', '.71em').attr('x', width).text('Distance (km)');
        svg.append('g').attr('class', 'y axis-d3').call(yAxis).append('text').attr('transform', 'rotate(-90)').attr('y', 6).attr('dy', '.71em').text('Altitude (m)');
        svg.append('g').attr('class', 'grid-d3 vertical').attr('transform', 'translate(0,' + height + ')').call(xAxis.orient('bottom').tickSize(-height, 0, 0).tickFormat(''));
        svg.append('g').attr('class', 'grid-d3 horizontal').call(yAxis.orient('left').tickSize(-width, 0, 0).tickFormat(''));
        svg.append('path').datum(data).attr('class', 'line-d3').attr('d', line);
        svg.selectAll('circle').data(data).enter().append('circle').attr('cx', function (d) {
            return x(d.dist);
        }).attr('cy', function (d) {
            return y(d.z);
        }).attr('r', 0).attr('class', 'circle-d3');
        var focus = svg.append('g').style('display', 'none');
        focus.append('line').attr('id', 'focusLineX').attr('class', 'focusLine-d3');
        focus.append('line').attr('id', 'focusLineY').attr('class', 'focusLine-d3');
        focus.append('circle').attr('id', 'focusCircle').attr('r', 4).attr('class', 'circle-d3 focusCircle-d3');
        var div = d3.select(container).append('div').attr('class', 'tooltip-d3').style('opacity', 0);
        var bisectDist = d3.bisector(function (d) {
            return d.dist;
        }).left;
        var self = context;
        svg.append('rect').attr('class', 'overlay-d3').attr('width', width).attr('height', height).on('mouseover', function () {
            focus.style('display', null);
            ElevationPath.__updateProfilMarker(data[0], self);
        }).on('mouseout', function () {
            focus.style('display', 'none');
            ElevationPath.__removeProfilMarker(self);
            div.transition().duration(500).style('opacity', 0);
        }).on('mousemove', function () {
            var m = d3.mouse(this);
            var distance = x.invert(m[0]);
            var i = bisectDist(data, distance);
            var d0 = i === 0 ? data[0] : data[i - 1];
            var d1 = data[i];
            var d = distance - d0[0] > d1[0] - distance ? d1 : d0;
            var xc = x(d.dist);
            var yc = y(d.z);
            focus.select('#focusCircle').attr('cx', xc).attr('cy', yc);
            focus.select('#focusLineX').attr('x1', xc).attr('y1', y(yDomain[0])).attr('x2', xc).attr('y2', y(yDomain[1]));
            focus.select('#focusLineY').attr('x1', x(xDomain[0])).attr('y1', yc).attr('x2', x(xDomain[1])).attr('y2', yc);
            ElevationPath.__updateProfilMarker(d, self);
            div.transition().duration(200).style('opacity', 0.9);
            div.html('Alt : ' + d.z + ' m <br/>' + 'Lon : ' + d.lon + ' <br/>' + 'Lat : ' + d.lat).style('left', d3.event.pageX + 'px').style('top', d3.event.pageY - 28 + 'px');
        });
        self._profile = d3.selectAll('rect.overlay')[0][0];
    };
    ElevationPath.DISPLAY_PROFILE_RAW = function (data, container, context) {
        if (container) {
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
        }
        var self = context;
        var div = document.createElement('textarea');
        div.id = 'profileElevationRaw';
        div.rows = 10;
        div.cols = 50;
        div.style.width = '100%';
        div.wrap = 'off';
        div.innerHTML = JSON.stringify(data, undefined, 4);
        container.appendChild(div);
        self._profile = container;
        if (self.options.debug) {
            var _proj = self.getMap().getView().getProjection();
            for (var i = 0; i < data.length; i++) {
                var obj = data[i];
                var _coordinate = ol.proj.transform([
                    obj.lon,
                    obj.lat
                ], 'EPSG:4326', _proj);
                var _geometry = new ol.geom.Point(_coordinate);
                self._marker = new ol.Feature({ geometry: _geometry });
                var styles = ElevationPath.DEFAULT_STYLES.RESULTS;
                var _image = new ol.style.Circle({
                    radius: styles.imageRadius,
                    stroke: new ol.style.Stroke({
                        color: styles.imageStrokeColor,
                        width: styles.imageStrokeWidth
                    }),
                    fill: new ol.style.Fill({ color: styles.imageFillColor })
                });
                self._marker.setStyle(new ol.style.Style({ image: _image }));
                self._measureSource.addFeature(self._marker);
            }
        }
    };
    ElevationPath.DISPLAY_PROFILE_BY_DEFAULT = function (data, container, context) {
        if (container) {
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
        }
        if (!data) {
            return;
        }
        var sortedElev = JSON.parse(JSON.stringify(data));
        sortedElev.sort(function (e1, e2) {
            return e1.z - e2.z;
        });
        var minZ = sortedElev[0].z;
        var maxZ = sortedElev[sortedElev.length - 1].z;
        var diff = maxZ - minZ;
        var distMax = data[data.length - 1].dist;
        var barwidth = 100 / data.length;
        var self = context;
        var div = document.createElement('div');
        div.id = 'profileElevationByDefault';
        div.addEventListener('mouseover', function (e) {
            var _lon = parseFloat(e.target.dataset['lon']);
            var _lat = parseFloat(e.target.dataset['lat']);
            if (_lon && _lat) {
                ElevationPath.__updateProfilMarker({
                    lon: _lon,
                    lat: _lat
                }, self);
            }
        });
        div.addEventListener('mousemove', function () {
        });
        div.addEventListener('mouseout', function () {
            ElevationPath.__removeProfilMarker(self);
        });
        container.appendChild(div);
        var divBox = document.createElement('div');
        divBox.className = 'profile-box';
        var divZ = document.createElement('div');
        divZ.className = 'profile-z-vertical';
        var ulZ = document.createElement('ul');
        var liZmin = document.createElement('li');
        liZmin.setAttribute('class', 'profile-min-z');
        liZmin.innerHTML = minZ + ' m';
        var liZmax = document.createElement('li');
        liZmax.setAttribute('class', 'profile-max-z');
        liZmax.innerHTML = maxZ + ' m';
        ulZ.appendChild(liZmax);
        ulZ.appendChild(liZmin);
        divZ.appendChild(ulZ);
        divBox.appendChild(divZ);
        var divData = document.createElement('div');
        divData.className = 'profile-content';
        var ulData = document.createElement('ul');
        ulData.id = 'profile-data';
        ulData.className = 'profile-z-axis profile-x-axis';
        divData.appendChild(ulData);
        for (var i = 0; i < data.length; i++) {
            var d = data[i];
            var li = document.createElement('li');
            li.setAttribute('data-z', d.z);
            li.setAttribute('data-lon', d.lon);
            li.setAttribute('data-lat', d.lat);
            li.setAttribute('data-dist', d.dist);
            var pct = Math.floor((d.z - minZ) * 100 / diff);
            li.setAttribute('class', 'percent v' + pct);
            li.title = 'altitude : ' + d.z + 'm';
            li.setAttribute('style', 'width: ' + barwidth + '%');
            ulData.appendChild(li);
        }
        divBox.appendChild(divData);
        div.appendChild(divBox);
        var divX = document.createElement('div');
        divX.className = 'profile-x-horizontal';
        var ulX = document.createElement('ul');
        var liXmin = document.createElement('li');
        liXmin.setAttribute('class', 'profile-min-x');
        liXmin.innerHTML = '';
        var liXmax = document.createElement('li');
        liXmax.setAttribute('class', 'profile-max-x');
        liXmax.innerHTML = distMax + ' km';
        ulX.appendChild(liXmin);
        ulX.appendChild(liXmax);
        divX.appendChild(ulX);
        div.appendChild(divX);
        self._profile = container;
    };
    ElevationPath.DEFAULT_STYLES = {
        MARKER: new ol.style.Icon({
            src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAsCAYAAAAATWqyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABTtJREFUeNq8WGtsFUUU/rb3gtdCAykFG9AUDTQUKimhxUewEusrJYoBo4FfEgoqotHERH6oP9TGmJhIrIlWAf9hjAaEiME2pgFfVVpFii8sWqIQLLSx3EJLW7p+Z2Z2b2l7d/b23vZLTmZ2duacb2fmnDk7DlKA67rXs1hJKacsohRQppjXFygnKT9TDlH2O47zFzIFGnco91EOuqnjoBnr2Ow4FhIlLN6m3DykFTh3BGj/Doj/CfSe082xPCDnBmDWTUBeyXDVjZTHOUNHUiZCEs+weI0ySTV0/w0c2wa07gIungn+vOx8YN46oPhpYOp1Xms/5TmSeSMUERKImFnYqBoGuPRNL5LEW8BgX2rrmjWZZLYApS8BUW8r4T0zO5eTEjFr+S6lSjV0HgPqVwNdf6S30abNB+7aDeQWey3bKZtIxvU5DxvyrE/izJfAvuXpkxCIDtElOjWqjK2RM8LZWMbiG0oEnUc5kB7a14WMYvI04H56du5ieZKluZWz8r0/IyQh5TuKRH8cqFuTeRIC0Sm6xYbYok1j21+ahyhLVO3wC8D5VowbRLfY0FhibOulIavDLEoRZyD8sJDeMWBXKG5ZsIobsdDsg+OMq3u1m1u9KQo8zP45EqjRxOUpk6i50IRl4FuGjpZtwUoiMYa314GFj/EzIsN8n8v+C1e4kfvwcm+wnhsZY27xQ8oiWZpKrWRQB6tAElfxpKnjsCdGklDzG9HvpI/0DYLYEpsalVnmAAM6fgR62oMHl70C5N9mn3rpI32DILbEpkZ5ljlFgbPNFtebzij5VPhNKX1lTBASNtXSzPZ3cxCuvVOH7FTCu4yxeZDGbCES0z5+PniQ3uGpwTYmYTOWCPGTpgYP6u9OnYhtzBCbQkSH0NiM4EEdP6VOxDYmYbNLiJxQ1elFwYPaG3XQCn3QHddjgpCweUKI6K2bvzw4YROf//rJob6fZl/H2FRoFiINfqo3qyzYwD8MVIeYLw32J+8j76SP9A2C2BKbGg1CZL+EF/W4YKP9a3/fCeyhkrY9DOOXEu1SlzZ5J31sSNjqURm/OfQkY9qgvkYOvXhbuH0g505Oga7HT9rPF9+t5+pDL0ulwzt46FV5ROax+JUSRRtP0LoHMK64+xNg7iqVEVOKSKRVxRGpsKhRnaRD4SPjR0J0axKCGmP7ilQxm4X8d8xXmfvHJZlPkCR3WfODl9FLMlxCIhevSJ5Nwzo1XdKxYpe3hpmB6BKdmoS43VqPxIgsni+aWOg8biZ3f+nLmSMiuvKWek/P01az7QdLyNVT7lC/l59WAKcb0iMxhzpW1nvmvpDtSiKD1l9OkpnDgv8UyMWFU9wvTP8vdY6NhJwnD1JVtso2OiiLSeL0iJUbNfg6zikVVwRTyOn2HWOfjfLtHgnBhtFIJCViyNDZUatdmnGlaFPqJIoe1WM1aqlz71ivJbLNobgAA9zgu7nZ/vstHAk5WVdzaPRqmGC5lER6kjpV4OWJdq+1kkshSk4VH9izcy/bV66qSPQZV+0J9G7rTY6+XNmqHmYwyJVV24kse1X31dhKHdasygkzy+a64oC4nWr47F4e858nSbLv4V/KAe9JKpVDrx/SImLIXMOiRUKdujESl+49O8xVZxpXzVc/C/I/RxL/hgq8YYkYhev9q6kVO4d9B+sr3vdICNaHJTHWW8Ya/87wqy2uWwstUk/gTYw3aCRGOarMDfS67kfFWqSuIe9imAjQEC272nJHixYNaSvGRIIGN49ywbsZEw1zI11N6TZSHeaGORn+F2AAJtRIMx4t+hUAAAAASUVORK5CYII=',
            anchor: [
                0.5,
                1
            ],
            snapToPixel: true
        }),
        RESULTS: {
            imageRadius: 5,
            imageFillColor: 'rgba(128, 128, 128, 0.2)',
            imageStrokeColor: 'rgba(0, 0, 0, 0.7)',
            imageStrokeWidth: 2
        },
        PROFILE: {
            type: 'serial',
            pathToImages: 'http://cdn.amcharts.com/lib/3/images/',
            categoryField: 'dist',
            autoMarginOffset: 0,
            marginRight: 10,
            marginTop: 10,
            startDuration: 0,
            color: '#5E5E5E',
            fontSize: 10,
            theme: 'light',
            thousandsSeparator: '',
            categoryAxis: {
                color: '#5E5E5E',
                gridPosition: 'start',
                minHorizontalGap: 40,
                tickPosition: 'start',
                title: 'Distance (km)',
                titleColor: '#5E5E5E',
                startOnAxis: true
            },
            chartCursor: {
                animationDuration: 0,
                bulletsEnabled: true,
                bulletSize: 10,
                categoryBalloonEnabled: false,
                cursorColor: '#F90',
                graphBulletAlpha: 1,
                graphBulletSize: 1,
                zoomable: false
            },
            trendLines: [],
            graphs: [{
                    balloonColor: '#CCCCCC',
                    balloonText: '<span class=\'altiPathValue\'>[[title]] : [[value]]m</span><br/><span class=\'altiPathCoords\'>(lat: [[lat]] / lon:[[lon]])</span>',
                    bullet: 'round',
                    bulletAlpha: 0,
                    bulletBorderColor: '#FFF',
                    bulletBorderThickness: 2,
                    bulletColor: '#F90',
                    bulletSize: 6,
                    hidden: false,
                    id: 'AmGraph-1',
                    fillAlphas: 0.4,
                    fillColors: '#C77A04',
                    lineAlpha: 1,
                    lineColor: '#C77A04',
                    lineThickness: 1,
                    title: 'Altitude',
                    valueField: 'z'
                }],
            guides: [],
            valueAxes: [{
                    id: 'ValueAxis-1',
                    minVerticalGap: 20,
                    title: 'Altitude (m)'
                }],
            allLabels: [],
            balloon: {
                borderColor: '#CCCCCC',
                borderThickness: 1,
                fillColor: '#FFFFFF',
                showBullet: true
            },
            titles: []
        }
    };
    ElevationPath.prototype.constructor = ElevationPath;
    ElevationPath.prototype.setMap = function (map) {
        if (map) {
            if (this.options.active) {
                if (this._profile === null) {
                    this._panelContainer.style.display = 'none';
                }
                this._initMeasureInteraction(map);
                this._addMeasureInteraction(map);
            }
            if (!this.options.target) {
                MeasureToolBox.add(map, this);
            }
        }
        ol.control.Control.prototype.setMap.call(this, map);
    };
    ElevationPath.prototype.getActive = function () {
        return this.options.active;
    };
    ElevationPath.prototype.setActive = function (active) {
        this.options.active = active;
    };
    ElevationPath.prototype.clean = function () {
        var map = this.getMap();
        this._panelContainer.style.display = 'none';
        this._showContainer.checked = false;
        this._removeProfile();
        this._removeMeasure();
        this._removeMeasureInteraction(map);
    };
    ElevationPath.prototype._removeMeasure = function () {
        this._lastSketch = null;
        this._currentSketch = null;
        if (this._measureSource) {
            if (this._marker) {
                this._measureSource.removeFeature(this._marker);
                this._marker = null;
            }
            var _features = this._measureSource.getFeatures();
            for (var i = 0; i < _features.length; i++) {
                this._measureSource.removeFeature(_features[i]);
            }
        }
    };
    ElevationPath.prototype._removeProfile = function () {
        this._profile = null;
        if (this._profileContainer) {
            while (this._profileContainer.firstChild) {
                this._profileContainer.removeChild(this._profileContainer.firstChild);
            }
        }
    };
    ElevationPath.prototype._initialize = function (options) {
        this.options = {};
        this.options.target = typeof options.target !== 'undefined' ? options.target : null;
        this.options.render = typeof options.render !== 'undefined' ? options.render : null;
        this.options.apiKey = options.apiKey;
        var debug = options.debug;
        this.options.debug = typeof debug === 'undefined' ? false : debug;
        var active = options.active;
        this.options.active = typeof active === 'undefined' ? false : active;
        var service = options.elevationOptions;
        this.options.service = typeof service === 'undefined' || Object.keys(service).length === 0 ? {} : service;
        var profil = options.displayProfileOptions || {};
        if (typeof profil === 'undefined' || Object.keys(profil).length === 0) {
            this.options.profile = {
                apply: ElevationPath.DISPLAY_PROFILE_BY_DEFAULT,
                target: null
            };
        } else {
            this.options.profile = {};
        }
        var displayFunction = profil.apply || this.options.profile.apply;
        this.options.profile.apply = typeof displayFunction === 'function' ? displayFunction : ElevationPath.DISPLAY_PROFILE_BY_DEFAULT;
        var displayContainer = profil.target || this.options.profile.target;
        this.options.profile.target = typeof displayContainer === 'undefined' ? null : displayContainer;
        var styles = options.stylesOptions || {};
        if (typeof styles === 'undefined' || Object.keys(styles).length === 0) {
            this.options.styles = { profile: ElevationPath.DEFAULT_STYLES.PROFILE };
        } else {
            this.options.styles = {};
        }
        this.options.styles.draw = styles.draw || {};
        this._createStylingDraw();
        this.options.styles.marker = styles.marker || {};
        this._createStylingMarker();
        var profile = styles.profile || this.options.styles.profile;
        this.options.styles.profile = typeof profile === 'undefined' || Object.keys(profile).length === 0 ? ElevationPath.DEFAULT_STYLES.PROFILE : profile;
        this._createStylingProfile();
    };
    ElevationPath.prototype._initializeContainer = function () {
        var container = this._createMainContainerElement();
        var inputShow = this._showContainer = this._createShowElevationPathElement();
        container.appendChild(inputShow);
        var picto = this._pictoContainer = this._createShowElevationPathPictoElement();
        container.appendChild(picto);
        if (this.options.active) {
            this._showContainer.checked = true;
        }
        var panel = this._panelContainer = this._createElevationPathPanelElement();
        var header = this._createElevationPathPanelHeaderElement();
        panel.appendChild(header);
        var profile = this._profileContainer = this._createElevationPathPanelProfilElement();
        panel.appendChild(profile);
        var waiting = this._waitingContainer = this._createElevationPathWaitingElement();
        panel.appendChild(waiting);
        if (this.options.profile.target === null) {
            container.appendChild(panel);
        }
        return container;
    };
    ElevationPath.prototype._checkRightsManagement = function () {
        var rightManagement = RightManagement.check({
            key: this.options.apiKey,
            resources: ['SERVICE_CALCUL_ALTIMETRIQUE_RSC'],
            services: ['Elevation']
        });
        if (!rightManagement) {
            this._noRightManagement = true;
        }
        if (!this.options.apiKey) {
            this.options.apiKey = rightManagement.key;
        }
    };
    ElevationPath.prototype._createStylingMarker = function () {
        var marker = ElevationPath.DEFAULT_STYLES.MARKER;
        if (this.options.styles.marker instanceof ol.style.Image) {
            marker = this.options.styles.marker;
        }
        this._markerStyle = new ol.style.Style({ image: marker });
    };
    ElevationPath.prototype._createStylingDraw = function () {
        var styles = this.options.styles.draw;
        var startStyleOpts = {
            image: Measures.DEFAULT_POINTER_STYLE,
            stroke: Measures.DEFAULT_DRAW_START_STYLE.getStroke()
        };
        if (styles.hasOwnProperty('pointer') && styles.pointer instanceof ol.style.Image) {
            startStyleOpts.image = styles.pointer;
        }
        if (styles.hasOwnProperty('start') && styles.start instanceof ol.style.Stroke) {
            startStyleOpts.stroke = styles.start;
        }
        this._drawStyleStart = new ol.style.Style(startStyleOpts);
        var finishStyleOpts = { stroke: Measures.DEFAULT_DRAW_FINISH_STYLE.getStroke() };
        if (styles.hasOwnProperty('finish') && styles.finish instanceof ol.style.Stroke) {
            finishStyleOpts.stroke = styles.finish;
        }
        this._drawStyleFinish = new ol.style.Style(finishStyleOpts);
    };
    ElevationPath.prototype._createStylingProfile = function () {
        var userStyles = this.options.styles.profile;
        var defaultStyle = ElevationPath.DEFAULT_STYLES.PROFILE;
        Object.keys(defaultStyle).forEach(function (key) {
            if (!userStyles.hasOwnProperty(key)) {
                userStyles[key] = defaultStyle[key];
                return;
            } else {
                var _defaultStyle = defaultStyle[key];
                if (typeof _defaultStyle === 'object') {
                    Utils.mergeParams(_defaultStyle, userStyles[key]);
                    userStyles[key] = _defaultStyle;
                    return;
                }
            }
        }, this);
    };
    ElevationPath.prototype._initMeasureInteraction = function (map) {
        if (!map) {
            return;
        }
        this._measureSource = new ol.source.Vector();
        this._measureVector = new ol.layer.Vector({
            source: this._measureSource,
            style: this._drawStyleFinish
        });
        map.addLayer(this._measureVector);
    };
    ElevationPath.prototype._addMeasureInteraction = function (map) {
        if (!map) {
            return;
        }
        this._measureDraw = new ol.interaction.Draw({
            source: this._measureSource,
            type: 'LineString',
            style: this._drawStyleStart
        });
        this._measureDraw.setProperties({
            name: 'ElevationPath',
            source: this
        });
        map.addInteraction(this._measureDraw);
        var self = this;
        this._measureDraw.on('drawstart', function (evt) {
            if (self._marker !== null) {
                self._measureSource.removeFeature(self._marker);
                self._marker = null;
            }
            if (self._lastSketch !== null) {
                self._measureSource.removeFeature(self._lastSketch);
                self._lastSketch = null;
            }
            self._currentSketch = evt.feature;
            var _features = self._measureSource.getFeatures();
            for (var i = 0; i < _features.length; i++) {
                self._measureSource.removeFeature(_features[i]);
            }
        }, this);
        this._measureDraw.on('drawend', function (evt) {
            self._lastSketch = self._currentSketch;
            if (typeof self.options.service.onSuccess === 'undefined' && self.options.profile.target === null) {
                self._panelContainer.style.display = 'block';
            }
            self._requestService();
        }, this);
    };
    ElevationPath.prototype._removeMeasureInteraction = function (map) {
        if (!map) {
            return;
        }
        if (this._measureVector) {
            map.removeLayer(this._measureVector);
            this._measureVector = null;
        }
        if (this._measureDraw) {
            map.removeInteraction(this._measureDraw);
            this._measureDraw = null;
        }
    };
    ElevationPath.prototype._getGeometry = function () {
        if (this._currentSketch === null) {
            return;
        }
        var geometry = [];
        var map = this.getMap();
        var projSrc = map.getView().getProjection();
        var projDest = 'EPSG:4326';
        var coordinates = this._currentSketch.getGeometry().getCoordinates();
        for (var i = 0; i < coordinates.length; i++) {
            var xy = coordinates[i];
            var ll = xy;
            if (projSrc !== projDest) {
                ll = ol.proj.transform(xy, projSrc, projDest);
            }
            geometry.push({
                lon: ll[0],
                lat: ll[1]
            });
        }
        return geometry;
    };
    ElevationPath.prototype._getLength = function () {
        if (this._currentSketch === null) {
            return;
        }
        var length = 0;
        var wgs84Sphere = new ol.Sphere(6378137);
        var map = this.getMap();
        var projSrc = map.getView().getProjection();
        var projDest = 'EPSG:4326';
        var coordinates = this._currentSketch.getGeometry().getCoordinates();
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
            var c1 = ol.proj.transform(coordinates[i], projSrc, projDest);
            var c2 = ol.proj.transform(coordinates[i + 1], projSrc, projDest);
            length += wgs84Sphere.haversineDistance(c1, c2);
        }
        return length;
    };
    ElevationPath.prototype._requestService = function () {
        var geometry = this._getGeometry();
        if (!geometry) {
            return;
        }
        if (this._noRightManagement) {
            return;
        }
        var options = {};
        Utils.mergeParams(options, this.options.service);
        Utils.mergeParams(options, { apiKey: this.options.apiKey });
        var self = this;
        var _requestServiceOnSuccess = function (result) {
            if (result) {
                self._panelContainer.style.display = 'block';
                self._displayProfile(result.elevations);
                self._waitingContainer.className = 'GPelevationPathCalcWaitingContainerHidden';
                self._waiting = false;
            }
        };
        var _requestServiceOnFailure = function (error) {
            self._panelContainer.style.display = 'none';
            self._waitingContainer.className = 'GPelevationPathCalcWaitingContainerHidden';
            self._waiting = false;
        };
        Utils.mergeParams(options, {
            onSuccess: this.options.service.onSuccess || _requestServiceOnSuccess,
            onFailure: this.options.service.onFailure || _requestServiceOnFailure
        });
        var sampling = options.sampling;
        if (!sampling) {
            var _sampling = 50;
            var _length = this._getLength();
            var p = Math.floor(_length) / 5;
            if (p >= 200) {
                _sampling = 200;
            } else {
                _sampling = Math.floor(p);
            }
            Utils.mergeParams(options, { sampling: _sampling || 50 });
        }
        Utils.mergeParams(options, { positions: geometry });
        this._waitingContainer.className = 'GPelevationPathCalcWaitingContainerVisible';
        Gp.Services.getAltitude(options);
    };
    ElevationPath.prototype._computeElevationMeasure = function (elevations) {
        var wgs84Sphere = new ol.Sphere(6378137);
        elevations[0].dist = 0;
        var distance = 0;
        for (var i = 1; i < elevations.length; i++) {
            distance += wgs84Sphere.haversineDistance([
                elevations[i].lon,
                elevations[i].lat
            ], [
                elevations[i - 1].lon,
                elevations[i - 1].lat
            ]) / 1000;
            elevations[i].dist = distance;
            elevations[i].lat = Math.round(elevations[i].lat * 10000) / 10000;
            elevations[i].lon = Math.round(elevations[i].lon * 10000) / 10000;
        }
        var coeffArrond = 100;
        if (distance > 100) {
            coeffArrond = 1;
        } else if (distance > 10) {
            coeffArrond = 10;
        }
        for (var j = 0; j < elevations.length; j++) {
            var data = elevations[j];
            if (data.z < 0) {
                data.z = 0;
            }
            data.dist = Math.round(data.dist * coeffArrond) / coeffArrond;
        }
        return elevations;
    };
    ElevationPath.prototype._displayProfile = function (elevations) {
        var data = this._computeElevationMeasure(elevations);
        var container = this.options.profile.target;
        if (container) {
            container.appendChild(this._panelContainer);
        }
        container = this._profileContainer;
        var context = this;
        var displayFunction = this.options.profile.apply;
        displayFunction.call(this, data, container, context);
    };
    ElevationPath.prototype.onShowElevationPathClick = function () {
        var map = this.getMap();
        Interactions.unset(map, { current: 'ElevationPath' });
        if (!this._showContainer.checked) {
            if (this._profile === null) {
                this._panelContainer.style.display = 'none';
            }
            this._initMeasureInteraction(map);
            this._addMeasureInteraction(map);
        } else {
            this._panelContainer.style.display = 'none';
            this._removeMeasure();
            this._removeProfile();
            this._removeMeasureInteraction(map);
        }
    };
    return ElevationPath;
}(ol, {}, gp, Ol3Utils, CommonUtilsCheckRightManagement, Ol3ControlsMeasuresMeasures, Ol3ControlsMeasureToolBox, Ol3ControlsUtilsInteractions, CommonControlsElevationPathDOM, CommonUtilsSelectorID);
CommonControlsMeasureLengthDOM = function () {
    var MeasureLengthDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPmeasureLength');
            container.className = 'GPwidget';
            return container;
        },
        _createShowMeasureLengthElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowMeasureLength');
            input.type = 'checkbox';
            return input;
        },
        _createShowMeasureLengthPictoElement: function () {
            var context = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowMeasureLengthPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowMeasureLength');
            label.title = 'Mesurer une distance';
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    context.onShowMeasureLengthClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    context.onShowMeasureLengthClick(e);
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowMeasureLengthOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        }
    };
    return MeasureLengthDOM;
}();
Ol3ControlsMeasuresMeasureLength = function (ol, woodman, Utils, MeasureToolBox, Measures, MeasureLengthDOM, ID) {
    function MeasureLength(options) {
        options = options || {};
        if (!(this instanceof MeasureLength)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.CLASSNAME = 'MeasureLength';
        this._uid = ID.generate();
        this._showContainer = null;
        this._pictoContainer = null;
        this._initialize(options);
        var container = options.element ? options.element : this._initializeContainer();
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(MeasureLength, ol.control.Control);
    MeasureLength.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(MeasureLength.prototype, Measures);
    Utils.assign(MeasureLength.prototype, MeasureLengthDOM);
    MeasureLength.prototype.constructor = MeasureLength;
    MeasureLength.prototype.setMap = function (map) {
        var className = this.CLASSNAME;
        if (map) {
            if (!this.options.target) {
                MeasureToolBox.add(map, this);
            }
        } else {
            this.clean();
        }
        this.tools[className].instance = map ? this : null;
        ol.control.Control.prototype.setMap.call(this, map);
    };
    MeasureLength.prototype._initialize = function (options) {
        this.options = {};
        this.options.geodesic = typeof options.geodesic !== 'undefined' ? options.geodesic : true;
        this.options.target = typeof options.target !== 'undefined' ? options.target : null;
        this.options.render = typeof options.render !== 'undefined' ? options.render : null;
        this.createStylingMeasureInteraction(options.styles);
    };
    MeasureLength.prototype._initializeContainer = function () {
        var container = this._createMainContainerElement();
        var show = this._showContainer = this._createShowMeasureLengthElement();
        container.appendChild(show);
        this._showContainer.checked = false;
        var picto = this._pictoContainer = this._createShowMeasureLengthPictoElement();
        container.appendChild(picto);
        return container;
    };
    MeasureLength.prototype.addMeasureEvents = function () {
        var map = this.getMap();
        map.on('singleclick', this.onPointerMoveHandler, this);
        map.on('pointermove', this.onPointerMoveHandler, this);
    };
    MeasureLength.prototype.removeMeasureEvents = function () {
        var map = this.getMap();
        map.un('singleclick', this.onPointerMoveHandler, this);
        map.un('pointermove', this.onPointerMoveHandler, this);
    };
    MeasureLength.prototype.format = function (line) {
        var map = this.getMap();
        var measure;
        if (this.options.geodesic) {
            var wgs84Sphere = new ol.Sphere(6378137);
            var coordinates = line.getCoordinates();
            measure = 0;
            var sourceProj = map.getView().getProjection();
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                var c1 = ol.proj.transform(coordinates[i], sourceProj, 'EPSG:4326');
                var c2 = ol.proj.transform(coordinates[i + 1], sourceProj, 'EPSG:4326');
                measure += wgs84Sphere.haversineDistance(c1, c2);
            }
        } else {
            measure = Math.round(line.getLength() * 100) / 100;
        }
        var output;
        if (measure > 1000) {
            output = Math.round(measure / 1000 * 100) / 100 + ' ' + 'km';
        } else {
            output = Math.round(measure * 100) / 100 + ' ' + 'm';
        }
        return output;
    };
    MeasureLength.prototype.onShowMeasureLengthClick = function (e) {
        this.onShowMeasureClick(e, 'LineString');
    };
    return MeasureLength;
}(ol, {}, Ol3Utils, Ol3ControlsMeasureToolBox, Ol3ControlsMeasuresMeasures, CommonControlsMeasureLengthDOM, CommonUtilsSelectorID);
CommonControlsMeasureAreaDOM = function () {
    var MeasureAreaDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPmeasureArea');
            container.className = 'GPwidget';
            return container;
        },
        _createShowMeasureAreaElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowMeasureArea');
            input.type = 'checkbox';
            return input;
        },
        _createShowMeasureAreaPictoElement: function () {
            var context = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowMeasureAreaPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowMeasureArea');
            label.title = 'Mesurer une surface';
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    context.onShowMeasureAreaClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    context.onShowMeasureAreaClick(e);
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowMeasureAreaOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        }
    };
    return MeasureAreaDOM;
}();
Ol3ControlsMeasuresMeasureArea = function (ol, woodman, Utils, MeasureToolBox, Measures, MeasureAreaDOM, ID) {
    function MeasureArea(options) {
        options = options || {};
        if (!(this instanceof MeasureArea)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.CLASSNAME = 'MeasureArea';
        this._uid = ID.generate();
        this._showContainer = null;
        this._pictoContainer = null;
        this._initialize(options);
        var container = options.element ? options.element : this._initializeContainer();
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(MeasureArea, ol.control.Control);
    MeasureArea.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(MeasureArea.prototype, Measures);
    Utils.assign(MeasureArea.prototype, MeasureAreaDOM);
    MeasureArea.prototype.constructor = MeasureArea;
    MeasureArea.prototype.setMap = function (map) {
        var className = this.CLASSNAME;
        if (map) {
            if (!this.options.target) {
                MeasureToolBox.add(map, this);
            }
        } else {
            this.clean();
        }
        this.tools[className].instance = map ? this : null;
        ol.control.Control.prototype.setMap.call(this, map);
    };
    MeasureArea.prototype._initialize = function (options) {
        this.options = {};
        this.options.geodesic = typeof options.geodesic !== 'undefined' ? options.geodesic : true;
        this.options.target = typeof options.target !== 'undefined' ? options.target : null;
        this.options.render = typeof options.render !== 'undefined' ? options.render : null;
        this.createStylingMeasureInteraction(options.styles);
    };
    MeasureArea.prototype._initializeContainer = function () {
        var container = this._createMainContainerElement();
        var show = this._showContainer = this._createShowMeasureAreaElement();
        container.appendChild(show);
        this._showContainer.checked = false;
        var picto = this._pictoContainer = this._createShowMeasureAreaPictoElement();
        container.appendChild(picto);
        return container;
    };
    MeasureArea.prototype.addMeasureEvents = function () {
        var map = this.getMap();
        map.on('singleclick', this.onPointerMoveHandler, this);
        map.on('pointermove', this.onPointerMoveHandler, this);
    };
    MeasureArea.prototype.removeMeasureEvents = function () {
        var map = this.getMap();
        map.un('singleclick', this.onPointerMoveHandler, this);
        map.un('pointermove', this.onPointerMoveHandler, this);
    };
    MeasureArea.prototype.format = function (polygon) {
        var map = this.getMap();
        var measure;
        if (this.options.geodesic) {
            var wgs84Sphere = new ol.Sphere(6378137);
            var sourceProj = map.getView().getProjection();
            var geom = polygon.clone().transform(sourceProj, 'EPSG:4326');
            var coordinates = geom.getLinearRing(0).getCoordinates();
            measure = Math.abs(wgs84Sphere.geodesicArea(coordinates));
        } else {
            measure = polygon.getArea();
        }
        var output;
        if (measure > 1000000) {
            output = Math.round(measure / 1000000 * 100) / 100 + ' ' + 'km<sup>2</sup>';
        } else if (measure > 100000) {
            output = Math.round(measure / 1000000 * 1000) / 1000 + ' ' + 'km<sup>2</sup>';
        } else if (measure > 1000) {
            output = Math.round(measure / 10) * 10 + ' ' + 'm<sup>2</sup>';
        } else {
            output = Math.round(measure * 100) / 100 + ' ' + 'm<sup>2</sup>';
        }
        return output;
    };
    MeasureArea.prototype.onShowMeasureAreaClick = function (e) {
        this.onShowMeasureClick(e, 'Polygon');
    };
    return MeasureArea;
}(ol, {}, Ol3Utils, Ol3ControlsMeasureToolBox, Ol3ControlsMeasuresMeasures, CommonControlsMeasureAreaDOM, CommonUtilsSelectorID);
CommonControlsMeasureAzimuthDOM = function () {
    var MeasureAzimuthDOM = {
        _addUID: function (id) {
            var uid = this._uid ? id + '-' + this._uid : id;
            return uid;
        },
        _createMainContainerElement: function () {
            var container = document.createElement('div');
            container.id = this._addUID('GPmeasureAzimuth');
            container.className = 'GPwidget';
            return container;
        },
        _createShowMeasureAzimuthElement: function () {
            var input = document.createElement('input');
            input.id = this._addUID('GPshowMeasureAzimuth');
            input.type = 'checkbox';
            return input;
        },
        _createShowMeasureAzimuthPictoElement: function () {
            var context = this;
            var label = document.createElement('label');
            label.id = this._addUID('GPshowMeasureAzimuthPicto');
            label.className = 'GPshowAdvancedToolPicto';
            label.htmlFor = this._addUID('GPshowMeasureAzimuth');
            label.title = 'Mesurer un azimut';
            if (label.addEventListener) {
                label.addEventListener('click', function (e) {
                    context.onShowMeasureAzimuthClick(e);
                });
            } else if (label.attachEvent) {
                label.attachEvent('onclick', function (e) {
                    context.onShowMeasureAzimuthClick(e);
                });
            }
            var spanOpen = document.createElement('span');
            spanOpen.id = this._addUID('GPshowMeasureAzimuthOpen');
            spanOpen.className = 'GPshowAdvancedToolOpen';
            label.appendChild(spanOpen);
            return label;
        }
    };
    return MeasureAzimuthDOM;
}();
Ol3ControlsMeasuresMeasureAzimuth = function (ol, woodman, Utils, MeasureToolBox, Measures, MeasureAzimuthDOM, ID) {
    function MeasureAzimuth(options) {
        options = options || {};
        if (!(this instanceof MeasureAzimuth)) {
            throw new TypeError('ERROR CLASS_CONSTRUCTOR');
        }
        this.CLASSNAME = 'MeasureAzimuth';
        this._uid = ID.generate();
        this._showContainer = null;
        this._pictoContainer = null;
        this._initialize(options);
        var container = options.element ? options.element : this._initializeContainer();
        ol.control.Control.call(this, {
            element: container,
            target: options.target,
            render: options.render
        });
    }
    ol.inherits(MeasureAzimuth, ol.control.Control);
    MeasureAzimuth.prototype = Object.create(ol.control.Control.prototype, {});
    Utils.assign(MeasureAzimuth.prototype, Measures);
    Utils.assign(MeasureAzimuth.prototype, MeasureAzimuthDOM);
    MeasureAzimuth.prototype.constructor = MeasureAzimuth;
    MeasureAzimuth.prototype.setMap = function (map) {
        var className = this.CLASSNAME;
        if (map) {
            if (!this.options.target) {
                MeasureToolBox.add(map, this);
            }
        } else {
            this.clean();
        }
        this.tools[className].instance = map ? this : null;
        ol.control.Control.prototype.setMap.call(this, map);
    };
    MeasureAzimuth.prototype.setGeodesic = function (value) {
        this.options.geodesic = typeof value !== 'undefined' ? value : false;
    };
    MeasureAzimuth.prototype.isGeodesic = function () {
        return this.options.geodesic;
    };
    MeasureAzimuth.prototype._initialize = function (options) {
        this.options = {};
        this.options.geodesic = typeof options.geodesic !== 'undefined' ? options.geodesic : false;
        this.options.target = typeof options.target !== 'undefined' ? options.target : null;
        this.options.render = typeof options.render !== 'undefined' ? options.render : null;
        this.createStylingMeasureInteraction(options.styles);
    };
    MeasureAzimuth.prototype._initializeContainer = function () {
        var container = this._createMainContainerElement();
        var show = this._showContainer = this._createShowMeasureAzimuthElement();
        container.appendChild(show);
        this._showContainer.checked = false;
        var picto = this._pictoContainer = this._createShowMeasureAzimuthPictoElement();
        container.appendChild(picto);
        return container;
    };
    MeasureAzimuth.prototype.addMeasureEvents = function () {
        var map = this.getMap();
        map.on('singleclick', this.onPointerMoveAzimutHandler, this);
        map.on('pointermove', this.onPointerMoveAzimutHandler, this);
    };
    MeasureAzimuth.prototype.removeMeasureEvents = function () {
        var map = this.getMap();
        map.un('singleclick', this.onPointerMoveAzimutHandler, this);
        map.un('pointermove', this.onPointerMoveAzimutHandler, this);
    };
    MeasureAzimuth.prototype.format = function (line) {
        var map = this.getMap();
        var sourceProj = map.getView().getProjection();
        var c1 = ol.proj.transform(line.getFirstCoordinate(), sourceProj, 'EPSG:4326');
        var c2 = ol.proj.transform(line.getLastCoordinate(), sourceProj, 'EPSG:4326');
        if (!this.options.geodesic) {
            var wgs84Sphere = new ol.Sphere(6378137);
            var lengthGeodesic = wgs84Sphere.haversineDistance(c1, c2);
            if (lengthGeodesic > 500) {
                var fraction = 500 / lengthGeodesic;
                c2 = ol.proj.transform(line.getCoordinateAt(fraction), sourceProj, 'EPSG:4326');
            }
        }
        var degrees2radians = Math.PI / 180;
        var radians2degrees = 180 / Math.PI;
        var lon1 = degrees2radians * c1[0];
        var lon2 = degrees2radians * c2[0];
        var lat1 = degrees2radians * c1[1];
        var lat2 = degrees2radians * c2[1];
        var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
        var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
        var atan = Math.atan2(a, b);
        var azimut = radians2degrees * atan;
        if (azimut < 0) {
            azimut += 360;
        }
        var output = Math.round(azimut * 100) / 100 + ' \xB0';
        return output;
    };
    MeasureAzimuth.prototype.onShowMeasureAzimuthClick = function (e) {
        this.onShowMeasureClick(e, 'LineString');
    };
    MeasureAzimuth.prototype.onPointerMoveAzimutHandler = function (e) {
        this.onPointerMoveHandler(e);
        if (this.sketch) {
            var geom = this.sketch.getGeometry();
            if (geom.getCoordinates().length > 2) {
                this.measureDraw.finishDrawing();
            }
        }
    };
    return MeasureAzimuth;
}(ol, {}, Ol3Utils, Ol3ControlsMeasureToolBox, Ol3ControlsMeasuresMeasures, CommonControlsMeasureAzimuthDOM, CommonUtilsSelectorID);
Ol3GpPluginOl3 = function (ol, Gp, LayerUtils, Register, ProxyUtils, GfiUtils, Utils, KML, WMTS, CRS, SourceWMTS, SourceWMS, LayerWMTS, LayerWMS, LayerSwitcher, GetFeatureInfo, SearchEngine, MousePosition, Drawing, Route, Isocurve, ReverseGeocode, LayerImport, GeoportalAttribution, Markers, ElevationPath, MeasureLength, MeasureArea, MeasureAzimuth) {
    Gp.ol3extVersion = '0.12.0';
    Gp.ol3extDate = '2017-07-27';
    Gp.olUtils = Utils;
    Gp.LayerUtils = LayerUtils;
    Gp.ProxyUtils = ProxyUtils;
    ol.gp = {};
    ol.gp.GfiUtils = GfiUtils;
    ol.format.KMLExtended = KML;
    ol.source.WMTSExtended = WMTS;
    CRS.overload();
    ol.source.GeoportalWMTS = SourceWMTS;
    ol.source.GeoportalWMS = SourceWMS;
    ol.layer.GeoportalWMTS = LayerWMTS;
    ol.layer.GeoportalWMS = LayerWMS;
    ol.control.GeoportalAttribution = GeoportalAttribution;
    ol.control.LayerSwitcher = LayerSwitcher;
    ol.control.GetFeatureInfo = GetFeatureInfo;
    ol.control.SearchEngine = SearchEngine;
    ol.control.Route = Route;
    ol.control.Isocurve = Isocurve;
    ol.control.GeoportalMousePosition = MousePosition;
    ol.control.Drawing = Drawing;
    ol.control.ReverseGeocode = ReverseGeocode;
    ol.control.LayerImport = LayerImport;
    ol.control.MeasureLength = MeasureLength;
    ol.control.MeasureArea = MeasureArea;
    ol.control.MeasureAzimuth = MeasureAzimuth;
    ol.control.DefaultMarkers = Markers;
    ol.control.ElevationPath = ElevationPath;
    return Gp;
}(ol, gp, CommonUtilsLayerUtils, CommonUtilsRegister, CommonUtilsProxyUtils, Ol3GfiUtils, Ol3Utils, Ol3FormatsKML, Ol3SourcesWMTS, Ol3CRSCRS, Ol3LayersSourceWMTS, Ol3LayersSourceWMS, Ol3LayersLayerWMTS, Ol3LayersLayerWMS, Ol3ControlsLayerSwitcher, Ol3ControlsGetFeatureInfo, Ol3ControlsSearchEngine, Ol3ControlsMousePosition, Ol3ControlsDrawing, Ol3ControlsRoute, Ol3ControlsIsocurve, Ol3ControlsReverseGeocode, Ol3ControlsLayerImport, Ol3ControlsGeoportalAttribution, Ol3ControlsUtilsMarkers, Ol3ControlsElevationPath, Ol3ControlsMeasuresMeasureLength, Ol3ControlsMeasuresMeasureArea, Ol3ControlsMeasuresMeasureAzimuth);
window.proj4 = proj4;

return Gp;
}));
