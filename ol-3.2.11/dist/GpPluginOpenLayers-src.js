/*!
 * @brief French Geoportal Extension for OpenLayers
 *
 * This software is released under the licence CeCILL-B (Free BSD compatible)
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt
 * @see http://www.cecill.info/
 *
 * @copyright copyright (c) IGN 
 * @license CeCILL-B
 * @author IGN
 * @version 3.2.11
 * @date 31/03/2022
 *
 */

/*!
 * @overview  ol-mapbox-style - Use Mapbox Style objects with OpenLayers
 * @copyright Copyright (c) 2016 openlayers
 * @license   BSD 2-Clause "Simplified" License
 *            See https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE
 * @version   6.7.0
 */

/*!
 * Sortable -- JavaScript library for reorderable drag-and-drop lists on modern
 * browsers and touch devices. No jQuery required. Supports Meteor, AngularJS,
 * React, Polymer, Vue, Knockout and any CSS library, e.g. Bootstrap.
 *
 * Released under MIT LICENSE
 *
 * Copyright Lebedev Konstantin <ibnRubaXa@gmail.com>
 * https://github.com/SortableJS/Sortable
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @version 1.14.0
 */

/*!
 * @overview  Fetch - window.fetch polyfill
 * @copyright Copyright (c) 2014-2016 GitHub, Inc.
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/github/fetch/master/LICENSE
 * @version   3.0.0
 */

/*!
 * @overview  EventBus - Simple JavaScript class for managing events in JavaScript
 * @copyright Copyright (c) 2014 Krasimir Tsonev
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/krasimir/EventBus/master/LICENSE
 * @version   0.2.0
 */

/*!
 * @overview  es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4
 */

/*!
 * @overview   Proj4js - Javascript reprojection library.
 *
 * @authors
 * - Mike Adair madairATdmsolutions.ca
 * - Richard Greenwood richATgreenwoodmap.com
 * - Didier Richard didier.richardATign.fr
 * - Stephen Irons stephen.ironsATclear.net.nz
 * - Olivier Terral oterralATgmail.com
 * - Calvin Metcalf cmetcalfATappgeo.com
 *
 * @copyright Copyright (c) 2014, Mike Adair, Richard Greenwood, Didier Richard, Stephen Irons, Olivier Terral and Calvin Metcalf
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/proj4js/proj4js/master/LICENSE.md
 * @version   2.7.5
 */

var Gp =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(2);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    var parts = line.split(':')
    var key = parts.shift().trim()
    if (key) {
      var value = parts.join(':').trim()
      headers.append(key, value)
    }
  })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = 'statusText' in options ? options.statusText : 'OK'
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = self.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      resolve(new Response(body, options))
    }

    xhr.onerror = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.ontimeout = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.onabort = function() {
      reject(new DOMException('Aborted', 'AbortError'))
    }

    xhr.open(request.method, request.url, true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob'
    }

    request.headers.forEach(function(value, name) {
      xhr.setRequestHeader(name, value)
    })

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!self.fetch) {
  self.fetch = fetch
  self.Headers = Headers
  self.Request = Request
  self.Response = Response
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Services", function() { return Services; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Error", function() { return Error; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Helper", function() { return Helper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Protocols", function() { return Protocols; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "servicesDate", function() { return servicesDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "servicesVersion", function() { return servicesVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "olExtVersion", function() { return olExtVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "olExtDate", function() { return olExtDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "olExtended", function() { return Ol; });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
var _package_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(3, 1);
/* harmony import */ var _Common_Styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _Styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _GfiUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(41);
/* harmony import */ var _Formats_KML__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(143);
/* harmony import */ var _Formats_GPX__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(148);
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(156);
/* harmony import */ var _Sources_WMTS__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(158);
/* harmony import */ var _Layers_SourceWMTS__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(160);
/* harmony import */ var _Layers_SourceWMS__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(164);
/* harmony import */ var _Layers_LayerWMTS__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(165);
/* harmony import */ var _Layers_LayerWMS__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(168);
/* harmony import */ var _Controls_LayerSwitcher__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(169);
/* harmony import */ var _Controls_GetFeatureInfo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(175);
/* harmony import */ var _Controls_SearchEngine__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(177);
/* harmony import */ var _Controls_MousePosition__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(183);
/* harmony import */ var _Controls_Drawing__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(194);
/* harmony import */ var _Controls_Route__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(202);
/* harmony import */ var _Controls_Isocurve__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(206);
/* harmony import */ var _Controls_ReverseGeocode__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(208);
/* harmony import */ var _Controls_LocationSelector__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(203);
/* harmony import */ var _Controls_LayerImport__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(211);
/* harmony import */ var _Controls_GeoportalAttribution__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(275);
/* harmony import */ var _Controls_Utils_Markers__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(178);
/* harmony import */ var _Controls_ElevationPath__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(277);
/* harmony import */ var _Controls_Measures_MeasureLength__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(283);
/* harmony import */ var _Controls_Measures_MeasureArea__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(285);
/* harmony import */ var _Controls_Measures_MeasureAzimuth__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(287);
/* harmony import */ var _Controls_Editor_Style__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(266);
/* harmony import */ var _Controls_Editor_Filter__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(269);
/* harmony import */ var _Controls_Editor_Layer__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(271);
/* harmony import */ var _Controls_Editor_Themes__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(268);
/* harmony import */ var _Controls_Editor_Legend__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(270);
/* harmony import */ var _Controls_Editor_Group__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(272);
/* harmony import */ var _Controls_Editor__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(263);
/* harmony import */ var _Common_Utils_AutoLoadConfig__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(289);
/* harmony import */ var _CRS_AutoLoadCRS__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(290);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(49);
/* harmony import */ var _CRS_CRS__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(186);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(147);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "olUtils", function() { return _Common_Utils__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _Common_Utils_LayerUtils__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(163);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerUtils", function() { return _Common_Utils_LayerUtils__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _Common_Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(142);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProxyUtils", function() { return _Common_Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(155);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorUtils", function() { return _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(184);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(141);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_44__["default"]; });

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
* Global variable Gp.
*
* @module Gp
* @alias Gp
* @description
*
* This is the global variable that is exposed in the browser environment.
* Content is composed of constructor, functions and properties...
*
* > Config:  (...)
*
* > ColorUtils: (...)
* > LayerUtils: (...)
* > MathUtils: (...)
* > ProxyUtils: (...)
* > Logger: (...)
*
* > olExtended: (...)
* > olUtils: (...)
* > olExtDate: "YYYY-MM-DD"
* > olExtVersion: "X.X.X"
*
* > Error: (...)
* > Helper: (...)
* > Protocols: (...)
* > Services: (...)
* > servicesDate: "YYYY-MM-DD"
* > servicesVersion: "X.X.X"
*
* **Note :**
*
* function to add projections in 'proj4',
* they are exposed in the global variable 'proj4' and 'ol':
* > Gp.olExtended.includeProjections()
*
* You can test it :
* - ol.proj.proj4("EPSG:43260")
* - proj4("EPSG:4326")
*
* Projections include by default into proj4 and ol :
* > WGS84
* > ['EPSG:4326']
* > ['EPSG:3785'], ['EPSG:3857'],
* > ['EPSG:900913'], ['EPSG:102113']
*
* and
*
* > ["EPSG:2154"],
* > ["EPSG:27571"], ["EPSG:27572"],  ["EPSG:27573"],  ["EPSG:2757"],
* > ["CRS:84"],
* > ["IGNF:LAMB93"],
* > ["IGNF:LAMBE"],
* > ["IGNF:LAMB1"],  ["IGNF:LAMB2"],  ["IGNF:LAMB3"],  ["IGNF:LAMB4"],
* > ["IGNF:RGF93G"],
* > ["IGNF:WGS84G"]
*
* The following variables are aslo global :
*   - proj4,
*   - ol,
*   - eventbus
*/
 // ordre des CSS communes puis extensions



























 // import Proj4 from "proj4";







 // Les autoload...


 // export des services



var Services = geoportal_access_lib__WEBPACK_IMPORTED_MODULE_37__["default"].Services;
var Error = geoportal_access_lib__WEBPACK_IMPORTED_MODULE_37__["default"].Error;
var Helper = geoportal_access_lib__WEBPACK_IMPORTED_MODULE_37__["default"].Helper;
var Protocols = geoportal_access_lib__WEBPACK_IMPORTED_MODULE_37__["default"].Protocols;
var servicesDate = geoportal_access_lib__WEBPACK_IMPORTED_MODULE_37__["default"].servicesDate;
var servicesVersion = geoportal_access_lib__WEBPACK_IMPORTED_MODULE_37__["default"].servicesVersion;

/** Version */

var olExtVersion = _package_json__WEBPACK_IMPORTED_MODULE_0__.olExtVersion || _package_json__WEBPACK_IMPORTED_MODULE_0__.version;
/** Publication date */

var olExtDate = _package_json__WEBPACK_IMPORTED_MODULE_0__.date;
/** cf. Gp.olUtils */


/** cf. Gp.LayerUtils */


/** cf. Gp.ProxyUtils */


/** cf. Gp.ColorUtils */


/** cf. Gp.MathUtils */


/** cf. Gp.Logger */



function deepCopy(source, target) {
  // Implementing Tail Call Elimination
  function tce(source, target) {
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        if (!target.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        } else if (_typeof(source[prop]) === "object") {
          tce(source[prop], target[prop]);
        }
      }
    }
  }

  return tce(source, target);
}

var Ol = {}; // FIXME : est il utile d'avoir un ns particulier "gp" ?

Ol.gp = {};
Ol.gp.GfiUtils = _GfiUtils__WEBPACK_IMPORTED_MODULE_3__["default"]; // proposer une fonction de chargement des projections !

Ol.includeProjections = _CRS_CRS__WEBPACK_IMPORTED_MODULE_38__["default"].load; // Editeur MapBox

Ol.style = Ol.style || {};
Ol.style.Editor = _Controls_Editor__WEBPACK_IMPORTED_MODULE_34__["default"];
Ol.style.editor = Ol.style.editor || {};
Ol.style.editor.Style = _Controls_Editor_Style__WEBPACK_IMPORTED_MODULE_28__["default"];
Ol.style.editor.Filter = _Controls_Editor_Filter__WEBPACK_IMPORTED_MODULE_29__["default"];
Ol.style.editor.Layer = _Controls_Editor_Layer__WEBPACK_IMPORTED_MODULE_30__["default"];
Ol.style.editor.Legend = _Controls_Editor_Legend__WEBPACK_IMPORTED_MODULE_32__["default"];
Ol.style.editor.Group = _Controls_Editor_Group__WEBPACK_IMPORTED_MODULE_33__["default"];
Ol.style.editor.Themes = _Controls_Editor_Themes__WEBPACK_IMPORTED_MODULE_31__["default"]; // Rajout des propriétés dans le namespace Ol

Ol.format = Ol.format || {};
Ol.format.KMLExtended = _Formats_KML__WEBPACK_IMPORTED_MODULE_4__["default"];
Ol.format.GPXExtended = _Formats_GPX__WEBPACK_IMPORTED_MODULE_5__["default"];
Ol.format.GeoJSONExtended = _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_6__["default"];
Ol.source = Ol.source || {};
Ol.source.WMTSExtended = _Sources_WMTS__WEBPACK_IMPORTED_MODULE_7__["default"];
Ol.source.GeoportalWMTS = _Layers_SourceWMTS__WEBPACK_IMPORTED_MODULE_8__["default"];
Ol.source.GeoportalWMS = _Layers_SourceWMS__WEBPACK_IMPORTED_MODULE_9__["default"];
Ol.layer = Ol.layer || {};
Ol.layer.GeoportalWMTS = _Layers_LayerWMTS__WEBPACK_IMPORTED_MODULE_10__["default"];
Ol.layer.GeoportalWMS = _Layers_LayerWMS__WEBPACK_IMPORTED_MODULE_11__["default"];
Ol.control = Ol.control || {};
Ol.control.LayerSwitcher = _Controls_LayerSwitcher__WEBPACK_IMPORTED_MODULE_12__["default"];
Ol.control.GeoportalAttribution = _Controls_GeoportalAttribution__WEBPACK_IMPORTED_MODULE_22__["default"];
Ol.control.GetFeatureInfo = _Controls_GetFeatureInfo__WEBPACK_IMPORTED_MODULE_13__["default"];
Ol.control.SearchEngine = _Controls_SearchEngine__WEBPACK_IMPORTED_MODULE_14__["default"];
Ol.control.Route = _Controls_Route__WEBPACK_IMPORTED_MODULE_17__["default"];
Ol.control.Isocurve = _Controls_Isocurve__WEBPACK_IMPORTED_MODULE_18__["default"];
Ol.control.GeoportalMousePosition = _Controls_MousePosition__WEBPACK_IMPORTED_MODULE_15__["default"];
Ol.control.Drawing = _Controls_Drawing__WEBPACK_IMPORTED_MODULE_16__["default"];
Ol.control.ReverseGeocode = _Controls_ReverseGeocode__WEBPACK_IMPORTED_MODULE_19__["default"];
Ol.control.LayerImport = _Controls_LayerImport__WEBPACK_IMPORTED_MODULE_21__["default"];
Ol.control.MeasureLength = _Controls_Measures_MeasureLength__WEBPACK_IMPORTED_MODULE_25__["default"];
Ol.control.MeasureArea = _Controls_Measures_MeasureArea__WEBPACK_IMPORTED_MODULE_26__["default"];
Ol.control.MeasureAzimuth = _Controls_Measures_MeasureAzimuth__WEBPACK_IMPORTED_MODULE_27__["default"];
Ol.control.DefaultMarkers = _Controls_Utils_Markers__WEBPACK_IMPORTED_MODULE_23__["default"];
Ol.control.ElevationPath = _Controls_ElevationPath__WEBPACK_IMPORTED_MODULE_24__["default"];
Ol.control.LocationSelector = _Controls_LocationSelector__WEBPACK_IMPORTED_MODULE_20__["default"]; // Expose extensions openlayers extended

 // "proj4" is exposed into window (for a build bundle) with webpack.
//      console > proj4("EPSG:2154")
// And, it's useful to expose it too into OpenLayers :
//      console > ol.proj.get("EPSG:2154")
// if (window.ol && window.ol.proj && window.ol.proj.proj4) {
//     try {
//         window.ol.proj.proj4.register(Proj4);
//     } catch (e) {}
// }
// Expose extensions openlayers extended into ol

if (window.ol) {
  // on fusionne les fonctionnalités openlayers / étendues
  // Gp.olExtended -> ol
  deepCopy(Ol, window.ol); // ol -> Gp.olExtended

  deepCopy(window.ol, Ol);
}

/***/ }),
/* 3 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"geoportal-extensions\",\"description\":\"French Geoportal Extensions for OpenLayers, Leaflet and iTowns libraries\",\"version\":\"2.6.12\",\"date\":\"31/03/2022\",\"leafletExtName\":\"French Geoportal Extension for Leaflet\",\"leafletExtVersion\":\"2.2.4\",\"olExtName\":\"French Geoportal Extension for OpenLayers\",\"olExtVersion\":\"3.2.11\",\"itownsExtName\":\"French Geoportal Extension for Itowns\",\"itownsExtVersion\":\"2.3.6\",\"main\":\"dist/leaflet/GpPluginLeaflet.js, dist/openlayers/GpPluginOpenLayers.js, dist/itowns/GpPluginItowns.js\",\"module\":\"src/Leaflet/index.js, src/OpenLayers/index.js, src/Itowns/index.js\",\"directories\":{},\"scripts\":{\"setup\":\"npm install\",\"clean\":\"echo \\\"Warning: target not yet implemented!\\\" && exit 0\",\"eslint\":\"eslint src/\",\"test\":\"npm run test:serve\",\"test:serve\":\"cd test && webpack-dev-server --hot --config webpack.test.serve.js\",\"sample\":\"npm run sample:serve\",\"sample:serve\":\"npm run sample:ol:serve\",\"sample:itowns:serve\":\"webpack-dev-server --config build/webpack/webpack.config.itowns --mode=development --https --open-page samples/index-itowns-map.html --content-base . --output-public-path '/dist/itowns/' --port 9001 --open\",\"sample:leaflet:serve\":\"webpack-dev-server --config build/webpack/webpack.config.leaflet --mode=development --https --open-page samples/index-leaflet-map.html --content-base . --output-public-path '/dist/leaflet/' --port 9001 --open\",\"sample:ol:serve\":\"webpack-dev-server --config build/webpack/webpack.config.openlayers --mode=development --https --open-page samples/index-openlayers-map.html --content-base . --output-public-path '/dist/openlayers/' --port 9001 --open\",\"doc\":\"npm run doc:serve\",\"doc:serve\":\"npm run doc:ol:serve\",\"doc:itowns:serve\":\"webpack-dev-server --hot  --config build/webpack/webpack.config.itowns --content-base jsdoc/itowns --port 9001 --open\",\"doc:leaflet:serve\":\"webpack-dev-server --hot  --config build/webpack/webpack.config.leaflet --content-base jsdoc/leaflet --port 9001 --open\",\"doc:ol:serve\":\"webpack-dev-server --hot  --config build/webpack/webpack.config.openlayers --content-base jsdoc/openlayers --port 9001 --open\",\"build:dev\":\"npm-run-all --print-label --print-name build:*:dev\",\"build:prod\":\"npm-run-all --print-label --print-name build:*:prod\",\"build:src\":\"npm-run-all --print-label --print-name build:*:src\",\"build\":\"npm-run-all --print-label --print-name build:*:*\",\"build:itowns\":\"npm-run-all --print-label --print-name build:itowns:*\",\"build:itowns:dev\":\"webpack --config build/webpack/webpack.config.itowns --mode=development\",\"build:itowns:prod\":\"webpack --config build/webpack/webpack.config.itowns --mode=production\",\"build:itowns:src\":\"webpack --config build/webpack/webpack.config.itowns --mode=none\",\"build:ol\":\"npm-run-all --print-label --print-name build:ol:*\",\"build:ol:dev\":\"webpack --config build/webpack/webpack.config.openlayers --mode=development\",\"build:ol:prod\":\"webpack --config build/webpack/webpack.config.openlayers --mode=production\",\"build:ol:src\":\"webpack --config build/webpack/webpack.config.openlayers --mode=none\",\"build:leaflet\":\"npm-run-all --print-label --print-name build:leaflet:*\",\"build:leaflet:dev\":\"webpack --config build/webpack/webpack.config.leaflet --mode=development\",\"build:leaflet:prod\":\"webpack --config build/webpack/webpack.config.leaflet --mode=production\",\"build:leaflet:src\":\"webpack --config build/webpack/webpack.config.leaflet --mode=none\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/IGNF/geoportal-extensions.git\"},\"author\":\"IGNF\",\"keywords\":[\"geoportail\",\"javascript\",\"OpenLayers\",\"Leaflet\",\"Itowns\",\"3D\"],\"license\":\"CECILL-B\",\"bugs\":{\"url\":\"https://github.com/IGNF/geoportal-extensions/issues\"},\"homepage\":\"https://github.com/IGNF/geoportal-extensions#readme\",\"dependencies\":{\"@mapbox/mapbox-gl-style-spec\":\"13.20.1\",\"eventbusjs\":\"0.2.0\",\"geoportal-access-lib\":\"3.1.0\",\"itowns\":\"2.37.0\",\"leaflet\":\"1.7.1\",\"leaflet-draw\":\"1.0.4\",\"loglevel\":\"^1.6.7\",\"markdown-toc\":\"^1.2.0\",\"ol\":\"6.9.0\",\"ol-mapbox-style\":\"6.7.0\",\"proj4\":\"2.7.5\",\"proj4leaflet\":\"1.0.2\",\"sortablejs\":\"1.14.0\",\"three\":\"0.135.0\",\"whatwg-fetch\":\"3.0.0\"},\"devDependencies\":{\"@babel/core\":\"^7.4.4\",\"@babel/plugin-transform-template-literals\":\"^7.7.4\",\"@babel/preset-env\":\"^7.4.4\",\"babel-loader\":\"^8.0.5\",\"chai\":\"^4.2.0\",\"chalk\":\"^4.0.0\",\"clean-webpack-plugin\":\"^3.0.0\",\"copy-webpack-plugin\":\"^5.0.3\",\"core-js\":\"^3.6.4\",\"css-loader\":\"^3.4.2\",\"eslint\":\"^6.8.0\",\"eslint-config-standard\":\"^14.1.1\",\"eslint-loader\":\"^4.0.0\",\"eslint-plugin-import\":\"^2.17.2\",\"eslint-plugin-node\":\"^11.1.0\",\"eslint-plugin-promise\":\"^4.1.1\",\"eslint-plugin-standard\":\"^4.0.0\",\"exports-loader\":\"^0.7.0\",\"expose-loader\":\"^0.7.5\",\"fs-extra\":\"^9.0.0\",\"handlebars\":\"^4.7.5\",\"handlebars-layouts\":\"^3.1.4\",\"html-webpack-plugin\":\"^4.0.4\",\"jsdoc-webpack-plugin\":\"^0.3.0\",\"mini-css-extract-plugin\":\"^0.9.0\",\"mocha\":\"^7.1.1\",\"mocha-loader\":\"^5.0.0\",\"npm-run-all\":\"^4.1.5\",\"optimize-css-assets-webpack-plugin\":\"^5.0.1\",\"path\":\"^0.12.7\",\"replace-bundle-webpack-plugin\":\"^1.0.0\",\"requirejs\":\"^2.3.6\",\"responsive-loader\":\"^1.2.0\",\"speed-measure-webpack-plugin\":\"^1.3.0\",\"string-template\":\"^1.0.0\",\"style-loader\":\"^1.1.3\",\"terser-webpack-plugin\":\"^2.0.0\",\"url-loader\":\"^4.0.0\",\"webpack\":\"^4.30.0\",\"webpack-cli\":\"^3.3.1\",\"webpack-dev-server\":\"^3.3.1\",\"webpack-node-externals\":\"^1.7.2\"}}");

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_GPboostRelief_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _CSS_GPboostRelief_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPboostRelief_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _CSS_GPdrawing_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var _CSS_GPdrawing_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPdrawing_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CSS_GPelevationPath_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _CSS_GPelevationPath_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPelevationPath_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _CSS_GPgetFeatureInfo_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony import */ var _CSS_GPgetFeatureInfo_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPgetFeatureInfo_css__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _CSS_GPisochron_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var _CSS_GPisochron_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPisochron_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _CSS_GPlayerSwitcher_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
/* harmony import */ var _CSS_GPlayerSwitcher_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPlayerSwitcher_css__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _CSS_GPlocation_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _CSS_GPlocation_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPlocation_css__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _CSS_GPmeasureArea_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _CSS_GPmeasureArea_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPmeasureArea_css__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _CSS_GPmeasureAzimuth_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(14);
/* harmony import */ var _CSS_GPmeasureAzimuth_css__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPmeasureAzimuth_css__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _CSS_GPmeasureLength_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(15);
/* harmony import */ var _CSS_GPmeasureLength_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPmeasureLength_css__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _CSS_GPmeasureToolTip_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(16);
/* harmony import */ var _CSS_GPmeasureToolTip_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPmeasureToolTip_css__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _CSS_GPmousePosition_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(17);
/* harmony import */ var _CSS_GPmousePosition_css__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPmousePosition_css__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _CSS_GPreverseGeocoding_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(18);
/* harmony import */ var _CSS_GPreverseGeocoding_css__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPreverseGeocoding_css__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _CSS_GProute_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(19);
/* harmony import */ var _CSS_GProute_css__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_CSS_GProute_css__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _CSS_GPsearchEngine_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(20);
/* harmony import */ var _CSS_GPsearchEngine_css__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPsearchEngine_css__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _CSS_GPwaiting_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(21);
/* harmony import */ var _CSS_GPwaiting_css__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPwaiting_css__WEBPACK_IMPORTED_MODULE_16__);


















/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_GPgeneralWidgetOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _CSS_GPgeneralWidgetOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPgeneralWidgetOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _CSS_Controls_Attribution_GPattributionOpenLayers_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _CSS_Controls_Attribution_GPattributionOpenLayers_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Attribution_GPattributionOpenLayers_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CSS_Controls_Drawing_GPdrawingOpenLayers_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _CSS_Controls_Drawing_GPdrawingOpenLayers_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Drawing_GPdrawingOpenLayers_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _CSS_Controls_Editor_GPeditorOpenLayers_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _CSS_Controls_Editor_GPeditorOpenLayers_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Editor_GPeditorOpenLayers_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _CSS_Controls_ElevationPath_GPelevationPathOpenLayers_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27);
/* harmony import */ var _CSS_Controls_ElevationPath_GPelevationPathOpenLayers_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ElevationPath_GPelevationPathOpenLayers_css__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _CSS_Controls_GetFeatureInfo_GPgetFeatureInfoOpenLayers_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);
/* harmony import */ var _CSS_Controls_GetFeatureInfo_GPgetFeatureInfoOpenLayers_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_GetFeatureInfo_GPgetFeatureInfoOpenLayers_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _CSS_Controls_Isochrone_GPisochronOpenLayers_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29);
/* harmony import */ var _CSS_Controls_Isochrone_GPisochronOpenLayers_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Isochrone_GPisochronOpenLayers_css__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _CSS_Controls_LayerImport_GPimportOpenLayers_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30);
/* harmony import */ var _CSS_Controls_LayerImport_GPimportOpenLayers_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_LayerImport_GPimportOpenLayers_css__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _CSS_Controls_LayerSwitcher_GPlayerSwitcherOpenLayers_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(31);
/* harmony import */ var _CSS_Controls_LayerSwitcher_GPlayerSwitcherOpenLayers_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_LayerSwitcher_GPlayerSwitcherOpenLayers_css__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _CSS_Controls_LocationSelector_GPlocationOpenLayers_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(32);
/* harmony import */ var _CSS_Controls_LocationSelector_GPlocationOpenLayers_css__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_LocationSelector_GPlocationOpenLayers_css__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAreaOpenLayers_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(33);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAreaOpenLayers_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Measures_GPmeasureAreaOpenLayers_css__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAzimuthOpenLayers_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(34);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAzimuthOpenLayers_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Measures_GPmeasureAzimuthOpenLayers_css__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureLengthOpenLayers_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(35);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureLengthOpenLayers_css__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Measures_GPmeasureLengthOpenLayers_css__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _CSS_Controls_MousePosition_GPmousePositionOpenLayers_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(36);
/* harmony import */ var _CSS_Controls_MousePosition_GPmousePositionOpenLayers_css__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_MousePosition_GPmousePositionOpenLayers_css__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _CSS_Controls_ReverseGeocoding_GPreverseGeocodingOpenLayers_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(37);
/* harmony import */ var _CSS_Controls_ReverseGeocoding_GPreverseGeocodingOpenLayers_css__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ReverseGeocoding_GPreverseGeocodingOpenLayers_css__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _CSS_Controls_Route_GProuteOpenLayers_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(38);
/* harmony import */ var _CSS_Controls_Route_GProuteOpenLayers_css__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Route_GProuteOpenLayers_css__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _CSS_Controls_SearchEngine_GPsearchEngineOpenLayers_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(39);
/* harmony import */ var _CSS_Controls_SearchEngine_GPsearchEngineOpenLayers_css__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_SearchEngine_GPsearchEngineOpenLayers_css__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _CSS_Controls_ToolBoxMeasure_GPtoolBoxMeasureOpenLayers_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(40);
/* harmony import */ var _CSS_Controls_ToolBoxMeasure_GPtoolBoxMeasureOpenLayers_css__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ToolBoxMeasure_GPtoolBoxMeasureOpenLayers_css__WEBPACK_IMPORTED_MODULE_17__);
 // css widget : internal import into code source



















/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46);
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_source_WMTS__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_source_ImageWMS__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(47);
/* harmony import */ var ol_source_ImageWMS__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_source_ImageWMS__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(142);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import OpenLayers






 // import geoportal library access

 // import local


 // import $__xmldom from "xmldom";

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__["default"].getLogger("GfiUtils");
var GfiUtils = {
  /**
   * Return layer format
   *
   * @param {ol.layer.Layer} l - layer openlayers
   *
   * @return {String} format - layer format can be wms, wmts, vector or unknown
   *
   */
  getLayerFormat: function getLayerFormat(l) {
    // la fonction 'getType' existe uniquement en mode source es6.
    // le bundle ol ne fournit pas cette fonction !?
    var type = typeof l.getType === "function" ? l.getType() : null;
    var source = l.getSource();

    if (type) {
      if (type === "VECTOR" || type === "VECTOR_TILE") {
        return "vector";
      }

      if (type === "TILE") {
        if (source.tileGrid) {
          return "wmts";
        } else {
          return "wms";
        }
      }

      if (type === "IMAGE") {
        return "wms";
      }
    } else {
      if (source instanceof ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_3___default.a || source instanceof ol_source_ImageWMS__WEBPACK_IMPORTED_MODULE_5___default.a) {
        return "wms";
      }

      if (source instanceof ol_source_WMTS__WEBPACK_IMPORTED_MODULE_4___default.a) {
        return "wmts";
      }

      if (source instanceof ol_source_Vector__WEBPACK_IMPORTED_MODULE_2___default.a || source instanceof ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_1___default.a) {
        return "vector";
      }
    }

    return "unknown";
  },

  /**
   * Info Popup creation and display
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.Coordinate} coords - coordinates where to anchor popup.
   * @param {String} content - content to display
   * @param {String} [contentType='text/html'] - content mime-type
   * @param {Object} autoPanOptions - Auto-pan pop-up options
   * @param {Boolean|Object} [autoPanOptions.autoPan] - Specifies whether the map should auto-pan if the pop-up is rendered outside of the canvas (See {@link https://openlayers.org/en/latest/apidoc/module-ol_Overlay.html#~PanIntoViewOptions PanIntoViewOptions})
   * @param {Object} [autoPanOptions.autoPanAnimation] - Used to customize the auto-pan animation. See {@link https://openlayers.org/en/latest/apidoc/module-ol_Overlay.html#~PanOptions PanOptions}.
   * @param {Number} [autoPanOptions.autoPanMargin] - Margin (in pixels) between the pop-up and the border of the map when autopanning. Default is 20.
   * @return {Boolean} displayed - indicates if something has been displayed
   */
  displayInfo: function displayInfo(map, coords, content, contentType, autoPanOptions) {
    logger.trace("[GfiUtils] : displayInfo...");

    if (!contentType) {
      contentType = "text/html";
    }

    if (content === null) {
      return;
    }

    var _htmlDoc = null;
    var _parser = null;
    var _content = content;
    _content = _content.replace(/\n/g, "");
    _content = _content.replace(/(>)\s*(<)/g, "$1$2");
    var scope = typeof window !== "undefined" ? window : null;

    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && window === null) {
      // code for nodejs
      var DOMParser = __webpack_require__(64).DOMParser;

      _parser = new DOMParser();
      _htmlDoc = _parser.parseFromString(_content, contentType);
    } else if (scope.DOMParser) {
      // code for modern browsers
      _parser = new scope.DOMParser();
      _htmlDoc = _parser.parseFromString(_content, contentType);
    } else if (scope.ActiveXObject) {
      // code for old IE browsers
      _htmlDoc = new scope.ActiveXObject("Microsoft.XMLDOM");
      _htmlDoc.async = false;

      _htmlDoc.loadXML(_content);
    } else {
      logger.log("Incompatible environment for DOM Parser !");
      return false;
    }

    var body = _htmlDoc.getElementsByTagName("body");

    if (body && body.length === 1) {
      if (!body[0].hasChildNodes()) {
        return false;
      }
    } // Affichage des features.


    var element = document.createElement("div");
    element.className = "gp-feature-info-div";
    var closer = document.createElement("input");
    closer.type = "button";
    closer.className = "gp-styling-button closer"; // fait disparaître la popup au clic sur x

    closer.onclick = function () {
      if (map.featuresOverlay) {
        map.removeOverlay(map.featuresOverlay);
        map.featuresOverlay = null;
      }

      return false;
    };

    var contentDiv = document.createElement("div");
    contentDiv.className = "gp-features-content-div";
    contentDiv.innerHTML = content;
    /*
    if (content instanceof HTMLElement) {
        this.logger.trace("[Openlayers] : _displayInfo : pure HTMLElement") ;
        contentDiv.appendChild(content) ;
    } else {
        var parser = new DOMParser() ;
        var doc = null ;
        try {
            doc = parser.parseFromString(content,contentType) ;
            this.logger.trace("[Openlayers] : _displayInfo : HTMLElement from parser") ;
            // FIXME : avec cette methode, on a une balise html + body qui s'insère...
            contentDiv.appendChild(doc.documentElement) ;
        } catch (e) {
            console.log(e) ;
            this.logger.trace("[Openlayers] : _displayInfo : parsing content failed (not HTML)") ;
            // en cas d'erreur : on se contente de recopier le contenu.
            contentDiv.innerHTML = content ;
        }
    }
    */

    element.appendChild(contentDiv);
    element.appendChild(closer);

    if (map.featuresOverlay) {
      // fermeture d'une éventuelle popup déjà ouverte.
      map.removeOverlay(map.featuresOverlay);
      map.featuresOverlay = null;
    }

    map.featuresOverlay = new ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default.a({
      // id : id,
      element: element,
      autoPan: autoPanOptions.autoPan,
      autoPanAnimation: autoPanOptions.autoPanAnimation,
      autoPanMargin: autoPanOptions.autoPanMargin,
      positioning: "bottom-center",
      insertFirst: false,
      // popup appears on top of other overlays if any
      stopEvent: true
    });
    map.addOverlay(map.featuresOverlay);
    map.featuresOverlay.setPosition(coords);
    map.featuresOverlay.render();
    return true;
  },

  /**
   * Gets HTML content from features array
   *
   * @param {ol.Map} map - map openlayers
   * @param {Array.<ol.Features>} features - openlayers features Array
   * @returns {HTMLElement} HTML content.
   */
  features2html: function features2html(map, features) {
    var content = document.createElement("div");
    features.forEach(function (f) {
      var props = f.getProperties();

      if (props.hasOwnProperty("name")) {
        var nameDiv = document.createElement("div");
        nameDiv.className = "gp-att-name-div"; // nameDiv.appendChild(document.createTextNode(props["name"])) ;

        nameDiv.insertAdjacentHTML("afterbegin", props["name"]);
        content.appendChild(nameDiv);
      }

      if (props.hasOwnProperty("description")) {
        var descDiv = document.createElement("div");
        descDiv.className = "gp-att-description-div"; // descDiv.appendChild(document.createTextNode(props["description"])) ;

        descDiv.insertAdjacentHTML("afterbegin", props["description"]);
        content.appendChild(descDiv);
      }

      var p = null;
      var others = false;
      var oDiv = null;
      var ul = null;
      var li = null; // Liste des properties à retirer de la visualisation :

      var listForbidden = [// styles
      "fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width", "marker-symbol", "marker-color", "marker-size", "geometry", // geometrie
      "value", "name", // déjà traité
      "description", // déjà traité
      "styleUrl", "extensionsNode_" // extensions GPX
      ];

      for (p in props) {
        if (props[p] === undefined) {
          continue;
        }

        if (listForbidden.indexOf(p) !== -1) {
          continue;
        }

        if (!others) {
          oDiv = document.createElement("div");
          oDiv.className = "gp-att-others-div";
          ul = document.createElement("ul");
          others = true;
        }

        li = document.createElement("li");
        var span = document.createElement("span");
        span.className = "gp-attname-others-span";
        span.appendChild(document.createTextNode(p + " : "));
        li.appendChild(span);
        li.appendChild(document.createTextNode(props[p]));
        ul.appendChild(li);
      }

      if (ul) {
        oDiv.appendChild(ul);
        content.appendChild(oDiv);
      }
    }, map); // pas de contenu !

    if (!content.hasChildNodes()) {
      content = null;
    }

    return content;
  },

  /**
   * Indicates if there is a feature at the given coordinates for the given layer
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.layer.Layer} olLayer - vector layer openlayers
   * @param {ol.Coordinate} olCoordinate - coordinates pointed by user
   *
   * @return {Boolean} has feature
   *
   */
  layerGetFeatureAtCoordinates: function layerGetFeatureAtCoordinates(map, olLayer, olCoordinate) {
    var pixel = map.getPixelFromCoordinate(olCoordinate);
    return map.hasFeatureAtPixel(pixel, function (layer) {
      if (layer === olLayer) {
        return true;
      }

      return false;
    });
  },

  /**
   * Get information from all the features located at the specified coordinates
   * and belonging to the layers list argument. Those information are gathered
   * and displayed in an info popup.
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.Coordinate} olCoordinate - coordinates pointed by user
   * @param {Array.<ol.layer.Layer>} olLayers - layers requested
   * @param {Object} autoPanOptions - autopan options
   *
   * @returns {Boolean} something is displayed
   *
   */
  displayVectorFeatureInfo: function displayVectorFeatureInfo(map, olCoordinate, olLayers, autoPanOptions) {
    var pixel = map.getPixelFromCoordinate(olCoordinate); // couches vecteur : on remplit un tableau avec les features à proximité.

    var features = [];
    map.forEachFeatureAtPixel(pixel, function (feature, layer) {
      if (!olLayers || olLayers.indexOf(layer) > -1) {
        features.push(feature);
      }
    });

    if (features.length === 0) {
      // no features
      return false;
    }

    var content = this.features2html(map, features); // pas de contenu !

    if (content === null) {
      return false;
    } // Affichage des features.


    this.displayInfo(map, olCoordinate, content.innerHTML, "text/html", autoPanOptions); // this._displayInfo(evt.coordinate,content,"text/html") ;

    return true;
  },

  /**
   * Method to manage the request of information from a list of layers already added to the map.
   * Among the given list of layers only the visible ones are requested.
   * The priority is given to the upper layer having a feature at the pointed coordinates.
   * If the first (upper) feature encountered is from a vector layer the info popup will
   * display the information of the features from all visible vector layers and located at
   * the specified coordinates.
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.Coordinate} olCoordinate - coordinates pointed by user
   * @param {Array.<Object>} gfiLayers - list of layers which can be requested through the control. Each array element is an object, with following properties :
   * @param {ol.layer.Layer} gfiLayers.obj - ol.layer.Layer layer handled by the control (that has been added to map).
   * @param {String} [gfiLayers.event] - name of the mouse event triggering getFeatureInfo on this layer (that has been added to map). allowed values are : 'singleclick', 'dblclick' and 'contextmenu'
   * @param {String} [gfiLayers.infoFormat] - indicates the format mime-type of the response of GetFeatureInfo requests.
   * @param {Object} [proxyOptions] - options for poxy configuration :
   * @param {String} [proxyOptions.proxyUrl] - Proxy URL to avoid cross-domain problems, if not already set in mapOptions. Mandatory to import WMS and WMTS layer.
   * @param {Array.<String>} [proxyOptions.noProxyDomains] - Proxy will not be used for this list of domain names. Only use if you know what you're doing (if not already set in mapOptions).
   * @param {Object} [autoPanOptions] - Auto-pan pop-up options
   * @param {Boolean} [autoPanOptions.autoPan = true] - Specifies whether the map should auto-pan if the pop-up is rendered outside of the canvas. Defaults to true.
   * @param {Object} [autoPanOptions.autoPanAnimation] - Used to customize the auto-pan animation. See {@link https://openlayers.org/en/latest/apidoc/module-ol_Overlay.html#~PanOptions PanOptions}.
   * @param {Number} [autoPanOptions.autoPanMargin] - Margin (in pixels) between the pop-up and the border of the map when autopanning. Default is 20.
   *
   */
  displayFeatureInfo: function displayFeatureInfo(map, olCoordinate, gfiLayers, proxyOptions, autoPanOptions) {
    // Layers orders
    var layersOrdered = {};

    for (var j = 0; j < gfiLayers.length; j++) {
      var layer = gfiLayers[j];
      var position = layer.obj.getZIndex();

      if (!layersOrdered[position]) {
        layersOrdered[position] = [];
      }

      layersOrdered[position].push(layer);
    } // affichage de la première popup d'informations en partant du dessus...


    var requests = []; // inversion de l'ordre des layers

    var positions = Object.keys(layersOrdered);
    positions.sort(function (a, b) {
      return b - a;
    }); // si la 1ere couche affichable est de type vecteur on affiche les infos de toutes
    // les couches vecteur qui suivent. Par consequent, une seule requete vecteur suffit
    // (celle correspondant au premier objet vecteur rencontre)

    var foundFeature = false;

    for (var k = 0; k < positions.length; k++) {
      var p = positions[k];

      for (var h = 0; h < layersOrdered[p].length; ++h) {
        var l = layersOrdered[p][h].obj;
        var infoFormat = layersOrdered[p][h].infoFormat || "text/html";
        var minMaxResolutionOk = true;

        if (l.minResolution && l.minResolution > map.getResolution()) {
          minMaxResolutionOk = false;
        }

        if (minMaxResolutionOk && l.maxResolution && l.maxResolution < map.getResolution()) {
          minMaxResolutionOk = false;
        }

        if (l.getVisible() && minMaxResolutionOk) {
          var format = this.getLayerFormat(l);

          if (format === "vector") {
            if (!foundFeature && this.layerGetFeatureAtCoordinates(map, l, olCoordinate)) {
              requests.push({
                format: format,
                scope: this,
                coordinate: olCoordinate
              });
            }

            continue;
          } else if (format !== "wms" && format !== "wmts") {
            logger.log("[ERROR] DisplayFeatureInfo - layer format '" + format + "' not allowed");
            continue;
          }

          var _res = map.getView().getResolution();

          var _url = null; // INFO
          // en fonction de la version d'openlayers, la méthode est differente :
          // - getGetFeatureInfoUrl en v5
          // - getFeatureInfoUrl en v6

          if (format === "wmts") {
            // eslint-disable-next-line no-useless-call
            _url = l.getSource().getFeatureInfoUrl.call(l.getSource(), olCoordinate, _res, map.getView().getProjection(), {
              INFOFORMAT: infoFormat
            });
          } else {
            // eslint-disable-next-line no-useless-call
            _url = l.getSource().getFeatureInfoUrl.call(l.getSource(), olCoordinate, _res, map.getView().getProjection(), {
              INFO_FORMAT: infoFormat
            });
          }

          requests.push({
            // id : _id,
            format: infoFormat,
            url: _Common_Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_9__["default"].proxifyUrl(_url, proxyOptions),
            scope: this,
            coordinate: olCoordinate
          });
        }
      }
    } // on recupere les couches vecteur ordonnees (a utiliser dans le cas de l'affichage de donnees vecteur)


    var vectorLayersOrdered = null; // call request sync

    function requestsSync(list, iterator, callback) {
      if (list.length === 0) {
        return;
      }

      var nextItemIndex = 0; // function report next request

      function report(displayed) {
        nextItemIndex++;

        if (displayed || nextItemIndex === list.length) {
          callback();
        } else {
          iterator(list[nextItemIndex], report);
        }
      } // instead of starting all the iterations, we only start the 1st one


      iterator(list[0], report);
    }

    ;
    var context = this;
    requestsSync(requests, function (data, report) {
      if (data.format === "vector") {
        if (!vectorLayersOrdered) {
          vectorLayersOrdered = [];

          for (var m = 0; m < positions.length; m++) {
            var p = positions[m];

            for (var n = 0; n < layersOrdered[p].length; ++n) {
              vectorLayersOrdered.push(layersOrdered[p][n].obj);
            }
          }
        }

        report(data.scope.displayVectorFeatureInfo(map, data.coordinate, vectorLayersOrdered, autoPanOptions));
      } else {
        // var self = data.scope;
        geoportal_access_lib__WEBPACK_IMPORTED_MODULE_7__["default"].Protocols.XHR.call({
          url: data.url,
          method: "GET",
          scope: data.scope,
          // Handles GFI response
          onResponse: function onResponse(resp) {
            var exception = false; // a t on une exception ?

            if (resp.trim().length === 0 || resp.indexOf("java.lang.NullPointerException") !== -1 || resp.indexOf("not queryable") !== -1) {
              // rien à afficher
              exception = true;
            } // on affiche la popup GFI !


            var displayed = !exception && context.displayInfo(map, data.coordinate, resp, "text/html", autoPanOptions); // on reporte sur la prochaine requête...

            report(displayed);
          },
          // Handles GFI response error
          onFailure: function onFailure(error) {
            logger.log(error);
            report(false);
          }
        });
      }
    }, function () {
      logger.trace("Finish sync to GFI !");
    });
  },
  // Function returning the clicked position of an event
  getPosition: function getPosition(e, map) {
    if (e.coordinate) {
      return e.coordinate;
    }

    var pixel = [0, 0];

    if (e.offsetX || e.offsetY) {
      pixel[0] = e.offsetX; // + document.body.scrollLeft + document.documentElement.scrollLeft;

      pixel[1] = e.offsetY; // + document.body.scrollTop + document.documentElement.scrollTop;
    } else if (e.pointerType === "touch") {
      // a implementer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // Safari iOS / iPhone en mode Touch (cf. hammer)
      var p = e.pointers[0];
      pixel[0] = p.pageX;
      pixel[1] = p.pageY;
    }

    var coordinate = map.getCoordinateFromPixel(pixel);
    return coordinate;
  },
  // onDisplayFeatureInfo
  onDisplayFeatureInfo: function onDisplayFeatureInfo(e, gfiObj) {
    if (!gfiObj.isActive()) {
      return;
    }

    logger.trace(e);
    var map = gfiObj.getMap();

    if (e.type === "contextmenu" || e.type === "dblclick") {
      e.preventDefault();
    } else if (e.type === "singleclick") {
      var interactions = map.getInteractions().getArray();

      for (var i = 0; i < interactions.length; i++) {
        if (interactions[i].getActive() && (interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_6__["Select"] || interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_6__["Modify"] || interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_6__["Draw"])) {
          // si on a une interaction de dessin ou de sélection en cours, on ne fait rien.
          return;
        }
      }
    }

    var proxyOptions = {};

    if (gfiObj._proxyUrl) {
      proxyOptions.proxyUrl = gfiObj._proxyUrl;
    }

    if (gfiObj._noProxyDomains) {
      proxyOptions.noProxyDomains = gfiObj._noProxyDomains;
    }

    var autoPanOptions = {};

    if (gfiObj._autoPan) {
      autoPanOptions.autoPan = gfiObj._autoPan;
    }

    if (gfiObj._autoPanAnimation) {
      autoPanOptions.autoPanAnimation = gfiObj._autoPanAnimation;
    }

    if (gfiObj._autoPanMargin) {
      autoPanOptions.autoPanMargin = gfiObj._autoPanMargin;
    }

    var eventLayers = [];

    for (var j = 0; j < gfiObj._layers.length; ++j) {
      var event = gfiObj._layers[j].event ? gfiObj._layers[j].event : gfiObj._defaultEvent;

      if (event === e.type) {
        var ind = eventLayers.push(gfiObj._layers[j]) - 1;

        if (!eventLayers[ind].infoFormat) {
          eventLayers[ind].infoFormat = gfiObj._defaultInfoFormat;
        }
      }
    }

    var coords = this.getPosition(e, map);
    this.displayFeatureInfo(map, coords, eventLayers, proxyOptions, autoPanOptions);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (GfiUtils); // Expose GfiUtils as ol.gp.GfiUtils (for a build bundle)

if (window.ol) {
  if (window.ol.gp) {
    window.ol.gp.GfiUtils = GfiUtils;
  } else {
    window.ol.gp = {
      GfiUtils: GfiUtils
    };
  }
}

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = ol.Overlay;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = ol.source.VectorTile;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = ol.source.Vector;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = ol.source.TileWMS;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = ol.source.WMTS;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = ol.source.ImageWMS;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = ol.interaction;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "servicesVersion", function() { return servicesVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "servicesDate", function() { return servicesDate; });
/* harmony import */ var _Services_Services__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _Services_DefaultUrlService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);
/* harmony import */ var _Services_Alti_Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78);
/* harmony import */ var _Services_Alti_Response_model_Elevation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79);
/* harmony import */ var _Services_AutoComplete_Response_model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(127);
/* harmony import */ var _Services_AutoComplete_Response_model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(128);
/* harmony import */ var _Services_AutoConf_Response_model_AutoConfResponse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(83);
/* harmony import */ var _Services_AutoConf_Response_model_Constraint__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(84);
/* harmony import */ var _Services_AutoConf_Response_model_Format__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85);
/* harmony import */ var _Services_AutoConf_Response_model_Layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(86);
/* harmony import */ var _Services_AutoConf_Response_model_Legend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(87);
/* harmony import */ var _Services_AutoConf_Response_model_Metadata__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(88);
/* harmony import */ var _Services_AutoConf_Response_model_Originator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(89);
/* harmony import */ var _Services_AutoConf_Response_model_Service__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(90);
/* harmony import */ var _Services_AutoConf_Response_model_Style__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(91);
/* harmony import */ var _Services_AutoConf_Response_model_Territory__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(92);
/* harmony import */ var _Services_AutoConf_Response_model_Thematic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(93);
/* harmony import */ var _Services_AutoConf_Response_model_TileMatrix__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(95);
/* harmony import */ var _Services_AutoConf_Response_model_TileMatrixLimit__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(96);
/* harmony import */ var _Services_AutoConf_Response_model_TileMatrixSet__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(94);
/* harmony import */ var _Services_Geocode_Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(117);
/* harmony import */ var _Services_Geocode_Response_model_GeocodedLocation__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(119);
/* harmony import */ var _Services_Geocode_Response_model_DirectGeocodedLocation__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(118);
/* harmony import */ var _Services_Geocode_Response_model_ReverseGeocodedLocation__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(124);
/* harmony import */ var _Services_ProcessIsoCurve_Response_model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(140);
/* harmony import */ var _Services_Route_Response_model_RouteResponse__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(134);
/* harmony import */ var _Services_Route_Response_model_RouteInstruction__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(135);
/* harmony import */ var _Protocols_XHR__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(59);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(55);
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(57);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(67);
var _package_json__WEBPACK_IMPORTED_MODULE_30___namespace = /*#__PURE__*/__webpack_require__.t(67, 1);
/**
* Global variable Gp.
*
* @module Gp
* @alias Gp
* @description
*
* This is the global variable that is exposed in the browser environment.
* Content is composed of constructor, functions and properties...
*
* > {@link Gp.Error Error()}
*     - .TYPE_SRVERR : "SERVICE_ERROR"
*     - .TYPE_UNKERR : "UNKNOWN_ERROR"
*     - .TYPE_USEERR : "USAGE_ERROR"
*
* > {@link module:Helper Helper}
*     - .indent()
*     - .normalyzeParameters()
*     - .normalyzeUrl()
*
* > {@link module:XHR Protocols.XHR}
*     - .call()
*
* > {@link module:Services Services (objects)}
*     - .Alti
*         - {@link Gp.Services.Alti.Elevation .Elevation()}
*     - {@link Gp.Services.AltiResponse .AltiResponse()}
*     - .AutoComplete
*         - {@link Gp.Services.AutoComplete.SuggestedLocation .SuggestedLocation()}
*     - {@link Gp.Services.AutoCompleteResponse .AutoCompleteResponse()}
*     - {@link Gp.Services.Config .Config()}
*     - {@link Gp.Services.DefaultUrl .DefaultUrl()}
*     - .Geocode
*         - {@link Gp.Services.Geocode.GeocodedLocation .GeocodedLocation()}
*         - {@link Gp.Services.Geocode.ReverseGeocodedLocation .ReverseGeocodedLocation()}
*         - {@link Gp.Services.Geocode.DirectGeocodedLocation .DirectGeocodedLocation()}
*     - {@link Gp.Services.GeocodeResponse .GeocodeResponse()}
*     - {@link Gp.Services.GetConfigResponse .GetConfigResponse()}
*     - {@link Gp.Services.IsoCurveResponse .IsoCurveResponse()}
*     - .Route
*         - {@link Gp.Services.Route.RouteInstruction .RouteInstruction()}
*     - {@link Gp.Services.RouteResponse .RouteResponse()}
*
* > Services (factory)
*     - {@link module:Services~autoComplete .autoComplete()}
*     - {@link module:Services~geocode .geocode()}
*     - {@link module:Services~getAltitude .getAltitude()}
*     - {@link module:Services~getConfig .getConfig()}
*     - {@link module:Services~isoCurve .isoCurve()}
*     - {@link module:Services~reverseGeocode .reverseGeocode()}
*     - {@link module:Services~route .route()}
*
* > servicesDate : "YYYY-MM-DD"
*
* > servicesVersion : "X.X.X"
*
*/


































/** Version */
const servicesVersion = _package_json__WEBPACK_IMPORTED_MODULE_30__.version;
/** Publication date */
const servicesDate = _package_json__WEBPACK_IMPORTED_MODULE_30__.date;

// on declare les ns dans root global
var Gp = {};

Gp.servicesVersion = servicesVersion;
Gp.servicesDate = servicesDate;

// Export Protocols
Gp.Protocols = {};
Gp.Protocols.XHR = _Protocols_XHR__WEBPACK_IMPORTED_MODULE_27__["default"];
// Export services
Gp.Services = _Services_Services__WEBPACK_IMPORTED_MODULE_0__["default"];
// Export DefaultUrls
Gp.Services.DefaultUrl = _Services_DefaultUrlService__WEBPACK_IMPORTED_MODULE_1__["default"];
// Export Alti
Gp.Services.AltiResponse = _Services_Alti_Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_2__["default"];
Gp.Services.Alti = {};
Gp.Services.Alti.Elevation = _Services_Alti_Response_model_Elevation__WEBPACK_IMPORTED_MODULE_3__["default"];
// Export Autocomplete
Gp.Services.AutoCompleteResponse = _Services_AutoComplete_Response_model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_4__["default"];
Gp.Services.AutoComplete = {};
Gp.Services.AutoComplete.SuggestedLocation = _Services_AutoComplete_Response_model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_5__["default"];
// Export Autoconf
Gp.Services.GetConfigResponse = _Services_AutoConf_Response_model_AutoConfResponse__WEBPACK_IMPORTED_MODULE_6__["default"];
Gp.Services.Config = {};
Gp.Services.Config.Constraint = _Services_AutoConf_Response_model_Constraint__WEBPACK_IMPORTED_MODULE_7__["default"];
Gp.Services.Config.Format = _Services_AutoConf_Response_model_Format__WEBPACK_IMPORTED_MODULE_8__["default"];
Gp.Services.Config.Layer = _Services_AutoConf_Response_model_Layer__WEBPACK_IMPORTED_MODULE_9__["default"];
Gp.Services.Config.Legend = _Services_AutoConf_Response_model_Legend__WEBPACK_IMPORTED_MODULE_10__["default"];
Gp.Services.Config.Metadata = _Services_AutoConf_Response_model_Metadata__WEBPACK_IMPORTED_MODULE_11__["default"];
Gp.Services.Config.Originator = _Services_AutoConf_Response_model_Originator__WEBPACK_IMPORTED_MODULE_12__["default"];
Gp.Services.Config.Service = _Services_AutoConf_Response_model_Service__WEBPACK_IMPORTED_MODULE_13__["default"];
Gp.Services.Config.Style = _Services_AutoConf_Response_model_Style__WEBPACK_IMPORTED_MODULE_14__["default"];
Gp.Services.Config.Territory = _Services_AutoConf_Response_model_Territory__WEBPACK_IMPORTED_MODULE_15__["default"];
Gp.Services.Config.Thematic = _Services_AutoConf_Response_model_Thematic__WEBPACK_IMPORTED_MODULE_16__["default"];
Gp.Services.Config.TileMatrix = _Services_AutoConf_Response_model_TileMatrix__WEBPACK_IMPORTED_MODULE_17__["default"];
Gp.Services.Config.TileMatrixLimit = _Services_AutoConf_Response_model_TileMatrixLimit__WEBPACK_IMPORTED_MODULE_18__["default"];
Gp.Services.Config.TileMatrixSet = _Services_AutoConf_Response_model_TileMatrixSet__WEBPACK_IMPORTED_MODULE_19__["default"];
// Export Geocode
Gp.Services.GeocodeResponse = _Services_Geocode_Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_20__["default"];
Gp.Services.Geocode = {};
Gp.Services.Geocode.GeocodedLocation = _Services_Geocode_Response_model_GeocodedLocation__WEBPACK_IMPORTED_MODULE_21__["default"];
Gp.Services.Geocode.DirectGeocodedLocation = _Services_Geocode_Response_model_DirectGeocodedLocation__WEBPACK_IMPORTED_MODULE_22__["default"];
Gp.Services.Geocode.ReverseGeocodedLocation = _Services_Geocode_Response_model_ReverseGeocodedLocation__WEBPACK_IMPORTED_MODULE_23__["default"];
// Export IsoCurve
Gp.Services.IsoCurveResponse = _Services_ProcessIsoCurve_Response_model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_24__["default"];
// Export Route
Gp.Services.RouteResponse = _Services_Route_Response_model_RouteResponse__WEBPACK_IMPORTED_MODULE_25__["default"];
Gp.Services.Route = {};
Gp.Services.Route.RouteInstruction = _Services_Route_Response_model_RouteInstruction__WEBPACK_IMPORTED_MODULE_26__["default"];
// Export Erreurs et Outils
Gp.Error = _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_28__["default"];
Gp.Helper = _Utils_Helper__WEBPACK_IMPORTED_MODULE_29__["default"];

/* harmony default export */ __webpack_exports__["default"] = (Gp);


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Alti_Alti__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _AutoConf_AutoConf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
/* harmony import */ var _Geocode_Geocode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/* harmony import */ var _Geocode_ReverseGeocode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(120);
/* harmony import */ var _AutoComplete_AutoComplete__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(125);
/* harmony import */ var _Route_Route__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(129);
/* harmony import */ var _ProcessIsoCurve_ProcessIsoCurve__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(136);
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "point|circle|bbox" }] */

/**
* Geoportal web services invocation namespace.
*
* @module Services
* @alias Gp.Services
*/








var Services = {
    /**
     * Access to Geoportal resources metadata availables with one ore several keys, using [Auto-configuration service]{@link https://wxs.ign.fr/APIKEY/autoconf} of the Geoportal platform.
     *
     * @method getConfig
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key(s) ("," as separator, no spaces) to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GetConfigResponse} object as a parameter except if "rawResponse" parameter is set to true : a String will be returned.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/autoconf] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=JSONP] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting an underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    getConfig : function (options) {
        var autoconfService = new _AutoConf_AutoConf__WEBPACK_IMPORTED_MODULE_1__["default"](options);
        autoconfService.call();
    },

    /**
     * Getting elevations in or along of one or several points on french territories using the [elevation services of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/alti.html}.<br/>
     * Two use cases are availables :<br/>
     * 1. getting elevations of the given points : don't use the options.sampling parameter ;<br/>
     * 2. getting a regular set of elevations along the given points : use the options.sampling parameter.
     *
     * @method getAltitude
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {Array.<Object>} options.positions - Array of positions ({lon:float, lat:float}) expressed in CRS:84 coordinates system, where to get elevations. 50 positions maximum may be given. 2 positions minimum are required if you use the options.sampling parameter.
     * @param {Number} [options.sampling] - Number of points to use (between 2 and 5000) in order to compute an elevation path. The points given with the options.positions parameter are used to fix the planimetric path along which the elevations will be computed.<br/>
     * If not used, only elevations of these positions will be returned.
     * @param {Boolean} [options.zonly=false] - Set this parameter to true if you only want to have elevations returned without corresponding coordinates.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AltiResponse} object as a parameter, except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/alti/rest/elevation.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     * @param {String} [options.api='REST'] - What API to use for interacting with underlying web service : 'REST' or 'WPS'. Only use if you know what you are doing.
     * @param {String} [options.outputFormat='xml'] - Output format for underlying web service response : 'xml' or 'json'. Only use if you know what you are doing.
     */
    getAltitude : function (options) {
        var altiService = new _Alti_Alti__WEBPACK_IMPORTED_MODULE_0__["default"](options);
        altiService.call();
    },
    /**
     * Getting positon of a geographic identifier (places names, address, cadastral parcel, other...) using the [geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage.html}.
     *
     * @example
     * Gp.Services.geocode ({
     *     apiKey : "carte",
     *     location : "73 avenue de Paris, Saint-Mandé",
     *     // traitement des resultats
     *     onSuccess  : function (result) {
     *         console.log("found (x:"+result.position.x+", y:"+result.position.y+")") ;
     *     }
     * }) ;
     *
     *
     * @method geocode
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String|Object} options.location - Geographic identifier to locate. May be provided as a single String or a structured Object for an address search. In this last case, the following properties are availaibles.
     *      @param {Number} [options.location.number] - Street number.
     *      @param {String} [options.location.street] - Street name.
     *      @param {String} [options.location.city] - City name.
     *      @param {Number} [options.location.postalCode] - Postal Code
     * @param {Object} [options.filterOptions] - Additional filters to apply to search. The following properties may be given.
     *      @param {Gp.BBox} [options.filterOptions.bbox] - Bounding box where to perform the search. Properties expressed in options.srs coordinates system.
     *      @param {Array.<String>} [options.filterOptions.type] - Geographical identifier types to search. Values currently availables are : "PositionOfInterest" for place names, "StreetAddress" for address search, "CadastralParcel" for Cadastral parcels search. Default is "StreetAddress".
     *
     *      @param {String} [options.filterOptions.[prop]] - Additionnal properties to filter search. Properties depends on options.filterOptions.type, and values type should be "String".
     *      <br/><br/>
     *      Common Properties availables for all search types :<br/>
     *      "municipality", "insee", "department".
     *      <br/><br/>
     *      Properties availables for address search :<br/>
     *      "quality", "ID", "ID_TR" and "territory".
     *      <br/><br/>
     *      Properties availables for place names search :<br/>
     *      "importance", "nature" and "territory".
     *      <br/><br/>
     *      Properties availables for cadastral parcels search :<br/>
     *      "sheet", "section", and "absorbedcity".
     * @param {Number} [options.maximumResponses = 25] - Maximum number of responses. Default underlying service value applies (25) if not provided.
     * @param {Boolean} [options.returnFreeForm = false] - Set this parameter to true if you wish to have an address returned in a single String (unstructured). If unset, default underlying service value (false) applies.
     * @param {String} [options.srs = EPSG:4326] - Coordinates System used to expres coordinates for parameters and responses. Default underlying service value (EPSG:4326) applies.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/geoportail/ols] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    geocode : function (options) {
        var geocodeService = new _Geocode_Geocode__WEBPACK_IMPORTED_MODULE_2__["default"](options);
        geocodeService.call();
    },
    /**
     * Retrieving geographical identifiers (place names, address, cadastral parcels, ...) near a given position, using the [reverse geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage-inverse.html}.
     *
     * @method reverseGeocode
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {Gp.Point} options.position - Reference position where to search geographical identifiers. Its coordinates are expressed in the coordinates system given with options.srs parameter. (default is CRS:84, that means position.x is the longitude and position.y the latitude)
     * @param {Object} [options.filterOptions] - Additional filters to apply to search. The following properties may be given.
     *      @param {Array.<String>} [options.filterOptions.type] - Geographical identifier types to search. Values currently availables are : "PositionOfInterest" for place names, "StreetAddress" for address search, "CadastralParcel" for Cadastral parcels search. Default is "StreetAddress".
     *      @param {Gp.BBox} [options.filterOptions.bbox] - Bounding box where to perform the search. Expressed in options.srs coordinates system.
     *      @param {Gp.Circle} [options.filterOptions.circle] - Circle where to perform the search. Expressed in options.srs coordinates system.
     * @param {Array.<Gp.Point>} [options.filterOptions.polygon] - Polygon where to perform the search. Expressed in options.srs coordinates system.
     * @param {Number} [options.maximumResponses] - Maximum number of responses. Default underlying service value applies (25) if not provided.
     * @param {Boolean} [options.returnFreeForm = false] - Set this parameter to true if you wish to have an address returned in a single String (unstructured). If unset, default underlying service value (false) applies.
     * @param {String} [options.srs = CRS:84] - Coordinates System used to express coordinates for parameters and responses. Only WGS 84 geographical positioning is supported. Therefore, two values are allowed : "CRS:84" (position.x is the longitude and position.y the latitude) and "EPSG:4326" (position.x is the latitude and position.y the longitude) . Default is CRS:84.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/geoportail/ols] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    reverseGeocode : function (options) {
        var reverseGeocodeService = new _Geocode_ReverseGeocode__WEBPACK_IMPORTED_MODULE_3__["default"](options);
        reverseGeocodeService.call();
    },
    /**
     * Getting suggestions of probable places names or address based on uncomplete texts, using the [autocompletion service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/autocompletion.html}
     *
     * @method autoComplete
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} options.text - Text input to complete.
     * @param {Array.<String>} [options.filterOptions.type = "StreetAddress"] - Suggestion types to provide : address ("StreetAddress") and/or place name ("PositionOfInterest").
     * @param {Array.<String>} [options.filterOptions.territory] - Places where to limit the search of suggestions : "METROPOLE" (Corsica and metropolitan France), "DOMTOM" (French overseas departments and territories), or an INSEE code of a department. No limitation by default. For instance : ['METROPOLE', '31']
     * @param {Number} [options.maximumResponses = 10] - Maximum number of responses.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AutoCompleteResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/ols/apis/completion] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    autoComplete : function (options) {
        var autoCompleteService = new _AutoComplete_AutoComplete__WEBPACK_IMPORTED_MODULE_4__["default"](options);
        autoCompleteService.call();
    },
    /**
     * Getting a route from one point to another using the [route service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/itineraires.html}.
     *
     * @method route
     * @param {Object} options - Options for function call.
     * @param {String} options.resource - Resource used to compute the route. Available values are in the GetCapabilities.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} [options.routePreference = "fastest"] - Indicates the way to compute the route : "fastest" (time optimisation) or "shortest" (distance optimisation). Available values are in the GetCapabilities.
     * @param {Gp.Point} options.startPoint - Start point of the route. Expressed in CRS:84 coordinates system (startPoint.x corresponds to longitude, startPoint.y corresponds to latitude). Available bbox are in the GetCapabilities.
     * @param {Gp.Point} options.endPoint - End point of the route. Expressed in CRS:84 coordinates system (endPoint.x corresponds to longitude, endPoint.y corresponds to latitude). Available bbox are in the GetCapabilities.
     * @param {Array.<Gp.Point>} [options.viaPoints] - Ordered via Points of the route. Expressed in CRS:84 coordinates system (viaPoints[i].x corresponds to longitude, viaPoints[i].y corresponds to latitude). Available bbox are in the GetCapabilities.
     * @param {String} [options.graph = "Voiture"] - User profile to use to compute the route : "Voiture" (using a vehicule) or "Pieton" (pedestrian). Has an influence on the kind of roads the route may use and the average speed. Available bbox are in the GetCapabilities.
     * @param {Array.<String>} [options.exclusions] - DEPRECATED: use options.constraints. Indicates if route has to avoid some features ("toll", "bridge" or "tunnel").
     * @param {Boolean} [options.geometryInInstructions = false] - Indicates if route geometry has to be also returned with route instructions.
     * @param {Boolean} [options.provideBoundingBox = true] - Indicates if route instructions has to be localised with a BBOX in the response.
     * @param {String} [options.distanceUnit = "m"] - The unit used to provide distances in the response ("meter" or "kilometer").
     * @param {String} [options.timeUnit = "second"] - The unit used to provide duration in the response ("standard", "second", "minute", "hour").
     * @param {Array.<String>} [options.waysAttributes] - Way Attributes to add in the response. Available values are in the GetCapabilities.
     * @param {Array.<Object>} [options.constraints] - Constraints used ({'constraintType':'banned','key':'ways_type','operator':'=','value':'autoroute'}). Available values are in the GetCapabilities.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.RouteResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.outputFormat='json'] - Output format ("json" or "xml") to use for underlying webService. Only use if you know what you are doing.
     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/itineraire/rest/route.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    route : function (options) {
        var routeService = new _Route_Route__WEBPACK_IMPORTED_MODULE_5__["default"](options);
        routeService.call();
    },
    /**
     * Computing a set of places (curve) reachable from a given point (or from where to start to reach a given point) within a time or distance constraint using the [isochrone service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/isochrones.html}.
     *
     * @method isoCurve
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} options.resource - Resource used to compute the route. Available values are in the GetCapabilities.
     * @param {Gp.Point} options.position - Start or Arrival (options.reverse===true) Point for the computing. Expressed in CRS:84 coordinates system (position.x corresponds to longitude, position.y corresponds to latitude).
     * @param {String} [options.graph = "Voiture"] - User profile to use to compute the isoCurve : "Voiture" (using a vehicule) or "Pieton" (pedestrian). Has an influence on the kind of roads to use and the average speed. Available values are in the GetCapabilities.
     * @param {Array.<String>} [options.exclusions] - DEPRECATED: use options.constraints. Indicates if route has to avoid some features ("toll", "bridge" or "tunnel").
     * @param {Array.<Object>} [options.constraints] - Constraints used ({'constraintType':'banned','key':'ways_type','operator':'=','value':'autoroute'}). Available values are in the GetCapabilities.
     * @param {String} [options.method = "time"] - Computing method to use : "time" (using a duration as a constraint) or "distance" (using a distance as a constraint). Available values are in the GetCapabilities.
     * @param {Float} options.time - Maximum duration (expressed in seconds) to use when options.method is set to "time".
     * @param {Float} options.distance - Maximum distance (expressed in meters) to use when options.method is set to "distance".
     * @param {Boolean} [options.reverse = false] - Set this parameter to true if you want options.position to be the destination (instead of departure) for the computing.
     * @param {String} [options.distanceUnit = "km"] - The unit used to provide distances in the response ("m" or "km").
     * @param {String} [options.timeUnit = "second"] - The unit used to provide duration in the response ("standard", "second", "minute", "hour").
     * @param {Boolean} [options.smoothing = false] - DEPRECATED: Set this parameter to true if you want the resulting geometry to be smoothed.
     * @param {Boolean} [options.holes = false] - DEPRECATED: Set this parameter to true if you want the resulting geometry (polygon) to have holes if pertinent.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.IsoCurveResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.outputFormat='json'] - Output format ("json") to use for underlying webService. Only use if you know what you are doing.
     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/isochrone/isochrone.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    isoCurve : function (options) {
        var processIsoCurveService = new _ProcessIsoCurve_ProcessIsoCurve__WEBPACK_IMPORTED_MODULE_6__["default"](options);
        processIsoCurveService.call();
    }
};

/**
 * Point object.
 *
 * @namespace
 * @alias Gp.Point
 *
 * @property {Float} x - Point abscissa
 * @property {Float} y - Point ordinate
 */
var point = {};

/**
 * Circle object.
 *
 * @namespace
 * @alias Gp.Circle
 *
 * @property {Float} x - Circle center abscissa.
 * @property {Float} y - Circle center ordinate.
 * @property {Float} radius - Circle radius.
 */
var circle = {};

/**
 * Bounding box object, expressed with four coordinates.
 *
 * @namespace
 * @alias Gp.BBox
 *
 * @property {Float} left - minimum abscissa
 * @property {Float} right - maximum abscissa
 * @property {Float} bottom - minimum ordinate
 * @property {Float} top - maximum ordinate
 */
var bbox = {};

/* harmony default export */ __webpack_exports__["default"] = (Services);


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);
/* harmony import */ var _Request_AltiRequestFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(68);
/* harmony import */ var _Response_AltiResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75);









/**
 * @classdesc
 *
 * Appel du service d'altimétrie du Géoportail
 *
 * @todo gestion du parma. output et callback
 * @todo outputFormat (REST) et format (WPS)
 * @todo La reponse JSON peut encapsuler un XML !
 *
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.Alti
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {Array.<Object>} options.positions - Tableau ({lon:float,lat:float}) contenant les coordonnées des points (CRS:84)
 *      dont on veut connaître les altitudes (ou à partir desquelles on va calculer le profil).
 *      Chaque élément du tableau est un objet JavaScript avec deux attributs : lon et lat, qui sont des flottants.
 *      Minimum 2 éléments si on souhaite calculer un profil altimétrique (ElevationLine).
 *      Maximum 50 éléments.
 *
 * @param {String} options.outputFormat - Le format de la réponse du service alti : 'xml' ou 'json'.
 *      Ce paramètre déterminera l'extension '.xml' ou '.json' du service dans le cas de l'API REST,
 *      ou la valeur du paramètre 'format' dans le cas de la norme WPS.
 *      Nécessaire si serverUrl est renseigné, et qu'on souhaite passer par l'API REST,
 *      pour connaître le format dans lequel sera fournie la réponse (pour son traitement).
 *      Non nécessaire pour la norme WPS. Par défaut, ce paramètre vaut 'json'.
 *
 * @param {Number} [options.sampling] - Nombre de points à utiliser pour déterminer le tracé d'un profil altimétrique, compris entre 2 et 5000.
 *      A spécifier lorsqu'on souhaite accéder à cette fonctionnalité.
 *      Dans ce cas, les points fournis en entrée (au minimum de deux) servent à déterminer l'axe planimétrique
 *      le long duquel le profil doit être calculé.
 *      Si le paramètre sampling n'est pas spécifié ou moins de deux points sont fournis,
 *      c'est le service Elevation qui sera interrogé (altitudes simples calculées pour les points fournis).
 *      Une valeur de sampling strictement inférieure à 2 déclenchera un échantillonnage avec la valeur par défaut du service (3 points).
 *
 * @param {String} [options.api] - Manière d'accéder au service : 'REST' (via l'API REST) ou 'WPS' (via la norme WPS).
 *      Par défaut, on utilise l'API REST.
 *
 * @param {Boolean} [options.zonly] - Permet de ne récupérer que les altitudes en sortie s'il vaut 'true'.
 *      Vaut 'false' par défaut.
 *
 * @example
 *   var options = {
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      positions : [{lon:, lat:}, {lon:, lat:}],
 *      outputFormat : 'json' // json|xml
 *      sampling : 3,
 *      api : 'REST', // REST|WPS
 *      zonly : false // false|true
 *   };
 *
 * @private
 */
function Alti (options) {
    if (!(this instanceof Alti)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "Alti"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "Alti";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.Alti");
    this.logger.trace("[Constructeur Alti (options)]");

    // #####################
    // analyse des options
    // #####################

    if (!options.positions) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "positions"));
    }

    if (options.positions.length === 0) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "positions"));
    }

    // ajout des options spécifiques au service
    this.options.positions = options.positions;

    // format de réponse du service : "json" ou "xml" (valeur par défaut), en minuscule !
    this.options.outputFormat = (typeof options.outputFormat === "string") ? options.outputFormat.toLowerCase() : "xml";

    // sampling
    this.options.sampling = options.sampling || null;

    // type d'api utilisé pour requeter le service, en majuscule !
    this.options.api = (typeof options.api === "string") ? options.api.toUpperCase() : "REST";

    // l'api ne peut être interrogée qu'en GET.
    if (this.options.api === "REST") {
        this.options.httpMethod = "GET";
    }

    // param. zonly
    this.options.zonly = options.zonly || false;

    // gestion de l'url du service par defaut
    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut
    // en fonction du type d'api, REST ou WPS, du format de reponse demandé (outputFormat)
    // ainsi que sur le type de service (profil ou elevation)
    if (!this.options.serverUrl) {
        var lstUrlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].Alti.url(this.options.apiKey);
        var urlFound = null;
        switch (this.options.api) {
            case "WPS":
                urlFound = lstUrlByDefault.wps;
                break;
            case "REST":
                var key = (options.sampling ? "profil" : "elevation") + "-" + this.options.outputFormat;
                urlFound = lstUrlByDefault[key];
                break;
            default:
                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_UNKNOWN", "api"));
        }

        if (!urlFound) {
            throw new Error("Url by default not found !");
        }
        this.options.serverUrl = urlFound;
        this.logger.trace("Server URL by default : " + this.options.serverUrl);
    }

    // gestion du type de service
    // si l'extension de l'url est .json ou .xml, on surcharge le format de sortie (outputFormat)
    var idx = this.options.serverUrl.lastIndexOf(".");
    if (idx !== -1) {
        var extension = this.options.serverUrl.substring(idx + 1);
        if (extension && extension.length < 5) { // FIXME extension de moins de 4 car. ...
            this.logger.trace("Server Extension URL : " + extension);
            switch (extension.toLowerCase()) {
                case "json":
                case "xml":
                    this.options.outputFormat = extension.toLowerCase();
                    break;
                default:
                    throw new Error("type of service : unknown or unsupported (json or xml) !");
            }
        }
    }
}

/**
 * @lends module:Alti#
 */
Alti.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/**
 * Constructeur (alias)
 */
Alti.prototype.constructor = Alti;

/**
 * Création de la requête (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Alti.prototype.buildRequest = function (error, success) {
    // utilisation en mode callback
    var options = {
        httpMethod : this.options.httpMethod,
        // callback
        onSuccess : function (result) {
            // sauvegarde de la requete !
            this.request = result;
            success.call(this, this.request);
        },
        onError : error,
        scope : this,
        // spécifique au service :
        positions : this.options.positions,
        outputFormat : this.options.outputFormat,
        sampling : this.options.sampling,
        api : this.options.api,
        zonly : this.options.zonly
    };

    _Request_AltiRequestFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);
};

/**
 * Analyse de la reponse (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Alti.prototype.analyzeResponse = function (error, success) {
    // INFO
    // Factory pour masquer la complexité du retour du service qui renvoie soit
    //  - une 'string' qui contient du XML ou JSON natif en mode XHR
    //  - un objet JSON qui est natif ou encapsulé

    if (this.response) {
        var options = {
            response : this.response,
            outputFormat : this.options.outputFormat, // utile pour parser la string en mode XHR : JSON ou XML !
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this
        };

        _Response_AltiResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ __webpack_exports__["default"] = (Alti);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);


var LoggerByDefault = {
    /**
     * logger statique
     *
     * @static
     * @param {String} name - nom du logger
     * @returns {Object} retourne un logger
     */
    getLogger : function (name) {
        // Substitute global constants configured at compile time
        // cf. webpack.config.js
        // FIXME howtodo !? DefineWebpackPlugin ? EnvironmentWebpackPlugin ?
        ("false".match(/true/)) ? loglevel__WEBPACK_IMPORTED_MODULE_0__["disableAll"]() : loglevel__WEBPACK_IMPORTED_MODULE_0__["enableAll"]();
        var logname = name || "default";
        return loglevel__WEBPACK_IMPORTED_MODULE_0__["getLogger"](logname);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (LoggerByDefault);


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          self.setLevel(defaultLevel, false);
          clearPersistedLevel();
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Classe de gestion des erreurs qui permer d'associer un message d'erreur à l'exception lancée.
 *
 * @example
 * MessagesResources.getMessage("ERROR_PARAM_MISSING", "x", "y", "z")));
 * // --> output : Parameter(s) 'x - y - z' missing
 *
 * @module MessagesResources
 * @alias Gp.Utils.MessagesResources
 * @private
 */
var MessagesResources = {

    // Paramètres
    PARAM_MISSING : "Parameter(s) '%var%' missing",
    PARAM_EMPTY : "Parameter(s) '%var%' empty",
    PARAM_TYPE : "Wrong type(s) for parameter(s) '%var%'",
    PARAM_FORMAT : "Parameter(s) '%var%' not correctly formatted",
    PARAM_NOT_SUPPORT : "Value(s) for parameter(s) '%var%' not supported",
    PARAM_NOT_SUPPORT_NODEJS : "Value(s) for parameter(s) '%var%' not supported to NodeJS",
    PARAM_UNKNOWN : "Value(s) for parameter(s) '%var%' unknown",

    // Services
    // Requête
    SERVICE_REQUEST_BUILD : "An error occurred during the request building of the service",
    SERVICE_REQUEST_EMPTY : "The request sent to the service is empty",

    // Réponse
    SERVICE_RESPONSE_EXCEPTION : "The service returned an exception : '%var%'",
    SERVICE_RESPONSE_EXCEPTION_2 : "The service returned an exception",
    SERVICE_RESPONSE_ANALYSE : "An error occurred while parsing the response '%var%' of the service",
    SERVICE_RESPONSE_ANALYSE_2 : "An unknown error occurred while parsing the response",
    SERVICE_RESPONSE_EMPTY : "The response of the service is empty",
    SERVICE_RESPONSE_EMPTY_2 : "The response from the service could not be analyzed or is empty",
    SERVICE_RESPONSE_FORMAT : "The format of the service response is not supported (handled format(s) : '%var%')",
    SERVICE_RESPONSE_FORMAT_2 : "The format of the service response is not supported",
    SERVICE_RESPONSE_FORMAT_3 : "No suggestion matching the search",

    // Classes
    CLASS_CONSTRUCTOR : "'%var%' constructor cannot be called as a function.",

    /**
     * Fonction qui va retourner le message d'erreur associé à la clé donnée
     *
     * @method getMessage
     * @param {String} clef - Clef de l'erreur (ex : ERROR_PARAM)
     * @param {String[]} parametres - Paramètres/variables concernés par le message d'erreur associé à la clef donnée
     * @return {String} message - String contenant le message de l'exception
     */
    getMessage : function (clef, parametres) {
        // param de la fonction uniquement pour la documentation...

        if (Object.keys(arguments).length === 0) {
            return "Message indefined !";
        }

        var params = Array.prototype.slice.call(arguments);
        var key = params.shift();
        var args = params;

        var message = this[key];

        try {
            if (Array.isArray(args) && args.length > 0) {
                message = message.replace("%var%", args.join(" - "));
            } else {
                message = message.replace("%var%", "%var% (not specified)");
            }
        } catch (e) {
            // error de string.replace()

        }

        return message;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (MessagesResources);


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Errors raised by API for one among three reasons : wrong API usage, underlying service error or unknown reason.
 *
 * @property {String} message - Error message
 * @property {Number} status - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} ; -1 otherwise.
 * @property {String} type - Error type ({@link Gp.Error.TYPE_SRVERR}, {@link Gp.Error.TYPE_USEERR} or {@link Gp.Error.TYPE_UNKERR}).
 *
 * @namespace
 * @alias Gp.Error
 * @param {Object|String} error - Options for creating error object. Can be a String (message) or an Object.
 * @param {String} error.message - Error message to return to user.
 * @param {enum} [error.type=TYPE_UNKERR] - Error type
 * @param {status} [error.status=-1] - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}.
 *
 */
function ErrorService (error) {
    if (!(this instanceof ErrorService)) {
        throw new TypeError("ErrorService constructor cannot be called as a function.");
    }

    var e = error;
    if (typeof error === "string" || error instanceof String) {
        this.message = error;
        this.status = -1;
        this.type = ErrorService.TYPE_UNKERR;
    } else {
        this.message = e.message || "undefined!?";
        this.type = e.type;
        this.status = e.status || -1;
    }

    this.name = "ErrorService";
    this.stack = (new Error()).stack;
}

/**
 * Error raised when underlying geoportal service answers on error.
 *
 * @type {String}
 * @constant
 * @static
 */
ErrorService.TYPE_SRVERR = "SERVICE_ERROR";
/**
 * Error raised when funcion use is inappropriate
 *
 * @type {String}
 * @constant
 * @static
 */
ErrorService.TYPE_USEERR = "USAGE_ERROR";
/**
 * Error raised when API can't perform the job for a reason other than the two other ones.
 *
 * @type {String}
 * @constant
 * @static
 */
ErrorService.TYPE_UNKERR = "UNKNOWN_ERROR";

/**
 * @lends module:ErrorService
 */
ErrorService.prototype = Object.create(Error.prototype, {
    constructor : {
        value : ErrorService,
        writable : true,
        configurable : true
    }
});

/* harmony default export */ __webpack_exports__["default"] = (ErrorService);


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony import */ var _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55);
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(66);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67);
var _package_json__WEBPACK_IMPORTED_MODULE_6___namespace = /*#__PURE__*/__webpack_require__.t(67, 1);






// package.json (extract version)


/**
 * @classdesc
 * Composant Service
 *
 * @constructor
 * @alias Gp.Services.CommonService
 * @param {Object} options - options communes à tous les services
 *
 * @param {String} options.apiKey - Clef d'accès à la plateforme Géoportail,
 *      nécessaire pour franchir la couche de contrôle des accès pour avoir une réponse du service invoqué.
 *      Plusieurs clefs peuvent être passées dans le cas de l'invocation du service d'autoconfiguration.
 *      Si ce paramètre n'est pas renseigné, alors le paramètre serverUrl doit être renseigné (comprenant alors, si nécessaire la clef API).
 *
 * @param {String} options.serverUrl - URL d'accès au service.
 *      Permet de forcer l'utilisation d'un service équivalent déployé derrière une éventuelle autre URL d'accès.
 *      Si ce paramètre est renseigné alors, le paramètre apiKey est ignoré.
 *
 * @param {String} [options.protocol] - Le protocole à utiliser pour récupérer les informations du service :
 *      peut valoir 'JSONP' ou 'XHR'.
 *      Par défaut, c'est le protocole XHR qui sera utilisé.
 *      Attention, le protocole JSONP n'est pas valide dans un environnement NodeJS (Utilisation du mode XHR).
 *
 * @param {Boolean} [options.ssl] - Indique si l'on souhaite intérroger les services en https.
 *      Ce paramètre ne fonctionne que pour une utilisation hors navigateur (ex. NodeJS).
 *      Sur un navigateur, le protocole est automatiquement extrait de l'url du site...
 *      Par défaut, on utilise le protocole http (ssl=false).
 *
 * @param {String} [options.proxyURL] - Le proxy à utiliser pour pallier au problème de cross-domain dans le cas d'une requête XHR.
 *      Utile si le paramètre 'protocol' vaut 'XHR', il ne sera pas pris en compte si protocol vaut JSONP.
 *
 * @param {String} [options.callbackSuffix] - Suffixe de la fonction de callback à utiliser, dans le cas du protocole JSONP.
 *      Par défaut, la fonction de callback portera un nom du type "callback"+ID, où ID est soit un identifiant unique généré à chaque requête,
 *      soit le paramètre callbackSuffix s'il est spécifié. Par exemple, si callbackSuffix="_2", la fonction sera "callback_2 ()".
 *      Utile pour utiliser une réponse déjà encapsulée dans une fonction de callback, dont le nom est connu (ex : chargement de l'autoconfiguration en local)
 *      Utile seulement si le paramètre 'protocol' vaut 'JSONP', il ne sera pas pris en compte si protocol vaut 'XHR'.
 *
 * @param {String} [options.httpMethod] - La méthode HTTP
 *      à utiliser dans le cas d'une requête XHR : peut valoir 'GET' ou 'POST'.
 *      Non pris en compte si 'protocol' vaut JSONP qui fonctionne obligatoirement en GET.
 *      Par défaut, c'est la méthode GET qui est utilisée.
 *
 * @param {String} [options.contentType] - Content-Type de la requete
 *      à utiliser dans le cas d'une requête XHR en mode POST.
 *      Non pris en compte si 'protocol' vaut JSONP et/ou la méthode HTTP vaut GET.
 *      Par défaut, c'est la méthode GET qui est utilisée donc on n'utilise pas de Content-Type.
 *
 * @param {Number} [options.timeOut] - Délai d'attente maximal (en ms) de la réponse du service (à partir de l'envoi de la requête).
 *      Par défaut, aucun timeOut n'est pris en compte (timeoutDelay= 0).
 *
 * @param {Boolean} [options.rawResponse] - Indique si l'on souhaite que la réponse du service ne soit pas parsée par l'API avant d'être restituée.
 *      (Cf. paramètre « onSuccess » pour plus de détails).
 *
 * @param {Function} [options.onSuccess] - Fonction appelée lorsque le service répond correctement à la requête
 *      (code HTTP 200, sans message d'erreur).
 *      Cette fonction prend en paramètre la réponse du service,
 *      soit sous la forme d'un Object Javascript formaté par le parseur dédié à la syntaxe du service (comportement par défaut) ;
 *      soit brute au format String non prétraité si le paramètre « rawResponse » a été précisé avec la valeur « true ».
 *
 * @param {Function} [options.onFailure] - Fonction appelée lorsque le service ne répond pas correctement
 *      (code HTTP de retour différent de 200 ou pas de réponse).
 *
 * @param {Function} [options.onBeforeParse] - Fonction appelée avant le parsing de la réponse
 *      Permet de modifier la réponse avant parsing et la fonction doit retourner une String.
 *      Cette fonction prend en paramètre la réponse telle que renvoyée par le service
 *      (cad au format json ou xml).
 *      Pour le JSONP, si le paramètre "rawResponse" a été précisé avec la valeur "true",
 *      la fonction prend en paramètre un Object JavaScript contenant la réponse XML.
 *
 * @example
 *   var options = {
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      ssl : false,
 *      proxyURL : null,
 *      callbackName : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      onBeforeParse : function (rawResponse) {}
 *   };
 * @private
 */
function CommonService (options) {
    if (!(this instanceof CommonService)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("CLASS_CONSTRUCTOR"));
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("CommonService");
    this.logger.trace("[Constructeur CommonService (options)]");

    // #####################
    // récupération des options par défaut pour les paramètres optionnels
    // #####################

    /**
     * Options du service
     * @type {Object}
     */
    this.options = {
        // protocol : "JSONP",
        protocol : "XHR",
        ssl : true,
        proxyURL : "",
        // callbackName : "",
        callbackSuffix : null,
        httpMethod : "GET",
        timeOut : 0,
        rawResponse : false,
        scope : this,
        /**
        * callback par defaut pour la reponse
        * @param {Object} response - response
        * @private
        */
        onSuccess : function (response) {
            console.log("onSuccess - la reponse est la suivante : ", response);
        },
        /**
        * callback par defaut pour les erreurs
        * @param {Object} error - error
        * @private
        */
        onFailure : function (error) {
            if (error.status === 200 || !error.status) {
                console.log("onFailure : ", error.message);
            } else {
                console.log("onFailure - Erreur (", error.status, ") : ", error.message);
            }
        }
    };

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            this.options[opt] = options[opt];
        }
    }

    // #####################
    // analyse des options
    // #####################

    // gestion des clefs API
    if (!this.options.apiKey && !this.options.serverUrl) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_MISSING", "apiKey", "serverUrl"));
    }

    // modification de la fonction de callback onSuccess dans le cas où la réponse brute est demandée
    if (this.options.rawResponse && !this.options.onSuccess) {
        /**
        * callback par defaut pour la reponse
        * @param {Object} response - response
        * @private
        */
        this.options.onSuccess = function (response) {
            console.log("onSuccess - la réponse brute du service est la suivante : ", response);
        };
    }

    // gestion du callback onSuccess
    var bOnSuccess = !!(this.options.onSuccess !== null && typeof this.options.onSuccess === "function");
    if (!bOnSuccess) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_MISSING", "onSuccess()"));
    }

    // gestion de l'url du service par defaut
    if (!this.options.serverUrl) {
        // INFO
        // gestion de l'url du service par defaut pour les services qui ne possèdent qu'une seul url par defaut
        // les cas particuliers des services avec plusieurs urls (ex. Alti) devront être traité dans la classe du composant
        // donc si l'url n'est pas renseignée, il faut utiliser les urls par defaut
        _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__["default"].ssl = this.options.ssl;
        var urlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__["default"][this.CLASSNAME].url(this.options.apiKey);
        if (typeof urlByDefault === "string") {
            this.options.serverUrl = urlByDefault;
        } else {
            this.logger.trace("URL par defaut à determiner au niveau du composant...");
        }
    }

    // FIXME nettoyage des KVP dans l'url du service
    // if (this.options.serverUrl) {
    //     // INFO
    //     // si l'url est renseignée, il faut la nettoyer de tous ses KVP
    //     // ex. on ne veut pas de params. 'callback' ou 'output' car ceci declencherait
    //     // des opérations d'encapsulations des reponses légèrement farfelues ...
    //     var urlsource = this.options.serverUrl;
    //     var urlparts = urlsource.split("?");
    //     this.options.serverUrl = urlparts[0];
    // }

    // gestion de la methode HTTP
    this.options.httpMethod = (typeof options.httpMethod === "string") ? options.httpMethod.toUpperCase() : "GET";

    switch (this.options.httpMethod) {
        case "POST":
        case "GET":
            break;
        case "PUT":
        case "DELETE":
        case "HEAD":
        case "OPTIONS":
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_NOT_SUPPORT", "httpMethod"));
        default:
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_UNKNOWN", "httpMethod"));
    }

    // gestion du protocole
    // this.options.protocol = (typeof options.protocol === "string" ) ? options.protocol.toUpperCase() : "JSONP";
    this.options.protocol = (typeof options.protocol === "string") ? options.protocol.toUpperCase() : "XHR";

    switch (this.options.protocol) {
        case "JSONP":
        case "XHR":
            break;
        default:
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_UNKNOWN", "protocol"));
    }

    // on determine l'environnement d'execution : browser ou non ?
    // et on lance une exception sur l'utilisation du protocole JSONP pour nodeJS...
    if (typeof window === "undefined" && this.options.protocol === "JSONP") {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_NOT_SUPPORT_NODEJS", "protocol=JSONP (instead use XHR)"));
    }

    // le protocole JSONP ne fonctionne qu'en GET.
    if (this.options.protocol === "JSONP") {
        this.options.httpMethod = "GET";
    }

    // gestion du cache
    this.options.nocache = options.nocache || false;

    // #####################
    // attributs d'instances
    // #####################

    /**
     * Format de réponse du service
     */
    this.options.outputFormat = null;
    /**
     * Requête envoyée au service
     */
    this.request = null;
    /**
     * Reponse du service
     */
    this.response = null;
}

/**
 * @lends module:CommonService
 */
CommonService.prototype = {

    /*
     * Constructeur (alias)
     */
    constructor : CommonService,

    /**
     * Appel du service Géoportail
     */
    call : function () {
        /* jshint validthis : true */
        this.logger.trace("CommonService::call ()");

        var context = this;
        /** fonction d'execution */
        function run () {
            this.logger.trace("CommonService::run ()");
            this.buildRequest.call(context, onError, onBuildRequest);
        }

        run.call(context);

        // callback de fin de construction de la requête
        function onBuildRequest (result) {
            this.logger.trace("CommonService::onBuildRequest : ", result);
            this.callService.call(context, onError, onCallService);
        }

        // callback de fin d'appel au service
        function onCallService (result) {
            this.logger.trace("CommonService::onCallService : ", result);
            this.analyzeResponse.call(context, onError, onAnalyzeResponse);
        }

        // callback de fin de lecture de la reponse
        function onAnalyzeResponse (result) {
            this.logger.trace("CommonService::onAnalyzeResponse : ", result);
            if (result) {
                this.options.onSuccess.call(this, result);
            } else {
                return onError.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]("Analyse de la reponse en échec !?"));
            }
        }

        // callback de gestion des erreurs : renvoit un objet de type ErrorService
        function onError (error) {
            this.logger.trace("CommonService::onError()");
            // error : l'objet est du type ErrorService ou Error
            var e = error;
            if (!(e instanceof _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"])) {
                e = new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"](error.message);
            }
            this.options.onFailure.call(this, e);
        }
    },

    /**
     * Création de la requête
     * @param {Function} error - callback
     * @param {Function} success - callback
     */
    buildRequest : function (error, success) {
        // INFO
        this.logger.error("overwritten method !");
        // retourne l'objet 'this.request'
        if (error) {
            error.call(this, "This method must be overwritten !");
        }
        success.call(this, "This method must be overwritten !");
    },

    /**
     * Appel du service
     * @param {Function} error - callback
     * @param {Function} success - callback
     */
    callService : function (error, success) {
        // INFO
        // retourne l'objet 'this.response'

        // NOTES
        //  Pour le mode XHR, on recupère une reponse sous forme d'un json ou xml (#document).
        //  Pour le mode JSONP, on a toujours un objet JSON mais sous 2 formes :
        //      - natif
        //      - XML encapsulé :
        //          {http : {status:200, error:null},xml :'réponse du service'}
        //          {http : {status:400, error:'reponse du service'},xml :null}
        //  En XHR, la reponse est directement sauvegardée dans 'this.response'.
        //  Par contre, en JSONP, on doit analyser la reponse (status ou non vide),
        //  et ne renvoyer que le contenu (xml ou l'objet)

        // gestion de la proxification du service
        var strUrlProxified = null;
        var strData = this.request;

        // a t on mis en place un proxy ?
        // la proxyfication est valable uniquement en mode XHR !
        var bUrlProxified = !!(this.options.proxyURL && this.options.protocol === "XHR");

        // rajout de l'option gpbibaccess
        // INFO : acces au numero de version de package.conf aprés compilation !
        this.options.serverUrl = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(this.options.serverUrl, {
            "gp-access-lib" : _package_json__WEBPACK_IMPORTED_MODULE_6__.version
        }, false);

        // si le proxy est renseigné, on proxifie l'url du service
        if (bUrlProxified) {
            if (this.options.httpMethod === "GET") {
                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(this.options.serverUrl, this.request, true);
                strData = null;
            }

            if (this.options.httpMethod === "POST") {
                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(this.options.serverUrl, null, true);
                strData = this.request;
            }
        }

        // contexte du composant spécifique !
        var self = this;

        var options = {
            url : strUrlProxified || this.options.serverUrl,
            method : this.options.httpMethod,
            protocol : this.options.protocol,
            timeOut : this.options.timeOut || 0,
            format : this.options.outputFormat, // ceci declenche le parsing de la reponse du service, mais on souhaite toujours une reponse brute (string) !
            nocache : this.options.nocache || false, // ceci permet d'ajouter un timestamp dans la requête
            wrap : this.options.protocol !== "XHR", // ceci declenche l'encapsulation de la reponse XML du service dans du JSON, mais pas en mode XHR !
            callbackSuffix : this.options.callbackSuffix,
            // callbackName : this.options.callbackName || null,
            data : strData,
            headers : null, // TODO...
            content : this.options.contentType || "application/xml",
            scope : this.options.scope || this,
            // callback de reponse
            onResponse : function (response) {
                self.logger.trace("callService::onResponse()");

                // le contenu de la reponse à renvoyer !
                var content = null;

                // XHR : on renvoie toujours la reponse brute du service (json ou xml)
                // au parser du composant...
                if (self.options.protocol === "XHR") {
                    self.logger.trace("Response XHR", response);
                    content = response; // par defaut, la reponse du service  !
                }

                // JSONP : on pre-analyse la reponse brute du service (encapsuler ou pas)
                // avant de l'envoyer au parser du composant...
                if (self.options.protocol === "JSONP") {
                    self.logger.trace("Response JSON", response);
                    if (response) {
                        if (response.http) {
                            // reponse encapsulée :
                            // ex. reponse du service en xml
                            // > {http : {status:200, error:null},xml :'réponse du service'}
                            if (response.http.status !== 200) {
                                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]({
                                    status : response.http.status,
                                    message : response.http.error,
                                    type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"].TYPE_SRVERR
                                }));
                                return;
                            } else {
                                content = response.xml; // par defaut !
                                if (self.options.rawResponse) {
                                    content = response;
                                }
                            }
                        } else {
                            // reponse non encapsulée :
                            // ex. reponse du service en json ou xml
                            content = response;
                        }
                    } else {
                        error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]("Le contenu de la reponse est vide !?"));
                        return;
                    }
                }

                // si on souhaite parser la reponse du service
                if (typeof self.options.onBeforeParse === "function") {
                    var newResponse = self.options.onBeforeParse(content);
                    if (typeof newResponse === "string") {
                        // la reponse parsée par l'utilisateur est retournée sous
                        // forme de string !
                        content = newResponse;
                    }
                }
                // sauvegarde de la reponse dans l'objet parent (CommonService)
                self.response = content;
                // on renvoie la reponse...
                success.call(self, content);
            },
            // callback des erreurs
            onFailure : function (e) {
                self.logger.trace("callService::onFailure()");
                // on est forcement sur une erreur levée par un service !
                e.type = _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"].TYPE_SRVERR;
                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"](e));
            },
            // callback de timeOut
            onTimeOut : function () {
                self.logger.trace("callService::onTimeOut()");
                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]("TimeOut!"));
            }
        };

        _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__["default"].send(options);
    },

    /**
     * Analyse de la réponse
     * @param {Function} error - callback
     * @param {Function} success - callback
     */
    analyzeResponse : function (error, success) {
        // INFO
        this.logger.error("overwritten method !");
        // retourne l'objet spécifique au type de composant (json)
        if (error) {
            error.call(this, "This method must be overwritten !");
        }
        success.call(this, "This method must be overwritten !");
    }

};

/* harmony default export */ __webpack_exports__["default"] = (CommonService);


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Classe utilitaire
 *
 * @module Helper
 * @alias Gp.Helper
 */
var Helper = {

    /**
     * concatenation des parametres key/value dans les urls
     *
     * @method normalyzeParameters
     * @static
     * @param {Object} params - tableau de clef/valeur
     *
     * @example
     *  Gp.Utils.Helper.normalyzeParameters ({
     *         key1:value1,
     *         key2:value2,
     *         key3:value3
     *  });
     *  // out : "key1=value1&key2=value2&key3=value3"
     *
     * @returns {String} retourne les paramètres concaténés
     */
    normalyzeParameters : function (params) {
        var myParams = null;

        if (params) {
            var tabParams = [];
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    var value = params[key];
                    if (!value) {
                        value = "";
                    }
                    tabParams.push(key + "=" + value);
                }
            }

            myParams = tabParams.join("&");
        }

        return myParams;
    },

    /**
     * Concaténation et encodage des urls.
     *
     * @method normalyzeUrl
     * @static
     * @param {String} url - url
     * @param {Object|String} params - tableau de clef/valeur ou string
     * @param {Boolean} encode - true|false, false par defaut
     *
     * @example
     *  Gp.Utils.Helper.normalyzeUrl (url, {
     *         key1:value1,
     *         key2=:value2,
     *         key3:value3
     *  });
     *  // out : "url?key1=value1&key2=value2&key3=value3"
     *
     * @returns {String} retourne une url normalisée
     */
    normalyzeUrl : function (url, params, encode) {
        var myUrl = url;

        if (url) {
            var k = url.indexOf("?");
            if (k === -1) { // pas de ? et KVP
                myUrl += "?";
            }

            if (k !== -1 && k !== url.length - 1) { // KVP
                myUrl += "&";
            }
        }

        if (params) {
            if (typeof params === "string") {
                myUrl += params;
            } else {
                myUrl += this.normalyzeParameters(params);
            }
        }

        if (encode) {
            // FIXME bonne idée ?
            myUrl = encodeURIComponent(myUrl);
        }

        return myUrl;
    },

    /**
     * Indentation d'une chaine
     *
     * @method indent
     * @static
     * @param {Number} n - nombre de tabulation
     * @param {String} msg - chaine
     *
     * @example
     * Gp.Utils.Helper.indent (2, "message à indenter")
     * // out
     * // ........message à indenter
     *
     * @returns {String} retourne une chaine indentée
     */
    indent : function (n, msg) {
        var num = n || 0;
        return new Array(num + 1).join("\t") + msg;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (Helper);


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/* harmony import */ var _XHR__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _JSONP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);
/**
 * Interface de dialogue avec les webservices
 *
 * @module Protocols
 * @private
 * @alias Gp.Protocols
 */




var Protocol = {

    /**
     * Interface unique d"envoi d"une requête.
     *
     * @method send
     * @static
     * @param {Object} options - options generales
     * @param {String} options.url      - url du service
     * @param {String} options.method   - GET, POST, PUT, DELETE
     * @param {String} options.protocol - XHR | JSONP
     * @param {String} options.format   - format de la reponse du service : json, xml ou null (brute)...
     * @param {String} options.wrap     - encapsuler la reponse du service dans du JSON : true|false (true par defaut sur le protocole JSONP)
     * @param {String} options.callbackSuffix - suffixe de la fonction de callback (JSONP uniquement) (ex: si callbackSuffix="", la fonction s'appellera "callback")
     * @param {String} options.timeOut  - 0 ms
     * @param {Boolean} options.nocache  - true|false
     * @param {Object|String} options.data        - content (post) ou param (get)
     * @param {Object|String} options.headers     - (post) ex. referer
     * @param {Object|String} options.content - (post) ex. "application/json"
     * @param {String} options.scope       - this (TODO)
     * @param {Function} options.onResponse - callback
     * @param {Function} options.onFailure - callback
     * @param {Function} options.onTimeOut - callback
     * @param {String} options.proxyUrl -  (TODO)
     */
    send : function (options) {
        // INFO
        // "output" - param est interne à la classe "Protocol" (parametrable via "wrap"), et à ajouter à l"url
        //      ce param est independant du service car il est géré par le filtre LUA :
        //          ex. json|xml (json par defaut).
        //          Ce param. permet d"encapsuler du XML dans du JSON :
        //              {http : {status:200, error:null},xml :"réponse du service"}
        //          Utile pour les services qui ne repondent que du XML (ex. Geocodage)
        //
        // |-------------------------------------------------|
        // |      \service |      |     |                    |
        // | output\ format| json | xml |     remarques      |
        // |--------\------|------|-----|--------------------|
        // |    json       | json | json| json/xml encapsulé |
        // |    xml        | json | xml | param inactif      |
        // |-------------------------------------------------|
        // ex. le service demande une reponse native au "format" json et avec un "output" json.
        // on a donc une reponse json encapsulé dans un json : ce qu'on ne souhaite pas !
        // dans ce cas on ne renseigne pas output=json

        // INFO
        // "wrap" - choix d"encapsuler ou non les reponses dans du JSON.
        //      Par defaut, on encapsule uniquement les reponses sur le protocole JSONP (et qui sont en xml) !

        // INFO
        // "callback" - param est interne à la classe "Protocol" (non parametrable), et à ajouter à l"url
        //      ce param est independant du service car il est géré aussi par le filtre LUA :
        //          ex. callback|null
        //          Ce param. permet de renvoyer une reponse javascript :
        //              callback ({http : {status:200, error:null},xml :"réponse du service"})
        //          Ce param. est non renseigné par defaut car pour du JSONP, on utilise le
        //          le protocol JSONP, et ce dernier implemente déjà le callback !

        // settings par defaut
        var settings = options || {
            method : "GET",
            // protocol : "JSONP",
            protocol : "XHR",
            timeOut : 0,
            format : null,
            wrap : true,
            nocache : true,
            output : "json",
            callback : null,
            callbackSuffix : null
        };

        // on determine l'environnement d'execution : browser ou non ?
        // et on stoppe pour nodeJS... sur un protocole JSONP !
        if (typeof window === "undefined" && options.protocol === "JSONP") {
            console.log("Value (s) for parameter (s) 'protocol=JSONP (instead use XHR)' not supported to NodeJS");
            return;
        }

        if (options.protocol === "XHR" || options.format === "json") {
            settings.wrap = false;
        } else if (options.protocol === "JSONP" && options.format === "xml") {
            settings.wrap = true;
        }

        settings.callback = null; // FIXME non géré !?
        settings.output = settings.wrap ? "json" : null;

        // on encapsule les reponses dans un objet JSON
        if (settings.wrap) {
            var params = {};
            params.output = settings.output;
            params.callback = settings.callback;
            delete params.callback; // FIXME non géré !?
            settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__["default"].normalyzeUrl(options.url, params);
        }

        // choix de l"implementation :
        // XHR ou JSONP
        switch (settings.protocol) {
            case "XHR":
                // on normalise l'url (gestion du cache)
                if (options.method === "GET" && options.nocache) {
                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__["default"].normalyzeUrl(settings.url, {
                        t : new Date().getTime()
                    });
                }
                // appel du service en XHR
                _XHR__WEBPACK_IMPORTED_MODULE_1__["default"].call(settings);
                break;
            case "JSONP":

                // on normalise l'url si les params. sont renseignés dans la string|object "data"
                if (settings.data) {
                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__["default"].normalyzeUrl(settings.url, settings.data);
                }

                // appel du service en JSONP
                _JSONP__WEBPACK_IMPORTED_MODULE_2__["default"].call(settings);
                break;
            default:
                throw new Error("protocol not supported (XHR|JSONP) !");
        }
    }

};

/* harmony default export */ __webpack_exports__["default"] = (Protocol);


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);
/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(es6_promise__WEBPACK_IMPORTED_MODULE_2__);
/* global Promise, require, XDomainRequest */




// import __request from "request";
// import __xmldom from "xmldom";

/**
 * Ajax Request (use of Promises)
 *
 * @module XHR
 * @alias Gp.Protocols.XHR
 * @see dependance 'es6-promise'
 */

// cf. https://xhr.spec.whatwg.org/
// cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest

var XHR = {

    /**
     * Interface unique d'envoi d'une requête.
     *
     * @method call
     * @static
     * @param {Object} settings - options generales
     * @param {String} settings.url    - url du service
     * @param {String} settings.method - GET, POST, PUT, DELETE
     * @param {String} settings.format - format de la reponse du service : json, xml ou null (brute)
     * @param {String} settings.data   - content (post) ou param (get)
     * @param {String} settings.proxy  - proxy url
     * @param {Object|String} settings.headers - (post) ex. referer
     * @param {Object|String} settings.content - (post) ex. 'application/json'
     * @param {String} settings.timeOut - timeout = 0 par defaut
     * @param {String} settings.scope - this
     * @param {Function} settings.onResponse - callback
     * @param {Function} settings.onFailure  - callback
     */
    call : function (settings) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("XHR");
        logger.trace("[XHR::call()]");

        // FIXME
        // To polyfill the global environment
        es6_promise__WEBPACK_IMPORTED_MODULE_2___default.a.polyfill();

        // test sur les settings obligatoires
        if (!settings.url) {
            throw new Error("missing parameter : url is not defined !");
        }

        if (!settings.method) {
            throw new Error("missing parameter : method is not defined !");
        }

        if (!settings.format) {
            settings.format = "text"; // reponse brute !
        }

        var options = {};
        options.url = settings.url;
        options.data = settings.data ? settings.data : null;
        options.method = settings.method;
        options.timeOut = settings.timeOut || 0;
        options.scope = settings.scope || this;
        options.proxy = settings.proxy || null;
        options.content = settings.content || null;
        options.headers = settings.headers || {
            referer : "http://localhost"
        };

        // test sur les valeurs de 'settings.method'
        switch (settings.method) {
            case "DELETE":
            case "GET":
                break;
            case "PUT":
            case "POST":
                // on force sur ces params spécifiques au mode POST
                options.content = settings.content ? settings.content : "application/x-www-form-urlencoded"; // FIXME en attente des services : bascule en "application/xml" ou "application/json"
                options.headers = settings.headers ? settings.headers : { referer : "http://localhost" }; // FIXME parametrable...
                break;
            case "HEAD":
            case "OPTIONS":
                throw new Error("HTTP method not yet supported !");
            default:
                throw new Error("HTTP method unknown !");
        }

        // test sur les valeurs de 'settings.format'
        switch (settings.format) {
            case "text":
                this.__call(options)
                    .then(function (response) {
                        logger.trace(response);
                        settings.onResponse.call(this, response);
                    })
                    .catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                break;
            case "json":
                this.__callJSON(options)
                    .then(function (response) {
                        logger.trace(response);
                        settings.onResponse.call(this, response);
                    })
                    .catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                break;
            case "xml":
                this.__callXML(options)
                    .then(function (response) {
                        logger.trace(response);
                        settings.onResponse.call(this, response);
                    })
                    .catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                break;
            default:
                throw new Error("This output Format is not yet supported !");
        }
    },

    /**
     * Requete
     *
     * @method __call
     * @private
     * @param  {Object} options - options
     * @return {Object} promise
     */
    __call : function (options) {
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("XHR");
        logger.trace("[XHR::__call()]");

        var promise = new Promise(
            function (resolve, reject) {
                // traitement du corps de la requête
                var corps = (options.method === "POST" || options.method === "PUT") ? 1 : 0;

                // seulement si options.data n'est pas vide (peut être un objet ou une chaine de caractères)
                if (options.data && ((typeof options.data === "object" && Object.keys(options.data).length) || (typeof options.data === "string" && options.data.length)) && !corps) {
                    options.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(options.url, options.data);
                }

                logger.trace("URL = ", options.url);

                var hXHR = null;

                // test on env. nodejs or browser
                if (typeof window === "undefined") {
                    var nodefetch = __webpack_require__(63);

                    var opts = {
                        headers : {
                            Referer : "https://localhost"
                        }
                    };

                    if (options.data && typeof options.data === "string" && corps) {
                        opts = {
                            method : options.method,
                            body : options.data,
                            headers : {
                                "Content-Type" : options.content,
                                Referer : "https://localhost"
                            }
                        };
                    }

                    return nodefetch(options.url, opts)
                        .then(function (response) {
                            if (response.ok) { // res.status >= 200 && res.status < 300
                                resolve(response.text());
                            } else {
                                var message = "Errors Occured on Http Request (status : '" + response.statusText + "' | url : '" + response.url + "')";
                                var status = response.status;
                                reject({
                                    message : message,
                                    status : status
                                });
                            }
                        })
                        .catch(function (e) {
                            reject({
                                message : e,
                                status : -1
                            });
                        });
                } else {
                    if (window.XMLHttpRequest) {
                        logger.trace("XMLHttpRequest");

                        hXHR = new XMLHttpRequest();
                        hXHR.open(options.method, options.url, true); // async
                        hXHR.overrideMimeType = options.content;

                        // gestion du timeout
                        var onTimeOutTrigger = null;
                        if (options.timeOut > 0) {
                            // FIXME le timeout interne ne me permet pas de declencher le bon message...
                            // hXHR.timeout = options.timeOut;
                            logger.trace("XHR - TimeOut actif !");
                            /**
                             * Description
                             *
                             * @method onTimeOutTrigger
                             * @private
                             */
                            onTimeOutTrigger = window.setTimeout(
                                function () {
                                    var message = "TimeOut Occured on Http Request with XMLHttpRequest !";
                                    reject({
                                        message : message,
                                        status : -1
                                    });
                                }, options.timeOut);
                        }

                        if (corps) {
                            // headers, data, content of data
                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader
                            logger.trace("data = ", options.data);
                            hXHR.setRequestHeader("Content-type", options.content);
                            // FIXME refused to set unsafe header content-length javascript
                            // hXHR.setRequestHeader ("Content-length", options.data.length);
                            // hXHR.setRequestHeader ("Referer", options.headers.referer);
                        }

                        /**
                         * On Error
                         * FIXME ne se declenche pas !?
                         *
                         * @param {Object} e - Event
                         * @method onerror
                         * @private
                         */
                        hXHR.onerror = function (e) {
                            console.log(e);
                            reject(new Error("Errors Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * On Timeout
                         * FIXME ne se declenche pas !?
                         *
                         * @param {Object} e - Event
                         * @method ontimeout
                         * @private
                         */
                        hXHR.ontimeout = function (e) {
                            console.log(e);
                            reject(new Error("TimeOut Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * Description
                         *
                         * @method onreadystatechange
                         * @private
                         */
                        hXHR.onreadystatechange = function (e) {
                            if (hXHR.readyState === 4) { // DONE
                                if (hXHR.status === 200) {
                                    window.clearTimeout(onTimeOutTrigger);
                                    resolve(hXHR.response);
                                } else {
                                    var message = "Errors Occured on Http Request (status : '" + e.target.statusText + "' | url : '" + e.target.responseURL + "')";
                                    var status = e.target.status;
                                    reject({
                                        message : message,
                                        status : status
                                    });
                                }
                            }
                        };

                        // gestion du content data
                        var data4xhr = (options.data && corps) ? options.data : null;

                        hXHR.send(data4xhr);
                    } else if (window.XDomainRequest) {
                        // worked in Internet Explorer 8–10 only !
                        logger.trace("XDomainRequest");

                        hXHR = new XDomainRequest();
                        hXHR.open(options.method, options.url);

                        hXHR.overrideMimeType = options.content;

                        if (options.timeOut > 0) {
                            hXHR.timeout = options.timeout;
                            logger.trace("XHR - TimeOut actif !");
                        }

                        if (corps) {
                            // headers, data, content of data
                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader
                            hXHR.setRequestHeader("Content-type", options.content);
                            // FIXME refused to set unsafe header content-length javascript
                            // hXHR.setRequestHeader ("Content-length", options.data.length);
                            // hXHR.setRequestHeader ("Referer", options.headers.referer);
                        }

                        /**
                         * Description
                         *
                         * @method onerror
                         * @private
                         */
                        hXHR.onerror = function () {
                            reject(new Error("Errors Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * Description
                         *
                         * @method ontimeout
                         * @private
                         */
                        hXHR.ontimeout = function () {
                            reject(new Error("TimeOut Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * On Load
                         *
                         * @method onload
                         * @private
                         */
                        hXHR.onload = function (e) {
                            if (hXHR.status === 200) {
                                resolve(hXHR.responseText);
                            } else {
                                var message = "Errors Occured on Http Request (status : '" + e.target.statusText + "' | url : '" + e.target.responseURL + "')";
                                var status = e.target.status;
                                reject({
                                    message : message,
                                    status : status
                                });
                            }
                        };

                        var data4xdr = (options.data && corps) ? options.data : null;

                        hXHR.send(data4xdr);
                    } else {
                        throw new Error("CORS not supported");
                    }
                }
            }
        );

        return promise;
    },

    /**
     * Requete avec parser JSON
     *
     * @method __callJSON
     * @private
     * @param  {Object} options - options
     * @return {Object} promise
     */
    __callJSON : function (options) {
        return this.__call(options)
            .then(JSON.parse)
            .catch(function (error) {
                console.log("_callJSON failed on : ", options.url, error);
                // FIXME pas d'exception, laissons le fil se derouler...
                // throw error;
            });
    },

    /**
     * Requete avec parser XML
     *
     * @method __callXML
     * @private
     * @param  {Object} options - options
     * @return {Object} promise
     */
    __callXML : function (options) {
        return this.__call(options)
            .then(function (response) {
                var xmlDoc;

                // test on env. nodejs or browser
                if (typeof window === "undefined") {
                    var DOMParser = __webpack_require__(64).DOMParser; // __xmldom.DOMParser
                    xmlDoc = new DOMParser().parseFromString(response, "text/xml");
                } else {
                    if (window.DOMParser) {
                        var parser = new window.DOMParser();
                        xmlDoc = parser.parseFromString(response, "text/xml");
                    } else { // IE
                        xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                        xmlDoc.async = false;
                        xmlDoc.loadXML(response);
                    }
                }

                return xmlDoc;
            })
            .catch(function (error) {
                console.log("__callXML failed on : ", options.url, error);
                // FIXME pas d'exception, laissons le fil se derouler...
                // throw error;
            });
    }

};

/* harmony default export */ __webpack_exports__["default"] = (XHR);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(61), __webpack_require__(62)))

/***/ }),
/* 61 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 62 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = undefined;

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = undefined;

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/**
 * JSONP : Implémentation du protocole JSONP de la plateforme Géoportail
 *
 * @module JSONP
 * @private
 * @alias Gp.Protocols.JSONP
 */


// cf. https://github.com/sobstel/jsonp.js
var JSONP = {

    /**
     * Construction d'un identifiant statique basé sur le timestamp,
     * et qui s'incremente de +1 à chaque appel
     */
    uuid : (function () {
        var id = Math.floor(Date.now());
        return function () {
            return id++;
        };
    })(),

    /**
     * Cette fonction réalise l'appel du service fourni via le paramètre "options.url"
     * en mettant en œuvre le protocole JSONP.
     *
     * @method call
     * @static
     * @param {Object} options - parametres d'invocation du service en JSONP
     * @param {String} options.url - URL du service à invoquer (indépendamment du protocole JSONP).
     *  Cette URL contient déjà les paramètres du service.
     *  Si le paramètre dédié à la mise en oeuvre du protocole JSONP (callback=xxx) n'est pas présent, il est rajouté par la fonction ;
     *  sa valeur est déterminée en fonction du paramètre callbackName.
     * @param {Number} [options.timeOut = 0] - Nombre de ms au bout duquel on considère que le service n'a pas répondu.
     *  Une valeur de 0 pour ce paramètre permet de désactiver la gestion du timeOut.
     * @param {String} [options.callbackSuffix = null] - Suffixe de la fonction de callback à rajouter sur l'URL.
     *  Si aucun suffixe n'est spécifié (cas par défaut), on utilisera l'identifiant this.uuid () comme suffixe. Ex: "callback1458574396582 ()"
     * @param {String} [options.callbackName = gp.protocol.jsonp] - Valeur du paramètre callback à rajouter sur l'URL.
     *  Si l'URL fournie contient déjà le paramètre callback, le paramètre callbackName ne sera pas pris en compte.
     *  La fonction de callback est créée dynamiquement par la fonction JSONP ;
     *  elle a deux fonctions :
     *    elle annule la condition de timeOut
     *    puis appelle la fonction fournie par l'utilisateur via le paramètre onResponse.
     * @param {Function} options.onResponse - Nom de la fonction qui sera appelée lors de la réception des résultats du service.
     *  Ce paramètre sera ignoré si l'URL contient déjà le paramètre callback.
     *  La fonction de rappel appelée sera alors celle ayant pour nom la valeur de ce paramètre.
     * @param {Function} [options.onTimeOut] - Nom de la fonction qui sera appelée en cas de non réponse du service.
     *  Le temps au bout duquel on considère que le service n'a pas répondu est déterminé par le paramètre timeOut.
     *  @example
     *  var options = {
     *      url : 'http://localhost/some/test.json&callback=myResults',
     *      timeOut : 100,
     *      callbackName : 'myResults',
     *      callbackSuffix : "",
     *      onResponse : function (response) {
     *          console.log('results : ', response);
     *      },
     *
     *   };
     *   JSONP.call(options);
     */
    call : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("JSONP");
        logger.trace("[JSONP::call ()]");

        // analyse parametres

        if (!options) {
            logger.error("missing parameter : options !");
            throw new Error("missing parameter : options !");
        }

        if (!options.url) {
            logger.error("missing parameter : options.url !");
            throw new Error("missing parameter : options.url !");
        }

        if (!options.timeOut) {
            logger.info("setting 'options.timeOut' default value");
            options.timeOut = 0;
        }

        // FIXME si un callback coté client a été mis en place,
        // cette condition sur cette methode n'a pas de sens !?
        if (!options.onResponse) {
            logger.error("missing parameter : options.onResponse !");
            throw new Error("missing parameter : options.onResponse !");
            // FIXME doit on definir un callback interne par defaut !?
            // options.onResponse = function (data) {
            //    console.log("response callback (inner) : ", data);
            // };
        }

        // ID du callback à utiliser : null ou string.
        // si l'utilisateur a spécifié un suffixe pour le callback, on le récupère comme un ID (ex: options.callbackSuffix = "")
        // sinon, on utilise un timestamp : this.uuid ()
        var callbackId = (typeof options.callbackSuffix === "string") ? options.callbackSuffix : this.uuid();

        // on recherche le parametre callback et son nom de fonction dans l'url
        var urlHasCallbackKey = false;
        var urlHasCallbackName = false;

        var idx = options.url.indexOf("callback=");

        if (idx !== -1) {
            urlHasCallbackKey = true;
            // extraction callbackName de l'url : entre "callback=" et "&" ou fin de ligne
            var j = options.url.indexOf("&", idx);
            if (j === -1) {
                j = options.url.length;
            }

            // on ecrase le parametre options.callbackName s'il avait été défini
            var callbackName = options.url.substring(idx + 9, j);

            if (callbackName) {
                urlHasCallbackName = true;
                options.callbackName = callbackName;
                logger.info("setting 'options.callbackName' value (" + options.callbackName + ") from 'options.url' parameter");
            }
        }

        // on ajoute le parametre callback dans l'URL s'il n'existe pas
        if (!urlHasCallbackKey) {
            // gestion des autres param. et "?"
            var k = options.url.indexOf("?");
            if (k === -1) {
                // aucun param., ni de '?'
                options.url = options.url + "?" + "callback=";
            } else if (k === options.url.length) {
                // uniquement le '?'
                options.url = options.url + "callback=";
            } else {
                // le '?' et les param. existent
                options.url = options.url + "&" + "callback=";
            }
            logger.info("setting callback default key in 'options.url' : " + options.url);
        }

        // utilisation de la fonction callback coté client ?
        var HasCallbackName = options.callbackName ? true : urlHasCallbackName;

        // on ajoute le nom de la fonction callback dans l'URL si elle n'existe pas
        if (!urlHasCallbackName) {
            // fonction callback par defaut
            if (!options.callbackName) {
                logger.info("setting 'options.callbackName' default value");
                options.callbackName = "callback"; // ou "gp.protocol.jsonp" ?
                // info : si on ne veut pas gerer d'ID dans le callback,
                // options.callbackSuffix = ""
                if (callbackId || callbackId === "") {
                    options.callbackName += callbackId;
                }
            }
            options.url = options.url.replace("callback=", "callback=" + options.callbackName);
            logger.info("setting callback function name in 'options.url' : " + options.url);
        }

        // timeOut par defaut
        if (!options.onTimeOut) {
            logger.info("setting 'options.onTimeOut' default value");
            /** callback timeout par defaut */
            options.onTimeOut = function (/* error */) {
                console.log("TimeOut while invoking url : " + options.url);
            };
        }

        if (!HasCallbackName) {
            var self = this;

            // event du timeout
            var onTimeOutTrigger = null;

            // declenche le timeout si > à 0 !
            if (options.timeOut > 0) {
                onTimeOutTrigger = window.setTimeout(
                    function () {
                        /** fonction de reponse du service */
                        window[options.callbackName] = function () {};
                        options.onTimeOut();
                        self._deleteScript(callbackId);
                    }, options.timeOut);
            }

            // FIXME le nom de la fonction n'accepte pas de namespace !
            // ex. Gp.Function.callback
            /**
            * fonction de reponse du service
            * @param {Object} data - data
            * @private
            */
            window[options.callbackName] = function (data) {
                window.clearTimeout(onTimeOutTrigger);
                options.onResponse(data);
                self._deleteScript(callbackId);
            };
        }

        this._createScript(callbackId, options.url);
    },

    /**
    * create Script
    * @param {String} callbackId - callback Id
    * @param {String} url - url
    * @private
    */
    _createScript : function (callbackId, url) {
        var scriptu;
        var scripto = document.getElementById("results" + callbackId);

        scriptu = document.createElement("script");
        scriptu.setAttribute("type", "text/javascript");
        scriptu.setAttribute("src", url);
        scriptu.setAttribute("charset", "UTF-8");
        scriptu.setAttribute("id", "results" + callbackId);
        scriptu.setAttribute("async", "true"); // FIXME async ?
        // head ou body ou autres ?
        var node = document.documentElement || document.getElementsByTagName("head")[0];
        if (scripto === null) {
            node.appendChild(scriptu);
        } else {
            // s'il existe déjà, on le remplace !
            node.replaceChild(scriptu, scripto);
        }
    },

    /**
    * delete Script
    * @param {String} callbackId - callback Id
    * @private
    */
    _deleteScript : function (callbackId) {
        var script = document.getElementById("results" + callbackId);
        if (script) {
            var node = script.parentNode || document.documentElement;
            if (!node) {
                return;
            }
            node.removeChild(script);
        }
    }
};

/* harmony default export */ __webpack_exports__["default"] = (JSONP);


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// cette classe contient les URLs par defaut des services.
//  DefaultUrlService.Alti.url(key)[elevation-json]
//  DefaultUrlService.Alti.url(key)[elevation-xml]
//  DefaultUrlService.Alti.url(key)[profil-json]
//  DefaultUrlService.Alti.url(key)[profil-xml]
//  DefaultUrlService.Alti.url(key)[wps]
//  DefaultUrlService.ProcessIsoCurve.url(key)
//  DefaultUrlService.AutoComplete.url(key)
//  DefaultUrlService.ReverseGeocode.url(key)
//  DefaultUrlService.AutoConf.url(key)[apiKey]
//  DefaultUrlService.AutoConf.url(key)[apiKeys]
//  DefaultUrlService.AutoConf.url(key)[aggregate]
//  DefaultUrlService.Geocode.url(key)
//  DefaultUrlService.Route.url(key)

// Example :
//
// DefaultUrlService.Alti.url('alti')[elevation-json]
//  output {String} -> http://wxs.ign.fr/calcul/alti/rest/elevation.json
//
// DefaultUrlService.Alti.url('calcul')
// output {Object|String}
// -> http://wxs.ign.fr/calcul/alti/rest/elevation.json
// -> http://wxs.ign.fr/calcul/alti/rest/elevation.xml
// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.json
// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.xml
// -> http://wxs.ign.fr/calcul/alti/wps
//
// ssl by default.
//
// Force to not do ssl :
// DefaultUrlService.ssl = false;
//
// DefaultUrlService.AutoComplete.url('calcul')
// output {Object|String}
// -> https://wxs.ign.fr/calcul/ols/apis/completion

// constantes internes
var HOSTNAME = "wxs.ign.fr";

/**
 * Default Geoportal web services URLs access.
 *
 * @namespace
 * @alias Gp.Services.DefaultUrl
 */
var DefaultUrlService = {

    /** if set true, require the use of https protocol */
    ssl : true,

    /**
    * base url of services (ssl protocol management)
    * @param {String} key - key
    * @param {String} path - path
    * @returns {String} url
    */
    url : function (key, path) {
        // comportement par défaut => https
        // sinon, il est fixé par l'option 'ssl' (false => http)
        var _protocol;
        if (DefaultUrlService.ssl === false) {
            _protocol = "http://";
        } else {
            _protocol = "https://";
        }

        return _protocol + HOSTNAME.concat("/", key, path);
    },

    /**
     * Elevation web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns elevation service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols ("elevation-json", "elevation-xml", "profil-json" or "profil-xml").
     */
    Alti : {
        _key : {
            // rest
            "elevation-json" : "/alti/rest/elevation.json",
            "elevation-xml" : "/alti/rest/elevation.xml",
            "profil-json" : "/alti/rest/elevationLine.json",
            "profil-xml" : "/alti/rest/elevationLine.xml",
            // other
            wps : "/alti/wps"
        },
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            return {
                // rest
                "elevation-json" : DefaultUrlService.url(key, this._key["elevation-json"]),
                "elevation-xml" : DefaultUrlService.url(key, this._key["elevation-xml"]),
                "profil-json" : DefaultUrlService.url(key, this._key["profil-json"]),
                "profil-xml" : DefaultUrlService.url(key, this._key["profil-xml"]),
                // other
                wps : DefaultUrlService.url(key, this._key["wps"])
            };
        }
    },
    /**
     * IsoCurve web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns isocurve service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols ("iso-json" or "iso-xml").
     */
    ProcessIsoCurve : {
        _key : "/geoportail/isochrone/rest/1.0.0/isochrone",
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            return DefaultUrlService.url(key, this._key);
        }
    },
    /**
     * Autocompletion web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns autocomplete service default urls with or without geoportal access key given as a parameter. The result is a String.
     */
    AutoComplete : {
        _key : "/ols/apis/completion",
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            return DefaultUrlService.url(key, this._key);
        }
    },
    /**
     * Reverse geocoding web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns reverse geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.
     */
    ReverseGeocode : {
        _key : "/geoportail/ols",
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            return DefaultUrlService.url(key, this._key);
        }
    },
    /**
     * Autoconfiguration web service access
     *
     * @member {Object}
     * @property {Function} url ([key1,...]) - Returns autoconfiguration service default urls with geoportal access key (s) given as a String array parameter. The result is a javascript object with different urls given the access mode ("apiKey", "apiKeys" or "aggregate").
     */
    AutoConf : {
        _key : {
            apiKey : "/autoconf",
            apiKeys : "/autoconf?keys=%KEYS%",
            aggregate : "/autoconf/id/"
        },
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            var keys = "";
            if (Array.isArray(key) && key.length > 0) {
                keys = key[0];
                for (var i = 1; i < key.length; i++) {
                    keys += "," + key[i];
                }
            }
            return {
                apiKey : DefaultUrlService.url(key, this._key["apiKey"]), // une seule clé
                apiKeys : DefaultUrlService.url(key[0], this._key["apiKeys"]).replace("%KEYS%", keys), // autoconf de plusieurs clés
                aggregate : DefaultUrlService.url(key, this._key["aggregate"])
            };
        }
    },
    /**
     * Geocoding web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.
     */
    Geocode : {
        _key : "/geoportail/ols",
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            return DefaultUrlService.url(key, this._key);
        }
    },
    /**
     * Routing web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns routing service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols.
     */
    Route : {
        _key : "/geoportail/itineraire/rest/1.0.0/route",
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            return DefaultUrlService.url(key, this._key);
        }
    }
};

/* harmony default export */ __webpack_exports__["default"] = (DefaultUrlService);


/***/ }),
/* 67 */
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"geoportal-access-lib@3.1.0\",\"_id\":\"geoportal-access-lib@3.1.0\",\"_inBundle\":false,\"_integrity\":\"sha512-2G24zh3wkfF43++KbCCfG1x4t3QseaiV1x75urlKRhVgFHXTzC8D9MWnaPUeVVyBbgskhr9rV/ZzFFwGPdTBrQ==\",\"_location\":\"/geoportal-access-lib\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"geoportal-access-lib@3.1.0\",\"name\":\"geoportal-access-lib\",\"escapedName\":\"geoportal-access-lib\",\"rawSpec\":\"3.1.0\",\"saveSpec\":null,\"fetchSpec\":\"3.1.0\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/geoportal-access-lib/-/geoportal-access-lib-3.1.0.tgz\",\"_shasum\":\"8b53fab5865e73917dc16b43dc1ec8889d45235d\",\"_spec\":\"geoportal-access-lib@3.1.0\",\"_where\":\"/home/runner/work/geoportal-extensions/geoportal-extensions\",\"author\":{\"name\":\"IGNF\"},\"bugs\":{\"url\":\"https://github.com/IGNF/geoportal-access-lib/issues\"},\"bundleDependencies\":false,\"date\":\"23/03/2022\",\"dependencies\":{\"es6-promise\":\"^4.2.4\",\"node-fetch\":\"^2.6.1\",\"xmldom\":\"^0.1.27\"},\"deprecated\":false,\"description\":\"French Geoportal resources access library\",\"devDependencies\":{\"@babel/core\":\"^7.12.10\",\"@babel/plugin-transform-template-literals\":\"^7.12.1\",\"@babel/preset-env\":\"^7.12.11\",\"babel-loader\":\"^8.2.2\",\"chai\":\"^4.1.2\",\"clean-webpack-plugin\":\"^3.0.0\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^7.18.0\",\"eslint-config-standard\":\"^16.0.2\",\"eslint-loader\":\"^4.0.2\",\"eslint-plugin-import\":\"^2.22.1\",\"eslint-plugin-node\":\"^11.1.0\",\"eslint-plugin-promise\":\"^4.2.1\",\"eslint-plugin-standard\":\"^5.0.0\",\"glob\":\"^7.1.2\",\"handlebars-layouts\":\"^3.1.4\",\"handlebars-webpack-plugin\":\"^1.4.1\",\"html-webpack-plugin\":\"^4.5.1\",\"istanbul-instrumenter-loader\":\"^3.0.1\",\"jsdoc-webpack-plugin\":\"^0.3.0\",\"loglevel\":\"^1.6.1\",\"mocha\":\"^7.2.0\",\"mocha-loader\":\"^5.1.5\",\"mocha-webpack\":\"^2.0.0-beta.0\",\"mochawesome\":\"^6.2.1\",\"nyc\":\"^15.1.0\",\"path\":\"^0.12.7\",\"replace-bundle-webpack-plugin\":\"^1.0.0\",\"sinon\":\"^9.2.4\",\"sinon-es6\":\"0.0.3\",\"speed-measure-webpack-plugin\":\"^1.4.2\",\"string-template\":\"^1.0.0\",\"terser-webpack-plugin\":\"^2.3.8\",\"webpack\":\"^4.46.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.2\",\"webpack-node-externals\":\"^2.5.2\",\"webpack-shell-plugin\":\"^0.5.0\"},\"homepage\":\"https://github.com/IGNF/geoportal-access-lib#readme\",\"keywords\":[\"geoportail\",\"webservice\",\"javascript\",\"es6\"],\"license\":\"CECILL-B\",\"main\":\"dist/GpServices-src.js\",\"module\":\"src/Gp.js\",\"name\":\"geoportal-access-lib\",\"nyc\":{\"include\":[\"src/**/*.js\"],\"instrument\":false,\"sourceMap\":false},\"optionalDependencies\":{},\"peerDependencies\":{},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/IGNF/geoportal-access-lib.git\"},\"scripts\":{\"build\":\"webpack --mode=none\",\"build:dev\":\"webpack --mode=development\",\"build:prod\":\"webpack --mode=production\",\"clean\":\"echo \\\"Warning: no yet implemented!\\\" && exit 0\",\"cover\":\"nyc --reporter=lcov --reporter=text npm run test\",\"doc\":\"npm run doc:serve\",\"doc:serve\":\"webpack-dev-server --content-base jsdoc --port 9001 --open\",\"eslint\":\"eslint src/\",\"sample\":\"npm run sample:serve\",\"sample:serve\":\"webpack-dev-server --mode=none --open-page samples/index-src.html --https --content-base . --output-public-path '/dist/' --port 9001 --open\",\"sample:serve:dev\":\"webpack-dev-server --mode=development --open-page samples/index-map.html --content-base . --output-public-path '/dist/' --port 9001 --open\",\"sample:serve:prod\":\"webpack-dev-server --mode=production --open-page samples/index-prod.html --content-base . --output-public-path '/dist/' --port 9001 --open\",\"setup\":\"npm install\",\"test\":\"mocha-webpack --reporter mochawesome --reporter-options reportDir=test-report,reportFilename=index --webpack-config ./test/webpack/webpack.test.js --glob \\\"test_*.js\\\" test/spec/\",\"test:end-to-end:serve\":\"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.js\",\"test:end-to-end:serve:docker\":\"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.docker.js\",\"test:serve\":\"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.js\",\"test:serve:docker\":\"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.docker.js\"},\"version\":\"3.1.0\"}");

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _AltiRequestREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69);
/* harmony import */ var _AltiRequestWPS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(73);
/**
 * Creation d'une requête en REST ou WPS
 * (Factory)
 *
 * @module AltiRequestFactory
 * @alias Gp.Services.Alti.Request.AltiRequestFactory
 * @private
 */





var AltiRequestFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Alti
     *
     * @example
     *   var options = {
     *      httpMethod : 'GET', // GET|POST
     *      onSuccess : function (response) {},
     *      onError : function (error) {},
     *      scope : this,
     *      positions : [{lon:, lat:}, {lon:, lat:}],
     *      outputFormat : 'json' // json|xml
     *      sampling : 3,
     *      api : 'REST', // REST|WPS
     *      zonly : false // false|true
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiRequestFactory");
        logger.trace(["AltiRequestFactory::build()"]);

        var request = null;

        // on factorise les options par groupe;
        // - global,
        // - param, les params pour les data inputs
        // - wps, les param du service
        // - callback

        var settings = {
            // ajout des valeurs par defaut spécifiques au service
            type : options.sampling ? "Profil" : "Elevation",
            method : options.httpMethod,
            param : {
                positions : null,
                delimiter : null, // FIXME par defaut, on ne le met pas en place car ça fait planter la requête !?
                indent : null, // par defaut
                crs : null, // par defaut
                format : null, // (only to POST)
                sampling : null, // (only use by Profil)
                zonly : null // (only use by Elevation)
            }
        };

        // surcharge des valeurs obligatoires
        settings.param.positions = options.positions;
        settings.param.format = options.outputFormat;
        settings.param.sampling = options.sampling;
        settings.param.zonly = options.zonly;

        // gestion des callback
        var bOnError = !!(options.onError !== null && typeof options.onError === "function"); // cast variable to boolean
        var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function");

        var message = null;
        switch (options.api) {
            case "REST":
                // FIXME les exceptions ne sont pas 'catchées' sur le constructeur !
                var myReq = new _AltiRequestREST__WEBPACK_IMPORTED_MODULE_2__["default"](settings);
                if (!myReq.processRequestString()) {
                    message = "Error in process request (rest) !";
                    if (bOnError) {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                        return;
                    }
                    throw new Error(message);
                }
                request = myReq.requestString;
                break;
            case "WPS":
                // ajout des valeurs par defaut spécifiques au service WPS
                settings.wps = {
                    service : null, // par defaut
                    version : null, // par defaut
                    identifier : null, // par defaut
                    rawdataoutput : null, // par defaut
                    request : null // par defaut
                };

                request = _AltiRequestWPS__WEBPACK_IMPORTED_MODULE_3__["default"].build(settings);
                if (!request) {
                    message = "Error in process request (wps) !";
                    if (bOnError) {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                        return;
                    }
                    throw new Error(message);
                }
                break;
            default:
                message = "Type of API is not supported by service (REST or WPS) !";
                if (bOnError) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                    return;
                }
                throw new Error(message);
        }

        if (bOnSuccess) {
            options.onSuccess.call(options.scope, request);
        }

        return request;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AltiRequestFactory);


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* jshint multistr : true */






/**
 * @classdesc
 * Classe de gestion des requêtes de type REST sur le service altimetrique.
 *
 * @todo Le service Alti n'implemente pas le POST !?
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiRequestREST
 * @param {Object} options - options
 * @param {Object}   options.param.positions - tableau de coordonnées lon/lat
 * @param {String}   options.param.delimiter - '|'
 * @param {Boolean}  options.param.indent - false|true
 * @param {String}   options.param.crs - 'CRS:84'
 * @param {String}   options.param.sampling - 3
 * @param {Boolean}  options.param.zonly - false|true
 * @param {String}   options.param.format - "JSON|XML"
 * @param {String}   options.type - "Profil|Elevation"
 * @param {String}   options.method - GET|POST
 *
 * @example
 *      var options = {
 *           type : 'Profil', // Elevation
 *           method : 'GET',  // par defaut
 *           param : {
 *               positions : [
 *                   {lon:'1.11', lat:'1.11'},
 *                   {lon:'1.10', lat:'1.10'},
 *                   {lon:'1.12', lat:'1.12'}
 *               ],
 *               delimiter : ";",         // par defaut
 *               indent    : true,        // par defaut
 *               crs       : 'EPSG:4326', // par defaut
 *               format    : 'json',      // par defaut (only to POST)
 *               sampling  : 3 ,          // par defaut (only use by Profil)
 *               zonly     : false        // par defaut (only use by Elevation)
 *           }
 *      };
 *
 *      var result;
 *      try {
 *          var obj = new AltiRequestREST (options);
 *          if (! obj.processRequestString ()) {
 *              throw new Error("Request empty !?")
 *          }
 *          result = obj.requestString;
 *      } catch (e) {
 *          // exceptions...
 *      }
 * @private
 */
function AltiRequestREST (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiRequestREST");
    this.logger.trace("[Constructeur AltiRequestREST ()]");

    if (!(this instanceof AltiRequestREST)) {
        throw new TypeError("AltiRequestREST constructor cannot be called as a function.");
    }

    this.options = options || {};

    // existance des options
    if (!this.options) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
    }

    // type de requete : Altitude ou Profil
    // (param. à determiner en fonction des parametres d'entrée)
    if (!this.options.type) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "type (Elevation or Profil)"));
    }

    // construction du modele de requête
    // (test du type d'objet candidat)
    this.DataObject = null;
    switch (this.options.type) {
        case "Elevation":
            this.DataObject = new _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_2__["default"](this.options.param);
            break;
        case "Profil":
            this.DataObject = new _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_3__["default"](this.options.param);
            break;
        default:
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "type (Elevation or Profil)"));
    }

    /**
     * methode.
     * Par defaut, "GET".
     */
    this.method = this.options.method || "GET";
}

AltiRequestREST.prototype = {

    /**
     * request
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : AltiRequestREST,

    /**
     * Template de la requête.
     */
    template : {
        get : {
            // FIXME on retire le param 'delimiter' : &delimiter='__DELIMITER__'
            value : "lon=__LON__&lat=__LAT__&indent=__INDENT__&crs='__CRS__'",
            input : {
                point : "&zonly=__ZONLY__",
                profil : "&sampling=__SAMPLING__"
            }
        },
        post : {
            // FIXME on retire le param 'delimiter' : delimiter='__DELIMITER__'\n\
            value : "lon=__LON__\n" +
                "lat=__LAT__\n" +
                "indent=__INDENT__\n" +
                "crs='__CRS__'\n",
            input : {
                point : "zonly=__ZONLY__",
                profil : "sampling=__SAMPLING__"
            }
        }
    },

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out : lon=0.2367,2.1570&lat=48.0551,46.6077&delimiter=,&indent=true&zonly=true&crs='CRS:84'
     * // POST out : Not yet supported method POST !
     * @returns {String}
     */
    processRequestString : function () {
        this.logger.trace("AltiRequestREST::processRequestString ()");

        var template = "";
        if (this.method === "POST") {
            template = this.template.post.value;
        } else if (this.method === "GET") {
            template = this.template.get.value;
        }

        template = template.replace(/__LON__/g, this.DataObject.getLon());
        template = template.replace(/__LAT__/g, this.DataObject.getLat());
        // FIXME on retire le param 'delimiter'
        // template = template.replace(/__DELIMITER__/g, this.DataObject.delimiter);
        template = template.replace(/__INDENT__/g, this.DataObject.indent);
        template = template.replace(/__CRS__/g, this.DataObject.crs);

        // ajout +
        template = template + this.__addDataInputs();
        this.logger.trace("traduction tmpl", template);

        // sauvegarde
        this.requestString = template;

        return this.requestString;
    },

    /**
     * Ajout de parametres spécifiques (ex. zonly)
     *
     * @returns {String}
     */
    __addDataInputs : function () {
        this.logger.trace("AltiRequestREST::addDataInput ()");

        var myTemplate;
        if (this.method === "POST") {
            myTemplate = this.template.post;
        } else if (this.method === "GET") {
            myTemplate = this.template.get;
        } else {
            throw new Error("No other HTTP method supported by the service !");
        }

        var tmpl = null;
        if (this.DataObject.CLASSNAME === "AltiElevationRequest") {
            tmpl = myTemplate.input.point;
            return tmpl.replace(/__ZONLY__/g, this.DataObject.zonly);
        } else if (this.DataObject.CLASSNAME === "AltiProfilRequest") {
            tmpl = myTemplate.input.profil;
            return tmpl.replace(/__SAMPLING__/g, this.DataObject.sampling);
        } else {
            throw new Error("No other object supported than elevation or profil !?");
        }
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AltiRequestREST);


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _AltiRequest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);




/**
 * @classdesc
 *
 * Classe de gestion des param. des requêtes de type POINT du service altimetrique.
 *
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiElevationRequest
 * @param {Object} options - options
 * @param {Boolean}  options.zonly - false|true
 *
 * @private
 */
function AltiElevationRequest (options) {
    if (!(this instanceof AltiElevationRequest)) {
        throw new TypeError("AltiElevationRequest constructor cannot be called as a function.");
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "AltiElevationRequest";

    // appel du constructeur par heritage
    _AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur AltiElevationRequest ()]");

    /**
     * Z uniquement.
     * true|false
     */
    this.zonly = this.options.zonly || false; // test des options héritées !
}

/**
 * @lends module:AltiElevationRequest#
 */

AltiElevationRequest.prototype = Object.create(_AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].prototype, {

    /**
     * Setter/getter pour "zonly"
     */
    zonly : {
        /** getter */
        get : function () {
            return this._zonly;
        },
        /** setter */
        set : function (z) {
            this._zonly = z;
        }
    }

});

/**
 * Constructeur (alias)
 */
AltiElevationRequest.prototype.constructor = AltiElevationRequest;

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Array}
 */
AltiElevationRequest.prototype.getData = function () {
    // par glop..., appel de AltiRequest::getData () !
    var map = [];
    map.push({
        k : "lon",
        v : this.getLon()
    });
    map.push({
        k : "lat",
        v : this.getLat()
    });
    // map.push({k : "delimiter", v : this.delimiter}); // FIXME on retire le param "delimiter"
    map.push({
        k : "indent",
        v : this.indent
    });
    map.push({
        k : "crs",
        v : this.crs
    });
    map.push({
        k : "zonly",
        v : this.zonly
    });
    map.push({
        k : "format",
        v : this.format
    });

    return map;
};

/* harmony default export */ __webpack_exports__["default"] = (AltiElevationRequest);


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);



/**
 * @classdesc
 * Classe de gestion des param. des requêtes du service altimetrique.
 *
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiRequest
 * @param {Object} options - options
 * @param {Object}   options.positions - tableau de coordonnées lon/lat
 * @param {String}   options.delimiter - "|"
 * @param {Boolean}  options.indent - false|true
 * @param {String}   options.crs - "CRS:84"
 * @param {String}   options.format - "JSON|XML"
 *
 * @private
 */
function AltiRequest (options) {
    if (!(this instanceof AltiRequest)) {
        throw new TypeError("AltiRequest constructor cannot be called as a function.");
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur AltiRequest ()]");

    /**
     * Options en paramêtres du constructeur.
     */
    this.options = options || {};

    /**
     * Liste des coordonnées.
     * @example
     * var c = [{lon : "", lat : ""}, {lon : "", lat : ""}];
     */
    this.positions = this.options.positions || [];

    /**
     * Caractère de séparation.
     * Par defaut, "|".
     */
    this.delimiter = this.options.delimiter || "|";

    /**
     * Indentation.
     * true|false
     */
    this.indent = this.options.indent || false;

    /**
     * Projection.
     * Par defaut, CRS:84.
     */
    this.crs = this.options.crs || "CRS:84";

    /**
     * format de sortie.
     * Par defaut, "json".
     */
    this.format = this.options.format || "json";
}

/**
 * CLASSNAME
 */
AltiRequest.CLASSNAME = "AltiRequest";

AltiRequest.prototype = {

    /**
     * @lends module:AltiRequest#
     */

    /**
     * Constructeur (alias)
     */
    constructor : AltiRequest,

    /**
     * Ajout d"une liste de coordonnées.
     *
     * @param {Object[]} lstPosition - liste de positions
     * @example
     * obj.setPositions ([{lon : "0.15", lat : "0.15"}, {lon : "1.15", lat : "1.15"}]);
     */
    setPositions : function (lstPosition) {
        var positions = [];
        for (var i = 0; i < lstPosition.length; i++) {
            var o = lstPosition[i];
            if (o.lon && o.lat) {
                positions.push(o);
            }
        }

        this.positions = positions;
    },

    /**
     * Liste des coordonnées.
     *
     * @param {Int} pos - position
     * @returns {positions}
     * @example
     * obj.getPositions ();  // [{lon : "", lat : ""}, {lon : "", lat : ""}]
     * obj.getPositions (0); // [{lon : "", lat : ""}]
     */
    getPositions : function (pos) {
        // FIXME test if not a number !?
        if (!pos) {
            return this.positions;
        }

        var index = this.positions.length - 1;
        if (pos > index || pos < index) {
            this.logger.warn("index out of range !");
            return this.positions;
        }

        return this.positions[pos];
    },

    /**
     * Ajout d"une liste de coordonnées.
     *
     * @param {Object[]} lstPosition - liste de positions
     * @example
     * obj.addPositions ([{lon : "0.15", lat : "0.15"}, {lon : "1.15", lat : "1.15"}]);
     */
    addPositions : function (lstPosition) {
        for (var i = 0; i < lstPosition.length; i++) {
            var o = lstPosition[i];
            if (o.lon && o.lat) {
                this.positions.push(lstPosition[i]);
            }
        }
    },

    /**
     * Retourne la liste des longitudes avec un caractère de séparation.
     *
     * @returns {String} - une liste de longitudes
     * @example
     * // out : 0.2367|2.1570|43.789|...
     */
    getLon : function () {
        var lstLon = [];
        for (var i = 0; i < this.positions.length; i++) {
            lstLon.push(this.positions[i].lon);
        }
        this.logger.trace(lstLon);
        return lstLon.join(this.delimiter);
    },

    /**
     * Retourne la liste des lattitudes avec un caractère de séparation.
     *
     * @returns {String} - une liste de lattitudes
     * @example
     * // out : 0.2367|2.1570|43.789|...
     */
    getLat : function () {
        var lstLat = [];
        for (var i = 0; i < this.positions.length; i++) {
            lstLat.push(this.positions[i].lat);
        }
        this.logger.trace(lstLat);
        return lstLat.join(this.delimiter);
    }

};

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Object[]}
 */
AltiRequest.prototype.getData = function () {
    var map = [];

    map.push({
        k : "lon",
        v : this.getLon()
    });
    map.push({
        k : "lat",
        v : this.getLat()
    });
    map.push({
        k : "delimiter",
        v : this.delimiter
    });
    map.push({
        k : "indent",
        v : this.indent
    });
    map.push({
        k : "crs",
        v : this.crs
    });
    map.push({
        k : "format",
        v : this.format
    });

    return map;
};

/* harmony default export */ __webpack_exports__["default"] = (AltiRequest);


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _AltiRequest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);




/**
 * @classdesc
 * Classe de gestion des param. des requêtes de type PROFIL du service altimetrique.
 *
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiProfilRequest
 * @param {Object}   options - options
 * @param {String}   options.sampling - 3
 *
 * @private
 */
function AltiProfilRequest (options) {
    if (!(this instanceof AltiProfilRequest)) {
        throw new TypeError("AltiProfilRequest constructor cannot be called as a function.");
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "AltiProfilRequest";

    // appel du constructeur par heritage
    _AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur AltiProfilRequest ()]");

    /**
     * Sampling
     * Par defaut, 3
     */
    this.sampling = this.options.sampling || 3; // test des options héritées !
}

/**
 * @lends module:AltiProfilRequest#
 */

AltiProfilRequest.prototype = Object.create(_AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].prototype, {

    /**
     * Setter/getter pour "sampling"
     */
    sampling : {
        /** getter */
        get : function () {
            return this._sampling;
        },
        /** setter */
        set : function (value) {
            this._sampling = value;
        }
    }
});

/**
 * Constructeur (alias)
 */
AltiProfilRequest.prototype.constructor = AltiProfilRequest;

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Object[]}
 */
AltiProfilRequest.prototype.getData = function () {
    // par glop..., appel de AltiRequest::getData () !
    var map = [];
    map.push({
        k : "lon",
        v : this.getLon()
    });
    map.push({
        k : "lat",
        v : this.getLat()
    });
    // map.push({k : "delimiter", v : this.delimiter}); // FIXME on retire le param "delimiter"
    map.push({
        k : "indent",
        v : this.indent
    });
    map.push({
        k : "crs",
        v : this.crs
    });
    map.push({
        k : "sampling",
        v : this.sampling
    });
    map.push({
        k : "format",
        v : this.format
    });

    return map;
};

/* harmony default export */ __webpack_exports__["default"] = (AltiProfilRequest);


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Formats_WPS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);
/* harmony import */ var _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/* harmony import */ var _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(72);
/**
 * Classe d'interface des requêtes de type WPS sur le service altimetrique.
 * (Factory)
 *
 * @module Gp.Services.Alti.Request.AltiRequestWPS
 * @alias Gp.Services.Alti.Request.AltiRequestWPS
 * @private
 */






var AltiRequestWPS = {

    /**
     * Interface unique de construction de la requête.
     *
     * @method build
     * @param {Object} options - options
     * @param {Object}   options.param.positions - tableau de coordonnées lon/lat
     * @param {String}   options.param.delimiter - '|'
     * @param {Boolean}  options.param.indent - false|true
     * @param {String}   options.param.crs - 'CRS:84'
     * @param {String}   options.param.sampling - 3
     * @param {Boolean}  options.param.zonly - false|true
     * @param {String}   options.param.format - "JSON|XML" (only to POST)
     * @param {String}   options.wps.service - "WPS"
     * @param {String}   options.wps.version - "1.0.0"
     * @param {String}   options.wps.identifier - "gs:WPSElevation|gs:WPSLineElevation"
     * @param {String}   options.wps.rawdataoutput - "result"
     * @param {String}   options.wps.request - "Execute"
     * @param {String}   options.type - "Profil|Elevation"
     * @param {String}   options.method - GET|POST
     * @example
     *      var options = {
     *           type : 'Profil', // Elevation
     *           method : 'GET',  // par defaut
     *           param : {
     *               positions : [
     *                   {lon:'1.11', lat:'1.11'},
     *                   {lon:'1.10', lat:'1.10'},
     *                   {lon:'1.12', lat:'1.12'}
     *               ],
     *               delimiter : ";",         // par defaut
     *               indent    : true,        // par defaut
     *               crs       : 'EPSG:4326', // par defaut
     *               format    : 'json',      // par defaut (only to POST)
     *               sampling  : 3 ,          // par defaut (only use by Profil)
     *               zonly     : false,       // par defaut (only use by Elevation)
     *           },
     *           wps : {
     *                 service : 'WPS',         // par defaut
     *                 version : '1.0.0',       // par defaut
     *                 identifier : 'gs:WPS',   // par defaut, Elevation = gs:WPSElevation, Profil = gs:WPSLineElevation
     *                 rawdataoutput : 'result',// par defaut
     *                 request : 'Execute'      // par defaut
     *           }
     *       };
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiRequestWPS");
        logger.trace(["AltiRequestWPS::build()"]);

        // existance des options
        if (!options) {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
        }

        // type de requete : Altitude ou Profil
        // (param. à determiner en fonction des parametres d'entrée)
        if (!options.type) {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "type (Elevation or Profil)"));
        }

        // construction du modele de requête
        // (test du type d'objet candidat)
        var DataObject = null;
        switch (options.type) {
            case "Elevation":
                // surcharge
                options.wps.identifier = "gs:WPSElevation";
                DataObject = new _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_3__["default"](options.param);
                break;
            case "Profil":
                // surcharge
                options.wps.identifier = "gs:WPSLineElevation";
                DataObject = new _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_4__["default"](options.param);
                break;
            default:
                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "type (Elevation or Profil)"));
        }

        // construction de la requête WPS
        var settings = {
            data : DataObject,
            method : options.method,
            param : options.wps
        };

        var rqstWPS = new _Formats_WPS__WEBPACK_IMPORTED_MODULE_2__["default"](settings);

        if (!rqstWPS.processRequestString()) {
            throw new Error("Enable to process request !");
        }

        return rqstWPS.requestString;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AltiRequestWPS);


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);


/**
 * @classdesc
 * Standard WPS
 *
 * @constructor
 * @alias Gp.Formats.WPS
 * @param {Object} options - options
 * @param {Object}   options.data - objet
 * @param {String}   options.method - POST|GET
 * @param {String}   options.param.service - "WPS"
 * @param {String}   options.param.version - "1.0.0"
 * @param {String}   options.param.identifier - "gs:WPSElevation|gs:WPSLineElevation"
 * @param {String}   options.param.rawdataoutput - "result"
 * @param {String}   options.param.request - "Execute"
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 * @private
 */
function WPS (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur WPS()]");

    if (!(this instanceof WPS)) {
        throw new TypeError("WPS constructor cannot be called as a function.");
    }

    this.options = options || {};

    /**
     * Objet DATA
     */
    this.DataObject = this.options.data;

    if (!this.DataObject) {
        throw new TypeError("This data object is not defined !");
    }

    /**
     * param service.
     * Par defaut, "WPS".
     */
    this.paramservice = this.options.param.service || "WPS";

    /**
     * param version.
     * Par defaut, "1.0.0".
     */
    this.paramversion = this.options.param.version || "1.0.0";

    /**
     * param identifier
     * Par defaut, "gs:WPS"
     */
    this.paramidentifier = this.options.param.identifier || "gs:WPS";

    /**
     * param rawdataoutput
     * Par defaut, "result".
     */
    this.paramrawdataoutput = this.options.param.rawdataoutput || "result";

    /**
     * param request
     * Par defaut, "Execute".
     */
    this.paramrequest = this.options.param.request || "Execute";

    /**
     * methode.
     * Par defaut, "GET".
     */
    this.method = this.options.method || "GET";
}

WPS.prototype = {

    /**
     * @lends module:WPS#
     */

    /**
     * request
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : WPS,

    /**
     * Template de la requête.
     */
    template : {
        get : {
            value : "service=__SERVICE__" +
                "&version=__VERSION__" +
                "&rawdataoutput=__RAWDATAOUTPUT__" +
                "&identifier=__IDENTIFIER__" +
                "&request=__REQUEST__" +
                "&datainputs=<!-- __DATAINPUTS__ -->",

            input : "__KEY__=__DATA__"

        },
        post : {

            value : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<wps:__REQUEST__ version=\"__VERSION__\" service=\"__SERVICE__\" " +
                "__NAMESPACE__ __SCHEMALOCATION__>" +
                "<ows:Identifier>__IDENTIFIER__</ows:Identifier>" +
                "<wps:DataInputs>" +
                "<!-- __DATAINPUTS__ -->" +
                "</wps:DataInputs>" +
                "<wps:ResponseForm>" +
                "<wps:RawDataOutput>" +
                "<ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>" +
                "</wps:RawDataOutput>" +
                "</wps:ResponseForm>" +
                "</wps:__REQUEST__>",

            input : "<wps:Input>" +
                "<ows:Identifier>__KEY__</ows:Identifier>" +
                "<wps:Data>" +
                "<wps:LiteralData>__DATA__</wps:LiteralData>" +
                "</wps:Data>" +
                "</wps:Input>"
        }
    },

    /**
     * Namespace par defaut de la requete POST.
     *
     * @returns {String} namespace
     */
    namespaceByDefault : function () {
        var ns = [
            "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
            "xmlns=\"http://www.opengis.net/wps/1.0.0\"",
            "xmlns:wfs=\"http://www.opengis.net/wfs\"",
            "xmlns:wps=\"http://www.opengis.net/wps/1.0.0\"",
            "xmlns:ows=\"http://www.opengis.net/ows/1.1\"",
            "xmlns:gml=\"http://www.opengis.net/gml\"",
            "xmlns:ogc=\"http://www.opengis.net/ogc\"",
            "xmlns:wcs=\"http://www.opengis.net/wcs/1.1.1\"",
            "xmlns:xlink=\"http://www.w3.org/1999/xlink\""
        ];

        return ns.join(" ");
    },

    /**
     * Schemalocation par defaut.
     *
     * @returns {String} schemaLocation
     */
    schemaLocationByDefault : function () {
        return "xsi:schemaLocation=\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\"";
    },

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out :
     * //  service=__SERVICE__
     * //  &version=__VERSION__
     * //  &rawdataoutput=__RAWDATAOUTPUT__
     * //  &identifier=__IDENTIFIER__
     * //  &request=__REQUEST__
     * //  &datainputs="__DATAINPUTS__"
     * //  avec __DATAINPUTS__ = __KEY__=__DATA__;...
     *
     * // POST out :
     * //      <?xml version=\"1.0\" encoding=\"UTF-8\"?>
     * //      <wps:__REQUEST__ version=\"__VERSION__\" service=\"__SERVICE__\"
     * //         __NAMESPACE__ __SCHEMALOCATION__>
     * //          <ows:Identifier>__IDENTIFIER__</ows:Identifier>
     * //          <wps:DataInputs>
     * //              <!-- __DATAINPUTS__ -->
     * //          </wps:DataInputs>
     * //          <wps:ResponseForm>
     * //              <wps:RawDataOutput>
     * //              <ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>
     * //              </wps:RawDataOutput>
     * //          </wps:ResponseForm>
     * //      </wps:__REQUEST__>",
     * //      avec __DATAINPUTS__
     * //             <wps:Input>
     * //                  <ows:Identifier>__KEY__</ows:Identifier>
     * //                  <wps:Data>
     * //                    <wps:LiteralData>__DATA__</wps:LiteralData>
     * //                  </wps:Data>
     * //              </wps:Input>
     *
     * @returns {Boolean} validation de la construction de la requete
     */
    processRequestString : function () {
        this.logger.trace("WPS::processRequestString ()");

        var template = "";
        if (this.method === "POST") {
            template = this.template.post.value;
        } else if (this.method === "GET") {
            template = this.template.get.value;
        } else {
            this.logger.error("No other method supported by the service !");
            return false;
        }

        template = template.replace(/__SERVICE__/g, this.paramservice);
        template = template.replace(/__VERSION__/g, this.paramversion);
        template = template.replace(/__RAWDATAOUTPUT__/g, this.paramrawdataoutput);
        template = template.replace(/__IDENTIFIER__/g, this.paramidentifier);
        template = template.replace(/__REQUEST__/g, this.paramrequest);

        // ajout +
        if (this.method === "POST") {
            template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);
            template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);
        }

        // ajout des datainputs
        template = template.replace(/<!-- __DATAINPUTS__ -->/g, this.__addDataInputs());

        if (!template) {
            this.logger.warn("traduction tmpl : empty request !?");
            return false;
        }

        this.requestString = template;
        this.logger.trace("traduction tmpl", template);

        return true;
    },

    /**
     * Ajout des données
     *
     * @returns {String} Données concaténées dans une chaine
     */
    __addDataInputs : function () {
        this.logger.trace("WPS::__addDataInputs ()");

        // c'est un peu grossier...
        var tmpl = this.method === "GET" ? this.template.get.input : this.template.post.input;
        var sep = this.method === "GET" ? ";" : "";

        var result = "";
        var that = this;
        var map = this.DataObject.getData();
        for (var i = 0; i < map.length; i++) {
            // FIXME closure ?
            (function (j) {
                if (sep) {
                    sep = (j === map.length - 1) ? "" : ";";
                }
                result = result.concat(that.__addDataInput(tmpl, map[j].k, map[j].v), sep);
            })(i);
        }

        return result;
    },

    /**
     * Ajout d'une donnée.
     *
     * @param {String} tmpl - template
     * @param {String} key - clef
     * @param {String} data - valeur
     * @returns {String} chaine avec les substitutions clef/valeur
     */
    __addDataInput : function (tmpl, key, data) {
        var tmp = tmpl;
        tmp = tmp.replace(/__KEY__/g, key);
        tmp = tmp.replace(/__DATA__/g, data);
        return tmp;
    },

    /**
     * Definir le mode de requête
     *
     * @param {String} method - GET|POST
     */
    setMethod : function (method) {
        if (method === "GET" || method === "POST") {
            this.method = method;
        } else {
            this.logger.warn("support only GET and POST method !");
        }
    },

    /**
     * Retourne le mode de requete (GET|POST).
     *
     * @returns {AltiRequest.options.mode|String} methode (GET|POST)
     */
    getMethod : function () {
        return this.method;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (WPS);


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _Formats_XML__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76);
/* harmony import */ var _Formats_AltiResponseReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(77);
/* harmony import */ var _model_AltiResponse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);
/* harmony import */ var _model_Elevation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(79);
/**
 * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON
 * (Factory)
 *
 * @module AltiResponseFactory
 * @private
 * @alias Gp.Services.Alti.Response.AltiResponseFactory
 */








var AltiResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Alti
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiResponseFactory");
        logger.trace(["AltiResponseFactory::build()"]);

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                switch (options.outputFormat) {
                    case "xml":
                        logger.trace("analyze response : xml");

                        try {
                            var p = new _Formats_XML__WEBPACK_IMPORTED_MODULE_3__["default"]({
                                reader : _Formats_AltiResponseReader__WEBPACK_IMPORTED_MODULE_4__["default"]
                            });

                            if (typeof options.response === "string") {
                                p.setXMLString(options.response);
                            } else {
                                p.setXMLDoc(options.response);
                            }

                            data = p.parse();

                            if (!data) {
                                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION_2"));
                            }
                        } catch (e) {
                            var message = e.message;
                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", message),
                                status : 200,
                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR
                            }));
                            return;
                        }

                        break;

                    case "json":
                        logger.trace("analyze response : json");
                        logger.trace("analyze response : ", typeof options.response);

                        var JSONResponse = null;
                        if (typeof options.response === "string") {
                            JSONResponse = JSON.parse(options.response);
                        } else {
                            JSONResponse = options.response;
                        }

                        // le service renvoie t il une erreur ?
                        if (JSONResponse && JSONResponse.error) {
                            // ex. {"error": {"code": "BAD_PARAMETER","description": "The values () cannot be parsed as a valid longitude (double value such as -180 < lat < 180)."}}
                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.error.description),
                                status : 200,
                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR
                            }));
                            return;
                        }

                        // analyse de la reponse
                        if (JSONResponse) {
                            var elevations = JSONResponse.elevations;
                            var altiResponse = new _model_AltiResponse__WEBPACK_IMPORTED_MODULE_5__["default"]();
                            var elevation;
                            if (Array.isArray(elevations) && elevations.length) {
                                for (var i = 0; i < elevations.length; i++) {
                                    elevation = new _model_Elevation__WEBPACK_IMPORTED_MODULE_6__["default"]();

                                    if (typeof elevations[i] === "object") {
                                        // elevations[i] est un objet elevation
                                        if (elevations[i].lon) {
                                            elevation.lon = elevations[i].lon;
                                        }
                                        if (elevations[i].lat) {
                                            elevation.lat = elevations[i].lat;
                                        }
                                        if (elevations[i].z) {
                                            elevation.z = elevations[i].z;
                                        }
                                        if (elevations[i].acc) {
                                            elevation.acc = elevations[i].acc;
                                        }
                                    } else if (typeof elevations[i] === "number") {
                                        // elevations[i] est un nombre, dans le cas de zonly=true notamment
                                        elevation.z = elevations[i];
                                    }

                                    if (Array.isArray(altiResponse.elevations)) {
                                        altiResponse.elevations.push(elevation);
                                    }
                                }
                            }
                            data = altiResponse;
                        }

                        if (!data) {
                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE_2"),
                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_UNKERR,
                                status : -1
                            }));
                            return;
                        }
                        break;

                    default:
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                            message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_FORMAT_2"),
                            type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_UNKERR,
                            status : -1
                        }));
                        return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                } else if (data.error) {
                    var errorMess = data.error.description;
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", errorMess),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }
            }
        } else {
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AltiResponseFactory);


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* global require */


// import __xmldom from "xmldom";

/**
 * @classdesc
 *
 * Classe permettant d'écrire ou de lire du XML, sous forme de document DOM,
 * éventuellement selon des clés de lecture (readers) ou d'écriture (writers) spécifiques.
 *
 * @constructor
 * @alias Gp.Formats.XML
 *
 * @param {Object} [options] - options du format XML
 *
 * @param {Object} [options.reader] - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)
 *      utile pour interpréter le XML lorsque sa structure est connue.
 *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.
 *
 * @param {Object} [options.writers] - writers
 *
 * @param {String} [options.xmlString] - chaîne de caractère contenant du XML à interpréter.
 *
 * @private
 */
function XML (options) {
    if (!(this instanceof XML)) {
        throw new TypeError("XML constructor cannot be called as a function.");
    }

    // FIXME : notion de singleton

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur XML ()]");

    /**
     * Chaîne de caractères contenant le texte XML
     * @type {String}
     */
    this.xmlString = null;

    /**
     * DOM Element correspondant à la structure du XML.
     * @type {DOMElement}
     */
    this.xmlDoc = null;

    /**
     * Objet contenant des fonctions de lecture des différentes balises XML.
     * @type {Object}
     */
    this.reader = null;

    // traitement des paramètres d'options s'il y en a
    if (options) {
        if (options.xmlString && typeof options.xmlString === "string") {
            this.xmlString = options.xmlString;
            // Si une chaine de caractère a été passée en entrée : on la transforme aussi en XML document
            this.xmlDoc = __getXMLDOC(options.xmlString);
        }
        if (options.reader) {
            this.setReader(options.reader);
        }
    }
}

XML.prototype = {

    /**
     * @lends module:XML
     */

    /*
     * Constructeur (alias)
     */
    constructor : XML,

    /**
     * Méthode permettant de récupérer la chaîne de caractères associée au format XML
     *
     * @returns {String} xmlString - la chaîne de caractères correspondant au format XML
     */
    getXMLString : function () {
        return this.xmlString;
    },

    /**
     * Méthode permettant d'attribuer une chaîne de caractères au format XML (attribut xmlString).
     * La méthode va aussi transformer cette chaîne de caractères en document XML,
     * afin de remplir l'attribut xmlDoc.
     *
     * @param {String} xmlString - la chaîne de caractères correspondant au format XML
     */
    setXMLString : function (xmlString) {
        if (xmlString && typeof xmlString === "string") {
            this.xmlString = xmlString;
            this.xmlDoc = __getXMLDOC(xmlString);
        }
    },

    /**
     * Méthode permettant de récupérer les readers associés au format XML, s'ils ont été définis
     *
     * @return {Object} readers - les readers associés au format XML, s'ils existent,
     *      sous forme d'une collection de fonctions
     */
    getReader : function () {
        return this.reader;
    },

    /**
     * Méthode permettant d'attribuer des readers, sous la forme d'un objet de fonctions (node, data),
     *      lorsqu'ils n'ont pas été définis lors de l'instanciation par exemple (new XML (options)).
     *
     * @param {Object} reader - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)
     *      utile pour interpréter le XML lorsque sa structure est connue.
     *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.
     */
    setReader : function (reader) {
        if (reader && reader.read && typeof reader.read === "function") {
            this.reader = reader;
        }
    },

    /**
     * Méthode permettant de récupérer le document XML associé au format, s'il existe.
     *
     * @return {DOMElement} xmlDoc - le document XML (DOM document node) s'il existe
     */
    getXMLDoc : function () {
        return this.xmlDoc;
    },

    /**
     * Setter
     */
    setXMLDoc : function (doc) {
        this.xmlDoc = doc;
    },
    /**
     * Méthode initialisant la lecture du XML, à partir d'un XML Document :
     *      création d'un objet JavaScript contenant les informations du XML,
     *      sauf dans le cas où il n'existe pas de XML Document à interpréter (retourne un objet vide).
     *
     * @return {Object} [parserOutput] - un objet JavaScript contenant les informations du XML :
     * - soit toutes les informations si aucun reader n'a été spécifié à la création du format
     * - soit les informations spécifiées dans le reader.
     */
    parse : function () {
        // build xml document from xmlString
        if (!this.xmlDoc && this.xmlString) {
            this.xmlDoc = __getXMLDOC(this.xmlString);
        }
        if (this.xmlDoc) {
            var root = __getRootNode(this.xmlDoc);
            if (root) {
                var parserOutput;
                // call reader if exists
                if (this.reader && this.reader.read) {
                    parserOutput = this.reader.read(root);
                } else {
                    parserOutput = {};
                    parserOutput[root.nodeName] = __readDefault(root);
                }
                return parserOutput;
            } else {
                return {};
            }
        }
    }

};

/**
 * Méthode de la classe (privée) permettant de créer un XML Document à partir d'une chaîne de caractères XML,
 *      en utilisant DOMParser () lorsque c'est possible.
 *      For more information, see: https://dvcs.w3.org/hg/innerhtml/raw-file/tip/index.html#the-domparser-interface
 *
 * @private
 * @memberof XML
 * @method __getXMLDOC
 * @param {String} xmlString - xml string to be converted into DOM element
 * @return {DOMElement} - the corresponding XML Document
 */
function __getXMLDOC (xmlString) {
    if (typeof window === "undefined") {
        // env. nodejs
        var DOMParser = __webpack_require__(64).DOMParser; // __xmldom.DOMParser;
        return new DOMParser().parseFromString(xmlString, "text/xml");
    } else {
        // env. browser

        var parser;
        var xmlDoc;
        var errorMsg = "Erreur lors du parsing de la réponse du service : XML non conforme";

        if (window.ActiveXObject) {
            // Internet Explorer < 9
            xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = false;
            xmlDoc.loadXML(xmlString);
            var parseError = xmlDoc.parseError;
            if (parseError.errorCode) {
                if (parseError.line && parseError.linepos) {
                    errorMsg += "( ligne " + parseError.line + ", colonne " + parseError.linepos;
                }
                if (parseError.reason) {
                    errorMsg += ":  " + parseError.reason + ")";
                }
                throw new Error(errorMsg);
            }
            return xmlDoc;
        } else if (window.DOMParser) {
            // les autres (Chrome, Mozilla, IE >= 9)
            parser = new window.DOMParser();
            try {
                xmlDoc = parser.parseFromString(xmlString, "text/xml");
            } catch (e) {
                // Internet Explorer browser raises exception if xmlString is not valid XML
                if (e.message === "SyntaxError") {
                    throw new Error(errorMsg);
                } else {
                    throw new Error("Erreur lors du parsing de la réponse du service : " + e.message);
                }
            }
            // look for parsing error in case no exception was raised
            if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                var parsererror = xmlDoc.getElementsByTagName("parsererror");
                for (var i = 0; i < parsererror.length; i++) {
                    var content = parsererror[i].innerHTML;
                    // except in case parsererror is just because of huge xml, but parsing is done.
                    if (content.indexOf("Huge input lookup") === -1) {
                        errorMsg += "(" + content + ")";
                        throw new Error(errorMsg);
                    }
                }
            } else if (!xmlDoc.documentElement) { // may happen in chrome browser
                throw new Error(errorMsg);
            }
            return xmlDoc;
        } else {
            // FIXME
            throw new Error("Incompatible DOM Parser pour ce navigateur !");
        }
    }
}

/**
 * Méthode de la classe (privée) permettant de récupérer le noeud racine du document,
 *      à partir d'un document node (nodeType=9), puis lecture de ce noeud (readNode)
 *
 * @private
 * @memberof XML
 * @method __getRootNode
 * @param {DOMElement} [xmlDoc] - a Document Node
 * @return {DOMElement} root - the document root node
 */
function __getRootNode (xmlDoc) {
    var root;
    if (xmlDoc.nodeType === 9) {
        // INFO : nodeType 9 represents the entire document (the root-node of the DOM tree)
        root = xmlDoc.documentElement;
    } else if (xmlDoc.nodeType === 1) {
        root = xmlDoc;
    }
    return root;
}

/**
 * Méthode de la classe (privée) permettant de lire automatiquement un noeud XML,
 *      lorsqu'aucun reader spécifique n'a été spécifié (parser brut)
 *
 * @private
 * @memberof XML
 * @method readDefault
 * @param {DOMElement} node - a DOM element node
 * @example final data object looks like :
 *          data = {
 *              attributeName: attributeValue,
 *              childName: {
 *                  attributeName: attributeValue,
 *                  attributeName: attributeValue,
 *                  childName: {
 *                      "textContent": textContent
 *                  },
 *                  childName: {
 *                      childName: {
 *                          attributeName:attributeValue
 *                      }
 *                  }
 *              }
 *          }
 */
function __readDefault (node) {
    var data = {};

    // if element node has attributes, set their values to data
    if (node.attributes.length > 0) {
        var dataAttributes = __getAttributes(node);
        data["attributes"] = dataAttributes;
    }

    // if element node has childNodes, read them and set them to data
    if (node.hasChildNodes()) {
        var childData = {};
        var child;
        var children = node.childNodes;

        for (var i = 0; i < children.length; i++) {
            child = children[i];

            if (child.nodeType === 3) { // TEXT_NODE
                data["textContent"] = child.nodeValue;
            } else if (child.nodeType === 1) {
                childData = __readDefault(child);

                if (!data[child.nodeName]) {
                    // store childData in an object
                    data[child.nodeName] = childData;
                } else {
                    // in case several childNodes has the same name : store them in an array.
                    // if data[nodeName] already exists but is not an array
                    if (!Array.isArray(data[child.nodeName])) {
                        var old = data[child.nodeName];
                        data[child.nodeName] = [];
                        data[child.nodeName].push(old);
                    }
                    data[child.nodeName].push(childData);
                }
            }
            // TODO : manage other node types (4=CDATA, etc)
        }
    }

    return data;
}

/**
 * Méthode de la classe (privée) permettant de récupérer les attributs d'un noeud élément
 *
 * @private
 * @memberof XML
 * @method __getAttributes
 * @param {DOMElement} node - noeud contenant l'attribut recherché
 * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs
 */
function __getAttributes (node) {
    if (node.attributes.length > 0) {
        var nodeAttributes = {};
        var attributes = node.attributes;
        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            nodeAttributes[attribute.nodeName] = attribute.nodeValue;
        }
        return nodeAttributes;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (XML);


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/* harmony import */ var _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);

/**
 * Fonction retournant un objet contenant des clés de lecture (readers)
 *      qui permettent de parser des réponses XML du service Altimétrique du Géoportail
 *      (calcul altimétrique simple ou profil altimétrique d'une courbe),
 *      lorsque le paramètre output = xml,
 *      afin de récupérer les élévations retournées.
 *
 * @module AltiResponseReader
 * @alias Gp.Services.Alti.Formats.AltiResponseReader
 * @private
 */

// import Logger from "../../../Utils/LoggerByDefault";



/**
 *
 * Objet AltiResponseReader
 *
 * @member {Object} AltiResponseReader
 *
 * @property {Object} AltiResponseReader.READERS - Objet contenant des fonctions de lecture, appelées "readers"
 *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire
 *      et la valeur associée est une fonction (node, data)
 *      où node est un noeud du document DOM
 *      et data est un objet où l'on stocke les informations lues dans le XML.
 *
 * @property {Method} AltiResponseReader.READERS.elevations -  Lecture d'un noeud "elevations" de la réponse XML
 *      du service alti, correspondant logiquement à la racine du document
 *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)
 *
 * @property {Method} AltiResponseReader.READERS.elevation - ecture d'un noeud "elevation" de la réponse xml du service alti.
 *      (contient un ou 4 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, et acc)
 *
 * @property {Method} AltiResponseReader.READERS.lat - Lecture d'un noeud "lat" de la réponse xml du service alti.
 *      (contient une valeur de latitude, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.lon - Lecture d'un noeud "lon" de la réponse xml du service alti.
 *      (contient une valeur de longitude, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.z - Lecture d'un noeud "z" de la réponse xml du service alti.
 *      (contient une valeur d'altitude, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.acc - Lecture d'un noeud "acc" de la réponse xml du service alti.
 *      (contient une valeur de précision, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.exceptionreport - Lecture d'un noeud "ExceptionReport" de la réponse xml du service alti.
 *
 * @property {Method} AltiResponseReader.READERS.exception - Lecture d'un noeud "Exception" de la réponse xml du service alti.
 *
 * @property {Method} AltiResponseReader.read - Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,
 *      à l'aide des readers de la classe.
 *
 */
var AltiResponseReader = {};

AltiResponseReader.READERS = {

    /**
     * Lecture d'un noeud "elevations" de la réponse XML du service alti, correspondant logiquement à la racine du document
     *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)
     *
     * @param {DOMElement} root - racine de la réponse XML
     * @static
     * @memberof AltiResponseReader
     * @returns {Object} Retourne un objet de type AltiResponse
     */
    elevations : function (root) {
        // INFO : on passe en paramètre l'objet en entrée elevations, vide, à remplir.
        var altiResponse = new _Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_0__["default"]();

        if (root.hasChildNodes()) {
            var children = root.childNodes;
            var child;
            var elevation;

            for (var i = 0; i < children.length; i++) {
                child = children[i];

                if (AltiResponseReader.READERS[child.nodeName]) {
                    elevation = AltiResponseReader.READERS[child.nodeName](child);
                    altiResponse.elevations.push(elevation);
                }
            }
        }

        return altiResponse;
    },

    /**
     * Lecture d'un noeud "elevation" de la réponse xml du service alti.
     *      (contient un ou 4 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, et acc)
     *
     * @param {DOMElement} node - noeud elevation à lire pour récupérer les informations de l'élévation retournée (z [, lon, lat, acc])
     * @return {Array} elevationResponse - format de la réponse en sortie, instance de AltiResponse
     * @static
     * @memberof AltiResponseReader
     */
    elevation : function (node) {
        var elevation = new _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__["default"]();

        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                if (AltiResponseReader.READERS[child.nodeName]) {
                    // INFO : on passe en paramètre l'objet en entrée elevation, vide, à remplir.
                    AltiResponseReader.READERS[child.nodeName](child, elevation);
                }
            }
        }
        return elevation;
    },

    /**
     * Lecture d'un noeud "lat" de la réponse xml du service alti.
     *      (contient une valeur de latitude, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la latitude
     * @param {Object} elevation - objet dans lequel stocker la latitude retournée
     * @static
     * @memberof AltiResponseReader
     */
    lat : function (node, elevation) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            elevation.lat = parseFloat(textNode.nodeValue);
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : latitude attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "lon" de la réponse xml du service alti.
     *      (contient une valeur de longitude, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la longitude
     * @param {Object} elevation - objet dans lequel stocker la longitude retournée
     * @static
     * @memberof AltiResponseReader
     */
    lon : function (node, elevation) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            elevation.lon = parseFloat(textNode.nodeValue);
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : longitude attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "z" de la réponse xml du service alti.
     *      (contient une valeur d'altitude, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'altitude
     * @param {Object} elevation - objet dans lequel stocker l'altitude retournée
     * @static
     * @memberof AltiResponseReader
     */
    z : function (node, elevation) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            if (elevation) {
                elevation.z = parseFloat(textNode.nodeValue);
            } else {
                elevation = new _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__["default"]();
                elevation.z = parseFloat(textNode.nodeValue);
                return elevation;
            }
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : altitude attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "acc" de la réponse xml du service alti.
     *      (contient une valeur de précision, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la précision
     * @param {Object} elevation - objet dans lequel stocker la précision retournée
     * @static
     * @memberof AltiResponseReader
     */
    acc : function (node, elevation) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            elevation.acc = parseFloat(textNode.nodeValue);
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : précision (acc) attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "ExceptionReport" de la réponse xml du service alti.
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'exception
     * @return {Object} exceptionReport - objet contenant l'exception
     * @static
     * @memberof AltiResponseReader
     */
    exceptionreport : function (node) {
        var response = {};

        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                if (child.nodeName === "Exception") {
                    response.exceptionReport = AltiResponseReader.READERS.exception(child);
                }
            }
        }

        return response;
    },

    /**
     * Lecture d'un noeud "Exception" de la réponse xml du service alti.
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'exception
     * @return {Object} exceptionReport - objet contenant l'exception, avec deux attributs :
     *      {String} exceptionReport.exceptionCode - qui contient l'identifiant du code de l'exception
     *      {String} exceptionReport.exception - qui contient le message de l'exception
     * @static
     * @memberof AltiResponseReader
     */
    exception : function (node) {
        var exceptionReport = {};

        // get exception code
        var exceptionCode = node.getAttribute("exceptionCode");
        if (exceptionCode) {
            exceptionReport.exceptionCode = exceptionCode;
        }

        // get exception message
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            exceptionReport.exception = textNode.nodeValue;
        }

        return exceptionReport;
    },

    /**
     * Lecture d'un noeud "Error" de la réponse xml du service alti.
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'exception
     * @return {Object} error - objet contenant l'exception
     * @static
     */
    error : function (node) {
        var response = {
            error : {}
        };
        // get error code and description
        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                var textNode;
                // get error code
                if (child.nodeType === 1 && child.nodeName === "code") { // 1 === node.ELEMENT_NODE
                    textNode = child.firstChild;
                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
                        response.error.code = textNode.nodeValue;
                    }
                }
                // get error description
                if (child.nodeType === 1 && child.nodeName === "description") { // 1 === node.ELEMENT_NODE
                    textNode = child.firstChild;
                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
                        response.error.description = textNode.nodeValue;
                    }
                }
            }
        }
        return response;
    }

};

/**
 * Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,
 *      à l'aide des readers de la classe.
 *
 * @method AltiResponseReader.read
 * @param {DOMElement} root - racine de la réponse XML à lire
 * @static
 * @memberof AltiResponseReader
 */
AltiResponseReader.read = function (root) {
    if (root.nodeName === "elevations") {
        var altiResponse = AltiResponseReader.READERS.elevations(root);
        return altiResponse;
    } else if (root.nodeName === "ExceptionReport") {
        var exceptionReport = AltiResponseReader.READERS.exceptionreport(root);
        return exceptionReport;
    } else if (root.nodeName === "error") {
        var error = AltiResponseReader.READERS.error(root);
        return error;
    } else {
        throw new Error("Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.");
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AltiResponseReader);


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Response object for {@link module:Services~getAltitude Gp.Services.getAltitude ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Array.<Gp.Services.Alti.Elevation>} elevations - Elevations array.
 *
 * @namespace
 * @alias Gp.Services.AltiResponse
 */
function AltiResponse () {
    if (!(this instanceof AltiResponse)) {
        throw new TypeError("AltiResponse constructor cannot be called as a function.");
    }

    this.elevations = [];
}

AltiResponse.prototype = {

    constructor : AltiResponse

};

/* harmony default export */ __webpack_exports__["default"] = (AltiResponse);


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Single elevation object returned by underlying web service. Contains at least, one elevation (z). May also contain point coordinates and elevation accuracy if "zonly" parameter wasn't set to true.
 *
 * @property {Float} lat - Point latitude. (only if zonly=false)
 * @property {Float} lon - Point longitude. (only if zonly=false)
 * @property {Float} z - Point elevation.
 * @property {Float} acc - Accuracy of elevation for this point. (only if zonly=false)
 *
 * @namespace
 * @alias Gp.Services.Alti.Elevation
 */
function Elevation () {
    if (!(this instanceof Elevation)) {
        throw new TypeError("Elevation constructor cannot be called as a function.");
    }

    this.z = null;
}

Elevation.prototype = {

    constructor : Elevation

};

/* harmony default export */ __webpack_exports__["default"] = (Elevation);


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56);
/* harmony import */ var _Response_AutoConfResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(81);









/**
 * @classdesc
 * Appel du service d'autoconfiguration du Géoportail
 *
 * @private
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.AutoConf
 *
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String} [options.layerId] - Le nom de l'agrégat (couche) dont on veut connaître les informations détaillées.
 *      La présence de cette propriété implique l'utilisation de la deuxième opération du service pour accéder aux informations d'une couche aggrégée.
 *      Dans ce cas, la fonction effectuera quand même dans un premier temps la récupération des informations de l'auto-
 *      configuration complète, sauf si un premier appel à l'autoconf a déjà été fait avec cette clé (i.e. si la variable globale est définie
 *      pour la clé de contrat). Elle ira ensuite chercher les informations des couches agrégées, qui seront ajoutées à la variable globale Gp.Config.
 *
 * @example
 *   var options = {
 *      // options communes aux services
 *      apiKey : "apikey",
 *      protocol : 'JSONP', // JSONP|XHR
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      layerId : "ORTHOIMAGERY.ORTHOPHOTOS.3D$GEOPORTAIL:OGC:WMTS@aggregate"
 *   };
 */
function AutoConf (options) {
    if (!(this instanceof AutoConf)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "AutoConf"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "AutoConf";

    // Autoconf default protocol remains JSONP (#see http://ignf.github.io/geoportal-access-lib/latest/jsdoc/tutorial-optimize-getconfig.html)
    if (!options) {
        options = {};
    }
    options.protocol = options.protocol || "JSONP";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_5__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.AutoConf");
    this.logger.trace("[Constructeur AutoConf (options)]");

    // si on a une liste de plusieurs clés en options, on la transforme en tableau (multiKeys)
    if ((typeof this.options.apiKey === "string" || this.options.apiKey instanceof String) && Array.isArray(this.options.apiKey.split(",")) && this.options.apiKey.split(",").length > 1) {
        this.options.apiKey = this.options.apiKey.split(",");
    }

    // #####################
    // analyse des options
    // #####################

    // gestion de l'url du service par defaut
    if (!this.options.serverUrl) {
        // si l'url n'est pas renseignée, il faut utiliser les urls par defaut
        // en fonction du nombre de clés en entrée et du paramètre layerId
        if (!this.options.serverUrl) {
            var lstUrlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].AutoConf.url(this.options.apiKey);

            if (!this.options.layerId) {
                // cas d'une autoconf simple
                if (Array.isArray(this.options.apiKey) && this.options.apiKey.length > 0) {
                    // cas d'un tableau de clés en entrée
                    this.options.serverUrl = lstUrlByDefault.apiKeys;
                } else {
                    this.options.serverUrl = lstUrlByDefault.apiKey;
                }
            } else {
                // cas d'une autoconf pour des couches aggrégées
                this.options.serverUrl = lstUrlByDefault.aggregate + this.options.layerId;
            }
        }
    }

    // INFO
    // le service ne repond pas en mode POST (405 Method Not Allowed)
    if (this.options.protocol === "XHR" && this.options.httpMethod === "POST") {
        this.logger.warn("Le service ne gére pas le mode d'interrogation en POST, on bascule sur du GET !");
        this.options.httpMethod = "GET"; // on surcharge !
    }

    // #####################
    // attributs d'instances
    // #####################

    /**
     * Format forcé de la réponse du service : "xml"
     * sauf si l'on souhaite une reponse brute (options.rawResponse)
     */
    this.options.outputFormat = (this.options.rawResponse) ? "" : "xml";
}

/**
 * @lends module:AutoConf#
 */

AutoConf.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_5__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
AutoConf.prototype.constructor = AutoConf;

/**
 * Création de la requête (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback de succès de la création de la requête
 */
AutoConf.prototype.buildRequest = function (error, success) {
    var scope = typeof window !== "undefined" ? window : {};

    if (scope.Gp && scope.Gp.Config && scope.Gp.Config.generalOptions && scope.Gp.Config.layers) {
        if (scope.Gp.Config.generalOptions.apiKeys[this.options.apiKey]) {
            if (this.options.layerId) { // cas d'une autoconf + détaillée sur une couche agrégée
                if (scope.Gp.Config.layers[this.options.layerId] && scope.Gp.Config.layers[this.options.layerId].aggregatedLayers) {
                    this.logger.warn("Gp.Config existe déjà pour cette clé et cette couche");
                    this.options.onSuccess.call(this, scope.Gp.Config);
                    return;
                }
            } else {
                this.logger.warn("Gp.Config existe déjà pour cette clé");
                this.options.onSuccess.call(this, scope.Gp.Config);
                return;
            }
        }
    }

    // requete par defaut
    this.request = "";

    // gestion de l'autoconf local
    // Le fichier en local doit respecter le format de sortie du service.
    //  - En XHR, le format est en xml
    //  - En JSONP, le format est en xml encapsulé dans un json avec une fonction de callback
    //    ex. callback ({"http":{"status":200,"error":null},"xml":"..."})
    var bLocal;
    if (this.options.serverUrl.indexOf("http://") === -1) {
        bLocal = true;
    } else {
        bLocal = false;
    }

    // FIXME param. KVP optionnel sur un service uniquement (pas sur un autoconf local !)
    if (!bLocal && this.layerId) {
        this.request = _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].normalyzeParameters({
            layerId : this.layerId
        });
    }

    // normalement pas d'erreur d'autoconf...
    (this.request || this.request === "")
        ? success.call(this, this.request)
        : error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_3__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD")));
};

/**
 * Analyse de la reponse (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback de succès de l'analyse de la réponse
 */
AutoConf.prototype.analyzeResponse = function (error, success) {
    if (this.response) {
        var options = {
            layerId : this.options.layerId,
            response : this.response,
            rawResponse : this.options.rawResponse,
            onSuccess : success,
            onError : error,
            scope : this
        };

        _Response_AutoConfResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_3__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AutoConf);


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _Formats_XML__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76);
/* harmony import */ var _Formats_AutoConfResponseReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82);
/**
 * Factory pour générer une reponse JSON à partir d'un XML
 *
 * @module AutoConfReponseFactory
 * @private
 * @alias Gp.Services.AutoConf.Response.AutoConfResponseFactory
 * @todo gérer le cas du JSONP qui encapsule du XML ?
 */






var AutoConfReponseFactory = {

    /**
     * interface unique
     * Fabrique d'analyse des réponses (xml) du service d'autoconfiguration.
     * Création d'un format XML, auquel on associe un reader et une chaîne XML, et qui renverra un objet JavaScript correspondant.
     * Si une erreur est levée lors de l'analyse, ou si l'objet est vide ou contient une exception : appel de la fonction de callback onError
     * Sinon, appel de la fonction de callback onSuccess (définies dans Autoconf.analyzeResponse)
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant AutoConf
     *
     * @example
     *   var options = {
     *      layerId :
     *      response :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AutoConfResponseFactory");
        logger.trace(["AutoConfResponseFactory::build()"]);

        // data de type AutoConfResponse
        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                data = options.response;
            } else {
                try {
                    var p = new _Formats_XML__WEBPACK_IMPORTED_MODULE_3__["default"]({
                        reader : _Formats_AutoConfResponseReader__WEBPACK_IMPORTED_MODULE_4__["default"]
                    });

                    if (typeof options.response === "string") {
                        p.setXMLString(options.response);
                    } else {
                        p.setXMLDoc(options.response);
                    }

                    data = p.parse();
                } catch (e) {
                    // si une exception a été levée, on appelle le callback d'erreur avec le message renvoyé
                    var message = e.message;
                    if (typeof options.response === "string") {
                        message += "\n (raw response service'" + options.response + "')";
                    } else {
                        message += "\n (raw response service'" + options.response.documentElement.innerHTML + "')";
                    }

                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", message),
                        status : 200,
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR
                    }));
                    return;
                }

                // Si la réponse est vide, on appelle le callback d'erreur
                var isEmpty = true;
                for (var key in data) {
                    if (data.hasOwnProperty(key)) {
                        isEmpty = false;
                    }
                }
                if (isEmpty) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY_2")));
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service, on appelle le callback d'erreur
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }
            }
        } else {
            // si la réponse (xmlString) est vide, on appelle le callback d'erreur
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        // définition de la variable globale Gp.Config à partir de la réponse
        var scope = typeof window !== "undefined" ? window : {};

        if (!scope.Gp) {
            scope.Gp = {};
        }
        if (!scope.Gp.Config) {
            scope.Gp.Config = data;
        } else {
            this.mergeConfig(scope.Gp.Config, data, options.layerId);
        }

        // si tout s'est bien passé, on appelle le callback de succès
        options.onSuccess.call(options.scope, scope.Gp.Config);
    },

    /**
     * Fonction utilisée dans le cas où l'autoconfiguration est appelée plusieurs fois
     * (par exemple pour des clés différentes ou pour des infos sur une couche agrégée)
     *
     * @method mergeConfig
     * @static
     * @param {Object} GpConfig - Variable Gp.Config préexistante
     * @param {Object} data - la nouvelle réponse de l'autoconf, à fusionner avec GpConfig
     * @param {String} [layerId] - l'identifiant d'une couche agrégée dans le cas d'une 2è opération de l'autoconf
     */
    mergeConfig : function (GpConfig, data, layerId) {
        if (data && GpConfig) {
            // on boucle sur les propriétés (generalOptions, layers, projections, services, tileMatrixSets, territories)
            for (var prop in data) {
                if (data.hasOwnProperty(prop)) {
                    // on récupère la nouvelle clé dans generalOptions
                    if (prop === "generalOptions") {
                        for (var key in data[prop].apiKeys) {
                            if (data[prop].apiKeys.hasOwnProperty(key) && !GpConfig.generalOptions.apiKeys[key]) {
                                GpConfig.generalOptions.apiKeys[key] = data[prop].apiKeys[key];
                            }
                        }
                        // on récupère les nouveaux objets (TMS, layers, projections...)
                    } else {
                        if (GpConfig[prop]) {
                            for (var obj in data[prop]) {
                                if (data[prop].hasOwnProperty(obj) && !GpConfig[prop][obj]) {
                                    GpConfig[prop][obj] = data[prop][obj];
                                }
                            }
                        }
                    }
                }
            }

            // dans le cas d'une autoconf pour une couche agrégée, on récupère l'info
            if (layerId) {
                var aggregatedLayers = [];

                for (var lyr in data.layers) {
                    if (data.layers.hasOwnProperty(lyr)) {
                        aggregatedLayers.push(lyr);
                    }
                }

                if (GpConfig.layers[layerId]) {
                    GpConfig.layers[layerId].aggregatedLayers = aggregatedLayers;
                }
            }
        }
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AutoConfReponseFactory);


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Response_model_AutoConfResponse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);
/* harmony import */ var _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var _Response_model_Format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85);
/* harmony import */ var _Response_model_Layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86);
/* harmony import */ var _Response_model_Legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(87);
/* harmony import */ var _Response_model_Metadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88);
/* harmony import */ var _Response_model_Originator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(89);
/* harmony import */ var _Response_model_Service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(90);
/* harmony import */ var _Response_model_Style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(91);
/* harmony import */ var _Response_model_Territory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(92);
/* harmony import */ var _Response_model_Thematic__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(93);
/* harmony import */ var _Response_model_TileMatrixSet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(94);
/* harmony import */ var _Response_model_TileMatrix__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(95);
/* harmony import */ var _Response_model_TileMatrixLimit__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(96);

/**
 * Fonction retournant un objet contenant des clés de lecture (readers)
 *      qui permettent de parser des réponses XML du service d'autoconfiguration du Géoportail
 *      afin de récupérer les informations retournées.
 * @module AutoConfResponseReader
 * @private
 * @alias Gp.Services.AutoConf.Formats.AutoConfResponseReader
 */

// import Logger from "../../../Utils/LoggerByDefault";















var AutoConfResponseReader = {};

/**
 * version du service d'autoconf
 */
AutoConfResponseReader.VERSION = "1.1.0";

/**
 * Objet stockant les différents namespaces et les URI associées
 */
AutoConfResponseReader.NAMESPACES = {
    xmlns : "http://www.opengis.net/context",
    gpp : "http://api.ign.fr/geoportail", // FIXME remplacer par https://www.geoportail.gouv.fr/gpp
    ows : "http://www.opengis.net/ows/2.0",
    sld : "http://www.opengis.net/sld",
    wmts : "http://www.opengis.net/wmts/1.0",
    xlink : "http://www.w3.org/1999/xlink",
    xsi : "http://www.w3.org/2001/XMLSchema-instance"
};

/**
 * Localisation (URL) du schema de définition du XML (XSD)
 */
AutoConfResponseReader.SCHEMALOCATION = [
    "http://www.opengis.net/context http://wxs.ign.fr/schemas/extContext.xsd http://api.ign.fr/geoportail http://wxs.ign.fr/schemas/autoconf/autoconf.xsd",
    "http://www.opengis.net/context http://wxs.ign.fr/schemas/extContext.xsd http://api.ign.fr/geoportail http://wxs.ign.fr/schemas/autoconf.xsd"
];

/**
 * Namespace par défaut du format
 */
AutoConfResponseReader.DEFAULTPREFIX = "context";

/**
 * Objet contenant des fonctions de lecture, appelées "READERS"
 *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire
 *      et la valeur associée est une fonction (node, data)
 *      où node est un noeud du document DOM
 *      et data est un objet où l'on stocke les informations lues dans le XML.
 */
AutoConfResponseReader.READERS = {

    context : {

        /** ViewContext */
        ViewContext : function (viewContextNode) {
            // info : balise "racine" de la réponse de l'autoconf

            // vérification de la version du service, et des namespaces de l'en-tête
            __checkServiceAttributes(viewContextNode);

            // create AutoConfResponse
            var config = new _Response_model_AutoConfResponse__WEBPACK_IMPORTED_MODULE_0__["default"]();

            __getChildNodes(viewContextNode, config);

            return config;
        },

        // info : /General/Title
        // ou : /LayerList/Layer/Title
        /** Title */
        Title : function (titleNode, data) {
            if (data && data.generalOptions) { // cas de la variable config générale
                data.generalOptions.title = __getChildValue(titleNode);
            } else if (data && data.lyr) { // cas d'une layer
                data.lyr.title = __getChildValue(titleNode);
            }
        },

        // info : /LayerList/Layer/Abstract
        /** Abstract */
        Abstract : function (node, data) {
            if (data && data.lyr) {
                data.lyr.description = __getChildValue(node);
            }
        },

        // info : /General/Extension/gpp:General/gpp:Services/Server
        // ou : /LayerList/Server
        /** Server */
        Server : function (node, data) {
            var serverId = node.getAttribute("service");
            var title = node.getAttribute("title");
            var version = node.getAttribute("version");
            if (serverId) {
                if (data && data.services && typeof data.services === "object" && !data.services[serverId]) {
                    // on est dans la balise Services
                    var s = new _Response_model_Service__WEBPACK_IMPORTED_MODULE_7__["default"]();
                    s.title = title;
                    s.version = version;
                    // récupération de l'url du service, dans une balise enfant "OnlineResource"
                    __getChildNodes(node, s);
                    // ajout du service à la variable config
                    data.services[serverId] = s;
                } else if (data && data.lyr) {
                    // on est dans la balise Layer
                    if (!data.lyr.serviceParams) {
                        // si l'objet serviceParams n'a pas encore été créé, on le crée.
                        data.lyr.serviceParams = {};
                    }
                    data.lyr.serviceParams.id = serverId;
                    data.lyr.serviceParams.version = version;
                }
            }
        },

        // info : /General/Extension/gpp:General/gpp:Services/Server/OnlineResource
        // ou : /LayerList/Layer/Server/OnlineResource
        // ou : /LayerList/Layer/Extention/gpp:Layer/gpp:QuickLook/OnlineResource
        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend/gpp:LegendURL/OnlineResource
        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:MetadataURL/OnlineResource
        /** OnlineResource */
        OnlineResource : function (node, service) {
            if (service && service.hasOwnProperty("serverUrl")) {
                service.serverUrl = node.getAttribute("xlink:href");
            }
        },

        // info : /LayerList
        /** LayerList */
        LayerList : function (layerListNode, config) {
            // liste de balises "layer"
            __getChildNodes(layerListNode, config);

            if (config && config.layers && config.generalOptions && config.services) {
                // récupération des clés et des couches associées
                for (var lyr in config.layers) {
                    if (config.layers.hasOwnProperty(lyr)) {
                        var layerConfig = config.layers[lyr];

                        // récupération de la clé associée
                        var apiKeys = layerConfig.apiKeys;
                        if (apiKeys && Array.isArray(apiKeys)) {
                            for (var i = 0; i < apiKeys.length; i++) {
                                // pour chaque clé API, on ajoute la couche
                                var key = apiKeys[i];
                                if (config.generalOptions.apiKeys) {
                                    if (!config.generalOptions.apiKeys[key] || !Array.isArray(config.generalOptions.apiKeys[key])) {
                                        config.generalOptions.apiKeys[key] = [];
                                    }
                                    config.generalOptions.apiKeys[key].push(lyr);
                                }
                            }
                        }

                        // récupération du service associé
                        var serviceParams = layerConfig.serviceParams;
                        if (serviceParams && serviceParams.id) {
                            if (!config.services[serviceParams.id]) {
                                var s = new _Response_model_Service__WEBPACK_IMPORTED_MODULE_7__["default"]();
                                if (serviceParams.serverUrl) {
                                    s.serverUrl = serviceParams.serverUrl;
                                }
                                if (serviceParams.version) {
                                    s.version = serviceParams.version;
                                }
                                config.services[serviceParams.id] = s;
                            }
                        }

                        // récupération de la projection associée (dans le cas d'une couche WMTS)
                        if (layerConfig.wmtsOptions && layerConfig.wmtsOptions.tileMatrixSetLink && config.tileMatrixSets) {
                            var tmsLink = layerConfig.wmtsOptions.tileMatrixSetLink;
                            var tileMatrixSets = config.tileMatrixSets;
                            for (var tms in tileMatrixSets) {
                                if (tileMatrixSets.hasOwnProperty(tms) && tms === tmsLink) {
                                    layerConfig.defaultProjection = tileMatrixSets[tms].projection;
                                }
                            }
                        }
                    }
                }
            }
        },

        // info : /LayerList/Layer
        /** Layer */
        Layer : function (layerNode, config) {
            if (config && config.layers) {
                var lyrData = {
                    lyr : new _Response_model_Layer__WEBPACK_IMPORTED_MODULE_3__["default"](),
                    lyrId : null
                };

                var hidden = layerNode.getAttribute("hidden");
                if (hidden === "1") {
                    lyrData.lyr.hidden = true;
                } else {
                    lyrData.lyr.hidden = false;
                }

                var queryable = layerNode.getAttribute("queryable");
                if (queryable === "1") {
                    lyrData.lyr.queryable = true;
                } else {
                    lyrData.lyr.queryable = false;
                }

                // on peut avoir les balises : Server, Name, Title, Abstract, DataURL, MetadataURL,
                // sld:MinScaleDenominator, sld:MaxScaleDenominator, SRS, FormatList, StyleList
                // DimensionList, Extension
                __getChildNodes(layerNode, lyrData);

                // si on a bien récupéré l'identifiant de la couche, on s'en sert pour l'ajouter au tableau associatif des couches disponibles
                if (lyrData.lyrId) {
                    // Dans le cas des services, on modifie le contexte de l'identifiant.
                    if (lyrData.lyr.serviceParams && lyrData.lyr.serviceParams.id) {
                        var serviceid = lyrData.lyr.serviceParams.id;
                        if (serviceid.toUpperCase().indexOf("OPENLS") !== -1 || serviceid.toUpperCase().indexOf("ELEVATION") !== -1) {
                            // Il faut changer l'identifiant de la ressource.
                            var resourceId = lyrData.lyrId.split("$")[0];
                            lyrData.lyrId = resourceId + "$" + serviceid;
                        }
                    }

                    // on ajoute l'information dans les attributs de la couche
                    lyrData.lyr.layerId = lyrData.lyrId;
                    // et dans le tableau Gp.Config.layers
                    config.layers[lyrData.lyrId] = lyrData.lyr;
                }
            }
        },

        // info : /LayerList/Layer/Name
        /** TODO : jsdoc block */
        Name : function (node, lyrData) {
            if (lyrData && lyrData.lyr) {
                lyrData.lyr.name = __getChildValue(node);
            }
        },

        // info : /LayerList/Layer/SRS (dans le cas des couches WMS ou WFS)
        /** TODO : jsdoc block */
        SRS : function (node, lyrData) {
            // on récupère la projection de la couche (SRS)
            if (lyrData && lyrData.lyr) {
                lyrData.lyr.defaultProjection = __getChildValue(node);
            }
        },

        // info : /LayerList/Layer/FormatList/Format
        /** TODO : jsdoc block */
        Format : function (node, lyrData) {
            if (lyrData && lyrData.lyr) {
                var f = new _Response_model_Format__WEBPACK_IMPORTED_MODULE_2__["default"]();
                var current = node.getAttribute("current");
                if (current === "1") {
                    f.current = true;
                } else {
                    f.current = false;
                }
                f.name = __getChildValue(node);
                // si on n'a pas encore ajouté de format, on crée le tableau vide
                if (!lyrData.lyr.formats || !Array.isArray(lyrData.lyr.formats)) {
                    lyrData.lyr.formats = [];
                }
                lyrData.lyr.formats.push(f);
            }
        },

        // info : /LayerList/Layer/StyleList/Style
        /** TODO : jsdoc block */
        Style : function (node, lyrData) {
            if (lyrData && lyrData.lyr) {
                var s = new _Response_model_Style__WEBPACK_IMPORTED_MODULE_8__["default"]();
                var current = node.getAttribute("current");
                if (current === "1" || current === 1) {
                    s.current = true;
                } else {
                    s.current = false;
                }
                if (node.hasChildNodes) {
                    var children = node.childNodes;
                    var child;
                    var childName;
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE
                            childName = child.localName || child.baseName || child.nodeName;
                            if (childName === "Name") {
                                s.name = __getChildValue(child);
                            } else if (childName === "Title") {
                                s.title = __getChildValue(child);
                            } else if (childName === "URL") {
                                s.url = __getChildValue(child);
                            }
                        }
                    }
                }
                // si on n'a pas encore ajouté de style, on crée le tableau vide
                if (!lyrData.lyr.styles || !Array.isArray(lyrData.lyr.styles)) {
                    lyrData.lyr.styles = [];
                }
                lyrData.lyr.styles.push(s);
            }
        },

        // info : /LayerList/Layer/DimensionList/Dimension
        /** TODO : jsdoc block */
        Dimension : function (node, lyrData) {
            // possède des attributs obligatoires : name, units, unitSymbol et userValue
            // et d'autres attributs facultatifs : default, multipleValues, nearestValue, current
            var name = node.getAttribute("name");
            var dim = __getChildValue(node);
            if (lyrData && lyrData.lyr) {
                // si on n'a pas encore ajouté de dimension, on crée l'objet vide
                if (!lyrData.lyr.dimensions) {
                    lyrData.lyr.dimensions = {};
                }
                if (name === "Type") {
                    lyrData.lyr.dimensions.type = dim;
                } else if (name === "VisibilityRange") {
                    lyrData.lyr.dimensions.visibilityRange = dim;
                } else if (name === "VisibilityMode ") {
                    lyrData.lyr.dimensions.visibilityMode = dim;
                } else if (name === "GeometricType") {
                    lyrData.lyr.dimensions.geometricType = dim;
                } else if (name === "NoDataValue") {
                    lyrData.lyr.dimensions.noDataValue = dim;
                }
            }
        }

    },

    gpp : {

        // info : /General/Extension/gpp:General/gpp:Theme
        /** TODO : jsdoc block */
        Theme : function (themeNode, config) {
            if (config && config.generalOptions && config.generalOptions.hasOwnProperty("theme")) {
                config.generalOptions.theme = __getChildValue(themeNode);
            }
        },

        // info : /General/Extension/gpp:General/gpp:defaultGMLGFIStyleUrl
        /** TODO : jsdoc block */
        defaultGMLGFIStyleUrl : function (node, config) {
            if (config && config.generalOptions && config.generalOptions.hasOwnProperty("defaultGMLGFIStyle")) {
                config.generalOptions.defaultGMLGFIStyle = __getChildValue(node);
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory
        /** TODO : jsdoc block */
        Territory : function (territoryNode, config) {
            // info : Information to configure the API for this territory
            var tid = territoryNode.getAttribute("id");
            if (tid) {
                // create a new Territory
                var t = new _Response_model_Territory__WEBPACK_IMPORTED_MODULE_9__["default"]();

                var isDefault = territoryNode.getAttribute("default");
                if (isDefault === "1") {
                    t.isDefault = true;
                } else {
                    t.isDefault = false;
                }
                // read territory informations
                __getChildNodes(territoryNode, t);
                // add territory to config
                if (config && config.territories && typeof config.territories === "object") {
                    config.territories[tid] = t;
                }
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:defaultCRS
        /** TODO : jsdoc block */
        defaultCRS : function (node, territory) {
            // info : Identifier for the default Coordinate Reference System (CRS).
            if (territory && territory.hasOwnProperty("defaultCRS")) {
                territory.defaultCRS = __getChildValue(node);
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:AdditionalCRS
        // ou : /LayerList/Extension/gpp:Layer/gpp:AdditionalCRS
        /** TODO : jsdoc block */
        AdditionalCRS : function (node, data) {
            // info : Identifier for additional Coordinate Reference System (CRS).
            // info : data peut être une instance de Territory.js, ou une instance de Layer.js
            var addCRS = __getChildValue(node);
            if (addCRS && data) {
                if (Array.isArray(data.additionalCRS)) { // cas d'un territoire
                    data.additionalCRS.push(addCRS);
                } else { // cas d'une couche
                    // si le tableau n'est pas encore créé
                    if (!data.additionalProjections || !Array.isArray(data.additionalProjections)) {
                        data.additionalProjections = [];
                    }
                    data.additionalProjections.push(addCRS);
                }
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:DefaultLayer
        /** TODO : jsdoc block */
        DefaultLayer : function (node, territory) {
            var lyr = node.getAttribute("layerId");
            if (lyr && territory && Array.isArray(territory.defaultLayers)) {
                territory.defaultLayers.push(lyr);
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:BoundingBox
        // ou : /LayerList/Extension/gpp:Layer/gpp:BoundingBox
        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Constraints/gpp:Constraint/gpp:BoundingBox
        // ou : /LayerList/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/gpp:Constraint/gpp:BoundingBox
        /** TODO : jsdoc block */
        BoundingBox : function (node, data) {
            if (data) {
                var values = __getChildValue(node).split(",");
                if (values.length === 4) {
                    // get bbox coordinates (wgs84)
                    var bbox = {
                        left : parseFloat(values[0]),
                        right : parseFloat(values[2]),
                        top : parseFloat(values[3]),
                        bottom : parseFloat(values[1])
                    };
                    // get temporal extent params (constraint or layer)
                    var minT = node.getAttribute("minT");
                    var maxT = node.getAttribute("maxT");

                    if (data.hasOwnProperty("geoBBOX")) { // cas d'un territoire
                        data.geoBBOX = bbox;
                    } else if (data.hasOwnProperty("bbox")) { // cas d'une constraint
                        if (data.bbox.left || data.bbox.right || data.bbox.top || data.bbox.bottom) {
                            // si on a déjà une bbox, il faut stocker d'autres contraintes
                            if (!data.multiConstraints) {
                                data.multiConstraints = [];
                            }
                            var newConstraint = new _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__["default"]();
                            newConstraint.bbox = bbox;
                            newConstraint.temporalExtent = [minT, maxT];
                            data.multiConstraints.push(newConstraint);
                        } else {
                            // contrainte classique
                            data.bbox = bbox;
                            data.temporalExtent = [minT, maxT];
                        }
                    } else { // cas d'une layer
                        if (!data.globalConstraint) {
                            data.globalConstraint = new _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__["default"]();
                        }
                        data.globalConstraint.bbox = bbox;
                        data.globalConstraint.temporalExtent = [minT, maxT];
                    }
                }
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:Resolution
        /** TODO : jsdoc block */
        Resolution : function (node, territory) {
            // info : The default resolution to display on this territory, in CRS coordinate system
            var res = __getChildValue(node);
            if (res && territory && territory.defaultOptions && territory.defaultOptions.hasOwnProperty("resolution")) {
                territory.defaultOptions.resolution = parseFloat(res);
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:Center/gpp:x
        /** TODO : jsdoc block */
        x : function (node, territory) {
            var lon = __getChildValue(node);
            if (lon && territory && territory.geoCenter && territory.geoCenter.hasOwnProperty("lon")) {
                territory.geoCenter.lon = parseFloat(lon);
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:Center/gpp:y
        /** TODO : jsdoc block */
        y : function (node, territory) {
            var lat = __getChildValue(node);
            if (lat && territory && territory.geoCenter && territory.geoCenter.hasOwnProperty("lat")) {
                territory.geoCenter.lat = parseFloat(lat);
            }
        },

        // info : /General/Extension/gpp:General/gpp:Resolutions
        /** TODO : jsdoc block */
        Resolutions : function (resNode, config) {
            // info : List of resolutions in CRS:84 (comma separated values)
            if (config && config.generalOptions && config.generalOptions.hasOwnProperty("wgs84Resolutions")) {
                config.generalOptions.wgs84Resolutions = __getChildValue(resNode).split(",");
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer
        /** TODO : jsdoc block */
        Layer : function (node, lyrData) {
            // attributs : id, opacity, order, visibleInCatalog, aggregate, more
            if (lyrData && lyrData.hasOwnProperty("lyrId") && lyrData.lyr) {
                lyrData.lyrId = node.getAttribute("id");
                var aggregate = node.getAttribute("aggregate");
                var more = node.getAttribute("more");
                if (aggregate || more) {
                    lyrData.lyr.isAggregate = true;
                }
                __getChildNodes(node, lyrData.lyr);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Constraints/gpp:Constraint
        // ou : /LayerList/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/gpp:Constraint
        /** TODO : jsdoc block */
        Constraint : function (node, data) {
            var c = new _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__["default"]();
            __getChildNodes(node, c);
            if (data) {
                // on peut être dans le cas d'un originator ou d'une layer, tous les deux ont l'attribut constraints
                if (!data.constraints || !Array.isArray(data.constraints)) {
                    data.constraints = [];
                }

                // cas de plusieurs contraintes (par ex différents territoires)
                if (c.multiConstraints && Array.isArray(c.multiConstraints)) {
                    // on récupère la première contrainte, stockée normalement
                    var constraint = new _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__["default"]();
                    constraint.crs = c.crs;
                    constraint.bbox = c.bbox;
                    constraint.minScaleDenominator = c.minScaleDenominator;
                    constraint.maxScaleDenominator = c.maxScaleDenominator;
                    constraint.temporalExtent = c.temporalExtent;
                    data.constraints.push(constraint);

                    // puis on récupère les autres contraintes, à partir de multiConstraints
                    for (var i = 0; i < c.multiConstraints.length; i++) {
                        constraint = new _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__["default"]();
                        constraint.crs = c.crs;
                        constraint.minScaleDenominator = c.minScaleDenominator;
                        constraint.maxScaleDenominator = c.maxScaleDenominator;
                        constraint.bbox = c.multiConstraints[i].bbox;
                        constraint.temporalExtent = c.multiConstraints[i].temporalExtent;
                        data.constraints.push(constraint);
                    }
                } else {
                    // cas d'une contrainte classique
                    data.constraints.push(c);
                }
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/gpp:Constraint/gpp:CRS
        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Constraints/gpp:Constraint/gpp:CRS
        /** TODO : jsdoc block */
        CRS : function (node, data) {
            // nothing to do.
            if (data && data.hasOwnProperty("crs")) {
                data.crs = __getChildValue(node);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Thematics/gpp:Thematic
        /** TODO : jsdoc block */
        Thematic : function (node, lyr) {
            if (lyr) {
                var t = new _Response_model_Thematic__WEBPACK_IMPORTED_MODULE_10__["default"]();
                t.inspire = false;
                t.name = __getChildValue(node);
                // si aucune thématique n'a été ajoutée, on crée le tableau vide
                if (!lyr.thematics || !Array.isArray(lyr.thematics)) {
                    lyr.thematics = [];
                }
                lyr.thematics.push(t);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Thematics/gpp:InspireThematic
        /** TODO : jsdoc block */
        InspireThematic : function (node, lyr) {
            if (lyr) {
                var t = new _Response_model_Thematic__WEBPACK_IMPORTED_MODULE_10__["default"]();
                t.inspire = true;
                t.name = __getChildValue(node);
                // si aucune thématique n'a été ajoutée, on crée le tableau vide
                if (!lyr.thematics || !Array.isArray(lyr.thematics)) {
                    lyr.thematics = [];
                }
                lyr.thematics.push(t);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator
        /** TODO : jsdoc block */
        Originator : function (node, lyr) {
            if (lyr) {
                // info : contient des balises Attribution, Logo, URL, et Constraints
                var o = new _Response_model_Originator__WEBPACK_IMPORTED_MODULE_6__["default"]();
                o.name = node.getAttribute("name");
                __getChildNodes(node, o);
                // si aucun originator n'a été ajouté, on crée le tableau vide
                if (!lyr.originators || !Array.isArray(lyr.originators)) {
                    lyr.originators = [];
                }
                lyr.originators.push(o);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Attribution
        /** TODO : jsdoc block */
        Attribution : function (node, originator) {
            if (originator && originator.hasOwnProperty("attribution")) {
                originator.attribution = __getChildValue(node);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Logo
        /** TODO : jsdoc block */
        Logo : function (node, originator) {
            if (originator && originator.hasOwnProperty("logo")) {
                originator.logo = __getChildValue(node);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:URL
        /** TODO : jsdoc block */
        URL : function (node, originator) {
            if (originator && originator.hasOwnProperty("url")) {
                originator.url = __getChildValue(node);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend
        /** TODO : jsdoc block */
        Legend : function (node, lyr) {
            // 2 balises : sld:MinScaleDenominator et gpp:LegendURL
            var l = new _Response_model_Legend__WEBPACK_IMPORTED_MODULE_4__["default"]();
            __getChildNodes(node, l);
            if (lyr) {
                // si aucune légende n'a encore été ajoutée, on crée le tableau vide
                if (!lyr.legends || !Array.isArray(lyr.legends)) {
                    lyr.legends = [];
                }
                lyr.legends.push(l);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend/gpp:LegendURL
        /** TODO : jsdoc block */
        LegendURL : function (node, legend) {
            if (legend && legend.hasOwnProperty("format")) {
                legend.format = node.getAttribute("format");
                if (node.hasChildNodes) {
                    var child = node.childNodes[0];
                    var childName = child.localName || child.baseName || child.nodeName;
                    if (childName === "OnlineResource" && legend.hasOwnProperty("url")) {
                        legend.url = child.getAttribute("xlink:href");
                    }
                }
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:QuickLook
        /** TODO : jsdoc block */
        QuickLook : function (node, lyr) {
            // info : contient une balise OnlineResource avec l'url dans l'attribut "xlink:href"
            if (node.hasChildNodes) {
                var child = node.childNodes[0];
                var childName = child.localName || child.baseName || child.nodeName;
                if (childName === "OnlineResource" && lyr) {
                    lyr.quicklookUrl = child.getAttribute("xlink:href");
                }
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:MetadataURL
        /** TODO : jsdoc block */
        MetadataURL : function (node, lyr) {
            if (lyr) {
                // info : contient une balise OnlineResource avec l'url dans l'attribut "xlink:href"
                var m = new _Response_model_Metadata__WEBPACK_IMPORTED_MODULE_5__["default"]();
                m.format = node.getAttribute("format");
                if (node.hasChildNodes) {
                    var child = node.childNodes[0];
                    var childName = child.localName || child.baseName || child.nodeName;
                    if (childName === "OnlineResource") {
                        m.url = child.getAttribute("xlink:href");
                    }
                }
                // si aucune metadata n'a été ajoutée, on crée le tableau vide
                if (!lyr.metadata) {
                    lyr.metadata = [];
                }
                lyr.metadata.push(m);
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Keys/gpp:Key
        /** TODO : jsdoc block */
        Key : function (node, lyr) {
            if (lyr) {
                // récupération de la clé API
                var key = node.getAttribute("id");
                // si on n'a pas encore ajouté de clé, on crée le tableau vide
                if (!lyr.apiKeys || !Array.isArray(lyr.apiKeys)) {
                    lyr.apiKeys = [];
                }
                lyr.apiKeys.push(key);

                // récupération de l'url du service avec la clé API
                var serverUrl = __getChildValue(node);
                if (!lyr.serviceParams) {
                    lyr.serviceParams = {};
                }
                if (!lyr.serviceParams.serverUrl) {
                    lyr.serviceParams.serverUrl = {};
                }
                if (!lyr.serviceParams.serverUrl[key]) {
                    lyr.serviceParams.serverUrl[key] = serverUrl;
                }
            }
        }

    },

    ows : {
        /** TODO : jsdoc block */
        Identifier : function (node, data) {
            if (data && data.hasOwnProperty("TMS")) { // dans le cas d'un TileMatrixSet
                data.identifier = __getChildValue(node);
            } else if (data && data.hasOwnProperty("matrixId")) { // dans le cas d'une TileMatrix
                data.matrixId = __getChildValue(node);
            }
        },

        /** TODO : jsdoc block */
        SupportedCRS : function (node, tmsData) {
            if (tmsData && tmsData.TMS && tmsData.TMS.hasOwnProperty("projection")) {
                tmsData.TMS.projection = __getChildValue(node);
            }
        }
    },

    sld : {
        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/sld:MinScaleDenominator
        // ou : /LayerList/Layer/sld:MinScaleDenominator
        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/sld:MinScaleDenominator
        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend/sld:MinScaleDenominator
        /** TODO : jsdoc block */
        MinScaleDenominator : function (node, data) {
            var minScale = __getChildValue(node);
            if (minScale && data) {
                if (data.hasOwnProperty("defaultOptions")) { // cas d'un territoire
                    data.defaultOptions.minScaleDenominator = parseFloat(minScale);
                } else if (data.lyr) { // cas d'une layer
                    if (!data.lyr.globalConstraint) {
                        data.lyr.globalConstraint = new _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__["default"]();
                    }
                    data.lyr.globalConstraint.minScaleDenominator = parseFloat(minScale);
                } else if (data.hasOwnProperty("minScaleDenominator")) { // cas d'une contrainte ou d'une légende
                    data.minScaleDenominator = parseFloat(minScale);
                }
            }
        },

        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/sld:MaxScaleDenominator
        // ou : /LayerList/Layer/sld:MaxScaleDenominator
        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/sld:MaxScaleDenominator
        /** TODO : jsdoc block */
        MaxScaleDenominator : function (node, data) {
            var maxScale = __getChildValue(node);
            if (maxScale && data) {
                if (data.hasOwnProperty("defaultOptions")) { // cas d'un territoire
                    data.defaultOptions.maxScaleDenominator = parseFloat(maxScale);
                } else if (data.lyr) { // cas d'une layer
                    if (!data.lyr.globalConstraint) {
                        data.lyr.globalConstraint = new _Response_model_Constraint__WEBPACK_IMPORTED_MODULE_1__["default"]();
                    }
                    data.lyr.globalConstraint.maxScaleDenominator = parseFloat(maxScale);
                } else if (data.hasOwnProperty("maxScaleDenominator")) { // cas d'une contrainte
                    data.maxScaleDenominator = parseFloat(maxScale);
                }
            }
        }
    },

    wmts : {

        // info : /LayerList/Layer/Extension/gpp:Layer/wmts:TileMatrixSetLink/wmts:TileMatrixSetLimits
        /** TODO : jsdoc block */
        TileMatrixSetLimits : function (node, lyr) {
            // info : contient des balises wmts:TileMatrixLimits
            if (lyr) {
                var limits = {};
                // on récupère les limites dans les balises TileMatrixLimits
                __getChildNodes(node, limits);

                if (!lyr.wmtsOptions) {
                    lyr.wmtsOptions = {};
                }
                lyr.wmtsOptions.tileMatrixSetLimits = limits;
            }
        },

        // info : /LayerList/Layer/Extension/gpp:Layer/wmts:TileMatrixSetLink/wmts:TileMatrixSetLimits/wmts:TileMatrixLimits
        /** TODO : jsdoc block */
        TileMatrixLimits : function (node, limits) {
            var limit = new _Response_model_TileMatrixLimit__WEBPACK_IMPORTED_MODULE_13__["default"]();
            var limitId;
            if (node.hasChildNodes) {
                var children = node.childNodes;
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    var childName = child.localName || child.baseName || child.nodeName;
                    if (childName === "TileMatrix") {
                        limitId = __getChildValue(child);
                    } else if (childName === "MinTileRow") {
                        limit.minTileRow = __getChildValue(child);
                    } else if (childName === "MaxTileRow") {
                        limit.maxTileRow = __getChildValue(child);
                    } else if (childName === "MinTileCol") {
                        limit.minTileCol = __getChildValue(child);
                    } else if (childName === "MaxTileCol") {
                        limit.maxTileCol = __getChildValue(child);
                    }
                }
                if (limitId && limits && !limits[limitId]) {
                    limits[limitId] = limit;
                }
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet
        // ou : // info : /LayerList/Layer/Extension/gpp:Layer/wmts:TileMatrixSetLink/wmts:TileMatrixSet
        /** TODO : jsdoc block */
        TileMatrixSet : function (node, data) {
            // info : Describes a particular set of tile matrices.

            if (data && data.tileMatrixSets) { // les tileMatrixSets de General
                // nouvel objet TileMatrixSet
                var tmsData = {};
                tmsData.TMS = new _Response_model_TileMatrixSet__WEBPACK_IMPORTED_MODULE_11__["default"]();
                tmsData.resolutions = [];

                // lecture des informations du TMS
                __getChildNodes(node, tmsData);

                // récupération des identifiants des niveaux de matrice (pour faciliter l'accès au WMTS via les API carto)
                var tileMatrices = tmsData.TMS.tileMatrices;
                for (var tm in tileMatrices) {
                    if (tileMatrices.hasOwnProperty(tm)) {
                        tmsData.TMS.matrixIds.push(tm);
                    }
                }

                if (tmsData.TMS.getProjection() === "IGNF:WGS84G" || tmsData.TMS.getProjection() === "EPSG:4326") {
                    if (data.generalOptions && Array.isArray(data.generalOptions.wgs84Resolutions)) {
                        var wgs84Resolutions = data.generalOptions.wgs84Resolutions;
                        for (var i = 0; i < wgs84Resolutions.length; i++) {
                            // info : les résolutions stockées dans wgs84Resolutions, issues de l'autoconf, sont des string
                            tmsData.resolutions[i] = parseFloat(wgs84Resolutions[i]);
                        }
                    }
                }

                // tri des résolutions (par ordre décroissant cette fois)
                if (Array.isArray(tmsData.resolutions) && tmsData.resolutions.sort !== undefined) {
                    tmsData.resolutions.sort(
                        function (x, y) {
                            return y - x;
                        }
                    );
                }
                tmsData.TMS.nativeResolutions = tmsData.resolutions;

                // ajout du TileMatrixSet à la variable config
                data.tileMatrixSets[tmsData.identifier] = tmsData.TMS;
            } else { // le TileMatrixSetLink d'une couche (layer)
                if (data && !data.wmtsOptions) {
                    data.wmtsOptions = {};
                }
                // ajout du lien vers le TMS
                data.wmtsOptions.tileMatrixSetLink = __getChildValue(node);
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix
        /** TODO : jsdoc block */
        TileMatrix : function (node, tmsData) {
            // info : Describes a particular tile matrix.

            if (tmsData) {
                // nouveau niveau de matrice : TileMatrix
                var tileMatrix = new _Response_model_TileMatrix__WEBPACK_IMPORTED_MODULE_12__["default"]();

                // lecture des information du TileMatrix
                __getChildNodes(node, tileMatrix);

                // calcul de la résolution associée au dénominateur d'échelle du niveau de pyramide, selon la projection.
                if (tmsData.TMS && tmsData.TMS.getProjection()) {
                    var proj = tmsData.TMS.getProjection();
                    if (proj === "EPSG:3857" || proj === "EPSG:2154") {
                        // calcul de la résolution associée, en m/px
                        // en se basant sur une "taille standard de pixel" de 0.28mm*0.28mm (standard WMTS 1.0)
                        var r = tileMatrix.scaleDenominator * 0.00028;
                        if (tmsData.resolutions && Array.isArray(tmsData.resolutions)) {
                            tmsData.resolutions.push(r);
                        }
                    }
                }

                // ajout du TileMatrix au TileMatrixSet
                if (tmsData.TMS && tmsData.TMS.tileMatrices) {
                    tmsData.TMS.tileMatrices[tileMatrix.matrixId] = tileMatrix;
                }
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:ScaleDenominator
        /** TODO : jsdoc block */
        ScaleDenominator : function (node, tileMatrix) {
            var scale = __getChildValue(node);
            if (scale && tileMatrix && tileMatrix.hasOwnProperty("scaleDenominator")) {
                tileMatrix.scaleDenominator = parseFloat(scale);
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:TopLeftCorner
        /** TODO : jsdoc block */
        TopLeftCorner : function (node, tileMatrix) {
            var values = __getChildValue(node).split(" ");
            if (values && tileMatrix) {
                tileMatrix.topLeftCorner = {};
                tileMatrix.topLeftCorner.x = parseFloat(values[0]);
                tileMatrix.topLeftCorner.y = parseFloat(values[1]);
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:TileWidth
        /** TODO : jsdoc block */
        TileWidth : function (node, tileMatrix) {
            var value = __getChildValue(node);
            if (value && tileMatrix && tileMatrix.hasOwnProperty("tileWidth")) {
                tileMatrix.tileWidth = parseInt(value, 10);
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:TileHeight
        /** TODO : jsdoc block */
        TileHeight : function (node, tileMatrix) {
            var value = __getChildValue(node);
            if (value && tileMatrix && tileMatrix.hasOwnProperty("tileHeight")) {
                tileMatrix.tileHeight = parseInt(value, 10);
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:MatrixWidth
        /** TODO : jsdoc block */
        MatrixWidth : function (node, tileMatrix) {
            var value = __getChildValue(node);
            if (value && tileMatrix && tileMatrix.hasOwnProperty("matrixWidth")) {
                tileMatrix.matrixWidth = parseInt(value, 10);
            }
        },

        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:MatrixHeight
        /** TODO : jsdoc block */
        MatrixHeight : function (node, tileMatrix) {
            var value = __getChildValue(node);
            if (value && tileMatrix && tileMatrix.hasOwnProperty("matrixHeight")) {
                tileMatrix.matrixHeight = parseInt(value, 10);
            }
        }
    },

    /** TODO : jsdoc block */
    serviceException : function (node) {
        var response = {};
        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                if (child.nodeName === "exception") {
                    response.exceptionReport = AutoConfResponseReader.READERS["exception"](child);
                }
            }
        }
        return response;
    },

    /** TODO : jsdoc block */
    exception : function (node) {
        var exceptionReport = {};

        // get exception code
        var exceptionCode = node.getAttribute("code");
        if (exceptionCode) {
            exceptionReport.exceptionCode = exceptionCode;
        }

        // get exception message
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            exceptionReport.exception = textNode.nodeValue;
        }

        return exceptionReport;
    }

};

/**
 * Méthode permettant de lancer la lecture d'une réponse XML du service d'autoconf,
 *      à l'aide des READERS de la classe.
 *
 * @method AutoConfResponseReader.read
 * @param {DOMElement} root - racine de la réponse XML à lire
 * @return {Object} config|exceptionReport : l'objet contenant les informations de la réponse XML,
 *      sous la forme d'un objet AutoConfResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.
 * @static
 * @memberof AutoConfResponseReader
 */
AutoConfResponseReader.read = function (root) {
    if (root.nodeName === "ViewContext") {
        var nsPrefix = root.prefix || AutoConfResponseReader.DEFAULTPREFIX;
        var config = AutoConfResponseReader.READERS[nsPrefix][root.nodeName](root);
        return config;
    } else if (root.nodeName === "serviceException") {
        var exceptionReport = AutoConfResponseReader.READERS[root.nodeName](root);
        return exceptionReport;
    } else {
        throw new Error("Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.");
    }
};

/**
 * Récupération des attributs d'un noeud élément
 *
 * @private
 * @memberof AutoConfResponseReader
 * @method __getAttributes
 * @param {DOMElement} node - noeud contenant l'attribut recherché
 * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs
 */
function __getAttributes (node) {
    if (node.attributes.length > 0) {
        var nodeAttributes = {};
        var attributes = node.attributes;
        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            nodeAttributes[attribute.nodeName] = attribute.nodeValue;
        }
        return nodeAttributes;
    }
}

/**
 * Récupération des noeuds enfants (seulement de type ELEMENT), à partir d'un noeud donné, pour lecture (readNode).
 *
 * @private
 * @memberof AutoConfResponseReader
 * @method __getChildNodes
 * @param {DOMElement} node - a DOM node
 * @param {Array|Object} [data] - an object to be filled with node data
 */
function __getChildNodes (node, data) {
    if (node.hasChildNodes()) {
        var children = node.childNodes;
        var child;
        var childName;
        var childPrefix;

        for (var i = 0; i < children.length; i++) {
            child = children[i];

            if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE
                childName = child.localName || child.baseName || child.nodeName;
                childPrefix = child.prefix || AutoConfResponseReader.DEFAULTPREFIX;

                if (AutoConfResponseReader.READERS[childPrefix][childName]) {
                    var reader = AutoConfResponseReader.READERS[childPrefix][childName];
                    reader(child, data);
                } else {
                    __getChildNodes(child, data);
                }
            }
        }
    }
}

/**
 * Lecture de la valeur du premier child d'un noeud, si elle existe.
 *
 * @private
 * @memberof AutoConfResponseReader
 * @method __getChildValue
 * @param {DOMElement} node - a DOM node
 * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.
 */
function __getChildValue (node) {
    var textNode;
    var value = "";

    if (node.hasChildNodes()) {
        textNode = node.firstChild;
        if (textNode.nodeType === 3 || textNode.nodeType === 4) { // 3 === node.TEXT_NODE
            value = textNode.nodeValue;
        }
    }
    return value;
}

/**
 * Vérification des attributs du service, dans la balise XLS de la réponse :
 *      version, namespaces, et namespace par défaut doivent correspondre à ceux attendus.
 *
 * @private
 * @memberof AutoConfResponseReader
 * @method __checkServiceAttributes
 * @param {DOMElement} viewContextNode - a DOM node, corresponding to XLS first tag.
 */
function __checkServiceAttributes (viewContextNode) {
    if (viewContextNode.attributes.length > 0) {
        // on récupère et parcourt les attributs de la balise XLS de la réponse
        var xlsAttributes = __getAttributes(viewContextNode);
        for (var att in xlsAttributes) {
            if (xlsAttributes.hasOwnProperty(att)) {
                // vérification de la version
                if (att === "version") {
                    if (xlsAttributes["version"] !== AutoConfResponseReader.VERSION) {
                        console.log("[AutoConfResponseReader] autoconf version is not the expected one : there may be errors in parsing");
                        return;
                    }
                }

                // on vérifie que l'uri du namespace par défaut est bien celle que l'on attend
                if (att === "xmlns") {
                    if (xlsAttributes[att] !== AutoConfResponseReader.NAMESPACES.xmlns) {
                        console.log("[AutoConfResponseReader] autoconf response default namespace is not the expected one");
                        return;
                    }
                    continue;
                }

                var prefix = att.split(":")[0];
                var ns = att.split(":")[1];

                // si on a un autre xmlns, on vérifie aussi les URI
                if (prefix === "xmlns" && ns) {
                    // si l'attribut correspond à un namespace défini dans le reader
                    if (AutoConfResponseReader.NAMESPACES[ns]) {
                        // il faut que les URI correspondent aussi.
                        if (AutoConfResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {
                            console.log("[AutoConfResponseReader] autoconf response " + att + " namespace is not the expected one");
                            return;
                        }
                    }
                }

                // pour finir on vérifie la localisation du schema XSD du service
                if (ns === "schemaLocation") {
                    if (xlsAttributes[att] !== AutoConfResponseReader.SCHEMALOCATION[0] && xlsAttributes[att] !== AutoConfResponseReader.SCHEMALOCATION[1]) {
                        console.log("[AutoConfResponseReader] autoconf response schema location is not the expected one");
                        return;
                    }
                }
            }
        }
    }
}

/* harmony default export */ __webpack_exports__["default"] = (AutoConfResponseReader);


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Response object for {@link module:Services~getConfig Gp.Services.getConfig ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Object} generalOptions - General properties for default map configuration resources.
 * @property {Object} generalOptions.apiKeys - Object that associates apiKey (s) with an array of resources IDs availables with that key.
 * @property {String} generalOptions.title - Underlying web service Title.
 * @property {String} generalOptions.defaultGMLGFIStyle - XSL URL used by default to translate an XML GetFeatureInfo response into an HTML array.
 * @property {String} generalOptions.theme - default theme (FIXME : for what ?)
 * @property {Array.<Float>} generalOptions.wgs84Resolutions - geographical resolutions Array for each [zoom level of the Geoportal platform]{@link http://api.ign.fr/tech-docs-js/webmaster/layers.html#Geoportal_resolutions} from 0 to 21. Expressed in degrees/pixel.
 * @property {Object} layers - Associative array mapping resources availables IDs (keys) with their properties (values given as {@link Gp.Services.Config.Layer}).
 * @property {Object} territories - Associative array mapping french territories IDs (keys) with their properties (values given as {@link Gp.Services.Config.Territory}).
 * @property {Object} tileMatrixSets - Associative Array mapping TileMatrixSets IDs (keys) availables with their properties (values given as {@link Gp.Services.Config.TileMatrixSet}).
 * @property {Object} services - Associative Array mapping Geoportal web services IDs (keys) availables with their properties (values given as {@link Gp.Services.Config.Service}).
 *
 * @namespace
 * @alias Gp.Services.GetConfigResponse
 */
function AutoConfResponse () {
    if (!(this instanceof AutoConfResponse)) {
        throw new TypeError("AutoConfResponse constructor cannot be called as a function.");
    }

    this.generalOptions = {
        apiKeys : {},
        title : null,
        defaultGMLGFIStyle : null,
        theme : null,
        wgs84Resolutions : []
    };

    this.layers = {};

    this.territories = {};

    this.tileMatrixSets = {};

    this.services = {};
}

AutoConfResponse.prototype = {

    /*
     * Constructor (alias)
     */
    constructor : AutoConfResponse,

    /**
     * Check if config is loaded for a given key
     *
     * @param {String} apiKey - Access key to Geoportal platform
     * @returns {Boolean} isConfLoaded - true if config is already loaded, false otherwise
     */
    isConfLoaded : function (apiKey) {
        if (!apiKey) {
            return;
        }
        if (this.generalOptions.apiKeys[apiKey]) {
            return true;
        }
        return false;
    },

    /**
     * Returns an array of Geoportal layers identifiers, corresponding to an API contract key.
     *
     * @param {String} apiKey - Access key to Geoportal platform
     * @returns {Array} apiKeys - Array of geoportal layers identifiers
     */
    getLayersId : function (apiKey) {
        return this.generalOptions.apiKeys[apiKey];
    },

    /**
     * Returns an associative array of Geoportal layers configurations, corresponding to an API contract key.
     * If no key is specified, all layers from configuration are returned.
     *
     * @param {String} apiKey - Access key to Geoportal platform
     * @returns {Object} layers - Object which properties are layers identifiers, and corresponding
     *      values are instances of <Gp.Services.Config.Layer>.
     */
    getLayersConf : function (apiKey) {
        var layers = {};
        var layersIdArray = this.getLayersId(apiKey);
        if (layersIdArray) {
            for (var i = 0; i < layersIdArray.length; i++) {
                var lyrId = layersIdArray[i];
                layers[lyrId] = this.layers[lyrId];
            }
        }
        return layers;
    },

    /**
     * Returns a geoportal layer configuration, given its identifier
     *
     * @param {String} layerId - Geoportal layer identifier (e.g. "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
     * @return {Object} layer - Layer configuration : instance of {@link Gp.Services.Config.Layer}
     */
    getLayerConf : function (layerId) {
        if (!this.layers) {
            return;
        }
        return this.layers[layerId];
    },

    /**
     * Returns an associative array of Tile Matrix Sets configurations.
     *
     * @return {Object} tileMatrixSets - Object which properties are TMS identifiers,
     *      and corresponding values are instances of {@link Gp.Services.Config.TileMatrixSet}.
     */
    getTileMatrixSets : function () {
        return this.tileMatrixSets;
    },

    /**
     * Returns a Tile Matrix Sets configuration, given its identifier.
     *
     * @param {String} tmsID - Tile Matrix Set identifier (e.g. : "PM")
     * @return {Object} tileMatrixSet - Tile Matrix Set configuration, instance of {@link Gp.Services.Config.TileMatrixSet}
     */
    getTMSConf : function (tmsID) {
        if (!this.tileMatrixSets) {
            return;
        }
        return this.tileMatrixSets[tmsID];
    },

    /**
     * Returns an associative array of territories configurations.
     *
     * @return {Object} territories - Object which properties are territory identifiers,
     *      and corresponding values are instances of {@link Gp.Services.Config.Territory}.
     */
    getTerritories : function () {
        return this.territories;
    },

    /**
     * Returns a territory configuration, given its identifier.
     *
     * @param {String} territoryID - territory identifier (e.g. "FXX")
     * @return {Object} territory - Territory configuration, instance of {@link Gp.Services.Config.Territory}
     */
    getTerritoryConf : function (territoryID) {
        if (!this.territories) {
            return;
        }
        return this.territories[territoryID];
    },

    /**
     * Returns an associative array of services configurations.
     *
     * @return {Object} services - Object which properties are services identifiers,
     *      and corresponding values are instances of {@link Gp.Services.Config.Service}.
     */
    getServices : function () {
        return this.services;
    },

    /**
     * Returns a service configuration, given its identifier.
     *
     * @param {String} serviceID - service identifier (e.g. "OGC:WMTS")
     * @return {Object} service - service configuration, instance of {@link Gp.Services.Config.Service}
     */
    getServiceConf : function (serviceID) {
        if (!this.services) {
            return;
        }
        return this.services[serviceID];
    }

};

/* harmony default export */ __webpack_exports__["default"] = (AutoConfResponse);


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 *
 * Object used to express a geographical (BBOX, scale) and temporal constraint.
 *
 * @property {String} crs - Coordinates System ID used to express coordinates contraints.
 * @property {Gp.BBox} bbox - Constraint Bounding Box.
 * @property {Number} minScaleDenominator - Minimum scale denominator where constraint applies.
 * @property {Number} maxScaleDenominator - Maximum scale denominator where constraint applies.
 * @property {Array.<String>} temporalExtent - Array expressing the time interval of the constraint [minT, maxT]. Dates are expressed in the [ISO-8601]{@link https://en.wikipedia.org/wiki/ISO_8601} way.
 *
 * @namespace
 * @alias Gp.Services.Config.Constraint
 */

function Constraint () {
    if (!(this instanceof Constraint)) {
        throw new TypeError("Constraint constructor cannot be called as a function.");
    }

    this.crs = null;

    this.bbox = {
        left : null,
        right : null,
        top : null,
        bottom : null
    };

    this.minScaleDenominator = null;

    this.maxScaleDenominator = null;

    this.temporalExtent = [null, null];
}

Constraint.prototype = {

    constructor : Constraint

};

/* harmony default export */ __webpack_exports__["default"] = (Constraint);


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a format to use with Geoportal resources.
 *
 * @property {Boolean} current - If true, then this format is used by default.
 * @property {String} name - Format mime-type.
 *
 * @namespace
 * @alias Gp.Services.Config.Format
 */

function Format () {
    if (!(this instanceof Format)) {
        throw new TypeError("Format constructor cannot be called as a function.");
    }

    this.current = null;

    this.name = null;
}

Format.prototype = {

    constructor : Format

};

/* harmony default export */ __webpack_exports__["default"] = (Format);


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe geoportal resource (WMTS, WMS, WFS layers, geocoding resources or elevation service) parameters. Properties may be used or not depending on the resource type.
 *
 * @property {String} name - name of the resource to use with the webservice that serves it (eg : "GEOGRAPHICALGRIDSYSTEMS.MAPS").
 * @property {String} title - Human readable name for the resource.
 * @property {String} description - Resource description.
 * @property {String} layerId - Unique resource Identifier (eg : "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
 * @property {String} quicklookUrl - Image URL for the resource.
 * @property {Object} serviceParams - Informations about the webservice that serves the resource (OpenLS, WFS, WMTS)
 * @property {String} serviceParams.id - Web Service identifier ("OGC:WMTS", "OGC:OPENLS;ReverseGeocode", etc...)
 * @property {Object} serviceParams.serverUrl - Associative array mapping geoportal access key (keys) with their properties (URLs of the web service, with the geoportal access key).
 * @property {String} serviceParams.version - webservice version.
 * @property {String} defaultProjection - coordinates system ID used by default for the resource (WMS or WFS layer) or of the TileMatrixSet used by the WMTS layer.
 * @property {Array.<String>} additionalProjections - additional coordinates systems IDs availables for the resource, others than the default one (see defaultProjection) (WMS and WFS layers only).
 * @property {Array.<Gp.Services.Config.Format>} formats - Formats availables for the resource.
 * @property {Array.<Gp.Services.Config.Legend>} legends - Informations about legends associated to the resource.
 * @property {Array.<Gp.Services.Config.Metadata>} metadata - Informations about metadata associated to the resource.
 * @property {Array.<Gp.Services.Config.Style>} styles - Informations about styles availables for the resources (WMS, WFS and WMTS only).
 * @property {Array.<Gp.Services.Config.Thematic>} thematics - Informations about thematics associated to the resource.
 * @property {Gp.Services.Config.Constraint} globalConstraint - geographical constraint for the resource.
 * @property {Array.<Gp.Services.Config.Constraint>} constraints - additionnal geographical constraints for the resource.
 * @property {Array.<Gp.Services.Config.Originator>} originators - Informations about originator of the resource.
 * @property {Object} wmtsOptions - Informations associated to WMTS resources.
 * @property {String} wmtsOptions.tileMatrixSetLink - TileMatrixSet identifier used by the resource (see {@link Gp.Services.Config.TileMatrixSet})
 * @property {Gp.Services.Config.TileMatrixLimit} wmtsOptions.tileMatrixSetLimits - limits of the resource for that TileMAtrixSet.
 * @property {Boolean} queryable - true if a getFeatureInfo request may be done for the resource (WMS or WMTS only).
 * @property {Boolean} hidden - true if the resource is not visible.
 * @property {Boolean} isAggregate - true if the resource is an aggregate of other resources (@see aggregatedLayers).
 * @property {Array.<String>} aggregatedLayers - Layers IDs composing the being described aggregated layer.
 * @property {Array.<String>} apiKeys - Array of access keys that grant access to that resource.
 * @property {Object} dimensions - Dimensions informations associated with the resource.
 * @property {String} dimensions.type
 * @property {String} dimensions.visibilityRange
 * @property {String} dimensions.visibilityMode
 * @property {String} dimensions.noDataValue
 * @property {String} dimensions.geometricType
 *
 * @namespace
 * @alias Gp.Services.Config.Layer
 */
function Layer () {
    if (!(this instanceof Layer)) {
        throw new TypeError("Layer constructor cannot be called as a function.");
    }

    // info : une instance de la classe Layer n'a aucune propriété au départ,.
    // les attributs possibles sont documentés ci-dessus,
    // et seront implémentés au fur et à mesure de la lecture de la réponse de l'autoconf, lorsque l'information est rencontrée.
}

Layer.prototype = {

    constructor : Layer,

    /**
     * Returns the layer name
     *
     * @returns {String} name - name of the resource to use with the webservice that serves it (eg : "GEOGRAPHICALGRIDSYSTEMS.MAPS").
     */
    getName : function () {
        return this.name;
    },

    /**
     * Returns the layer title
     *
     * @returns {String} title - Human readable name for the resource.
     */
    getTitle : function () {
        return this.title;
    },

    /**
     * Returns the layer description
     *
     * @returns {String} description - Resource description.
     */
    getDescription : function () {
        return this.description;
    },

    /**
     * Returns the layer identifier
     *
     * @returns {String} layerId - Unique resource Identifier (eg : "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
     */
    getLayerId : function () {
        return this.layerId;
    },

    /**
     * Returns the layer quicklookUrl
     *
     * @returns {String} quicklookUrl - Image URL for the resource.
     */
    getQuicklookUrl : function () {
        return this.quicklookUrl;
    },

    /**
     * Returns the layer default projection
     *
     * @returns {String} defaultProjection - coordinates system ID used by default for the resource (WMS or WFS layer) or of the TileMatrixSet used by the WMTS layer.
     */
    getDefaultProjection : function () {
        return this.defaultProjection;
    },

    /**
     * Returns the layer projections
     *
     * @returns {Array.<String>} projections - coordinates systems IDs availables for the resource, including the default one.
     */
    getProjections : function () {
        var projections = [];
        projections.push(this.defaultProjection);
        var proj = projections.concat(this.additionalProjections);
        return proj;
    },

    /**
     * Returns the global BBOX
     *
     * @returns {Gp.BBox} bbox - the layer global bounding box, expressed in CRS system.
     */
    getBBOX : function () {
        if (!this.globalConstraint) {
            return;
        }
        return this.globalConstraint.bbox;
    },

    /**
     * Returns the layer minimum scale denominator
     *
     * @returns {Number} minScaleDenominator - minimum scale denominator for this layer
     */
    getMinScaleDenominator : function () {
        if (!this.globalConstraint) {
            return;
        }
        return this.globalConstraint.minScaleDenominator;
    },

    /**
     * Returns the layer maximum scale denominator
     *
     * @returns {Number} maxScaleDenominator - maximum scale denominator for this layer
     */
    getMaxScaleDenominator : function () {
        if (!this.globalConstraint) {
            return;
        }
        return this.globalConstraint.maxScaleDenominator;
    },

    /**
     * Returns layer Tile Matrix Set identifier if exists
     *
     * @returns {String} tileMatrixSetLink - Tile Matrix Set identifier (for instance : "PM")
     */
    getTMSID : function () {
        if (this.wmtsOptions) {
            return this.wmtsOptions.tileMatrixSetLink;
        }
    },

    /**
     * Returns information about the webservice that serves the resource
     *
     * @returns {Object} serviceParams - Information about the webservice that serves the resource (OpenLS, WFS, WMTS)
     */
    getServiceParams : function () {
        return this.serviceParams;
    },

    /**
     * Returns Geoportal server url for a given key
     *
     * @param {String} apiKey - Access key to Geoportal platform
     * @returns {String} serverUrl - general URL of the web service (with the geoportal access key)
     */
    getServerUrl : function (apiKey) {
        if (!apiKey || !this.serviceParams || !this.serviceParams.serverUrl) {
            return;
        }
        return this.serviceParams.serverUrl[apiKey];
    },

    /**
     * Returns information about legends associated to the resource.
     *
     * @returns {Array.<Gp.Services.Config.Legend>} legends - Informations about legends associated to the resource.
     */
    getLegends : function () {
        return this.legends;
    },

    /**
     * Returns information about metadata associated to the resource.
     *
     * @returns {Array.<Gp.Services.Config.Metadata>} metadata - Informations about metadata associated to the resource.
     */
    getMetadata : function () {
        return this.metadata;
    },

    /**
     * Returns information about styles availables for the resources (WMS, WFS and WMTS only).
     *
     * @returns {Array.<Gp.Services.Config.Style>} styles - Informations about styles availables for the resources (WMS, WFS and WMTS only).
     */
    getStyles : function () {
        return this.styles;
    },

    /**
     * Returns layer default style
     *
     * @returns {String} styleName - style identifier (eg : "normal", "bdparcellaire", ...)
     */
    getDefaultStyle : function () {
        if (!this.styles) {
            return;
        }
        var style;
        var s = this.styles;
        for (var i = 0; i < s.length; i++) {
            if (s[i].current === true) {
                style = s[i].name;
                break;
            }
        }
        return style;
    },

    /**
     * Returns information about thematics associated to the resource.
     *
     * @returns {Array.<Gp.Services.Config.Thematic>} thematics - Informations about thematics associated to the resource.
     */
    getThematics : function () {
        return this.thematics;
    },

    /**
     * Returns layer default format
     *
     * @returns {String} formatName - Format mime-type. (eg. "image/jpeg")
     */
    getDefaultFormat : function () {
        if (!this.formats) {
            return;
        }
        var format;
        var f = this.formats;
        for (var i = 0; i < f.length; i++) {
            if (f[i].current === true) {
                format = f[i].name;
                break;
            }
        }
        return format;
    },

    /**
     * Returns information about geographical or temporal constraints for the resource
     *
     * @returns {Array.<Gp.Services.Config.Constraint>} constraints - Informations about geographical or temporal constraints for the resource
     */
    getConstraints : function () {
        return this.constraints;
    },

    /**
     * Returns information about originators of this resource
     *
     * @returns {Array.<Gp.Services.Config.Originator>} originators - Informations about originators of this resource
     */
    getOriginators : function () {
        return this.originators;
    },

    /**
     * Returns information about dimensions associated with this resource
     *
     * @returns {Object} dimensions - Dimensions informations associated with the resource.
     */
    getDimensions : function () {
        return this.dimensions;
    },

    /**
     * Returns information about aggregated layers composing the being described layer, in case the resource is an aggregate of other resources.
     *
     * @returns {Object} aggregatedLayers - Layers IDs composing the being described aggregated layer.
     */
    getAggregatedLayers : function () {
        if (this.isAggregate) {
            return this.aggregatedLayers;
        } else {
            // ...
        }
    }

};

/* harmony default export */ __webpack_exports__["default"] = (Layer);


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a legend file associated with a geoportal resource (WMTS, WMS, WFS layers).
 *
 * @property {String} format - mime-type of the legend file.
 * @property {String} url - legend file URL
 * @property {Number} minScaleDenominator - minimum scale denominator where this legend applies.
 *
 * @namespace
 * @alias Gp.Services.Config.Legend
 */

function Legend () {
    if (!(this instanceof Legend)) {
        throw new TypeError("Legend constructor cannot be called as a function.");
    }

    this.format = null;

    this.url = null;

    this.minScaleDenominator = null;
}

Legend.prototype = {

    constructor : Legend

};

/* harmony default export */ __webpack_exports__["default"] = (Legend);


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a metadata file associated with a geoportal resource.
 *
 * @property {String} format - mime-type of the metadata file.
 * @property {String} url - metadata file URL
 *
 * @namespace
 * @alias Gp.Services.Config.Metadata
 */

function Metadata () {
    if (!(this instanceof Metadata)) {
        throw new TypeError("Metadata constructor cannot be called as a function.");
    }

    this.format = null;

    this.url = null;
}

Metadata.prototype = {

    constructor : Metadata

};

/* harmony default export */ __webpack_exports__["default"] = (Metadata);


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe an Originator of geoportal resource.
 *
 * @property {String} name - originator name
 * @property {String} attribution - originator full name
 * @property {String} logo - originator logo file URL
 * @property {String} url - originator web site URL
 * @property {Array.<Gp.Services.Config.Constraint>} constraints - where and when the originator applies for the ressource.
 *
 * @namespace
 * @alias Gp.Services.Config.Originator
 */

function Originator () {
    if (!(this instanceof Originator)) {
        throw new TypeError("Originator constructor cannot be called as a function.");
    }

    this.name = null;

    this.attribution = null;

    this.logo = null;

    this.url = null;

    this.constraints = [];
}

Originator.prototype = {

    constructor : Originator

};

/* harmony default export */ __webpack_exports__["default"] = (Originator);


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a web service of the geoportal platform.
 *
 * @property {String} title - Web service name
 * @property {Object} serverUrl - Associative array mapping geoportal access key (keys) with their properties (URLs of the web service, with the geoportal access key).
 * @property {String} version - web service version.
 *
 * @namespace
 * @alias Gp.Services.Config.Service
 */
function Service () {
    if (!(this instanceof Service)) {
        throw new TypeError("Service constructor cannot be called as a function.");
    }

    this.title = null;

    this.serverUrl = null;

    this.version = null;
}

Service.prototype = {

    constructor : Service

};

/* harmony default export */ __webpack_exports__["default"] = (Service);


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a style that may be used for a geoportal resource.
 *
 * @property {String} name - Style identifier (eg : "normal", "bdparcellaire", ...)
 * @property {String} title - human readable name of the style.
 * @property {Boolean} current - true if this is the default style.
 * @property {String} url - Url Style (eg: vectortile).
 *
 * @namespace
 * @alias Gp.Services.Config.Style
 */

function Style () {
    if (!(this instanceof Style)) {
        throw new TypeError("Style constructor cannot be called as a function.");
    }

    this.name = null;

    this.title = null;

    this.current = null;

    this.url = null;
}

Style.prototype = {

    constructor : Style

};

/* harmony default export */ __webpack_exports__["default"] = (Style);


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe properties of a french territory covered by geoportal resources.
 *
 * @property {Boolean} isDefault - if this territory is to use by default.
 * @property {String} defaultCRS - Identifier of the coordinates system to use by default for that territory.
 * @property {Array.<String>} additionalCRS - Identifiers of additional coordinates systems availables for that territory.
 * @property {Array.<String>} defaultLayers - Identifiers of layers to load by default for that territory.
 * @property {Object} defaultOptions - options to use by default for that territory.
 * @property {Number} defaultOptions.resolution - resolution to use by default for that territory (in meter per pixel).
 * @property {Number} defaultOptions.minScaleDenominator - minimum scaleDenominator accessible for that territory.
 * @property {Number} defaultOptions.maxScaleDenominator - maximum scaleDenominator accessible for that territory.
 * @property {Gp.BBox} geoBBox - Bounding Box of the territory (expressed in geographical coordinates)
 * @property {Object} geoCenter - center of the territory (expressed in geographical coordinates)
 * @property {Float} geoCenter.lon - center longitude
 * @property {Float} geoCenter.lat - center latitude
 *
 * @namespace
 * @alias Gp.Services.Config.Territory
 */
function Territory () {
    if (!(this instanceof Territory)) {
        throw new TypeError("Territory constructor cannot be called as a function.");
    }

    this.isDefault = null;

    this.defaultCRS = null;

    this.additionalCRS = [];

    this.geoBBOX = {
        left : null,
        right : null,
        top : null,
        bottom : null
    };

    this.geoCenter = {
        lon : null,
        lat : null
    };

    this.defaultOptions = {
        resolution : null,
        minScaleDenominator : null,
        maxScaleDenominator : null
    };

    this.defaultLayers = [];
}

Territory.prototype = {

    constructor : Territory

};

/* harmony default export */ __webpack_exports__["default"] = (Territory);


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a thematic
 *
 * @property {String} name - Thematic name
 * @property {Boolean} inspire - true if the thematic name is an [INSPIRE one]{@link http://inspire.ec.europa.eu/index.cfm/pageid/2/list/7}.
 *
 * @namespace
 * @alias Gp.Services.Config.Thematic
 */

function Thematic () {
    if (!(this instanceof Thematic)) {
        throw new TypeError("Thematic constructor cannot be called as a function.");
    }

    this.inspire = null;

    this.name = null;
}

Thematic.prototype = {

    constructor : Thematic

};

/* harmony default export */ __webpack_exports__["default"] = (Thematic);


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 *
 * Object used to describe a TileMatrix set (for WMTS use).
 *
 * @property {Array.<String>} matrixIds - Array of IDs for each TileMatrix of the set.
 * @property {Array.<Gp.Services.Config.TileMatrix>} tileMatrices - Array of TileMatrix descriptions.
 * @property {Array.<Float>} nativeResolutions - Array of resolutions (in meter per pixel) applying for each TileMatrix of the set.
 * @property {String} projection - Identifier of the Cordinates System used for the tileMatrixSet.
 *
 * @namespace
 * @alias Gp.Services.Config.TileMatrixSet
 */
function TileMatrixSet () {
    if (!(this instanceof TileMatrixSet)) {
        throw new TypeError("TileMatrixSet constructor cannot be called as a function.");
    }

    this.projection = null;

    this.nativeResolutions = [];

    this.matrixIds = [];

    this.tileMatrices = {};
}

TileMatrixSet.prototype = {

    constructor : TileMatrixSet,

    /**
     * Returns Tile Matrix Set resolutions
     *
     * @returns {Array} nativeResolutions - Array of resolutions (in meter per pixel) applying for each TileMatrix of the set.
     */
    getResolutions : function () {
        return this.nativeResolutions;
    },

    /**
     * Returns Tile Matrix Set identifiers
     *
     * @returns {Array} matrixIds - Array of IDs for each TileMatrix of the set.
     */
    getMatrixIds : function () {
        return this.matrixIds;
    },

    /**
     * Returns Tile Matrix Set projection
     *
     * @returns {String} projection - Identifier of the Cordinates System used for the tileMatrixSet.
     */
    getProjection : function () {
        return this.projection;
    },

    /**
     * Returns Tile Matrices descriptions.
     *
     * @returns {Array.<Gp.Services.Config.TileMatrix>} tileMatrices - Array of TileMatrix descriptions.
     */
    getTileMatrices : function () {
        return this.tileMatrices;
    },

    /**
     * Returns top left corner point of matrices
     *
     * @returns {Gp.Point} topLeftCorner - Top Left Corner Point of TMS matrices, expressed in the tileMatrixSet coordinates system.
     */
    getTopLeftCorner : function () {
        var topLeftCorner;
        var matrices = this.getTileMatrices();
        if (matrices) {
            for (var id in matrices) {
                if (matrices.hasOwnProperty(id)) {
                    topLeftCorner = matrices[id].topLeftCorner;
                    break;
                }
            }
        }
        return topLeftCorner;
    }

};

/* harmony default export */ __webpack_exports__["default"] = (TileMatrixSet);


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a TileMatrix.
 *
 * @property {String} matrixId - matrix Identifier
 * @property {Number} matrixHeight - Number of tiles from the top to the bottom of the matrix.
 * @property {Number} matrixWidth - Number of tiles from the left to the right of the matrix.
 * @property {Number} scaleDenominator - Scale denominator associated to that matrix.
 * @property {Number} tileHeight - tile height in number of pixels
 * @property {Number} tileWidth - tile width in number of pixels
 * @property {Gp.Point} topLeftCorner - Top Left Corner Point of the matrix expressed in the tileMatrixSet coordinates system.
 *
 * @namespace
 * @alias Gp.Services.Config.TileMatrix
 */

function TileMatrix () {
    if (!(this instanceof TileMatrix)) {
        throw new TypeError("TileMatrix constructor cannot be called as a function.");
    }

    this.matrixId = null;

    this.matrixHeight = null;

    this.matrixWidth = null;

    this.scaleDenominator = null;

    this.tileHeight = null;

    this.tileWidth = null;

    this.topLeftCorner = null;
}

TileMatrix.prototype = {

    constructor : TileMatrix,

    /**
     * Returns top left corner point of the matrix
     *
     * @returns {Gp.Point} topLeftCorner - Top Left Corner Point of the matrix expressed in the tileMatrixSet coordinates system.
     */
    getTopLeftCorner : function () {
        return this.topLeftCorner;
    },

    /**
     * Returns Scale denominator associated to that matrix.
     *
     * @returns {Number} scaleDenominator - Scale denominator associated to that matrix.
     */
    getScaleDenominator : function () {
        return this.scaleDenominator;
    },

    /**
     * Returns tile height of matrix
     *
     * @returns {Number} tileHeight - tile height in number of pixels
     */
    getTileHeight : function () {
        return this.tileHeight;
    },

    /**
     * Returns tile width of matrix
     *
     * @returns {Number} tileWidth - tile width in number of pixels
     */
    getTileWidth : function () {
        return this.tileWidth;
    },

    /**
     * Returns matrix height (number of tiles)
     *
     * @returns {Number} matrixHeight - Number of tiles from the top to the bottom of the matrix.
     */
    getMatrixHeight : function () {
        return this.matrixHeight;
    },

    /**
     * Returns matrix width (number of tiles)
     *
     * @returns {Number} matrixWidth - Number of tiles from the left to the right of the matrix.
     */
    getMatrixWidth : function () {
        return this.matrixWidth;
    }

};

/* harmony default export */ __webpack_exports__["default"] = (TileMatrix);


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Object used to describe a layer extent on a Tile Matrix.
 *
 * @property {Number} minTileCol - minimum column index where tile can be found on the Tile matrix.
 * @property {Number} maxTileCol - maximum column index where tile can be found on the Tile matrix.
 * @property {Number} minTileRow - minimum row index where tile can be found on the Tile matrix.
 * @property {Number} maxTileCol - maximum row index where tile can be found on the Tile matrix.
 *
 * @namespace
 * @alias Gp.Services.Config.TileMatrixLimit
 */

function TileMatrixLimit () {
    if (!(this instanceof TileMatrixLimit)) {
        throw new TypeError("TileMatrixLimit constructor cannot be called as a function.");
    }

    this.minTileRow = null;

    this.maxTileRow = null;

    this.minTileCol = null;

    this.maxTileCol = null;
}

/**
 * @lends module:Autoconf/Response/TileMatrixLimit
 */
TileMatrixLimit.prototype = {

    constructor : TileMatrixLimit
};

/* harmony default export */ __webpack_exports__["default"] = (TileMatrixLimit);


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _Request_DirectGeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _Response_DirectGeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(115);








/**
 * @classdesc
 * Appel du service de géocodage direct du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 *
 *
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.Geocode
 *
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String|Object} options.location - Nom de l'adresse, du toponyme, de l'unité administrative ou de la parcelle cadastrale recherchée.
 *      Sous forme de String, la propriété permet de faire une recherche déstructurée.
 *      Sous forme d'objet, la propriété permet de structurer la recherche.
 *      Dans ce cas, les propriétés possibles de cet objet sont décrites ci-après.
 *      @param {Number} [options.location.number] - Numéro du bâtiment de l'adresse recherchée, dans le cas d'une recherche structurée
 *      (si options.location est un objet Javascript).
 *      @param {String} [options.location.street] - Nom de la rue de l'adresse recherchée, dans le cas d'une recherche structurée
 *      (si options.location est un objet Javascript).
 *      @param {String} [options.location.city] - Nom de la ville de l'adresse recherchée, dans le cas d'une recherche structurée
 *      (si options.location est un objet Javascript).
 *      @param {Number} [options.location.postalCode] - Numéro du code postal de l'adresse recherchée, dans le cas d'une recherche structurée
 *      (si options.location est un objet Javascript).
 *
 * @param {Object} [options.filterOptions] - Les propriétés possibles de cet objet sont décrites ci-après.
 * @param {Object} [options.filterOptions.bbox] - Emprise dans laquelle on souhaite effectuer la recherche.
 *      Les propriétés possibles de cet objet sont décrites ci-après.
 *      @param {Float} options.filterOptions.bbox.left - Abscisse du côté gauche de la BBOX
 *      @param {Float} options.filterOptions.bbox.right - Abscisse du côté droit de la BBOX
 *      @param {Float} options.filterOptions.bbox.top - Ordonnée supérieure de la BBOX
 *      @param {Float} options.filterOptions.bbox.bottom - Ordonnée inférieure de la BBOX
 *
 * @param {Array.<String>} [options.filterOptions.type = "StreetAddress"] - Type de l'objet recherché.
 *      Le service de géocodage du Géoportail permet de rechercher des 'PostionOfInterest' pour des toponymes, des 'StreetAddress'
 *      pour des adresses postales, et/ou des 'CadastralParcel' pour des parcelles cadastrales.
 *      D'autres types pourront être rajoutés selon l'évolution du service.
 *      Par défaut, type = ['StreetAddress'].
 *
 * @param {String} [options.filterOptions.[proprietes du filtre]] - Critère supplémentaire pour filtrer la recherche sous la forme
 *      d'un couple clé/valeur à définir selon les possibilités du serveur ajouté à la requête.
 *      Le service de géocodage du Géoportail permet de filtrer tous les résultats avec les propriétés :
 *          "municipality", "insee", et "department".
 *      Il permet aussi de filtrer les adresses postales avec les propriétés :
 *          "quality", "ID", "ID_TR" et "territory".
 *      Il permet de filtrer les toponymes avec les propriétés :
 *          "importance", "nature" et "territory".
 *      Enfin, il permet de filtrer les parcelles cadastrales avec les propriétés :
 *          "sheet", "section", et "absorbedcity". Pas de valeur par défaut.
 *
 * @param {Number} [options.maximumResponses] - Nombre de réponses maximal que l'on souhaite recevoir.
 *      Pas de valeur par défaut.
 *      Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 25.
 *
 * @param {Boolean} [options.returnFreeForm] - Indique si l'on souhaite en réponse un localisant concaténée plutôt que structuré.
 *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 'false'.
 *
 * @param {String} [options.srs] - Système de coordonnées dans lequel les paramètres géographiques en entrée et la réponse du service sont exprimés.
 *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 'EPSG:4326'.
 *
 * @example
 *   var options = {
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      positions : [{lon:, lat:}, {lon:, lat:}],
 *      (...)
 *   };
 * @private
 */
function Geocode (options) {
    if (!(this instanceof Geocode)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "Geocode"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "Geocode";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.Geocode");
    this.logger.trace("[Constructeur Geocode (options)]");

    if (!options.location) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "location"));
    }

    // FIXME ECMAScript 5 support
    if (typeof options.location === "object" && Object.keys(options.location).length === 0) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "location"));
    } else if (typeof options.location === "string" && options.location.length === 0) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "location"));
    }

    // ajout des options spécifiques au service
    this.options.location = options.location;

    // on definit des filtres apr defaut
    if (!options.filterOptions || typeof options.filterOptions !== "object") {
        this.options.filterOptions = options.filterOptions = {
            type : ["StreetAddress"]
        };
    }

    // FIXME ECMAScript 5 support (valable pour un objet uniquement !)
    // ceci permet de tester le cas où 'options.filterOptions' : {}
    if (Object.keys(options.filterOptions).length === 0) {
        this.options.filterOptions = {
            type : ["StreetAddress"]
        };
    }

    var filter = Object.keys(options.filterOptions);
    for (var i = 0; i < filter.length; i++) {
        var key = filter[i];
        // on transforme certains filtres qui pourraient être numériques en string
        var filtersCouldBeNumberList = ["department", "number", "postalCode", "insee", "importance", "ID", "IDTR", "absorbedCity", "sheet", "section", "inseeRegion", "inseeDepartment"];
        if (filtersCouldBeNumberList.indexOf(key) !== -1 && typeof options.filterOptions[key] !== "string") {
            options.filterOptions[key] = options.filterOptions[key].toString();
        }
        // on supprime les filtres vides
        if (!options.filterOptions[key]) {
            delete this.options.filterOptions[key];
        }
    }

    this.options.filterOptions.type = options.filterOptions.type || ["StreetAddress"];
    this.options.maximumResponses = options.maximumResponses || 25;
    this.options.returnFreeForm = options.returnFreeForm || false;
    this.options.srs = options.srs || "EPSG:4326";

    // attributs d'instances

    /**
     * Format forcé de la réponse du service : "xml"
     * sauf si l'on souhaite une reponse brute (options.rawResponse)
     */
    this.options.outputFormat = (this.options.rawResponse) ? "" : "xml";
}

/**
 * @lends module:Geocode#
 */
Geocode.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
Geocode.prototype.constructor = Geocode;

/**
 * Création de la requête (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Geocode.prototype.buildRequest = function (error, success) {
    var options = {
        httpMethod : this.options.httpMethod,
        // options specifiques du service
        location : this.options.location,
        returnFreeForm : this.options.returnFreeForm,
        filterOptions : this.options.filterOptions,
        srs : this.options.srs,
        maximumResponses : this.options.maximumResponses
    };

    this.request = _Request_DirectGeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_4__["default"].build(options);

    // on teste si la requete a bien été construite !
    (!this.request)
        ? error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD")))
        : success.call(this, this.request);
};

/**
 * Analyse de la reponse (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Geocode.prototype.analyzeResponse = function (error, success) {
    /* INFO :
         Etape 1 : Création de la requête
            -> Appel du format OpenLS pour créer une requête à partir des paramètres (par exemple)
              (soit directement une URL si GET, soit une requête XML si POST)
            /!\ tester si apiKey && serverUrl => on ne garde que serverUrl
            -> stockage de la requête dans this.request
         Etape 2 : Envoi de la requête selon le bon protocole
            -> appel du protocol JSONP ou XHR, et envoi (par ex send ()) (this.protocol)
            -> récupération de la réponse xml dans la fonction onSuccess () (this.response)
            -> si code HTTP 200 et pas de message d'erreur : etape 3
            -> si code HTTP != 200 : lancement de la fonction de callback onFailure avec le message d'erreur
         Etape 3 : Analyse de la réponse xml et construction du JSON (si rawResponse === false )
            -> appel du parser pour récupérer le xmlDocument
            -> appel du reader OpenLS pour lire les éléments et récupérer l'objet JSON
               correspondant au type de géocodage (défini dans les specs)
         Etape 4 : Lancement de la fonction de callback onSuccess avec la réponse :
            -> xmlResponse (si rawResponse === true)
            -> ou geocodedLocations
    */

    if (this.response) {
        var options = {
            response : this.response,
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this
        };

        _Response_DirectGeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ __webpack_exports__["default"] = (Geocode);


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Formats_XLS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99);
/* harmony import */ var _Formats_XLS_LocationUtilityService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(103);
/* harmony import */ var _Formats_XLS_LocationUtilityService_GeocodeFilterExtension__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(106);
/* harmony import */ var _Request_model_StreetAddress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(110);
/* harmony import */ var _Request_model_PositionOfInterest__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var _Request_model_CadastralParcel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(113);
/* harmony import */ var _Request_model_Administratif__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(114);
/**
 * Creation d'une requête OpenLS en mode POST ou GET
 * (Factory)
 *
 * @module DirectGeocodeRequestFactory
 * @alias Gp.Services.Geocode.Request.DirectGeocodeRequestFactory
 * @private
 */









var DirectGeocodeRequestFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Geocode
     *
     * @example
     *   var options = {
     *      httpMethod:
     *      // options specifiques du service
     *      location:
     *      returnFreeForm:
     *      filterOptions:
     *      srs:
     *      maximumResponses:
     *   };
     *   var result = DirectGeocodeRequestFactory.build(options);
     *   if (!result) {
     *       // error...
     *   }
     * @returns {String} request
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("DirectGeocodeRequestFactory");
        logger.trace(["DirectGeocodeRequestFactory::build()"]);

        var request = null;

        // gestion des filtres (table de geocodage) !
        // par defaut, on les ajoute toute ...
        var oFilter = new _Formats_XLS_LocationUtilityService_GeocodeFilterExtension__WEBPACK_IMPORTED_MODULE_3__["default"]();
        oFilter.addFilterExtensions(new _Request_model_Administratif__WEBPACK_IMPORTED_MODULE_7__["default"]());
        oFilter.addFilterExtensions(new _Request_model_StreetAddress__WEBPACK_IMPORTED_MODULE_4__["default"]());
        oFilter.addFilterExtensions(new _Request_model_PositionOfInterest__WEBPACK_IMPORTED_MODULE_5__["default"]());
        oFilter.addFilterExtensions(new _Request_model_CadastralParcel__WEBPACK_IMPORTED_MODULE_6__["default"]());

        // objet LUS
        // on peut aussi par un objet XLS::GeocodeRequest
        var oLUS = new _Formats_XLS_LocationUtilityService__WEBPACK_IMPORTED_MODULE_2__["default"]({
            location : options.location,
            returnFreeForm : options.returnFreeForm,
            filterOptions : options.filterOptions
        });
        oLUS.addFilter(oFilter);

        // Format XLS
        var oXLS = new _Formats_XLS__WEBPACK_IMPORTED_MODULE_1__["default"]({
            srsName : options.srs,
            maximumResponses : options.maximumResponses
        });
        oXLS.namespace = true;
        oXLS.setService(oLUS);

        // request brute !
        request = oXLS.build();

        // en mode GET, la requête est encodée
        // et le param. 'qxml' est ajouté
        if (options.httpMethod === "GET") {
            var myRequest = "qxml=" +
                encodeURIComponent(request)
                    .replace(/-/g, "%2D")
                    .replace(/_/g, "%5F")
                    .replace(/\./g, "%2E")
                    .replace(/!/g, "%21")
                    .replace(/~/g, "%7E")
                    .replace(/\*/g, "%2A")
                    .replace(/'/g, "%27")
                    .replace(/\(/g, "%28")
                    .replace(/\)/g, "%29");
            request = myRequest;
        }

        logger.trace(request);

        return request;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (DirectGeocodeRequestFactory);


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _XLS_RequestHeader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
/* harmony import */ var _XLS_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);
/* harmony import */ var _XLS_AbstractService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(102);





/**
 * @classdesc
 *
 * standard OpenLS
 * standard XLS
 * (version 1.2)
 *
 * Réfs :
 *     - {@link http://schemas.opengis.net/ols/1.2/}
 *     - {@link http://www.opengeospatial.org/standards/ols}
 *     - {@link http://wxs.ign.fr/schemas/}
 *
 *
 * Création du template XLS (avec gestion des namespaces)
 * ------------------------
 * ```
 *   balise xsd : element name="XLS" attribute name="version" [(attribute ref="lang")]
 * ```
 *
 * Exemple :
 * ```
 * <XLS xmlns="http://www.opengis.net/xls" version="1.2">
 *   < (ref. OLS) />
 * </XLS>
 * ```
 * ```
 * <xls:XLS xmlns:xls="http://www.opengis.net/xls" version="1.2">
 *   <xls: (ref. OLS) />
 * </xls:XLS>
 * ```
 *
 * Création des templates OLS pour LocationUtilityService
 * ------------------------------------------------------
 *
 * Exemple :
 *
 * ```
 * <RequestHeader srsName="epsg:4326"/>
 * <Request maximumResponses="26" methodName="GeocodeRequest" requestID="uid1349081498314_388" version="1.2">
 *      <GeocodeRequest>
 *          <Address countryCode="PositionOfInterest">
 *              <freeFormAddress>saint mandé</freeFormAddress>
 *          </Address>
 *      </GeocodeRequest>
 *  </Request>
 * ```
 * ```
 * <RequestHeader sessionID="" />
 * <Request methodName="ReverseGeocodeRequest" version="1.2" requestID="" maximumResponses="10">
 *   <ReverseGeocodeRequest>
 *     <Position>
 *       <gml:Point xmlns:gml="http://www.opengis.net/gml">
 *           <gml:pos>50.347775 3.205098</gml:pos>
 *       </gml:Point>
 *     </Position>
 *     <ReverseGeocodePreference>StreetAddress</ReverseGeocodePreference>
 *  </ReverseGeocodeRequest>
 * </Request>
 * ```
 * ```
 * Geocodage direct (balise xsd) :
 *   element ref="RequestHeader" [ (attribute name="clientName" attribute name="clientPassword" attribute name="sessionID" attribute name="srsName" attribute name="MSID") ]
 *     element name="Request" attribute name="methodName" attribute name="version" attribute name="requestID" [ attribute name="maximumResponses" ]
 *       element name="GeocodeRequest" attribute name="returnFreeForm"
 *         element ref="xls:Address"
 * ```
 * ```
 * Geocodage inverse (balise xsd) :
 *   element ref="RequestHeader" [ (attribute name="clientName" attribute name="clientPassword" attribute name="sessionID" attribute name="srsName" attribute name="MSID") ]
 *     element name="Request" attribute name="methodName" attribute name="version" attribute name="requestID" [ attribute name="maximumResponses" ]
 *       element name="ReverseGeocodeRequest"
 *         element ref="xls:Position"
 *         element name="ReverseGeocodePreference" (enumeration)
 * ```
 *
 * Il existe 3 sous ensembles d'objets :
 *     - RequestHeader
 *     - Request
 *     - ReverseGeocodeRequest, GeocodeRequest
 *
 * GeocodeRequest est composé d'un objet {@link Gp.Services.Geocode.Response.GeocodeLocation}.
 * ReverseGeocodeRequest est composé d'un objet {@link Gp.Services.ReverseGeocode.Response.ReverseGeocodeLocation}.
 *
 * Les locations font appels aux objets suivants qui possèdent des attributs spécifiques
 * en fonction du type de table de geocodage interrogé :
 *     - StreetAddress
 *     - CadastralParcel
 *     - PositionOfInterest
 *     - Administratif
 *
 *
 * et des élements sous jacents tels que :
 *     - ReverseGeocodePreference -> tables de geocodages :
 *         - StreetAddress
 *         - CadastralParcel
 *         - PositionOfInterest
 *         - Administratif (une balise par table)
 *     - Position -> standard GML 3.2.1
 *     - Address  -> cf. ci-dessous
 *
 * ```
 * Position (balise xsd) :
 *   ex. <Position><gml:Point xmlns:gml="http://www.opengis.net/gml"><gml:pos>50.347775 3.205098</gml:pos></gml:Point></Position>
 *   ex. <Position><gml:CircleByCenterPoint xmlns:gml="http://www.opengis.net/gml"><gml:pos>48.85978570614691 2.2913572761128878</gml:pos><gml:radius>1000</gml:radius></gml:CircleByCenterPoint></Position>
 *   (au choix)
 *   element ref="gml:Point"
 *   element ref="gml:CircleByCenterPoint"
 *   element ref="gml:Polygon"
 *   element ref="gml:MultiPolygon"
 *   les autres elemennts ne sont pas implémentés (QoP, Speed, Direction, Time, ...)
 *
 * Address (balise xsd) :
 *   ex. <Address countryCode="StreetAddress"><freeFormAddress>1 r de paris saint denis</freeFormAddress></Address>
 *   attribute name="countryCode"
 *     element name="freeFormAddress"
 *     element ref="xls:Place"
 *     element ref="gml:Envelope"
 *  ou
 *   ex. <Address countryCode="StreetAddress"><StreetAddress><Street>1 rue Marconi</Street></StreetAddress><Place type="Municipality">Metz</Place><PostalCode>57000</PostalCode></Address>
 *   attribute name="countryCode"
 *     element ref="xls:StreetAddress"
 *     element ref="xls:PostalCode"
 *     element ref="xls:Place"
 *     element ref="gml:Envelope"
 *
 * Place  (balise xsd) :
 *  ex. <Place type="Municipality">Metz</Place>
 *  attribute name="type"
 *   enumeration value="CountrySubdivision"
 *   enumeration value="CountrySecondarySubdivision"
 *   enumeration value="Municipality"
 *   enumeration value="MunicipalitySubdivision"
 *   enumeration value="choume-banchi-go"
 *   enumeration value="Qualite"
 *   enumeration value="Departement"
 *   enumeration value="Bbox"
 *   enumeration value="Commune"
 *   enumeration value="Territoire"
 *   enumeration value="Importance"
 *   enumeration value="Nature"
 *   (la liste n'est pas exhaustives...)
 *
 * StreetAddress (balise xsd) :
 *   ex. <StreetAddress><Street>1 rue Marconi</Street></StreetAddress>
 *   attribute name="locator"
 *    element name="xls:Building"
 *    element ref="xls:Street"
 *
 * Street (balise xsd) :
 *   ex. <Street>1 rue Marconi</Street>
 *   attribute name="officialName" (...)
 *
 * Building (balise xsd) :
 *   ex. <Building number="800"/>
 *   attribute name="number" attribute name="subdivision" attribute name="buildingName"
 *
 * PostalCode (balise xsd) :
 *   ex. <PostalCode>77182</PostalCode>
 *
 * ```
 *
 * Requête
 * -------
 *
 * 2 modes de requête sur les services : GET ou POST.
 *
 * Le mode GET n'est que l'encodage du XML en param (qxml) de la requête (donc pas d'implementation particulière ?)
 *
 * Modèle de classes
 * -----------------
 *
 * ```
 *                 ________  XLS ____________
 *               /            |               \
 *   RequestHeader      AbstractService    Request
 *                            ^
 *                      ______|________________________
 *           (extends) /                               \ (extends)
 *          LocationUtilityService                    RouteService
 *                    |                                    |
 *         ___________|___________                       (...)
 *       /                        \
 * GeocodeRequest          ReverseGeocodeRequest
 *      |                          |
 *      |                     _____|______
 *      |                    /            \
 *   Address              Preference  Position
 *      |
 *    /   \
 * Place   StreetAddress
 *               |
 *             /   \
 *       Street   Building
 * ```
 *
 * @example
 * // encapsule un objet 'LocationUtilityService'
 * // dans une coquille XSL (avec/sans namespace)
 * xsl = new XSL ();
 * xsl.namespace = false;
 * xsl.srsName = "epsg:4326";
 * xsl.maximumResponses = 26;
 * //   methodName fournit par l'objet 'lus'
 * //   requestID est calculé
 * xsl.setService (lus);
 * xsl.build ();
 * // out ->
 * // <XLS xmlns="http://www.opengis.net/xls" version="1.2">
 * // <RequestHeader srsName="epsg:4326"/>
 * // <Request maximumResponses="26" methodName="GeocodeRequest" requestID="uid1349081498314_388" version="1.2">
 * //   < (ref. LocationUtilityService ou vide) />
 * //  </Request>
 * // </XLS>
 *
 *
 * @constructor
 * @alias Gp.Formats.XLS
 * @param {Object} options - options du constructeur
 * @param {Object} options.srsName - identifiant du Systeme de Coordonnees
 * @param {String}   options.maximumResponses - nombre de reponses max d'une requete
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 *
 * @private
 */
function XLS (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur XLS()]");

    if (!(this instanceof XLS)) {
        throw new TypeError("XLS constructor cannot be called as a function.");
    }

    // options par defaut
    this.options = {
        srsName : "EPSG:4326",
        maximumResponses : 25
    };

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            if (options[opt]) {
                this.options[opt] = options[opt];
            }
        }
    }
}

/**
 * Version
 */
XLS.VERSION = "1.2";

XLS.prototype = {

    /**
     * @lends module:XLS#
     */

    /**
     * request (out)
     * @type {String}
     */
    requestString : null,

    /**
     * namespace
     * Surcharge les balises XLS d'un prefixe.
     * Par defaut, false
     * @type {Boolean}
     */
    namespace : false,

    /**
     * Objet Service
     * LocationUtilityService ou RouteService
     * @type {AbstractService}
     */
    oService : null,

    /**
     * Constructeur (alias)
     */
    constructor : XLS,

    /**
     * Template de la requête.
     * substitution des valeurs suivantes :
     * __VERSION__, __NAMESPACE__, __SCHEMALOCATION__
     * __REQUESTHEADER__, __REQUEST__
     */
    template : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
        "<XLS version=\"__VERSION__\"\n" +
        "__NAMESPACE__ \n" +
        "__SCHEMALOCATION__>\n" +
        "__REQUESTHEADER__\n" +
        "__REQUEST__\n" +
        "</XLS>\n",

    /**
     * Namespace par defaut.
     *
     * @returns {String} namespace
     */
    namespaceByDefault : function () {
        var ns = [
            "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
            "xmlns:xls=\"http://www.opengis.net/xls\"",
            "xmlns:gml=\"http://www.opengis.net/gml\""
        ];

        return ns.join(" ");
    },

    /**
     * Schemalocation par defaut
     *
     * @returns {String} schemaLocation
     */
    schemaLocationByDefault : function () {
        return "xsi:schemaLocation=\"http://www.opengis.net/xls http://schemas.opengis.net/ols/1.2/olsAll.xsd\"";
    },

    /**
     * Setter Service
     * Ajout d'un objet de type LocationUtilityService (LUS) ou RouteService
     *
     * @param {Object} oService - GeoceodeRequest / ReverseGeocodeRequest ou RouteRequest
     */
    setService : function (oService) {
        if (!oService) {
            this.logger.trace("L'objet de type Service XSL n'est pas encore defini !?");
            return;
        }

        if (oService instanceof _XLS_AbstractService__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            this.oService = oService;
        } else {
            this.logger.error("L'objet n'est pas du type 'LocationUtilityService' ou 'RouteService' !?");
        }
    },

    /**
     * Getter Service
     * Retourne un objet de type LocationUtilityService (LUS) ou RouteService
     * ex. GeoceodeRequest / ReverseGeocodeRequest ou RouteRequest
     *
     * @returns {Object} service (LocationUtilityService|RouteService)
     */
    getService : function () {
        return this.oService;
    }
};

/**
 * Ajout d'un prefixe de namespace
 *
 * @todo impl. l'ajout de namespace
 * @param {Object} ns - ex. {key:xls, url:http://www.opengis.net/xls}
 * @param {String} request - requête
 * @returns {String} requête
 */
XLS.prototype.addNamespace = function (ns, request) {
    // INFO
    // on recherche la clef dans les namespaces par defaut.
    // si la clef n'existe pas dans les namespaceByDefault (), on l'ajoute.
    // on surcharge toutes les balises, ex. XLS -> xls:XLS
    // sauf celles qui sont déjà prefixées !

    var keyNS = ns.key;
    // var urlNS = ns.url; // TODO not yet implemented !

    // recherche la clef dans les namespaces par defaut
    var bFound = false;
    var allNS = this.namespaceByDefault().split(" ");
    for (var index = 0; index < allNS.length; index++) {
        var element = allNS[index];
        var map = element.split("=");
        var key = map[0];
        // var url = map[1]; // TODO not yet implemented !

        if (key === "xmlns:" + keyNS) {
            bFound = true;
            break;
        }
    }

    // TODO
    // si on a une nouvelle clef, on l'ajoute...
    if (!bFound) {
        this.logger.warn("L'ajout d'un nouvel namespace n'est pas encore implémenté !");
        return request;
    }

    // surcharge toutes les balises
    var regex;
    var subst;

    // regex balise ouvrante
    regex = /<(\w+[\s>])/g;
    subst = "<" + keyNS + ":$1";
    request = request.replace(regex, subst);

    // regex balise fermante
    regex = /<\/(\w+[\s>])/g;
    subst = "</" + keyNS + ":$1";
    request = request.replace(regex, subst);

    this.logger.trace("namespace", request);

    return request;
};

/**
 * Construction de la requête
 * @returns {String} requête
 */
XLS.prototype.build = function () {
    // out ->
    // <XLS xmlns="http://www.opengis.net/xls" version="1.2">
    // <RequestHeader srsName="epsg:4326"/>
    // <Request maximumResponses="26" methodName="GeocodeRequest" requestID="uid1349081498314_388" version="1.2">
    //   < (ref. LocationUtilityService ou vide) />
    //  </Request>
    // </XLS>

    // as t on un objet de type Service XLS à disposition ?
    var bService = !!this.getService();

    var template = "";
    template = this.template;
    template = template.replace(/__VERSION__/g, XLS.VERSION);
    template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);
    template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);

    // header
    var oHeader = new _XLS_RequestHeader__WEBPACK_IMPORTED_MODULE_1__["default"]({
        srsName : this.options.srsName
    });
    template = template.replace(/__REQUESTHEADER__/g, oHeader.toString());

    // request
    var oRequest = new _XLS_Request__WEBPACK_IMPORTED_MODULE_2__["default"]({
        maximumResponses : this.options.maximumResponses,
        version : XLS.VERSION, // FIXME même version ?
        methodName : bService ? this.getService().CLASSTYPE : null
    });
    template = template.replace(/__REQUEST__/g, oRequest.toString());

    // objet lus ou route
    if (bService) { // INFO : clef __REQUESTSERVICE__ dispo dans l'objet 'Request'
        template = template.replace(/<!-- __REQUESTSERVICE__ -->/g, this.getService().toString());
    }

    if (!template) {
        this.logger.warn("traduction tmpl : empty request !?");
        return;
    }

    // ajout d'un namespace
    if (this.namespace) {
        // ajout de xls par defaut
        template = this.addNamespace({
            key : "xls",
            url : "http://www.opengis.net/xls"
        }, template);
    }

    this.requestString = template;
    this.logger.trace("traduction tmpl", template);

    // on retourne qqchose !
    return this.requestString;
};

/* harmony default export */ __webpack_exports__["default"] = (XLS);


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);


/**
 * @classdesc
 *
 * Entête de la requête XSL
 *
 * @example
 * // header XSL
 * header = new RequestHeader ();
 * header.srsName = "epsg:4326";
 * header.toString();
 * // out ->
 * // <RequestHeader srsName="epsg:4326"/>
 *
 * @constructor
 * @alias Gp.Formats.XLS.RequestHeader
 * @param {Object} options - options
 * @param {Object}   options.srsName - projection
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 *
 * @private
 */
function RequestHeader (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur RequestHeader ()]");

    if (!(this instanceof RequestHeader)) {
        throw new TypeError("RequestHeader constructor cannot be called as a function.");
    }

    // options par defaut
    this.options = options || {
        srsName : "EPSG:4326"
    };

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            this.options[opt] = options[opt];
        }
    }
}

RequestHeader.prototype = {

    /**
     * @lends module:RequestHeader#
     */

    /**
     * request (out)
     * @type {String}
     */
    requestString : null,

    /**
     * Template de la requête.
     * substitution des valeurs suivantes :
     * __SRSNAME__
     */
    template : "<RequestHeader srsName=\"__SRSNAME__\"/>",

    /**
     * Constructeur (alias)
     */
    constructor : RequestHeader,

    /**
     * toString
     * @returns {String} requête
     */
    toString : function () {
        var template = null;
        template = this.template;
        template = template.replace(/__SRSNAME__/g, this.options.srsName);
        this.requestString = template;
        return this.requestString;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (RequestHeader);


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* jshint bitwise: false */


/**
 * @classdesc
 *
 * Requête XLS
 *
 * @example
 * // request XSL
 * request = new Request ();
 * request.maximumResponses = 26;
 * request.methodName = "GeocodeRequest";
 * request.version = "1.2";
 * request.toString();
 * // out ->
 * // <Request maximumResponses="26" methodName="GeocodeRequest" requestID="uid1349081498314_388" version="1.2">
 * //   <!-- __LUS__ -->
 * //  </Request>
 *
 * @constructor
 * @alias Gp.Formats.XLS.Request
 * @param {Object} options - options
 * @param {Object}   options.maximumResponses - 25
 * @param {String}   options.methodName - nom de l'objet LUS, "GeocodeRequest" | "ReverseGeocodeRequest"
 * @param {String}   options.version - '1.2'
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 *
 * @private
 */
function Request (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur Request ()]");

    if (!(this instanceof Request)) {
        throw new TypeError("Request constructor cannot be called as a function.");
    }

    // options par defaut
    this.options = options || {
        maximumResponses : 25,
        methodName : null,
        version : "1.2"
    };

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            this.options[opt] = options[opt];
        }
    }
}

Request.prototype = {

    /**
     * @lends module:Request#
     */

    /**
     * request (out)
     * @type {String}
     */
    requestString : null,

    /**
     * Template de la requête.
     * substitution des valeurs suivantes :
     * __MAXRESPONSES__, __METHODNAME__, __UUID__, __VERSION__
     * __REQUESTSERVICE__
     */
    template : "<Request maximumResponses=\"__MAXRESPONSES__\" methodName=\"__METHODNAME__\" requestID=\"__UUID__\" version=\"__VERSION__\">" +
        "<!-- __REQUESTSERVICE__ -->" +
        "</Request>",

    /**
     * Constructeur (alias)
     */
    constructor : Request,

    /**
     * an rfc4122 version 4 compliant guid
     * @returns {String} guid
     */
    guid : function () {
        // INFO
        // cf. http://byronsalau.com/blog/how-to-create-a-guid-uuid-in-javascript/
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0;
            var v = c === "x" ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    },

    /**
     * toString
     * @returns {String} requête
     */
    toString : function () {
        var template = null;
        template = this.template;
        template = template.replace(/__MAXRESPONSES__/g, this.options.maximumResponses);
        template = template.replace(/__METHODNAME__/g, this.options.methodName);
        template = template.replace(/__UUID__/g, this.guid());
        template = template.replace(/__VERSION__/g, this.options.version);

        this.requestString = template;
        return this.requestString;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (Request);


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);


/**
 * @classdesc
 * @private
 *
 * @constructor
 * @alias Gp.Formats.XLS.AbstractService
 *
 * @param {Object} [options] - options
 */
function AbstractService (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur AbstractService ()]");

    if (!(this instanceof AbstractService)) {
        throw new TypeError("AbstractService constructor cannot be called as a function.");
    }

    // options par defaut
    this.options = options || {};

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            this.options[opt] = options[opt];
        }
    }
}

/**
 * @lends module:AbstractService#
 */
AbstractService.prototype = {

    /**
     * request (out)
     * @type {String}
     */
    strRequest : null,

    /**
     * objet Request
     * @type {Request}
     */
    oRequest : null,

    /**
     * Filter
     * @type {FilterExtension}
     */
    oFilter : null,

    /**
     * Constructeur (alias)
     */
    constructor : AbstractService,

    /**
     * Ajout d'un objet de type Request : GeocodeRequest / ReverseGeocodeRequest / RouteRequest
     *
     * @param {Object} oRequest - GeocodeRequest / ReverseGeocodeRequest / RouteRequest
     */
    addRequest : function (oRequest) {
        this.logger.error("overwritten method !");
    },

    /**
     * Ajout d'un objet de type FilterExtension : GeocodeFilterExtension ou RouteRequestExtension
     *
     * @param {Object} oFilter - GeocodeFilterExtension ou RouteRequestExtension
     */
    addFilter : function (oFilter) {
        this.logger.error("overwritten method !");
    },

    /**
     * toString
     */
    toString : function () {
        this.logger.error("overwritten method !");
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AbstractService);


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _AbstractService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(102);
/* harmony import */ var _LocationUtilityService_GeocodeRequest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(104);
/* harmony import */ var _LocationUtilityService_ReverseGeocodeRequest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(107);
/* harmony import */ var _LocationUtilityService_GeocodeFilterExtension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(106);






/**
 * @classdesc
 *
 * Requête de type LocationUtilityService (LUS)
 * (Factory)
 *
 * @example
 * // encapsule un objet dans une coquille XSL, Factory sur les objets Geocode/ReverseGeocode
 * lus = new LocationUtilityService ();
 * lus.addRequest (req);
 * lus.toString();
 *  ou
 * lus = new LocationUtilityService ({
 *      location : "saint mandé",
 *      returnFreeForm : true,
 *      filterOptions : {
 *          type :  ['PositionOfInterest']
 *      }
 * });
 * lus.toString();
 *
 * // out ->
 * // <GeocodeRequest>
 * //   <Address countryCode="PositionOfInterest">
 * //     <freeFormAddress>saint mandé</freeFormAddress>
 * //   </Address>
 * // </GeocodeRequest>
 *
 * // creation de l'objet Geocode
 * req = new GeocodeRequest ();
 * req.addAddress (new Address (/*todo/*));
 * req.toString();
 * // out ->
 * // <GeocodeRequest>
 * //   <Address countryCode="PositionOfInterest">
 * //     <freeFormAddress>saint mandé</freeFormAddress>
 * //   </Address>
 * // </GeocodeRequest>
 *
 * // creation de l'objet ReverseGeocode
 * req = new ReverseGeocodeRequest ();
 * req.addPosition (new Position (position:{x: , y: }));
 * req.addPreference (['StreetAddress']);
 * req.toString();
 * // out ->
 * // <ReverseGeocodeRequest>
 * //     <Position>
 * //       <gml:Point xmlns:gml="http://www.opengis.net/gml">
 * //           <gml:pos>50.347775 3.205098</gml:pos>
 * //       </gml:Point>
 * //     </Position>
 * //     <ReverseGeocodePreference>StreetAddress</ReverseGeocodePreference>
 * //  </ReverseGeocodeRequest>
 *
 * @constructor
 * @alias Gp.Formats.XLS.LocationUtilityService
 * @param {Object} options - options
 * @param {Object}   options.location - location
 * @param {String}   options.position - position : {x : "", y : ""}
 * @param {String}   options.returnFreeForm - true|false
 * @param {Object}   options.filterOptions - filtres
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 *
 * @private
 */
function LocationUtilityService (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur LocationUtilityService ()]");

    if (!(this instanceof LocationUtilityService)) {
        throw new TypeError("LocationUtilityService constructor cannot be called as a function.");
    }

    /**
     * Nom de la classe
     */
    this.CLASSNAME = "LocationUtilityService";

    /**
     * Type de classe de geocodage
     * ex. GeocodeRequest ou ReverseGeocodeRequest
     */
    this.CLASSTYPE = null;

    // appel du constructeur par heritage
    _AbstractService__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);

    // on determine le type de geocodage si les options sont renseignées
    if (this.options) {
        this.CLASSTYPE = (this.options.location) ? "GeocodeRequest" : (this.options.position) ? "ReverseGeocodeRequest" : null;
    }
}

/**
 * @lends module:LocationUtilityService#
 */
LocationUtilityService.prototype = Object.create(_AbstractService__WEBPACK_IMPORTED_MODULE_1__["default"].prototype, {
    // todo
    // getter/setter
});

/**
 * Constructeur (alias)
 */
LocationUtilityService.prototype.constructor = LocationUtilityService;

/**
 * (overwrite) Ajout d'un objet de type LUS : GeocodeRequest ou ReverseGeocodeRequest
 *
 * @param {Object} oLUSRequest - objet de type LUS
 */
LocationUtilityService.prototype.addRequest = function (oLUSRequest) {
    // on determine le type de geocodage
    this.CLASSTYPE = oLUSRequest.CLASSNAME;

    // on controle les types acceptés
    switch (this.CLASSTYPE) {
        case "GeocodeRequest":
        case "ReverseGeocodeRequest":
            this.oRequest = oLUSRequest;
            break;
        default:
            throw new Error("Ce n'est pas un objet de type 'LUS Request' !?");
    }
};

/**
 * (overwrite) Ajout d'un objet de type GeocodeFilterExtension
 *
 * @param {Object} oFilter - objet de type Filtre
 */
LocationUtilityService.prototype.addFilter = function (oFilter) {
    // FIXME gestion des filtres à partir des tables de geocodages
    if (oFilter instanceof _LocationUtilityService_GeocodeFilterExtension__WEBPACK_IMPORTED_MODULE_4__["default"]) {
        this.oFilter = oFilter;
    }
};

/**
 * (overwrite) toString
 *
 * @returns {String} requête
 */
LocationUtilityService.prototype.toString = function () {
    // soit, on a un objet LUS Request déjà instancié
    // sinon, il faut le construire à partir des options à disposition
    if (!this.oRequest) {
        // il nous faut des options
        if (!this.options) {
            throw new Error("Les options ne sont pas renseignées, impossible de construire la requête !");
        }

        // si les options 'location' et 'position' sont renseignées,
        // on prendra par defaut le choix du geocodage direct
        if (this.CLASSTYPE === "GeocodeRequest") {
            var settingsDirect = {
                location : this.options.location,
                returnFreeForm : this.options.returnFreeForm,
                filterOptions : this.options.filterOptions || {}
            };
            this.oRequest = new _LocationUtilityService_GeocodeRequest__WEBPACK_IMPORTED_MODULE_2__["default"](settingsDirect);
            // ajout des filtres spécifiques au service du geocodage direct de l'IGN
            if (this.oFilter) {
                this.oRequest.addFilter(this.oFilter);
            }
        } else if (this.CLASSTYPE === "ReverseGeocodeRequest") {
            var settingsInv = {
                position : this.options.position,
                returnFreeForm : this.options.returnFreeForm,
                filterOptions : this.options.filterOptions || {}
            };
            this.oRequest = new _LocationUtilityService_ReverseGeocodeRequest__WEBPACK_IMPORTED_MODULE_3__["default"](settingsInv);
        } else {
            this.logger.error("impossible de determiner le type de geocodage : Direct ou Inverse !?");
        }
    }

    // objet indefini !?
    if (!this.oRequest) {
        throw new Error("Type de Geocodage indefini !");
    }

    this.strRequest = this.oRequest.toString();
    return this.strRequest;
};

/* harmony default export */ __webpack_exports__["default"] = (LocationUtilityService);


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _model_Address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(105);
/* harmony import */ var _GeocodeFilterExtension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106);




/**
 * @classdesc
 * Requête de geocodage direct
 *
 * ```
 * XSD
 * Geocodage direct (balise xsd) :
 *   element ref="RequestHeader" [ (attribute name="clientName" attribute name="clientPassword" attribute name="sessionID" attribute name="srsName" attribute name="MSID") ]
 *     element name="Request" attribute name="methodName" attribute name="version" attribute name="requestID" [ attribute name="maximumResponses" ]
 *       element name="GeocodeRequest" attribute name="returnFreeForm"
 *         element ref="xls:Address"
 * ```
 *
 * @example
 * // creation de l'objet Geocode an ajoutant un objet Address
 * req = new GeocodeRequest ();
 * req.returnFreeForm = true; // TODO !
 * req.addAddress (new Address ({
 *      location : "saint mandé",
 *      type : ['PositionOfInterest'],
 *      filter : {
 *          (...)
 *      }
 * }));
 * req.toString();
 * // out ->
 * // <GeocodeRequest>
 * //   <Address countryCode="PositionOfInterest">
 * //     <freeFormAddress>saint mandé</freeFormAddress>
 * //   </Address>
 * // </GeocodeRequest>
 *
 * // creation de l'objet Geocode avec les options uniquement
 * req = new GeocodeRequest ({
 *      location : "saint mandé",
 *      returnFreeForm : true,
 *      filterOptions : {
 *          type : ['PositionOfInterest'],
 *          (...)
 *      }
 * });
 * req.toString();
 * // out ->
 * // <GeocodeRequest>
 * //   <Address countryCode="PositionOfInterest">
 * //     <freeFormAddress>saint mandé</freeFormAddress>
 * //   </Address>
 * // </GeocodeRequest>
 * @constructor
 *
 * @alias Gp.Formats.XLS.LocationUtilityService.GeocodeRequest
 * @param {Object} options - options
 * @param {Object}   options.location - location
 * @param {String}   options.returnFreeForm - returnFreeForm
 * @param {String}   options.filterOptions - filtres
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 *
 * @private
 */
function GeocodeRequest (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur GeocodeRequest ()]");

    if (!(this instanceof GeocodeRequest)) {
        throw new TypeError("GeocodeRequest constructor cannot be called as a function.");
    }

    // options par defaut
    this.options = options || {};

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            this.options[opt] = options[opt];
        }
    }

    // TODO
    // gestion de l'option 'returnFreeForm' si elle n'est pas renseignée dans les options !

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "GeocodeRequest";
}

GeocodeRequest.prototype = {

    /**
     * @lends module:GeocodeRequest#
     */

    /**
     * request (out)
     * @type {String}
     */
    strRequest : null,

    /**
     * Addresse
     * @type {Address}
     */
    oAddress : null,

    /**
     * Filter
     * @type {GeocodeFilterExtension}
     */
    oFilter : null,

    /**
     * Template de la requête.
     * substitution des valeurs suivantes :
     * __ADDRESS__, __RETURNFREEFORM__
     */
    template : "<GeocodeRequest returnFreeForm=\"__RETURNFREEFORM__\">" +
        "__ADDRESS__" +
        "</GeocodeRequest>",

    /**
     * Ajout d'un objet de type Adresse
     *
     * @param {Object} oAddress - Adresse
     */
    addAddress : function (oAddress) {
        if (oAddress instanceof _model_Address__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            this.oAddress = oAddress;
        }
    },

    /**
     * Ajout d'un objet de type GeocodeFilterExtension
     *
     * @param {Object} oFilter - GeocodeFilterExtension
     */
    addFilter : function (oFilter) {
        // FIXME gestion des filtres à partir des tables de geocodages
        if (oFilter instanceof _GeocodeFilterExtension__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            this.oFilter = oFilter;
        }
    },

    /**
     * Constructeur (alias)
     */
    constructor : GeocodeRequest,

    /**
     * toString
     *
     * @returns {String} requête
     */
    toString : function () {
        var template = "";
        template = this.template;

        // soit on a déjà un objet Address instancié,
        // sinon, on le fabrique via les options
        if (!this.oAddress) {
            var settings = {};
            settings.location = this.options.location;
            settings.type = this.options.filterOptions.type || ["StreetAddress"];
            settings.filter = this.options.filterOptions;
            delete settings.filter.type; // on ne met pas le 'type' dans les filtres...

            // gestion des filtres
            if (this.oFilter) {
                // on reconstruit les filtres
                settings.filter = {};

                // on determine la liste des filtres possibles
                // pour chaque table de geocodage en param
                for (var idx in settings.type) {
                    var filter = settings.type[idx];
                    var oFilter = this.oFilter.getFilter(filter);

                    if (!oFilter) {
                        this.logger.warn("Le filtre '" + filter + "' n'existe pas !?");
                        continue;
                    }

                    var mFilter = this.options.filterOptions;

                    // correspondances des attributs de filtres possibles avec ceux qui sont en options
                    var attributs = oFilter.attributesList;
                    for (var idxe = 0; idxe < attributs.length; idxe++) {
                        var key = attributs[idxe];
                        if (mFilter[key]) {
                            var matchingKey = oFilter.serviceAttributes[idxe];
                            oFilter.placeAttributes[matchingKey] = mFilter[key];
                            this.logger.trace("Selection du filtre '" + key + "' sur le type '" + filter + "'.");
                        }
                    }

                    // ajout des valeurs des filtres
                    var places = oFilter.placeAttributes;
                    for (var kplace in places) {
                        if (places.hasOwnProperty(kplace)) {
                            settings.filter[kplace] = places[kplace];
                        }
                    }
                }
            }

            this.oAddress = new _model_Address__WEBPACK_IMPORTED_MODULE_1__["default"](settings);
            if (!this.oAddress) {
                throw new Error("La construction de l'adresse n'est pas correctement definie !?");
            }
        }

        // FIXME gestion des filtres pour un objet Address déjà instancié ?

        template = template.replace(/__ADDRESS__/g, this.oAddress.toString());
        template = template.replace(/__RETURNFREEFORM__/g, (this.options.returnFreeForm) ? "true" : "false");

        this.strRequest = template;
        return this.strRequest;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (GeocodeRequest);


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);



/**
 * @classdesc
 *
 * Location type "Address".
 *
 * Modèles de classes :
 * ------------------
 * ```
 *
 *                Address
 *            (est composé de)
 *           ______ | _________ _________________
 *          /       |          \                 \
 *      Place (StreetAddress ou FreeFormAddress) PostalCode
 *       (*)       _|_
 *                /   \
 *           Street   Building
 * ```
 * ```
 * XSD
 * Address (balise xsd) :
 *   ex. <Address countryCode="StreetAddress"><freeFormAddress>1 r de paris saint denis</freeFormAddress></Address>
 *   attribute name="countryCode"
 *     element name="freeFormAddress"
 *     element ref="xls:Place"
 *     element ref="gml:Envelope"
 *  ou
 *   ex. <Address countryCode="StreetAddress"><StreetAddress><Street>1 rue Marconi</Street></StreetAddress><Place type="Municipality">Metz</Place><PostalCode>57000</PostalCode></Address>
 *   attribute name="countryCode"
 *     element ref="xls:StreetAddress"
 *     element ref="xls:PostalCode"
 *     element ref="xls:Place"
 *     element ref="gml:Envelope"
 * ```
 *
 * @example
 * // simple
 * adr = new Address ({
 *    location : "2 av pasteur, Saint-Mandée",
 *    type : ["StreetAddress"],
 *    filter : {}
 * });
 * adr.toString();
 * // -> out
 * // <Address countryCode="StreetAddress">
 * //   <freeFormAddress>2 av pasteur, Saint-Mandée</freeFormAddress>
 * // </Address>
 *
 * // avec filtre
 * adr = new Address ({
 *    location : {
 *      number : 2,
 *      street : "av pasteur",
 *      city : "Saint-Mandée", // FIXME filter Place "commune" ou "municipality" ?
 *      postalCode : "94166"   // FIXME filter Place ou balise PostalCode ?
 *    },
 *    type : ["StreetAddress"],
 *    filter : {
 *      territory : "FR",
 *      department : "94"
 *    }
 * });
 * adr.toString();
 * // -> out
 * // <Address countryCode="StreetAddress">
 * //   <StreetAddress>
 * //   <Building number="2"/>
 * //   <Street>2 av pasteur</Street>
 * // </StreetAddress>
 * // <Place type="municipality">Saint-Mandée</Place>
 * // <Place type="departement">94</Place>
 * // <Place type="territoire">FR</Place>
 * // <PostalCode>94166</PostalCode>
 * // </Address>
 *
 * // avec bbox
 * adr = new Address ({
 *    location : "2 av pasteur, Saint-Mandée",
 *    type : ["StreetAddress"],
 *    filter : {
 *      bbox : {left:1, right:2, top:2, bottom:0}
 *    }
 * });
 * adr.toString();
 * // -> out
 * // <Address countryCode="StreetAddress">
 * //   <freeFormAddress>2 av pasteur, Saint-Mandée</freeFormAddress>
 * //   <gml:Envelope>
 * //     <gml:lowerCorner>1 0</gml:lowerCorner>
 * //     <gml:upperCorner>2 2</gml:upperCorner>
 * //   </gl:Envelope>
 * // </Address>
 *
 * @constructor
 * @alias Gp.Formats.XLS.LocationUtilityService.Address
 * @param {Object} options - options
 * @param {Object} options.location - location
 * @param {String} options.type - type
 * @param {String} options.filter - filtres
 * @param {String} options.filter.* - Filtré en fonction des tables de geocodage interrogées
 *
 * @private
 */
function Address (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Address");
    this.logger.trace("[Constructeur Address ()]");

    if (!(this instanceof Address)) {
        throw new TypeError("Address constructor cannot be called as a function.");
    }

    // param par defaut
    this.options = options || {
        location : {},
        type : ["StreetAddress"],
        filter : {}
    };

    // param obligatoire
    if (!this.options.location || Object.keys(this.options.location).length === 0) {
        throw new Error("l'option 'location' n'est pas renseignée !");
    }
}

/**
 * @lends module:Address#
 */
Address.prototype = {

    /**
     * Constructeur (alias)
     */
    constructor : Address,

    /**
     * request (out)
     * @type {String}
     */
    requestString : null,

    /**
     * Template de la requête.
     *
     * substitution des valeurs suivantes :
     * - address :  __COUNTRYCODE__, __LOCATION__, __PLACE__, __POSTALCODE__, __ENVELOPE__
     * - freeFormAddress : __FREEFORMADDRESSVALUE__
     * - streetAddress : __STREET__, __BUILDING__
     * - street : __STREETVALUE__
     * - building : __BUILDINGVALUE__
     * - place : __PLACEATYPE__, __PLACEVALUE__
     * - postalCode : __POSTALCODEVALUE__
     * - gml:envelope : __LEFT__ __BOTTOM__ __RIGHT__ __TOP__
     *
     * @todo gestion de l"indentation
     */
    template : {
        address : "<Address countryCode=\"__COUNTRYCODE__\">" +
            "__LOCATION__" +
            "__PLACE__" +
            "__POSTALCODE__" +
            "__ENVELOPE__" +
            "</Address>",
        location : {
            freeFormAddress : "<freeFormAddress>__FREEFORMADDRESSVALUE__</freeFormAddress>",
            streetAddress : {
                container : "<StreetAddress>" +
                    "__STREET__" +
                    "__BUILDING__" +
                    "</StreetAddress>",
                building : "<Building number=\"__BUILDINGVALUE__\"/>",
                street : "<Street>__STREETVALUE__</Street>"
            }
        },
        place : "<Place type=\"__PLACETYPE__\">__PLACEVALUE__</Place>",
        postalCode : "<PostalCode>__POSTALCODEVALUE__</PostalCode>",
        envelope : "<gml:Envelope>" +
            "<gml:lowerCorner>__LEFT__ __BOTTOM__</gml:lowerCorner>" +
            "<gml:upperCorner>__RIGHT__ __TOP__</gml:upperCorner>" +
            "</gml:Envelope>"
    }

};

/**
 * toString
 *
 * @returns {String} requête
 */
Address.prototype.toString = function () {
    var template = null;
    template = this.template.address;
    template = template.replace(/__COUNTRYCODE__/g, this.options.type);

    // on a une adresse structurée ou libre ?
    if (typeof this.options.location === "string") {
        // balise freeFormeAddress
        var tmplFreeFormAddress = this.template.location.freeFormAddress;
        tmplFreeFormAddress = tmplFreeFormAddress.replace(/__FREEFORMADDRESSVALUE__/g, this.options.location);
        template = template.replace(/__LOCATION__/g, tmplFreeFormAddress);
    } else {
        // balises Street et Building
        var tmplBuilding = "";
        var tmplStreet = "";

        if (this.options.location.number) {
            tmplBuilding = this.template.location.streetAddress.building;
            tmplBuilding = tmplBuilding.replace(/__BUILDINGVALUE__/g, this.options.location.number);
        }

        if (this.options.location.street) {
            tmplStreet = this.template.location.streetAddress.street;
            tmplStreet = tmplStreet.replace(/__STREETVALUE__/g, this.options.location.street);
        }

        // balise streetAddress
        var tmplStreetAddress = this.template.location.streetAddress.container;
        tmplStreetAddress = tmplStreetAddress.replace(/__STREET__/g, tmplStreet);
        tmplStreetAddress = tmplStreetAddress.replace(/__BUILDING__/g, tmplBuilding);
        template = template.replace(/__LOCATION__/g, tmplStreetAddress);
    }

    // a t on un filtre de type PostalCode ?
    var tmplPostalCode = "";
    if (this.options.location.postalCode) {
        tmplPostalCode = this.template.postalCode;
        tmplPostalCode = tmplPostalCode.replace(/__POSTALCODEVALUE__/g, this.options.location.postalCode);
    }

    // a t on un filtre de type GML::Envelope ?
    var tmplEnvelope = "";
    if (this.options.filter) {
        var bbox = this.options.filter.bbox;
        if (bbox) {
            tmplEnvelope = this.template.envelope;
            tmplEnvelope = tmplEnvelope.replace(/__LEFT__/g, bbox.left);
            tmplEnvelope = tmplEnvelope.replace(/__BOTTOM__/g, bbox.bottom);
            tmplEnvelope = tmplEnvelope.replace(/__RIGHT__/g, bbox.right);
            tmplEnvelope = tmplEnvelope.replace(/__TOP__/g, bbox.top);
        }
    }

    // liste des filtres Place
    var Places = [];

    // a t on des filtres de type Place ?
    var tmplPlace = "";
    if (this.options.filter) {
        var filters = this.options.filter;
        for (var filter in filters) {
            if (filter === "bbox") {
                continue;
            }
            // FIXME gestion des filtres spécifiques IGN ?
            tmplPlace = this.template.place;
            tmplPlace = tmplPlace.replace(/__PLACETYPE__/g, filter);
            tmplPlace = tmplPlace.replace(/__PLACEVALUE__/g, filters[filter]);
            Places.push(tmplPlace);
        }
    }

    // a t on un filtre de type Place dans location ?
    var tmplPlaceCity = "";
    if (this.options.location.city) {
        tmplPlaceCity = this.template.place;
        tmplPlaceCity = tmplPlaceCity.replace(/__PLACETYPE__/g, "Municipality");
        tmplPlaceCity = tmplPlaceCity.replace(/__PLACEVALUE__/g, this.options.location.city);
        Places.push(tmplPlaceCity);
    }

    template = template.replace(/__POSTALCODE__/g, tmplPostalCode);
    template = template.replace(/__PLACE__/g, Places.join("\n"));
    template = template.replace(/__ENVELOPE__/g, tmplEnvelope);

    this.requestString = template;
    return this.requestString;
};

/* harmony default export */ __webpack_exports__["default"] = (Address);


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);



/**
 * @classdesc
 *
 * Ajouter des extensions de filtres spécifiques au service de geocodage de l'IGN.
 * Ceci permet de contrôler les options spécifiques de la table de geocodage intérrogées.
 *
 * @example
 * var ext =  new GeocodeFiltersExtension ();
 *     ext.add (new Administratif ());
 *     ext.add (new StreetAddress ());
 *     ext.add (new PositionOfInterest ());
 *     ext.add (new CadastralParcel ());
 *
 * ext.getNames ()
 * // --> out
 * // [Administratif, StreetAddress, PositionOfInterest, CadastralParcel]
 *
 * ext.getFilters ()
 * // --> out
 * // [Object, Object, Object, Object] = tableau d'objet GeocodeLocation
 *
 * ext.getFilter ('StreetAddress')
 * // --> out
 * // {Object} = objet GeocodeLocation
 *
 * ext.getAttributs ('StreetAddress')
 * // --> out
 * // ["bbox", "number", "ID", "IDTR", "postalCode", "quality", "street", "territoire", "commune", "department", "insee", "municipality"]
 *
 * ext.setPlaceAttributs ('StreetAddress', {number:'', territoire:'', quality:'', fake:''})
 * // --> out
 * // (fake est écarté car il n'appartient pas à la liste !)
 *
 * ext.getPlaceAttributs ('StreetAddress')
 * // --> out
 * // {number : '', territoire : '', quality : ''}
 *
 * // Comment ajouter des filtres spécifiques au service de geocodage ?
 * var req = new GeocodeRequest ({
 *      location : "saint mandé",
 *      returnFreeForm : true,
 *      filterOptions : {
 *          type : ['PositionOfInterest'], <-- ajouter une extension afin de gerer les attributs de cette table de geocodage !
 *          (...)
 *      }
 *  })
 *  req.addFilter (new PositionOfInterest ());
 * @constructor
 * @alias Gp.Formats.XLS.LocationUtilityService.GeocodeFilterExtension
 *
 * @private
 */
function GeocodeFilterExtension () {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("GeocodeFilterExtension");
    this.logger.trace("[Constructeur GeocodeFilterExtension ()]");

    if (!(this instanceof GeocodeFilterExtension)) {
        throw new TypeError("GeocodeFilterExtension constructor cannot be called as a function.");
    }

    /**
     * Tableau de filtres (table de geocodage)
     */
    this.filters = [];
}

/**
 * @lends module:GeocodeFilterExtension#
 */
GeocodeFilterExtension.prototype = {

    /**
     * Constructeur (alias)
     */
    constructor : GeocodeFilterExtension,

    /**
     * Ajout d'un filtre
     *
     * @param {Object} oGeocodeLocation - objet de type 'GeocodeLocation'
     */
    addFilterExtensions : function (oGeocodeLocation) {
        // FIXME test sur le type d'objet !
        if (oGeocodeLocation) {
            // FIXME ou test sur ses propriétés !
            this.filters.push(oGeocodeLocation);
        }
    },

    // getter

    /**
     * Tableau de noms (tables de geocodage)
     *
     * @returns {Array.<String>} liste des noms de filtres
     */
    getNames : function () {
        var names = [];
        for (var idx in this.filters) {
            names.push(this.filters[idx].CLASSNAME);
        }
        this.logger.trace(names);
        return names;
    },

    /**
     * Retourne une table de geocodage
     *
     * @param {String} name - nom de la table de geocodage
     * @returns {Object} filtre
     */
    getFilter : function (name) {
        var filter = null;
        for (var idx in this.filters) {
            if (this.filters[idx].CLASSNAME === name) {
                filter = this.filters[idx];
            }
        }
        this.logger.trace(filter);
        return filter;
    },

    /**
     * Tableau d'objects (tables de geocodage)
     *
     * @returns {Array.<Object>} liste des filtres
     */
    getFilters : function () {
        this.logger.trace(this.filters);
        return this.filters;
    },

    /**
     * Récupère la liste des attributs (filtres) sur une table de geocodage
     *
     * @param {String} name - nom de la table de geocodage
     * @returns {Array} liste des attributs d'un filtre
     */
    getAttributs : function (name) {
        var attributs = [];
        for (var idx in this.filters) {
            if (this.filters[idx].CLASSNAME === name) {
                attributs = this.filters[idx].attributesList;
            }
        }
        this.logger.trace(attributs);
        return attributs;
    },

    /**
     * Ajout des attributs (filtres) sur une table de geocodage
     *
     * @param {String} name - nom de la table de geocodage
     * @param {Object} options - options de la table de geocodage
     */
    setPlaceAttributs : function (name, options) {
        var filter = this.getFilter(name);
        var attributs = this.getAttributs(name);
        for (var idx in attributs) {
            var value = attributs[idx];
            if (options[value]) {
                filter.placeAttributes[value] = options[value];
            }
        }
    },

    /**
     * Retourne les attributs (filtres) sur une table de geocodage
     *
     * @param {String} name - nom de la table de geocodage
     * @returns {Array} liste des attributs d'un filtre
     */
    getPlaceAttributs : function (name) {
        var places = {};
        for (var idx in this.filters) {
            if (this.filters[idx].CLASSNAME === name) {
                places = this.filters[idx].placeAttributes;
            }
        }
        this.logger.trace(places);
        return places;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (GeocodeFilterExtension);


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _model_Position__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(108);
/* harmony import */ var _model_Preference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);





/**
 * @classdesc
 *
 * Requête de geocodage inverse
 *
 * XSD
 * ```
 * Geocodage inverse (balise xsd) :
 *   element ref="RequestHeader" [ (attribute name="clientName" attribute name="clientPassword" attribute name="sessionID" attribute name="srsName" attribute name="MSID") ]
 *     element name="Request" attribute name="methodName" attribute name="version" attribute name="requestID" [ attribute name="maximumResponses" ]
 *       element name="ReverseGeocodeRequest"
 *         element ref="xls:Position"
 *         element name="ReverseGeocodePreference" (enumeration)
 * ```
 *
 * @example
 * // creation de l"objet ReverseGeocode
 * req = new ReverseGeocodeRequest ();
 * req.addPosition (new Position (position:{x: , y: }));
 * req.addPreference (["StreetAddress"]);
 * req.toString();
 * // out ->
 * // <ReverseGeocodeRequest>
 * //     <Position>
 * //       <gml:Point xmlns:gml="http://www.opengis.net/gml">
 * //           <gml:pos>50.347775 3.205098</gml:pos>
 * //       </gml:Point>
 * //     </Position>
 * //     <ReverseGeocodePreference>StreetAddress</ReverseGeocodePreference>
 * //  </ReverseGeocodeRequest>
 * @constructor
 * @alias Gp.Formats.XLS.ReverseGeocodeRequest
 * @param {Object} options - options
 * @param {Object}   options.position - position
 * @param {String}   options.returnFreeForm - returnFreeForm
 * @param {String}   options.filterOptions - filtres
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 *
 * @private
 */
function ReverseGeocodeRequest (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur ReverseGeocodeRequest ()]");

    if (!(this instanceof ReverseGeocodeRequest)) {
        throw new TypeError("ReverseGeocodeRequest constructor cannot be called as a function.");
    }

    // options par defaut
    this.options = options || {};

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            this.options[opt] = options[opt];
        }
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "ReverseGeocodeRequest";
}

ReverseGeocodeRequest.prototype = {

    /**
     * @lends module:ReverseGeocodeRequest#
     */

    /**
     * request (out)
     * @type {String}
     */
    strRequest : null,

    /**
     * Position
     * @type {Position}
     */
    oPosition : null,

    /**
     * Preference
     * @type {Preference}
     */
    oPreference : null,

    /**
     * Constructeur (alias)
     */
    constructor : ReverseGeocodeRequest,

    /**
     * Template de la requête.
     * substitution des valeurs suivantes :
     * __POSITION__, __PREFERENCE__, __RETURNFREEFORM__
     */
    template : "<ReverseGeocodeRequest returnFreeForm=\"__RETURNFREEFORM__\">" +
        "__POSITION__" +
        "__PREFERENCE__" +
        "</ReverseGeocodeRequest>",

    /**
     * Ajout d"un objet de type Position
     *
     * @param {Object} oPosition - Position
     */
    addPosition : function (oPosition) {
        if (oPosition instanceof _model_Position__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            this.oPosition = oPosition;
        }
    },

    /**
     * Ajout d"une liste de table de référence LUS :
     * [StreetAddress, PointOfInterest, CadastralParcel, Administrativ]
     *
     * @param {Object} oPreference - Preference
     */
    addPreferences : function (oPreference) {
        if (oPreference instanceof _model_Preference__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            this.oPreference = oPreference;
        }
    },

    /**
     * toString
     * @returns {String} requête
     */
    toString : function () {
        var template = "";
        template = this.template;

        // si on a déjà un objet Preference instancié,
        // sinon, on le fabrique via les options
        if (!this.oPreference) {
            this.oPreference = new _model_Preference__WEBPACK_IMPORTED_MODULE_2__["default"](this.options.filterOptions.type || ["StreetAddress"]);
            if (!this.oPreference) {
                throw new Error("Les preferences ne sont pas definies !?");
            }
        }
        template = template.replace(/__PREFERENCE__/g, this.oPreference.toString());

        // si on a déjà un objet Position instancié,
        // sinon, on le fabrique via les options
        if (!this.oPosition) {
            var settings = {
                position : this.options.position,
                filter : {}
            };

            // FIXME gestion des filtres ?
            if (this.options.filterOptions) {
                settings.filter = this.options.filterOptions;
                delete settings.filter.type; // pas besoin ?
            }
            this.oPosition = new _model_Position__WEBPACK_IMPORTED_MODULE_1__["default"](settings);
            if (!this.oPosition) {
                throw new Error("La position et ses filtres ne sont pas definis !?");
            }
        }
        template = template.replace(/__POSITION__/g, this.oPosition.toString());
        template = template.replace(/__RETURNFREEFORM__/g, (this.options.returnFreeForm) ? "true" : "false");

        this.strRequest = template;
        return this.strRequest;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocodeRequest);


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);


/**
 * @classdesc
 * Location de type Position
 *
 * ```
 * XSD
 * Position (balise xsd) :
 *   ex. <Position><gml:Point xmlns:gml="http://www.opengis.net/gml"><gml:pos>50.347775 3.205098</gml:pos></gml:Point></Position>
 *   ex. <Position><gml:CircleByCenterPoint xmlns:gml="http://www.opengis.net/gml"><gml:pos>48.85978570614691 2.2913572761128878</gml:pos><gml:radius>1000</gml:radius></gml:CircleByCenterPoint></Position>
 *   (au choix)
 *   element ref="gml:Point"
 *   element ref="gml:CircleByCenterPoint"
 *   element ref="gml:Polygon"
 *   element ref="gml:MultiPolygon"
 * ```
 *
 * FIXME les autres elements ne sont pas implémentés (QoP, Speed, Direction, Time, ...) ?
 *
 * ```
 * template : "<Position>
 *                  __GMLPOINT__
 *                  __GMLFILTER__
 *             </Position>"
 * ```
 * ```
 * GML : {
 *  pos     : "<gml:pos>__X__ __Y__</gml:pos>",
 *  point   : "<gml:Point xmlns:gml=\"http://www.opengis.net/gml\">__POS__</gml:Point>",
 *  circle  : "<gml:CircleByCenterPoint xmlns:gml=\"http://www.opengis.net/gml\">__POS__<gml:radius>__RADIUS__</gml:radius></gml:CircleByCenterPoint>",
 *  // not yet implemented !
 *  polygon      : "",
 *  multipolygon : ""
 * }
 * ```
 *
 * @constructor
 * @alias Gp.Formats.XLS.LocationUtilityService.Position
 * @param {Object} options - options données en entrée
 * @param {Object} options.position - x/y
 * @param {Object} options.filter - filtre
 * @param {Object} options.filter.circle - un cercle
 * @param {Object} options.filter.polygon - un polygone
 *
 * @private
 */
function Position (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Position");
    this.logger.trace("[Constructeur Position ()]");

    if (!(this instanceof Position)) {
        throw new TypeError("Position constructor cannot be called as a function.");
    }

    // param par defaut
    this.options = options || {};

    // param obligatoire
    if (!this.options.position) {
        throw new Error("l'option 'position' n'est pas renseignée !");
    }
}

/**
 * @lends module:Position#
 */
Position.prototype = {

    /**
     * Constructeur (alias)
     */
    constructor : Position,

    /**
     * request (out)
     * @type {String}
     */
    requestString : null,

    /**
     * Template de la requête.
     *
     * substitution des valeurs suivantes :
     * __GMLPOINT__ __GMLFILTER__
     * __X__ __Y__ __RADIUS__
     * __XY__
     * @todo indentation XML
     * @todo implementation classe GML
     */
    template : {
        position : "<Position>" +
            "__GMLPOINT__" +
            "__GMLFILTER__" +
            "</Position>",
        gml : {
            point : "<gml:Point xmlns:gml=\"http://www.opengis.net/gml\"><gml:pos>__X__ __Y__</gml:pos></gml:Point>",
            pos : null,
            filter : {
                bbox : "<gml:Envelope xmlns:gml=\"http://www.opengis.net/gml\">" +
                    "<gml:lowerCorner>__LEFT__ __BOTTOM__</gml:lowerCorner>" +
                    "<gml:upperCorner>__RIGHT__ __TOP__</gml:upperCorner>" +
                    "</gml:Envelope>",
                circle : "<gml:CircleByCenterPoint xmlns:gml=\"http://www.opengis.net/gml\"><gml:pos>__X__ __Y__</gml:pos><gml:radius>__RADIUS__</gml:radius></gml:CircleByCenterPoint>",
                polygon : "<gml:Polygon xmlns:gml=\"http://www.opengis.net/gml\"><gml:exterior><gml:LinearRing><gml:posList>__XY__</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>",
                multipolygon : null
            }
        }
    }
};

/**
 * toString
 *
 * @returns {String} requête
 */
Position.prototype.toString = function () {
    var template = this.template.position;

    var tmplGmlPoint = this.template.gml.point;
    tmplGmlPoint = tmplGmlPoint.replace(/__X__/g, this.options.position.x);
    tmplGmlPoint = tmplGmlPoint.replace(/__Y__/g, this.options.position.y);

    var tmplGmlFilter = "";
    if (this.options.filter) {
        var filter = this.options.filter;

        for (var name in filter) {
            switch (name) {
                case "circle":
                    tmplGmlFilter = this.template.gml.filter[name];
                    tmplGmlFilter = tmplGmlFilter.replace(/__X__/g, filter[name].x);
                    tmplGmlFilter = tmplGmlFilter.replace(/__Y__/g, filter[name].y);
                    tmplGmlFilter = tmplGmlFilter.replace(/__RADIUS__/g, filter[name].radius);
                    break;
                case "bbox":
                    tmplGmlFilter = this.template.gml.filter[name];
                    tmplGmlFilter = tmplGmlFilter.replace(/__LEFT__/g, filter[name].left);
                    tmplGmlFilter = tmplGmlFilter.replace(/__BOTTOM__/g, filter[name].bottom);
                    tmplGmlFilter = tmplGmlFilter.replace(/__RIGHT__/g, filter[name].right);
                    tmplGmlFilter = tmplGmlFilter.replace(/__TOP__/g, filter[name].top);
                    break;
                case "polygon":
                    // FIXME implementation simple du polygone !
                    // aucun test de fermeture du polygone, ni de gestion des trous !
                    tmplGmlFilter = this.template.gml.filter[name];
                    var strPoints = "";
                    var lstPoints = filter[name];
                    for (var i = 0; i < lstPoints.length; i++) {
                        var coord = lstPoints[i];
                        if (Array.isArray(coord)) {
                            this.logger.error("Holes are not implemented !");
                            break;
                        }
                        if ((coord.x && coord.y) || (coord.x === 0 || coord.y === 0)) {
                            strPoints += coord.x + " " + coord.y;
                        }
                        if (lstPoints.length !== i + 1) {
                            strPoints += " ";
                        }
                    }
                    tmplGmlFilter = tmplGmlFilter.replace(/__XY__/g, strPoints);
                    break;
                case "multipolygon":
                    this.logger.warn("Filter '" + name + "' is not yet implemented !");
                    break;
                default:
                    this.logger.error("This filter '" + name + "' is not useful !");
            }
        }
    }

    template = template.replace(/__GMLPOINT__/g, tmplGmlPoint);
    template = template.replace(/__GMLFILTER__/g, tmplGmlFilter);

    this.requestString = template;
    return this.requestString;
};

/* harmony default export */ __webpack_exports__["default"] = (Position);


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);


/**
 * @classdesc
 *
 * Preference (Reverse)
 *
 * FIXME liste des types de tables de geocodage
 *
 * ```
 * template : "<ReverseGeocodePreference>__TYPE__</ReverseGeocodePreference>"
 * ```
 *
 * @constructor
 * @alias Gp.Formats.XLS.LocationUtilityService.Preference
 * @param {String} type - type de table de geocodage
 *
 * @private
 *
 */

function Preference (type) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Preference");
    this.logger.trace("[Constructeur Preference ()]");

    if (!(this instanceof Preference)) {
        throw new TypeError("Preference constructor cannot be called as a function.");
    }

    /**
     * type de table de geocodage
     * @type {Array.<String>}
     */
    this.type = type;
}

/**
 * @lends module:Preference#
 */
Preference.prototype = {

    /**
     * Constructeur (alias)
     */
    constructor : Preference,

    /**
     * request (out)
     * @type {String}
     */
    requestString : null,

    /**
     * Template de la requête.
     *
     * substitution des valeurs suivantes :
     *  __TYPE__
     *
     */
    template : "<ReverseGeocodePreference>__TYPE__</ReverseGeocodePreference>"
};

/**
 * toString
 *
 * @returns {String} requête
 */
Preference.prototype.toString = function () {
    var Preferences = [];
    var tmplPreference = "";
    for (var idx = 0; idx < this.type.length; idx++) {
        tmplPreference = this.template;
        tmplPreference = tmplPreference.replace(/__TYPE__/g, this.type[idx]);
        Preferences.push(tmplPreference);
    }

    this.strRequest = Preferences.join("\n");
    return this.strRequest;
};

/* harmony default export */ __webpack_exports__["default"] = (Preference);


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(111);



/**
 * @classdesc
 * Format des attributs d'un résultat de géocodage de type StreetAddress.
 *
 * @constructor
 * @alias Gp.Services.Geocode.Request.StreetAddress
 * @private
 */
function StreetAddress () {
    if (!(this instanceof StreetAddress)) {
        throw new TypeError("StreetAddress constructor cannot be called as a function.");
    }

    // INFO
    // appel du constructeur de la classe mère
    // avec passage de param.
    _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    /**
     * Nom de la classe (heritage)
     * @type {String}
     */
    this.CLASSNAME = "StreetAddress";

    /**
     * Liste des attributs possibles pour une GeocodeLocation de type StreetAddress
     * - **bbox** : Emprise de l'adresse dans le système de coordonnées demandé {left, right, top, bottom}. *{Object}*
     * - **ID** : Identifiant BD ADRESSE dans le cas où le résultat est une adresse. *{String}*
     * - **IDTR** : Identifiant "Route Adresse" de la voie portant l'adresse dans la base BD ADRESSE. *{String}*
     * - **quality** : Indicateur de qualité du géocodage (pour plus d'infos : http://api.ign.fr/tech-docs-js/fr/developpeur/search.html *{String}*
     * - **territory** : Code du territoire français où se situe l'adresse *{String}*
     * - **commune** : Ville l'adresse. *{String}*
     * - **department** : Département l'adresse. *{String}*
     * - **insee** : Code INSEE de l'adresse. *{Number}*
     * - **municipality** : Municipalité de l'adresse. *{String}*
     */

    this.attributesList = ["bbox", "ID", "IDTR", "quality", "territory", "commune", "department", "insee", "municipality"];

    this.serviceAttributes = ["bbox", "ID", "IDTR", "Qualite", "Territoire", "Commune", "Departement", "INSEE", "Municipality"];
}

/**
 * @lends module:StreetAdress#
 */
StreetAddress.prototype = Object.create(_GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

/**
 * Constructeur (alias)
 */
StreetAddress.prototype.constructor = StreetAddress;

/* harmony default export */ __webpack_exports__["default"] = (StreetAddress);


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * @classdesc
 *
 * Liste des attributs des tables de geocodage
 * @constructor
 * @alias Gp.Services.Geocode.Request.GeocodeLocation
 * @private
 */
function GeocodeLocation () {
    if (!(this instanceof GeocodeLocation)) {
        throw new TypeError("GeocodeLocation constructor cannot be called as a function.");
    }

    /**
     * Objet qui peut prendre comme propriétés les valeurs du tableau serviceAttributes
     * @type {Object}
     */
    this.placeAttributes = {};

    /**
     * Tableau qui liste les attributs spécifiques selon le type de la GeocodeLocation.
     * Ces attributs correspondent à ceux saisis par l'utilisateur (légèrement différents de ceux du service)
     * @type {String[]}
     */
    this.attributesList = [];

    /**
     * Tableau qui liste les attributs spécifiques selon le type de la GeocodeLocation
     * Ces attributs correspondent à ceux interprétés par le service (balises Place).
     * @type {String[]}
     */
    this.serviceAttributes = [];
}

/**
 * @lends module:GeocodeLocation
 */
GeocodeLocation.prototype = {

    /**
     * Constructeur (alias)
     */
    constructor : GeocodeLocation

};

/* harmony default export */ __webpack_exports__["default"] = (GeocodeLocation);


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(111);



/**
 * @classdesc
 * Format des attributs d'un résultat de géocodage de type PositionOfInterest
 *
 * @constructor
 * @alias Gp.Services.Geocode.Request.PositionOfInterest
 * @private
 */
function PositionOfInterest () {
    if (!(this instanceof PositionOfInterest)) {
        throw new TypeError("PositionOfInterest constructor cannot be called as a function.");
    }

    // INFO
    // appel du constructeur de la classe mère
    // avec passage de param.
    _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    /**
     * Nom de la classe (heritage)
     * @type {String}
     */
    this.CLASSNAME = "PositionOfInterest";

    /**
     * Liste des attributs possibles pour une GeocodeLocation de type PositionOfInterest
     * - **bbox** : Emprise du toponyme dans le système de coordonnées demandé {left, right, top, bottom} *{Object}*
     * - **importance** : Importance du toponyme *{number}*
     * - **nature** : Nature du toponyme. *{String}*
     * - **territory** : Code du territoire français où se situe le toponyme *{String}*
     * - **commune** : Ville du toponyme. *{String}*
     * - **department** : Département du toponyme. *{String}*
     * - **insee** : Code INSEE de la commune où se situe le toponyme. *{Number}*
     * - **municipality** : Municipalité du toponyme. *{String}*
     */

    this.attributesList = ["bbox", "importance", "nature", "territory", "commune", "department", "insee", "municipality"];

    this.serviceAttributes = ["bbox", "Importance", "Nature", "Territoire", "Commune", "Departement", "INSEE", "Municipality"];
}

/**
 * @lends module:PositionOfInterest#
 */
PositionOfInterest.prototype = Object.create(_GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

/**
 * Constructeur (alias)
 */
PositionOfInterest.prototype.constructor = PositionOfInterest;

/* harmony default export */ __webpack_exports__["default"] = (PositionOfInterest);


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(111);



/**
 * @classdesc
 * Format des attributs d'un filtre de géocodage de type CadastralParcel.
 *
 * @constructor
 * @alias Gp.Services.Geocode.Request.CadastralParcel
 * @private
 */
function CadastralParcel () {
    if (!(this instanceof CadastralParcel)) {
        throw new TypeError("CadastralParcel constructor cannot be called as a function.");
    }

    // INFO
    // appel du constructeur de la classe mère
    // avec passage de param.
    _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "CadastralParcel";

    /**
     * Liste des attributs possibles pour une GeocodeLocation de type CadastralParcel
     * - **absorbedCity** : Code commune absorbée de la parcelle :
     *      lorsqu'une parcelle est issue p d'une ancienne commune qui a fusionné avec une autre.
     *      Sinon, le code vaut '000'. *{String}*
     * - **sheet** : Feuille de la parcelle (ex 1). *{String}*
     * - **number** : Numéro de la parcelle (ex. 0041) *{String}*
     * - **section** : Section de la parcelle (ex 0D). *{String}*
     * - **commune** : Ville du filtre. *{String}*
     * - **department** : Département du filtre. *{String}*
     * - **insee** : Code INSEE du filtre. *{Number}*
     * - **municipality** : Municipalité du filtre. *{String}*
     * - **origin** : L'origine de l'objet parcellaire renvoyé
     *      (correspond à l'attribut "type" dans la réponse XML)
     *      Pour plus d'informations : http://api.ign.fr/tech-docs-js/fr/developpeur/search.html#Recherche_par_parcelles_cadastrales *{Number}*
     *
     */

    this.attributesList = ["absorbedCity", "sheet", "number", "section", "commune", "department", "insee", "municipality", "origin"];

    this.serviceAttributes = ["CommuneAbsorbee", "Feuille", "Numero", "Section", "Commune", "Departement", "INSEE", "Municipality", "Type"];
}

/**
 * @lends module:CadastralParcel#
 */
CadastralParcel.prototype = Object.create(_GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

/**
 * Constructeur (alias)
 */
CadastralParcel.prototype.constructor = CadastralParcel;

/* harmony default export */ __webpack_exports__["default"] = (CadastralParcel);


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(111);



/**
 * @classdesc
 * Format des attributs d'un filtre de géocodage de type Administratif.
 * @constructor
 * @alias Gp.Services.Geocode.Request.Administratif
 * @private
 */
function Administratif () {
    if (!(this instanceof Administratif)) {
        throw new TypeError("Administratif constructor cannot be called as a function.");
    }

    // INFO
    // appel du constructeur de la classe mère
    // avec passage de param.
    _GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    /**
     * Nom de la classe (heritage)
     * @type {String}
     */
    this.CLASSNAME = "Administratif";

    /**
     * Liste des attributs possibles pour une GeocodedLocation de type Administratif
     * - **bbox** : Emprise de l'unité administrative dans le système de coordonnées demandé *{left, right, top, bottom}*
     * - **prefecture** - Nom de la préfécture de la région ou du département *{String}*
     * - **inseeRegion** - Numéro INSEE de la région *{String}*
     * - **inseeDepartment** - Numéro INSEE du département *{String}*
     * - **municipality** - Nom de l'unité administrative *{String}*
     *
     */

    this.attributesList = ["bbox", "prefecture", "inseeRegion", "inseeDepartment", "municipality"];

    this.serviceAttributes = ["bbox", "Prefecture", "InseeRegion", "InseeDepartement", "Municipality"];
}

/**
 * @lends module:Administratif#
 */
Administratif.prototype = Object.create(_GeocodeLocation__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

/**
 * Constructeur (alias)
 */
Administratif.prototype.constructor = Administratif;

/* harmony default export */ __webpack_exports__["default"] = (Administratif);


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Formats_XML__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);
/* harmony import */ var _Formats_DirectGeocodeResponseReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(116);
/**
 * Factory pour générer une reponse JSON à partir d'un XML
 * ou d'un JSON encapsulant du XML
 * (Factory)
 *
 * @module GeocodeResponseFactory
 * @alias Gp.Services.Geocode.Response.GeocodeResponseFactory
 * @todo La reponse JSON peut encapsuler un XML !
 * @private
 */
// import Logger from "../../../Utils/LoggerByDefault";





var DirectGeocodeReponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Geocode
     *
     * @example
     *   var options = {
     *      response :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // data de type GeocodeResponse
        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                data = options.response;
            } else {
                try {
                    var p = new _Formats_XML__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        reader : _Formats_DirectGeocodeResponseReader__WEBPACK_IMPORTED_MODULE_3__["default"]
                    });

                    if (typeof options.response === "string") {
                        p.setXMLString(options.response);
                    } else {
                        p.setXMLDoc(options.response);
                    }

                    data = p.parse();

                    if (!data) {
                        throw new Error("L'analyse de la réponse du service !?");
                    }
                } catch (e) {
                    var message = e.message;
                    if (typeof options.response === "string") {
                        message += "('" + options.response + "')";
                    } else {
                        message += "('" + options.response.documentElement.innerHTML + "')";
                    }
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", message),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"].TYPE_UNKERR,
                        status : -1
                    }));
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"].TYPE_SRVERR,
                        status : 200 // FIXME : 200 ?
                    }));
                    return;
                }
            }
        } else {
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"]({
                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY"),
                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"].TYPE_SRVERR,
                status : -1 // FIXME : status response
            }));
            return;
        }

        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (DirectGeocodeReponseFactory);


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(117);
/* harmony import */ var _Response_model_DirectGeocodedLocation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(118);

/**
 * Fonction retournant un objet contenant des clés de lecture (readers)
 *      qui permettent de parser des réponses XML du service de géocodage direct du Géoportail
 *      afin de récupérer les résultats retournés.
 * @module DirectGeocodeResponseReader
 * @alias Gp.Services.Geocode.Formats.DirectGeocodeResponseReader
 * @private
 */

// import Logger from "../../../Utils/LoggerByDefault";





/**
 * @member DirectGeocodeResponseReader
 */
var DirectGeocodeResponseReader = {};

/**
 * @property {String} DirectGeocodeResponseReader.VERSION - version du service de géocodage
 */
DirectGeocodeResponseReader.VERSION = "1.2";

/**
 * Objet stockant les différents namespaces et les URI associées
 */
DirectGeocodeResponseReader.NAMESPACES = {
    xmlns : "http://www.opengis.net/xls",
    gml : "http://www.opengis.net/gml",
    xls : "http://www.opengis.net/xls",
    xlsext : "http://www.opengis.net/xlsext",
    xsi : "http://www.w3.org/2001/XMLSchema-instance"
};

/**
 * Localisation (URL) du schema de définition du XML (XSD)
 */
DirectGeocodeResponseReader.SCHEMALOCATION = "http://wxs.ign.fr/schemas/olsAll.xsd";

/**
 * Namespace par défaut du format
 */
DirectGeocodeResponseReader.DEFAULTPREFIX = "xls";

/**
 * Objet contenant des fonctions de lecture, appelées "READERS"
 *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire
 *      et la valeur associée est une fonction (node, data)
 *      où node est un noeud du document DOM
 *      et data est un objet où l'on stocke les informations lues dans le XML.
 */
DirectGeocodeResponseReader.READERS = {

    xls : {

        /** TODO : jsdoc block */
        XLS : function (root) {
            var geocodeResponse = new _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__["default"]();

            // vérification de la version du service, et des namespaces de l'en-tête
            __checkServiceAttributes(root);

            // puis lancement de la lecture de l'ensemble des noeuds, en bouclant sur les childNodes
            __getChildNodes(root, geocodeResponse);

            return geocodeResponse;
        },

        /** TODO : jsdoc block */
        GeocodedAddress : function (node, geocodeResponse) {
            var geocodedLocation = new _Response_model_DirectGeocodedLocation__WEBPACK_IMPORTED_MODULE_3__["default"]();

            __getChildNodes(node, geocodedLocation);

            // Ajout du résultat au tableau geocodedLocations de geocodeReponse
            if (geocodeResponse && Array.isArray(geocodeResponse.locations)) {
                geocodeResponse.locations.push(geocodedLocation);
            }
        },

        /** TODO : jsdoc block */
        GeocodeMatchCode : function (node, geocodedLocation) {
            var acc = node.getAttribute("accuracy");
            if (acc && geocodedLocation) {
                geocodedLocation.accuracy = parseFloat(acc);
            }
            var matchType = node.getAttribute("matchType");
            if (matchType && geocodedLocation) {
                geocodedLocation.matchType = matchType;
            }
        },

        /** TODO : jsdoc block */
        Address : function (node, geocodedLocation) {
            var countrycode = node.getAttribute("countryCode");
            if (geocodedLocation && countrycode) {
                geocodedLocation.type = countrycode;
            }
            // on va récupérer les autres informations (StreetAddress, place, postalCode...)
            __getChildNodes(node, geocodedLocation);
        },

        /** TODO : jsdoc block */
        freeFormAddress : function (node, geocodedLocation) {
            if (geocodedLocation && geocodedLocation.hasOwnProperty("placeAttributes")) {
                geocodedLocation.placeAttributes.freeform = __getChildValue(node);
            }
        },

        /** TODO : jsdoc block */
        Building : function (node, geocodedLocation) {
            var num = node.getAttribute("number");
            if (geocodedLocation && geocodedLocation.hasOwnProperty("placeAttributes")) {
                if (num) {
                    geocodedLocation.placeAttributes.number = num;
                } else if (node.getAttribute("buildingName")) {
                    geocodedLocation.placeAttributes.number = node.getAttribute("buildingName");
                } else if (node.getAttribute("subdivision")) {
                    geocodedLocation.placeAttributes.number = node.getAttribute("subdivision");
                }
            }
        },

        /** TODO : jsdoc block */
        Street : function (node, geocodedLocation) {
            if (geocodedLocation && geocodedLocation.hasOwnProperty("placeAttributes")) {
                // in case of a streetAddress result : street represents the street name
                if (geocodedLocation.type === "StreetAddress") {
                    geocodedLocation.placeAttributes.street = __getChildValue(node);

                    // in case of a cadastral parcel result : street represents the cadastral parcel identifier
                } else if (geocodedLocation.type === "CadastralParcel") {
                    geocodedLocation.placeAttributes.cadastralParcel = __getChildValue(node);
                }
            }
        },

        /** TODO : jsdoc block */
        Place : function (node, geocodedLocation) {
            var placeType = node.getAttribute("type");
            var placeName = __getChildValue(node);

            if (geocodedLocation && geocodedLocation.hasOwnProperty("placeAttributes")) {
                if (placeType === "Municipality") {
                    geocodedLocation.placeAttributes.municipality = placeName;
                } else if (placeType === "Bbox") {
                    var values = placeName.split(";");
                    if (values.length === 4) {
                        geocodedLocation.placeAttributes.bbox = {
                            left : parseFloat(values[0]),
                            right : parseFloat(values[2]),
                            top : parseFloat(values[1]),
                            bottom : parseFloat(values[3])
                        };
                    }
                } else if (placeType === "Commune") {
                    geocodedLocation.placeAttributes.commune = placeName;
                } else if (placeType === "Departement") {
                    geocodedLocation.placeAttributes.department = placeName;
                } else if (placeType === "INSEE") {
                    geocodedLocation.placeAttributes.insee = placeName;
                } else if (placeType === "Qualite") {
                    geocodedLocation.placeAttributes.quality = placeName;
                } else if (placeType === "Territoire") {
                    geocodedLocation.placeAttributes.territory = placeName;
                } else if (placeType === "ID") {
                    geocodedLocation.placeAttributes.ID = placeName;
                } else if (placeType === "ID_TR") {
                    geocodedLocation.placeAttributes.IDTR = placeName;
                } else if (placeType === "Importance") {
                    geocodedLocation.placeAttributes.importance = parseInt(placeName, 10);
                } else if (placeType === "Nature") {
                    geocodedLocation.placeAttributes.nature = placeName;
                } else if (placeType === "Numero") {
                    geocodedLocation.placeAttributes.number = placeName;
                } else if (placeType === "Feuille") {
                    geocodedLocation.placeAttributes.sheet = placeName;
                } else if (placeType === "Section") {
                    geocodedLocation.placeAttributes.section = placeName;
                } else if (placeType === "CommuneAbsorbee") {
                    geocodedLocation.placeAttributes.absorbedCity = placeName;
                } else if (placeType === "Arrondissement") {
                    if (placeName) {
                        geocodedLocation.placeAttributes.arrondissement = placeName;
                    }
                } else if (placeType === "Type") {
                    geocodedLocation.placeAttributes.origin = placeName;
                } else if (placeType === "Prefecture") {
                    geocodedLocation.placeAttributes.prefecture = placeName;
                } else if (placeType === "InseeRegion") {
                    geocodedLocation.placeAttributes.inseeRegion = placeName;
                } else if (placeType === "InseeDepartment") {
                    geocodedLocation.placeAttributes.inseeDepartment = placeName;
                }
            }
        },

        /** TODO : jsdoc block */
        PostalCode : function (node, geocodedLocation) {
            if (geocodedLocation && geocodedLocation.hasOwnProperty("placeAttributes")) {
                geocodedLocation.placeAttributes.postalCode = __getChildValue(node);
            }
        },

        /** TODO : jsdoc block */
        Error : function (node) {
            // on imagine qu'on a une balise ainsi :
            // <Error message="Message..." errorCode="InternalServerError"/>
            var srvMess = node.getAttribute("message");
            var errorCode = node.getAttribute("errorCode");
            var message = _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION",
                "(" + errorCode + ") : " + srvMess);
            throw new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"]({
                message : message,
                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"].TYPE_SRVERR
            });
        }
    },

    gml : {

        /** TODO : jsdoc block */
        pos : function (node, geocodedLocation) {
            var pos = __getChildValue(node);
            if (geocodedLocation && pos) {
                geocodedLocation.position = {
                    x : parseFloat(pos.split(" ")[0]),
                    y : parseFloat(pos.split(" ")[1])
                };
            }
        }
    },

    /** TODO : jsdoc block */
    ExceptionReport : function (node) {
        var response = {};
        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                if (child.nodeName === "Exception") {
                    response.exceptionReport = DirectGeocodeResponseReader.READERS["Exception"](child);
                }
            }
        }
        return response;
    },

    /** TODO : jsdoc block */
    Exception : function (node) {
        var exceptionReport = {};

        // get exception code
        var exceptionCode = node.getAttribute("exceptionCode");
        if (exceptionCode) {
            exceptionReport.exceptionCode = exceptionCode;
        }

        // get exception message
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            exceptionReport.exception = textNode.nodeValue;
        }

        return exceptionReport;
    }

};

/**
 * Méthode permettant de lancer la lecture d'une réponse XML du service de géocodage,
 *      à l'aide des READERS de la classe.
 *
 * @method DirectGeocodeResponseReader.read
 * @param {DOMElement} root - racine de la réponse XML à lire
 * @return {Object} geocodeResponse|exceptionReport : l'objet contenant les informations de la réponse XML,
 *      sous la forme d'un objet GeocodeResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.
 * @static
 * @memberof DirectGeocodeResponseReader
 */
DirectGeocodeResponseReader.read = function (root) {
    if (root.nodeName === "XLS") {
        var nsPrefix = root.prefix;
        if (!nsPrefix) {
            nsPrefix = DirectGeocodeResponseReader.DEFAULTPREFIX;
        }
        var geocodeResponse = DirectGeocodeResponseReader.READERS[nsPrefix][root.nodeName](root);
        return geocodeResponse;
    } else if (root.nodeName === "ExceptionReport") {
        var exceptionReport = DirectGeocodeResponseReader.READERS[root.nodeName](root);
        return exceptionReport;
    } else {
        var mess = _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", root.nodeName);
        throw new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"]({
            message : mess,
            type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"].TYPE_UNKERR,
            status : 200
        });
    }
};

/**
 * Récupération des attributs d'un noeud élément
 *
 * @private
 * @memberof DirectGeocodeResponseReader
 * @method __getAttributes
 * @param {DOMElement} node - noeud contenant l'attribut recherché
 * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs
 */
function __getAttributes (node) {
    if (node.attributes.length > 0) {
        var nodeAttributes = {};
        var attributes = node.attributes;
        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            nodeAttributes[attribute.nodeName] = attribute.nodeValue;
        }
        return nodeAttributes;
    }
}

/**
 * Récupération des noeuds enfants à partir d'un noeud donné, pour lecture (readNode).
 *
 * @private
 * @memberof DirectGeocodeResponseReader
 * @method __getChildNodes
 * @param {DOMElement} node - a DOM node
 * @param {Array|Object} [data] - an object to be filled with node data
 */
function __getChildNodes (node, data) {
    if (node.hasChildNodes()) {
        var children = node.childNodes;
        var child;
        var childName;
        var childPrefix;

        for (var i = 0; i < children.length; i++) {
            child = children[i];

            if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE
                childName = child.localName || child.baseName || child.nodeName;
                childPrefix = child.prefix || DirectGeocodeResponseReader.DEFAULTPREFIX;

                if (DirectGeocodeResponseReader.READERS[childPrefix][childName]) {
                    var reader = DirectGeocodeResponseReader.READERS[childPrefix][childName];
                    reader(child, data);
                } else {
                    __getChildNodes(child, data);
                }
            }
        }
    }
}

/**
 * Lecture de la valeur du premier child d'un noeud, si elle existe.
 *
 * @private
 * @memberof DirectGeocodeResponseReader
 * @method __getChildValue
 * @param {DOMElement} node - a DOM node
 * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.
 */
function __getChildValue (node) {
    var textNode;
    var value = "";

    if (node.hasChildNodes()) {
        textNode = node.firstChild;
        if (textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            value = textNode.nodeValue;
        }
    }
    return value;
}

/**
 * Vérification des attributs du service, dans la balise XLS de la réponse :
 *      version, namespaces, et namespace par défaut doivent correspondre à ceux attendus.
 *
 * @private
 * @memberof DirectGeocodeResponseReader
 * @method __checkServiceAttributes
 * @param {DOMElement} XLSNode - a DOM node, corresponding to XLS first tag.
 */
function __checkServiceAttributes (XLSNode) {
    if (XLSNode.attributes.length > 0) {
        // on récupère et parcourt les attributs de la balise XLS de la réponse
        var xlsAttributes = __getAttributes(XLSNode);
        for (var att in xlsAttributes) {
            if (xlsAttributes.hasOwnProperty(att)) {
                // vérification de la version
                if (att === "version") {
                    if (xlsAttributes["version"] !== DirectGeocodeResponseReader.VERSION) {
                        console.log("[DirectGeocodeResponseReader] geocode version is not the expected one : there may be errors in parsing");
                        return;
                    }
                }

                // on vérifie que l'uri du namespace par défaut est bien celle que l'on attend
                if (att === "xmlns") {
                    if (xlsAttributes[att] !== DirectGeocodeResponseReader.NAMESPACES[DirectGeocodeResponseReader.DEFAULTPREFIX]) {
                        console.log("[DirectGeocodeResponseReader] geocode response default namespace is not the expected one");
                        return;
                    }
                    continue;
                }

                var prefix = att.split(":")[0];
                var ns = att.split(":")[1];

                // si on a un autre xmlns, on vérifie aussi les URI
                if (prefix === "xmlns" && ns) {
                    // si l'attribut correspond à un namespace défini dans le reader
                    if (DirectGeocodeResponseReader.NAMESPACES[ns]) {
                        // il faut que les URI correspondent aussi.
                        if (DirectGeocodeResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {
                            console.log("[DirectGeocodeResponseReader] geocode response " + att + " namespace is not the expected one");
                            return;
                        }
                    }
                }

                // pour finir on vérifie la localisation du schema XSD du service
                if (ns === "schemaLocation") {
                    if (DirectGeocodeResponseReader.SCHEMALOCATION !== xlsAttributes[att]) {
                        console.log("[DirectGeocodeResponseReader] geocode response schema location is not the expected one");
                        return;
                    }
                }
            }
        }
    }
}

/* harmony default export */ __webpack_exports__["default"] = (DirectGeocodeResponseReader);


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Response object for {@link module:Services~geocode Gp.Services.geocode ()} or {@link module:Services~reverseGeocode Gp.Services.reverseGeocode ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Array.<Gp.Services.Geocode.DirectGeocodedLocation|Gp.Services.Geocode.ReverseGeocodedLocation>} locations - locations array.
 *
 * @namespace
 * @alias Gp.Services.GeocodeResponse
 */
function GeocodeResponse () {
    if (!(this instanceof GeocodeResponse)) {
        throw new TypeError("GeocodeResponse constructor cannot be called as a function.");
    }

    this.locations = [];
}

GeocodeResponse.prototype = {

    constructor : GeocodeResponse

};

/* harmony default export */ __webpack_exports__["default"] = (GeocodeResponse);


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeocodedLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);



/**
 * Single location object returned by the underlying geocoding web service.
 *
 * @property {Float} accuracy - Accuracy of the response towards the requested location between 0 (unaccurate) and 1 (exact match).
 *
 * @namespace
 * @extends {Gp.Services.Geocode.GeocodedLocation}
 * @alias Gp.Services.Geocode.DirectGeocodedLocation
 */
function DirectGeocodedLocation () {
    if (!(this instanceof DirectGeocodedLocation)) {
        throw new TypeError("DirectGeocodedLocation constructor cannot be called as a function.");
    }

    // INFO
    // appel du constructeur de la classe mère
    // avec passage de param.
    _GeocodedLocation__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    /**
     * Nom de la classe (heritage) : "DirectGeocodedLocation"
     * @type {String}
     */
    this.CLASSNAME = "DirectGeocodedLocation";

    this.accuracy = null;
}

DirectGeocodedLocation.prototype = Object.create(_GeocodedLocation__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

DirectGeocodedLocation.prototype.constructor = DirectGeocodedLocation;

/* harmony default export */ __webpack_exports__["default"] = (DirectGeocodedLocation);


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Location object holding common properties returned by the underlying geocoding and reverse geocoding web service.
 *
 * @property {Gp.Point} position - Position of the location given in the requested coordinates system.
 * @property {String} type - location type "StreetAddress" (for an address), "PositionOfInterest" (for a place name) or "CadastralParcel" (for cadastral parcel).
 * @property {String} matchType - how geocoding is performed : "street number" (exact address), "street enhanced" (street number calculated by interpolation), "street" (only the street), "city" (only the city).
 * @property {Object} placeAttributes - Associative array matching the following attributes with their values given by the underlying web service :
 *
 * *Common attributes : *
 *
 * - **freeform** - freeform complete Address.
 * - **bbox** - Bounding Box *{@link Gp.BBox}*.
 * - **municipality** - Municipality
 *
 * *if type === "StreetAddress" : *
 *
 * - **number** - Street number.
 * - **ID** - Identifier of the address in the [BD ADRESSE Database]{@link http://professionnels.ign.fr/bdadresse}.
 * - **IDTR** - Identifier of the lineString in the [BD ADRESSE Database]{@link http://professionnels.ign.fr/bdadresse}.
 * - **postalCode** - PostCode
 * - **quality** - Geocoding quality ([see]{@link http://api.ign.fr/tech-docs-js/developpeur/search.html})
 * - **street** - Street name
 * - **territory** - French Territory code
 * - **commune** - City
 * - **department** - Department
 * - **insee** - INSEE Code
 *
 *
 * *if type === "PositionOfInterest" :*
 *
 * - **importance** - Place name importance
 * - **nature** - Place name nature
 * - **postalCode** - PostCode
 * - **territory** - French Territory code
 * - **commune** - City
 * - **department** - Department
 * - **insee** - INSEE Code
 *
 *
 * *si type = "CadastralParcel" :*
 *
 * - **absorbedCity** - when a parcel comes from a city that was absorbed by another, code of that old city. "000" otherwise.
 * - **arrondissement** - arrondissement
 * - **cadastralParcel** - cadastral parcel code
 * - **district** - district
 * - **sheet** - Parcel Sheet (eg. "1").
 * - **number** - Parcel Number (eg. "0041")
 * - **section** - Parcel Section (eg. "0D").
 * - **commune** - Parcel municipality.
 * - **department** - Parcel Department.
 * - **insee** - INSEE Code.
 * - **origin** - Parcel origin (see "type" attribute in the [underlying web service response]{@link http://api.ign.fr/tech-docs-js/developpeur/search.html#Cadastral_parcels_search})
 *
 * @namespace
 * @alias Gp.Services.Geocode.GeocodedLocation
 */
function GeocodedLocation () {
    if (!(this instanceof GeocodedLocation)) {
        throw new TypeError("GeocodedLocation constructor cannot be called as a function.");
    }

    this.position = {
        x : null,
        y : null
    };

    this.matchType = null;

    this.placeAttributes = {};

    this.type = null;
}

GeocodedLocation.prototype = {

    constructor : GeocodedLocation

};

/* harmony default export */ __webpack_exports__["default"] = (GeocodedLocation);


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _Request_ReverseGeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(121);
/* harmony import */ var _Response_ReverseGeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(122);








/**
 * @classdesc
 * Appel du service de géocodage inverse du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.ReverseGeocode
 *
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {Object} options.position - Position du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs.
 *      @param {Float} options.position.x - Abcisse du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs. (= longitude si srs = "CRS:84", latitude si srs = "EPSG:4326")
 *      @param {Float} options.position.y - Ordonnée du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs. (= latitude si srs = "CRS:84", longitude si srs = "EPSG:4326")
 *
 * @param {Object} [options.filterOptions] - Les propriétés possibles de cet objet sont décrites ci-après.
 * @param {Object} [options.filterOptions.bbox] - Emprise dans laquelle on souhaite effectuer la recherche.
 *      Les propriétés possibles de cet objet sont décrites ci-après.
 *      @param {Float} options.filterOptions.bbox.left   - Abscisse du côté gauche de la BBOX
 *      @param {Float} options.filterOptions.bbox.right  - Abscisse du côté droit de la BBOX
 *      @param {Float} options.filterOptions.bbox.top    - Ordonnée supérieure de la BBOX
 *      @param {Float} options.filterOptions.bbox.bottom - Ordonnée inférieure de la BBOX
 *
 * @param {Object} [options.filterOptions.circle] - Cercle dans lequel on souhaite effectuer la recherche.
 *      Les propriétés possibles de cet objet sont décrites ci-après.
 *      @param {Float} options.filterOptions.circle.x      - Abscisse du centre du cercle de recherche.
 *      @param {Float} options.filterOptions.circle.y      - Ordonnée du centre du cercle de recherche.
 *      @param {Float} options.filterOptions.circle.radius - Rayon du cercle de recherche.
 *
 * @param {Array.<Object>} [options.filterOptions.polygon] - Polygone dans lequel on souhaite effectuer la recherche.
 *      Liste des couples x et y pour chaque point constituant le polygone.
 *
 * @param {Array.<String>} [options.filterOptions.type = "StreetAddress"] - Type de l'objet recherché.
 *      Le service de géocodage du Géoportail permet de rechercher des 'PostionOfInterest' pour des toponymes, des 'StreetAddress'
 *      pour des adresses postales et/ou des 'CadastralParcel' pour des parcelles cadastrales.
 *      D'autres types pourront être rajoutés selon l'évolution du service.
 *      Par défaut, type = ['StreetAddress'].
 *
 * @param {Number} [options.maximumResponses] - Nombre de réponses maximal que l'on souhaite recevoir.
 *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 25.
 *
 * @param {String} [options.srs = CRS:84] - Système de coordonnées dans lequel les paramètres géographiques en entrée et la réponse du service sont exprimés.
 *      Pas de valeur par défaut.
 *      Si le serveur consulté est celui du Géoportail, la valeur par défaut est : "CRS:84".
 *
 * @example
 *   var options = {
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      position : {x:0 , y:0},
 *      filterOptions :{
 *          bbox : {left : 0, right : 1, top : 1, bottom : 0},
 *          [circle : {
 *              x : 0,
 *              y : 0,
 *              radius : 100
 *          }]
 *          [polygon  : [{x:0,y:0}, {x:1,y:1}, {x:2,y:2}, {x:3,y:2}, {x:4,y:1}, {x:0,y:0}]]
 *          type : ['StreetAddress']
 *      },
 *      maximumResponses : 25,
 *      srs : 'EPSG:4326'
 *   };
 *
 * @private
 */
function ReverseGeocode (options) {
    if (!(this instanceof ReverseGeocode)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "ReverseGeocode"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "ReverseGeocode";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.ReverseGeocode");
    this.logger.trace("[Constructeur ReverseGeocode (options)]");

    if (!options.position) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position"));
    }

    // on lance une exception afin d'eviter au service de le faire...
    if (options.position.x === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position.x"));
    }

    if (options.position.y === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position.y"));
    }

    // ajout des options spécifiques au service
    this.options.position = options.position;

    // on definit des filtres par defaut
    if (!options.filterOptions || typeof options.filterOptions !== "object") {
        this.options.filterOptions = options.filterOptions = {
            type : ["StreetAddress"]
        };
    }

    // FIXME ECMAScript 5 support (valable pour un objet uniquement !)
    // ceci permet de tester le cas où : object = {}
    if (Object.keys(options.filterOptions).length === 0) {
        this.options.filterOptions = {
            type : ["StreetAddress"]
        };
    }

    // on teste pour chaque filtre, les conditions suivantes : null ou vide !
    var filter = Object.keys(options.filterOptions);
    for (var i = 0; i < filter.length; i++) {
        var key = filter[i];
        if (!options.filterOptions[key] || Object.keys(options.filterOptions[key]).length === 0) {
            delete this.options.filterOptions[key];
        }
    }

    this.options.filterOptions.type = options.filterOptions.type || ["StreetAddress"];
    // on vérifie que le type est bien dans un tableau
    if (!Array.isArray(this.options.filterOptions.type)) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "filterOptions.type"));
    }

    this.options.maximumResponses = options.maximumResponses || 25;

    // FIXME : cet attribut (returnFreeForm) n'est pas spécifié dans la doc du constructeur ?
    // Il est inutile en effet, mais présent dans les specs...
    this.options.returnFreeForm = options.returnFreeForm || false;
    // info : en réalité le service ne reconnait que EPSG:4326. this.options.srs permet essentiellement de différencier EPSG:4326 (lat,lon) et CRS:84 (lon,lat)
    this.options.srs = options.srs || "CRS:84";

    // si on n'a pas un systeme de coordonnées EPSG géographique, il faut inverser les coordonnées
    // (car elles sont en lon, lat alors que le service attend une position en lat, lon).
    // dans le cas d'EPSG:4326 par exemple, les coordonnées sont bien en lat, lon donc on ne fait rien.
    if (ReverseGeocode.geoEPSG.indexOf(this.options.srs) === -1) {
        // pour la position
        this.options.position = {
            x : this.options.position.y,
            y : this.options.position.x
        };
        // pour les filtres spatiaux s'ils sont spécifiés
        if (this.options.filterOptions && this.options.filterOptions.circle) {
            var circle = this.options.filterOptions.circle;
            this.options.filterOptions.circle = {
                x : circle.y,
                y : circle.x,
                radius : circle.radius
            };
        }
        if (this.options.filterOptions && this.options.filterOptions.polygon) {
            var polygon = this.options.filterOptions.polygon;
            for (i = 0; i < polygon.length; i++) {
                var coords = polygon[i];
                this.options.filterOptions.polygon[i] = {
                    x : coords.y,
                    y : coords.x
                };
            }
        }
    }

    // attributs d'instances

    /**
     * Format forcé de la réponse du service : "xml"
     * sauf si l'on souhaite une reponse brute (options.rawResponse)
     */
    this.options.outputFormat = (this.options.rawResponse) ? "" : "xml";
}

/**
 * @lends module:ReverseGeocode#
 */
ReverseGeocode.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
ReverseGeocode.prototype.constructor = ReverseGeocode;

/**
 * (overwrite)
 * Création de la requête
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
ReverseGeocode.prototype.buildRequest = function (error, success) {
    var options = {
        httpMethod : this.options.httpMethod,
        // options specifiques du service
        position : this.options.position,
        returnFreeForm : this.options.returnFreeForm,
        filterOptions : this.options.filterOptions,
        srs : "EPSG:4326", // info : en réalité le service ne reconnait que EPSG:4326. this.options.srs permet essentiellement de différencier EPSG:4326 (lat,lon) et CRS:84 (lon,lat)
        maximumResponses : this.options.maximumResponses
    };

    this.request = _Request_ReverseGeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_4__["default"].build(options);

    // on teste si la requete a bien été construite !
    (!this.request)
        ? error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD")))
        : success.call(this, this.request);
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
ReverseGeocode.prototype.analyzeResponse = function (error, success) {
    if (this.response) {
        var options = {
            response : this.response,
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this
        };

        _Response_ReverseGeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/**
 * Codes EPSG géographiques (lat/lon). Utiles car les coordonnées doivent être inversées.
 */
ReverseGeocode.geoEPSG = ["EPSG:4326"];

/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocode);


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Formats_XLS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99);
/* harmony import */ var _Formats_XLS_LocationUtilityService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(103);
/**
 * Creation d'une requête OpenLS en mode POST ou GET
 * (Factory)
 *
 * @module ReverseGeocodeRequestFactory
 * @alias Gp.Services.Geocode.Request.ReverseGeocodeRequestFactory
 * @private
 */




var ReverseGeocodeRequestFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Geocode
     *
     * @example
     *   var options = {
     *      httpMethod :
     *      // options specifiques du service
     *      position :
     *      returnFreeForm :
     *      filterOptions :
     *      srs :
     *      maximumResponses :
     *   };
     *   var result = ReverseGeocodeRequestFactory.build(options);
     *   if (!result) {
     *       // error...
     *   }
     * @returns {String} request
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("ReverseGeocodeRequestFactory");
        logger.trace(["ReverseGeocodeRequestFactory::build()"]);

        // options non definies
        var settings = options || {};

        var request = null;

        // objet LUS
        var oLUS = new _Formats_XLS_LocationUtilityService__WEBPACK_IMPORTED_MODULE_2__["default"]({
            position : settings.position,
            returnFreeForm : settings.returnFreeForm,
            filterOptions : settings.filterOptions
        });

        // Format XLS
        var oXLS = new _Formats_XLS__WEBPACK_IMPORTED_MODULE_1__["default"]({
            srsName : settings.srs,
            maximumResponses : settings.maximumResponses
        });
        oXLS.namespace = true;
        oXLS.setService(oLUS);

        // request brute !
        request = oXLS.build();

        // en mode GET, la requête est encodée
        // et le param. 'qxml' est ajouté
        if (settings.httpMethod === "GET") {
            var myRequest = "qxml=" +
                encodeURIComponent(request)
                    .replace(/-/g, "%2D")
                    .replace(/_/g, "%5F")
                    .replace(/\./g, "%2E")
                    .replace(/!/g, "%21")
                    .replace(/~/g, "%7E")
                    .replace(/\*/g, "%2A")
                    .replace(/'/g, "%27")
                    .replace(/\(/g, "%28")
                    .replace(/\)/g, "%29");
            request = myRequest;
        }

        logger.trace(request);

        return request;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocodeRequestFactory);


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _Formats_XML__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);
/* harmony import */ var _Formats_ReverseGeocodeResponseReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(123);
/**
 * Factory pour générer une reponse JSON à partir d'un XML
 * ou d'un JSON encapsulant du XML
 * (Factory)
 *
 * @module ReverseGeocodeResponseFactory
 * @alias Gp.Services.ReverseGeocode.Response.ReverseGeocodeResponseFactory
 * @todo La reponse JSON peut encapsuler un XML !
 * @private
 */






var ReverseGeocodeReponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant ReverseGeocode
     *
     * @example
     *   var options = {
     *      response :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // data de type ReverseGeocodeResponse
        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                data = options.response;
            } else {
                try {
                    var p = new _Formats_XML__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        reader : _Formats_ReverseGeocodeResponseReader__WEBPACK_IMPORTED_MODULE_3__["default"]
                    });

                    if (typeof options.response === "string") {
                        p.setXMLString(options.response);
                    } else {
                        p.setXMLDoc(options.response);
                    }

                    data = p.parse();

                    if (!data) {
                        throw new Error("L'analyse de la réponse du service !?");
                    }
                } catch (e) {
                    // on relaye l'erreur reçue
                    e.status = 200;
                    options.onError.call(options.scope, e);
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                // TODO : quand cela arrive-t-il ?
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }

                // dans le cas d'un srs non EPSG géographique, il faut réinverser les coordonnées (lat,lon => lon,lat)
                if (options.scope && options.scope.options && options.scope.options.srs && options.scope.options.srs !== "EPSG:4326") {
                    var location;
                    var pos;
                    if (data.locations) {
                        for (var i = 0; i < data.locations.length; i++) {
                            location = data.locations[i];
                            if (location) {
                                pos = location.position;
                                if (pos) {
                                    // on inverse les 2 coordonnées
                                    location.position = {
                                        x : pos.y,
                                        y : pos.x
                                    };
                                }
                            }
                        }
                    }
                }
            }
        } else {
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"]({
                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__["default"].getMessage("SERVICE_RESPONSE_EMPTY"),
                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"].TYPE_SRVERR,
                status : -1 // FIXME : status response
            }));
            return;
        }

        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocodeReponseFactory);


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(117);
/* harmony import */ var _Response_model_ReverseGeocodedLocation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(124);

/**
 * Fonction retournant un objet contenant des clés de lecture (readers)
 *      qui permettent de parser des réponses XML du service de géocodage inverse du Géoportail
 *      afin de récupérer les résultats retournés.
 * @module ReverseGeocodeResponseReader
 * @alias Gp.Services.Geocode.Formats.ReverseGeocodeResponseReader
 * @private
 */

// import Logger from "../../../Utils/LoggerByDefault";





/**
 * Objet ReverseGeocodeResponseReader
 * @member {Object} ReverseGeocodeResponseReader
 *
 * @property {String} ReverseGeocodeResponseReader.VERSION - Version du service de géocodage
 *
 * @property {Object} ReverseGeocodeResponseReader.NAMESPACES - Objet stockant les différents namespaces et les URI associées
 *
 * @property {String} ReverseGeocodeResponseReader.SCHEMALOCATION - Localisation (URL) du schema de définition du XML (XSD)
 *
 * @property {String} ReverseGeocodeResponseReader.DEFAULTPREFIX - Namespace par défaut du format
 *
 * @property {Object} ReverseGeocodeResponseReader.READERS - Objet contenant des fonctions de lecture, appelées "READERS"
 *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire
 *      et la valeur associée est une fonction (node, data)
 *      où node est un noeud du document DOM
 *      et data est un objet où l'on stocke les informations lues dans le XML.
 *
 * @property {Method} ReverseGeocodeResponseReader.read - Méthode permettant de lancer la lecture d'une réponse XML du service de géocodage,
 *      à l'aide des READERS de la classe.
 *
 */

var ReverseGeocodeResponseReader = {};

/**
 * version du service de géocodage
 */
ReverseGeocodeResponseReader.VERSION = "1.2";

/**
 * Objet stockant les différents namespaces et les URI associées
 */
ReverseGeocodeResponseReader.NAMESPACES = {
    xmlns : "http://www.opengis.net/xls",
    gml : "http://www.opengis.net/gml",
    xls : "http://www.opengis.net/xls",
    xlsext : "http://www.opengis.net/xlsext",
    xsi : "http://www.w3.org/2001/XMLSchema-instance"
};

/**
 * Localisation (URL) du schema de définition du XML (XSD)
 */
ReverseGeocodeResponseReader.SCHEMALOCATION = "http://wxs.ign.fr/schemas/olsAll.xsd";

/**
 * Namespace par défaut du format
 */
ReverseGeocodeResponseReader.DEFAULTPREFIX = "xls";

/**
 * Objet contenant des fonctions de lecture, appelées "READERS"
 *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire
 *      et la valeur associée est une fonction (node, data)
 *      où node est un noeud du document DOM
 *      et data est un objet où l'on stocke les informations lues dans le XML.
 */
ReverseGeocodeResponseReader.READERS = {

    xls : {

        /** TODO : jsdoc block */
        XLS : function (root) {
            var reverseGeocodeResponse = new _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__["default"]();

            // vérification de la version du service, et des namespaces de l'en-tête
            __checkServiceAttributes(root);

            // puis lancement de la lecture de l'ensemble des noeuds, en bouclant sur les childNodes
            __getChildNodes(root, reverseGeocodeResponse);

            return reverseGeocodeResponse;
        },

        /** TODO : jsdoc block */
        ReverseGeocodedLocation : function (node, reverseGeocodeResponse) {
            var reverseGeocodedLocation = new _Response_model_ReverseGeocodedLocation__WEBPACK_IMPORTED_MODULE_3__["default"]();

            __getChildNodes(node, reverseGeocodedLocation);

            // Ajout du résultat au tableau locations de reverseGeocodeResponse
            if (reverseGeocodeResponse && Array.isArray(reverseGeocodeResponse.locations)) {
                reverseGeocodeResponse.locations.push(reverseGeocodedLocation);
            }
        },

        /** TODO : jsdoc block */
        Address : function (node, reverseGeocodedLocation) {
            var countrycode = node.getAttribute("countryCode");
            if (reverseGeocodedLocation && countrycode) {
                reverseGeocodedLocation.type = countrycode;
            }
            // on va récupérer les autres informations (StreetAddress, place, postalCode...)
            __getChildNodes(node, reverseGeocodedLocation);
        },

        /** TODO : jsdoc block */
        Building : function (node, reverseGeocodedLocation) {
            var num = node.getAttribute("number");
            if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty("placeAttributes")) {
                if (num) {
                    reverseGeocodedLocation.placeAttributes.number = num;
                } else if (node.getAttribute("buildingName")) {
                    reverseGeocodedLocation.placeAttributes.number = node.getAttribute("buildingName");
                } else if (node.getAttribute("subdivision")) {
                    reverseGeocodedLocation.placeAttributes.number = node.getAttribute("subdivision");
                }
            }
        },

        /** TODO : jsdoc block */
        Street : function (node, reverseGeocodedLocation) {
            // in case of a streetAddress result : street represents the street name
            if (reverseGeocodedLocation.type === "StreetAddress") {
                reverseGeocodedLocation.placeAttributes.street = __getChildValue(node);

                // in case of a cadastral parcel result : street represents the cadastral parcel identifier
            } else if (reverseGeocodedLocation.type === "CadastralParcel") {
                reverseGeocodedLocation.placeAttributes.cadastralParcel = __getChildValue(node);
            }
        },

        /** TODO : jsdoc block */
        Place : function (node, reverseGeocodedLocation) {
            var placeType = node.getAttribute("type");
            var placeName = __getChildValue(node);

            if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty("placeAttributes")) {
                if (placeType === "Municipality") {
                    reverseGeocodedLocation.placeAttributes.municipality = placeName;
                } else if (placeType === "Bbox") {
                    var values = placeName.split(";");
                    if (values.length === 4) {
                        reverseGeocodedLocation.placeAttributes.bbox = {
                            left : parseFloat(values[0]),
                            right : parseFloat(values[2]),
                            top : parseFloat(values[1]),
                            bottom : parseFloat(values[3])
                        };
                    }
                } else if (placeType === "Commune") {
                    reverseGeocodedLocation.placeAttributes.commune = placeName;
                } else if (placeType === "Departement") {
                    reverseGeocodedLocation.placeAttributes.department = placeName;
                } else if (placeType === "INSEE") {
                    reverseGeocodedLocation.placeAttributes.insee = placeName;
                } else if (placeType === "Qualite") {
                    reverseGeocodedLocation.placeAttributes.quality = placeName;
                } else if (placeType === "Territoire") {
                    reverseGeocodedLocation.placeAttributes.territory = placeName;
                } else if (placeType === "ID") {
                    reverseGeocodedLocation.placeAttributes.ID = placeName;
                } else if (placeType === "ID_TR") {
                    reverseGeocodedLocation.placeAttributes.IDTR = placeName;
                } else if (placeType === "Importance") {
                    reverseGeocodedLocation.placeAttributes.importance = parseInt(placeName, 10);
                } else if (placeType === "Nature") {
                    reverseGeocodedLocation.placeAttributes.nature = placeName;
                } else if (placeType === "Numero") {
                    reverseGeocodedLocation.placeAttributes.number = placeName;
                } else if (placeType === "Feuille") {
                    reverseGeocodedLocation.placeAttributes.sheet = placeName;
                } else if (placeType === "Section") {
                    reverseGeocodedLocation.placeAttributes.section = placeName;
                } else if (placeType === "CommuneAbsorbee") {
                    reverseGeocodedLocation.placeAttributes.absorbedCity = placeName;
                } else if (placeType === "Arrondissement") {
                    if (placeName) {
                        reverseGeocodedLocation.placeAttributes.arrondissement = placeName;
                    }
                } else if (placeType === "Type") {
                    reverseGeocodedLocation.placeAttributes.origin = placeName;
                } else if (placeType === "Prefecture") {
                    reverseGeocodedLocation.placeAttributes.prefecture = placeName;
                } else if (placeType === "InseeRegion") {
                    reverseGeocodedLocation.placeAttributes.inseeRegion = placeName;
                } else if (placeType === "InseeDepartment") {
                    reverseGeocodedLocation.placeAttributes.inseeDepartment = placeName;
                }
            }
        },

        /** TODO : jsdoc block */
        PostalCode : function (node, reverseGeocodedLocation) {
            if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty("placeAttributes")) {
                reverseGeocodedLocation.placeAttributes.postalCode = __getChildValue(node);
            }
        },

        /** TODO : jsdoc block */
        SearchCentreDistance : function (node, reverseGeocodedLocation) {
            if (reverseGeocodedLocation) {
                reverseGeocodedLocation.searchCenterDistance = parseFloat(node.getAttribute("value"));
            }
        },

        /** TODO : jsdoc block */
        Error : function (node) {
            // <Error message="For input string : &quot;2,45&quot;" errorCode="InternalServerError"/>
            var srvMess = node.getAttribute("message");
            var errorCode = node.getAttribute("errorCode");
            var message = _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION",
                "(" + errorCode + ") : " + srvMess);
            throw new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"]({
                message : message,
                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"].TYPE_SRVERR
            });
        }
    },

    gml : {

        /** TODO : jsdoc block */
        pos : function (node, reverseGeocodedLocation) {
            var pos = __getChildValue(node);
            if (reverseGeocodedLocation && pos) {
                reverseGeocodedLocation.position = {
                    x : parseFloat(pos.split(" ")[0]),
                    y : parseFloat(pos.split(" ")[1])
                };
            }
        }
    },

    xlsext : {
        /** TODO : jsdoc block */
        ExtendedGeocodeMatchCode : function (node, reverseGeocodedLocation) {
            if (reverseGeocodedLocation) {
                reverseGeocodedLocation.matchType = __getChildValue(node);
            }
        }
    },

    /** TODO : jsdoc block */
    ExceptionReport : function (node) {
        var response = {};
        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                if (child.nodeName === "Exception") {
                    response.exceptionReport = ReverseGeocodeResponseReader.READERS["Exception"](child);
                }
            }
        }
        return response;
    },

    /** TODO : jsdoc block */
    Exception : function (node) {
        var exceptionReport = {};

        // get exception code
        var exceptionCode = node.getAttribute("exceptionCode");
        if (exceptionCode) {
            exceptionReport.exceptionCode = exceptionCode;
        }

        // get exception message
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            exceptionReport.exception = textNode.nodeValue;
        }

        return exceptionReport;
    }

};

/**
 * Méthode permettant de lancer la lecture d'une réponse XML du service de géocodage,
 *      à l'aide des READERS de la classe.
 *
 * @method ReverseGeocodeResponseReader.read
 * @param {DOMElement} root - racine de la réponse XML à lire
 * @return {Object} geocodeResponse|exceptionReport : l'objet contenant les informations de la réponse XML,
 *      sous la forme d'un objet GeocodeResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.
 * @static
 * @memberof ReverseGeocodeResponseReader
 */
ReverseGeocodeResponseReader.read = function (root) {
    if (root.nodeName === "XLS") {
        var nsPrefix = root.prefix;
        if (!nsPrefix) {
            nsPrefix = ReverseGeocodeResponseReader.DEFAULTPREFIX;
        }
        var geocodeResponse = ReverseGeocodeResponseReader.READERS[nsPrefix][root.nodeName](root);
        return geocodeResponse;
    } else if (root.nodeName === "ExceptionReport") {
        var exceptionReport = ReverseGeocodeResponseReader.READERS[root.nodeName](root);
        return exceptionReport;
    } else {
        throw new Error("Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.");
    }
};

/**
 * Récupération des attributs d'un noeud élément
 *
 * @private
 * @memberof ReverseGeocodeResponseReader
 * @method __getAttributes
 * @param {DOMElement} node - noeud contenant l'attribut recherché
 * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs
 */
function __getAttributes (node) {
    if (node.attributes.length > 0) {
        var nodeAttributes = {};
        var attributes = node.attributes;
        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            nodeAttributes[attribute.nodeName] = attribute.nodeValue;
        }
        return nodeAttributes;
    }
}

/**
 * Récupération des noeuds enfants à partir d'un noeud donné, pour lecture (readNode).
 *
 * @private
 * @memberof ReverseGeocodeResponseReader
 * @method __getChildNodes
 * @param {DOMElement} node - a DOM node
 * @param {Array|Object} [data] - an object to be filled with node data
 */
function __getChildNodes (node, data) {
    if (node.hasChildNodes()) {
        var children = node.childNodes;
        var child;
        var childName;
        var childPrefix;

        for (var i = 0; i < children.length; i++) {
            child = children[i];

            if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE
                childName = child.localName || child.baseName || child.nodeName;
                childPrefix = child.prefix || ReverseGeocodeResponseReader.DEFAULTPREFIX;

                if (ReverseGeocodeResponseReader.READERS[childPrefix][childName]) {
                    var reader = ReverseGeocodeResponseReader.READERS[childPrefix][childName];
                    reader(child, data);
                } else {
                    __getChildNodes(child, data);
                }
            }
        }
    }
}

/**
 * Lecture de la valeur du premier child d'un noeud, si elle existe.
 *
 * @private
 * @memberof ReverseGeocodeResponseReader
 * @method __getChildValue
 * @param {DOMElement} node - a DOM node
 * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.
 */
function __getChildValue (node) {
    var textNode;
    var value = "";

    if (node.hasChildNodes()) {
        textNode = node.firstChild;
        if (textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            value = textNode.nodeValue;
        }
    }
    return value;
}

/**
 * Vérification des attributs du service, dans la balise XLS de la réponse :
 *      version, namespaces, et namespace par défaut doivent correspondre à ceux attendus.
 *
 * @private
 * @memberof ReverseGeocodeResponseReader
 * @method __checkServiceAttributes
 * @param {DOMElement} XLSNode - a DOM node, corresponding to XLS first tag.
 */
function __checkServiceAttributes (XLSNode) {
    if (XLSNode.attributes.length > 0) {
        // on récupère et parcourt les attributs de la balise XLS de la réponse
        var xlsAttributes = __getAttributes(XLSNode);
        for (var att in xlsAttributes) {
            if (xlsAttributes.hasOwnProperty(att)) {
                // vérification de la version
                if (att === "version") {
                    if (xlsAttributes["version"] !== ReverseGeocodeResponseReader.VERSION) {
                        console.log("[ReverseGeocodeResponseReader] geocode version is not the expected one : there may be errors in parsing");
                        return;
                    }
                }

                // on vérifie que l'uri du namespace par défaut est bien celle que l'on attend
                if (att === "xmlns") {
                    if (xlsAttributes[att] !== ReverseGeocodeResponseReader.NAMESPACES[ReverseGeocodeResponseReader.DEFAULTPREFIX]) {
                        console.log("[ReverseGeocodeResponseReader] geocode response default namespace is not the expected one");
                        return;
                    }
                    continue;
                }

                var prefix = att.split(":")[0];
                var ns = att.split(":")[1];

                // si on a un autre xmlns, on vérifie aussi les URI
                if (prefix === "xmlns" && ns) {
                    // si l'attribut correspond à un namespace défini dans le reader
                    if (ReverseGeocodeResponseReader.NAMESPACES[ns]) {
                        // il faut que les URI correspondent aussi.
                        if (ReverseGeocodeResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {
                            console.log("[ReverseGeocodeResponseReader] geocode response " + att + " namespace is not the expected one");
                            return;
                        }
                    }
                }

                // pour finir on vérifie la localisation du schema XSD du service
                if (ns === "schemaLocation") {
                    if (ReverseGeocodeResponseReader.SCHEMALOCATION !== xlsAttributes[att]) {
                        console.log("[ReverseGeocodeResponseReader] geocode response schema location is not the expected one");
                        return;
                    }
                }
            }
        }
    }
}

/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocodeResponseReader);


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GeocodedLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);



/**
 * Single location object returned by the underlying reverse geocoding web service.
 *
 * @property {Float} searchCenterDistance - Distance between the requested point and the location.
 *
 * @namespace
 * @extends {Gp.Services.Geocode.GeocodedLocation}
 * @alias Gp.Services.Geocode.ReverseGeocodedLocation
 */
function ReverseGeocodedLocation () {
    if (!(this instanceof ReverseGeocodedLocation)) {
        throw new TypeError("ReverseGeocodedLocation constructor cannot be called as a function.");
    }

    // INFO
    // appel du constructeur de la classe mère
    // avec passage de param.
    _GeocodedLocation__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    /**
     * Nom de la classe (heritage) : "ReverseGeocodedLocation"
     * @type {String}
     */
    this.CLASSNAME = "ReverseGeocodedLocation";

    this.searchCenterDistance = null;
}

ReverseGeocodedLocation.prototype = Object.create(_GeocodedLocation__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

ReverseGeocodedLocation.prototype.constructor = ReverseGeocodedLocation;

/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocodedLocation);


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _Response_AutoCompleteResponseFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(55);







/**
 * @classdesc
 * Appel du service d'autocomplétion du Géoportail :
 * envoi de la requête construite selon les paramètres en options,
 * éventuellement parsing et analyse  de la réponse,
 * retour d'une réponse en paramètre de la fonction onSuccess.
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.AutoComplete
 *
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String} options.text - La chaîne de caractère à compléter.
 *      Cette chaîne n'est pas "URL encodée".
 *      C'est l'API qui s'occupe de l'encoder pour l'inclure dans la requête.
 *
 * @param {Array.<String>} [options.filterOptions.type = "StreetAddress"] - Type de l'objet recherché.
 *      Le service d'autocomplétion du Géoportail permet de rechercher des toponymes 'PostionOfInterest' et/ou des adresses postales 'StreetAddress'.
 *      D'autres types pourront être rajoutés selon l'évolution du service.
 *      Par défaut, type = ['StreetAddress'].
 *
 * @param {Array.<String>} [options.filterOptions.territory] - Limitation de la zone de recherche de localisants.
 *      Le service d'autocomplétion du Géoportail permet de limiter la recherche à la métropole et la Corse : options.filterOptions.territory = ['METROPOLE'],
 *      DOMS TOMS : options.filterOptions.territory = ['DOMTOM'], ou à une liste de départements : options.filterOptions.territory = ['31', '34']
 *      Pas de valeur par défaut.
 *      La valeur par défaut est donc celle du service.
 *      Le service d'autocomplétion du Géoportail renvoie toutes les informations quand aucun territoire n'est spécifié.
 *
 * @param {Number} [options.maximumResponses = 10] - Nombre de réponses maximal que l'on souhaite recevoir.
 *      Pas de valeur par défaut.
 *      La valeur par défaut sera donc celle du service : 10.
 *
 * @example
 *   var options = {
 *      // options communes aux services
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      text : "",
 *      filterOptions : {
 *          type : ["StreetAddress"],
 *          territory : ['METROPOLE', 'DOMTOM', '31']
 *      },
 *      maximumResponses : 10
 *   };
 * @private
 */
function AutoComplete (options) {
    if (!(this instanceof AutoComplete)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_3__["default"].getMessage("CLASS_CONSTRUCTOR", "AutoComplete"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "AutoComplete";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("Gp.Services.AutoComplete");
    this.logger.trace("[Constructeur AutoComplete (options)]");

    if (!options.text) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_3__["default"].getMessage("PARAM_MISSING", "text"));
    }

    // ajout des options spécifiques au service
    this.options.text = options.text;

    // on definit des filtres par defaut
    if (!options.filterOptions || typeof options.filterOptions !== "object") {
        this.options.filterOptions = options.filterOptions = {
            territory : [],
            type : ["StreetAddress"]
        };
    }

    // FIXME ECMAScript 5 support (valable pour un objet uniquement !)
    // ceci permet de tester le cas où : object = {}
    if (Object.keys(options.filterOptions).length === 0) {
        this.options.filterOptions = {
            territory : [],
            type : ["StreetAddress"]
        };
    }

    this.options.filterOptions.type = options.filterOptions.type || ["StreetAddress"];
    this.options.filterOptions.territory = options.filterOptions.territory || [];
    this.options.maximumResponses = options.maximumResponses || 10;

    // INFO
    // le service ne repond pas en mode POST (405 Method Not Allowed)
    if (this.options.protocol === "XHR" && this.options.httpMethod === "POST") {
        this.logger.warn("Le service ne gére pas le mode d'interrogation en POST, on bascule sur du GET !");
        this.options.httpMethod = "GET"; // on surcharge !
    }

    // attributs d'instances

    /**
     * Format forcé de la réponse du service : "json"
     * sauf si l'on souhaite une reponse brute (options.rawResponse)
     */
    this.options.outputFormat = (this.options.rawResponse) ? "" : "json";
}

/**
 * @lends module:AutoComplete#
 */

AutoComplete.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_0__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
AutoComplete.prototype.constructor = AutoComplete;

/**
 * (overwrite)
 * Création de la requête
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
AutoComplete.prototype.buildRequest = function (error, success) {
    // ex.
    // http://wxs.ign.fr/CLEF/ols/apis/completion?
    // text=Brie-Comt&
    // type=StreetAddress,PositionOfInterest&
    // territory=METROPOLE&
    // maximumResponses=10

    // traitement des param KPV sous forme de tableau
    var territories = "";
    if (this.options.filterOptions.territory) {
        territories = this.options.filterOptions.territory.join(";");
    }

    var types = "";
    if (this.options.filterOptions.type) {
        types = this.options.filterOptions.type.join(",");
    }

    // normalisation de la requete avec param KPV
    this.request = _Utils_Helper__WEBPACK_IMPORTED_MODULE_4__["default"].normalyzeParameters({
        text : encodeURIComponent(this.options.text),
        type : types,
        terr : territories,
        maximumResponses : this.options.maximumResponses
    });

    (!this.request)
        ? error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_5__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_3__["default"].getMessage("SERVICE_REQUEST_BUILD")))
        : success.call(this, this.request);
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback de succès de l'analyse de la réponse
 */
AutoComplete.prototype.analyzeResponse = function (error, success) {
    if (this.response) {
        var options = {
            response : this.response,
            rawResponse : this.options.rawResponse,
            onSuccess : success,
            onError : error,
            scope : this
        };

        _Response_AutoCompleteResponseFactory__WEBPACK_IMPORTED_MODULE_1__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_5__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_3__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AutoComplete);


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(127);
/* harmony import */ var _model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(128);
/**
 * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON
 * (Factory)
 *
 * @module AutoCompleteResponseFactory
 * @private
 * @alias Gp.Services.AutoComplete.Response.AutoCompleteResponseFactory
 */






var AutoCompleteResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Alti
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AutoCompleteResponseFactory");
        logger.trace(["AutoCompleteResponseFactory::build()"]);

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                var JSONResponse = null;
                if (typeof options.response === "string") {
                    JSONResponse = JSON.parse(options.response);
                } else {
                    JSONResponse = options.response;
                }

                // analyse de la réponse
                if (JSONResponse) {
                    // le service renvoie t il une erreur ?
                    if (JSONResponse.error) {
                        // ex. ?
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                            message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.error.description),
                            status : JSONResponse.error.code,
                            type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR
                        }));
                        return;
                    }

                    // création de l'objet réponse
                    data = new _model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_3__["default"]();

                    // boucle sur les résultats de l'autocomplétion
                    if (JSONResponse.results && Array.isArray(JSONResponse.results)) {
                        var suggestedLocation = null;

                        for (var i = 0; i < JSONResponse.results.length; i++) {
                            var result = JSONResponse.results[i];
                            suggestedLocation = new _model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_4__["default"]();

                            if (result) {
                                if (result.country === "StreetAddress") {
                                    suggestedLocation.street = result.street;
                                    suggestedLocation.type = "StreetAddress";
                                } else if (result.country === "PositionOfInterest") {
                                    suggestedLocation.poi = result.street;
                                    suggestedLocation.kind = result.kind;
                                    suggestedLocation.type = "PositionOfInterest";
                                }

                                if (suggestedLocation.position) {
                                    suggestedLocation.position.x = result.x;
                                    suggestedLocation.position.y = result.y;
                                }

                                suggestedLocation.commune = result.city;
                                suggestedLocation.fullText = result.fulltext;
                                suggestedLocation.postalCode = result.zipcode;
                                suggestedLocation.classification = result.classification;
                            }
                            // Ajout du résultat au tableau reverseGeocodedLocations de geocodedLocation
                            data.suggestedLocations.push(suggestedLocation);
                        }
                    } else {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_FORMAT_3")));
                        return;
                    }

                    if (!data.suggestedLocations.length) {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_FORMAT_3")));
                        return;
                    }
                }

                if (!data) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE_2"),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_UNKERR,
                        status : -1
                    }));
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }
            }
        } else {
            // si la réponse (xmlString) est vide, on appelle le callback d'erreur
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        // si tout s'est bien passé, on appelle le callback de succès
        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (AutoCompleteResponseFactory);


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Response object for {@link module:Services~autoComplete Gp.Services.autoComplete ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Array.<Gp.Services.AutoComplete.SuggestedLocation>} suggestedLocations - SuggestedLocations array.
 *
 * @namespace
 * @alias Gp.Services.AutoCompleteResponse
 */
function AutoCompleteResponse () {
    if (!(this instanceof AutoCompleteResponse)) {
        throw new TypeError("AutoCompleteResponse constructor cannot be called as a function.");
    }

    this.suggestedLocations = [];
}

AutoCompleteResponse.prototype = {

    constructor : AutoCompleteResponse

};

/* harmony default export */ __webpack_exports__["default"] = (AutoCompleteResponse);


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Single SuggestedLocation Object returned by underlying web service.
 * Each suggested location represents a street address ("StreetAddress") or a place name ("PositionOfInterest").
 *
 * @property {String} type - Suggested location type : "StreetAddress" ou "PositionOfInterest"
 * @property {Gp.Point} position - Position of the suggested location given in requested coordinates system.
 * @property {String} commune - Suggested municipality
 * @property {String} fullText - Full text representation of the suggested location.
 * @property {String} postalCode - Suggested location postcode
 * @property {Integer} classification - Number used to classify the importance of the place where is the suggested location from 1 (most important) to 7 (less important).
 * @property {String} street - Street name of the suggested location ("StreetAddress" only).
 * @property {String} kind - Nature of the suggested location : "prefecture", "monument", "commune", ... for instance ("PositionOfInterest" only).
 *
 * @namespace
 * @alias Gp.Services.AutoComplete.SuggestedLocation
 */
function SuggestedLocation () {
    if (!(this instanceof SuggestedLocation)) {
        throw new TypeError("SuggestedLocation constructor cannot be called as a function.");
    }

    /* REPONSE :
        {
           "status" : "OK",
           "results" : [
              {
                 "country":"PositionOfInterest",
                 "x":-1.559185,
                 "y":47.952603,
                 "city":"Brie",
                 "zipcode":"35150",
                 "street":"corbe",
                 "kind":"Lieu-dit habité",
                 "fulltext":"corbe, 35150 Brie",
                 "classification":6
              },
              {
                 "country":"StreetAddress",
                 "x":1.538295,
                 "y":43.19646,
                 "city":"Brie",
                 "zipcode":"09700",
                 "street":"courreste",
                 "kind":"",
                 "fulltext":"courreste, 09700 Brie",
                 "classification":7
              }
           ]
        }
    */

    /* REPONSE EN ERREUR
        {
            status : "ERROR",
            results : [ ]
        }
    */

    /**
     * Suggested location type : "StreetAddress" ou "PositionOfInterest"
     * @type {String}
     */
    this.type = null;

    /**
     * Position of the suggested location given in requested coordinates system.
     * @type {Gp.Point}
     */
    this.position = {
        x : null,
        y : null
    };

    /**
     * Suggested municipality
     * @type {String}
     */
    this.commune = null;

    /**
     * Full text representation of the suggested location.
     * @type {String}
     */
    this.fullText = null;

    /**
     * Suggested location postcode
     * @type {Number}
     */
    this.postalCode = null;

    /**
     * Number used to classify the importance of the place where is the suggested location from 1 (most important) to 7 (less important).
     * @type {Integer}
     */
    this.classification = null;

    /**
     * Street name of the suggested location ("StreetAddress" only).
     * @type {String}
     */
    this.street = null;

    /**
     * Place name of the suggested location ("PositionOfInterest" only).
     * @type {String}
     */
    this.poi = null;

    /**
     * Nature of the suggested location : "prefecture", "monument", "commune", ... for instance ("PositionOfInterest" only).
     * @type {String}
     */
    this.kind = null;
}

SuggestedLocation.prototype = {

    constructor : SuggestedLocation
};

/* harmony default export */ __webpack_exports__["default"] = (SuggestedLocation);


/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);
/* harmony import */ var _Request_RouteRequestFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(130);
/* harmony import */ var _Response_RouteResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(133);









/**
 * @classdesc
 * Appel du service d'itinéraire du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 *
 * @alias Gp.Services.Route
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String} options.resource - La ressource utilisée pour le calcul. Ce paramètre devrait être obligatoire car il l'est dans l'appel au service. Mais il ne l'est pas pour des raisons de rétrocompatibilité.
 *
 * @param {String} options.outputFormat - Le format de la réponse du service itineraire : 'json' uniquement et par défaut.
 *
 * @param {String} [options.routePreference = "fastest"] - Mode de calcul à utiliser :
 * - le plus rapide « fastest »
 * - le plus court « shortest »
 * Par défaut : « fastest ».
 *
 * @param {Object} options.startPoint - Point de départ du calcul. Coordonnées exprimées en longitudes, latitudes (EPSG:4326)
 * @param {Float} options.startPoint.x - Abcisse du point de départ du calcul d'itinéraire.
 * @param {Float} options.startPoint.y - Ordonnée du point de départ du calcul d'itinéraire.
 *
 * @param {Object} options.endPoint - Point d'arrivée du calcul. Coordonnées exprimées en longitudes, latitudes (EPSG:4326)
 * @param {Float} options.endPoint.x - Abcisse du point d'arrivée du calcul d'itinéraire.
 * @param {Float} options.endPoint.y - Ordonnée du point d'arrivée du calcul d'itinéraire.
 *
 * @param {Object[]} [options.viaPoints] - Liste de point ({x:Float,y:Float}) intermédaires que l'itinéraire doit emprunter dans l'ordre du tableau.
 *      Coordonnées exprimées en longitudes, latitudes (EPSG:4326) :{x:float, y:float}
 *
 * @param {String} [options.graph = "voiture"] - Type de graphe utilisé : "Voiture" ou "Pieton".
 *      Détermine le profil de vitesses utilisé pour le calcul ainsi que les tronçons autorisés ou non.
 *      Par défaut, c'est la valeur "Voiture" qui sera utilisée.
 *
 * @param {String[]} [options.exclusions] - DEPRECATED: Critères d'exclusions à appliquer pour le calcul. (correspond au paramètre "avoidFeature" d'OpenLS)
 *      On précise ici le type de tronçons que l'on ne veut pas que l'itinéraire emprunte
 *      (valeurs possibles : « toll » (éviter les péages), « bridge », « tunnel »).
 *      Ce paramètre est conservé pour une rétrocompatibilité de l'api. Le nouveau paramètre à utiliser est options.constraints
 *
 * @param {Object[]} [options.constraints] - Critères de contraintes à appliquer sur un itinéraire. Les valeurs disponibles dépendent de la ressource utilisée. Il est donc utile de regarder le getCapabilities.
 * @param {String} [options.constraints.constraintType] - Type de la contrainte. Généralement "banned".
 * @param {String} [options.constraints.key] - Clé de la contrainte. Généralement "wayType".
 * @param {String} [options.constraints.operator] - Opérateur de la contrainte. Généralement "=".
 * @param {String} [options.constraints.value] - Valeur de la contrainte. Généralement "autoroute".
 *
 * @param {Boolean} [options.geometryInInstructions = false] - Indique si la géométrie de l'itinéraire doit être reprise morceau par morceau dans les instructions.
 *      (correspond au paramètre "provideGeometry" d'OpenLS) Par défaut : false.
 *
 * @param {Boolean} [options.provideBbox = true] - Indique si les instructions doivent être localisées par une bbox dans la réponse.
 *      Par défaut : true.
 *
 * @param {String} [options.distanceUnit = "m"] - Indique si la distance doit être exprimée en km ou m dans la réponse.
 *      Par défaut : m.
 * @param {String} [options.timeUnit = "second"] - Indique si la durée doit être exprimée en seconde, minute ou heure dans la réponse. Il peut-être formatté hh:mm::ss avec la valeur standard.
 *      Les valeurs possibles sont "standard", "second", "minute" ou "hour".
 *      Par défaut : "standard".
 *
 * @param {String} [options.srs] - Système de coordonnées dans lequel les paramètres géographiques en entrée et la réponse du service sont exprimés.
 *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 'EPSG:4326'.
 *
 * @param {String[]} [options.waysAttributes] - Nom des attributs des voies. Les valeurs disponibles dépendent de la ressource utilisée. Il est donc utile de regarder le getCapabilities.
 *
 * @example
 *  var options = {
 *      // options communes aux services
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'XHR',
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      resource : 'bdtopo'
 *      outputFormat : 'json',
 *      startPoint : {
 *          x : 42.1121,
 *          y : 1.5557
 *      },
 *      endPoint : {
 *          x : 42.1121,
 *          y : 1.5557
 *      },
 *      provideBbox : true,
 *      exclusions : ["Bridge", "Tunnel", "Toll"],
 *      distanceUnit : "km",
 *      graph : "Voiture",
 *      geometryInInstructions : true,
 *      routePreference : "fastest"
 *  };
 *
 * @private
 */
function Route (options) {
    if (!(this instanceof Route)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "Route"));
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "Route";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.Route");
    this.logger.trace("[Constructeur Route (options)]");

    if (!options.startPoint) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "startPoint"));
    }

    // on lance une exception afin d'eviter au service de le faire...
    if (options.startPoint.x === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "startPoint.x"));
    }

    if (options.startPoint.y === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "startPoint.y"));
    }

    if (!options.endPoint) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "endPoint"));
    }

    // on lance une exception afin d'eviter au service de le faire...
    if (options.endPoint.x === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "endPoint.x"));
    }

    if (options.endPoint.y === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "endPoint.y"));
    }

    // options par defaut

    // on passe l'option outputFormat en minuscules afin d'éviter des exceptions.
    if (options.outputFormat && options.outputFormat !== "json") {
        this.logger.warn("options.outputFormat could only be json");
    }
    this.options.outputFormat = "json";

    this.options.resource = options.resource || "bdtopo-osrm";
    this.options.startPoint = options.startPoint;
    this.options.endPoint = options.endPoint;
    this.options.viaPoints = options.viaPoints || [];
    this.options.routePreference = options.routePreference || "fastest";
    /** Gestion des anciennes valeurs de graph */
    if (options.graph) {
        if (options.graph === "Voiture") {
            this.options.graph = "car";
        }
        if (options.graph === "Pieton") {
            this.options.graph = "pedestrian";
        }
    } else {
        this.options.graph = "car";
    }
    this.options.constraints = [];
    if (options.constraints) {
        if (Array.isArray(options.constraints)) {
            for (var k = 0; k < options.constraints.length; k++) {
                this.options.constraints.push(options.constraints[k]);
            }
        } else {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "constraints"));
        }
    }

    /** Gestion de l'ancien paramètre exclusion */
    var constraintTunnel = {};
    var constraintPont = {};
    var constraintAutoroute = {};
    if (options.exclusions) {
        if (options.exclusions.length !== 0) {
            this.logger.warn("options.exclusions is DEPRECATED !!");
            for (var c = 0; c < options.exclusions.length; c++) {
                if (typeof options.exclusions[c] === "string") {
                    options.exclusions[c] = options.exclusions[c].toLowerCase();
                } else {
                    // on ne crée pas une erreur pour rétro-compatibilité avec les anciennes versions
                    continue;
                }
                if (options.exclusions[c] === "toll") {
                    constraintAutoroute.constraintType = "banned";
                    constraintAutoroute.key = "wayType";
                    constraintAutoroute.operator = "=";
                    constraintAutoroute.value = "autoroute";
                    this.options.constraints.push(constraintAutoroute);
                }
                if (options.exclusions[c] === "tunnel") {
                    constraintTunnel.constraintType = "banned";
                    constraintTunnel.key = "wayType";
                    constraintTunnel.operator = "=";
                    constraintTunnel.value = "tunnel";
                    this.options.constraints.push(constraintTunnel);
                }
                if (options.exclusions[c] === "bridge") {
                    constraintPont.constraintType = "banned";
                    constraintPont.key = "wayType";
                    constraintPont.operator = "=";
                    constraintPont.value = "pont";
                    this.options.constraints.push(constraintPont);
                }
            }
        }
    }

    this.options.geometryInInstructions = options.geometryInInstructions || false;
    this.options.provideBbox = options.provideBbox || true;
    this.options.distanceUnit = options.distanceUnit || "m";
    this.options.timeUnit = options.timeUnit || "second";
    this.options.expectedStartTime = null; // FIXME not yet implemented !
    this.options.srs = options.srs || "EPSG:4326";
    this.options.waysAttributes = options.waysAttributes || [];

    // gestion de l'url du service par defaut
    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut
    if (!this.options.serverUrl) {
        var UrlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].Route.url(this.options.apiKey);
        if (!UrlByDefault) {
            throw new Error("Url by default not found !");
        }
        this.options.serverUrl = UrlByDefault;
        this.logger.trace("Serveur URL par defaut : " + this.options.serverUrl);
    }
}

/**
 * @lends module:Route#
 */
Route.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
Route.prototype.constructor = Route;

/**
 * (overwrite)
 * Création de la requête
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Route.prototype.buildRequest = function (error, success) {
    var options = {
        // spécifique au service
        resource : this.options.resource,
        startPoint : this.options.startPoint,
        endPoint : this.options.endPoint,
        viaPoints : this.options.viaPoints,
        provideBbox : this.options.provideBbox,
        constraints : this.options.constraints,
        distanceUnit : this.options.distanceUnit,
        timeUnit : this.options.timeUnit,
        graph : this.options.graph,
        geometryInInstructions : this.options.geometryInInstructions,
        routePreference : this.options.routePreference,
        srs : this.options.srs,
        waysAttributes : this.options.waysAttributes
    };

    this.request = _Request_RouteRequestFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);

    // on teste si la requete a bien été construite !
    if (!this.request) {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD")));
    } else {
        success.call(this, this.request);
    }
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Route.prototype.analyzeResponse = function (error, success) {
    // INFO
    // Factory pour masquer la complexité du retour du service

    if (this.response) {
        var options = {
            distanceUnit : this.options.distanceUnit,
            timeUnit : this.options.timeUnit,
            response : this.response,
            outputFormat : this.options.outputFormat, // utile pour parser la string en mode XHR : JSON ou XML !
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this,
            geometryInInstructions : this.options.geometryInInstructions
        };

        _Response_RouteResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ __webpack_exports__["default"] = (Route);


/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _RouteRequestREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(131);
/**
 * Creation d'une requête REST en mode POST ou GET
 * (Factory)
 *
 * @module RouteRequestFactory
 * @alias Gp.Services.Route.Request.RouteRequestFactory
 * @private
 */




var RouteRequestFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Route
     *
     * @example
     *   // utilisation avec les callback
     *   var options = {
     *      (...)
     *      onSuccess : function (response) {},
     *      onError : function (error) {},
     *      // spécifique au service
     *      startPoint : {
     *          x : 42.1121,
     *          y : 1.5557
     *      },
     *      endPoint : {
     *          x : 42.1121,
     *          y : 1.5557
     *      },
     *      provideBbox : false,
     *      exclusions : ["bridge", "tunnel", "toll"],
     *      distanceUnit : "km",
     *      graph : "Voiture",
     *      geometryInInstructions : false,
     *      routePreference : "fastest"
     *   };
     *   RouteRequestFactory.build(options);
     *
     *   // utilisation sans callback
     *   var options = {...};
     *   try {
     *      var result = RouteRequestFactory.build(options);
     *      if (! result) { throw new Error("..."):}
     *   } catch (e) {
     *      // todo
     *   }
     * @returns {String} request
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("RouteRequestFactory");
        logger.trace(["RouteRequestFactory::build()"]);

        var request = null;

        var settings = options || {};

        // gestion des callback
        var bOnError = !!(options.onError !== null && typeof options.onError === "function");

        var message = null;

        // FIXME les exceptions ne sont pas 'catchées' sur le constructeur !
        var myReq = new _RouteRequestREST__WEBPACK_IMPORTED_MODULE_2__["default"](settings);
        if (!myReq.processRequestString()) {
            message = "Error process request (rest) !";
            if (bOnError) {
                options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                return;
            }
            throw new Error(message);
        }
        request = myReq.requestString;

        return request;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (RouteRequestFactory);


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _model_RouteParamREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(132);





/**
 * @classdesc
 * Classe de gestion des requêtes de type REST sur le service de calcul d'itineraire
 * (uniquement en GET)
 *
 * @constructor
 * @alias Gp.Services.Route.Request.RouteRequestREST
 * @param {Object} options - options definies dans le composant Route
 *
 * @example
 * var options = {
 *      (...)
 * };
 *
 * @private
 */
function RouteRequestREST (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("RouteRequestREST");
    this.logger.trace("[Constructeur RouteRequestREST ()]");

    if (!(this instanceof RouteRequestREST)) {
        throw new TypeError("RouteRequestREST constructor cannot be called as a function.");
    }

    // existance des options
    if (!options) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
    }

    /** liste des options */
    this.settings = options;
}

RouteRequestREST.prototype = {

    /**
     * @lends module:RouteRequestREST#
     */

    /**
     * request
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : RouteRequestREST,

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out : origin=2.416907353809513,48.8465772142297&destination=2.4248037771493673,48.84591353161838
     * // POST out : Not yet supported method POST !
     * @returns {String} request
     */
    processRequestString : function () {
        // INFO
        // construction simple sans template...,
        // mais en attendant que les services soient fixés, on taggue ce composant en mode PROTOTYPE !
        this.logger.warn(" PROTOTYPE !");

        // Mapping des options avec le service de l'API REST
        var oParams = new _model_RouteParamREST__WEBPACK_IMPORTED_MODULE_2__["default"](this.settings);
        var params = oParams.getParams();

        var request = "";
        for (var i = 0; i < params.length; i++) {
            var o = params[i];
            if (request) {
                request += "&";
            }
            request += o.k + "=" + o.v;
        }

        // Exemple :
        //  http://wxs.ign.fr/KEY/itineraire/rest/route.json?
        //  origin=&
        //  destination=&
        //  waypoints=&
        //  method=DISTANCE&
        //  graph=Pieton&
        //  graphName=Pieton&
        //  exclusions=&
        //  tolerance=10&
        //  srs=

        this.logger.trace(request);
        this.requestString = request;

        return this.requestString;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (RouteRequestREST);


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);



/**
 * @classdesc
 * Classe de gestion des param. des requêtes du service de calcul d'itineraire (REST).
 *      Permet le mapping avec les options du service.
 * @constructor
 * @alias Gp.Services.Route.Request.RouteParamREST
 * @param {Object} options - options
 *
 * @private
 */
function RouteParamREST (options) {
    if (!(this instanceof RouteParamREST)) {
        throw new TypeError("RouteParamREST constructor cannot be called as a function.");
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur RouteParamREST ()]");
    /**
     * Options en paramêtres du constructeur.
     */
    this.options = options || {};

    // mapping des options avec l'API REST

    /** Ressource utilisée */
    this.resource = this.options.resource;

    /** Coordonnées du point de départ. */
    this.start = this.options.startPoint.x + "," + this.options.startPoint.y;

    /** Coordonnées du point d’arrivée. */
    this.end = this.options.endPoint.x + "," + this.options.endPoint.y;

    /** Coordonnées des étapes point de départ. */
    this.intermediates = this.options.viaPoints;

    /** Nom du profile à utiliser */
    this.profile = this.options.graph;

    /** projection (code EPSG comme epsg:4326 ou wgs84) */
    this.crs = this.options.srs;

    /** Liste des contraintes */
    this.constraints = this.options.constraints;

    /** Nom de l'optimisation à utiliser */
    this.optimization = this.options.routePreference;

    /** Format de sortie (résumé de l’itinéraire) */
    this.getSteps = (this.options.geometryInInstructions) ? "true" : "false";

    /** Unité des distances */
    this.distanceUnit = this.options.distanceUnit;

    /** Unité des durées */
    this.timeUnit = this.options.timeUnit;

    /** Attributs des voies */
    this.waysAttributes = this.options.waysAttributes;
}

/**
 * CLASSNAME
 */
RouteParamREST.CLASSNAME = "RouteParamREST";

RouteParamREST.prototype = {

    /**
     * @lends module:RouteParamREST#
     */

    /**
     * Constructeur (alias)
     */
    constructor : RouteParamREST,

    /**
     * Retourne une liste de points
     * @returns {String} une liste de points (sep '|')
     */
    getIntermediates : function () {
        var array = [];
        if (this.intermediates.length !== 0) {
            for (var i = 0; i < this.intermediates.length; i++) {
                var obj = this.intermediates[i];
                array.push(obj.x + "," + obj.y);
            }
        }

        return array.join("|");
    },

    /**
     * Retourne une liste d'attributs
     * @returns {String} une liste d'attributs (sep '|')
     */
    getWaysAttributes : function () {
        return this.waysAttributes.join("|");
    },

    /**
     * Retourne un profile
     * @returns {String} profile
     */
    getProfile : function () {
        return this.profile;
    },

    /**
     * Retourne un distanceUnit
     * @returns {String} distanceUnit
     */
    getDistanceUnit : function () {
        if (this.distanceUnit === "m") {
            return "meter";
        }
        if (this.distanceUnit === "km") {
            return "kilometer";
        }
        return "";
    },

    /**
     * Retourne une optimisation
     * @returns {String} optimization
     */
    getOptimization : function () {
        if (this.optimization) {
            return this.optimization;
        } else {
            return "";
        }
    },

    /**
     * Retourne la liste des constraints
     * @returns {String} une liste des constraints (sep '|')
     */
    getConstraints : function () {
        var constraintArray = [];

        if (this.constraints.length !== 0) {
            for (var k = 0; k < this.constraints.length; k++) {
                constraintArray.push(JSON.stringify(this.constraints[k]));
            }
        }
        return constraintArray.join("|");
    }
};

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Array} liste de paramêtres
 */
RouteParamREST.prototype.getParams = function () {
    var map = [];

    map.push({
        k : "resource",
        v : this.resource
    });

    map.push({
        k : "start",
        v : this.start
    });

    map.push({
        k : "end",
        v : this.end
    });

    map.push({
        k : "geometryFormat",
        v : "geojson"
    });

    if (this.optimization) {
        map.push({
            k : "optimization",
            v : this.getOptimization()
        });
    }

    if (this.intermediates) {
        map.push({
            k : "intermediates",
            v : this.getIntermediates()
        });
    }

    if (this.profile) {
        map.push({
            k : "profile",
            v : this.getProfile()
        });
    }

    if (this.constraints) {
        map.push({
            k : "constraints",
            v : this.getConstraints()
        });
    }

    if (this.crs) {
        map.push({
            k : "crs",
            v : this.crs
        });
    }

    if (this.distanceUnit) {
        map.push({
            k : "distanceUnit",
            v : this.getDistanceUnit()
        });
    }

    if (this.timeUnit) {
        map.push({
            k : "timeUnit",
            v : this.timeUnit
        });
    }

    if (this.waysAttributes) {
        map.push({
            k : "waysAttributes",
            v : this.getWaysAttributes()
        });
    }

    return map;
};

/* harmony default export */ __webpack_exports__["default"] = (RouteParamREST);


/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _model_RouteResponse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(134);
/* harmony import */ var _model_RouteInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(135);
/**
 * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON
 * (Factory)
 *
 * @module RouteResponseFactory
 * @alias Gp.Services.Route.Response.RouteResponseFactory
 * @private
 */






var RouteResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Route
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("RouteResponseFactory");
        logger.trace("RouteResponseFactory::build()");

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                logger.trace("analyze response : json");

                var JSONResponse;
                if (typeof options.response === "string") {
                    JSONResponse = JSON.parse(options.response);
                } else {
                    JSONResponse = options.response;
                }

                // construction de l'objet réponse JSON
                if (JSONResponse) {
                    // le service renvoie t il une erreur ?
                    if (JSONResponse.message) {
                        // ex. {"message":"message not null", "status":"ERROR"}
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.message)));
                        return;
                    }
                    var legs = [];
                    var legSteps = [];
                    var steps = [];

                    data = new _model_RouteResponse__WEBPACK_IMPORTED_MODULE_3__["default"]();

                    if (data.hasOwnProperty("totalTime")) {
                        data.totalTime = parseFloat(JSONResponse.duration);
                    }
                    if (data.hasOwnProperty("totalDistance")) {
                        data.totalDistance = parseFloat(JSONResponse.distance);
                    }

                    if (data.hasOwnProperty("bbox")) {
                        data.bbox.left = parseFloat(JSONResponse.bbox[0]);
                        data.bbox.bottom = parseFloat(JSONResponse.bbox[1]);
                        data.bbox.right = parseFloat(JSONResponse.bbox[2]);
                        data.bbox.top = parseFloat(JSONResponse.bbox[3]);
                    }

                    if (data.hasOwnProperty("routeGeometry") && !options.geometryInInstructions) {
                        data.routeGeometry = JSONResponse.geometry;
                    }

                    if (data.hasOwnProperty("routeInstructions") && options.geometryInInstructions) {
                        var legList = JSONResponse.portions;
                        var i;
                        if (Array.isArray(legList) && legList.length) {
                            for (i = 0; i < legList.length; i++) {
                                legs.push(legList[i]);
                            }
                        }
                        if (legs.length) {
                            for (i = 0; i < legs.length; i++) {
                                legSteps.push(legs[i].steps);
                            }
                        }
                        if (legSteps.length) {
                            for (i = 0; i < legSteps.length; i++) {
                                steps = steps.concat(legSteps[i]);
                            }
                        }

                        steps.forEach(function (step) {
                            data.routeInstructions.push(new _model_RouteInstruction__WEBPACK_IMPORTED_MODULE_4__["default"]());
                            data.routeInstructions[data.routeInstructions.length - 1].duration = step.duration;
                            data.routeInstructions[data.routeInstructions.length - 1].distance = step.distance;
                            data.routeInstructions[data.routeInstructions.length - 1].code = "";
                            data.routeInstructions[data.routeInstructions.length - 1].instruction = "";
                            data.routeInstructions[data.routeInstructions.length - 1].geometry = step.geometry;

                            // on ne souhaite pas de ce type de valeur...
                            if (step.name === "Valeur non renseignée") {
                                step.name = "";
                            }

                            switch (step.instruction.type) {
                                case "turn":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Tourner";
                                    break;
                                case "new name":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Continuer tout droit";
                                    break;
                                case "depart":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Départ";
                                    break;
                                case "arrive":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Arrivée";
                                    break;
                                case "merge":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Rejoindre";
                                    break;
                                case "ramp":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la bretelle";
                                    break;
                                case "on ramp":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la bretelle";
                                    break;
                                case "off ramp":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la sortie";
                                    break;
                                case "fork":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Sur la bifurcation, prendre";
                                    break;
                                case "end of road":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "À la fin de la route, prendre";
                                    break;
                                case "use lane":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Utiliser la file";
                                    break;
                                case "continue":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Continuer";
                                    break;
                                case "roundabout":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond-point";
                                    break;
                                case "rotary":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond-point";
                                    break;
                                case "roundabout turn":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond point, tourner";
                                    break;
                                case "notification":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "";
                                    break;
                                default:
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "?" + step.instruction.type + "?";
                                    break;
                            }

                            if (step.instruction.modifier) {
                                switch (step.instruction.modifier) {
                                    case "uturn":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction = "Faire demi-tour";
                                        break;
                                    case "sharp right":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " complètement à droite";
                                        break;
                                    case "right":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " à droite";
                                        break;
                                    case "slight right":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " légèrement à droite";
                                        break;
                                    case "straight":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction = "Continuer tout droit";
                                        break;
                                    case "slight left":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " lègèrement à gauche";
                                        break;
                                    case "left":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " à gauche";
                                        break;
                                    case "sharp left":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " complètement à gauche";
                                        break;
                                    default:
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " ?" + step.instruction.modifier + "?";
                                        break;
                                }
                            }

                            if (step.instruction.exit) {
                                data.routeInstructions[data.routeInstructions.length - 1].instruction += `${step.instruction.exit}e sortie`;
                            }

                            if (step.attributes.name) {
                                if (step.attributes.name.nom_1_droite || step.attributes.name.toponyme) {
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " sur";
                                }

                                if (step.attributes.name.nom_1_droite) {
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += ` ${step.attributes.name.nom_1_droite}`;
                                }

                                if (step.attributes.name.toponyme) {
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += ` ${step.attributes.name.toponyme}`;
                                }
                            }
                        });
                    }
                }

                if (!data) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", "json")));
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION_2")));
                    return;
                }
            }
        } else {
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (RouteResponseFactory);


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Response object for {@link module:Services~route Gp.Services.route ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Gp.BBox} bbox - Bounding Box of the route. Given when provideBBox parameter is used in function call.
 * @property {Object} routeGeometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the route.
 * @property {Array.<Gp.Services.Route.RouteInstruction>} routeInstructions - Instructions of the route.
 * @property {String} totalDistance - Length of the route. If distanceUnit parameter was set to "km" (default), totalDistance is a string containing the total distance expressed in kilometers, followed by " Km" (e.g. : "19.6 Km"). If distanceUnit parameter was set to "m", totalDistance is a string containing the total distance expressed in meters (e.g. : "19599.14").
 * @property {Float} totalTime - Route duration in seconds.
 *
 * @namespace
 * @alias Gp.Services.RouteResponse
 */
function RouteResponse () {
    if (!(this instanceof RouteResponse)) {
        throw new TypeError("RouteResponse constructor cannot be called as a function.");
    }

    this.totalTime = null;

    this.totalDistance = null;

    this.bbox = {
        left : null,
        right : null,
        top : null,
        bottom : null
    };

    this.routeGeometry = null; // FIXME can be null if option 'geometryInInstructions' is true !

    this.routeInstructions = [];
}

RouteResponse.prototype = {

    constructor : RouteResponse

};

/* harmony default export */ __webpack_exports__["default"] = (RouteResponse);


/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Single Route Instruction object.
 *
 * @property {String} code - Instruction code :
 *
 * - "F" : Straight forward
 * - "B" : U-turn
 * - "L" : turn left
 * - "R" : turn right
 * - "BL" : turn left strongly
 * - "BR" : turn right strongly
 * - "FL" : turn lightly to the left
 * - "FR" : turn lightly to the right
 * - "round_about_entry" : round about entry
 * - "round_about_exit" : round about exit
 *
 * @property {String} instruction - Instruction text : translated code + street name
 * @property {Object} geometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the street.
 * @property {Float} distance - Length of the instruction. Expressed in km or m, depending on distanceUnit parameter.
 * @property {Float} duration - Instruction duration in seconds.
 *
 * @namespace
 * @alias Gp.Services.Route.RouteInstruction
 */
function RouteInstruction () {
    if (!(this instanceof RouteInstruction)) {
        throw new TypeError("RouteInstruction constructor cannot be called as a function.");
    }

    this.duration = null;

    this.distance = null;

    this.code = null;

    this.instruction = null;

    this.geometry = null; // FIXME can be null if option 'geometryInInstructions' is false !
}

RouteInstruction.prototype = {

    constructor : RouteInstruction

};

/* harmony default export */ __webpack_exports__["default"] = (RouteInstruction);


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);
/* harmony import */ var _Request_ProcessIsoCurveRequest__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(137);
/* harmony import */ var _Response_ProcessIsoCurveResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(139);









/**
 * @classdesc
 * Appel du service d'isochrone/distance du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.ProcessIsoCurve
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String} options.resource - La ressource utilisée pour le calcul. Ce paramètre devrait être obligatoire car il l'est dans l'appel au service. Mais il ne l'est pas pour des raisons de rétrocompatibilité.
 *
 * @param {String} options.outputFormat - Le format de la réponse du service iso : 'json' uniquement et par défaut.
 *
 * @param {Object} options.position - Point de départ du calcul.
 *      Coordonnées exprimées en longitudes, latitudes (EPSG:4326)
 *      @param {Float} options.position.x - Abcisse du point de départ du calcul d'isochrone/distance.
 *      @param {Float} options.position.y - Ordonnée du point de départ du calcul d'isochrone/distance.
 *
 * @param {String} options.srs - Projection.
 *      Système de coordonnées dans lequel les coordonnées du point « location » sont exprimées et
 *      dans lequel la géométrie de la courbe résultante sera exprimée.
 *      Par défaut, le système de coordonnées utilisé sera « EPSG:4326 ».
 *
 * @param {String} [options.graph = "voiture"] - Nom du graphe à utiliser pour le calcul (« Pieton » ou « Voiture »).
 *      La valeur par défaut est : «voiture»
 *
 * @param {Array.<String>} [options.exclusions] - DEPRECATED: Ce paramètre est conservé pour une rétrocompatibilité de l'api. Le nouveau paramètre à utiliser est options.constraints.
 *      Critères d'exclusions à appliquer pour le calcul.
 *      On précise ici le type de tronçons que l'on ne veut pas que l'isochrone/distance emprunte
 *      (valeurs possibles : « toll » (éviter les péages), « bridge », « tunnel »).
 *
 * @param {Object[]} [options.constraints] - Critères de contraintes à appliquer sur un itinéraire. Les valeurs disponibles dépendent de la ressource utilisée. Il est donc utile de regarder le getCapabilities.
 *      @param {String} [options.constraints.constraintType] - Type de la contrainte. Généralement "banned".
 *      @param {String} [options.constraints.key] - Clé de la contrainte. Généralement "wayType".
 *      @param {String} [options.constraints.operator] - Opérateur de la contrainte. Généralement "=".
 *      @param {String} [options.constraints.value] - Valeur de la contrainte. Généralement "autoroute".
 *
 * @param {String} [options.method = "time"] - Méthode utilisée pour le calcul de la courbe iso.
 *      Les valeurs possible sont "time" pour un calcul d'isochrone, "distance" pour un calcul d'isodistance.
 *      Pas de valeur spécifié équivaut à un calcul d'isochrone.
 *
 * @param {String} [options.distanceUnit = "m"] - Indique si la distance doit être exprimée en km ou m dans la réponse ("m" or "km").
 *
 * @param {String} [options.timeUnit = "second"] - Indique si la durée doit être exprimée en seconde, minute ou heure dans la réponse ("standard", "second", "minute", "hour"). Il peut-être formatté hh:mm::ss avec la valeur standard.
 *
 * @param {Float} options.time - Durée maximum (exprimée en secondes) à utiliser pour le calcul de la courbe à partir du ou jusqu'au point « location ».
 *      Ce paramètre doit être renseigné si l'option "méthod" a la valeur "time".
 *      Si l'option method n'est pas renseignée, ce paramètre doit être renseigné.
 *
 * @param {Float} options.distance - Distance maximum (exprimée en metres) à utiliser pour le calcul de la courbe à partir du ou j'usqu'au point « location ».
 *      Ce paramètre doit être renseigné si l'option "méthod" a la valeur "DISTANCE".
 *      Si l'option "method" n'est pas renseignée, ce paramètre sera ignoré.
 *
 * @param {Boolean} [options.reverse = false] - Indique si la géométrie résultante doit être lissée (« true ») pour ne pas avoir d'effet d'escalier.
 *      Par défaut, la valeur « false » est appliquée.
 *
 * @param {Boolean} [options.smoothing = false] - Indique si la géométrie résultante doit être lissée (« true ») pour ne pas avoir d'effet d'escalier.
 *      Par défaut, la valeur « false » est appliquée.
 *
 * @param {Boolean} [options.holes = false] - Indique si la géométrie résultante (surface) doit être retournée avec des trous (« true »).
 *      Par défaut, la valeur « false » est appliquée.
 *
 * @example
 *   var options = {
 *      // options communes aux services
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      position : {
 *           x : 2.3242664298058053,
 *           y : 48.86118017324745
 *      },
 *      distance : 200,
 *      [time : ]
 *      method : "distance",
 *      graph : "voiture",
 *      reverse : false
 *  };
 * @private
 */

function ProcessIsoCurve (options) {
    if (!(this instanceof ProcessIsoCurve)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "ProcessIsoCurve"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "ProcessIsoCurve";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.ProcessIsoCurve");
    this.logger.trace("[Constructeur ProcessIsoCurve (options)]");

    if (!options.position) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position"));
    }

    // on lance une exception afin d'eviter au service de le faire...
    if (options.position.x === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position.x"));
    }

    if (options.position.y === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position.y"));
    }

    if (!options.time && !options.distance) {
        throw new Error("Parameter (s) 'distance' missing. Parameter time to calculate an isochrone, parameter distance for an isodistance");
    }

    // si on a que le paramètre "distance" en entrée, on calcule une isodistance.
    // Le paramètre "méthode" doit pour avoir une réponse du service, être passé à "distance"
    if (!options.time && options.distance) {
        this.options.method = "distance";
        // on supprime l'éventuel attribut time, résidu d'un appel antérieur
        if (this.options.time) {
            delete this.options.time;
        }
    }

    // si on a que le paramètre "time" en entrée, on calcule une isochrone.
    // Le paramètre "méthode" doit pour avoir une réponse du service, être passé à "time"
    if (options.time && !options.distance) {
        this.options.method = "time";
        // on supprime l'éventuel attribut time, résidu d'un appel antérieur
        if (this.options.distance) {
            delete this.options.distance;
        }
    }

    // au cas où on a ni l'un, ni l'autre...
    this.options.method = this.options.method || "time";

    // options par defaut du service
    // TODO: modifier la ressource lors de la mise en production du service
    this.options.resource = options.resource || "bdtopo-iso";
    this.options.exclusions = options.exclusions || [];
    this.options.reverse = options.reverse || false;
    this.options.srs = options.srs || "EPSG:4326";
    this.options.distanceUnit = options.distanceUnit || "m";
    this.options.timeUnit = options.timeUnit || "second";

    // options depreciees
    if (options.smoothing) {
        this.logger.warn("options.smoothing is DEPRECATED");
    }
    this.options.smoothing = false;
    if (options.holes) {
        this.logger.warn("options.holes is DEPRECATED");
    }
    this.options.holes = false;

    // Gestion du graphe
    if (options.graph) {
        if (options.graph === "Voiture") {
            this.options.graph = "car";
        }
        if (options.graph === "Pieton") {
            this.options.graph = "pedestrian";
        }
    } else {
        this.options.graph = "car";
    }

    // Gestions des contraintes
    this.options.constraints = [];
    if (options.constraints) {
        if (Array.isArray(options.constraints)) {
            for (var k = 0; k < options.constraints.length; k++) {
                this.options.constraints.push(options.constraints[k]);
            }
        } else {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "constraints"));
        }
    }

    // Gestion de l'ancien paramètre exclusions
    var constraintTunnel = {};
    var constraintPont = {};
    var constraintAutoroute = {};
    if (options.exclusions) {
        if (options.exclusions.length !== 0) {
            this.logger.warn("options.exclusions is DEPRECATED !!");
            for (var c = 0; c < options.exclusions.length; c++) {
                if (typeof options.exclusions[c] === "string") {
                    options.exclusions[c] = options.exclusions[c].toLowerCase();
                } else {
                    // on ne crée pas une erreur pour rétro-compatibilité avec les anciennes versions
                    continue;
                }
                if (options.exclusions[c] === "toll") {
                    constraintAutoroute.constraintType = "banned";
                    constraintAutoroute.key = "wayType";
                    constraintAutoroute.operator = "=";
                    constraintAutoroute.value = "autoroute";
                    this.options.constraints.push(constraintAutoroute);
                }
                if (options.exclusions[c] === "tunnel") {
                    constraintTunnel.constraintType = "banned";
                    constraintTunnel.key = "wayType";
                    constraintTunnel.operator = "=";
                    constraintTunnel.value = "tunnel";
                    this.options.constraints.push(constraintTunnel);
                }
                if (options.exclusions[c] === "bridge") {
                    constraintPont.constraintType = "banned";
                    constraintPont.key = "wayType";
                    constraintPont.operator = "=";
                    constraintPont.value = "pont";
                    this.options.constraints.push(constraintPont);
                }
            }
        }
    }

    // on passe l'option outputFormat en minuscules afin d'éviter des exceptions.
    this.options.outputFormat = (typeof options.outputFormat === "string") ? options.outputFormat.toLowerCase() : "json";
    if (options.outputFormat && options.outputFormat !== "json") {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_NOT_SUPPORT", "outputFormat"));
    }
    this.options.outputFormat = "json";

    // gestion de l'url du service par defaut
    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut
    if (!this.options.serverUrl) {
        var urlFound = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].ProcessIsoCurve.url(this.options.apiKey);
        if (!urlFound) {
            throw new Error("Url by default not found !");
        }
        this.options.serverUrl = urlFound;
        this.logger.trace("Serveur URL par defaut : " + this.options.serverUrl);
    }
}

/**
 * @lends module:ProcessIsoCurve#
 */
ProcessIsoCurve.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
ProcessIsoCurve.prototype.constructor = ProcessIsoCurve;

/**
 * Création de la requête (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
ProcessIsoCurve.prototype.buildRequest = function (error, success) {
    try {
        var oIsoCurve = new _Request_ProcessIsoCurveRequest__WEBPACK_IMPORTED_MODULE_5__["default"](this.options);
        if (!oIsoCurve.processRequestString()) {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD"));
        }

        this.request = oIsoCurve.requestString;
    } catch (e) {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](e.message));
        return;
    }

    success.call(this, this.request);
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} onError   - callback des erreurs
 * @param {Function} onSuccess - callback de succès de l'analyse de la réponse
 */
ProcessIsoCurve.prototype.analyzeResponse = function (onError, onSuccess) {
    if (this.response) {
        var options = {
            response : this.response,
            outputFormat : this.options.outputFormat,
            rawResponse : this.options.rawResponse,
            onSuccess : onSuccess,
            onError : onError,
            scope : this
        };

        _Response_ProcessIsoCurveResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        onError.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ __webpack_exports__["default"] = (ProcessIsoCurve);


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _model_ProcessIsoCurveParam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(138);





/**
 * @classdesc
 * Classe de gestion des requêtes sur le service de calcul d'isoschrone/isodistance.
 *  Les requêtes peuvent être en mode GET ou POST,
 *  et le format de sorti est en JSON.
 *
 * @constructor
 * @alias Gp.Services.ProcessIsoCurve.Request.ProcessIsoCurveRequest
 * @param {Object} options - options
 *
 * @example
 * var options = {
 *      httpMethod : 'GET', // GET|POST
 *      // spécifique au service
 *      position : {
 *          x : 2.3242664298058053,
 *          y : 48.86118017324745
 *      },
 *      graph : "car",
 *      method : 'time',
 *      time : 1000, //distance : 200
 *      reverse : false,
 *      srs : 'EPSG:4326'
 *  };
 *
 * try {
 *
 *      var oIsoCurve = new ProcessIsoCurveRequest (options);
 *      if (!oIsoCurve.processRequestString ()) {
 *          // error
 *      }
 *
 *      var request = oIsoCurve.requestString;
 *
 * } catch (e) {
 *      // error
 * }
 * @private
 */
function ProcessIsoCurveRequest (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("ProcessIsoCurveRequest");
    this.logger.trace("[Constructeur ProcessIsoCurveRequest ()]");

    if (!(this instanceof ProcessIsoCurveRequest)) {
        throw new TypeError("ProcessIsoCurveRequest constructor cannot be called as a function.");
    }

    // existance des options
    if (!options) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
    }

    /**
     * Liste des options
     */
    this.settings = options;

    /**
     * Mode HTPP.
     * Par defaut, "GET".
     * @type {String}
     */
    this.mode = this.settings.httpMethod || "GET";
}

ProcessIsoCurveRequest.prototype = {

    /**
     * @lends module:ProcessIsoCurveRequest#
     */

    /**
     * Requête
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : ProcessIsoCurveRequest,

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out :
     *   //  (http://wxs.ign.fr/KEY/isochrone?)
     *   //  resource=&
     *   //  point=&
     *   //  costValue=&
     *   //  costType=&
     *   //  profile=&
     *   //  constraints=&
     *   //  direction=&
     *   //  crs=
     *
     * // POST out :
     * {
     *  resource: "bduni-idf-pgr",
     *  point: "2.337306,48.849319",
     *  costValue: 100,
     *  costType: "time",
     *  profile: "car",
     *  constraints: [{
     *      constraintType: "banned",
     *      key: "ways_type",
     *      operator: "=",
     *      value: "autoroute"
     *  }]
     * }
     *
     * @returns {String} request
     */
    processRequestString : function () {
        var request = "";
        var i = 0;

        switch (this.mode) {
            case "GET":
                this.logger.trace("Process GET Request");

                // Mapping des options avec le service de l'API REST
                var oParams = new _model_ProcessIsoCurveParam__WEBPACK_IMPORTED_MODULE_2__["default"](this.settings);
                var params = oParams.getParams();

                for (i = 0; i < params.length; i++) {
                    var o = params[i];
                    if (request) {
                        request += "&";
                    }
                    request += o.k + "=" + o.v;
                }

                break;

            case "POST":
                this.logger.trace("Process POST Request");
                // creation du JSON
                var postRequest = {};

                postRequest.resource = this.settings.resource;

                postRequest.point = this.settings.position.x + "," + this.settings.position.y;

                if (this.settings.method === "distance") {
                    postRequest.costType = "distance";
                    postRequest.costValue = this.settings.distance;
                } else {
                    postRequest.costType = "time";
                    postRequest.costValue = this.settings.time;
                }

                postRequest.profile = this.settings.graph;

                if (this.settings.reverse) {
                    postRequest.direction = "arrival";
                } else {
                    postRequest.direction = "departure";
                }

                postRequest.constraints = this.settings.constraints;

                postRequest.distanceUnit = this.settings.distanceUnit;

                postRequest.timeUnit = this.settings.timeUnit;

                postRequest.crs = this.settings.srs;

                // conversion en chaîne de caractères
                request = JSON.stringify(postRequest);
                break;

            default:
                this.logger.error("No other HTTP method supported by the service !");
        }

        this.logger.trace(request);
        this.requestString = request;

        return this.requestString;
    }
};

/* harmony default export */ __webpack_exports__["default"] = (ProcessIsoCurveRequest);


/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);



/**
 * @classdesc
 *
 * Classe de gestion des param. des requêtes du service de calcul des iso.
 * Permet le mapping avec les options du service.
 *
 * @constructor
 * @alias Gp.Services.ProcessIsoCurve.Request.ProcessIsoCurveParam
 * @param {Object} options - options
 * @private
 *
 */
function ProcessIsoCurveParam (options) {
    if (!(this instanceof ProcessIsoCurveParam)) {
        throw new TypeError("ProcessIsoCurveParam constructor cannot be called as a function.");
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur ProcessIsoCurveParam ()]");

    /**
     * Options en paramêtres du constructeur.
     */
    this.options = options || {};

    // mapping des options avec l'API REST

    /** Identifiant de l’isochrone */
    this.id = this.options.id;

    /** Resource */
    this.resource = this.options.resource;

    /** Coordonnées de départ (ou arrivée si le reverse est à true). */
    this.point = this.options.position;

    /** projection (code EPSG comme epsg:4326 ou wgs84) */
    this.crs = this.options.srs;

    /**
     * Profil de véhicule à utiliser pour le calcul.
     * Voiture ou Pieton
     */
    this.profile = this.options.graph;

    /** Liste des règles de restrictions à utiliser */
    this.constraints = this.options.constraints;

    this.reverse = this.options.reverse;

    this.timeUnit = this.options.timeUnit;

    this.distanceUnit = this.options.distanceUnit;

    /**
     * "time" pour isochrone ou "distance" for isodistance.
     * Par defaut, time...
     */
    if (this.options.method === "distance") {
        this.costType = "distance";
        this.costValue = this.options.distance;
    } else {
        this.costType = "time";
        this.costValue = this.options.time;
    }
}

/**
 * CLASSNAME
 */
ProcessIsoCurveParam.CLASSNAME = "ProcessIsoCurveParam";

ProcessIsoCurveParam.prototype = {

    /**
     * @lends module:ProcessIsoCurveParam#
     */

    /**
     * Constructeur (alias)
     */
    constructor : ProcessIsoCurveParam,

    /**
     * Retourne le point
     * @returns {String} x,y
     */
    getLocation : function () {
        return this.point.x + "," + this.point.y;
    },

    /**
     * Retourne l'unité de la distance
     * @returns {String}
     */
    getDistanceUnit : function () {
        if (this.distanceUnit === "m") {
            return "meter";
        }
        if (this.distanceUnit === "km") {
            return "kilometer";
        }
        return "";
    },

    /**
     * Retourne la liste des contraintes
     * @returns {String}
     */
    getConstraints : function () {
        var constraintArray = [];

        if (this.constraints.length !== 0) {
            for (var k = 0; k < this.constraints.length; k++) {
                constraintArray.push(JSON.stringify(this.constraints[k]));
            }
        }
        return constraintArray.join("|");
    },

    /**
     * Retourne la direction
     * @returns {String}
     */
    getDirection : function () {
        if (this.reverse) {
            return "arrival";
        } else {
            return "departure";
        }
    }
};

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Object[]} KVP
 */
ProcessIsoCurveParam.prototype.getParams = function () {
    var map = [];

    map.push({
        k : "resource",
        v : this.resource
    });

    map.push({
        k : "point",
        v : this.getLocation()
    });

    map.push({
        k : "direction",
        v : this.getDirection()
    });

    map.push({
        k : "costType",
        v : this.costType
    });

    map.push({
        k : "costValue",
        v : this.costValue
    });

    map.push({
        k : "profile",
        v : this.profile
    });

    map.push({
        k : "timeUnit",
        v : this.timeUnit
    });

    map.push({
        k : "distanceUnit",
        v : this.getDistanceUnit()
    });

    if (this.crs) {
        map.push({
            k : "crs",
            v : this.crs
        });
    }

    if (this.constraints) {
        map.push({
            k : "constraints",
            v : this.getConstraints()
        });
    }

    return map;
};

/* harmony default export */ __webpack_exports__["default"] = (ProcessIsoCurveParam);


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(140);
/**
 * Factory pour générer une reponse JSON à partir d'un JSON
 * (Factory)
 *
 * @module ProcessIsoCurveResponseFactory
 * @alias Gp.Services.ProcessIsoCurve.Response.ProcessIsoCurveResponseFactory
 * @private
 */





var ProcessIsoCurveResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant ProcessIsoCurve
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("ProcessIsoCurveResponseFactory");
        logger.trace(["ProcessIsoCurveResponseFactory::build()"]);

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                logger.trace("analyze response : json");

                var JSONResponse;
                if (typeof options.response === "string") {
                    JSONResponse = JSON.parse(options.response);
                } else {
                    JSONResponse = options.response;
                }

                // analyse de la reponse
                // création de l'objet de réponse
                data = new _model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_3__["default"]();

                // remplissage de l'objet créé avec les attribtuts de la réponse du service
                if (JSONResponse) {
                    if (JSONResponse.costType === "distance") {
                        data.time = "";
                        data.distance = JSONResponse.costValue;
                    } else {
                        data.time = JSONResponse.costValue;
                        data.distance = "";
                    }

                    data.message = "";
                    data.id = "";
                    data.srs = JSONResponse.crs;
                    data.geometry = JSONResponse.geometry;
                    var coords = JSONResponse.point.split(",");
                    if (data.location) {
                        data.location.x = coords[0];
                        data.location.y = coords[1];
                    }
                } else {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", options.response)));
                    return;
                }

                // info : en cas de problèmes de droits (clé invalide ou autre), la réponse est au format XML !!
                // ex. <ExceptionReport><Exception exceptionCode="MissingParameter">Key does not exist or has expired</Exception></ExceptionReport>
                // mais le statut est 403, l'erreur est donc remontée plus tôt.
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }
            }
        } else {
            // si la réponse est vide, on appelle le callback d'erreur
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        // si tout s'est bien passé, on appelle le callback de succès
        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (ProcessIsoCurveResponseFactory);


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Response object for {@link module:Services~isoCurve Gp.Services.isoCurve ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Float} distance - distance (expressed in meters) used for the request.
 * @property {Float} time - time (expressed in seconds) used for the request.
 * @property {Object} geometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the isocurve.
 * @property {String} id - request id (used by underlying webservice).
 * @property {Gp.Point} location - Position of the start or end point used for the request (expressed in "srs" coordinates system).
 * @property {String} message - message
 * @property {String} srs - Identifier of the coordinates system used for the isocurve.
 *
 * @namespace
 * @alias Gp.Services.IsoCurveResponse
 *
 */
function ProcessIsoCurveResponse () {
    if (!(this instanceof ProcessIsoCurveResponse)) {
        throw new TypeError("ProcessIsoCurveResponse constructor cannot be called as a function.");
    }

    this.message = null;

    this.id = null;

    this.location = {};
    this.location.x = null;
    this.location.y = null;

    this.srs = null;

    this.geometry = null;

    this.time = null;

    this.distance = null;
}

ProcessIsoCurveResponse.prototype = {

    constructor : ProcessIsoCurveResponse

};

/* harmony default export */ __webpack_exports__["default"] = (ProcessIsoCurveResponse);


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);

var LoggerByDefault = {
  /**
   * creation d'un logger statique
   *
   * @param {String} [name="default"] - the logger name
   * @returns {Object} logger
   */
  getLogger: function getLogger(name) {
    // INFO :
    // à la compilation en mode production, on substitue false
    // avec "true", ceci desactive les loggers !
    //
    // à la compilation en mode developpement, on substitue false
    // avec "false", ceci permet d'avoir les loggers actifs !
    //
    // lors d'une utilisation en module es6, il n'y a pas de substitution de false,
    // les loggers sont donc actifs par defaut !
    //
    // > Substitute global constants configured at compile time
    // cf. webpack.config.js
    // on masque cette constante afin d'eviter "referenceerror not defined"
    "false".match(/true/) ? loglevel__WEBPACK_IMPORTED_MODULE_0__["disableAll"]() : loglevel__WEBPACK_IMPORTED_MODULE_0__["enableAll"]();
    var logname = name || "default";
    return loglevel__WEBPACK_IMPORTED_MODULE_0__["getLogger"](logname);
  },

  /** desactive tous les loggers */
  disableAll: function disableAll() {
    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__["getLoggers"]();

    for (var key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        var logger = loggers[key];
        logger.disableAll();
      }
    }
  },

  /** active tous les loggers */
  enableAll: function enableAll() {
    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__["getLoggers"]();

    for (var key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        var logger = loggers[key];
        logger.enableAll();
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (LoggerByDefault);

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);

/**
* @module ProxyUtils
* @alias Gp.ProxyUtils
* @description
* ...
*
* @example
* proxifyUrl();
*/

var ProxyUtils = {
  /**
   * Ajoute un proxy aux url des couches vecteurs si besoin.
   *
   * @param {String} url - Url to proxify.
   * @param {Object} [proxyOptions] - Object defining proxy options.
   * @param {String} proxyOptions.proxyUrl - Proxy URL.
   * @param {Array.<String>} [proxyOptions.noProxyDomains] - Proxy will not be used for this list of domain names.
   *
   * @returns {String} proxy url
   */
  proxifyUrl: function proxifyUrl(url, proxyOptions) {
    // logger
    var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("proxifyUrl");

    if (!proxyOptions || !proxyOptions.hasOwnProperty("proxyUrl") || proxyOptions.proxyUrl === null || proxyOptions.proxyUrl.trim().length === 0) {
      return url;
    } // on regarde si l'url nest pas dans les domaines sans proxy


    if (proxyOptions.noProxyDomains && Array.isArray(proxyOptions.noProxyDomains) && proxyOptions.noProxyDomains.length > 0) {
      for (var i in proxyOptions.noProxyDomains) {
        logger.trace("[ProxyUtils] proxifyUrl : analyzing " + proxyOptions.noProxyDomains[i]);

        if (url.indexOf(proxyOptions.noProxyDomains[i]) !== -1) {
          logger.info("[ProxyUtils] proxifyUrl : " + url + " found in noProxyDomains list (" + proxyOptions.noProxyDomains[i] + ").");
          return url;
        }
      }
    }

    return proxyOptions.proxyUrl + encodeURIComponent(url);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (ProxyUtils);

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_format_KML__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(144);
/* harmony import */ var ol_format_KML__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_KML__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(146);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(147);
// import openlayers

 // import local



 // import $__xmldom from "xmldom";

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("extended KML format");
/**
 * @classdesc
 *
 * Extended Styles KML format to export (internal use only !)
 *
 * INFO
 * only ol.Control is a user-extendable class.
 * Everything else requires integration with the original openlayers source and a new ol.js
 * to be built with your new classes incorporated.
 *
 * SPEC
 * cf. https://developers.google.com/kml/forum/advanced
 *
 * ISSUES
 * cf. https://github.com/openlayers/openlayers/issues/4829
 * cf. https://github.com/openlayers/openlayers/issues/4460
 * cf. https://github.com/openlayers/openlayers/pull/5590
 * cf. https://github.com/openlayers/openlayers/issues/5229
 * cf. https://github.com/openlayers/openlayers/issues/3371
 *
 * @constructor
 * @alias ol.format.KMLExtended
 * @extends {ol.format.KML}
 * @param {Object} options - Options
 */

var KML = function (olKML) {
  function KML(options) {
    if (!(this instanceof KML)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // call constructor


    olKML.call(this, options);
    this.options = options || {};
  } // Inherits


  if (olKML) KML.__proto__ = olKML;
  /*
   * @lends module:KML
   */

  KML.prototype = Object.create(olKML.prototype, {});
  /**
   * Constructor (alias)
   *
   * En lecture, on surcharge la méthode readFeatures.
   * ✔️ In : kml string + features du format original
   * ✔️ Out : features étendus avec des styles, et des metadatas (name ou extendData)
   * > on modifie les features du format original avec les fonctionnalités non gérées.
   *
   * En écriture, on surcharge la méthode writeFearures.
   * ✔️ In : kml du format original + features étendus
   * ✔️ Out : kml étendu avec des styles, et des metadatas (name ou extendData)
   * > on modifie le kml généré par le format original avec les fonctionnalités que nous avons ajoutées aux features.
   *
   * Le principe
   * On parse le kml, et on lit (get) ou on ajoute (set) des fonctionnalités.
   *
   * Les getters vont lire le kml (ex. LabelExtendStyle), et ajouter le style ainsi que le nom du label dans le feature original.
   * getLabelIconStyle (appel des 2 fonctions suivantes)
   * getLabelExtendStyle (New)
   * getHotSpotIconStyle (Bug sur la lecture du  hotspot)
   * getExtendData (New)
   *
   * Les setters vont écrire dans le dom du kml original les fonctionnalités ajoutées dans les features.
   * setLabelExtendStyle (New)
   * setHotSpotIconStyle (Bug sur l'écriture du hotspot)
   * setNameData (Bug suppression de cette balise du format par défaut).
   *
   */

  KML.prototype.constructor = KML;
  /**
   * Fonction de lecture du KML avec fonction de traitement en fonction du type
   * PlaceMark (Label ou Marker).
   * Les traitements sont de 2 types :
   *  - creation de styles étendus ou correctifs sur le KML
   *  - ajout de styles étendus sur les features
   *
   * @param {DOMElement} kmlDoc - kml document
   * @param {Object[]} features - features
   * @param {Object} process - process
   *
   * @example
   * // ajoute des fonctionnalités dans le KML
   * _kmlRead(kmlDoc, {
   *   labelStyle : createStyleLabel,
   *   iconStyle  : createStyleIcon
   * });
   *
   * // lit des fonctionnalités du KML non impl. par OpenLayers
   * _kmlRead(kmlDoc, {
   *   labelStyle : getStyleToFeatureLabel,
   *   iconStyle  : getStyleToFeatureIcon,
   *   extendedData : getExtendedData
   * });
   */

  function _kmlRead(kmlDoc, features, process) {
    var root = kmlDoc.documentElement;
    var firstNodeLevel = root.childNodes; // Si le DOM contient un seul objet, le noeud est directement un PlaceMark
    // sinon, c'est un ensemble de noeuds PlaceMark contenus dans le noeud Document.

    var nodes = firstNodeLevel;

    if (firstNodeLevel.length === 1 && firstNodeLevel[0].nodeName === "Document") {
      nodes = firstNodeLevel[0].childNodes;
    } // On recherche les PlaceMark de type Point ayant un Style...
    // Le style peut être placé directement dans le PlaceMark
    // ou lié avec un id (share)


    var stylesUrl = {}; // listes des styles

    var index = -1; // index du features...

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      switch (node.nodeName) {
        case "Style":
          // INFO
          // pour le traitement des balises Styles liées avec styleUrl,
          // elles doivent être toujours déclarées avant les PlaceMark !
          // On ne prend en compte que celles qui sont identifiées via un ID !
          var id = node.attributes[0];

          if (id && id.nodeName === "id") {
            var _k = id.nodeValue;
            var _v = node;
            stylesUrl[_k] = _v;
          }

          break;

        case "Placemark":
          index++;
          var types = node.childNodes; // Point, LineString, Polygon, Style, ...

          var point = false;
          var styles = null; // dom

          var extend = null; // dom

          var name = node;

          for (var j = 0; j < types.length; j++) {
            switch (types[j].nodeName) {
              case "Point":
                point = true;
                break;

              case "Style":
                styles = types[j].childNodes; // liste de styles

                break;

              case "styleUrl":
                // style avec lien vers...
                var _idStyle = types[j].textContent.slice(1);

                if (stylesUrl[_idStyle]) {
                  styles = stylesUrl[_idStyle].childNodes;
                }

                break;

              case "ExtendedData":
                extend = types[j].childNodes;
                break;

              case "name":
                name = null;
                break;

              default: // on ne traite pas les autres informations ...
              // car elles seront gérées par defaut par le format standard...

            }
          } // On traite les balises kml:extendedData pour tous les objets !


          if (extend) {
            logger.log("ExtendedData :", extend);
            var fctExtend = process.extendedData;

            if (fctExtend && typeof fctExtend === "function") {
              fctExtend(features[index], extend);
            }
          } //  On traite la balise kml:name
          // (si elle n'existe plus lors de l'ecriture...)


          if (name) {
            logger.log("Name :", name);
            var fctName = process.nameData;

            if (fctName && typeof fctName === "function") {
              fctName(features[index], name);
            }
          } // On a un Marker avec un Style.
          // Les markers sans styles seront gérées par defaut par le format standard...
          // Il peut être associé avec un Label !


          if (point && styles) {
            // Les Styles !
            if (styles.length) {
              var labelStyle = null;
              var iconStyle = null; // On recherche le type de Style

              for (var k = 0; k < styles.length; k++) {
                switch (styles[k].nodeName) {
                  case "LabelStyle":
                    labelStyle = styles[k];
                    break;

                  case "IconStyle":
                    iconStyle = styles[k];
                    break;

                  default: // on ne traite pas les autres informations ...

                }
              } // Pour un label, il nous faut un titre !


              var labelName = features[index].getProperties().name;
              var labelDescription = features[index].getProperties().description;
              var value = labelName || labelDescription;
              logger.trace(value); // C'est uniquement un Label !

              if (!iconStyle && labelStyle) {
                var fctLabel = process.labelStyle;

                if (fctLabel && typeof fctLabel === "function") {
                  fctLabel(features[index], labelStyle);
                } // C'est uniquement un marker !

              } else if (iconStyle && !labelStyle) {
                var fctIcon = process.iconStyle;

                if (fctIcon && typeof fctIcon === "function") {
                  fctIcon(features[index], iconStyle);
                } // C'est un marker avec un label !

              } else if (iconStyle && labelStyle) {
                var fctIconLabel = process.iconLabelStyle;

                if (fctIconLabel && typeof fctIconLabel === "function") {
                  fctIconLabel(features[index], iconStyle, labelStyle);
                }
              }
            }
          }

          break;

        default:
          logger.trace("tag is not processing !");
      }
    }
  }

  ;
  /**
   * Write Extend Styles for Features.
   * This function overloads ol.format.KML.writeFeatures ...
   *
   * @see ol.format.KML.prototype.writeFeatures
   * @param {Object[]} features - Features.
   * @param {Object} options - Options.
   *
   * @return {String} Result.
   */

  KML.prototype.writeFeatures = function (features, options) {
    // KML.prototype._parentWriteFeatures = ol.format.KML.prototype.writeFeatures;
    logger.log("overload : ol.format.KML.writeFeatures");

    var kmlString = this._writeExtendStylesFeatures(features, options);

    return kmlString;
  };
  /**
   * _writeExtendStylesFeatures
   *
   * @param {Object[]} features - features
   * @param {Object} options - options
   *
   * @returns {String} kml string formatted
   *
   * @private
   */


  KML.prototype._writeExtendStylesFeatures = function (features, options) {
    var kmlString = olKML.prototype.writeFeatures.call(this, features, options);
    var kmlDoc = _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_3__["default"].parse(kmlString);

    if (kmlDoc === null) {
      // au cas où...
      return kmlString;
    }
    /**
     * C'est un Label !
     * On va donc y ajouter qq styles sur le Label (police, halo, ...) :
     * Insertion : PlaceMark>Style>LabelStyle
     *
     * @param {Object} feature - feature
     * @param {DOMElement} style - style
     *
     * @example
     *      <LabelStyleSimpleExtensionGroup fontFamily="Arial" haloColor="16777215" haloRadius="2" haloOpacity="1"/>
     */


    var __createExtensionStyleLabel = function __createExtensionStyleLabel(feature, style) {
      logger.trace("label with style :", style);

      if (!feature) {
        return;
      }

      var labelName = feature.getProperties().name;

      if (!labelName) {
        return;
      } // RGB Colors (RRGGBB) To KML Colors (AABBGGRR)


      function __convertRGBColorsToKML(data) {
        var strColor = data.toString(16);

        if (strColor.charAt(0) === "#") {
          strColor = strColor.slice(1);
        }

        var opacity = 1;
        opacity = parseInt(opacity * 255, 10);
        opacity = opacity.toString(16);
        var color = opacity;
        color = color + strColor.substr(4, 2);
        color = color + strColor.substr(2, 2);
        color = color + strColor.substr(0, 2);
        return color.toLowerCase();
      } // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...


      if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__["Style"]) {
        var fTextStyle = feature.getStyle().getText().getStroke();

        if (!fTextStyle) {
          return;
        }

        var _haloColor = __convertRGBColorsToKML(fTextStyle.getColor()) || __convertRGBColorsToKML("#FFFFFF"); // KML Colors : 64FFFFFF (blanc)


        var _haloRadius = fTextStyle.getWidth() || "0";

        var _haloOpacity = "1"; // TODO

        var _font = "Sans"; // TODO

        if (style && style.getElementsByTagName("LabelStyleSimpleExtensionGroup").length === 0) {
          var labelextend = kmlDoc.createElement("LabelStyleSimpleExtensionGroup");
          labelextend.setAttribute("fontFamily", _font);
          labelextend.setAttribute("haloColor", _haloColor);
          labelextend.setAttribute("haloRadius", _haloRadius);
          labelextend.setAttribute("haloOpacity", _haloOpacity);
          style.appendChild(labelextend);
        }
      }
    };
    /**
     * C'est un marker !
     * On va donc ajouter la balise hotspot :
     *  Traiter le cas où les unités sont de type
     *   - FRACTION
     *   - PIXELS
     *  Insertion du correctif dans le noeud : <PlaceMark><Style>IconStyle
     *
     * @param {Object} feature - ol feature
     * @param {DOMElement} style - style
     *
     *  @example
     *  <Style><IconStyle>
     *      <hotSpot x="0.5"  y="1" xunits="fraction" yunits="fraction"/>
     *  </IconStyle></Style>
     */


    var __createHotSpotStyleIcon = function __createHotSpotStyleIcon(feature, style) {
      logger.trace("marker with style (hotspot):", style);

      if (!feature) {
        return;
      } // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...


      if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__["Style"]) {
        var fImageStyle = feature.getStyle().getImage();

        if (!fImageStyle) {
          return;
        }

        var x = 0;
        var y = 0;
        var xunits = "pixels";
        var yunits = "pixels";
        var size = fImageStyle.getSize();
        var anchor = fImageStyle.getAnchor(); // pixels ! but anchor_ in the current unit !

        if (anchor.length) {
          x = anchor[0];
          y = anchor[1];

          if (yunits === "fraction") {
            y = y === 1 ? 0 : 1 - y; // cf. fixme contribution à faire !
          } else {
            y = yunits === "pixels" && y === size[1] ? 0 : size[1] - y; // cf. fixme contribution à faire !
          }
        }

        if (style && style.getElementsByTagName("hotSpot").length === 0) {
          var hotspot = kmlDoc.createElement("hotSpot");
          hotspot.setAttribute("x", x);
          hotspot.setAttribute("y", y);
          hotspot.setAttribute("xunits", xunits);
          hotspot.setAttribute("yunits", yunits);
          style.appendChild(hotspot);
        }
      }
    }; // TODO


    var __createStyleToFeatureIconLabel = function __createStyleToFeatureIconLabel(feature, iconStyle, labelStyle) {
      logger.trace("write an icon with a label");

      __createHotSpotStyleIcon(feature, iconStyle);

      __createExtensionStyleLabel(feature, labelStyle);
    }; // TODO


    var __setNameData = function __setNameData(feature, tags) {
      for (var i = 0; i < tags.length; i++) {
        var tag = tags[i];

        if (tag.nodeName === "name") {
          return;
        }
      }

      var labelName = feature.getProperties().name;

      if (labelName) {
        var name = kmlDoc.createElement("name");
        name.innerHTML = labelName;
        tags.appendChild(name);
      }
    }; // On ajoute les styles étendus dans le DOM


    _kmlRead(kmlDoc, features, {
      labelStyle: __createExtensionStyleLabel,
      iconStyle: __createHotSpotStyleIcon,
      iconLabelStyle: __createStyleToFeatureIconLabel,
      nameData: __setNameData
    }); // On convertit le DOM en String...


    var kmlStringExtended = _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_3__["default"].toString(kmlDoc); // au cas où...

    if (!kmlStringExtended) {
      kmlStringExtended = kmlString;
    } // On realise un formattage du KML


    var kmlStringFormatted = _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_3__["default"].format(kmlStringExtended); // au cas où...

    if (kmlStringFormatted === "") {
      kmlStringFormatted = kmlString;
    }

    return kmlStringFormatted;
  };
  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.KML.readFeatures ...
   *
   * @see ol.format.KML.prototype.readFeatures
   * @param {Document|Node|ArrayBuffer|Object|String} source - Source.
   * @param {olx.format.ReadOptions=} options - options.
   * @return {Array.<ol.Feature>} Features.
   */


  KML.prototype.readFeatures = function (source, options) {
    // KML.prototype._parentReadFeatures = ol.format.KML.prototype.readFeatures;
    logger.log("overload : ol.format.KML.readFeatures");

    var features = this._readExtendStylesFeatures(source, options);

    logger.trace("Styles étendus", features); // la gestion des styles est deplacée au niveau des extensions
    // qui ont besoin de lire un KML (ex. Drawing) ...
    //
    // features.forEach(function (feature) {
    //     var featureStyleFunction = feature.getStyleFunction();
    //     if (featureStyleFunction) {
    //         var styles = featureStyleFunction.call(feature, 0);
    //         if (styles && styles.length !== 0) {
    //             feature.setStyle(styles[0]);
    //         }
    //     }
    // });

    return features;
  };
  /**
   * _readExtendStylesFeatures
   *
   * @param {(Document|Node|ArrayBuffer|Object|String)} source - source
   * @param {olx.format.ReadOptions=} options - options
   *
   * @returns {Object[]} features
   *
   * @private
   */


  KML.prototype._readExtendStylesFeatures = function (source, options) {
    var features = olKML.prototype.readFeatures.call(this, source, options);
    var kmlDoc = null;
    var kmlString = "";

    if (typeof source === "string") {
      kmlString = source;
    } else {
      kmlString = source.documentElement.outerHTML;
    } // On 'deformatte' le KML afin d'eviter des pb de parsing...


    kmlString = kmlString.replace(/\n/g, "");
    kmlString = kmlString.replace(/(>)\s*(<)/g, "$1$2"); // On met en place un Parser sur le KML

    kmlDoc = _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_3__["default"].parse(kmlString);

    if (kmlDoc === null) {
      // au cas où...
      return features;
    }
    /**
     * Gestion des styles étendus sur le Label
     * - ajout d'un icone par defaut (1x1p transparent) sur les labels
     * s'il n'existe pas !
     * - lecture des styles étendus des labels
     *
     * @param {Object} feature - ol feature
     * @param {DOMElement} style - style
     *
     * @example
     * <Placemark>
     *  <description>Un label</description>
     *  <name>C'est un label étendu !</name>
     *  <Style>
     *    <IconStyle>
     *      <Icon>
     *        <href>data:image/png;base64,...</href>
     *      </Icon>
     *    </IconStyle>
     *    <LabelStyle>
     *      <color>ffffffff</color>
     *      <colorMode>normal</colorMode>
     *      <scale>1.85</scale>
     *      <LabelStyleSimpleExtensionGroup haloColor="16711680" haloRadius="5" haloOpacity="1"/>
     *    </LabelStyle>
     *  </Style>
     *  <Point>
     *    <coordinates>2,48</coordinates>
     *  </Point>
     * </Placemark>
     */


    var __getExtensionStyleToFeatureLabel = function __getExtensionStyleToFeatureLabel(feature, style) {
      logger.trace("label with style :", style);

      if (!feature) {
        return;
      } // KML Colors (AABBGGRR) To RGB Colors (RRGGBB)


      function __convertKMLColorsToRGB(data) {
        var color = "";
        color = color + data.substr(6, 2);
        color = color + data.substr(4, 2);
        color = color + data.substr(2, 2);
        var hex = parseInt(color, 16).toString(16);
        var comp = "";
        var len = hex.length || 0;

        for (var i = 0; i < 6 - len; i++) {
          comp += "0";
        }

        hex = "#" + comp + hex;
        return hex.toString(16);
      }

      var _text = feature.getProperties().name || "---";

      var _color = __convertKMLColorsToRGB("ff000000"); // "#000000"


      var _colorHalo = "#FFFFFF";
      var _radiusHalo = 0;
      var _font = "Sans"; // TODO

      var _fontSize = "16px"; // TODO
      // On recherche les balises du Style

      var bLabelStyleSimpleExtensionGroup = false;
      var styles = style.childNodes;

      for (var k = 0; k < styles.length; k++) {
        switch (styles[k].nodeName) {
          case "scale":
            // TODO
            break;

          case "colorMode":
            // TODO
            break;

          case "color":
            _color = __convertKMLColorsToRGB(styles[k].textContent);
            break;

          case "LabelStyleSimpleExtensionGroup":
            bLabelStyleSimpleExtensionGroup = true;
            var attributs = styles[k].attributes;

            for (var l = 0; l < attributs.length; l++) {
              switch (attributs[l].nodeName) {
                case "fontFamily":
                  // TODO
                  break;

                case "haloColor":
                  _colorHalo = __convertKMLColorsToRGB(attributs[l].nodeValue);
                  break;

                case "haloRadius":
                  _radiusHalo = parseInt(attributs[l].nodeValue, 10);
                  break;

                case "haloOpacity":
                  // TODO
                  break;

                default:
              }
            }

            break;

          default: // on ne traite pas les autres informations ...

        }
      } // Ce n'est pas un style étendu !


      if (!bLabelStyleSimpleExtensionGroup) {
        logger.trace("it's not a Label Style Simple Extension Group !");
        return;
      } // On reconstruit le style !


      feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_1__["Style"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_1__["Icon"]({
          src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
          size: [51, 38],
          anchor: [25.5, 38],
          anchorOrigin: "top-left",
          anchorXUnits: "pixels",
          anchorYUnits: "pixels"
        }),
        text: new ol_style__WEBPACK_IMPORTED_MODULE_1__["Text"]({
          font: _fontSize + " " + _font,
          textAlign: "left",
          text: _text,
          // offsetX : 5, // FIXME valeur arbitraire MAIS esthétique !
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_1__["Fill"]({
            color: _color
          }),
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_1__["Stroke"]({
            color: _colorHalo,
            width: _radiusHalo
          })
        })
      }));
    };
    /**
     * Gestion de la balise kml:hostSpot sur les styles d'un Marker
     * - problème avec 'hotspot y === 0' (?)
     *
     * @param {Object} feature - ol feature
     * @param {DOMElement} style - style
     *
     * @example
     * <Placemark>
     *   <Style>
     *     <IconStyle>
     *       <Icon>
     *         <href>data:image/png;base64,...</href>
     *       </Icon>
     *       <hotSpot x="25.5" y="0" xunits="pixels" yunits="pixels"/>
     *     </IconStyle>
     *   </Style>
     *   <Point>
     *     <coordinates>2,48</coordinates>
     *   </Point>
     * </Placemark>
     */


    var __getHotSpotStyleToFeatureIcon = function __getHotSpotStyleToFeatureIcon(feature, style) {
      logger.trace("hotspot :", style);
      var _src = null;
      var _scale = null;
      var _bSizeIcon = false;
      var _sizeW = 51;
      var _sizeH = 38;
      var _bHotSpot = false;
      var _anchorX = 25.5;
      var _anchorXUnits = "pixels";
      var _anchorY = 38;
      var _anchorYUnits = "pixels";
      var styles = style.childNodes;

      for (var k = 0; k < styles.length; k++) {
        switch (styles[k].nodeName) {
          case "Icon":
            var nodes = styles[k].childNodes;

            for (var i = 0; i < nodes.length; i++) {
              switch (nodes[i].nodeName) {
                case "href":
                  _src = nodes[i].textContent;
                  break;

                case "gx:w":
                  _bSizeIcon = true;
                  _sizeW = parseFloat(nodes[i].textContent);
                  break;

                case "gx:h":
                  _bSizeIcon = true;
                  _sizeH = parseFloat(nodes[i].textContent);
                  break;

                default:
              }
            }

            break;

          case "hotSpot":
            _bHotSpot = true;
            var attributs = styles[k].attributes;

            for (var l = 0; l < attributs.length; l++) {
              switch (attributs[l].nodeName) {
                case "x":
                  _anchorX = parseFloat(attributs[l].nodeValue);
                  break;

                case "y":
                  _anchorY = parseFloat(attributs[l].nodeValue);
                  break;

                case "yunits":
                  _anchorXUnits = attributs[l].nodeValue;
                  break;

                case "xunits":
                  _anchorYUnits = attributs[l].nodeValue;
                  break;

                default:
              }
            }

            break;

          case "scale":
            _scale = parseFloat(styles[k].textContent);
            break;

          default: // on ne traite pas les autres informations ...

        }
      }

      var _options = {
        src: _src,
        crossOrigin: "anonymous",
        // cf. https://gis.stackexchange.com/questions/121555/wms-server-with-cors-enabled/147403#147403
        scale: _scale || 1 // FIXME !?

      };

      if (_bSizeIcon) {
        _Common_Utils__WEBPACK_IMPORTED_MODULE_4__["default"].mergeParams(_options, {
          size: [_sizeW, _sizeH]
        });
      }

      if (_bHotSpot) {
        _Common_Utils__WEBPACK_IMPORTED_MODULE_4__["default"].mergeParams(_options, {
          anchor: [_anchorX, _anchorY],
          anchorOrigin: "bottom-left",
          anchorXUnits: _anchorXUnits || "pixels",
          anchorYUnits: _anchorYUnits || "pixels"
        });
      } // existe il déjà le style du label ?


      var featureStyleFunction = feature.getStyleFunction();

      if (featureStyleFunction) {
        var _styles = featureStyleFunction(feature, 0);

        if (_styles && !Array.isArray(_styles)) {
          _styles = [_styles];
        }

        if (_styles && _styles.length !== 0) {
          var _style = _styles.length === 1 ? _styles[0] : _styles[_styles.length - 1]; // on écrase l'icone magic du label !


          feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_1__["Style"]({
            image: new ol_style__WEBPACK_IMPORTED_MODULE_1__["Icon"](_options),
            text: _style.getText()
          }));
        }
      }
    };
    /**
     * Gestion de la balise kml:ExtendedData
     *
     * @param {Object} feature - ol feature
     * @param {DOMElement[]} extend - extend
     *
     * @example
     * //--> Marker (Point), LineString, Polygon
     * <ExtendedData>
     *    <Data name="attributetitle">
     *        <displayName>title</displayName>
     *        <value>Titre à concatener avec la valeur de la balise "kml:description"</value>
     *    </Data>
     * </ExtendedData>
     * //--> Label
     * <ExtendedData>
     *    <Data name="label">
     *        <value>PARIS</value> // valeur à remplacer dans "kml:name"
     *    </Data>
     *    <Data name="attributetitle">
     *        <displayName>title</displayName>
     *        <value>Titre à concatener avec la valeur de la balise "kml:description"</value>
     *    </Data>
     * </ExtendedData>
     */


    var __getExtendedData = function __getExtendedData(feature, extend) {
      logger.trace("extendData :", extend);

      if (!feature) {
        return;
      }

      var _fname = feature.getProperties().name || "";

      var _fdescription = feature.getProperties().description || "";

      var _ftitle = null;

      for (var i = 0; i < extend.length; i++) {
        var data = extend[i];
        var name = data.attributes[0]; // 1 seul attribut !

        var nodes = data.childNodes;

        if (name.nodeName === "name") {
          switch (name.nodeValue) {
            // compatibilité ancien geoportail !
            case "label":
              _fname = data.textContent;
              break;
            // compatibilité ancien geoportail !

            case "title":
            case "attributetitle":
              for (var j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeName === "value") {
                  _ftitle = nodes[j].textContent;
                }
              }

              break;

            default: // for (var k = 0; k < nodes.length; k++) {
            //     if (nodes[k].nodeName === "value") {
            //         _fdescription += "<br>";
            //         _fdescription += nodes[k].textContent;
            //
            //     }
            // }

          }
        }
      } // Modification des properties "name" et "description"


      if (_ftitle) {
        _fdescription = _fdescription ? _ftitle + " : " + _fdescription : _ftitle;
      }

      feature.setProperties({
        name: _fname,
        description: _fdescription
      });
    };
    /** TODO
    * @param {Object} feature - ol feature
    * @param {DOMElement} iconStyle - icon style
    * @param {DOMElement} labelStyle - label style
    *
    *
    */


    var __getStyleToFeatureIconLabel = function __getStyleToFeatureIconLabel(feature, iconStyle, labelStyle) {
      logger.trace("display icon and label");

      __getExtensionStyleToFeatureLabel(feature, labelStyle);

      __getHotSpotStyleToFeatureIcon(feature, iconStyle);
    }; // On lit les styles étendus et on les ajoute aux features


    _kmlRead(kmlDoc, features, {
      labelStyle: this.options.showPointNames ? __getExtensionStyleToFeatureLabel : null,
      iconStyle: __getHotSpotStyleToFeatureIcon,
      iconLabelStyle: this.options.showPointNames ? __getStyleToFeatureIconLabel : __getHotSpotStyleToFeatureIcon,
      extendedData: __getExtendedData
    });

    return features;
  };

  return KML;
}(ol_format_KML__WEBPACK_IMPORTED_MODULE_0___default.a);

/* harmony default export */ __webpack_exports__["default"] = (KML); // Expose KML as ol.source.KMLExtended. (for a build bundle)

if (window.ol && window.ol.format) {
  window.ol.format.KMLExtended = KML;
}

/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = ol.format.KML;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = ol.style;

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("parser");
/**
* @module Parser
* @alias Gp.Parser
* @description
* ...
*
* @example
* parse();
* toString();
*/

var Parser = {
  /**
   * ...
   *
   * @param {String} xml - XML string
   * @returns {DOMElement} doc
   */
  parse: function parse(xml) {
    var doc = null;
    var parser = null;
    var scope = typeof window !== "undefined" ? window : null;

    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && window === null) {
      // code for nodejs
      var DOMParser = __webpack_require__(64).DOMParser;

      parser = new DOMParser();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.DOMParser) {
      // code for modern browsers
      parser = new scope.DOMParser();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.ActiveXObject) {
      // code for old IE browsers
      doc = new scope.ActiveXObject("Microsoft.XMLDOM");
      doc.async = false;
      doc.loadXML(xml);
    } else {
      logger.log("Incompatible environment for DOM Parser !");
    }

    logger.trace(doc);
    return doc;
  },

  /**
   * ...
   *
   * @param {DOMElement} doc - doc
   * @returns {String} XML string
   */
  toString: function toString(doc) {
    // TODO
    // try catch pour les exceptions !
    // cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer/serializeToString
    var oSerializer = new XMLSerializer();
    var xml = oSerializer.serializeToString(doc);
    logger.trace(xml);
    return xml;
  },

  /**
   * ...
   * cf. https://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript/
   *
   * @param {String} xml - XML string
   * @returns {String} XML string formatted
   */
  format: function format(xml) {
    var reg = /(>)\s*(<)(\/*)/g; // updated Mar 30, 2015

    var wsexp = / *(.*) +\n/g;
    var contexp = /(<.+>)(.+\n)/g;
    xml = xml.replace(reg, "$1\n$2$3").replace(wsexp, "$1\n").replace(contexp, "$1\n$2");
    var formatted = "";
    var lines = xml.split("\n");
    var indent = 0;
    var lastType = "other"; // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions

    var transitions = {
      "single->single": 0,
      "single->closing": -1,
      "single->opening": 0,
      "single->other": 0,
      "closing->single": 0,
      "closing->closing": -1,
      "closing->opening": 0,
      "closing->other": 0,
      "opening->single": 1,
      "opening->closing": 0,
      "opening->opening": 1,
      "opening->other": 1,
      "other->single": 0,
      "other->closing": -1,
      "other->opening": 0,
      "other->other": 0
    };

    for (var i = 0; i < lines.length; i++) {
      var ln = lines[i];
      var single = Boolean(ln.match(/<.+\/>/)); // is this line a single tag? ex. <br />

      var closing = Boolean(ln.match(/<\/.+>/)); // is this a closing tag? ex. </a>

      var opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)

      var type = single ? "single" : closing ? "closing" : opening ? "opening" : "other";
      var fromTo = lastType + "->" + type;
      lastType = type;
      var padding = "";
      indent += transitions[fromTo];

      for (var j = 0; j < indent; j++) {
        padding += "\t";
      }

      if (fromTo === "opening->closing") {
        formatted = formatted.substr(0, formatted.length - 1) + ln + "\n"; // substr removes line break (\n) from prev loop
      } else {
        formatted += padding + ln + "\n";
      }
    }

    logger.trace(formatted);
    return formatted;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Parser);

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
* @module Utils
* @alias Gp.olUtils
* @description
* ...
*
* @example
* detectSupport();
* assign();
* mergeParams();
*/
var Utils = {
  /**
   * this method is called by the constructor.
   * this information is useful to switch to touch mode.
   * Detection : test for desktop or tactile
   *
   * @returns {Boolean} isDesktop - true for desktop userAgent, false for mobile
   */
  detectSupport: function detectSupport() {
    var isDesktop = true;
    var userAgent = window.navigator.userAgent.toLowerCase();

    if (userAgent.indexOf("iphone") !== -1 || userAgent.indexOf("ipod") !== -1 || userAgent.indexOf("ipad") !== -1 || userAgent.indexOf("android") !== -1 || userAgent.indexOf("mobile") !== -1 || userAgent.indexOf("blackberry") !== -1 || userAgent.indexOf("tablet") !== -1 || userAgent.indexOf("phone") !== -1 || userAgent.indexOf("touch") !== -1) {
      isDesktop = false;
    }

    if (userAgent.indexOf("msie") !== -1 || userAgent.indexOf("trident") !== -1) {
      isDesktop = true;
    }

    return isDesktop;
  },

  /**
   *  Copies all source object members to dest
   *
   * @param {Object} dest - destination object where properties and method will be copied
   * @param {Object} source - source object from which properties and method will be copied
   * @returns {Object} dest
   */
  assign: function assign(dest, source) {
    dest = dest || {};

    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        dest[prop] = source[prop];
      }
    }

    return dest;
  },

  /**
   * Merge two objects parameters (deeper than assign)
   *
   * @param {Object} dest     - destination object where properties and method will be merge
   * @param {Object} source   - source object from which properties and method will be merge
   * @param {Boolean} replace - replace destination value by source if exists or not (true by default)
   */
  mergeParams: function mergeParams(dest, source, replace) {
    if (!dest || !source) {
      return;
    }

    if (typeof replace === "undefined") {
      replace = true;
    }

    for (var param in source) {
      if (source.hasOwnProperty(param)) {
        if (_typeof(source[param]) === "object") {
          if (dest.hasOwnProperty(param)) {
            this.mergeParams(dest[param], source[param], replace);
          } else {
            dest[param] = source[param];
          }
        } else {
          if (dest.hasOwnProperty(param)) {
            if (replace) {
              dest[param] = source[param];
            }
          } else {
            dest[param] = source[param];
          }
        }
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Utils);

/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_format_GPX__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(149);
/* harmony import */ var ol_format_GPX__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_GPX__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(150);
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_style_Style__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(151);
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_style_Circle__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(152);
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_style_Icon__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(153);
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_style_Fill__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(154);
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/* harmony import */ var _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(146);
// import openlayers
 // import Style





 // import local



/**
 * @classdesc
 *
 * Extended Styles GPX format to export (internal use only !)
 *
 * SPEC
 * cf. https://www.topografix.com/gpx.asp
 *
 *
 * @constructor
 * @alias ol.format.GPXExtended
 * @extends {ol.format.GPX}
 * @param {Object} options - Options
 * @param {Object} options.defaultStyle - Styles by default
 * @param {function} options.readExtensions - Reading extensions (native)
 */

var GPX = function (olGPX) {
  function GPX(options) {
    if (!(this instanceof GPX)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    this.options = options || {}; // INFO
    // surcharge de la callback : readExtensions

    if (this.options.readExtensions && typeof this.options.readExtensions === "function") {
      var clbk = this.options.readExtensions; // callback definie par l'utilisateur

      this.options.readExtensions = function (feature, node) {
        this.readExtensions(feature, node);
        clbk.call(this, feature, node);
      };
    } else {
      this.options.readExtensions = this.readExtensions;
    } // INFO
    // defaultStyle est un objet de type Style


    if (this.options.defaultStyle === null || typeof this.options.defaultStyle === "undefined") {
      this.options.defaultStyle = {};
    } // call constructor


    olGPX.call(this, this.options);
  } // Inherits


  if (olGPX) GPX.__proto__ = olGPX;
  /**
   * @lends module:GPX
   */

  GPX.prototype = Object.create(olGPX.prototype, {});
  /**
   * Constructor (alias)
   */

  GPX.prototype.constructor = GPX;
  /**
   * Balises autorisées selon la specification "simplestyle"
   */

  GPX.SIMPLESTYLE_TAGS = ["fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width", "marker-symbol", "marker-color", "marker-size"];
  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GPX.readFeatures ...
   *
   * @see ol.format.GPX.prototype.readFeatures
   * @param {Document|Node|ArrayBuffer|Object|String} source - Source.
   * @param {olx.format.ReadOptions=} options - options.
   * @return {Array.<ol.Feature>} Features.
   */

  GPX.prototype.readFeatures = function (source, options) {
    var _this = this;

    // INFO
    // le travail de lecture des extensions du format est porté
    // par la callback des options : readExtensions
    var features = olGPX.prototype.readFeatures.call(this, source, options); // INFO
    // on applique les styles par defaut definis avec l'option defaultStyle
    // sauf sur les features qui possèdent des extensions.
    // les features avec extensions sont traité au préalable
    // dans la callback des options : readExtensions

    features.forEach(function (feature) {
      // HACK : enregistrement de la description de la balise 'desc' du format GPX
      var value = feature.getProperties().desc;

      if (value) {
        feature.setProperties({
          description: value
        });
      }

      var styleFunction = function styleFunction(feature, resolution) {
        var style = null;

        if (Object.keys(_this.options.defaultStyle).length === 0) {
          return [];
        }

        var type = feature.getGeometry().getType();

        switch (type) {
          case "Point":
            if (_this.options.defaultStyle.getImage()) {
              style = new ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default.a({
                image: _this.options.defaultStyle.getImage()
              });
            }

            break;

          case "LineString":
          case "MultiLineString":
            var options = {};

            if (_this.options.defaultStyle.getFill()) {
              options.fill = _this.options.defaultStyle.getFill();
            }

            if (_this.options.defaultStyle.getStroke()) {
              options.stroke = _this.options.defaultStyle.getStroke();
            }

            style = new ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default.a(options);
            break;
        }

        return [style];
      };

      var featureStyleFunction = feature.getStyleFunction();

      if (!featureStyleFunction) {
        feature.setStyle(styleFunction);
      }
    });
    return features;
  };
  /**
   * Write Extend Styles for Features.
   * This function overloads ol.format.GPX.writeFeatures ...
   *
   * @see ol.format.GPX.prototype.writeFeatures
   * @param {Object[]} features - Features.
   * @param {Object} options - Options.
   *
   * @return {String} Result.
   */


  GPX.prototype.writeFeatures = function (features, options) {
    // INFO
    // il n'est pas possible de surcharger les parsers d'OpenLayers (private),
    // on decide de (re)parser la sortie d'OpenLayers afin d'y placer les balises
    // d'extensions
    // on met à jour les properties de styles
    features.forEach(function (feature) {
      // HACK : enregistrement de la description dans la balise 'desc' du format GPX
      var value = feature.getProperties().description;

      if (value) {
        feature.setProperties({
          desc: value
        });
      }

      var style = feature.getStyle();

      if (style) {
        // style ajouté via une fonction, pour les styles par defaut par ex.
        if (typeof style === "function") {
          var styles = style.call(this, feature, 0);

          if (styles && styles.length !== 0) {
            style = styles[0];
          } else {
            // au cas où...
            return;
          }
        } // convertir le style en properties
        // * stroke
        // * fill (impossible car pas de polygone sur le GPX !)
        // * image :
        //      * un marker
        //      * un cercle si fill et/ou stroke est present !


        var fill = style.getFill();

        if (fill) {
          var colorFill = null;

          if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(fill.getColor())) {
            colorFill = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(fill.getColor());
            feature.set("fill", colorFill.hex);
            feature.set("fill-opacity", colorFill.opacity);
          } else {
            colorFill = fill.getColor();
            feature.set("fill", colorFill);
            feature.set("fill-opacity", 1);
          }
        }

        var stroke = style.getStroke();

        if (stroke) {
          var colorStroke = null;

          if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(stroke.getColor())) {
            colorStroke = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(stroke.getColor());
            feature.set("stroke", colorStroke.hex);
            feature.set("stroke-opacity", colorStroke.opacity);
          } else {
            colorStroke = stroke.getColor();
            feature.set("stroke", colorStroke);
            feature.set("stroke-opacity", 1);
          }

          feature.set("stroke-width", stroke.getWidth());
        }

        var image = style.getImage();

        if (image) {
          // si le tag image est seul...
          // c'est soit un marker ou soit un cercle !
          if (image instanceof ol_style_Icon__WEBPACK_IMPORTED_MODULE_3___default.a) {
            var color = image.getColor(); // array

            if (Array.isArray(color)) {
              var c = "rgba(";
              c += color[0] + ",";
              c += color[1] + ",";
              c += color[2] + ",";
              c += color[3] + ")";
              color = c;
            } // feature.set("marker-color", ""); // par defaut


            if (color) {
              var colorIcon = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(color);
              feature.set("marker-color", colorIcon.hex);
            }

            var scaleIcon = image.getScale();

            switch (scaleIcon) {
              case 0.5:
                feature.set("marker-size", "small");
                break;

              case 1:
                feature.set("marker-size", "medium");
                break;

              case 1.5:
                feature.set("marker-size", "large");
                break;

              default:
                // feature.set("marker-size", ""); // par defaut
                break;
            } // feature.set("marker-symbol", ""); // par defaut


            var srcImage = image.getSrc();

            if (srcImage) {
              feature.set("marker-symbol", srcImage);
            }
          } else {
            var fillImg = image.getFill();

            if (fillImg) {
              var colorFillImg = null;

              if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(fillImg.getColor())) {
                colorFillImg = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(fillImg.getColor());
                feature.set("fill", colorFillImg.hex);
                feature.set("fill-opacity", colorFillImg.opacity);
              } else {
                colorFillImg = fillImg.getColor();
                feature.set("fill", colorFillImg);
                feature.set("fill-opacity", 1);
              }
            }

            var strokeImg = image.getStroke();

            if (strokeImg) {
              var colorStrokeImg = null;

              if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(strokeImg.getColor())) {
                colorStrokeImg = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(strokeImg.getColor());
                feature.set("stroke", colorStrokeImg.hex);
                feature.set("stroke-opacity", colorStrokeImg.opacity);
              } else {
                colorStrokeImg = strokeImg.getColor();
                feature.set("stroke", colorStrokeImg);
                feature.set("stroke-opacity", 1);
              }

              feature.set("stroke-width", strokeImg.getWidth());
            }
          }
        }
      }
    });
    var gpxStringInitial = olGPX.prototype.writeFeatures.call(this, features, options);
    var gpxDoc = _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_7__["default"].parse(gpxStringInitial); // au cas où..., si exception...

    if (gpxDoc === null) {
      return gpxStringInitial;
    } // INFO
    // à chaque fois qu'un style est trouvé dans un feature,
    // on appelle la fonction d'insertion des balises extensions dans le DOM.


    processExtensions_(gpxDoc, features, {
      extensions: writeExtensions_
    }); // dom -> string

    var gpxStringExtended = _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_7__["default"].toString(gpxDoc); // au cas où..., si exception...

    if (!gpxStringExtended) {
      return gpxStringInitial;
    } // format string


    var gpxStringFormatted = _Common_Utils_Parser__WEBPACK_IMPORTED_MODULE_7__["default"].format(gpxStringExtended); // au cas où..., si exception...

    if (gpxStringFormatted === "") {
      return gpxStringInitial;
    }

    return gpxStringFormatted;
  };
  /**
   * Callback to read extensions from options : readExtensions
   *
   * @param {*} feature - ...
   * @param {*} node - ...
   */


  GPX.prototype.readExtensions = function (feature, node) {
    var _node = node; // recherche de la properties de type Node ou Element
    // si le node n'est pas renseigné...

    if (!node) {
      var props = feature.getProperties();

      for (var key in props) {
        if (Object.hasOwnProperty.call(props, key)) {
          var _element = props[key];

          if (_element instanceof Node) {
            _node = _element;
            break;
          }
        }
      }
    }

    if (!_node) {
      return;
    } // ex. de nodes :
    // <extensions>
    //     <marker-size>medium</marker-size>
    //     <marker-symbol></marker-symbol>
    //     <marker-color>#ffffff</marker-color>
    // </extensions>


    for (var index = 0; index < _node.childNodes.length; index++) {
      var element = _node.childNodes[index];

      if (element.nodeType === 1) {
        feature.set(element.nodeName, element.textContent);
      }
    } // les options de styles


    var options = {}; // properties :
    // "marker-size" -> icon
    // "marker-symbol" -> icon
    // "marker-color" -> icon

    var marker = null;

    if (feature.get("marker-color") || feature.get("marker-size") || feature.get("marker-symbol")) {
      marker = {}; // icone par defaut

      marker["src"] = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAToSURBVFiF3VhdbFNlGH7ec05/F6IUE9GLIYgXXYpXJBBZE0xM9EausIl6ObzBGSHRdnEJ1p+RhnBBNF4YY/xJFigNaIwxLpFYB2WwMWCW0bG1W7eEdUBwQ0fb7fy83nQJjK3nnO90F/okvTnf+7zP+/Q75/ve7wP+R6BGJ4xGo+skSXqFmfcAaAHwFIANAO4CmCai64Zh/OT3+3+Nx+PzjdRumJmOjo71zNwB4B0APguUMjN/vri4mDh27NhcI2poiJloNLqXiL4EEBCg/8XMbx05cuS00zpkh3yKxWKHiOgLAH7BHD4iiuzatcvIZDJnnRTjyEw0Gv2QiD6C8xkmInqxtbVVy2QyvcJJRIm1V+ukkxwrwCCivYlE4gcRslAhBw4ceNzj8RQg9o2YYZaInk0kErN2iZKImtvt/gBrYwQA1gN4X4Roe2ai0eg6IroFa8uvKMo+n+9Ju/uQYleltiGaGnG73eVIJNIfDAa3yLK8Udf1mVwuN55MJneoqmrG91er1ZcBnLJVm51gAKjt7HXhdrvLnZ2d46FQaLcsy80A3LIsN4dCod2dnZ15l8tVaYTOcoh8M0GzgEgk0u/xeEIrjXm93m2RSOSiBZ0Wu4WJmHnaLCAYDG6pN97S0rK5ETrLIWJmg1mALMsbnYzX8ITlimoQMfOPWYCu6zMm4yULOn9brqgGETO3zAJyudx4vfFr164VzXIwc90/ZCWImOk3C0gmkzuq1Wp2pbFyuZxNpVI7zXIQkanOcoiY+d0sQFVVX1dX19ZsNpvWdX0SwKKu65NDQ0Ppw4cPP6dpmtcsBzOn7RZme9P0+XynK5XKZwAeqxenqqqvu7t79wOPNtV+VnDPMAzb5xvbM1NrMb6xy7OJr48ePXrfLkmo0SSijwHcFuFawG0i+lSEKGSm1p4fFOFawEGR9h9weLCKxWLdAN5wkuNBMPPxEydOvC1JksfD7Fsg8riYSdMlFwAosqFqkmQQUcW9sHB/282bcylAX+LbXgCWYT+AFwA84zAPVFWdO9PTM+WWpHcBQCeCAoCJICsMAGAQZGaAGZrLhcubNutbGUVF4rMjxWLR8ZE3Fou1AkjDwX0CM/OVwcHvJwqFomgKDfjO6e0MMpnMVDgc9gIIi+YoTU+fyw4NXXFQBpFh3BFaAJbD6/UeAmClrX8ElXK5dOnixT+c6BuAoUtSoSFm4vG4ZhjGm7DQhD5UhGGoAwMDp1RV1c2jVwHzIsny6WKxOOP4NVvC+fPnZ8Ph8F0Ar1rlFPL5X8bHxuo2pXXADIx4df3kjcnJSWANLs5jsdhJAK+Zxd2bmxv5racnKSBRYeY/oSiDhULhoY3b6dL8CDRN209EL8myvH7VGFW9f6Gv72erOZlJA3GeJWm4ubk5l06ntZXiGj4zANDe3r6nqanpx1Xyc/bq1eOjN26M1cvBTKoEY4IkadiQ5ZF8Pr9gprsmZgCgvb29u6mp6ZHuYKZUupDp7e1ZhVYB0bgEjLr8/tzw8PCiHc2Gv2ZLmJ+fb1MUpdXj8TQvPatWq3f6+/rOPBjHQBnMY4okXX9++/Z8KpUSXtnWbGYAYN++fTsDgUAvEbkMw9AvnDv3ValUugXgHojyMjD6+sTEWBwwGqG3pmYAoK2t7ZNAIPDe1OTUqSuXBr6FouRGR0enAfBaa/+n8S8PPeWMetb8+wAAAABJRU5ErkJggg==";
      marker["anchor"] = [0.5, 1];
      var symbolMarker = feature.get("marker-symbol");

      if (symbolMarker) {
        if (symbolMarker.search("data:image/png;base64") !== -1) {
          // icone du portail
          marker["src"] = symbolMarker;
        } else {// TODO
          // utiliser les symboles de Maki
          // (cf. https://labs.mapbox.com/maki-icons/)
        }
      }

      var colorMarker = feature.get("marker-color");

      if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isHex(colorMarker)) {
        marker["color"] = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].hexToRgba(colorMarker, 1);
      }

      var size = feature.get("marker-size");

      if (size) {
        switch (size) {
          case "small":
            marker["scale"] = 0.5;
            break;

          case "medium":
            marker["scale"] = 1;
            break;

          case "large":
            marker["scale"] = 1.5;
            break;

          default:
            marker["scale"] = 1;
            break;
        }
      }
    } // properties :
    // "stroke" -> line / circle
    // "stroke-opacity" -> line / circle
    // "stroke-width" -> line / circle


    var stroke = null;

    if (feature.get("stroke") || feature.get("stroke-opacity") || feature.get("stroke-width")) {
      stroke = {};
      stroke["color"] = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].hexToRgba(feature.get("stroke"), feature.get("stroke-opacity") || 1);
      stroke["width"] = feature.get("stroke-width") || 1;
    } // properties :
    // "fill" -> circle
    // "fill-opacity" -> circle


    var fill = null;

    if (feature.get("fill") || feature.get("fill-opacity")) {
      fill = {};
      fill["color"] = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].hexToRgba(feature.get("fill"), feature.get("fill-opacity") || 1);
    } // styles en fonction du type de geometrie


    var type = feature.getGeometry().getType();

    switch (type) {
      case "Point":
        // representer un point de depart ou d'arrivée
        if (marker) {
          options["image"] = new ol_style_Icon__WEBPACK_IMPORTED_MODULE_3___default.a(marker);
        } // representer un point intermediaire


        var optionsCircle = {};

        if (stroke) {
          optionsCircle["stroke"] = new ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5___default.a(stroke);
        }

        if (fill) {
          optionsCircle["fill"] = new ol_style_Fill__WEBPACK_IMPORTED_MODULE_4___default.a(fill);
        }

        if (Object.keys(optionsCircle).length !== 0) {
          optionsCircle["radius"] = 6; // param fixe

          options["image"] = new ol_style_Circle__WEBPACK_IMPORTED_MODULE_2___default.a(optionsCircle);
        }

        break;

      case "LineString":
      case "MultiLineString":
        if (stroke) {
          options["stroke"] = new ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5___default.a(stroke);
        }

        break;

      default:
        break;
    } // si aucun style disponible, on utilisera le style par defaut defini
    // par l'utilisateur ou l'application


    if (Object.keys(options).length !== 0) {
      feature.setStyle(new ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default.a(options));
    }
  };
  /**
   * ...
   *
   * @param {Object} feature - ...
   * @param {DOMElement} node - ...
   * @private
   */


  function writeExtensions_(feature, node) {
    // creation du DOM
    var extensionsNode = document.createElementNS(node.parentNode.namespaceURI, "extensions");
    GPX.SIMPLESTYLE_TAGS.forEach(function (key) {
      if (feature.get(key)) {
        var extension = document.createElementNS(node.parentNode.namespaceURI, key);
        extension.innerHTML = feature.get(key);
        extensionsNode.appendChild(extension);
      }
    });
    node.appendChild(extensionsNode);
  }
  /**
   * ...
   *
   * @param {DOMElement} doc - ...
   * @param {Object} features - ...
   * @param {Object} actions - ...
   * @private
   */


  function processExtensions_(doc, features, actions) {
    // INFO
    // OpenLayers ne gère pas tous les tags du format GPX : ex. metadata
    // Liste des tags :
    // * wpt
    // * rte
    // * trk
    // On peut y placer nos balises extensions.
    var index = -1;
    var root = doc.documentElement;
    var nodes = root.childNodes;

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      switch (node.nodeName) {
        case "wpt":
        case "rte":
        case "trk":
          index++;
          var feature = features[index];
          var style = feature.getStyle();

          if (style) {
            var fct = actions.extensions;

            if (fct && typeof fct === "function") {
              fct(feature, node);
            }
          }

          break;

        default:
          // on ne devrait jamais passer à ce niveau !?
          // sauf si OpenLayers ajoute le noeud "metadata"...
          break;
      }
    }
  }

  return GPX;
}(ol_format_GPX__WEBPACK_IMPORTED_MODULE_0___default.a);

/* harmony default export */ __webpack_exports__["default"] = (GPX); // Expose GPX as ol.source.GPXExtended. (for a build bundle)

if (window.ol && window.ol.format) {
  window.ol.format.GPXExtended = GPX;
}

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = ol.format.GPX;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = ol.style.Style;

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = ol.style.Circle;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = ol.style.Icon;

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = ol.style.Fill;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = ol.style.Stroke;

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
* @module ColorUtils
* @alias Gp.ColorUtils
* @description
* ...
*
* @example
* rgbaToHex();
* hexToRgba();
* isHex();
* isRGB();
*/
var ColorUtils = {
  /**
   * Converts rgba String to #RRGGBBAA
   * (Code adapted from : https://gist.github.com/mstssk/afda4ce9e5c335fd79cd)
   *
   * @param {String} rgba - A color of RGB or RGBA format.
   * @returns {Object} hex and opacity formated values
   */
  rgbaToHex: function rgbaToHex(rgba) {
    // number to hex conversion
    function hex(number) {
      if (number > 255) {
        throw new Error("'" + number + "'' is greater than 255(0xff);");
      }

      var str = Number(number).toString(16);
      return ("0" + str).slice(-2);
    }

    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(rgba);

    if (!parsed) {
      throw new Error("Invalid format: " + rgba);
    }

    var red = parsed[1];
    var green = parsed[2];
    var blue = parsed[3];
    var alpha = parsed[4];
    var elems = [hex(red), hex(green), hex(blue)];
    var result = {};
    result.hex = "#" + elems.join("");

    if (alpha) {
      // elems.push(hex(alpha));
      result.opacity = parseFloat(alpha);
    }

    return result;
  },

  /**
   * Converts hex color and opacity value to rgba String.
   * (Code adapted from : http://stackoverflow.com/a/5624139)
   * @param {String} hex - A color value on RGB format (hexa).
   * @param {Number} opacity - A opacity value.
   * @returns {String} A color of RGB or RGBA format
   */
  hexToRgba: function hexToRgba(hex, opacity) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;

    if (!hex) {
      throw new Error("Invalid format");
    }

    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    rgb = rgb ? {
      r: parseInt(rgb[1], 16),
      g: parseInt(rgb[2], 16),
      b: parseInt(rgb[3], 16)
    } : null;
    var result = rgb ? "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + opacity + ")" : null;
    return result;
  },

  /**
   * Determine if value is a correct hexa color.
   * @param {*} value - hex color (#FFFFFF)
   * @returns {Boolean} True if value is a hexa color
   */
  isHex: function isHex(value) {
    if (!value) {
      return false;
    }

    if (value.charAt(0) !== "#") {
      return false;
    }

    var regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    var parsed = regex.exec(value);

    if (!parsed) {
      return false;
    }

    return true;
  },

  /**
   * Determine if value is a correct rgba color.
   * @param {*} value - rgba color (rgba(125,125,125,1))
   * @returns {Boolean} True if value is a rgba color
   */
  isRGB: function isRGB(value) {
    if (!value) {
      return false;
    }

    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(value);

    if (!parsed) {
      return false;
    }

    return true;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (ColorUtils);

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(157);
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(150);
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_style_Style__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(151);
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_style_Circle__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(152);
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_style_Icon__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(153);
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_style_Fill__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(154);
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
// import openlayers
 // import Style





 // import local


/**
 * @classdesc
 *
 * Extended Styles GeoJSON format to export (internal use only !)
 *
 * SPEC
 * cf. https://github.com/mapbox/simplestyle-spec/
 * cf. https://geojson.org/
 *
 *
 * @constructor
 * @alias ol.format.GeoJSONExtended
 * @extends {ol.format.GeoJSON}
 * @param {Object} options - Options
 * @param {Object} options.defaultStyle - Styles by default
 */

var GeoJSON = function (olGeoJSON) {
  function GeoJSON(options) {
    if (!(this instanceof GeoJSON)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    this.options = options || {}; // INFO
    // defaultStyle est un objet de type Style

    if (this.options.defaultStyle === null || typeof this.options.defaultStyle === "undefined") {
      this.options.defaultStyle = {};
    } // call constructor


    olGeoJSON.call(this, this.options);
  } // Inherits


  if (olGeoJSON) GeoJSON.__proto__ = olGeoJSON;
  /**
   * @lends module:GeoJSON
   */

  GeoJSON.prototype = Object.create(olGeoJSON.prototype, {});
  /**
   * Constructor (alias)
   */

  GeoJSON.prototype.constructor = GeoJSON;
  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GeoJSON.readFeatures ...
   *
   * @see ol.format.GeoJSON.prototype.readFeatures
   * @param {Document|Node|ArrayBuffer|Object|String} source - Source.
   * @param {olx.format.ReadOptions=} options - options.
   * @return {Array.<ol.Feature>} Features.
   */

  GeoJSON.prototype.readFeatures = function (source, options) {
    var _this = this;

    var features = olGeoJSON.prototype.readFeatures.call(this, source, options);
    features.forEach(function (feature) {
      var featureStyleFunction = feature.getStyleFunction(); // existe t il déjà une fonction de style ?
      // si oui, on l'applique !

      if (featureStyleFunction) {
        var styles = featureStyleFunction.call(_this, feature, 0);

        if (styles && styles.length !== 0) {
          feature.setStyle(styles[0]);
        }
      } else {
        // à ce niveau, il n'existe pas de styles, donc :
        // soit, on applique les styles par defaut
        // soit, on prend en compte les styles definis dans le format
        // et, les styles définis dans le format ecrasent les styles par defaut...
        // les options de styles définis dans le format
        var options = {}; // properties :
        // "marker-size" -> icon / label
        // "marker-symbol" -> icon / label
        // "marker-color" -> icon / label

        var marker = null;

        if (feature.get("marker-color") || feature.get("marker-size") || feature.get("marker-symbol")) {
          marker = {}; // icone par defaut

          marker["src"] = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAToSURBVFiF3VhdbFNlGH7ec05/F6IUE9GLIYgXXYpXJBBZE0xM9EausIl6ObzBGSHRdnEJ1p+RhnBBNF4YY/xJFigNaIwxLpFYB2WwMWCW0bG1W7eEdUBwQ0fb7fy83nQJjK3nnO90F/okvTnf+7zP+/Q75/ve7wP+R6BGJ4xGo+skSXqFmfcAaAHwFIANAO4CmCai64Zh/OT3+3+Nx+PzjdRumJmOjo71zNwB4B0APguUMjN/vri4mDh27NhcI2poiJloNLqXiL4EEBCg/8XMbx05cuS00zpkh3yKxWKHiOgLAH7BHD4iiuzatcvIZDJnnRTjyEw0Gv2QiD6C8xkmInqxtbVVy2QyvcJJRIm1V+ukkxwrwCCivYlE4gcRslAhBw4ceNzj8RQg9o2YYZaInk0kErN2iZKImtvt/gBrYwQA1gN4X4Roe2ai0eg6IroFa8uvKMo+n+9Ju/uQYleltiGaGnG73eVIJNIfDAa3yLK8Udf1mVwuN55MJneoqmrG91er1ZcBnLJVm51gAKjt7HXhdrvLnZ2d46FQaLcsy80A3LIsN4dCod2dnZ15l8tVaYTOcoh8M0GzgEgk0u/xeEIrjXm93m2RSOSiBZ0Wu4WJmHnaLCAYDG6pN97S0rK5ETrLIWJmg1mALMsbnYzX8ITlimoQMfOPWYCu6zMm4yULOn9brqgGETO3zAJyudx4vfFr164VzXIwc90/ZCWImOk3C0gmkzuq1Wp2pbFyuZxNpVI7zXIQkanOcoiY+d0sQFVVX1dX19ZsNpvWdX0SwKKu65NDQ0Ppw4cPP6dpmtcsBzOn7RZme9P0+XynK5XKZwAeqxenqqqvu7t79wOPNtV+VnDPMAzb5xvbM1NrMb6xy7OJr48ePXrfLkmo0SSijwHcFuFawG0i+lSEKGSm1p4fFOFawEGR9h9weLCKxWLdAN5wkuNBMPPxEydOvC1JksfD7Fsg8riYSdMlFwAosqFqkmQQUcW9sHB/282bcylAX+LbXgCWYT+AFwA84zAPVFWdO9PTM+WWpHcBQCeCAoCJICsMAGAQZGaAGZrLhcubNutbGUVF4rMjxWLR8ZE3Fou1AkjDwX0CM/OVwcHvJwqFomgKDfjO6e0MMpnMVDgc9gIIi+YoTU+fyw4NXXFQBpFh3BFaAJbD6/UeAmClrX8ElXK5dOnixT+c6BuAoUtSoSFm4vG4ZhjGm7DQhD5UhGGoAwMDp1RV1c2jVwHzIsny6WKxOOP4NVvC+fPnZ8Ph8F0Ar1rlFPL5X8bHxuo2pXXADIx4df3kjcnJSWANLs5jsdhJAK+Zxd2bmxv5racnKSBRYeY/oSiDhULhoY3b6dL8CDRN209EL8myvH7VGFW9f6Gv72erOZlJA3GeJWm4ubk5l06ntZXiGj4zANDe3r6nqanpx1Xyc/bq1eOjN26M1cvBTKoEY4IkadiQ5ZF8Pr9gprsmZgCgvb29u6mp6ZHuYKZUupDp7e1ZhVYB0bgEjLr8/tzw8PCiHc2Gv2ZLmJ+fb1MUpdXj8TQvPatWq3f6+/rOPBjHQBnMY4okXX9++/Z8KpUSXtnWbGYAYN++fTsDgUAvEbkMw9AvnDv3ValUugXgHojyMjD6+sTEWBwwGqG3pmYAoK2t7ZNAIPDe1OTUqSuXBr6FouRGR0enAfBaa/+n8S8PPeWMetb8+wAAAABJRU5ErkJggg==";
          marker["anchor"] = [0.5, 1];
          var symbolMarker = feature.get("marker-symbol");

          if (symbolMarker) {
            if (symbolMarker.search("data:image/png;base64") !== -1) {
              // icone du portail
              marker["src"] = symbolMarker;
            } else {// TODO
              // utiliser les symboles de Maki
              // (cf. https://labs.mapbox.com/maki-icons/)
            }
          }

          var colorMarker = feature.get("marker-color");

          if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isHex(colorMarker)) {
            marker["color"] = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].hexToRgba(colorMarker, 1);
          }

          var size = feature.get("marker-size");

          if (size) {
            switch (size) {
              case "small":
                marker["scale"] = 0.5;
                break;

              case "medium":
                marker["scale"] = 1;
                break;

              case "large":
                marker["scale"] = 1.5;
                break;

              default:
                marker["scale"] = 1;
                break;
            }
          }
        } // properties :
        // "stroke" -> line / polygon / circle
        // "stroke-opacity" -> line / polygon / circle
        // "stroke-width" -> line / polygon / circle


        var stroke = null;

        if (feature.get("stroke") || feature.get("stroke-opacity") || feature.get("stroke-width")) {
          stroke = {};
          stroke["color"] = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].hexToRgba(feature.get("stroke"), feature.get("stroke-opacity") || 1);
          stroke["width"] = feature.get("stroke-width") || 1;
        } // properties :
        // "fill" -> polygon / circle
        // "fill-opacity" -> polygon / circle


        var fill = null;

        if (feature.get("fill") || feature.get("fill-opacity")) {
          fill = {};
          fill["color"] = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].hexToRgba(feature.get("fill"), feature.get("fill-opacity") || 1);
        } // styles en fonction du type de geometrie


        var type = feature.getGeometry().getType();

        switch (type) {
          case "Point":
          case "MultiPoint":
            // Cercle
            var optionsCircle = {};

            if (stroke) {
              optionsCircle["stroke"] = new ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5___default.a(stroke);
            }

            if (fill) {
              optionsCircle["fill"] = new ol_style_Fill__WEBPACK_IMPORTED_MODULE_4___default.a(fill);
            }

            if (Object.keys(optionsCircle).length !== 0) {
              optionsCircle["radius"] = 6; // param fixe

              options["image"] = new ol_style_Circle__WEBPACK_IMPORTED_MODULE_2___default.a(optionsCircle);
            } // Ponctuel ou label


            if (marker) {
              options["image"] = new ol_style_Icon__WEBPACK_IMPORTED_MODULE_3___default.a(marker);
            }

            break;

          case "Polygon":
          case "MultiPolygon":
            if (stroke) {
              options["stroke"] = new ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5___default.a(stroke);
            }

            if (fill) {
              options["fill"] = new ol_style_Fill__WEBPACK_IMPORTED_MODULE_4___default.a(fill);
            }

            break;

          case "LineString":
          case "LinearRing":
          case "MultiLineString":
            if (stroke) {
              options["stroke"] = new ol_style_Stroke__WEBPACK_IMPORTED_MODULE_5___default.a(stroke);
            }

            break;

          default:
            break;
        } // si aucun style disponible, on utilisera le style par defaut defini
        // par l'utilisateur ou l'application


        if (Object.keys(options).length !== 0) {
          feature.setStyle(new ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default.a(options));
        } else {
          // les styles par defaut
          var styleFunction = function styleFunction(feature, resolution) {
            var style = null;

            if (Object.keys(_this.options.defaultStyle).length === 0) {
              return [];
            }

            var type = feature.getGeometry().getType();

            switch (type) {
              case "Point":
              case "MultiPoint":
              case "Circle":
                if (_this.options.defaultStyle.getImage()) {
                  style = new ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default.a({
                    image: _this.options.defaultStyle.getImage()
                  });
                }

                break;

              case "Polygon":
              case "MultiPolygon":
                var optsp = {};

                if (_this.options.defaultStyle.getFill()) {
                  optsp.fill = _this.options.defaultStyle.getFill();
                }

                if (_this.options.defaultStyle.getStroke()) {
                  optsp.stroke = _this.options.defaultStyle.getStroke();
                }

                style = new ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default.a(optsp);
                break;

              case "LineString":
              case "LinearRing":
              case "MultiLineString":
                var optsl = {};

                if (_this.options.defaultStyle.getStroke()) {
                  optsl.stroke = _this.options.defaultStyle.getStroke();
                }

                style = new ol_style_Style__WEBPACK_IMPORTED_MODULE_1___default.a(optsl);
                break;
            }

            return [style];
          };

          feature.setStyle(styleFunction);
        }
      }
    });
    return features;
  };
  /**
   * Write Extend Styles for Features.
   * This function overloads ol.format.GeoJSON.writeFeatures ...
   *
   * @see ol.format.GeoJSON.prototype.writeFeatures
   * @param {Object[]} features - Features.
   * @param {Object} options - Options.
   *
   * @return {String} Result.
   */


  GeoJSON.prototype.writeFeatures = function (features, options) {
    // on met à jour les properties de styles
    features.forEach(function (feature) {
      var style = feature.getStyle();

      if (style) {
        // style ajouté via une fonction, pour les styles par defaut par ex.
        if (typeof style === "function") {
          var styles = style.call(this, feature, 0);

          if (styles && styles.length !== 0) {
            style = styles[0];
          } else {
            // au cas où...
            return;
          }
        } // convertir le style en properties
        // * stroke
        // * fill
        // * image :
        //      * un marker ou un label
        //      * un cercle si fill et/ou stroke est present !


        var fill = style.getFill();

        if (fill) {
          var colorFill = fill.getColor(); // array

          if (Array.isArray(colorFill)) {
            var cf = "rgba(";
            cf += colorFill[0] + ",";
            cf += colorFill[1] + ",";
            cf += colorFill[2] + ",";
            cf += colorFill[3] + ")";
            colorFill = cf;
          }

          if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(colorFill)) {
            var oColorFill = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(colorFill);
            feature.set("fill", oColorFill.hex);
            feature.set("fill-opacity", oColorFill.opacity);
          } else {
            feature.set("fill", colorFill);
            feature.set("fill-opacity", 1);
          }
        }

        var stroke = style.getStroke();

        if (stroke) {
          var colorStroke = stroke.getColor(); // array

          if (Array.isArray(colorStroke)) {
            var cs = "rgba(";
            cs += colorStroke[0] + ",";
            cs += colorStroke[1] + ",";
            cs += colorStroke[2] + ",";
            cs += colorStroke[3] + ")";
            colorStroke = cs;
          }

          if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(colorStroke)) {
            var oColorStroke = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(colorStroke);
            feature.set("stroke", oColorStroke.hex);
            feature.set("stroke-opacity", oColorStroke.opacity);
          } else {
            feature.set("stroke", colorStroke);
            feature.set("stroke-opacity", 1);
          }

          feature.set("stroke-width", stroke.getWidth());
        }

        var image = style.getImage();

        if (image) {
          // si le tag image est seul...
          // c'est soit un marker ou soit un cercle !
          if (image instanceof ol_style_Icon__WEBPACK_IMPORTED_MODULE_3___default.a) {
            var color = image.getColor(); // array

            if (Array.isArray(color)) {
              var c = "rgba(";
              c += color[0] + ",";
              c += color[1] + ",";
              c += color[2] + ",";
              c += color[3] + ")";
              color = c;
            } // feature.set("marker-color", ""); // par defaut


            if (color) {
              var colorIcon = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(color);
              feature.set("marker-color", colorIcon.hex);
            }

            var scaleIcon = image.getScale();

            switch (scaleIcon) {
              case 0.5:
                feature.set("marker-size", "small");
                break;

              case 1:
                feature.set("marker-size", "medium");
                break;

              case 1.5:
                feature.set("marker-size", "large");
                break;

              default:
                // feature.set("marker-size", ""); // par defaut
                break;
            } // feature.set("marker-symbol", ""); // par defaut


            var srcImage = image.getSrc();

            if (srcImage) {
              feature.set("marker-symbol", srcImage);
            }
          } else {
            var fillImg = image.getFill();

            if (fillImg) {
              var colorFillImg = fillImg.getColor(); // array

              if (Array.isArray(colorFillImg)) {
                var cfi = "rgba(";
                cfi += colorFill[0] + ",";
                cfi += colorFill[1] + ",";
                cfi += colorFill[2] + ",";
                cfi += colorFill[3] + ")";
                colorFillImg = cfi;
              }

              if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(colorFillImg)) {
                var oColorFillImg = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(colorFillImg);
                feature.set("fill", oColorFillImg.hex);
                feature.set("fill-opacity", oColorFillImg.opacity);
              } else {
                feature.set("fill", colorFillImg);
                feature.set("fill-opacity", 1);
              }
            }

            var strokeImg = image.getStroke();

            if (strokeImg) {
              var colorStrokeImg = strokeImg.getColor(); // array

              if (Array.isArray(colorStrokeImg)) {
                var csi = "rgba(";
                csi += colorFill[0] + ",";
                csi += colorFill[1] + ",";
                csi += colorFill[2] + ",";
                csi += colorFill[3] + ")";
                colorStrokeImg = csi;
              }

              if (_Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].isRGB(colorStrokeImg)) {
                var oColorStrokeImg = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_6__["default"].rgbaToHex(colorStrokeImg);
                feature.set("stroke", oColorStrokeImg.hex);
                feature.set("stroke-opacity", oColorStrokeImg.opacity);
              } else {
                feature.set("stroke", colorStrokeImg);
                feature.set("stroke-opacity", 1);
              }

              feature.set("stroke-width", strokeImg.getWidth());
            }
          }
        }
      }
    });
    var geoJSONString = olGeoJSON.prototype.writeFeatures.call(this, features, options);
    return geoJSONString;
  };

  return GeoJSON;
}(ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0___default.a);

/* harmony default export */ __webpack_exports__["default"] = (GeoJSON); // Expose GeoJSON as ol.source.GeoJSONExtended. (for a build bundle)

if (window.ol && window.ol.format) {
  window.ol.format.GeoJSONExtended = GeoJSON;
}

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = ol.format.GeoJSON;

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_source_WMTS__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(159);
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_extent__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(147);
// import OpenLayers

 // import geoportal library access

 // import local


/**
 * @classdesc
 *
 * Extended ol.source.WMTS.
 *
 * @constructor
 * @alias ol.source.WMTSExtended
 * @extends {ol.source.WMTS}
 * @param {Object} options - Options
 */

var WMTS = function (WMTSSource) {
  function WMTS(options) {
    if (!(this instanceof WMTS)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // call constructor


    WMTSSource.call(this, options);
  } // Inherits


  if (WMTSSource) WMTS.__proto__ = WMTSSource;
  /*
   * @lends module:WMTS
   */

  WMTS.prototype = Object.create(WMTSSource.prototype, {});
  /**
   * Constructor (alias)
   */

  WMTS.prototype.constructor = WMTS;
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {ol.Coordinate} coordinate - Coordinate.
   * @param {Number} resolution - Resolution.
   * @param {ol.proj.Projection} projection - Projection.
   * @param {!Object} params - GetFeatureInfo params. `INFOFORMAT` at least should
   *     be provided.
   * @return {String|undefined} GetFeatureInfo URL.
   */

  WMTS.prototype.getFeatureInfoUrl = function (coordinate, resolution, projection, params) {
    // INFO
    // en fonction de la version d'openlayers, la méthode est differente :
    // - getGetFeatureInfoUrl en v5
    // - getFeatureInfoUrl en v6
    var pixelRatio = this.options && this.options.tilePixelRatio ? this.options.tilePixelRatio : 1;
    var tileGrid = this.tileGrid;
    var tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution); // this code is duplicated from createFromWMTSTemplate function

    var getTransformedTileCoord = function getTransformedTileCoord(tileCoord, tileGrid, projection) {
      var tmpTileCoord = [0, 0, 0];
      /* Note : [z(zoomLevel),x,y] */

      var tmpExtent = Object(ol_extent__WEBPACK_IMPORTED_MODULE_1__["createEmpty"])();
      var x = tileCoord[1];
      var y = tileCoord[2];
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
      var extent = projection.getExtent();

      if (extent != null && projection.isGlobal()) {
        var numCols = Math.ceil(Object(ol_extent__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(extent) / Object(ol_extent__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(tileExtent));
        x = x % numCols;
        tmpTileCoord[0] = tileCoord[0];
        tmpTileCoord[1] = x;
        tmpTileCoord[2] = tileCoord[2];
        tileExtent = tileGrid.getTileCoordExtent(tmpTileCoord, tmpExtent);
      }

      if (!Object(ol_extent__WEBPACK_IMPORTED_MODULE_1__["intersects"])(tileExtent, extent)
      /* || ol.extent.touches(tileExtent, extent) */
      ) {
        return null;
      }

      return [tileCoord[0], x, y];
    };

    var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
    var transformedTileCoord = getTransformedTileCoord(tileCoord, tileGrid, projection);

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileMatrix = tileGrid.getMatrixIds()[tileCoord[0]];
    var baseParams = {
      SERVICE: "WMTS",
      VERSION: "1.0.0",
      REQUEST: "GetFeatureInfo",
      LAYER: this.getLayer(),
      TILECOL: transformedTileCoord[1],
      TILEROW: transformedTileCoord[2],
      TILEMATRIX: tileMatrix,
      TILEMATRIXSET: this.getMatrixSet(),
      FORMAT: this.getFormat() || "image/png",
      STYLE: this.getStyle() || "normal"
    };
    _Common_Utils__WEBPACK_IMPORTED_MODULE_3__["default"].assign(baseParams, params);
    /* var tileSize = tileGrid.getTileSize();
    var x = Math.floor(tileSize*((coordinate[0]-tileExtent[0])/(tileExtent[2]-tileExtent[0])));
    var y = Math.floor(tileSize*((tileExtent[3]-coordinate[1])/(tileExtent[3]-tileExtent[1]))); */

    var x = Math.floor((coordinate[0] - tileExtent[0]) / (tileResolution / pixelRatio));
    var y = Math.floor((tileExtent[3] - coordinate[1]) / (tileResolution / pixelRatio));
    /* patch parce que la fonction getTileCoordForCoordAndResolution(coords,res) d'Openlayers peut renvoyer
    une tuile dont l'étendue (getTileCoordExtent) ne contient pas le point passé en paramètre (coords) */

    var tileSize = tileGrid.getTileSize(tileCoord[0]);
    x = Math.min(x, (tileSize[0] | tileSize) - 1);
    y = Math.max(y, 0);
    baseParams["I"] = x;
    baseParams["J"] = y;
    var url = this.urls[0];
    var featureInfoUrl = geoportal_access_lib__WEBPACK_IMPORTED_MODULE_2__["default"].Helper.normalyzeUrl(url, baseParams);
    return featureInfoUrl;
  };

  return WMTS;
}(ol_source_WMTS__WEBPACK_IMPORTED_MODULE_0___default.a);

/* harmony default export */ __webpack_exports__["default"] = (WMTS); // Expose WMTS as ol.source.WMTSExtended. (for a build bundle)

if (window.ol && window.ol.source) {
  window.ol.source.WMTSExtended = WMTS;
}

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = ol.extent;

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(161);
/* harmony import */ var ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Sources_WMTS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(158);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);
/* harmony import */ var _Common_Utils_LayerUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(163);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(141);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3);
var _package_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(3, 1);
 // import OpenLayers

 // import local with ol dependencies

 // import local




 // package.json (extract version)


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__["default"].getLogger("sourcewmts");
/**
 * @classdesc
 * Geoportal WMTS source creation (inherit from ol.source.WMTS)
 *
 * @constructor
 * @alias ol.source.GeoportalWMTS
 * @extends {WMTSExtended}
 * @param {Object} options            - options for function call.
 * @param {String} options.layer      - Layer name (e.g. "ORTHOIMAGERY.ORTHOPHOTOS")
 * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
 * @param {String} [options.apiKey]   - Access key to Geoportal platform
 * @param {Object} [options.olParams] - other options for ol.source.WMTS function (see {@link http://openlayers.org/en/latest/apidoc/ol.source.WMTS.html ol.source.WMTS})
 * @example
 * var sourceWMTS = new ol.source.GeoportalWMTS({
 *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
 * });
 */

var SourceWMTS = function (WMTSExtended) {
  function SourceWMTS(options) {
    if (!(this instanceof SourceWMTS)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // check layer params


    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }

    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    } // par defaut


    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    } // Check if configuration is loaded


    if (!_Common_Utils_Config__WEBPACK_IMPORTED_MODULE_4__["default"].isConfigLoaded()) {
      throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html");
    }

    var layerId = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_4__["default"].getLayerId(options.layer, "WMTS");

    if (layerId && _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_4__["default"].configuration.getLayerConf(layerId)) {
      var wmtsParams = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_4__["default"].getLayerParams(options.layer, "WMTS", options.apiKey); // si ssl = false on fait du http
      // par défaut, ssl = true, on fait du https

      var protocol = options.ssl === false ? "http://" : "https://"; // save originators (to be updated by Originators control)

      this._originators = wmtsParams.originators; // save legends and metadata (to be added to LayerSwitcher control)

      this._legends = wmtsParams.legends;
      this._metadata = wmtsParams.metadata;
      var wmtsSourceOptions = {
        // tracker extension openlayers
        // FIXME : gp-ext version en mode AMD
        url: geoportal_access_lib__WEBPACK_IMPORTED_MODULE_0__["default"].Helper.normalyzeUrl(wmtsParams.url.replace(/(http|https):\/\//, protocol), {
          "gp-ol-ext": _package_json__WEBPACK_IMPORTED_MODULE_7__.olExtVersion || _package_json__WEBPACK_IMPORTED_MODULE_7__.version
        }, false),
        version: wmtsParams.version,
        style: wmtsParams.styles,
        format: wmtsParams.format,
        projection: wmtsParams.projection,
        maxZoom: _Common_Utils_LayerUtils__WEBPACK_IMPORTED_MODULE_5__["default"].getZoomLevelFromScaleDenominator(wmtsParams.minScale),
        layer: options.layer,
        matrixSet: wmtsParams.TMSLink,
        tileGrid: new ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_1___default.a({
          resolutions: wmtsParams.nativeResolutions,
          matrixIds: wmtsParams.matrixIds,
          origin: [wmtsParams.matrixOrigin.x, wmtsParams.matrixOrigin.y]
        }) // ,
        // attributions : [
        //     new ol.Attribution({
        //         html : "<a class='gp-control-attribution-link' target='_blank' href='http://www.ign.fr'><img class='gp-control-attribution-image' src='http://wxs.ign.fr/static/logos/IGN/IGN.gif' title='Institut national de l\'information géographique et forestière' style='height: 30px; width: 30px;'></a>"
        //     })
        // ]

      }; // récupération des autres paramètres passés par l'utilisateur

      _Common_Utils__WEBPACK_IMPORTED_MODULE_3__["default"].mergeParams(wmtsSourceOptions, options.olParams); // returns a WMTS object, that inherits from WMTSExtended.

      WMTSExtended.call(this, wmtsSourceOptions); // add originators to layer source (to be updated by Originators control)

      this._originators = wmtsParams.originators; // add legends and metadata (to be added to LayerSwitcher control)

      this._legends = wmtsParams.legends;
      this._metadata = wmtsParams.metadata;
      this._description = wmtsParams.description;
      this._title = wmtsParams.title;
      this._quicklookUrl = wmtsParams.quicklookUrl;
    } else {
      // If layer is not in Gp.Config
      logger.log("[source WMTS] ERROR : " + options.layer + " cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.");
      return new WMTSExtended({});
    }
  } // Inherits from ol.source.WMTS


  if (WMTSExtended) SourceWMTS.__proto__ = WMTSExtended;
  /*
   * @lends module:SourceWMTS
   */

  SourceWMTS.prototype = Object.create(WMTSExtended.prototype, {});
  /*
   * Constructor (alias)
   */

  SourceWMTS.prototype.constructor = SourceWMTS;
  return SourceWMTS;
}(_Sources_WMTS__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (SourceWMTS); // Expose SourceWMTS as ol.source.GeoportalWMTS. (for a build bundle)

if (window.ol && window.ol.source) {
  window.ol.source.GeoportalWMTS = SourceWMTS;
}

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = ol.tilegrid.WMTS;

/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("config");
var Config = {
  /** autoconf */
  configuration: null,

  /**
   * Controle du chargement de l'autoconf
   *
   * @returns {Boolean} isConfigLoaded - True si l'autoconf a déjà été chargée, False sinon.
   */
  isConfigLoaded: function isConfigLoaded() {
    var scope = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};

    if (scope.Gp && scope.Gp.Config && Object.keys(scope.Gp.Config).length !== 0) {
      this.configuration = scope.Gp.Config;
      return true;
    }

    return false;
  },

  /**
   * Recuperation de l'identifiant d'une couche donnée
   *
   * @param {String} layerName - nom de la couche (par ex. "ORTHOIMAGERY.ORTHOPHOTOS")
   * @param {String} service   - nom du service (par ex. "WMS" ou "WMTS")
   * @returns {String} layerId - identifiant de la couche (par ex. "ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS")
   */
  getLayerId: function getLayerId(layerName, service) {
    var layerId = null; // layer
    // key : [layerName]$[contexte]:OGC:[service]
    // ex : "ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS"
    // service
    // key : [layerName]$[contexte];[service]
    // ex : PositionOfInterest$OGC:OPENLS;ReverseGeocode

    if (this.configuration) {
      var layers = this.configuration["layers"];

      for (var key in layers) {
        if (layers.hasOwnProperty(key)) {
          var parts = key.split("$");

          if (layerName === parts[0]) {
            if (parts[1]) {
              var servicePartsLayer = parts[1].split(":");
              var servicePartsService = parts[1].split(";");

              if (servicePartsService[1] === service) {
                layerId = key;
                break;
              }

              if (servicePartsLayer[2] === service) {
                layerId = key;
                break;
              }
            }
          }
        }
      }
    }

    if (!layerId) {
      logger.error("ERROR layer id (layer name: " + layerName + " / service: " + service + ") was not found !?");
    }

    return layerId;
  },

  /**
   * Récupération des paramètres nécessaires à l'affichage d'une couche WMS ou WMTS
   *
   * @param {String} layerName - nom de la couche (par ex. "ORTHOIMAGERY.ORTHOPHOTOS")
   * @param {String} service   - nom du service (par ex. "WMS" ou "WMTS")
   * @param {String} [apiKey]  - Clé de contrat API
   * @returns {Object} params  - paramètres du service (WMS ou WMTS) pour la couche donnée
   * @returns {String} params.url        - Url du service à requêter pour afficher la couche
   * @returns {String} params.version    - Version du service
   * @returns {String} params.styles     - Style par défaut de la couche
   * @returns {String} params.format     - Format par défaut de la couche
   * @returns {String} params.projection - Projection par défaut de la couche
   * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche
   * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche
   * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche
   * @returns {Array} params.legends     - Tableau des légendes associées à la couche
   * @returns {Array} params.metadata    - Tableau des métadonnées associées à la couche
   * @returns {Array} params.originators - Tableau des originators associés à la couche
   * @returns {Array} params.title       - Nom de la resource, lisible par un humain.
   * @returns {Array} params.description - Url de l'image d'aperçu rapide de la ressource.
   * @returns {Array} params.quicklookUrl- Tableau des originators associés à la couche
   * @returns {String} params.[TMSLink]          - Identifiant de la pyramide (TMS), dans le cas d'une couche WMTS
   * @returns {Gp.Point} params.[matrixOrigin]   - Origine de la matrice (top left corner), dans le cas d'une couche WMTS
   * @returns {Array} params.[nativeResolutions] - Tableau regroupant les résolutions de chaque niveau de la matrice, dans le cas d'une couche WMTS
   * @returns {Array} params.[matrixIds]         - Tableau regroupant les identifiants de chaque niveau de la matrice, dans le cas d'une couche WMTS
   */
  getLayerParams: function getLayerParams(layerName, service, apiKey) {
    var params = {};

    if (this.configuration) {
      // récupération de l'identifiant complet de la couche.
      var layerId = this.getLayerId(layerName, service);

      if (layerId) {
        // récupération de l'objet de configuration de la couche
        var layerConf = this.configuration.layers[layerId]; // controle de la clef

        var key = layerConf.apiKeys[0];

        if (apiKey) {
          if (apiKey !== key) {
            logger.error("ERROR different keys (" + apiKey + " !== " + key + ") !?");
            return;
          }
        }

        apiKey = apiKey || key;
        params.key = apiKey; // récupération des paramètres du service

        params.url = layerConf.getServerUrl(apiKey);
        params.version = layerConf.getServiceParams().version;
        params.styles = layerConf.getDefaultStyle();
        params.format = layerConf.getDefaultFormat();
        params.projection = layerConf.getDefaultProjection(); // récupération des infos de la couche

        params.minScale = layerConf.getMinScaleDenominator();
        params.maxScale = layerConf.getMaxScaleDenominator();
        params.extent = layerConf.getBBOX();
        params.legends = layerConf.getLegends();
        params.metadata = layerConf.getMetadata();
        params.originators = layerConf.getOriginators();
        params.title = layerConf.getTitle();
        params.description = layerConf.getDescription();
        params.quicklookUrl = layerConf.getQuicklookUrl(); // WMTS : récupération des tileMatrixSetLimits

        if (layerConf.wmtsOptions) {
          params.tileMatrixSetLimits = layerConf.wmtsOptions.tileMatrixSetLimits;
        } // WMTS : récupération des paramètres de la pyramide (TMS)


        var TMSLink = layerConf.getTMSID();

        if (TMSLink) {
          params.TMSLink = TMSLink;
          var tmsConf = this.configuration.getTMSConf(TMSLink); // Get matrix origin : Gp.Point = Object{x:Float, y:Float}

          params.matrixOrigin = tmsConf.getTopLeftCorner();
          params.nativeResolutions = tmsConf.nativeResolutions;
          params.matrixIds = tmsConf.matrixIds;
          params.tileMatrices = tmsConf.tileMatrices;
        }
      }
    }

    return params;
  },

  /**
   * Recuperation des parametres d'un service
   *
   * @param {String} [resource] - "PositionOfInterest", "StreetAddress", "Voiture", "Pieton", ...
   * @param {String} [service] - Geocode, Itineraire, ...
   * @param {Array} [apiKeys]  - Clé(s) de contrat API
   * @returns {Object} params - paramètres de la ressource
   * @returns {String} params. -
   * @returns {String} params. -
   * @returns {String} params. -
   */
  getServiceParams: function getServiceParams(resource, service, apiKeys) {
    var params = {};

    if (this.configuration) {
      // récupération de l'identifiant complet de la couche.
      var layerId = this.getLayerId(resource, service);

      if (layerId) {
        // récupération de l'objet de configuration de la couche
        var layerConf = this.configuration.layers[layerId]; // controle de la clef (on prend la première clé disponible qui est censée avoir accès à la ressource)

        var key = layerConf.apiKeys[0];

        if (apiKeys) {
          if (!Array.isArray(apiKeys)) {
            apiKeys = [apiKeys];
          }

          for (var i = 0; i < apiKeys.length; i++) {
            if (apiKeys[i] === key) {
              var keyIndex = i;
              break;
            }
          } // si aucune clé du tableau apiKeys ne correspond, on retourne rien => pas de droits pour la ressource


          if (typeof keyIndex === "undefined") {
            return;
          }
        } // on retourne la première clé qui a effectivement accès à la ressource


        var apiKey = apiKeys[keyIndex] || key;
        params.key = apiKey; // récupération des paramètres du service

        params.url = layerConf.getServerUrl(apiKey);
        params.version = layerConf.getServiceParams().version; // récupération des infos de la couche

        params.extent = layerConf.getBBOX();
        params.title = layerConf.getTitle();
        params.description = layerConf.getDescription();
      }
    }

    return params;
  },

  /**
   * Resolution en geographique
   *
   * @returns {Array} resolutions
   */
  getResolutions: function getResolutions() {
    var resolutions = [];

    if (this.configuration) {
      resolutions = this.configuration["generalOptions"]["wgs84Resolutions"];
    }

    return resolutions;
  },

  /**
   * Recuperation des parametres TMS de la configuration
   * @param {String} tmsName - tile matrix set name
   *
   * @returns {Object} tile matrix set
   */
  getTileMatrix: function getTileMatrix(tmsName) {
    var tms = {};

    if (this.configuration) {
      if (tmsName) {
        tms = this.configuration["tileMatrixSets"][tmsName.toUpperCase()];
      }
    }

    return tms;
  },

  /**
   * Récupération des contraintes générales d'une couche donnée : extent, minScale, maxScale, projection
   *
   * @param {String} layerId - identifiant de la couche
   * @returns {Object} params - contraintes de la couche
   * @returns {String} params.projection - Projection par défaut de la couche
   * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche
   * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche
   * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche
   */
  getGlobalConstraints: function getGlobalConstraints(layerId) {
    var params = {};

    if (layerId) {
      // récupération de l'objet de configuration de la couche
      var layerConf = this.configuration.layers[layerId];
      params.projection = layerConf.getDefaultProjection();
      params.minScale = layerConf.getMinScaleDenominator();
      params.maxScale = layerConf.getMaxScaleDenominator();
      params.extent = layerConf.getBBOX();
    }

    return params;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Config);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(62)))

/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
* @module LayerUtils
* @alias Gp.LayerUtils
* @description
* ...
*
* @example
* getZoomLevelFromScaleDenominator();
* getAttributions();
* intersects();
*/
var LayerUtils = {
  /**
   * Obtenir le ZoomLevel à partir du ScaleDenominator
   * @param {Number} scaleDenominator - the scale denominator
   * @param {String} crs - the crs
   *
   * @returns {Integer} zoom level
   */
  getZoomLevelFromScaleDenominator: function getZoomLevelFromScaleDenominator(scaleDenominator, crs) {
    // ------------------------------------------------- //
    // Code issu de l'API Geoportal/Catalogue/Config.js  //
    // ------------------------------------------------- //
    //     var configuration = Gp.Config;
    //     var general = configuration.generalOptions;
    //     var layers  = configuration.layersContext;
    //
    //     for (var tms in general.tileMatrixSets) {
    //         var tileMatrixSet = general.tileMatrixSets[tms];
    //         // IGN's WMTS bug : epsg:nnnn instead of EPSG:nnnn
    //         var crs = tileMatrixSet.supportedCRS = tileMatrixSet.supportedCRS.replace(/epsg/,"EPSG");
    //
    //         if (!Geoportal.Catalogue.CRSRESOLUTIONS.hasOwnProperty(crs)) {
    //             var p= new OpenLayers.Projection(crs);
    //             Geoportal.Catalogue.CRSRESOLUTIONS[crs]= [];
    //             var matrixIds= tileMatrixSet.matrixIds;
    //             for (var i= 0, li= matrixIds.length; i<li; ++i) {
    //                 var mid= matrixIds[i];
    //                 Geoportal.Catalogue.CRSRESOLUTIONS[crs].push(
    //                     0.00028*mid.scaleDenominator
    //                     /(OpenLayers.METERS_PER_INCH*OpenLayers.INCHES_PER_UNIT[p.getUnits()]));
    //                     mid.supportedCRS= mid.supportedCRS.replace(/epsg/,"EPSG");
    //                 }
    //                 Geoportal.Catalogue.CRSRESOLUTIONS[crs].sort(function (a,b){ return b-a; });
    //             }
    //         }
    //         var llR= Geoportal.Catalogue.CRSRESOLUTIONS['CRS:84'];
    //         if (!llR) {
    //             llR= Geoportal.Catalogue.CRSRESOLUTIONS['CRS:84']= general.resolutions.slice();
    //         }
    //         var wmR= Geoportal.Catalogue.CRSRESOLUTIONS['EPSG:3857'];
    //         if (!wmR) {//FIXME : should never happened !!
    //             // reproject resolutions from CRS84 to WebMercator (transform resolutions from degree/px to meter/px)
    //             wmR= Geoportal.Catalogue.CRSRESOLUTIONS['EPSG:3857']= new Array(llR.length);
    //             for (var i= 0, len= llR.length; i<len; i++) {
    //                 var pt= new OpenLayers.LonLat(llR[i], 0);
    //                 pt.transform(OpenLayers.Projection.CRS84, OpenLayers.Projection.WebMercator);
    //                 wmR[i]= pt.lon;
    //             }
    //         }
    //         Geoportal.Catalogue.RESOLUTIONS= wmR;
    //
    //         var getResolutionsFromCRS= function(crs) {
    //             if (OpenLayers.Projection.WebMercator.isAliasOf(crs)) {
    //                 return wmR;
    //             }
    //             if (OpenLayers.Projection.CRS84.isAliasOf(crs)) {
    //                 return llR;
    //             }
    //             return Geoportal.Catalogue.CRSRESOLUTIONS[crs]?Geoportal.Catalogue.CRSRESOLUTIONS[crs]:null ;
    //         };
    //
    //         var retrieveZoomFromResolution= function(resolutions, resolution) {
    //             for (var i= 0, li= resolutions.length; i<li; i++) {
    //                 if (resolutions[i]-resolution <= resolutions[li-1]) {
    //                     return i;
    //                 }
    //             }
    //             return -1;
    //         };
    //
    //         var getZoomLevelFromScaleDenominator= function(scaleDenominator,crs) {
    //             var resolution= scaleDenominator * 0.00028;
    //             var R= getResolutionsFromCRS(crs);
    //             if (R) {
    //                 return retrieveZoomFromResolution(R,resolution);
    //             }
    //             resolution= resolution/(OpenLayers.METERS_PER_INCH * OpenLayers.INCHES_PER_UNIT["degrees"]);
    //             return retrieveZoomFromResolution(llR,resolution);
    //         };
    //
    //         var getZoomLevelFromResolution= function(resolution,crs){
    //             var R= getResolutionsFromCRS(crs);
    //             if (R) {
    //                 return retrieveZoomFromResolution(R,resolution);
    //             }
    //             var pt0= new OpenLayers.LonLat(0, 0);
    //             var pt1= new OpenLayers.LonLat(1, 0);
    //             pt0.transform(new OpenLayers.Projection(crs),OpenLayers.Projection.CRS84);
    //             pt1.transform(new OpenLayers.Projection(crs),OpenLayers.Projection.CRS84);
    //             resolution= resolution*(Math.abs(pt1.lon-pt0.lon));
    //             return retrieveZoomFromResolution(llR,resolution);
    //         };
    // par defaut, on utilise la projection WebMercator (EPSG:3857 = PM)
    // soit la liste des resolutions natives
    var resolutionsNatives = {};

    switch (crs) {
      case "EPSG:2154":
        resolutionsNatives = {
          0: 104579.224549894,
          1: 52277.5323537905,
          2: 26135.4870785954,
          3: 13066.8913818,
          4: 6533.2286041135,
          5: 3266.5595244627,
          6: 1633.2660045974,
          7: 816.629554986,
          8: 408.3139146768,
          9: 204.1567415109,
          10: 102.0783167832,
          11: 51.0391448966,
          12: 25.5195690743,
          13: 12.7597836936,
          14: 6.379891636,
          15: 3.1899457653,
          16: 1.5949728695,
          17: 0.7974864315,
          18: 0.3987432149,
          19: 0.1993716073,
          20: 0.0996858037,
          21: 0.0498429018
        };
        break;

      default:
        resolutionsNatives = {
          0: 156543.033928041,
          1: 78271.51696402048,
          2: 39135.758482010235,
          3: 19567.87924100512,
          4: 9783.93962050256,
          5: 4891.96981025128,
          6: 2445.98490512564,
          7: 1222.99245256282,
          8: 611.49622628141,
          9: 305.7481131407048,
          10: 152.8740565703525,
          11: 76.43702828517624,
          12: 38.21851414258813,
          13: 19.10925707129406,
          14: 9.554628535647032,
          15: 4.777314267823516,
          16: 2.388657133911758,
          17: 1.194328566955879,
          18: 0.5971642834779395,
          19: 0.2985821417389697,
          20: 0.1492910708694849,
          21: 0.0746455354347424
        };
        break;
    } // gestion des autres SRS
    // TODO
    // if (crs) {
    // }


    var resolution = scaleDenominator * 0.00028;

    for (var index in resolutionsNatives) {
      if (resolutionsNatives.hasOwnProperty(index)) {
        if (resolutionsNatives[index] <= resolution) {
          index = parseInt(index, 10);
          return index;
        }
      }
    }

    return 0; // -1 ?
  },

  /**
   * Get attributions list for a layer, based on current zoom and extent
   *
   * @param {Object} params - function params
   * @param {Array.<Float>} params.extent - map current geographical extent (EPSG:4326) : [top, left, bottom, right] = [maxy, minx, miny, maxx]
   * @param {Number} params.zoom - map current zoom
   * @param {String} params.crs - map current projection code (ex "EPSG:2154")
   * @param {Boolean} params.visibility - layer visibility
   * @param {Gp.Services.Config.Originator} params.originators - resource originators (from Gp.Config.layers[].originators)
   * @returns {Object} attributions - associative array, mapping originators url (keys) with their properties : html attributions elements
   */
  getAttributions: function getAttributions(params) {
    var zoom = params.zoom;
    var attributions = [];

    if (params.originators != null && params.visibility) {
      // drawLogo = boolean, true if attribution should be displayed (zoom, extent), false otherwise
      var drawLogo;

      for (var j = 0, jl = params.originators.length; j < jl; j++) {
        drawLogo = true;
        var originator = params.originators[j];
        var constraints = params.originators[j].constraints || [];

        for (var k = 0, kl = constraints.length; k < kl; k++) {
          var constraint = constraints[k];
          drawLogo = true;
          var minZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.maxScaleDenominator, params.crs);
          var maxZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.minScaleDenominator, params.crs) || 21; // min zoom constraints

          if (minZoomLevel && minZoomLevel > zoom) {
            drawLogo = false;
          } // max zoom constraints


          if (drawLogo && maxZoomLevel && maxZoomLevel < zoom) {
            drawLogo = false;
          } // bbox constraints


          var bbox = constraint.bbox;

          if (drawLogo && bbox) {
            drawLogo = false;
            var viewExtent = params.extent;

            if (viewExtent) {
              var bounds = [bbox.top, bbox.left, bbox.bottom, bbox.right];

              if (this.intersects(viewExtent, bounds)) {
                // at least one constraint matches the map ones
                drawLogo = true;
                break;
              }
            }
          }
        }

        if (drawLogo) {
          // on a un originator qui correspond au zoom et à l'étendue.
          var logo = originator.logo;
          var url = originator.url;
          var name = originator.name ? originator.name : "";
          var text = originator.attribution;
          var container = document.createElement("div");
          container.className = "gp-control-attribution"; // on crée un lien dans tous les cas (même s'il ne pointe pas vers une référence), pour avoir accès à la class CSS (pour surcharge)

          var link = null;
          link = document.createElement("a");
          link.className = "gp-control-attribution-link";
          link.target = "_blank";
          container.appendChild(link);

          if (url) {
            link.href = url;
          }

          var bImage = !!logo;
          var image = null; // si on a un logo, on l'affiche à l'interieur du lien

          if (bImage) {
            image = document.createElement("img");

            if (link) {
              image.className = "gp-control-attribution-image";
              link.appendChild(image);
            } else {
              image.className = "";
              container.appendChild(image);
            }

            image.src = logo; // FIXME : mixContent !

            image.title = text || name;
            image.style.height = "30px";
            image.style.width = "30px";
          } else {
            // sinon, on affiche le nom de l'originator, ou sa description ou l'url.
            if (name) {
              link.textContent = name;
            } else if (text) {
              link.textContent = text;
            } else if (url) {
              link.textContent = url;
            } else {
              link.textContent = "";
            }
          }

          attributions.push(container.innerHTML + " ");
        }
      }
    }

    return attributions;
  },

  /**
   * Determines if one extent (extent1) intersects another (extent2)
   *
   * @param {Array.<Float>} extent1 - First extent : [top, left, bottom, right] = [maxy, minx, miny, maxx]
   * @param {Array.<Float>} extent2 - Second extent : [top, left, bottom, right] = [maxy, minx, miny, maxx]
   * @return {Boolean} intersects - True if the two extents intersect, false otherwise.
   */
  intersects: function intersects(extent1, extent2) {
    var intersectsX = extent1[1] <= extent2[3] && extent2[1] <= extent1[3];
    var intersectsY = extent1[2] <= extent2[0] && extent2[2] <= extent1[0];
    return intersectsX && intersectsY;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (LayerUtils);

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
var _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(3, 1);
 // import OpenLayers

 // import local



 // package.json (extract version)


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("sourcewms");
/**
 * @classdesc
 * Geoportal tile WMS source creation (inherit from ol.source.TileWMS)
 *
 * @constructor
 * @alias ol.source.GeoportalWMS
 * @extends {ol.source.TileWMS}
 * @param {Object} options            - options for function call.
 * @param {String} options.layer      - Layer name (e.g. "ORTHOIMAGERY.ORTHOPHOTOS")
 * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
 * @param {String} [options.apiKey]   - Access key to Geoportal platform
 * @param {Object} [options.olParams] - other options for ol.source.TileWMS function (see {@link http://openlayers.org/en/latest/apidoc/ol.source.TileWMS.html ol.source.TileWMS})
 * @example
 * var sourceWMS = new ol.source.GeoportalWMS({
 *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
 * });
 */

var SourceWMS = function (TileWMSSource) {
  function SourceWMS(options) {
    if (!(this instanceof SourceWMS)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // check layer params


    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }

    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    } // par defaut


    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    } // Check if configuration is loaded


    if (!_Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].isConfigLoaded()) {
      throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html");
    }

    var layerId = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].getLayerId(options.layer, "WMS");

    if (layerId && _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].configuration.getLayerConf(layerId)) {
      var wmsParams = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].getLayerParams(options.layer, "WMS", options.apiKey); // si ssl = false on fait du http
      // par défaut, ssl = true, on fait du https

      var protocol = options.ssl === false ? "http://" : "https://";
      var wmsSourceOptions = {
        // tracker extension openlayers
        // FIXME : gp-ext version en mode AMD
        url: geoportal_access_lib__WEBPACK_IMPORTED_MODULE_0__["default"].Helper.normalyzeUrl(wmsParams.url.replace(/(http|https):\/\//, protocol), {
          "gp-ol-ext": _package_json__WEBPACK_IMPORTED_MODULE_5__.olExtVersion || _package_json__WEBPACK_IMPORTED_MODULE_5__.version
        }, false),
        params: {
          SERVICE: "WMS",
          LAYERS: options.layer,
          VERSION: wmsParams.version,
          STYLES: wmsParams.styles,
          FORMAT: wmsParams.format
        } // ,
        // attributions : [
        //     new ol.Attribution({
        //         html : "<a class='gp-control-attribution-link' target='_blank' href='http://www.ign.fr'><img class='gp-control-attribution-image' src='http://wxs.ign.fr/static/logos/IGN/IGN.gif' title='Institut national de l\'information géographique et forestière' style='height: 30px; width: 30px;'></a>"
        //     })
        // ]

      }; // récupération des autres paramètres passés par l'utilisateur

      _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(wmsSourceOptions, options.olParams); // returns a WMS object, that inherits from ol.source.TileWMS.

      TileWMSSource.call(this, wmsSourceOptions); // save originators (to be updated by Originators control)

      this._originators = wmsParams.originators; // save legends and metadata (to be added to LayerSwitcher control)

      this._legends = wmsParams.legends;
      this._metadata = wmsParams.metadata;
      this._title = wmsParams.title;
      this._description = wmsParams.description;
      this._quicklookUrl = wmsParams.quicklookUrl;
    } else {
      // If layer is not in Gp.Config
      logger.log("[source WMS] ERROR : " + options.layer + " cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.");
      return new TileWMSSource({});
    }
  } // Inherits from ol.source.TileWMS


  if (TileWMSSource) SourceWMS.__proto__ = TileWMSSource;
  /*
   * @lends module:SourceWMS
   */

  SourceWMS.prototype = Object.create(TileWMSSource.prototype, {});
  /*
   * Constructor (alias)
   */

  SourceWMS.prototype.constructor = SourceWMS;
  return SourceWMS;
}(ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (SourceWMS); // Expose SourceWMS as ol.source.GeoportalWMTS. (for a build bundle)

if (window.ol && window.ol.source) {
  window.ol.source.GeoportalWMS = SourceWMS;
}

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(167);
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _SourceWMTS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(160);
// import openlayers

 // import local


 // import local with ol dependencies


/**
 * @classdesc
 * Geoportal LayerWMTS source creation (inherit from ol.layer.Tile)
 *
 * @constructor
 * @extends {ol.layer.Tile}
 * @alias ol.layer.GeoportalWMTS
 * @param {Object} options            - options for function call.
 * @param {String} options.layer      - Layer name (e.g. "ORTHOIMAGERY.ORTHOPHOTOS")
 * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
 * @param {String} [options.apiKey]   - Access key to Geoportal platform
 * @param {Object} [options.olParams] - other options for ol.layer.Tile function (see {@link http://openlayers.org/en/latest/apidoc/ol.layer.Tile.html ol.layer.Tile})
 * @param {Object} [options.olParams.sourceParams] - other options for ol.source.WMTS function (see {@link http://openlayers.org/en/latest/apidoc/ol.source.WMTS.html ol.source.WMTS})
 * @example
 * var layerWMTS = new ol.layer.GeoportalWMTS({
 *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
 * });
 */

var LayerWMTS = function (TileLayer) {
  function LayerWMTS(options) {
    if (!(this instanceof LayerWMTS)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }

    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    } // par defaut


    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    } // Check if configuration is loaded


    if (!_Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].isConfigLoaded()) {
      throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html");
    } // création de la source WMTS


    var olSourceParams;

    if (options.olParams && options.olParams.sourceParams) {
      olSourceParams = options.olParams.sourceParams;
    }

    var wmtsSource = new _SourceWMTS__WEBPACK_IMPORTED_MODULE_4__["default"]({
      layer: options.layer,
      ssl: options.ssl,
      apiKey: options.apiKey,
      olParams: olSourceParams
    });
    var layerTileOptions = {
      source: wmtsSource
    }; // si le param layer n'a pas été renseigné lors de la création de la source,
    // c'est que l'identifiant de la couche n'a pas été trouvé. on passe donc la recherche des paramètres.

    if (wmtsSource.getLayer() !== undefined) {
      // récupération des autres paramètres nécessaires à la création de la layer
      var layerId = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].getLayerId(options.layer, "WMTS");
      var globalConstraints = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].getGlobalConstraints(layerId);

      if (globalConstraints && globalConstraints.projection) {
        /* INFO : désactivation temporaire de l'étendue, car certaines étendues (trop grandes ?)
        provoquent quelques bugs d'affichage (zoom > 16 par exemple) */
        // récupération de l'étendue (en EPSG:4326), et reprojection dans la proj de la couche
        // var geobbox = [
        //     globalConstraints.extent.left,
        //     globalConstraints.extent.bottom,
        //     globalConstraints.extent.right,
        //     globalConstraints.extent.top
        // ];
        // layerTileOptions.extent = ol.proj.transformExtent(geobbox, "EPSG:4326", globalConstraints.projection);
        // récupération des résolutions min et max
        var p; // on récupère tout d'abord la projection

        if (typeof globalConstraints.projection === "string") {
          p = Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["get"])(globalConstraints.projection);
        } // puis, selon l'unité de la projection, on calcule la résolution correspondante


        if (p && p.getUnits()) {
          if (p.getUnits() === "m") {
            /* fixme : fix temporaire pour gérer les min/max scaledenominator qui sont arrondis dans l'autoconf !
             * on les arrondit respectivement à l'unité inférieure et supérieure
             * pour que les couches soient bien disponibles aux niveaux de zoom correspondants */
            // info : 1 pixel = 0.00028 m
            layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028;
            layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028;
          } else if (p.getUnits() === "degrees") {
            /* fixme : fix temporaire pour gérer les min/max scaledenominator qui sont arrondis dans l'autoconf !
             * on les arrondit respectivement à l'unité inférieure et supérieure
             * pour que les couches soient bien disponibles aux niveaux de zoom correspondants */
            // info : 6378137 * 2 * pi / 360 = rayon de la terre (ellipsoide WGS84)
            layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028 * 180 / (Math.PI * 6378137);
            layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028 * 180 / (Math.PI * 6378137);
          }
        }
      }
    } // récupération des autres paramètres passés par l'utilisateur


    _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(layerTileOptions, options.olParams); // création d'une ol.layer.Tile avec les options récupérées ci-dessus.

    TileLayer.call(this, layerTileOptions);
  } // Inherits from ol.layer.Tile


  if (TileLayer) LayerWMTS.__proto__ = TileLayer;
  /*
   * @lends module:LayerWMTS
   */

  LayerWMTS.prototype = Object.create(TileLayer.prototype, {});
  /*
   * Constructor (alias)
   */

  LayerWMTS.prototype.constructor = LayerWMTS;
  return LayerWMTS;
}(ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (LayerWMTS); // Expose LayerWMTS as ol.layerGeoportalWMTS. (for a build bundle)

if (window.ol && window.ol.layer) {
  window.ol.layer.GeoportalWMTS = LayerWMTS;
}

/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = ol.proj;

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = ol.layer.Tile;

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(167);
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _SourceWMS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(164);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import openlayers

 // import local


 // import local with ol dependencies


/**
 * @classdesc
 * Geoportal LayerWMS source creation (inherit from ol.layer.Tile)
 *
 * @constructor
 * @extends {ol.layer.Tile}
 * @alias ol.layer.GeoportalWMS
 * @param {Object} options            - options for function call.
 * @param {String} options.layer      - Layer name (e.g. "ORTHOIMAGERY.ORTHOPHOTOS")
 * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
 * @param {String} [options.apiKey]   - Access key to Geoportal platform
 * @param {Object} [options.olParams] - other options for ol.layer.Tile function (see {@link http://openlayers.org/en/latest/apidoc/ol.layer.Tile.html ol.layer.Tile})
 * @param {Object} [options.olParams.sourceParams] - other options for ol.source.TileWMS function (see {@link http://openlayers.org/en/latest/apidoc/ol.source.TileWMS.html ol.source.TileWMS})
 * @example
 * var layerWMS = new ol.layer.GeoportalWMS({
 *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
 * });
 */

var LayerWMS = function (TileLayer) {
  function LayerWMS(options) {
    if (!(this instanceof LayerWMS)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }

    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    } // par defaut


    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    } // Check if configuration is loaded


    if (!_Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].isConfigLoaded()) {
      throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html");
    } // création de la source WMS


    var olSourceParams;

    if (options.olParams && options.olParams.sourceParams) {
      olSourceParams = options.olParams.sourceParams;
    }

    var wmsSource = new _SourceWMS__WEBPACK_IMPORTED_MODULE_4__["default"]({
      layer: options.layer,
      ssl: options.ssl,
      apiKey: options.apiKey,
      olParams: olSourceParams
    });
    var layerTileOptions = {
      source: wmsSource
    }; // si le param LAYERS n'a pas été renseigné lors de la création de la source,
    // c'est que l'identifiant de la couche n'a pas été trouvé. on passe donc la recherche des paramètres.

    if (wmsSource.getParams().LAYERS !== undefined) {
      // récupération des autres paramètres nécessaires à la création de la layer
      var layerId = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].getLayerId(options.layer, "WMS");
      var globalConstraints = _Common_Utils_Config__WEBPACK_IMPORTED_MODULE_3__["default"].getGlobalConstraints(layerId);
      /* INFO : on ne récupère l'emprise de la couche que lorsque que l'utilisateur spécifie la projection.
         Si aucune projection n'est spécifiée, il faudrait spécifier l'emprise dans la projection de la carte (car OpenLayers reprojette),
         mais on ne peut pas la récupérer à ce niveau. On ne spécifie donc aucune emprise.
         Idem pour les résolutions : il faut connaitre l'unité de la projection (metres ou degrés) pour pouvoir calculer la résolution.
      */

      if (olSourceParams && olSourceParams.projection) {
        // récupération de l'étendue (en EPSG:4326), et reprojection dans la proj spécifiée
        var geobbox = [globalConstraints.extent.left, globalConstraints.extent.bottom, globalConstraints.extent.right, globalConstraints.extent.top];
        layerTileOptions.extent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["transformExtent"])(geobbox, "EPSG:4326", olSourceParams.projection); // récupération des résolutions min et max

        var p; // on récupère tout d'abord la projection

        if (typeof olSourceParams.projection === "string") {
          p = Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["get"])(olSourceParams.projection);
        } else if (_typeof(olSourceParams.projection) === "object" && olSourceParams.projection.getCode()) {
          p = Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["get"])(olSourceParams.projection.getCode());
        } // puis, selon l'unité de la projection, on calcule la résolution correspondante


        if (p && p.getUnits()) {
          if (p.getUnits() === "m") {
            /* fixme : fix temporaire pour gérer les min/max scaledenominator qui sont arrondis dans l'autoconf !
             * on les arrondit respectivement à l'unité inférieure et supérieure
             * pour que les couches soient bien disponibles aux niveaux de zoom correspondants */
            // info : 1 pixel = 0.00028 m
            layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028;
            layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028;
          } else if (p.getUnits() === "degrees") {
            /* fixme : fix temporaire pour gérer les min/max scaledenominator qui sont arrondis dans l'autoconf !
             * on les arrondit respectivement à l'unité inférieure et supérieure
             * pour que les couches soient bien disponibles aux niveaux de zoom correspondants */
            // info : 6378137 * 2 * pi / 360 = rayon de la terre (ellipsoide WGS84)
            layerTileOptions.minResolution = (globalConstraints.minScale - 1) * 0.00028 * 180 / (Math.PI * 6378137);
            layerTileOptions.maxResolution = (globalConstraints.maxScale + 1) * 0.00028 * 180 / (Math.PI * 6378137);
          }
        }
      }
    } // récupération des autres paramètres passés par l'utilisateur


    _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(layerTileOptions, options.olParams); // création d'une ol.layer.Tile avec les options récupérées ci-dessus.

    TileLayer.call(this, layerTileOptions);
  } // Inherits from ol.layer.Tile


  if (TileLayer) LayerWMS.__proto__ = TileLayer;
  /*
   * @lends module:LayerWMS
   */

  LayerWMS.prototype = Object.create(TileLayer.prototype, {});
  /*
   * Constructor (alias)
   */

  LayerWMS.prototype.constructor = LayerWMS;
  return LayerWMS;
}(ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (LayerWMS); // Expose LayerWMS as ol.layerGeoportalWMS. (for a build bundle)

if (window.ol && window.ol.layer) {
  window.ol.layer.GeoportalWMS = LayerWMS;
}

/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_LayerSwitcher_GPlayerSwitcherOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/* harmony import */ var _CSS_Controls_LayerSwitcher_GPlayerSwitcherOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_LayerSwitcher_GPlayerSwitcherOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(171);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(159);
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_extent__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(141);
/* harmony import */ var _Common_Controls_LayerSwitcherDOM__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(173);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import OpenLayers



 // import local



 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__["default"].getLogger("layerswitcher");
/**
 * @classdesc
 * OpenLayers Control to manage map layers : their order, visibility and opacity, and display their informations (title, description, legends, metadata...)
 *
 * @constructor
 * @extends {ol.control.Control}
 * @alias ol.control.LayerSwitcher
 * @param {Object} options - control options
 * @param {Array} [options.layers] - list of layers to be configured. Each array element is an object, with following properties :
 * @param {ol.layer.Layer} [options.layers.layer] - ol.layer.Layer layer to be configured (that has been added to map)
 * @param {Object} [options.layers.config] - custom configuration object for layer information (title, description, legends, metadata, quicklook url), with following properties :
 * @param {String} [options.layers.config.title] - layer alias, to be displayed in widget layer list. E.g. : "Cartes IGN"
 * @param {String} [options.layers.config.description] - layer description, to be displayed on title hover, or in layer information panel.
 * @param {String} [options.layers.config.quicklookUrl] - link to a quick look image for this layer.
 * @param {Array} [options.layers.config.legends] - array of layer legends. Each array element is an object, with following properties :
 *      - url (String, mandatory) : link to a legend
 *      - minScaleDenominator (Number, optional) : min scale denominator for legend validity.
 * @param {Array} [options.layers.config.metadata] - array of layer metadata. Each array element is an object, with property url (String, mandatory) : link to a metadata
 * @param {Object} [options.options] - ol.control.Control options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html ol.control.Control})
 * @param {Boolean} [options.options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
 * @example
 * map.addControl(new ol.control.LayerSwitcher(
 *  [
 *      {
 *          layer : wms1,
 *          config : {
 *              title : "test layer name 1",
 *              description : "test layer desc 1",
 *          }
 *      }
 *  ],
 *  {
 *      collapsed : true
 *  }
 * ));
 */

var LayerSwitcher = function (Control) {
  function LayerSwitcher(options) {
    options = options || {};

    var _options = options.options || {};

    var _layers = options.layers || [];

    if (!(this instanceof LayerSwitcher)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    if (!Array.isArray(_layers)) {
      throw new Error("ERROR WRONG_TYPE : layers should be an array");
    }

    if (_typeof(_options) !== "object") {
      throw new Error("ERROR WRONG_TYPE : options should be an object");
    }

    this._initialize(_options, _layers);

    var container = this._container = this._initContainer(_options); // call ol.control.Control constructor


    Control.call(this, {
      element: container,
      target: _options.target,
      render: _options.render
    });
  } // Inherits from Control


  if (Control) LayerSwitcher.__proto__ = Control;
  /*
   * @lends module:LayerSwitcher
   */

  LayerSwitcher.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune LayerSwitcherDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_4__["default"].assign(LayerSwitcher.prototype, _Common_Controls_LayerSwitcherDOM__WEBPACK_IMPORTED_MODULE_7__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  LayerSwitcher.prototype.constructor = LayerSwitcher; // ################################################################### //
  // ############## public methods (getters, setters) ################## //
  // ################################################################### //

  /**
   * Overload setMap function, that enables to catch map events, such as movend events.
   *
   * @param {ol.Map} map - Map.
   */

  LayerSwitcher.prototype.setMap = function (map) {
    var _this = this;

    // info : cette méthode est appelée (entre autres?) après un map.addControl() ou map.removeControl()
    if (map) {
      // dans le cas de l'ajout du contrôle à la map
      // on ajoute les couches
      this._addMapLayers(map); // At every map movement, layer switcher may be updated,
      // according to layers on map, and their range.


      this._listeners.onMoveListener = map.on("moveend", function () {
        return _this._onMapMoveEnd(map);
      }); // add event listeners when a new layer is added to map, to add it in LayerSwitcher control (and DOM)

      this._listeners.onAddListener = map.getLayers().on("add", function (evt) {
        var layer = evt.element;
        var id; // on attribue un nouvel identifiant à cette couche,
        // sauf si c'est une couche qui a déjà été ajoutée dans le LayerSwitcher au préalable (si gpLayerId existe)

        if (!layer.hasOwnProperty("gpLayerId")) {
          id = _this._layerId;
          layer.gpLayerId = id;
          _this._layerId++;
        } else {
          id = layer.gpLayerId;
        }

        if (!_this._layers[id]) {
          _this.addLayer(layer);
        }
      }); // add event listeners when a layer is removed from map, to remove it from LayerSwitcher control (and DOM)

      this._listeners.onRemoveListener = map.getLayers().on("remove", function (evt) {
        var layer = evt.element;
        var id = layer.gpLayerId;

        if (_this._layers[id]) {
          _this.removeLayer(layer);
        }
      });
    } else {
      // we are in a setMap(null) case
      // we forget the listeners linked to the layerSwitcher
      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this._listeners.onMoveListener);
      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this._listeners.onAddListener);
      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this._listeners.onRemoveListener); // we put all the layers at Zindex = 0, without changing the visual order
      // in order that the next added layers are not hidden by layers with Zindex > 0

      for (var i = this._layersOrder.length - 1; i >= 0; i--) {
        this._layersOrder[i].layer.setZIndex(0);
      }
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Add a new layer to control (when added to map) or add new layer configuration
   *
   * @param {ol.layer.Layer} layer - layer to add to layer switcher
   * @param {Object} [config] - additional options for layer configuration
   * @param {Object} [config.title] - layer title (default is layer identifier)
   * @param {Object} [config.description] - layer description (default is null)
   * @param {Object} [config.legends] - layer legends (default is an empty array)
   * @param {Object} [config.metadata] - layer metadata (default is an empty array)
   * @param {Object} [config.quicklookUrl] - layer quicklookUrl (default is null)
   * @example
   *   layerSwitcher.addLayer(
   *       gpParcels,
   *       {
   *           title : "Parcelles cadastrales",
   *           description : "description de la couche",
   *           quicklookUrl : "http://quicklookUrl.fr"
   *       }
   *   )
   */


  LayerSwitcher.prototype.addLayer = function (layer, config) {
    var _this2 = this;

    var map = this.getMap();
    config = config || {};

    if (!layer) {
      logger.log("[ERROR] LayerSwitcher:addLayer - missing layer parameter");
      return;
    }

    var id = layer.gpLayerId;

    if (typeof id === "undefined") {
      logger.trace("[WARN] LayerSwitcher:addLayer - configuration cannot be set for this layer (layer id not found)", layer);
      return;
    } // make sure layer is in map layers


    var isLayerInMap = false;
    map.getLayers().forEach(function (lyr) {
      if (lyr.gpLayerId === id) {
        isLayerInMap = true;
      }
    });

    if (!isLayerInMap) {
      logger.log("[ERROR] LayerSwitcher:addLayer - configuration cannot be set for ", layer, " layer (layer is not in map.getLayers() )");
      return;
    } // if layer is not already in layers list, add it to control (layers list and container div)


    if (!this._layers[id]) {
      // 1. add layer to layers list
      var layerInfos = this.getLayerInfo(layer) || {};
      var opacity = layer.getOpacity();
      var visibility = layer.getVisible();
      var isInRange = this.isInRange(layer, map);
      var layerOptions = {
        layer: layer,
        id: id,
        opacity: opacity != null ? opacity : 1,
        visibility: visibility != null ? visibility : true,
        inRange: isInRange != null ? isInRange : true,
        title: config.title != null ? config.title : layerInfos._title || id,
        description: config.description || layerInfos._description || null,
        legends: config.legends || layerInfos._legends || [],
        metadata: config.metadata || layerInfos._metadata || [],
        quicklookUrl: config.quicklookUrl || layerInfos._quicklookUrl || null
      };
      this._layers[id] = layerOptions; // 2. create layer div (to be added to control main container)
      // Création de la div correspondante à cette couche

      var layerDiv = this._createLayerDiv(layerOptions); // on stocke la div dans les options de la couche, pour une éventuelle réorganisation (setZIndex par ex)


      this._layers[id].div = layerDiv; // 3. réorganisation des couches si un zIndex est spécifié
      // FIXME :
      //  _forceNullzIndex !?
      //  getZIndex() retourne undefined au lieu de 0 !?

      if (layer.getZIndex && layer.getZIndex() !== 0 && typeof layer.getZIndex() !== "undefined" || layer._forceNullzIndex) {
        // réorganisation des couches si un zIndex est spécifié
        this._updateLayersOrder();
      } else {
        // sinon on ajoute la couche au dessus des autres
        this._layersOrder.unshift(layerOptions);

        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);

        this._layerListContainer.insertBefore(layerDiv, this._layerListContainer.firstChild);
      } // 3. Add listeners for opacity and visibility changes


      this._listeners.updateLayerOpacity = layer.on("change:opacity", function (e) {
        return _this2._updateLayerOpacity(e);
      });
      this._listeners.updateLayerVisibility = layer.on("change:visible", function (e) {
        return _this2._updateLayerVisibility(e);
      });

      if (this._layers[id].onZIndexChangeEvent == null) {
        this._layers[id].onZIndexChangeEvent = layer.on("change:zIndex", function () {
          return _this2._updateLayersOrder();
        });
      } // user may also add a new configuration for an already added layer

    } else {
      // add new configuration parameters to layer informations
      for (var prop in config) {
        if (config.hasOwnProperty(prop)) {
          this._layers[id][prop] = config[prop];
        }
      } // set new title in layer div


      if (config.title) {
        var nameDiv = document.getElementById(this._addUID("GPname_ID_" + id));

        if (nameDiv) {
          nameDiv.innerHTML = config.title;
          nameDiv.title = config.description || config.title;
        }
      } // add layer info picto if necessary


      var infodiv = document.getElementById(this._addUID("GPinfo_ID_" + id));

      if (!document.getElementById(this._addUID("GPinfo_ID_" + id)) && config.description) {
        var advancedTools = document.getElementById(this._addUID("GPadvancedTools_ID_" + id));

        if (advancedTools) {
          advancedTools.appendChild(this._createAdvancedToolInformationElement({
            id: id
          }));
        }
      } // close layer info element if open, to update information.


      if (infodiv && infodiv.className === "GPlayerInfoOpened") {
        document.getElementById(this._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
        infodiv.className = "GPlayerInfo";
      }
    }
  };
  /**
   * Remove a layer from control
   *
   * @param {ol.layer.Layer} layer - layer.
   * @deprecated on the future version ...
   */


  LayerSwitcher.prototype.removeLayer = function (layer) {
    if (!layer) {
      return;
    }

    Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this._listeners.updateLayerOpacity);
    Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this._listeners.updateLayerVisibility); // olObservableUnByKey(this._listeners.updateLayersOrder);

    logger.trace(layer);
    var layerID = layer.gpLayerId;
    var layerList = document.getElementById(this._addUID("GPlayersList")); // close layer info element if open.

    var infodiv = document.getElementById(this._addUID("GPinfo_ID_" + layerID));

    if (infodiv && infodiv.className === "GPlayerInfoOpened") {
      document.getElementById(this._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
      infodiv.className = "GPlayerInfo";
    } // remove layer div


    var layerDiv = document.getElementById(this._addUID("GPlayerSwitcher_ID_" + layerID));

    if (layerDiv) {
      layerList.removeChild(layerDiv);
    }

    var layerIndex = Math.abs(layer.getZIndex() - this._lastZIndex); // on retire la couche de la liste ordonnée des layers

    this._layersOrder.splice(layerIndex, 1);

    this._lastZIndex--; // on met à jour les zindex des couches restantes

    var layerOrderTemp = this._layersOrder;

    for (var i = 0; i < layerOrderTemp.length; i++) {
      layerOrderTemp[i].layer.setZIndex(this._lastZIndex - i);
    } // on retire la couche de la liste des layers


    delete this._layers[layerID];
  };
  /**
   * Collapse or display control main container
   *
   * @param {Boolean} collapsed - True to collapse control, False to display it
   */


  LayerSwitcher.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.log("[ERROR] LayerSwitcher:setCollapsed - missing collapsed parameter");
      return;
    }

    var isCollapsed = !document.getElementById(this._addUID("GPshowLayersList")).checked;

    if (collapsed && isCollapsed || !collapsed && !isCollapsed) {
      return;
    } // on simule l'ouverture du panneau après un click


    if (!isCollapsed) {
      var layers = document.getElementsByClassName("GPlayerInfoOpened");

      for (var i = 0; i < layers.length; i++) {
        layers[i].className = "GPlayerInfo";
      }

      document.getElementById(this._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
    }

    document.getElementById(this._addUID("GPshowLayersList")).checked = !collapsed;
  };
  /**
   * Returns true if widget is collapsed (minimize), false otherwise
   * @returns {Boolean} is collapsed
   */


  LayerSwitcher.prototype.getCollapsed = function () {
    return this.collapsed;
  };
  /**
   * Display or hide removeLayerPicto from layerSwitcher for this layer
   *
   * @param {ol.layer.Layer} layer - ol.layer to be configured
   * @param {Boolean} removable - specify if layer can be remove from layerSwitcher (true) or not (false). Default is true
   */


  LayerSwitcher.prototype.setRemovable = function (layer, removable) {
    if (!layer) {
      return;
    }

    var layerID = layer.gpLayerId;

    if (layerID == null) {
      // on teste si layerID est null ou undefined
      logger.log("[LayerSwitcher:setRemovable] layer should be added to map before calling setRemovable method");
      return;
    }

    var removalDiv = document.getElementById(this._addUID("GPremove_ID_" + layerID));

    if (removalDiv) {
      if (removable === false) {
        removalDiv.style.display = "none";
      } else if (removable === true) {
        removalDiv.style.display = "block";
      } else {}
    }
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize LayerSwitcher control (called by constructor)
   *
   * @param {Object} options - ol.control.Control options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html ol.control.Control})
   * @param {Array} layers - list of layers to be configured. Each array element is an object, with following properties :
   * @private
   */


  LayerSwitcher.prototype._initialize = function (options, layers) {
    // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)
    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_5__["default"].generate(); // {Object} control layers list. Each key is a layer id, and its value is an object of layers options (layer, id, opacity, visibility, title, description...)

    this._layers = {}; // [Array] array of ordered control layers

    this._layersOrder = []; // [Object] associative array of layers ordered by zindex (keys are zindex values, and corresponding values are arrays of layers at this zindex)

    this._layersIndex = {}; // {Number} layers max z index, to order layers using their z index

    this._lastZIndex = 0; // {Number} layers max id, incremented when a new layer is added

    this._layerId = 0;
    /** {Boolean} true if widget is collapsed, false otherwise */

    this.collapsed = options.collapsed !== undefined ? options.collapsed : true; // div qui contiendra les div des listes.

    this._layerListContainer = null; // [Object] listeners added to the layerSwitcher saved here in order to delete them if we remove the control from the map)

    this._listeners = {}; // add options layers to layerlist.
    // (seulement les couches configurées dans les options du layerSwitcher par l'utilisateur),
    // les autres couches de la carte seront ajoutées dans la méthode setMap

    for (var i = 0; i < layers.length; i++) {
      // recup la layer, son id,
      var layer = layers[i].layer;

      if (layer) {
        var id; // si elles ont déjà un identifiant (gpLayerId), on le récupère, sinon on en crée un nouveau, en incrémentant this_layerId.

        if (!layer.hasOwnProperty("gpLayerId")) {
          id = this._layerId;
          layer.gpLayerId = id;
          this._layerId++;
        } else {
          id = layer.gpLayerId;
        } // et les infos de la conf si elles existent (title, description, legends, quicklook, metadata)


        var conf = layers[i].config || {};
        var opacity = layer.getOpacity();
        var visibility = layer.getVisible();
        var layerOptions = {
          layer: layer,
          // la couche ol.layer concernée
          id: id,
          opacity: opacity != null ? opacity : 1,
          visibility: visibility != null ? visibility : true,
          title: conf.title != null ? conf.title : id,
          description: conf.description || null,
          legends: conf.legends || [],
          metadata: conf.metadata || [],
          quicklookUrl: conf.quicklookUrl || null
        };
        this._layers[id] = layerOptions;
      }
    }
  };
  /**
   * Create control main container (called by constructor)
   *
   * @returns {DOMElement} container - control container
   * @private
   */


  LayerSwitcher.prototype._initContainer = function () {
    // creation du container principal
    var container = this._createMainContainerElement(); // ajout dans le container principal d'affichage des layers


    var input = this._createMainLayersShowElement();

    container.appendChild(input); // gestion du mode "collapsed"

    if (!this.collapsed) {
      input.checked = "checked";
      this.collapsed = false;
    } else {
      this.collapsed = true;
    } // on ajoute un écouteur d'évènement sur le bouton (checkbox) de dépliement/repliement des couches,
    // pour modifier la propriété this.collapsed quand on clique dessus


    var context = this; // event listener

    var changeCollapsed = function changeCollapsed(e) {
      this.collapsed = !e.target.checked; // on génère nous même l'evenement OpenLayers de changement de pté
      // (utiliser layerSwitcher.on("change:collapsed", function ) pour s'abonner à cet évènement)

      this.dispatchEvent("change:collapsed");
    };

    input.addEventListener("click", function (e) {
      changeCollapsed.call(context, e);
    }); // ajout dans le container principal de la liste des layers

    var divL = this._layerListContainer = this._createMainLayersElement();

    container.appendChild(divL); // creation du mode draggable

    this._createDraggableElement(divL, this); // ajout dans le container principal du picto du controle


    var picto = this._createMainPictoElement();

    container.appendChild(picto); // ajout dans le container principal du panneau d'information

    var divI = this._createMainInfoElement();

    container.appendChild(divI);
    return container;
  };
  /**
   * Add all map layers to control main container
   *
   * @param {Object} map - ol.Map object, to which control is added
   * @private
   */


  LayerSwitcher.prototype._addMapLayers = function (map) {
    var _this3 = this;

    this._layersIndex = {}; // on parcourt toutes les couches de la carte, pour les ajouter à la liste du controle si ce n'est pas déjà le cas.
    // idée : le layerSwitcher doit représenter l'ensemble des couches de la carte.

    map.getLayers().forEach(function (layer) {
      // ajout des couches de la carte à la liste
      var id; // si elles ont déjà un identifiant (gpLayerId), on le récupère, sinon on en crée un nouveau, en incrémentant this_layerId.

      if (!layer.hasOwnProperty("gpLayerId")) {
        id = _this3._layerId;
        layer.gpLayerId = id;
        _this3._layerId++;
      } else {
        id = layer.gpLayerId;
      }

      var layerInfos = _this3.getLayerInfo(layer) || {};

      if (!_this3._layers[id]) {
        // si la couche n'est pas encore dans la liste des layers (this._layers), on l'ajoute
        var opacity = layer.getOpacity();
        var visibility = layer.getVisible();

        var isInRange = _this3.isInRange(layer, map);

        var layerOptions = {
          layer: layer,
          id: id,
          opacity: opacity != null ? opacity : 1,
          visibility: visibility != null ? visibility : true,
          inRange: isInRange != null ? isInRange : true,
          title: layerInfos._title || id,
          description: layerInfos._description || null,
          legends: layerInfos._legends || [],
          metadata: layerInfos._metadata || [],
          quicklookUrl: layerInfos._quicklookUrl || null
        };
        _this3._layers[id] = layerOptions;
      } else {
        // si elle existe déjà, on met à jour ses informations (visibility, opacity, inRange)
        _this3._layers[id].opacity = layer.getOpacity();
        _this3._layers[id].visibility = layer.getVisible();
        _this3._layers[id].inRange = _this3.isInRange(layer, map);
      } // Ajout de listeners sur les changements d'opacité, visibilité


      _this3._listeners.updateLayerOpacity = layer.on("change:opacity", function (e) {
        return _this3._updateLayerOpacity(e);
      });
      _this3._listeners._updateLayerVisibility = layer.on("change:visible", function (e) {
        return _this3._updateLayerVisibility(e);
      }); // récupération des zindex des couches s'ils existent, pour les ordonner.

      if (layer.getZIndex !== undefined) {
        var layerIndex = layer.getZIndex() || 0; // FIXME le zIndex peut être undefined !? donc par defaut à 0 !

        if (!_this3._layersIndex[layerIndex] || !Array.isArray(_this3._layersIndex[layerIndex])) {
          _this3._layersIndex[layerIndex] = [];
        }

        _this3._layersIndex[layerIndex].push(_this3._layers[id]);
      }

      ;
    }); // on récupère l'ordre d'affichage des couches entre elles dans la carte, à partir de zindex.

    for (var zindex in this._layersIndex) {
      if (this._layersIndex.hasOwnProperty(zindex)) {
        var layers = this._layersIndex[zindex];

        for (var l = 0; l < layers.length; l++) {
          // à ce stade layers[l] est une couche de this._layers.
          // on conserve l'ordre des couches : la première est celle qui se situe tout en haut, et la dernière est le "fond de carte"
          this._layersOrder.unshift(layers[l]); // et on réordonne les couches avec des zindex, uniques.


          this._lastZIndex++;
          layers[l].layer.setZIndex(this._lastZIndex);

          if (this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent == null) {
            this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent = layers[l].layer.on("change:zIndex", function () {
              return _this3._updateLayersOrder();
            });
          }
        }
      }
    } // on ajoute les div correspondantes aux différentes couches (dans l'ordre inverse d'affichage) dans le controle.


    for (var j = 0; j < this._layersOrder.length; j++) {
      var layerOptions = this._layersOrder[j];

      var layerDiv = this._createLayerDiv(layerOptions);

      this._layerListContainer.appendChild(layerDiv); // on stocke la div dans les options de la couche, pour une éventuelle réorganisation (setZIndex par ex)


      this._layers[layerOptions.id].div = layerDiv;
    }
  };
  /**
   * create layer div (to append to control DOM element).
   *
   * @param {Object} layerOptions - layer options (id, title, description, legends, metadata, quicklookUrl ...)
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  LayerSwitcher.prototype._createLayerDiv = function (layerOptions) {
    var isLegends = layerOptions.legends && layerOptions.legends.length !== 0;
    var isMetadata = layerOptions.metadata && layerOptions.metadata.length !== 0;
    var isQuicklookUrl = layerOptions.quicklookUrl; // on n'affiche les informations que si elles sont renseignées (pour ne pas avoir un panneau vide)

    if (isLegends || isMetadata || isQuicklookUrl) {
      layerOptions.displayInformationElement = true;
    } // ajout d'une div pour cette layer dans le control


    var layerDiv = this._createContainerLayerElement(layerOptions);

    if (!layerOptions.inRange) {
      layerDiv.classList.add("outOfRange");
    }

    return layerDiv;
  }; // ################################################################### //
  // ######################### DOM events ############################## //
  // ################################################################### //

  /**
   * Change layer opacity on layer opacity picto click
   *
   * @param {Object} e - event
   * @private
   */


  LayerSwitcher.prototype._onChangeLayerOpacity = function (e) {
    var divId = e.target.id; // ex GPvisibilityPicto_ID_26

    var layerID = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_5__["default"].index(divId); // ex. 26

    var layer = this._layers[layerID].layer;
    var opacityValue = e.target.value;
    var opacityId = document.getElementById(this._addUID("GPopacityValue_ID_" + layerID));
    opacityId.innerHTML = opacityValue + "%";
    layer.setOpacity(opacityValue / 100);
  };
  /**
   * Update picto opacity value on layer opacity change
   *
   * @param {Object} e - event
   * @private
   */


  LayerSwitcher.prototype._updateLayerOpacity = function (e) {
    var opacity = e.target.getOpacity();

    if (opacity > 1) {
      opacity = 1;
    }

    if (opacity < 0) {
      opacity = 0;
    }

    var id = e.target.gpLayerId;
    var layerOpacityInput = document.getElementById(this._addUID("GPopacityValueDiv_ID_" + id));

    if (layerOpacityInput) {
      layerOpacityInput.value = Math.round(opacity * 100);
    }

    var layerOpacitySpan = document.getElementById(this._addUID("GPopacityValue_ID_" + id));

    if (layerOpacitySpan) {
      layerOpacitySpan.innerHTML = Math.round(opacity * 100) + "%";
    }
  };
  /**
   * Change layer visibility on layer visibility picto click
   *
   * @param {Object} e - event
   * @private
   */


  LayerSwitcher.prototype._onVisibilityLayerClick = function (e) {
    var divId = e.target.id; // ex GPvisibilityPicto_ID_26

    var layerID = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_5__["default"].index(divId); // ex. 26

    var layer = this._layers[layerID].layer;
    layer.setVisible(e.target.checked);
  };
  /**
   * Change picto visibility on layer visibility change
   *
   * @param {Object} e - event
   * @private
   */


  LayerSwitcher.prototype._updateLayerVisibility = function (e) {
    var visible = e.target.getVisible();
    var id = e.target.gpLayerId;
    var layerVisibilityInput = document.getElementById(this._addUID("GPvisibility_ID_" + id));

    if (layerVisibilityInput) {
      layerVisibilityInput.checked = visible;
    }
  };
  /**
   * Change layers order in layerswitcher (control container) on a layer index change (on map) or when a layer is added to a specific zindex
   *
   * @private
   */


  LayerSwitcher.prototype._updateLayersOrder = function () {
    var _this4 = this;

    // info :
    // 1. on récupère les zindex et les couches associées dans un tableau associatif (objet)
    // 2. on réordonne les couche selon leur index : on leur attribue de nouveaux zindex uniques
    // 3. on vide le container des layers, et rajoute les div des couches dans l'ordre décroissant des zindex
    var map = this.getMap();

    if (!map) {
      return;
    }

    this._layersIndex = {};
    var layerIndex;
    var id; // on parcourt toutes les couches pour récupérer leur ordre :
    // on stocke les couches dans un tableau associatif ou les clés sont les zindex, et les valeurs sont des tableaux des couches à ce zindex.

    map.getLayers().forEach(function (layer) {
      id = layer.gpLayerId; // on commence par désactiver temporairement l'écouteur d'événements sur le changement de zindex.

      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(_this4._layers[id].onZIndexChangeEvent);
      _this4._layers[id].onZIndexChangeEvent = null; // on ajoute la couche dans le tableau (de l'objet this._layersIndex) correspondant à son zindex

      layerIndex = null;

      if (layer.getZIndex !== undefined) {
        layerIndex = layer.getZIndex();

        if (!_this4._layersIndex[layerIndex] || !Array.isArray(_this4._layersIndex[layerIndex])) {
          _this4._layersIndex[layerIndex] = [];
        }

        _this4._layersIndex[layerIndex].push(_this4._layers[id]);
      }

      ;
    }); // on réordonne les couches entre elles dans la carte, à partir des zindex stockés ci-dessus.

    this._lastZIndex = 0;
    this._layersOrder = [];

    for (var zindex in this._layersIndex) {
      if (this._layersIndex.hasOwnProperty(zindex)) {
        var layers = this._layersIndex[zindex];

        for (var l = 0; l < layers.length; l++) {
          // à ce stade layers[l] est une couche de this._layers.
          // on conserve l'ordre des couches : la première est celle qui se situe tout en haut, et la dernière est le "fond de carte"
          this._layersOrder.unshift(layers[l]); // et on réordonne les couches avec des zindex, uniques.


          this._lastZIndex++; // layers[l].layer.setZIndex(lastZIndex);
          // et on réactive l'écouteur d'événement sur les zindex

          if (this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent == null) {
            this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent = layers[l].layer.on("change:zIndex", function () {
              return _this4._updateLayersOrder();
            });
          }
        }
      }
    }

    if (this._layerListContainer) {
      // on vide le container précédent
      while (this._layerListContainer.firstChild) {
        this._layerListContainer.removeChild(this._layerListContainer.firstChild);
      } // et on rajoute les div correspondantes aux différentes couches, dans l'ordre décroissant des zindex


      for (var j = 0; j < this._layersOrder.length; j++) {
        var layerOptions = this._layersOrder[j];

        this._layerListContainer.appendChild(layerOptions.div);
      }
    } else {
      logger.log("[ol.control.LayerSwitcher] _updateLayersOrder : layer list container not found to update layers order ?!");
    }
  };
  /**
   * Open layer information panel on picto click
   *
   * @param {Event} e - MouseEvent
   * @private
   */


  LayerSwitcher.prototype._onOpenLayerInfoClick = function (e) {
    var divId = e.target.id; // ex GPvisibilityPicto_ID_26

    var layerID = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_5__["default"].index(divId); // ex. 26

    var layerOptions = this._layers[layerID];
    var panel;
    var info; // Close layer info panel

    divId = document.getElementById(e.target.id);

    if (divId.className === "GPlayerInfoOpened") {
      if (divId.classList !== undefined) {
        divId.classList.remove("GPlayerInfoOpened");
        divId.classList.add("GPlayerInfo");
      }

      panel = document.getElementById(this._addUID("GPlayerInfoPanel"));

      if (panel.classList !== undefined) {
        panel.classList.remove("GPpanel");
        panel.classList.remove("GPlayerInfoPanelOpened");
        panel.classList.add("GPlayerInfoPanelClosed");
      }

      info = document.getElementById(this._addUID("GPlayerInfoContent"));
      panel.removeChild(info);
      return;
    }

    var layers = document.getElementsByClassName("GPlayerInfoOpened");

    for (var i = 0; i < layers.length; i++) {
      layers[i].className = "GPlayerInfo";
    } // Open layer info panel


    if (divId.classList !== undefined) {
      divId.classList.remove("GPlayerInfo");
      divId.classList.add("GPlayerInfoOpened");
    }

    panel = document.getElementById(this._addUID("GPlayerInfoPanel"));

    if (panel.classList !== undefined) {
      panel.classList.add("GPpanel");
      panel.classList.remove("GPlayerInfoPanelClosed");
      panel.classList.add("GPlayerInfoPanelOpened");
    }

    info = document.getElementById(this._addUID("GPlayerInfoContent"));

    if (info) {
      panel.removeChild(info);
    } // on récupère les infos associées au layer pour mettre dynamiquement le contenu du panel d'informations


    var obj = {
      title: layerOptions.title,
      description: layerOptions.description,
      quicklookUrl: layerOptions.quicklookUrl,
      metadata: layerOptions.metadata,
      legends: layerOptions.legends
    }; // get layer max scale denominator

    var maxResolution = layerOptions.layer.getMaxResolution();

    if (maxResolution === Infinity) {
      obj._maxScaleDenominator = 560000000;
    } else {
      obj._maxScaleDenominator = Math.round(maxResolution / 0.00028);
    }

    var infoLayer = this._createContainerLayerInfoElement(obj);

    panel.appendChild(infoLayer);
  };
  /**
   * remove layer from layer switcher and map on picto click
   *
   * @param {Event} e - MouseEvent
   * @private
   */


  LayerSwitcher.prototype._onDropLayerClick = function (e) {
    var divId = e.target.id; // ex GPvisibilityPicto_ID_26

    var layerID = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_5__["default"].index(divId); // ex. 26

    var layer = this._layers[layerID].layer; // le retrait de la couche va déclencher l'ecouteur d'évenement,
    // et appeler this.removeLayer qui va supprimer la div.

    this.getMap().getLayers().remove(layer);
  };
  /**
   * change layers order (on map) on drag and drop (on control container)
   *
   * @private
   */


  LayerSwitcher.prototype._onDragAndDropLayerClick = function () {
    var _this5 = this;

    // INFO : e.oldIndex et e.newIndex marchent en mode AMD mais pas Bundle.
    var map = this.getMap(); // on récupère l'ordre des div dans le contrôle pour réordonner les couches (avec zindex)

    var matchesLayers = document.querySelectorAll("div.GPlayerSwitcher_layer");
    var maxZIndex = matchesLayers.length; // on vide la liste ordonnée avant de la remplir avec l'ordre des couches selon les div.

    this._layersOrder = [];

    for (var i = 0; i < matchesLayers.length; i++) {
      var tag = matchesLayers[i].id;
      var id = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_5__["default"].index(tag);
      var layer = this._layers[id].layer; // on commence par désactiver temporairement l'écouteur d'événements sur le changement de zindex.

      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this._layers[id].onZIndexChangeEvent);
      this._layers[id].onZIndexChangeEvent = null;

      if (layer.setZIndex) {
        // maxZIndex--;
        layer.setZIndex(maxZIndex);

        this._layersOrder.push(this._layers[id]);

        maxZIndex--;
      } // et on réactive l'écouteur d'événement sur les zindex


      if (this._layers[id].onZIndexChangeEvent == null) {
        this._layers[id].onZIndexChangeEvent = layer.on("change:zIndex", function () {
          return _this5._updateLayersOrder();
        });
      }
    } // mise à jour de la visu


    map.updateSize();
  };
  /**
   * check layers range on map movement
   *
   * @param {ol.Map} map - ol map on which event occured
   * @private
   */


  LayerSwitcher.prototype._onMapMoveEnd = function (map) {
    var _this6 = this;

    // pour chaque couche de la map, on vérifie qu'elle soit toujours dans la visu (inRange)
    map.getLayers().forEach(function (layer) {
      var id = layer.gpLayerId;

      if (_this6._layers[id]) {
        var layerOptions = _this6._layers[id]; // Check if layer is out of range.

        var layerDiv;

        if (_this6.isInRange(layer, map) && !layerOptions.inRange) {
          layerOptions.inRange = true;
          layerDiv = document.getElementById(_this6._addUID("GPlayerSwitcher_ID_" + id));
          layerDiv.classList.remove("outOfRange");
        } else if (!_this6.isInRange(layer, map) && layerOptions.inRange) {
          layerOptions.inRange = false;
          layerDiv = document.getElementById(_this6._addUID("GPlayerSwitcher_ID_" + id));
          layerDiv.classList.add("outOfRange");
        }
      }
    });
  }; // ################################################################### //
  // ############################ Utils ################################ //
  // ################################################################### //

  /**
   * Returns Layer Container Id associated with given olLayer
   *
   * @param {ol.layer.Layer} olLayer - ol layer object
   * @returns {String} - div container Id ; null if layer not found.
   */


  LayerSwitcher.prototype.getLayerDOMId = function (olLayer) {
    var foundId = null;
    this.getMap().getLayers().forEach(function (layer) {
      if (layer === olLayer) {
        foundId = layer.hasOwnProperty("gpLayerId") ? layer.gpLayerId : null;
      }
    }); // TODO : recuperer "GPlayerSwitcher_ID" depuis une constante

    return foundId !== null ? this._addUID("GPlayerSwitcher_ID_" + foundId) : null;
  };
  /**
   * Check if map view is out of layer range (in terms of extent and zoom)
   *
   * @param {Object} layer - the ol.layer object
   * @param {Object} map   - the ol.Map object
   * @returns {Boolean} outOfRange - false if map view is out of layer range
   */


  LayerSwitcher.prototype.isInRange = function (layer, map) {
    if (!map) {
      return;
    } // check if map zoom is in layer zoom range


    var mapResolution = map.getView().getResolution();

    if (mapResolution > layer.getMaxResolution() || mapResolution < layer.getMinResolution()) {
      return false;
    } // check if map extent intersects layer extent (if defined)


    var mapExtent = map.getView().calculateExtent(map.getSize());
    var layerExtent = layer.getExtent();

    if (layerExtent && !Object(ol_extent__WEBPACK_IMPORTED_MODULE_3__["intersects"])(mapExtent, layerExtent)) {
      return false;
    }

    return true;
  };
  /**
   * Get layer informations : title, description, quicklookurl, legends, metadata
   *
   * @param {Object} layer - the ol.layer object
   * @returns {Object} layerInfo - layer informations
   */


  LayerSwitcher.prototype.getLayerInfo = function (layer) {
    var layerInfo = {};

    if (layer.getSource !== undefined) {
      var src = layer.getSource();

      if (src) {
        layerInfo._title = src._title || "";
        layerInfo._description = src._description || "";
        layerInfo._quicklookUrl = src._quicklookUrl || "";
        layerInfo._metadata = src._metadata || [];
        layerInfo._legends = src._legends || [];
      }
    }

    return layerInfo;
  };

  return LayerSwitcher;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (LayerSwitcher); // Expose LayerSwitcher as ol.control.LayerSwitcher (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.LayerSwitcher = LayerSwitcher;
}

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = ol.control.Control;

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = ol.Observable;

/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @private
 * @description
 * formalisme d'un tag ID :
 * -> NAME(_ORDER)-1460636385836
 *
 * @example
 * Ex.
 *   GProutePoints-1460636385836
 *   GProutePoint_10-1460636385836
 */
var SelectorID = {
  /**
   * Construction d'un identifiant statique basé sur le timestamp,
   * et qui s'incremente de +1 à chaque appel
   */
  generate: function () {
    var timestamp = Math.floor(Date.now());
    return function () {
      return timestamp++;
    };
  }(),

  /**
   * nom du tag
   * @param {String} id - the id
   *
   * @returns {String} index
   */
  name: function name(id) {
    var name = null;
    var i = id.lastIndexOf("-");

    if (i === -1) {
      name = id;
    } else {
      name = id.substring(0, i);
    }

    return name;
  },

  /**
   * numero d'identifiant du tag
   * @param {String} id - the id
   *
   * @returns {String} index
   */
  index: function index(id) {
    var index = null;
    var name = this.name(id); // if (name !== id) {

    var i = name.lastIndexOf("_");

    if (i !== -1) {
      index = name.substring(i + 1);
    } // }


    return index;
  },

  /**
   * uuid du tag
   * @param {String} id - the id
   *
   * @returns {String} uuid
   */
  uuid: function uuid(id) {
    var uuid = null;
    var i = id.lastIndexOf("-");

    if (i !== -1) {
      uuid = parseInt(id.substring(i + 1), 10);
    }

    return uuid;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (SelectorID);

/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(174);

var LayerSwitcherDOM = {
  /**
   * Creation du drag and drop
   *
   * @param {Object} elementDraggable - Element HTML (DOM) Container
   * @param {Object} context - this
   */
  _createDraggableElement: function _createDraggableElement(elementDraggable, context) {
    // FIXME retirer cette détection user-agent pour solution propre
    // option forcefallback pour réparer sortable sous Chrome 97
    // option forcefallback casse le layerswitcher du portail sous firefox
    if (navigator.userAgent.match(/chrome|chromium|crios/i)) {
      sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create(elementDraggable, {
        handle: ".GPlayerName",
        draggable: ".draggable-layer",
        ghostClass: "GPghostLayer",
        animation: 200,
        forceFallback: true,
        // Call event function on drag and drop
        onEnd: function onEnd(e) {
          // FIXME pas terrrible, mais il faut bien passer ce contexte...
          context._onDragAndDropLayerClick(e);
        }
      });
    } else {
      sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create(elementDraggable, {
        handle: ".GPlayerName",
        draggable: ".draggable-layer",
        ghostClass: "GPghostLayer",
        animation: 200,
        // Call event function on drag and drop
        onEnd: function onEnd(e) {
          // FIXME pas terrrible, mais il faut bien passer ce contexte...
          context._onDragAndDropLayerClick(e);
        }
      });
    }
  },
  // ################################################################### //
  // ######################### Main container ########################## //
  // ################################################################### //

  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Creation du container principal (DOM)
   *
   * @returns {DOMElement} container - layer switcher DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerSwitcher");
    container.className = "GPwidget";
    return container;
  },

  /**
   * Creation du container principal d"affichage des layers (DOM)
   *
   * @returns {DOMElement} input - element for minimizing/maximizing the layer switcher
   */
  _createMainLayersShowElement: function _createMainLayersShowElement() {
    // <!-- Hidden checkbox for minimizing/maximizing -->
    var input = document.createElement("input");
    input.id = this._addUID("GPshowLayersList");
    input.type = "checkbox";
    return input;
  },

  /**
   * Creation du container principal des layers (DOM)
   *
   * @returns {DOMElement} container - layers list container
   */
  _createMainLayersElement: function _createMainLayersElement() {
    // ajout de la liste des layers dans le container principal
    // <div id="GPlayersList" class="GPpanel">
    //   (...)
    // </div>
    var div = document.createElement("div");
    div.id = this._addUID("GPlayersList");
    div.className = "GPpanel";
    return div;
  },

  /**
   * Creation du container du picto du controle (DOM)
   *
   * @returns {DOMElement} label
   */
  _createMainPictoElement: function _createMainPictoElement() {
    var self = this; // exemple :
    // <!-- Label for minimizing/maximizing -->
    // <label id="GPshowLayersListPicto" class="GPshowAdvancedToolPicto" for="GPshowLayersList" title="Afficher/masquer le gestionnaire de couches">
    //    <span id="GPshowLayersListOpen" class="GPshowAdvancedToolOpen"></span><span id="GPshowLayersListClose"></span>
    // </label>

    var label = document.createElement("label");
    label.id = this._addUID("GPshowLayersListPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowLayersList");
    label.title = "Afficher/masquer le gestionnaire de couches";
    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowLayersListOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    spanOpen.addEventListener("click", function () {
      if (document.getElementById(self._addUID("GPshowLayersList")).checked) {
        var layers = document.getElementsByClassName("GPlayerInfoOpened");

        for (var i = 0; i < layers.length; i++) {
          layers[i].className = "GPlayerInfo";
        }

        document.getElementById(self._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
      }
    });
    label.appendChild(spanOpen);
    var spanClose = document.createElement("span");
    spanClose.addEventListener("click", function () {
      if (document.getElementById(self._addUID("GPshowLayersList")).checked) {
        var layers = document.getElementsByClassName("GPlayerInfoOpened");

        for (var i = 0; i < layers.length; i++) {
          layers[i].className = "GPlayerInfo";
        }

        document.getElementById(self._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
      }
    });
    spanClose.id = self._addUID("GPshowLayersListClose");
    label.appendChild(spanClose);
    return label;
  },

  /**
   * Creation du container du panneau d"information (DOM)
   *
   * @returns {DOMElement} container
   */
  _createMainInfoElement: function _createMainInfoElement() {
    // gestion du panneau d"information dans le container principal
    // <div id="GPlayerInfoPanel" class="GPlayerInfoPanelClosed">...</div>
    var div = document.createElement("div");
    div.id = this._addUID("GPlayerInfoPanel");
    div.className = "GPpanel GPlayerInfoPanelClosed";
    return div;
  },
  // ################################################################### //
  // ######################### Layer container ######################### //
  // ################################################################### //

  /**
   * Creation du container du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   * @param {Object} obj.layer - couche (ol ou leaflet)
   * @param {String} obj.id - identifiant de la couche (pour ol ou leaflet)
   * @param {String} obj.title - nom de la couche à afficher dans le controle
   * @param {String} obj.description - description de la couche à afficher
   * @param {Boolean} obj.visibility - visibilité de la couche dans la carte (true or false)
   * @param {Float} obj.opacity - opacité de la couche
   *
   * @returns {DOMElement} container
   */
  _createContainerLayerElement: function _createContainerLayerElement(obj) {
    // exemple :
    // <div id="GPlayerSwitcher_ID_Layer1" class="GPlayerSwitcher_layer outOfRange">
    //     <!-- Basic toolbar : visibility / layer name
    //     _createBasicToolElement
    //           _createBasicToolVisibilityElement
    //           _createBasicToolNameElement
    //     -->
    //     <!-- Hidden checkbox + label for showing advanced toolbar
    //     _createAdvancedToolShowElement
    //     -->
    //     <!-- Advanced toolbar : layer info / opacity slider / opacity value / removal
    //     _createAdvancedToolElement
    //           _createAdvancedToolDeleteElement
    //           _createAdvancedToolInformationElement
    //           _createAdvancedToolOpacityElement
    //     -->
    // </div>
    // <!-- Layer entry in layer list -->
    // <!-- Every item is marked with layerID, which is defined at layer import -->
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerSwitcher_ID_" + obj.id);
    container.className = "GPlayerSwitcher_layer draggable-layer"; // ajout des outils basiques (visibility / layer name)

    container.appendChild(this._createBasicToolElement(obj)); // liste des outils avancés (layer info / opacity slider / opacity value / removal)

    var array = this._createAdvancedToolShowElement(obj);

    for (var i = 0; i < array.length; i++) {
      container.appendChild(array[i]);
    } // ajout des outils avancés


    container.appendChild(this._createAdvancedToolElement(obj));
    return container;
  },
  // ################################################################### //
  // ############################ Layer tool ########################### //
  // ################################################################### //

  /**
   * Creation du container des outils basiques du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createBasicToolElement: function _createBasicToolElement(obj) {
    // exemple :
    // <div id="GPbasicTools_ID_1" class="GPlayerBasicTools">
    //      <!-- _createBasicToolVisibilityElement -->
    //      <!-- _createBasicToolNameElement -->
    // </div>
    var div = document.createElement("div");
    div.id = this._addUID("GPbasicTools_ID_" + obj.id);
    div.className = "GPlayerBasicTools";
    div.appendChild(this._createBasicToolNameElement(obj));

    var array = this._createBasicToolVisibilityElement(obj);

    for (var i = 0; i < array.length; i++) {
      div.appendChild(array[i]);
    }

    return div;
  },

  /**
   * Creation du nom du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createBasicToolNameElement: function _createBasicToolNameElement(obj) {
    // exemple :
    // <span id="GPname_ID_Layer1" class="GPlayerName" title="Quartiers prioritaires de la ville">Quartiers prioritaires de la ville</span>
    var span = document.createElement("span");
    span.id = this._addUID("GPname_ID_" + obj.id);
    span.className = "GPlayerName";
    span.title = obj.description || obj.title;
    span.innerHTML = obj.title;
    return span;
  },

  /**
   * Creation de l'icone de visibilité du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
    * @returns {DOMElement[]} array containing input and label elements
   */
  _createBasicToolVisibilityElement: function _createBasicToolVisibilityElement(obj) {
    // exemple :
    // <input type="checkbox" id="GPvisibility_ID_Layer1" checked="">
    // <label for="GPvisibility_ID_Layer1" id="GPvisibilityPicto_ID_Layer1" class="GPlayerVisibility" title="Afficher/masquer la couche"></label>
    var list = [];
    var checked = typeof obj.visibility !== "undefined" ? obj.visibility : true;

    var id = this._addUID("GPvisibility_ID_" + obj.id);

    var input = document.createElement("input");
    input.id = id;
    input.type = "checkbox";
    input.checked = checked;
    var label = document.createElement("label");
    label.htmlFor = id;
    label.id = this._addUID("GPvisibilityPicto_ID_" + obj.id);
    label.className = "GPlayerVisibility";
    label.title = "Afficher/masquer la couche"; // add event for visibility change

    var context = this;

    if (input.addEventListener) {
      input.addEventListener("click", function (e) {
        context._onVisibilityLayerClick(e);
      });
    } else if (input.attachEvent) {
      // internet explorer
      input.attachEvent("onclick", function (e) {
        context._onVisibilityLayerClick(e);
      });
    }

    list.push(input);
    list.push(label);
    return list;
  },

  /**
   * Creation de l'affichage du menu des outils avancés du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement[]} array containing input and label elements
   */
  _createAdvancedToolShowElement: function _createAdvancedToolShowElement(obj) {
    // <input type="checkbox" id="GPshowAdvancedTools_ID_Layer1">
    // <label for="GPshowAdvancedTools_ID_Layer1" id="GPshowAdvancedToolsPicto_ID_Layer1" class="GPshowMoreOptions GPshowLayerAdvancedTools" title="Plus d'outils"></label>
    var list = [];
    var label = document.createElement("label");
    label.id = this._addUID("GPshowAdvancedToolsPicto_ID_" + obj.id);
    label.htmlFor = this._addUID("GPshowAdvancedTools_ID_" + obj.id);
    label.title = "Plus d'outils";
    label.className = "GPshowMoreOptions GPshowLayerAdvancedTools";
    var input = document.createElement("input");
    input.type = "checkbox";
    input.id = this._addUID("GPshowAdvancedTools_ID_" + obj.id);
    list.push(input);
    list.push(label);
    return list;
  },

  /**
   * Creation du container des outils avancés du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createAdvancedToolElement: function _createAdvancedToolElement(obj) {
    // exemple :
    // <div id="GPadvancedTools_ID_Layer1" class="GPlayerAdvancedTools">
    //     <!-- _createAdvancedToolDeleteElement -->
    //     <!-- _createAdvancedToolInformationElement -->
    //     <!-- _createAdvancedToolOpacityElement -->
    // </div>
    var container = document.createElement("div");
    container.id = this._addUID("GPadvancedTools_ID_" + obj.id);
    container.className = "GPlayerAdvancedTools";
    container.appendChild(this._createAdvancedToolDeleteElement(obj)); // si on n'a de l'informations à afficher, on met en place ce composant

    if (obj.title && obj.description) {
      container.appendChild(this._createAdvancedToolInformationElement(obj));
    }

    if (obj.type !== "feature") {
      var array = this._createAdvancedToolOpacityElement(obj);

      for (var i = 0; i < array.length; i++) {
        container.appendChild(array[i]);
      }
    }

    return container;
  },

  /**
   * Creation de l'icone de suppression du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createAdvancedToolDeleteElement: function _createAdvancedToolDeleteElement(obj) {
    // exemple :
    // <div id="GPremove_ID_Layer1" class="GPlayerRemove" title="Supprimer la couche" onclick="GPdropLayer(this);"></div>
    var div = document.createElement("div");
    div.id = this._addUID("GPremove_ID_" + obj.id);
    div.className = "GPlayerRemove";
    div.title = "Supprimer la couche";
    div.layerId = obj.id;
    var context = this;

    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        context._onDropLayerClick(e);
      });
    } else if (div.attachEvent) {
      // internet explorer
      div.attachEvent("onclick", function (e) {
        context._onDropLayerClick(e);
      });
    }

    return div;
  },

  /**
   * Creation de l'icone d'information du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createAdvancedToolInformationElement: function _createAdvancedToolInformationElement(obj) {
    // exemple :
    // <div id="GPinfo_ID_Layer1" class="GPlayerInfo" title="Informations/légende" onclick="GPopenLayerInfo(this);"></div>
    var div = document.createElement("div");
    div.id = this._addUID("GPinfo_ID_" + obj.id);
    div.className = "GPlayerInfo";
    div.title = "Informations/légende";
    div.layerId = obj.id; // add event on click

    var context = this;

    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        context._onOpenLayerInfoClick(e);
      });
    } else if (div.attachEvent) {
      // internet explorer
      div.attachEvent("onclick", function (e) {
        context._onOpenLayerInfoClick(e);
      });
    }

    return div;
  },

  /**
   * Creation de l'icone de gestion de l'opacité du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement[]} array of two containers
   */
  _createAdvancedToolOpacityElement: function _createAdvancedToolOpacityElement(obj) {
    // exemple :
    // <div id="GPopacity_ID_Layer1" class="GPlayerOpacity" title="Opacité">
    //   <input id="GPopacityRange_ID_Layer1" type="range" value="100" oninput="GPchangeLayerOpacity(this);" onchange="GPchangeLayerOpacity(this);">
    // </div>
    // <div class="GPlayerOpacityValue" id="GPopacityValueDiv_ID_Layer1">
    //   <span id="GPopacityValue_ID_Layer1">100</span>
    //   %
    // </div>
    var list = []; // curseur pour changer l'opacité

    var divO = document.createElement("div");
    divO.id = this._addUID("GPopacity_ID_" + obj.id);
    divO.className = "GPlayerOpacity";
    divO.title = "Opacité";
    var opacity = typeof obj.opacity !== "undefined" ? obj.opacity : 1;
    opacity = Math.round(opacity * 100);
    var input = document.createElement("input");
    input.id = this._addUID("GPopacityValueDiv_ID_" + obj.id);
    input.type = "range";
    input.value = opacity; // add event for opacity change

    var context = this;

    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        context._onChangeLayerOpacity(e);
      });
    } else if (input.attachEvent) {
      // internet explorer
      input.attachEvent("onchange", function (e) {
        context._onChangeLayerOpacity(e);
      });
    }

    if (input.addEventListener) {
      input.addEventListener("input", function (e) {
        context._onChangeLayerOpacity(e);
      });
    } else if (input.attachEvent) {
      // internet explorer
      input.attachEvent("oninput", function (e) {
        context._onChangeLayerOpacity(e);
      });
    }

    divO.appendChild(input); // Valeur d'opacité

    var divC = document.createElement("div");
    divC.id = this._addUID("GPopacityValueDiv_ID_" + obj.id);
    divC.className = "GPlayerOpacityValue";
    var span = document.createElement("span");
    span.id = this._addUID("GPopacityValue_ID_" + obj.id);
    span.innerHTML = opacity + "%";
    divC.appendChild(span);
    list.push(divO);
    list.push(divC);
    return list;
  },
  // ################################################################### //
  // ############################ Layer info ########################### //
  // ################################################################### //

  /**
   * Creation du container du layer info (DOM)
   *
   * TODO GPlayerInfoPopup : ???
   * TODO GPlayerInfoLink  : mettre en forme les échelles !
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createContainerLayerInfoElement: function _createContainerLayerInfoElement(obj) {
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerInfoContent");
    var title = document.createElement("div");
    title.id = this._addUID("GPlayerInfoTitle");
    title.innerHTML = obj.title;
    container.appendChild(title);

    if (obj.quicklookUrl) {
      var quick = document.createElement("div");
      quick.id = this._addUID("GPlayerInfoQuicklook");
      quick.title = "Afficher un aperçu de la couche";
      var refquick = document.createElement("a");
      refquick.href = obj.quicklookUrl;
      refquick.appendChild(quick);
      container.appendChild(refquick);
    }

    var close = document.createElement("div");
    close.id = this._addUID("GPlayerInfoClose");
    close.title = "Fermer la fenêtre";
    var self = this;
    /** Call event function on close click */

    var onCloseClick = function onCloseClick() {
      document.getElementById(self._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
      var layers = document.getElementsByClassName("GPlayerInfoOpened");

      for (var i = 0; i < layers.length; i++) {
        layers[i].className = "GPlayerInfo";
      }
    };

    if (close.addEventListener) {
      close.addEventListener("click", onCloseClick);
    } else if (close.attachEvent) {
      // internet explorer
      close.attachEvent("onclick", onCloseClick);
    }

    container.appendChild(close);
    var desc = document.createElement("div");
    desc.id = this._addUID("GPlayerInfoDescription");
    desc.innerHTML = obj.description;
    container.appendChild(desc);

    if (obj.metadata) {
      var mtd = document.createElement("div");
      mtd.id = this._addUID("GPlayerInfoMetadata");
      var mtdtitle = document.createElement("div");
      mtdtitle.className = "GPlayerInfoSubtitle";
      mtdtitle.innerHTML = "Métadonnées";
      mtd.appendChild(mtdtitle);

      for (var i = 0; i < obj.metadata.length; i++) {
        var urlmtd = obj.metadata[i].url;
        var mtdlink = document.createElement("div");
        mtdlink.className = "GPlayerInfoLink";
        var refmtd = document.createElement("a");
        refmtd.href = urlmtd;
        refmtd.innerHTML = urlmtd;
        mtdlink.appendChild(refmtd);
        mtd.appendChild(mtdlink);
      }

      if (obj.metadata.length !== 0) {
        container.appendChild(mtd);
      }
    }

    if (obj.legends) {
      var lgd = document.createElement("div");
      lgd.id = this._addUID("GPlayerInfoLegend");
      var lgdtitle = document.createElement("div");
      lgdtitle.className = "GPlayerInfoSubtitle";
      lgdtitle.innerHTML = "Légende";
      lgd.appendChild(lgdtitle);
      var legends = {};
      var maxScale = obj.maxScaleDenominator || 560000000; // on crée un tableau temporaire pour ordonner les légendes selon le dénominateur d'échelle

      for (var k = 0; k < obj.legends.length; k++) {
        var minScale = obj.legends[k].minScaleDenominator;

        if (minScale) {
          var s = minScale.toString();
          minScale = Math.round(parseInt(s.substring(0, 3), 10) / 10) * Math.pow(10, s.length - 2);
        } else {
          minScale = 270;
        }

        legends[minScale] = obj.legends[k];
      }

      for (var scale in legends) {
        if (legends.hasOwnProperty(scale)) {
          var urllgd = legends[scale].url; // on n'affiche pas les légendes pointant vers "nolegend.jpg"

          if (typeof urllgd === "string" && urllgd.toLowerCase().indexOf("nolegend.jpg") === -1) {
            // TODO GPlayerInfoPopup
            var lgdlink = document.createElement("div");
            lgdlink.className = "GPlayerInfoLink";
            maxScale = legends[scale].maxScaleDenominator || maxScale;
            var reflgd = document.createElement("a");
            reflgd.href = urllgd;
            reflgd.innerHTML = "Du 1/" + scale + " au 1/" + maxScale;
            lgdlink.appendChild(reflgd);
            lgd.appendChild(lgdlink);
          } else {
            delete legends[scale];
          }
        }
      }

      if (Object.keys(legends).length !== 0) {
        container.appendChild(lgd);
      }
    }

    return container;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (LayerSwitcherDOM);

/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiDrag", function() { return MultiDragPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sortable", function() { return Sortable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Swap", function() { return SwapPlugin; });
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.14.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}

function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;

function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }

  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
          options = this.options;

      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;

        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }

        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }

      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}

function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);

  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }

  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect,
    // for selection with modifier key down (SHIFT)
multiDragSortable,
    initialFolding = false,
    // Initial multi-drag fold when drag started
folding = false,
    // Folding any other time
dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;

function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    if (sortable.options.supportPointer) {
      on(document, 'pointerup', this._deselectMultiDrag);
    } else {
      on(document, 'mouseup', this._deselectMultiDrag);
      on(document, 'touchend', this._deselectMultiDrag);
    }

    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';

        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }

        dataTransfer.setData('Text', data);
      }
    };
  }

  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;

      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }

      sortable._hideClone();

      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;

      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;

      var sortable = _ref5.sortable,
          cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');

        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;

      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }

      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      }); // Sort multi-drag elements

      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;

      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;

      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM
        sortable.captureAnimationState();

        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }

      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;

        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        } // Remove all auxiliary multidrag items from el, if sorting enabled


        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;

      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;

      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
      var options = this.options;

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }

        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }

          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;

            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });

      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
          children = parentEl.children; // Multi-drag selection

      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }

        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvt: evt
          }); // Modifier activated, select from last to dragEl

          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
                currentIndex = index(dragEl$1);

            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;

              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }

              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }

          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      } // Multi-drag drop


      if (dragStarted && this.isMultiDrag) {
        folding = false; // Do not "unfold" after around dragEl if reverted

        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();

          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;

                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect; // Prepare unfold animation

                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed


            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }

              multiDragIndex++;
            }); // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.

            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });

              if (update) {
                dispatchSortableEvent('update');
              }
            }
          } // Must be done after capturing individual rects (scroll bar)


          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }

        multiDragSortable = toSortable;
      } // Remove clones if necessary


      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();

      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

      if (evt && evt.button !== 0) return;

      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();

          multiDragSortable = sortable;
        }

        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },

      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;

      var oldIndicies = [],
          newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        }); // multiDragElements will already be sorted if folding

        var newIndex;

        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }

        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();

        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }

        return key;
      }
    }
  });
}

function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */


function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}

function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

/* harmony default export */ __webpack_exports__["default"] = (Sortable);



/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_GetFeatureInfo_GPgetFeatureInfoOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _CSS_Controls_GetFeatureInfo_GPgetFeatureInfoOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_GetFeatureInfo_GPgetFeatureInfoOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);
/* harmony import */ var _GfiUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(41);
/* harmony import */ var _Common_Controls_GetFeatureInfoDOM__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(176);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import OpenLayers

 // import local



 // import local with ol dependencies

 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("getfeatureinfo");
/**
 * @classdesc
 * OpenLayers Control to manage getFeatureInfo capability. All queryable layers can be requested.
 * For the vector objects the information displayed are the objects properties. For the wms and wmts layers
 * this is the response of the getFeatureInfo request which is shown to the user.
 *
 * @constructor
 * @alias ol.control.GetFeatureInfo
 * @extends {ol.control.Control}
 * @param {Object} options - control options
 * @param {Array.<Object>} [options.layers] - list of layers which can be requested through the control. Each array element is an object, with following properties :
 * @param {ol.layer.Layer} options.layers.obj - {@link http://openlayers.org/en/latest/apidoc/ol.layer.Layer.html ol.layer.Layer} layer handled by the control (that has been added to map).
 * @param {String} [options.layers.event] - name of the mouse event triggering getFeatureInfo on this layer (that has been added to map). allowed values are : 'singleclick', 'dblclick' and 'contextmenu'. If not specified the triggering event is the current default event (see options.options.defaultEvent).
 * @param {String} [options.layers.infoFormat] - indicates the format mime-type of the response of GetFeatureInfo requests.
 * @param {Object} [options.options] - custom options object to configure the control, with following properties :
 * @param {Boolean} [options.options.hidden=false] - specifies if the widget should be hidden.
 * @param {Boolean} [options.options.auto=false] - specifies if the control run in automatic mode. In automatic mode all vector layers added on run time or added at map initialization can be requested through the control. The triggering event of those layers is the default event.
 * @param {Boolean} [options.options.active=true] - specifies if the control is active or inactive. In inactive mode requests are not fired and no information are displayed.
 * @param {String} [options.options.defaultEvent="singleclick"] - default triggering event chosen in the list ('singleclick', 'dblclick', 'contextmenu'). This is the triggering event of all layers added to the control without configured triggering event.
 * @param {String} [options.options.defaultInfoFormat="text/html"] - indicates the default format mime-type of the response of GetFeatureInfo requests.
 * @param {String} [options.options.cursorStyle="pointer"] - specifies the type of cursor to be displayed when pointing on vector feature of a layer previously added to the control. The value must be choosen in the possible values of the css cursor property.
 * @param {String} [options.options.proxyUrl] - Proxy URL to avoid cross-domain problems.
 * @param {Array.<String>} [options.options.noProxyDomains] - Proxy will not be used for this list of domain names. Only use if you know what you're doing.
 * @param {Boolean} [options.options.autoPan = true] - Specifies whether the map should auto-pan if the pop-up is rendered outside of the canvas. Defaults to true.
 * @param {Object} [options.options.autoPanAnimation] - Used to customize the auto-pan animation. See {@link https://openlayers.org/en/latest/apidoc/module-ol_Overlay.html#~PanOptions PanOptions}.
 * @param {Number} [options.options.autoPanMargin] - Margin (in pixels) between the pop-up and the border of the map when autopanning. Default is 20.
 */

var GetFeatureInfo = function (Control) {
  function GetFeatureInfo(options) {
    options = options || {};

    var _options = options.options || {};

    var _layers = options.layers || [];

    if (!(this instanceof GetFeatureInfo)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    if (!Array.isArray(_layers)) {
      throw new Error("ERROR WRONG_TYPE : layers should be an array");
    }

    if (_typeof(_options) !== "object") {
      throw new Error("ERROR WRONG_TYPE : options should be an object");
    }

    this._initialize(_options, _layers); // init control DOM container


    var container = this._container = this._initContainer(_options); // call ol.control.Control constructor


    Control.call(this, {
      element: container,
      target: _options.target,
      render: _options.render
    });
  }

  ; // Inherits from ol.control.Control

  if (Control) GetFeatureInfo.__proto__ = Control;
  /**
   * @lends module:GetFeatureInfo
   */

  GetFeatureInfo.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune GetFeatureInfoDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].assign(GetFeatureInfo.prototype, _Common_Controls_GetFeatureInfoDOM__WEBPACK_IMPORTED_MODULE_6__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  GetFeatureInfo.prototype.constructor = GetFeatureInfo; // ################################################################### //
  // ######################## initialize control ####################### //
  // ################################################################### //

  /**
   * Initializes GetFeatureInfo control (called by constructor)
   *
   * @param {Object} options - General options of the control set by user.
   * @param {Array.<Object>} layers - Array of ol layers with their configuration options (obj, event, infoFormat)
   * @private
   */

  GetFeatureInfo.prototype._initialize = function (options, layers) {
    // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)
    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate(); // List of triggering events associated to a boolean indicating if the event is listened (there must be
    // almost one layer having this triggering event configured)

    this._events = {
      dblclick: false,
      singleclick: false,
      contextmenu: false
    }; // Object associating a event (key) to his handler (value) in order to unlisten events which have
    // no more layers related to.

    this._eventsHandler = {};

    if (typeof options.auto !== "undefined" && typeof options.auto !== "boolean") {
      logger.log("[ERROR] GetFeatureInfo:_initialize - auto parameter should be a boolean");
      return;
    }

    this._auto = options.auto || false;

    if (typeof options.active !== "undefined" && typeof options.active !== "boolean") {
      logger.log("[ERROR] GetFeatureInfo:_initialize - active parameter should be a boolean");
      return;
    }

    this._active = typeof options.active === "undefined" ? true : options.active;

    if (options.defaultEvent && typeof options.defaultEvent !== "string") {
      logger.log("[ERROR] GetFeatureInfo:_initialize - defaultEvent parameter should be a string");
      return;
    }

    this._defaultEvent = options.defaultEvent || "singleclick";

    if (!this._isValidEvent(this._defaultEvent)) {
      logger.log("[ERROR] GetFeatureInfo:_initialize - _defaultEvent '" + this._defaultEvent + "' is not a valid event");
      return;
    }

    if (options.defaultInfoFormat && typeof options.defaultInfoFormat !== "string") {
      logger.log("[ERROR] GetFeatureInfo:_initialize - defaultInfoFormat parameter should be a string");
      return;
    }

    this._defaultInfoFormat = options.defaultInfoFormat || "text/html";

    if (options.cursorStyle && typeof options.cursorStyle !== "string") {
      logger.log("[ERROR] GetFeatureInfo:_initialize - cursorStyle parameter should be a string");
      return;
    }

    this._cursorStyle = options.cursorStyle || "pointer";

    if (options.proxyUrl) {
      if (typeof options.proxyUrl !== "string") {
        logger.log("[ERROR] GetFeatureInfo:_initialize - proxyUrl parameter should be a string");
        return;
      }

      this._proxyUrl = options.proxyUrl;
    }

    if (options.noProxyDomains) {
      if (!Array.isArray(options.noProxyDomains)) {
        logger.log("[ERROR] GetFeatureInfo:_initialize - noProxyDomains parameter should be a array");
        return;
      }

      this._noProxyDomains = options.noProxyDomains;
    }

    if (typeof options.autoPan !== "undefined" && typeof options.autoPan !== "boolean") {
      logger.log("[ERROR] GetFeatureInfo:_initialize - autoPan parameter should be a boolean");
      return;
    }

    this._autoPan = typeof options.autoPan === "undefined" ? true : options.autoPan;

    if (options.autoPanAnimation) {
      if (options.autoPanAnimation.duration) {
        if (typeof options.autoPanAnimation.duration !== "number") {
          logger.log("[ERROR] GetFeatureInfo:_initialize - autoPanAnimation parameter is invalid : duration should be a number.");
          return;
        }
      }

      if (options.autoPanAnimation.easing) {
        if (typeof options.autoPanAnimation.easing !== "function") {
          logger.log("[ERROR] GetFeatureInfo:_initialize - autoPanAnimation parameter is invalid : easing should be a ol.easing function or a custom function.");
          return;
        }
      }

      this._autoPanAnimation = options.autoPanAnimation;
    }

    if (options.autoPanMargin) {
      if (typeof options.autoPanMargin !== "number") {
        logger.log("[ERROR] GetFeatureInfo:_initialize - autoPanMargin parameter should be a number");
        return;
      }

      this._autoPanMargin = options.autoPanMargin;
    } // {Object} control layers list.


    if (!Array.isArray(layers)) {
      logger.log("[ERROR] GetFeatureInfo:_initialize - layers parameter should be an array");
      return;
    }

    this._setLayers(layers); // {Object} control panel container (DOM Element)


    this._activateGetFeatureInfoContainer = null;
  };
  /**
   * Binds map to control.
   *
   * @param {ol.Map} map - Map.
   */


  GetFeatureInfo.prototype.setMap = function (map) {
    var _this = this;

    if (map) {
      // on active les evenements (si des couches sont configurees)
      this._updateEvents(map);

      if (this._cursorStyle && this._active) {
        this._activateCursor(true, map);
      }

      map.getLayers().on("remove", function (evt) {
        for (var i = 0; i < _this._layers.length; ++i) {
          if (_this._layers[i].obj === evt.element) {
            _this._layers.splice(i, 1);

            break;
          }
        }

        _this._updateEvents(map);
      });

      if (this._auto) {
        // ajout des couches vecteur deja dans la carte
        var updated = false;
        map.getLayers().forEach(function (olLayer) {
          var layerFormat = _GfiUtils__WEBPACK_IMPORTED_MODULE_5__["default"].getLayerFormat(olLayer);

          if (!_this._hasLayer(olLayer) && layerFormat === "vector") {
            _this._layers.push({
              obj: olLayer
            });

            updated = true;
          }
        });

        if (updated) {
          this._updateEvents(map);
        }

        map.getLayers().on("add", function (evt) {
          var layerFormat = _GfiUtils__WEBPACK_IMPORTED_MODULE_5__["default"].getLayerFormat(evt.element);

          if (layerFormat === "vector") {
            _this._layers.push({
              obj: evt.element
            });
          }

          _this._updateEvents(map);
        });
      }
    } else {
      this._clearEvents();

      this._activateCursor(false);
    } // call original setMap method


    Control.prototype.setMap.call(this, map);
  }; // ################################################################### //
  // #################### user interface methods ####################### //
  // ################################################################### //

  /**
   * Gets the list of layers already added to the map and attached to the control.
   *
   * @returns {Array.<Object>} gfiLayers List of layers.
   * @returns {ol.layer.Layer} gfiLayers.obj {@link http://openlayers.org/en/latest/apidoc/ol.layer.Layer.html ol.layer.Layer} layer handled by the control (that has been added to map).
   * @returns {String} gfiLayers.event Optional. Name of the mouse event triggering getFeatureInfo on this layer (that has been added to map). allowed values are : 'singleclick', 'dblclick' and 'contextmenu'.
   * @returns {String} gfiLayers.infoFormat Optional. Indicates the format mime-type of the response of GetFeatureInfo requests.
   */


  GetFeatureInfo.prototype.getLayers = function () {
    return this._layers;
  };
  /**
   * Sets the default event applied to layer with no triggering event configured.
   * This can be set on run time.
   *
   * @param {String} eventName - name of the mouse event chosen in the list : 'singleclick', 'dblclick', 'contextmenu'.
   */


  GetFeatureInfo.prototype.setDefaultEvent = function (eventName) {
    if (typeof eventName !== "string") {
      logger.log("[ERROR] GetFeatureInfo:setDefaultEvent - eventName parameter should be a string");
      return;
    }

    if (!eventName || !this._isValidEvent(eventName)) {
      logger.log("[ERROR] GetFeatureInfo:setDefaultEvent - event '" + eventName + "' is not allowed.");
      return;
    }

    this._defaultEvent = eventName;

    this._updateEvents();
  };
  /**
   * Sets the cursor style when hovering vector layers features.
   *
   * @param {String} cursorStyle - cursor style. The value must be choosen in the possible values of the css cursor property.
   */


  GetFeatureInfo.prototype.setCursorStyle = function (cursorStyle) {
    if (typeof cursorStyle !== "string") {
      logger.log("[ERROR] GetFeatureInfo:setCursorStyle - cursorStyle parameter should be a string");
      return;
    }

    if (this._active) {
      if (!this._cursorStyle && cursorStyle) {
        this._activateCursor(true);
      } else if (this._cursorStyle && !cursorStyle) {
        this._activateCursor(false);
      }
    }

    this._cursorStyle = cursorStyle;
  };
  /**
   * Sets active control property
   *
   * @param {Boolean} active - specify the value the active property must be set to.
   */


  GetFeatureInfo.prototype.setActive = function (active) {
    this._setActive(active);

    var element = document.getElementById(this._addUID("GPactivateGetFeatureInfo"));

    if (element) {
      element.checked = active;
    }
  };
  /**
   * Sets active control property
   *
   * @param {Boolean} active - specify the value the active property must be set to.
   *
   * @private
   */


  GetFeatureInfo.prototype._setActive = function (active) {
    if (typeof active !== "boolean") {
      logger.log("[ERROR] GetFeatureInfo:_setActive - active parameter should be a boolean");
      return;
    }

    if (this._active === active) {
      return;
    }

    this._active = active;

    if (this._cursorStyle) {
      this._activateCursor(active);
    }
  };
  /**
   * Gets active control property
   *
   * @return {Boolean} active
   */


  GetFeatureInfo.prototype.isActive = function () {
    return this._active;
  };
  /**
   * Hides/displays widget
   *
   * @param {Boolean} hidden - specify if the widget must be hidden
   */


  GetFeatureInfo.prototype.setHidden = function (hidden) {
    this.element.style.visibility = hidden ? "hidden" : "";
  };
  /**
   * Indicates if the widget is hidden
   *
   * @return {Boolean} is hidden
   */


  GetFeatureInfo.prototype.isHidden = function () {
    return this.element.style.visibility === "hidden";
  };
  /**
   * Set the layers list the control is attached to. Listened events are updated according to this list.
   *
   * @param {Array.<Object>} gfiLayers - list of layers which can be requested through the control.
   * @param {ol.layer.Layer} gfiLayers.obj - {@link http://openlayers.org/en/latest/apidoc/ol.layer.Layer.html ol.layer.Layer} layer handled by the control (that has been added to map).
   * @param {String} [gfiLayers.event] - Name of the mouse event triggering getFeatureInfo on this layer (that has been added to map). allowed values are : 'singleclick', 'dblclick' and 'contextmenu'.
   * @param {String} [gfiLayers.infoFormat] - Indicates the format mime-type of the response of GetFeatureInfo requests.
   */


  GetFeatureInfo.prototype.setLayers = function (gfiLayers) {
    this._setLayers(gfiLayers);

    this._updateEvents();
  };
  /**
   * Indicates if an event is allowed
   *
   * @param {String} eventName - name of the mouse event chosen in the list : 'singleclick', 'dblclick', 'contextmenu'.
   *
   * @returns {Boolean} is valid event
   *
   * @private
   */


  GetFeatureInfo.prototype._isValidEvent = function (eventName) {
    return Object.keys(this._events).indexOf(eventName) > -1;
  };
  /**
   * Adds an event listener to the specified event.
   *
   * @param {String} eventName - name of the mouse event chosen in the list : 'singleclick', 'dblclick', 'contextmenu'.
   * @param {Object} map - map on wich event are attached.
   *
   * @private
   */


  GetFeatureInfo.prototype._activateEvent = function (eventName, map) {
    var gfiObj = this;

    var getFeatureInfoHandler = function getFeatureInfoHandler(e) {
      _GfiUtils__WEBPACK_IMPORTED_MODULE_5__["default"].onDisplayFeatureInfo(e, gfiObj);
    };

    if (eventName === "contextmenu") {
      map.getViewport().addEventListener(eventName, getFeatureInfoHandler);
    } else {
      map.on(eventName, getFeatureInfoHandler);
    }

    this._eventsHandler[eventName] = getFeatureInfoHandler;
    this._events[eventName] = true;
  };
  /**
   * Unlistens the specified event.
   * @param {String} eventName - name of the mouse event chosen in the list : 'singleclick', 'dblclick', 'contextmenu'.
   * @param {Object} map - map on wich event are attached.
   *
   * @private
   */


  GetFeatureInfo.prototype._deactivateEvent = function (eventName, map) {
    if (eventName === "contextmenu") {
      map.getViewport().removeEventListener(eventName, this._eventsHandler[eventName]);
    } else {
      map.un(eventName, this._eventsHandler[eventName]);
    }

    delete this._eventsHandler[eventName];
    this._events[eventName] = false;
  };
  /**
   * Updates the listener (listen/unlisten) in accordance with the layers attached to the control and their triggering events.
   *
   * @param {Object} map - map on wich event are attached.
   *
   * @private
   */


  GetFeatureInfo.prototype._updateEvents = function (map) {
    if (!map) {
      map = this.getMap();
    }

    var sEvent = [];

    for (var i = 0; i < this._layers.length; ++i) {
      var event = this._layers[i].event ? this._layers[i].event : this._defaultEvent;

      if (sEvent.indexOf(event) < 0) {
        sEvent.push(event);
      }
    }

    for (var eventName in this._events) {
      if (!this._events[eventName] && sEvent.indexOf(eventName) >= 0) {
        this._activateEvent(eventName, map);
      } else if (this._events[eventName] && sEvent.indexOf(eventName) < 0) {
        this._deactivateEvent(eventName, map);
      }
    }
  };
  /**
   * Clears all the listeners.
   *
   * @private
   */


  GetFeatureInfo.prototype._clearEvents = function () {
    var map = this.getMap();

    for (var eventName in this._events) {
      if (this._events[eventName]) {
        this._deactivateEvent(eventName, map);
      }
    }
  };
  /**
   * Indicates if the control has the specified layer attached
   *
   * @param {ol.layer.Layer} olLayer - layer openlayers
   *
   * @returns {Boolean} has layer
   *
   * @private
   */


  GetFeatureInfo.prototype._hasLayer = function (olLayer) {
    for (var i = 0; i < this._layers.length; ++i) {
      if (this._layers[i].obj === olLayer) {
        return true;
      }
    }

    return false;
  };
  /**
   * Listens/unlistens 'pointermove' event displaying specific cursor style when hovering vector features
   *
   * @param {Boolean} activate - specify if the control must be activated or deactivated
   * @param {Object} map - map on wich cursor is attached.
   *
   * @private
   */


  GetFeatureInfo.prototype._activateCursor = function (activate, map) {
    if (!map) {
      map = this.getMap();
    }

    if (activate) {
      if (this._eventsHandler.hasOwnProperty("pointermove")) {
        logger.log("[ERROR] _activateCursor - inconsistent state: pointermove event handler already registered");
        return;
      }

      var gfiObj = this;

      var displayCursor = function displayCursor(evt) {
        var hit = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {
          // on ne prend en compte que les couches vecteurs connues du controle
          var gfiLayers = gfiObj.getLayers();

          for (var m = 0; m < gfiLayers.length; ++m) {
            if (gfiLayers[m].obj === layer) {
              return true;
            }
          }
        });

        if (hit) {
          map.getTargetElement().style.cursor = gfiObj._cursorStyle;
        } else {
          map.getTargetElement().style.cursor = "";
        }
      };

      this._eventsHandler["pointermove"] = displayCursor;
      map.on("pointermove", displayCursor);
    } else {
      if (this._eventsHandler.hasOwnProperty("pointermove")) {
        // si le widget n'a jamais ete active l'evenement pointermove n'existe pas
        map.un("pointermove", this._eventsHandler["pointermove"]);
        delete this._eventsHandler["pointermove"];
      }

      map.getTargetElement().style.cursor = "";
    }
  };
  /**
   * Sets the layers list the control is attached to.
   * @param {Array.<Object>} gfiLayers - list of layers which can be requested through the control.
   *
   * @private
   */


  GetFeatureInfo.prototype._setLayers = function (gfiLayers) {
    if (!gfiLayers || !Array.isArray(gfiLayers)) {
      logger.log("[ERROR] GetFeatureInfo:setLayers - gfiLayers parameter should be a array");
      return;
    }

    this._layers = [];

    for (var i = 0; i < gfiLayers.length; ++i) {
      var ind = this._layers.push({}) - 1;

      if (gfiLayers[i].event) {
        if (!this._isValidEvent(gfiLayers[i].event)) {
          logger.log("[ERROR] GetFeatureInfo:setLayers - layer event '" + this._layers[i].event + "' is not allowed.");
        } else {
          this._layers[ind].event = gfiLayers[i].event;
        }
      }

      if (gfiLayers[i].infoFormat) {
        this._layers[ind].infoFormat = gfiLayers[i].infoFormat;
      }

      this._layers[ind].obj = gfiLayers[i].obj;
    }
  }; // ################################################################### //
  // ######################## methods handle dom ####################### //
  // ################################################################### //

  /**
   * This method is called by event 'change' on 'GPactivateGetFeatureInfo'
   * tag select (cf. this._createActivateGetFeatureInfoElement).
   *
   * @method onActivateGetFeatureInfoElementChange
   * @param {Object} e - HTMLElement
   *
   * @private
   */


  GetFeatureInfo.prototype.onActivateGetFeatureInfoElementChange = function (e) {
    this._setActive(e.target.checked);
  };
  /**
   * Creates control main container (called by GetFeatureInfo constructor)
   * @param {Object} [options] - options object to configure the widget :
   * @param {Boolean} [options.hidden] - specifies if the widget should be hidden.
   *
   * @return {DOMElement} DOM element
   *
   * @method _initContainer
   *
   * @private
   */


  GetFeatureInfo.prototype._initContainer = function (options) {
    // creation du container principal
    var container = this._createMainContainerElement();

    var inputActivate = this._activateGetFeatureInfoContainer = this._createActivateGetFeatureInfoElement(this.isActive());

    container.appendChild(inputActivate); // ajout dans le container principal du picto du controle

    var picto = this._createMainPictoElement();

    container.appendChild(picto);

    if (typeof options.hidden !== "undefined") {
      if (typeof options.hidden !== "boolean") {
        logger.log("[ERROR] GetFeatureInfo:_initContainer - hidden parameter should be a boolean");
        return;
      }

      if (options.hidden) {
        container.style.visibility = "hidden";
      }
    }

    return container;
  };

  return GetFeatureInfo;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (GetFeatureInfo); // Expose GetFeatureInfo as ol.control.GetFeatureInfo (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.GetFeatureInfo = GetFeatureInfo;
}

/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var GetFeatureInfoDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPgetFeatureInfo");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //

  /**
   * Hidden checkbox for activating getFeatureInfo
   * @param {Boolean} activate - specify if the control is active or inactive
   *
   * @returns {DOMElement} DOM element
   */
  _createActivateGetFeatureInfoElement: function _createActivateGetFeatureInfoElement(activate) {
    // contexte d'execution
    var context = this;
    var input = document.createElement("input");
    input.id = this._addUID("GPactivateGetFeatureInfo");
    input.type = "checkbox";
    input.checked = activate;
    input.addEventListener("change", function (e) {
      context.onActivateGetFeatureInfoElementChange(e);
    });
    return input;
  },

  /**
   * Creation du container du picto du controle (DOM)
   * @returns {DOMElement} DOM element
   */
  _createMainPictoElement: function _createMainPictoElement() {
    var self = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPgetFeatureInfoPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPactivateGetFeatureInfo");
    label.title = "activer/desactiver l'interrogation des couches";
    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPgetFeatureInfoActivate");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    var spanClose = document.createElement("span");
    spanClose.id = self._addUID("GPgetFeatureInfoDeactivate");
    label.appendChild(spanClose);
    return label;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (GetFeatureInfoDOM);

/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_SearchEngine_GPsearchEngineOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _CSS_Controls_SearchEngine_GPsearchEngineOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_SearchEngine_GPsearchEngineOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(147);
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(178);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(179);
/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_SearchEngineUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(181);
/* harmony import */ var _Common_Controls_SearchEngineDOM__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(182);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import OpenLayers



 // import geoportal library access

 // import local







 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__["default"].getLogger("searchengine");
/**
 * @classdesc
 * SearchEngine control
 *
 * @constructor
 * @extends {ol.control.Control}
 * @alias ol.control.SearchEngine
 * @param {Object}  options - control options
 * @param {String}   [options.apiKey] - API key, mandatory if autoconf service has not been charged in advance
 * @param {Boolean}   [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.collapsed = true] - collapse mode, true by default
 * @param {String|Numeric|Function} [options.zoomTo] - zoom to results, by default, current zoom.
 *       Value possible : auto or zoom level.
 *       Possible to overload it with a function :
 *       zoomTo : function (info) {
 *           // do some stuff...
 *           return zoom;
 *       }
 * @param {String}  [options.placeholder] - Placeholder in search bar. Default is "Rechercher un lieu, une adresse".
 * @param {Boolean} [options.displayMarker = true] - set a marker on search result, defaults to true.
 * @param {String}  [options.markerStyle = "lightOrange"] - Marker style. Currently possible values are "lightOrange" (default value), "darkOrange", "red" and "turquoiseBlue".
 * @param {Boolean} [options.displayAdvancedSearch = true] - False to disable advanced search tools (it will not be displayed). Default is true (displayed)
 * @param {Object}  [options.advancedSearch] - advanced search options for geocoding (filters). Properties can be found among geocode options.filterOptions (see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~geocode Gp.Services.geocode})
 * @param {Object}  [options.resources] - resources to be used by geocode and autocompletion services :
 * @param {Array}   [options.resources.geocode] - resources geocoding, by default : ["PositionOfInterest", "StreetAddress"]
 * @param {Array}   [options.resources.autocomplete] - resources autocompletion, by default : ["PositionOfInterest", "StreetAddress"]
 * @param {Object}  [options.geocodeOptions = {}] - options of geocode service
 * @param {Object}  [options.geocodeOptions.apiKey] - to overload the check of rights (only) on the given apiKey for the geocode service
 * @param {Object}  [options.geocodeOptions.filterOptions = {}] - filteroptions of the geocode service
 * @param {Array}   [options.geocodeOptions.filterOptions.type = []] - to overload the check of rights (only) on the given type of resources used by the geocode service.
 * @param {Object}  [options.geocodeOptions.serviceOptions] - overload other options : options of geocode service from the access-lib API (see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~geocode Gp.Services.geocode})
 * @param {Object}  [options.autocompleteOptions = {}] - options of autocomplete service
 * @param {Object}  [options.autocompleteOptions.apiKey] - to overload the check of rights (only) on the given apiKey for the the autocomplete service
 * @param {Object}  [options.autocompleteOptions.filterOptions = {}] - filteroptions of the autocomplete service
 * @param {Array}   [options.autocompleteOptions.filterOptions.type = []] - to overload the check of rights (only) on the given type of resources used by the autocomplete service
 * @param {Object}  [options.autocompleteOptions.serviceOptions] - overload other options : options of autocomplete service from the access-lib API (see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete})
 * @param {Boolean} [options.autocompleteOptions.triggerGeocode = false] - trigger a geocoding request if the autocompletion does not return any suggestions, false by default
 * @param {Number}  [options.autocompleteOptions.triggerDelay = 1000] - waiting time before sending the geocoding request, 1000ms by default
 * @fires searchengine:compute
 * @example
 *  var SearchEngine = ol.control.SearchEngine({
 *      apiKey : "CLEAPI",
 *      collapsed : true,
 *      resources : {
 *          geocode : ["StreetAddress", "PositionOfInterest"],
 *          autocomplete : ["StreetAddress"]
 *      },
 *      advancedSearch : {
 *          PositionOfInterest : [{name : "municipality", title : "Ville"}],
 *          StreetAddress : [{...}]
 *      },
 *      geocodeOptions : {},
 *      autocompleteOptions : {}
 *  });
 */

var SearchEngine = function (Control) {
  function SearchEngine(options) {
    options = options || {};

    if (!(this instanceof SearchEngine)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // initialisation du composant


    this.initialize(options); // // Widget main DOM container

    this._container = this._initContainer(); // info: le container sera complété lors de l'ajout à la carte (setMap), car certains composants nécessitent d'être liés à la map.

    this._containerElement = null; // on peut éventuellement encapsuler le composant dans une div passée par l'utilisateur

    if (options.element && options.element.appendChild) {
      // dans ce cas on stocke les deux container
      options.element.appendChild(this._container);
      this._containerElement = options.element;
    } // call ol.control.Control constructor


    Control.call(this, {
      element: this._containerElement || this._container,
      target: options.target,
      render: options.render
    });
  }

  ; // Inherits from ol.control.Control

  if (Control) SearchEngine.__proto__ = Control;
  /*
   * @lends module:SearchEngine
   */

  SearchEngine.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune IsoDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_6__["default"].assign(SearchEngine.prototype, _Common_Controls_SearchEngineDOM__WEBPACK_IMPORTED_MODULE_12__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  SearchEngine.prototype.constructor = SearchEngine; // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */

  SearchEngine.prototype.setMap = function (map) {
    if (!map) {
      this._clearResults();
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */


  SearchEngine.prototype.getCollapsed = function () {
    return this.collapsed;
  };
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */


  SearchEngine.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.log("[ERROR] SearchEngine:setCollapsed - missing collapsed parameter");
      return;
    }

    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }

    this._showSearchEngineInput.click();

    this.collapsed = collapsed;
  };
  /**
   * Get locations data from geocode service
   *
   * @returns {Object} data - locations
   */


  SearchEngine.prototype.getData = function () {
    return this._geocodedLocations;
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize SearchEngine control (called by SearchEngine constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */


  SearchEngine.prototype.initialize = function (options) {
    this._checkInputOptions(options); // define default options


    this.options = {
      collapsed: true,
      zoomTo: "",
      resources: {
        geocode: [],
        autocomplete: []
      },
      displayAdvancedSearch: true,
      advancedSearch: {},
      geocodeOptions: {
        serviceOptions: {}
      },
      autocompleteOptions: {
        serviceOptions: {},
        triggerGeocode: false,
        triggerDelay: 1000
      },
      displayMarker: true,
      markerStyle: "lightOrange",
      placeholder: "Rechercher un lieu, une adresse"
    }; // merge with user options

    _Common_Utils__WEBPACK_IMPORTED_MODULE_6__["default"].mergeParams(this.options, options);

    if (this.options.resources.geocode.length === 0) {
      this.options.resources.geocode = ["PositionOfInterest", "StreetAddress"];
    }

    if (this.options.resources.autocomplete.length === 0) {
      this.options.resources.autocomplete = ["PositionOfInterest", "StreetAddress"];
    }
    /** {Boolean} specify if searchEngine control is collapsed (true) or not (false) */


    this.collapsed = this.options.collapsed; // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__["default"].generate();
    this._showSearchEngineInput = null; // container de l'input de recherche

    this._inputSearchContainer = null; // container des reponses de l'autocompletion

    this._autocompleteContainer = null;
    this._suggestedContainer = null; // listes des reponses de l'autocompletion

    this._suggestedLocations = []; // container des reponses du geocodage

    this._geocodedContainer = null; // liste des reponses du geocodage

    this._geocodedLocations = []; // container des filtres du geocodage

    this._filterContainer = null; // ressource de geocodage selectionnée pour le geocodage avancé

    this._currentGeocodingCode = null; // localisant */

    this._currentGeocodingLocation = null; // liste des filtres du geocodage pour le geocodage avancé

    this._advancedSearchFilters = {};

    this._initAdvancedSearchFilters(); // liste des ressources du geocodage pour le geocodage avancé


    this._advancedSearchCodes = [];

    this._initAdvancedSearchCodes(); // marker


    this._marker = null; // marker style

    var _markerStyle = this.options.markerStyle;
    this._markerUrl = Object.keys(_Utils_Markers__WEBPACK_IMPORTED_MODULE_7__["default"]).indexOf(_markerStyle) === -1 ? _Utils_Markers__WEBPACK_IMPORTED_MODULE_7__["default"]["lightOrange"] : _Utils_Markers__WEBPACK_IMPORTED_MODULE_7__["default"][_markerStyle]; // marker display

    this._displayMarker = this.options.displayMarker; // popup

    this._popupContent = null;
    this._popupDiv = this._initPopupDiv();
    this._popupOverlay = null; // ressources des services d'autocompletion et de geocodage

    this._servicesRightManagement = {};
    /*
     * Droit sur les ressources sur les services.
     * Par defaut, on n'en s'occupe pas
     * sauf si l'autoconfiguration est chargée !
     */

    this._noRightManagement = false; // gestion des droits sur les ressources/services

    this._checkRightsManagement(); // trigger geocode


    this._triggerHandler = null;
  };
  /**
   * this method is called by this.initialize()
   * and makes sure input options are correctly formated
   *
   * @param {Object} options - options
   *
   * @private
   */


  SearchEngine.prototype._checkInputOptions = function (options) {
    var i;

    if (options.resources) {
      // on vérifie que resources est bien un objet
      if (_typeof(options.resources) === "object") {
        // ressources de geocodage
        var geocodeResources = options.resources.geocode;

        if (geocodeResources) {
          // on vérifie que la liste des ressources de geocodage est bien un tableau
          if (Array.isArray(geocodeResources)) {
            var geocodeResourcesList = ["StreetAddress", "PositionOfInterest", "CadastralParcel", "Administratif"];

            for (i = 0; i < geocodeResources.length; i++) {
              if (geocodeResourcesList.indexOf(geocodeResources[i]) === -1) {
                // si la resource n'est pas référencée, on l'enlève
                // geocodeResources.splice(i, 1);
                logger.log("[SearchEngine] options.resources.geocode : " + geocodeResources[i] + " is not a resource for geocode");
              }
            }
          } else {
            logger.log("[SearchEngine] 'options.resources.geocode' parameter should be an array");
            geocodeResources = null;
          }
        } // ressources d'autocompletion


        var autocompleteResources = options.resources.autocomplete;

        if (autocompleteResources) {
          // on vérifie que la liste des ressources d'autocompletion est bien un tableau
          if (Array.isArray(autocompleteResources)) {
            var autocompleteResourcesList = ["StreetAddress", "PositionOfInterest"];

            for (i = 0; i < autocompleteResources.length; i++) {
              if (autocompleteResourcesList.indexOf(autocompleteResources[i]) === -1) {
                // si la resource n'est pas référencée, on l'enlève
                // autocompleteResources.splice(i, 1);
                logger.log("[SearchEngine] options.resources.autocomplete : " + autocompleteResources[i] + " is not a resource for autocomplete");
              }
            }
          } else {
            logger.log("[SearchEngine] 'options.resources.autocomplete' parameter should be an array");
            autocompleteResources = null;
          }
        }
      } else {
        logger.log("[SearchEngine] 'resources' parameter should be an object");
        options.resources = null;
      }
    }
  };
  /**
   * this method is called by this.initialize()
   * and initialize the geocoding resources titles.
   *
   * @private
   */


  SearchEngine.prototype._initAdvancedSearchCodes = function () {
    // INFORMATION
    // on y ajoute les filtres attributaires pour une table de ressources
    // selectionnée via un evenement (onchange) de la liste deroulante du
    // menu avancé du geocodage.
    // cf. onGeocodingAdvancedSearchCodeChange() pour la selection de la
    // ressource de geocodage à afficher
    var geocodeResources = this.options.resources.geocode;

    for (var i = 0; i < geocodeResources.length; i++) {
      switch (geocodeResources[i]) {
        case "PositionOfInterest":
          this._advancedSearchCodes.push({
            id: "PositionOfInterest",
            title: "Lieux/toponymes"
          });

          break;

        case "StreetAddress":
          this._advancedSearchCodes.push({
            id: "StreetAddress",
            title: "Adresses"
          });

          break;

        case "CadastralParcel":
          this._advancedSearchCodes.push({
            id: "CadastralParcel",
            title: "Parcelles cadastrales"
          });

          break;

        case "Administratif":
          this._advancedSearchCodes.push({
            id: "Administratif",
            title: "Administratif"
          });

          break;

        default:
          break;
      }
    } // par défaut, au cas où aucune ressource passée en option ne correspond à celles attendues


    if (this._advancedSearchCodes.length === 0) {
      this._advancedSearchCodes = [{
        id: "StreetAddress",
        title: "Adresses"
      }, {
        id: "PositionOfInterest",
        title: "Lieux/toponymes"
      }];
    }

    logger.log("advancedSearchCodes", this._advancedSearchCodes);
  };
  /**
   * this method is called by this.onAdd()
   * and initialize the advanced geocoding filters.
   *
   * @private
   */


  SearchEngine.prototype._initAdvancedSearchFilters = function () {
    // liste des filtres par defauts pour toutes les ressources
    this._advancedSearchFilters = _Common_Utils_SearchEngineUtils__WEBPACK_IMPORTED_MODULE_11__["default"].advancedSearchFiltersByDefault; // on merge les options avancées avec celles par defaut

    var advancedSearchFiltersCustom = this.options.advancedSearch;
    _Common_Utils__WEBPACK_IMPORTED_MODULE_6__["default"].assign(this._advancedSearchFilters, advancedSearchFiltersCustom);
    logger.log("advancedSearchFilters", this._advancedSearchFilters);
  };
  /**
   * this method is called by this.initialize() and initialize popup div
   * (to display results information on marker click)
   *
   * @return {Object} element - DOM element for popup
   * @private
   */


  SearchEngine.prototype._initPopupDiv = function () {
    var context = this;
    var element = document.createElement("div");
    element.className = "gp-feature-info-div";
    var closer = document.createElement("input");
    closer.type = "button";
    closer.className = "gp-styling-button closer"; // on closer click : remove popup

    closer.onclick = function () {
      if (context._popupOverlay != null) {
        context._popupOverlay.setPosition(undefined);
      }

      return false;
    };

    this._popupContent = document.createElement("div");
    this._popupContent.className = "gp-features-content-div";
    this._popupContent.style["min-width"] = "200px";
    element.appendChild(this._popupContent);
    element.appendChild(closer);
    return element;
  }; // ################################################################### //
  // ######################## DOM initialize ########################### //
  // ################################################################### //

  /**
   * Create control main container
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  SearchEngine.prototype._initContainer = function () {
    // create main container
    var container = this._createMainContainerElement(); // create show search engine element


    var inputShow = this._showSearchEngineInput = this._createShowSearchEngineElement();

    container.appendChild(inputShow); // mode "collapsed"

    if (!this.options.collapsed) {
      inputShow.checked = true;
    } // create search engine picto


    var picto = this._createShowSearchEnginePictoElement();

    container.appendChild(picto);

    var search = this._inputSearchContainer = this._createSearchInputElement(this.options.placeholder);

    var context = this;

    if (search.addEventListener) {
      search.addEventListener("click", function () {
        context.onAutoCompleteInputClick();
      });
    } else if (search.attachEvent) {
      search.attachEvent("onclick", function () {
        context.onAutoCompleteInputClick();
      });
    }

    container.appendChild(search);

    if (this.options.displayAdvancedSearch) {
      var advancedShow = this._createShowAdvancedSearchElement();

      container.appendChild(advancedShow); // INFO je decompose les appels car j'ai besoin de recuperer le container
      // des filtres

      var advancedPanel = this._createAdvancedSearchPanelElement();

      var advancedHeader = this._createAdvancedSearchPanelHeaderElement();

      var advancedForm = this._createAdvancedSearchPanelFormElement(this._advancedSearchCodes);

      var advancedFormFilters = this._filterContainer = this._createAdvancedSearchFormFiltersElement();

      this._setFilter(this._advancedSearchCodes[0].id); // ex "PositionOfInterest"


      var advancedFormInput = this._createAdvancedSearchFormInputElement();

      advancedForm.appendChild(advancedFormFilters);
      advancedForm.appendChild(advancedFormInput);
      advancedPanel.appendChild(advancedHeader);
      advancedPanel.appendChild(advancedForm);
      container.appendChild(advancedPanel);
    } // INFO je decompose les appels car j'ai besoin de recuperer le container
    // des resultats de l'autocompletion


    var autocomplete = this._autocompleteContainer = this._createAutoCompleteElement();

    var autocompleteList = this._suggestedContainer = this._createAutoCompleteListElement();

    autocomplete.appendChild(autocompleteList);
    container.appendChild(autocomplete); // INFO je decompose les appels car j'ai besoin de recuperer le container
    // des resultats du geocodage

    var geocode = this._createGeocodeResultsElement();

    var geocodeList = this._geocodedContainer = this._createGeocodeResultsListElement();

    geocode.appendChild(geocodeList);
    container.appendChild(geocode);
    return container;
  };
  /**
   * this method is called by :
   * - this._initContainer() : ...
   * - this.onGeocodingAdvancedSearchCodeChoice() : ...
   * and initialize or create the filters container HTMLElement
   * to the geocoding advanced menu.
   *
   * @param {String} code - resource geocoding name
   *
   * @returns {DOMElement} DOM element
   * @private
   */


  SearchEngine.prototype._setFilter = function (code) {
    // INFORMATION
    // Nous avons 2 solutions possibles pour la mise en place des filtres.
    // 1. Soit on decide de creer tous les filtres pour chaque ressource
    // de geocodage à l'initialisation du composant, et on joue sur le
    // mode 'hidden' pour n'afficher que la ressource selectionnée.
    // 2. Soit on decide de creer à chaque fois les filtres pour la
    // ressource selectionnée.
    // Chaque solution a ses inconvenients/avantages.
    // Implementation du choix 2 car elle offre plus de souplesse pour
    // recuperer les 'form-data'...
    var container = this._filterContainer;
    var codeFound = false;

    for (var i = 0; i < this._advancedSearchCodes.length; i++) {
      if (this._advancedSearchCodes[i].id === code) {
        codeFound = true;
        break;
      }
    }

    if (!codeFound) {
      // cette ressource n'est pas disponible,
      // on supprime les anciens enfants...
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }

      return;
    } // on sauvegarde la ressource de geocodage sélectionnée


    this._currentGeocodingCode = code; // on supprime les enfants...

    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }

    var lstAttributs = this._advancedSearchFilters[code];

    if (!lstAttributs || lstAttributs.length === 0) {
      // cette ressource n'est pas parametrable
      return;
    }

    var divTable = this._createAdvancedSearchFiltersTableElement(code, true);

    for (var j = 0; j < lstAttributs.length; j++) {
      var divFilter = this._createAdvancedSearchFiltersAttributElement(lstAttributs[j]);

      divTable.appendChild(divFilter);
    }

    container.appendChild(divTable);
    return container;
  }; // ################################################################### //
  // ##################### methods rights management ################### //
  // ################################################################### //

  /**
   * this method is called by constructor
   * and check the rights to resources and services
   *
   * @private
   */


  SearchEngine.prototype._checkRightsManagement = function () {
    // INFORMATION
    // l'autoconfiguration n'est utile que pour récupérer la clef si elle
    // n'est pas renseignée, et pour vérifier les droits sur les ressources
    // et les services.
    // si l'autoconfiguration n'est pas chargée,
    // il est toujours possible de requeter le service avec une clef API,
    // mais les droits sur les ressources ne sont pas garantis, on risque
    // d'obtenir des erreurs 403 forbidden..., la responsabilité revient
    // à l'utilisateur (message d'information)...
    // par contre, sans clef API renseignée au niveau du controle,
    // l'utilisateur doit la renseigner au niveau des services...,
    // sinon, Exception du service
    // si l'autoconfiguration est chargée,
    // si une clef API est renseignée au niveau controle, on controle
    // le mapping entre le contrat et la clef...
    // on obtient la liste des ressources ayant droits,
    // si on ne trouve pas de ressources ou certaines ressources ne sont
    // pas disponible, on previent l'utilisateur (message d'information).
    var _resources = [];

    var _key;

    var _opts = null; // les ressources du service d'autocompletion

    _key = this.options.autocompleteOptions.apiKey;
    _opts = this.options.autocompleteOptions.filterOptions; // on récupère les éventuelles ressources passées en option, soit dans autocompleteOptions

    _resources = _opts ? _opts.type : []; // soit dans options.resources.autocomplete

    if (!_resources || _resources.length === 0) {
      _resources = this.options.resources.autocomplete;
    } // ou celles par défaut sinon.


    if (!_resources || _resources.length === 0) {
      _resources = ["StreetAddress", "PositionOfInterest"];
    }

    var rightManagementAutoComplete = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_9__["default"].check({
      key: _key || this.options.apiKey,
      resources: _resources,
      services: ["AutoCompletion"]
    });
    logger.log("rightManagementAutoComplete", rightManagementAutoComplete); // les ressources du service de geocodage

    _key = this.options.geocodeOptions.apiKey;
    _opts = this.options.geocodeOptions.filterOptions; // on récupère les éventuelles ressources passées en option, soit dans geocodeOptions :

    _resources = _opts ? _opts.type : []; // soit directement dans options.resources.geocode :

    if (!_resources || _resources.length === 0) {
      _resources = this.options.resources.geocode;
    } // ou celles par défaut sinon.


    if (!_resources || _resources.length === 0) {
      _resources = ["StreetAddress", "PositionOfInterest"];
    }

    var rightManagementGeocode = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_9__["default"].check({
      key: _key || this.options.apiKey,
      resources: _resources,
      services: ["Geocode"]
    });
    logger.log("rightManagementGeocode", rightManagementGeocode); // aucun droit !

    if (!rightManagementAutoComplete && !rightManagementGeocode) {
      this._noRightManagement = true;
      return;
    } // on recupère les informations utiles
    // Ex. la clef API issue de l'autoconfiguration si elle n'a pas
    // été renseignée.


    if (!this.options.apiKey) {
      if (rightManagementGeocode) {
        this.options.apiKey = rightManagementGeocode.key;
      } else {
        this.options.apiKey = rightManagementAutoComplete.key;
      }
    } // les ressources par services ayant droit doivent servir pour les
    // appels aux services


    if (rightManagementAutoComplete) {
      this._servicesRightManagement["AutoCompletion"] = rightManagementAutoComplete["AutoCompletion"];
    }

    if (rightManagementGeocode) {
      this._servicesRightManagement["Geocode"] = rightManagementGeocode["Geocode"];
    }
  }; // ################################################################### //
  // ################ methods to request and results ################### //
  // ################################################################### //

  /**
   * this method is called by this.onAutoCompleteSearch()
   * and executes a request to the service.
   *
   * @param {Object} settings - service settings
   * @param {String}   settings.text - text
   * @param {Function} settings.onSuccess - callback
   * @param {Function} settings.onFailure - callback
   * @private
   */


  SearchEngine.prototype._requestAutoComplete = function (settings) {
    // on ne fait pas de requête si on n'a pas renseigné de parametres !
    if (!settings || _typeof(settings) === "object" && Object.keys(settings).length === 0) {
      return;
    } // on ne fait pas de requête si la parametre 'text' est vide !


    if (!settings.text) {
      return;
    }

    logger.log(settings);
    var options = {}; // on recupere les options du service

    _Common_Utils__WEBPACK_IMPORTED_MODULE_6__["default"].assign(options, this.options.autocompleteOptions.serviceOptions); // ainsi que la recherche et les callbacks

    _Common_Utils__WEBPACK_IMPORTED_MODULE_6__["default"].assign(options, settings); // on ajoute le paramètre filterOptions.type spécifiant les ressources.

    var resources = this.options.resources.autocomplete;

    if (resources && Array.isArray(resources)) {
      if (!options.filterOptions) {
        options.filterOptions = {};
      } // il se peut que l'utilisateur ait surchargé ce paramètre dans geocodeOptions,


      if (!options.filterOptions.type) {
        options.filterOptions.type = resources;
      }
    } // cas où la clef API n'est pas renseignée dans les options du service,
    // on utilise celle de l'autoconf ou celle renseignée au niveau du controle


    options.apiKey = options.apiKey || this.options.apiKey; // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
    // true par défaut (https)

    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }

    logger.log(options);
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_4__["default"].Services.autoComplete(options);
  };
  /**
   * this method is called by this.onAutoCompleteSearchText() (case of success)
   * and fills the container of the location list.
   * it creates a HTML Element per location
   *
   * @param {Array} locations - Array of Gp.Services.AutoComplete.SuggestedLocation corresponding to autocomplete results list
   * @private
   */


  SearchEngine.prototype._fillAutoCompletedLocationListContainer = function (locations) {
    if (!locations || locations.length === 0) {
      return;
    } // on vide la liste avant de la construire


    var element = this._suggestedContainer;

    if (element.childElementCount) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    this._displaySuggestedLocation();

    for (var i = 0; i < locations.length; i++) {
      // Proposals are dynamically filled in Javascript by autocomplete service
      this._createAutoCompletedLocationElement(locations[i], i);
    }
  };
  /**
   * this method is called by this.onAutoCompleteSearch()
   * and executes a request to the service.
   *
   * @param {Object} settings - service settings
   * @param {String}   settings.location - text
   * @param {Function} settings.onSuccess - callback
   * @param {Function} settings.onFailure - callback
   * @private
   */


  SearchEngine.prototype._requestGeocoding = function (settings) {
    // on ne fait pas de requête si on n'a pas renseigné de parametres !
    if (!settings || _typeof(settings) === "object" && Object.keys(settings).length === 0) {
      return;
    } // on ne fait pas de requête si la parametre 'text' est vide !


    if (!settings.location) {
      return;
    }

    logger.log(settings);
    var options = {};
    options.returnFreeForm = true; // on recupere les options du service

    _Common_Utils__WEBPACK_IMPORTED_MODULE_6__["default"].assign(options, this.options.geocodeOptions.serviceOptions); // ainsi que la recherche et les callbacks

    _Common_Utils__WEBPACK_IMPORTED_MODULE_6__["default"].assign(options, settings); // on redefinie les callbacks si les callbacks de service existent

    var self = this;
    var bOnFailure = !!(this.options.geocodeOptions.serviceOptions.onFailure !== null && typeof this.options.geocodeOptions.serviceOptions.onFailure === "function"); // cast variable to boolean

    var bOnSuccess = !!(this.options.geocodeOptions.serviceOptions.onSuccess !== null && typeof this.options.geocodeOptions.serviceOptions.onSuccess === "function");

    if (bOnSuccess) {
      var cbOnSuccess = function cbOnSuccess(e) {
        settings.onSuccess.call(self, e);
        self.options.geocodeOptions.serviceOptions.onSuccess.call(self, e);
      };

      options.onSuccess = cbOnSuccess;
    }

    if (bOnFailure) {
      var cbOnFailure = function cbOnFailure(e) {
        settings.onFailure.call(self, e);
        self.options.geocodeOptions.serviceOptions.onFailure.call(self, e);
      };

      options.onFailure = cbOnFailure;
    } // on ajoute le paramètre filterOptions.type spécifiant les ressources.


    var resources = this.options.resources.geocode;

    if (resources && Array.isArray(resources)) {
      if (!options.filterOptions) {
        options.filterOptions = {};
      } // il se peut que l'utilisateur ait surchargé ce paramètre dans geocodeOptions,
      // ou qu'il ait déjà été rempli (cas de la recherche avancée)


      if (!options.filterOptions.type) {
        options.filterOptions.type = resources;
      }
    } // cas où la clef API n'est pas renseignée dans les options du service,
    // on utilise celle de l'autoconf ou celle renseignée au niveau du controle


    options.apiKey = options.apiKey || this.options.apiKey; // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
    // true par défaut (https)

    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }

    logger.log(options);
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_4__["default"].Services.geocode(options);
  };
  /**
   * this method is called by this.onGeocodingSearch()
   * and fills the container of the location results.
   * it creates a HTML Element per location
   * (cf. this. ...)
   *
   * @param {Object[]} locations - locations
   *
   * @private
   */


  SearchEngine.prototype._fillGeocodedLocationListContainer = function (locations) {
    if (!locations || locations.length === 0) {
      this._clearGeocodedLocation();

      return;
    } // on vide la liste avant de la construire


    var element = this._geocodedContainer;

    if (element.childElementCount) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    for (var i = 0; i < locations.length; i++) {
      logger.log(locations[i]); // Proposals are dynamically filled in Javascript by autocomplete service

      this._createGeocodedLocationElement(locations[i], i);
    } // sauvegarde de l'etat des locations


    this._geocodedLocations = locations;
    /**
     * event triggered when the compute is finished
     *
     * @event searchengine:compute
     * @property {Object} type - event
     * @property {Object} target - instance SearchEngine
     * @example
     * ReverseGeocode.on("searchengine:compute", function (e) {
     *   console.log(e.target.getData());
     * })
     */

    this.dispatchEvent({
      type: "searchengine:compute"
    });
  }; // ################################################################### //
  // ######################### other methods ########################### //
  // ################################################################### //

  /**
   * this sends the label to the panel.
   *
   * @param {String} label - label suggested location
   * @private
   */


  SearchEngine.prototype._setLabel = function (label) {
    document.getElementById("GPsearchInputText-" + this._uid).value = label;
  };
  /**
   * this method is called by this.on*ResultsItemClick()
   * and move/zoom on a position.
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] (en lat/lon : "EPSG:4326")
   * @param {Number} zoom - zoom level
   * @private
   */


  SearchEngine.prototype._setPosition = function (position, zoom) {
    var view = this.getMap().getView();
    view.setCenter(position);
    view.setZoom(zoom);
  };
  /**
   * this method is called by this.on*ResultsItemClick()
   * and displays a marker.
   * FIXME
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] ou [x, y]
   * @param {Object} info - location information
   * @private
   */


  SearchEngine.prototype._setMarker = function (position, info) {
    var map = this.getMap();
    var context = this; // remove previous markers

    if (this._marker != null) {
      map.removeOverlay(this._marker);
      this._marker = null;
    }

    if (position) {
      // création de l'élément DOM
      var markerDiv = document.createElement("img");
      markerDiv.src = this._markerUrl; // ajout de l'évènement onclick (pour afficher une popup)

      if (markerDiv.addEventListener) {
        markerDiv.addEventListener("click", function () {
          context._onResultMarkerSelect(info);
        });
      } else if (markerDiv.attachEvent) {
        // Internet Explorer
        markerDiv.attachEvent("onclick", function () {
          context._onResultMarkerSelect(info);
        });
      } // création du marker (overlay)


      this._marker = new ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default.a({
        position: position,
        offset: [-25.5, -38],
        element: markerDiv,
        stopEvent: false
      });
      map.addOverlay(this._marker);
    }
  };
  /**
   * this method is called by this.on*ResultsItemClick()
   * and get zoom to results.
   *
   * @param {Object} info - info
   *
   * @returns {Integer} zoom
   * @private
   */


  SearchEngine.prototype._getZoom = function (info) {
    var map = this.getMap();
    var key = this.options.zoomTo;
    var zoom = null; // les valeurs du zooms sont determinées
    // soit par les mots clefs suivants :  max, min ou auto
    // soit par un niveau de zoom
    // soit defini par l'utilisateur via une fonction

    if (typeof key === "function") {
      logger.trace("zoom function");
      zoom = key.call(this, info);
    }

    if (typeof key === "number") {
      logger.trace("zoom level");
      zoom = key;
    }

    if (typeof key === "string") {
      // if (key === "max") {
      //     zoom = map.getMaxZoom();
      // } else if (key === "min") {
      //     zoom = map.getMinZoom();
      // } else
      if (key === "auto") {
        logger.trace("zoom auto");
        zoom = _Common_Utils_SearchEngineUtils__WEBPACK_IMPORTED_MODULE_11__["default"].zoomToResultsByDefault(info);
      } else {
        logger.trace("zoom level parsing");
        var value = parseInt(key, 10);

        if (!isNaN(value)) {
          logger.trace("zoom parsing");
          zoom = value;
        }
      }
    } // polyfill IE


    Number.isInteger = Number.isInteger || function (value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }; // test de validité du zoom,
    // on prend le zoom courant par defaut ...


    if (!zoom || zoom === "" || !Number.isInteger(zoom)) {
      logger.trace("zoom not found, current zoom...");
      zoom = map.getView().getZoom();
    } // FIXME test si le zoom est dans l'espace de la carte


    var min = map.minZoom; // .getMinZoom();

    var max = map.maxZoom; // .getMaxZoom();

    if (zoom < min) {
      logger.trace("zoom level min...");
      zoom = min;
    }

    if (zoom > max) {
      logger.trace("zoom level max...");
      zoom = max;
    }

    logger.trace("zoom", zoom);
    return zoom;
  };
  /**
   * this method is called on 'click' on this._marker
   * (cf. this._setMarker() )
   * and sets a popup with marker information
   *
   * @param {Object} information - location information
   * @private
   */


  SearchEngine.prototype._onResultMarkerSelect = function (information) {
    var map = this.getMap();
    var popupContent = "";

    if (information.attributes) {
      // si on a des attributes (freeform = false)
      popupContent = "<ul>";
      var attributes = information.attributes;

      for (var attr in attributes) {
        if (attributes.hasOwnProperty(attr)) {
          if (attr !== "bbox") {
            popupContent += "<li>";
            popupContent += "<span class=\"gp-attname-others-span\">" + attr.toUpperCase() + " : </span>";
            popupContent += attributes[attr];
            popupContent += " </li>";
          }
        }
      }

      popupContent += " </ul>";
    } else {
      // freeform
      popupContent = information.label;
    }

    this._popupContent.innerHTML = popupContent;

    if (!this._popupOverlay) {
      // ajout de la popup a la carte comme un overlay
      this._popupOverlay = new ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default.a({
        element: this._popupDiv,
        positioning: "bottom-center",
        position: this._marker.getPosition(),
        offset: [0, -42]
      });
      map.addOverlay(this._popupOverlay);
    } else {
      // si l'overlay est déjà créé, on modifie juste sa position
      this._popupOverlay.setPosition(this._marker.getPosition());
    }
  }; // ################################################################### //
  // ###################### other handlers events ###################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on 'GPshowSearchEnginePicto' tag label
   * (cf. this._createShowSearchEnginePictoElement), and it cleans the component
   * when it's closed.
   *
   * @private
   */


  SearchEngine.prototype.onShowSearchEngineClick = function () {
    var map = this.getMap(); // on supprime toutes les interactions

    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_8__["default"].unset(map);
    this.collapsed = this._showSearchEngineInput.checked; // on génère nous même l'evenement OpenLayers de changement de propriété
    // (utiliser ol.control.SearchEngine.on("change:collapsed", function ) pour s'abonner à cet évènement)

    this.dispatchEvent("change:collapsed");
  };
  /**
   * this method is called by event 'click' on 'GPsearchInputReset' tag div
   * (cf. this._createSearchInputElement), and it cleans the value of input.
   *
   * @private
   */


  SearchEngine.prototype.onSearchResetClick = function () {
    this._clearResults();
  }; // ################################################################### //
  // ################## handlers events AutoComplete ################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on 'GPlocationOrigin' input
   *
   * @private
   */


  SearchEngine.prototype.onAutoCompleteInputClick = function () {
    var inputSearchTextContainer = document.getElementById("GPsearchInputText-" + this._uid);

    if (inputSearchTextContainer && !inputSearchTextContainer.disabled && inputSearchTextContainer.value.length > 2) {
      this._displaySuggestedLocation();
    }
  };
  /**
   * this method is called by event 'keyup' on 'GPsearchInputText' tag input
   * (cf. this._createSearchInputElement), and it gets the value of input.
   * this value is passed as a parameter for the service autocomplete (text).
   * the results of the request are displayed into a drop down menu.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  SearchEngine.prototype.onAutoCompleteSearchText = function (e) {
    var value = e.target.value;

    if (!value) {
      return;
    } // aucun droits !
    // on evite une requête...


    if (this._noRightManagement) {
      logger.log("no rights for this service !");
      return;
    } // on sauvegarde le localisant


    this._currentGeocodingLocation = value; // on limite les requêtes à partir de 3 car. saisie !

    if (value.length < 3) {
      this._clearSuggestedLocation();

      return;
    }

    var _triggerGeocode = this.options.autocompleteOptions.triggerGeocode;
    var _triggerDelay = this.options.autocompleteOptions.triggerDelay; // INFORMATION
    // on effectue la requête au service d'autocompletion.
    // on met en place des callbacks afin de recuperer les resultats ou
    // les messages d'erreurs du service.
    // les resultats sont affichés dans une liste deroulante.

    var context = this;

    this._requestAutoComplete({
      text: value,
      // callback onSuccess
      onSuccess: function onSuccess(results) {
        logger.log("request from AutoComplete", results);

        if (results) {
          // on sauvegarde l'etat des résultats
          context._suggestedLocations = results.suggestedLocations;
          context._locationsToBeDisplayed = []; // on vérifie qu'on n'a pas récupéré des coordonnées nulles (par ex recherche par code postal)

          for (var i = 0; i < context._suggestedLocations.length; i++) {
            var ilocation = context._suggestedLocations[i];

            if (ilocation.position && ilocation.position.x === 0 && ilocation.position.y === 0 && ilocation.fullText) {
              // si les coordonnées sont nulles, il faut relancer une requête de géocodage avec l'attribut "fullText" récupéré
              context._getGeocodeCoordinatesFromFullText(ilocation, i);
            } else {
              // sinon on peut afficher normalement le résultat dans la liste
              context._locationsToBeDisplayed.push(ilocation);
            }
          }

          ; // on affiche les résultats qui n'ont pas des coordonnées nulles

          context._fillAutoCompletedLocationListContainer(context._locationsToBeDisplayed); // on annule eventuellement une requete de geocodage en cours car on obtient des
          // de nouveau des resultats d'autocompletion...


          if (context._triggerHandler) {
            clearTimeout(context._triggerHandler);
            context._triggerHandler = null;
            logger.warn("Cancel a geocode request !");
          }
        }
      },
      // callback onFailure
      onFailure: function onFailure(error) {
        // FIXME
        // où affiche t on les messages : ex. 'No suggestion matching the search' ?
        context._clearSuggestedLocation();

        logger.log(error.message); // on envoie une requete de geocodage si aucun resultat d'autocompletion
        // n'a été trouvé ! Et on n'oublie pas d'annuler celle qui est en cours !

        if (error.message === "No suggestion matching the search" && _triggerGeocode
        /* && value.length === 5 */
        ) {
          if (context._triggerHandler) {
            clearTimeout(context._triggerHandler);
            logger.warn("Cancel the last geocode request !");
          }

          context._triggerHandler = setTimeout(function () {
            logger.warn("Launch a geocode request (code postal) !");

            context._requestGeocoding({
              location: value,
              returnFreeForm: true,
              // callback onSuccess
              onSuccess: function onSuccess(results) {
                logger.log("request from Geocoding", results);

                if (results) {
                  context._locationsToBeDisplayed = []; // on modifie la structure des reponses pour être
                  // compatible avec l'autocompletion !

                  var locations = results.locations;

                  for (var i = 0; i < locations.length; i++) {
                    var location = locations[i];
                    location.fullText = location.placeAttributes.freeform;
                    location.position = {
                      x: location.position.y,
                      y: location.position.x
                    };

                    context._locationsToBeDisplayed.push(location);
                  }

                  context._fillAutoCompletedLocationListContainer(locations);
                }
              },
              // callback onFailure
              onFailure: function onFailure(error) {
                logger.log(error.message);
              }
            });
          }, _triggerDelay);
        }
      }
    });

    var map = this.getMap();
    map.on("click", this._hideSuggestedLocation, this);
    map.on("pointerdrag", this._hideSuggestedLocation, this);
  };
  /**
   * this method is called by Gp.Services.autoComplete callback in case of success
   * (cf. this.onAutoCompleteSearchText), for suggested locations with null coordinates
   * (case of postalCode research for instance).
   * Send a geocode request with suggested location 'fullText' attribute, to get its coordinates and display it in autocomplete results list container.
   *
   * @param {Gp.Services.AutoCompleteResponse.SuggestedLocation} suggestedLocation - autocompletion result (with null coordinates) to be geocoded
   * @param {Number} i - suggestedLocation position in Gp.Services.AutoCompleteResponse.suggestedLocations autocomplete results list
   * @private
   */


  SearchEngine.prototype._getGeocodeCoordinatesFromFullText = function (suggestedLocation, i) {
    var context = this;
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_4__["default"].Services.geocode({
      apiKey: this.options.apiKey,
      ssl: this.options.ssl,
      location: suggestedLocation.fullText,
      filterOptions: {
        type: suggestedLocation.type
      },
      // callback onSuccess
      onSuccess: function onSuccess(response) {
        logger.log("request from Geocoding (coordinates null)", response);

        if (response.locations && response.locations.length !== 0 && response.locations[0].position) {
          // on modifie les coordonnées du résultat en EPSG:4326 donc lat,lon
          if (context._suggestedLocations && context._suggestedLocations[i]) {
            context._suggestedLocations[i].position = {
              x: response.locations[0].position.y,
              y: response.locations[0].position.x
            }; // et on l'affiche dans la liste

            context._locationsToBeDisplayed.unshift(context._suggestedLocations[i]);

            context._fillAutoCompletedLocationListContainer(context._locationsToBeDisplayed);
          }
        }
      },
      // callback onFailure
      onFailure: function onFailure() {
        // si on n'a pas réussi à récupérer les coordonnées, on affiche quand même le résultat
        if (context._suggestedLocations && context._suggestedLocations[i]) {
          context._createAutoCompletedLocationElement(context._suggestedLocations[i], i);
        }
      }
    });
  };
  /**
   * this method is called by event 'click' on 'GPautoCompleteResultsList' tag div
   * (cf. this._createAutoCompleteListElement), and it selects the location.
   * this location displays a marker on the map.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  SearchEngine.prototype.onAutoCompletedResultsItemClick = function (e) {
    // TODO on souhaite un comportement different pour la selection des reponses
    // de l'autocompletion :
    // - liste deroulante des reponses,
    // - puis possibilité de cliquer sur une suggestion
    // - mais aussi de la choisir avec le clavier (arrow up/down), puis valider
    // par un return
    // cette selection avec les fleches doit mettre à jour le input !
    // (comme un moteur de recherche de navigateur)
    var idx = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__["default"].index(e.target.id);
    logger.log(idx);
    logger.log(this._locationsToBeDisplayed[idx]);

    if (!idx) {
      return;
    }

    var position = [this._locationsToBeDisplayed[idx].position.x, this._locationsToBeDisplayed[idx].position.y];
    var info = {
      service: "SuggestedLocation",
      type: this._locationsToBeDisplayed[idx].type,
      fields: this._locationsToBeDisplayed[idx]
    }; // on ajoute le texte de l'autocomplétion dans l'input

    var label = this._locationsToBeDisplayed[idx].fullText;

    this._setLabel(label);

    info.label = label; // Info : la position est en EPSG:4326, à transformer dans la projection de la carte

    var view = this.getMap().getView();
    var mapProj = view.getProjection().getCode();

    if (mapProj !== "EPSG:4326") {
      // on retransforme les coordonnées de la position dans la projection de la carte
      position = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(position, "EPSG:4326", mapProj);
    } // on centre la vue et positionne le marker, à la position reprojetée dans la projection de la carte


    var zoom = this._getZoom(info);

    this._setPosition(position, zoom);

    if (this._displayMarker) {
      this._setMarker(position, info);
    }
  }; // ################################################################### //
  // ################### handlers events Geocode ####################### //
  // ################################################################### //

  /**
   * this method is called by event 'submit' on 'GPsearchInput' tag form
   * (cf. this._createSearchInputElement), and it gets the value of input.
   * this value is passed as a parameter for the service geocoding.
   * the results of the request are displayed into a window.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  SearchEngine.prototype.onGeocodingSearchSubmit = function (e) {
    var value = e.target[0].value;

    if (!value) {
      return;
    } // aucun droits !
    // on evite une requête...


    if (this._noRightManagement) {
      logger.log("no rights for this service !");
      return;
    } // on sauvegarde le localisant


    this._currentGeocodingLocation = value; // on met en place l'affichage des resultats dans une fenetre de recherche.

    var context = this;

    this._requestGeocoding({
      location: value,
      // callback onSuccess
      onSuccess: function onSuccess(results) {
        logger.log("request from Geocoding", results);

        if (results) {
          var locations = results.locations;

          context._fillGeocodedLocationListContainer(locations);
        }
      },
      // callback onFailure
      onFailure: function onFailure(error) {
        // FIXME cf. this.onAutoCompleteSearch()
        context._clearGeocodedLocation();

        logger.log(error.message);
      }
    });
  };
  /**
   * this method is called by event 'submit' on 'GPgeocodeResultsList' tag div
   * (cf. this._createGeocodeResultsListElement), and it selects the location.
   * this location displays a marker on the map.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  SearchEngine.prototype.onGeocodedResultsItemClick = function (e) {
    var idx = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__["default"].index(e.target.id);

    if (!idx) {
      return;
    }

    var position = [this._geocodedLocations[idx].position.y, this._geocodedLocations[idx].position.x];
    var attributes = this._geocodedLocations[idx].placeAttributes;
    var info = {
      service: "DirectGeocodedLocation",
      type: this._geocodedLocations[idx].type,
      fields: this._geocodedLocations[idx]
    }; // on ajoute le texte du géocodage dans l'input

    var label;

    if (attributes.freeform) {
      // reponse en freeForm
      label = attributes.freeform;
    } else if (attributes.postalCode) {
      // cas des StreetAddress, PositionOfInterest, Administratif
      // on affiche uniquement ce qui est commun aux ressources ...
      label = attributes.postalCode + " " + attributes.commune;
      info.attributes = attributes;
    } else if (attributes.cadastralParcel) {
      // cas des CadastralParcel
      label = attributes.cadastralParcel;
      info.attributes = attributes;
    } else {
      label = "...";
    }

    this._setLabel(label);

    info.label = label; // Info : la position est en EPSG:4326, à transformer dans la projection de la carte

    var view = this.getMap().getView();
    var mapProj = view.getProjection().getCode();

    if (mapProj !== "EPSG:4326") {
      // on retransforme les coordonnées de la position dans la projection de la carte
      position = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(position, "EPSG:4326", mapProj);
    } // on centre la vue et positionne le marker, à la position reprojetée dans la projection de la carte


    var zoom = this._getZoom(info);

    this._setPosition(position, zoom);

    if (this._displayMarker) {
      this._setMarker(position, info);
    }
  }; // ################################################################### //
  // ############## handlers events Geocode Advanced ################### //
  // ################################################################### //

  /**
   * this method is called by event 'change' on 'GPadvancedSearchCode' tag select
   * (cf. this._createAdvancedSearchFormCodeElement), and it gets the value of
   * option selected.
   * this value is passed as a parameter to create the attributs container.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  SearchEngine.prototype.onGeocodingAdvancedSearchCodeChange = function (e) {
    logger.log(e);
    var idx = e.target.selectedIndex;
    var value = e.target.options[idx].value;

    if (!value) {
      return;
    } // INFORMATION
    // le declenchement de l'evenement va creer un container de filtre à la volée...
    // l'insertion des containers d'attributs dans le DOM sont :
    // - soit GPadvancedSearchFilters > PositionOfInterest
    // - soit GPadvancedSearchFilters > StreetAddress
    // - soit GPadvancedSearchFilters > CadastralParcel
    // cf. _setFilter() pour la creation du container


    this._setFilter(value);
  };
  /**
   * this method is called by event 'submit' on 'GPadvancedSearchForm' tag form
   * (cf. this._createAdvancedSearchPanelFormElement), and it gets the value of all input.
   * this value is passed as a parameter for the service geocoding.
   * the results of the request are displayed into a window.
   *
   * @param {Object} e - HTMLElement
   * @param {Array} data - [{key: ..., value: ...}]
   * @private
   */


  SearchEngine.prototype.onGeocodingAdvancedSearchSubmit = function (e, data) {
    logger.log(data);

    if (!data || data.length === 0) {
      return;
    }

    var _location;

    var _filterOptions = {};
    var filter;
    _filterOptions.type = [this._currentGeocodingCode];

    for (var i = 0; i < data.length; i++) {
      filter = data[i];
      _filterOptions[filter.key] = filter.value;
    }

    if (this._currentGeocodingCode === "CadastralParcel") {
      // dans ce cas, les filtres de recherche avancée ne sont pas vraiment des filtres,
      // mais simplement la décomposition des informations de la parcelle, à concaténer.
      _location = this._getCadastralParcelRequestParams(_filterOptions); // FIXME ne marche pas bien !

      _filterOptions = {
        type: [this._currentGeocodingCode]
      };
    } else {
      // recuperation des parametres des filtres pour les transmettre
      // à la requête, ainsi que le type de table de ressources de geocodage,
      // et le localisant (freeform)
      _location = this._currentGeocodingLocation;
    } // on met en place l'affichage des resultats dans une fenetre de recherche.


    var context = this;

    this._requestGeocoding({
      location: _location,
      filterOptions: _filterOptions,
      // callback onSuccess
      onSuccess: function onSuccess(results) {
        logger.log(results);

        if (results) {
          var locations = results.locations;

          context._fillGeocodedLocationListContainer(locations);
        }
      },
      // callback onFailure
      onFailure: function onFailure(error) {
        // FIXME cf. this.onAutoCompleteSearch()
        context._clearGeocodedLocation();

        logger.log(error.message);
      }
    });
  };
  /**
   * this method is called by 'onGeocodingAdvancedSearchSubmit' method,
   * in case geocoding type is 'CadastralParcel',
   * and gets request parameters from inputs
   *
   * @param {Object} filterOptions - object with inputs value (department, insee, ...)
   * @returns {String} location - cadastral parcel number : concatenation of inputs values (e.g. : 940670000D0041 or 94067_____0041)
   * @private
   */


  SearchEngine.prototype._getCadastralParcelRequestParams = function (filterOptions) {
    /* info:
        la parcelle cadastrale se compose de 14 chiffres ou lettres, indiquant, de gauche à droite :
        - le code du département (2 caractères)
        - le code commune (3 caractères). (Remarque : code département + code commune = code INSEE)
        - OU le code INSEE de la commune (5 chiffres) (remplace les 2 précédents)
        - le code commune absorbée INSEE, ou '000' (3 caractères),
        - la section (2 caractères),
        - le numéro de parcelle (4 caractères).
        Exemple de parcelle : '940670000D0041'. Si l'identifiant est incomplet (par exemple '940670000D'), le service renverra uniquement les 25 premiers résultats pouvant correspondre.
    */
    var _location = "";
    var l; // code département (2 caractères)

    var dep = filterOptions.department;

    if (dep) {
      l = dep.length;

      if (l === 2) {
        _location = dep;
      } else if (l === 1) {
        // si un seul numéro a été saisi, on présume que c'est un numéro < 10
        _location = "0" + dep;
      } else {
        _location = dep.substring(0, 2);
      }
    } else {
      _location = "__";
    } // code commune insee (3 caractères)


    var commune = filterOptions.commune;

    if (commune) {
      l = commune.length;

      if (l === 3) {
        _location += commune;
      } else if (l === 2) {
        _location += "_" + commune;
      } else if (l === 1) {
        _location += "__" + commune;
      } else {
        // l > 3
        _location += commune.substring(0, 3);
      }
    } else {
      _location += "___";
    } // code insee (5 caractères) : surcharge les 2 autres si renseigné


    var insee = filterOptions.insee;

    if (insee) {
      if (insee.length === 5) {
        _location = insee;
      }
    } // code commune absorbee INSEE (3 caractères)


    var absorbedCity = filterOptions.absorbedCity;

    if (absorbedCity) {
      l = absorbedCity.length;

      if (l === 3) {
        _location += absorbedCity;
      } else if (l < 3) {
        if (l === 2) {
          _location += "_" + absorbedCity;
        } else if (l === 1) {
          _location += "__" + absorbedCity;
        }
      } else {
        // l > 3
        _location += absorbedCity.substring(0, 3);
      }
    } else {
      _location += "___";
    } // section (2 caractères)


    var section = filterOptions.section;

    if (section) {
      l = section.length;

      if (l === 2) {
        _location += section;
      } else if (l === 1) {
        _location += "_" + section;
      } else {
        _location += section.substring(0, 2);
      }
    } else {
      _location += "__";
    } // numéro de parcelle (4 caractères)


    var number = filterOptions.number;

    if (number) {
      l = number.length;

      if (l === 4) {
        _location += number;
      } else if (l === 3) {
        _location += "_" + number;
      } else if (l === 2) {
        _location += "__" + number;
      } else if (l === 1) {
        _location += "___" + number;
      } else {
        // l > 4
        _location += number.substring(0, 4);
      }
    } else {
      _location += "___";
    }

    logger.log("location : " + _location);
    return _location;
  }; // ################################################################### //
  // ############################## clean ############################## //
  // ################################################################### //

  /**
   * this method is called by this.onSearchReset()
   * and it clears all results and the marker.
   *
   * @private
   */


  SearchEngine.prototype._clearResults = function () {
    var map = this.getMap();
    this._currentGeocodingLocation = null;

    this._clearSuggestedLocation();

    this._clearGeocodedLocation();

    this._setMarker(); // on retire l'overlay de la popup de la carte


    if (this._popupOverlay != null) {
      map.removeOverlay(this._popupOverlay);
      this._popupOverlay = null;
    }
  };
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and it clears all suggested location.
   *
   * @private
   */


  SearchEngine.prototype._clearSuggestedLocation = function () {
    this._suggestedLocations = [];

    if (this._suggestedContainer) {
      while (this._suggestedContainer.firstChild) {
        this._suggestedContainer.removeChild(this._suggestedContainer.firstChild);
      }
    }
  };
  /**
   * this method is called by event 'click' on map
   * and it hides suggested locations
   *
   * @private
   */


  SearchEngine.prototype._hideSuggestedLocation = function () {
    if (this._autocompleteContainer) {
      this._autocompleteContainer.style.display = "none";
    }
  };
  /**
   * this method is called by event 'click' on label input
   * and it displays suggested location.
   *
   * @private
   */


  SearchEngine.prototype._displaySuggestedLocation = function () {
    if (this._autocompleteContainer) {
      this._autocompleteContainer.style.display = "block";
    }
  };
  /**
   * this method is called by this.onGeocodingAdvancedSearchSubmit()
   * and it clears all geocoded location.
   *
   * @private
   */


  SearchEngine.prototype._clearGeocodedLocation = function () {
    this._geocodedLocations = [];

    if (this._geocodedContainer) {
      while (this._geocodedContainer.firstChild) {
        this._geocodedContainer.removeChild(this._geocodedContainer.firstChild);
      }
    }
  };

  return SearchEngine;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (SearchEngine); // Expose SearchEngine as ol.control.SearchEngine (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.SearchEngine = SearchEngine;
}

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var Marker = {
  lightOrange: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARDSURBVFiF3ZndaxxVGMZ/Z/YjX00Nadpo1qrFBgu56D9QbAtiLoRC7ywSNK1NURRREBKRFlSwFBW0gnSrJXY1CmISgyjFiyYSFC9ajE3MmpjdjWlMUtNos9lN9mteLzbRuCbZmTMTBB+Yi51znvd5n3nPnjnnjBIR/i/wuh4xpCpI0ojiENAA1AE1wCzwKzCE0EM5l2iShJvSyrXKnFVb8dOK4hmg3AIjifAmaU7ztMy7kYI7Zs6rQwjvka+AXcyiOMZx6XGahuE0AEHVitCFnhGAGoQugqrVaSrOKpNP4FWnSaxCGy1yWpesbyY/tLpwo7p/w0RxWHfI6Zk5q7ZSwhj6Q2sjzJLiXp1JQe+p+mllc4wA1CzHtw37lQmpCha5gbXpVxdJythh9z1kvzJJGrFixPBmOXixl+Z4mONmguZ4mIMXezG8WQsq5cs6tmDfTP7NXiSqN0vTzBD1TQfwbdmDUhX4tuyhvukATTNDlgxZ0SmUtUsgv0TZGPsv9FNSvXfNtpLqvey/0O+KTgF0zNQV7XHP4dsdtVvVKYCOmeqiPbwVOx21W9UpgI6ZWNEe2cSEo3arOgWwb0YYLp5G17Sjdqs6BdCZzYqL9B3dR2puYM221NwAfUf3uaJTAB0zaye5GmbWS6i2gdFQL5mFMCIJMgthRkO9hGobMLPFN4VWdAoptlcAQeUDRoG77YrZwDhQT4tk7JDsV6ZFMggv2+bZwyt2jYDuQnOa94GIFrc4IkzRrkPUM3NKsijatLjF0copsbJ++xec7TTPqw6EI/oB/glT+PC+13Y/aSQNv/Is+tNer09lMn7DMHwAYppp8fvTIpISkVQsFrslqww4M9OuqkgzANzl1MhCyrjZGAycm573pK1yFCyi5FoWvo/FYlPOT2fOqftRXMbB9lkEs+3zbe2f/FD5i3YMj2p3vn8/IV8DZ5yE+Gqkot+JEQCPada5dRhxEriiQ5ya90w+272916F+KpnJDLhjpkUy5HgESNqhZU2Vfr5ne+dSFtOBeso06J6cnEy6d0z0hPwEPGeH8sGVykvfjpfe1NZUci2+mHg7Go2G8z/d/goQVJ9B8S1veMYffujduo/thl+ZwUzDuBqJRGZWt7n/FcDH46lFNVLilar1uiTTxsJTnTssH/QpJVlMNQa5wbGJiWERya3Vz30zzfLb3OveY3dU5j5dp4e80Xdbd3TOu/H/yyAtpjnqgeGS8crRQRks+v5xf5gtY/KM/6NAVebhwvv90bLvHu2o/XId2pJSMmIaxo/RaHRMxN6yZtPM0K5K/7hl/FxVZgZWbs0mPDceeKcuGE95/kpSKUmaImHDNIfHrl+PiIj2zOb+MFvBY7IUOVl2ZG9g6bJH4ckJuRe/2NYZT3myKIkrGM4pNRyLjY+LW09URDb1+uaF0pfm3zJ+7zhRGdq1c9eDuwOBOzdLa/OG2X+APwE8DU64Y/5gfAAAAABJRU5ErkJggg==",
  darkOrange: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQ+SURBVFiF3ZlLaFxlGIaf/5zJpJNpaoxpYieoCxULEYK7Lqp0IWQhFLooKNKEtNIULxWlQoJgQQWLFMEg0lQMuXgD0dRSkNJFgoy0IrYNSTpj08xMmoxNYhLUyUwyt/O5mFbjmGTOLS58d3O+y/u95/vnvx0lIvxf4HE9Y7PyU0ETwl6gAQgANcA88AswhuIsKc7TJ0k3qZVrnTmqtpGhHeFloMJERArF+3g5Qaf84UYJ7og5rPai+JhCB6xiHuEQp+Ws0zI0pwloU+0oBrAnBKAGxQBtqt1pKc46UyjgHadFrEIHXXLCbrB9MYWhNYAb3f0bBsI+u0POnpijahtpJrA/tDbCPOU8aGdSsPdWM7SzOUIAam7ntwzrnWlWfnzMYW76tYsUy9RaXYesd6aCJswI0Tw5WvuG6EyEOWUk6UyEae0bQvPkTLEUeCzBupjCyl4iqyfHydkxdh3YQ/nWnSjlp3zrTnYd2MPJ2TFTgszwFNNaDaCwRdkYLd1B/NWNa9r81Y20dAdd4SmCHTGBkh6P7bvXkd0sTxHsiKku6eH13+fIbpanCHbExEp6ZJJTjuxmeYpgXYwiVNLnysCMI7tZniLYmc1Kk/Qe3E1ycXhNW3JxmN6Du13hKYIdMWsXuRpGzsOxugYu9Q+RXgojkiS9FOZS/xDH6howcqUPhWZ4imB9B9CmyoBx4AGrZBYwCTxMl2StBFnvTJdkUbxlOc4a3rYqBOxuNHfQC0RsxZZGhAA9dgLtiTkuOYQOW7Gl0c5xMbN/+xecnTQPq89QPGM/wT9hCJ8+MvjQ81pK8yp92ZvxeMpUNuvVNK0MQAwjI15vRkTSIpKOxWK/yyoBzsS0qiq8DAP3OxWylNMWmoL1XTMresZsjIJllIzk4GosFrvl/HbmiHoCYRAHx2cBo2Pknp4v45U3befQVY/z8/sp+Q5410mKC7P+oBMhALphBNy6jHgDxU92Am+t6PFXhrcPOeRPp7LZYXfEdEkWjWeBlJWwnKEyr41s/3rFwHDAnjY0zsTj8ZR710Qfys/Aq1ZCPrlZef7iwpYF25xKRhLLyQ+i0Wi48NPtrwBt6hsofeQNJ7zhp74PfGE1/Z0ZzNC0y5FIZHa1zf2vAFmeS2vqerkuVeu5pPLa0otXa01f9CklOQw1AfnRiampkIjk1/JzX0y3/LrY7Dm0w5f/ah0Pee/GXWeiSc/G/y+NjBjGuA6h8snK8VEZLbn+uD/MbiPe7P283pd9uvh5cMH3Q8uPdd+uE7ailFw3NO1aNBqdELG2rdk0MbSqLb8p7UZVmVF/59F8Wp97Mhg4ncjqfxWplKQMkbBmGKGJ6emIiNie2TZPDHB5v+/xxrtXBnWFnhfyL1yp/ejCXMUMShIKQnmlQrFYbFJcKmJTxQBc3O9789FtmZfOzfjPvT5S068bmWvj09PTm8G16WL+S/wJLybNu1V6htkAAAAASUVORK5CYII=",
  red: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQxSURBVFiF3ZldaBxVFMd/d2ayTRtjQpo2mlilWBEMshoj+FAERZIHIdA3iw+V1icRREFIQAKNgsUHQfBFwZI2WgWxqYUiVTDBBj9ILC5Nu2tjdjemsR+mSZNNNvsxO8eHTTRuk+zMnQmCf9iHnXvO+Z//nDvn3rmjRIT/C6zAI4ZVFRbtKDpQNCM0AvXANIo/EC4inMbmLBFZDJJaBVaZJ9Sd2HQCrwDbXHikgfewOMKPMh9ECsGIeVx1IHxEsQJeMY3iEMNy2m8aht8AtKpOhH70hADUI/TTqjr9puKvMsUE3vabxCp0MSJHdJ31xRSnVj9BVPcfOCj26U45PTHFh30c/am1EaaxuF+nKejd1WLX2gwhAPXL8T3De2XCqooKbuCu/eoiTZ6dXtch75WxaMeNENOyOXx8kHOpGMPOIudSMQ4fH8S0bBcs25Z5PMF7ZVpVL3BgQxvTsvn6+kVq6sK3jc3NRGhraKZgl9t9HGNEXvCSmvfKKJrL2nQfHVpTCEBNXZjuo0OB8JTAu5jiXmtjPL3vLl/jbnlKoNPN6spaVFbt8jXulqcEOmKSZS0yi5O+xt3ylEBHTLSsxbf913yNu+UpgU4DKE/Sc3AvczORNcfmZiL0HNwbCE8JvItxWDvJ1SjYFm0NzZzpG2RpIYbIIksLMc70Dbpsy+54SqCzzlQAY8B9Xsk8YAJ4gBHJe3HyXpkRyaN407OfN7zlVQjobjTv4BgQ1/ItjzjV9Oo46okZEBuhS8u3PDoZEDf7t9vg903zBLBfP8C/4cAnD87teclIGyFlLoVyllWh8vmQYRgVAOI4OQmFciKSFZFsMpmck1UC/Il5VNViEgHu9StkQYyb7bNNH1wrmDm3PgqWUHLBhl+SyeRV/6czLepJDAbw8fos4HTNb+/9PFv9u3YMU/X6f38/L98B7/gJ8U2uasiPEADTcRqDOozoBn7WcbzqmFOvpnYM+uTPpvP5SDBiimvP8xRPKV3DFpV7fX7HyYyD44M96xicmpqaSgd3TDQsv6J4zYvLx5nqsz/kK29qcyq5kFpafD+RSMSKf4P+CvCY+hJFRzmzmB2KPTvb+JnX8CsdzDGM8/F4/PrqseC/AggvZlGXtyipXc8kLcbCy6mdrg/6lBIbR41DYXR8cjIqIoW17IIXc17+nHnEOnS3VfhiHQt5d7HmVMK2Nn6+DHLiOGMmRLdMVI+NymjZ9Sf4abaMqZbQp01G/rnS60P5rT8duNXw1TpuGaXksmMYlxKJxLiIt23NponhKVV5a874rdZwmlYuTTvmjWdmGj9Mifl3kkpJ2hGJGY4THb9yJS4i2p0t+Gm2ggHJxMNb94eNzIAJZgEKbyxsP5kS00ZJSkG0oFQ0mZyYkKDuqIhs6u/7hyt75luM2RMPVfft3rW7bU9T0z2bxbV50+w/wF8f81R5OpwBhwAAAABJRU5ErkJggg==",
  turquoiseBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASxSURBVFiF3ZhdbBRVGIafc2Z2210hbeWnpcQVUC8kwBUJXJBIgwkgBEPEC1GMxhgE4gUJJsYERMWI3orYaiqgrYSWH/mvMaQLciE1RAKUkrLbbhMobQ20/LT7N3OOF0CC0O7szGwv9L3c73u/93vnnD3zzYH/EUTBKx6sHUvQWgR6GTAdmASMA26A6AYuofUhQnYTVevuFlK6cGaObC9DGh8i9PtAKA/GEIKvSRZtZfnbA4VooTBmjlWvQFADPOmBfRN4l8Xv7ffbhvTF1lpwrHoTgga8GeE+by9NNRvR2tfDNfyQmVv5MYJP8L/CAqgidtai/sgpP0W84d7WavBV43Eo0CtYvOaAF7K3Rg7sKKU4Hcf71sqFfmz1DEvX9rslevvPFKc/YnSMAJRhyA+8EN2vzMHasQSzveR3/HrFEMV2udv3kOlaJmgtIg8jYcMcqpu1oGXJhMi0oJQVGaV6Dvd1day62DwnaWWd+GHSciGwz01rHraZXuaUETbMoe6qVR3Ly6fMD0oZAYJBKSOvVEyd3z3/jVjIDCSddYSjzqPwYEY875RRN2tBS4kZnDFcrNQMztw144UzjjKa6W4787IylU4ZSyZEpuWKv1w+dWohdB6Fl9NsnFNCUMqKnHGRO34PYnz+Ld2DFzN3nBIySvXkjGt1PQ+d23l3dB9ezPQ6JRzu6+rIFT/Q25lwVNHkfCDDwYuZFqeEVReb5wxYmQvDxfqz6QtvnW+e69yZcNR5jOKWgKbZKSVpZUOV0bpnG3vi0YxWXUAmo1XXnp54tLL5p+dSyi52FlJRt625nwCavxlDyrgKlLjm5o9byPBkFr456IbkfmWq1t1FsMM1zx1q3RoBr4OmpT4F+jxxndGHrbZ4IXozs3RtP0Ks98R1ghDrvYz/4PfD6ti39Qix0leNh6H07siaL9ZJKYuKtA6lhSgKaC0sWwYATENlLSmVECIZTKcHZ167NtAI9gO6PzO/1ZRg6XPAFF91AJnKDES21NaYN26l8uVoLWyhSZhS/345kUj4/+Q9XjMPdBR/9wl6Qn3TjyWnzyW88i3Y5e92BmDx6tPAV35KjDnXftqHEQBhKDXZvxmA4p5NCJzH+mFg3rxzvXzn0ZN+5BUoW8p4YcxUbbZQ4nXyGEIfhrDt7MS6o/tEOm07Z48ArTPCMPYnEomewpgBeGl1HMQGN5SSk381hdsSNzwqag1tRbZdHY/HL8JoXJwfr24AXnVKK7rae/mpz3fs8aCQ1FqfxzTPxuPxf7243V9oOMESa4XOvqgDZtlIKTKVHpz4w6Ej+ZbUWlgIHdNStkYikbZoNGoNl1f4lQGM3V8us0tLfhmhvh6/98Tu0hN/XslVQ2uRlahOIWWrMozLsVgs7aQ7KmYAAnVb67PjSh+bDsKtHX9Ubmv4dQRaEiE6JLQHwuG21tbWjBvNwm+z+8hmU+/Iu8l5akwo8uA34/bg3+W1B088nKdhCK2vmFJemjV7dqyxsdHzyTZqKwMQ2r55bmpK+SktRABb2ZO+2//9E+djvcAthIgZ0P5aZ+eVzaAKoTeqZgCKt238LP10xYaxZy7tq/j5+E5Ms629vb0b0KOt/Z/GP4jqqfL5oxVsAAAAAElFTkSuQmCC",
  defaultOffset: [-25.5, -38]
};
/* harmony default export */ __webpack_exports__["default"] = (Marker);

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(147);
// import OpenLayers

 // import local



var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("interactions");
/**
 * @private
 * @description
 * Pourquoi et comment l'utiliser ?
 * Cette classe permet de gérer les interactions entre chaque extension.
 * Une extension qui active une interaction avec la carte, doit desactiver
 * les autres interactions issues d'autre extensions.
 * La désactivation d'une interaction s'accompagne d'actions telles que
 * le nettoyage des dessins, l'état du composant graphique, ...
 *
 * Ex
 * // desactive toutes les interactions avec l'opération par defaut : clean
 * Interactions.unset(map);
 * // desactive les interactions sauf celles de Drawing. On execute des
 * // operations particulieres : status, collapse et message
 * Interactions.unset(map, {
 *    current : "Drawing",
 *    status : false,
 *    collapse : true,
 *    messsage : ["WARNING", "Ceci est un avertissement !"]
 * });
 *
 * Dans le code de l'extension, il faut placer des informations dans l'interaction :
 * interaction.setProperties({
 *     name : "Drawing",
 *     source : this
 * });
 */

var Interactions = {
  /**
   * Liste des extensions qui utilisent le mécanisme des interactions
   */
  _extensions: ["Measures", "ElevationPath", "Drawing"],

  /**
   * Options par defaut
   * - current : ex. "Drawing"
   *       c'est l'extension qui demande la desactivation des autres interactions.
   *       Par defaut, toutes les interactions sont desactivées.
   * - clean :
   *       c'est la suppression des interactions, des dessins de la carte,
   *       ainsi que la reinitialisation de l'état graphique.
   *       Les extensions doivent implementer la méthode 'clean()'.
   *       Par defaut, tous les dessins sont supprimés
   */
  _options: {
    current: null,
    clean: null
  },

  /**
   * Permet de desactive les interactions (Draw) de la carte pour les extensions,
   * sauf l'interaction courrante (si elle est renseignée avec l'option 'current').
   * Il est possible d'ajouter des fonctionnalités via les options.
   * Par defaut, l'option 'clean' est renseignée...
   *
   * @param {Object} map - the map
   * @param {Object} options - options
   */
  unset: function unset(map, options) {
    logger.trace("unset()");
    var opts = {};
    _Common_Utils__WEBPACK_IMPORTED_MODULE_3__["default"].mergeParams(opts, this._options);
    _Common_Utils__WEBPACK_IMPORTED_MODULE_3__["default"].mergeParams(opts, options);
    var interactions = map.getInteractions().getArray();

    for (var i = 0; i < interactions.length; i++) {
      if (interactions[i].getActive() && (interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_1__["Draw"] || interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_1__["Select"] || interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_1__["Modify"])) {
        var prop = interactions[i].getProperties();
        var name = prop.name;

        if (typeof name !== "undefined" && this._extensions.indexOf(name) > -1) {
          // doit on desactiver l'interaction courrante ?
          if (opts.current && opts.current === name) {
            continue;
          }

          interactions[i].setActive(false); // instance de l'extension

          var source = prop.source;

          if (typeof source !== "undefined" && source instanceof ol_control_Control__WEBPACK_IMPORTED_MODULE_0___default.a) {
            // opérations sur le composant graphique
            for (var action in opts) {
              if (opts.hasOwnProperty(action)) {
                if (action === "current") {
                  continue;
                }

                if (typeof source[action] === "function") {
                  var args = Array.isArray(opts[action]) ? opts[action] : [opts[action]];
                  source[action].apply(source, args);
                }
              }
            }
          }
        }
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Interactions);

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);


/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Contrôle des droits sur les ressources.
   *
   * @param {Object} options - liste des options
   * @param {String} options.key - clef API
   * @param {Array} options.resources - liste des ressources
   * @param {Array} options.services - liste des services
   * @returns {Object} rightManagement - undefined ou {
   *       key : "",
   *       service-1 : [resource-1, resource-2],
   *       service-2 : [resource-1, resource-2]
   * }
   */
  check: function check(options) {
    // logger
    var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("checkrightmanagement"); // si aucune option n'est renseignée...

    if (!options) {
      // message orienté pour le developpeur !
      logger.error("WARNING : " + "no parameter specified !");
      return;
    } // les options


    var _key = options.key;

    var _resources = options.resources || [];

    var _services = options.services || []; // si aucune information sur les ressources,
    // il est impossible de controler quelquechose !!!


    if (_resources.length === 0) {
      // message orienté pour le developpeur !
      logger.error("WARNING : " + "no parameter 'resources' specified !");
      return;
    } // si aucune information sur les services,
    // il est impossible de controler quelquechose !!!


    if (_services.length === 0) {
      // message orienté pour le developpeur !
      logger.error("WARNING : " + "no parameter 'services' specified !");
      return;
    } // les ressources controlées :
    // Ex.
    // {
    //   "Itineraire"     : ["Pieton", "Voiture"],
    //   "Geocode"        : ["PositionOfInterest", "StreetAddress", "CadastralParcel", "Administratif"],
    //   "AutoCompletion" : ["PositionOfInterest", "StreetAddress", "CadastralParcel", "Administratif"],
    //   "Elevation"      : ["SERVICE_CALCUL_ALTIMETRIQUE_RSC"]
    // }


    var _rightManagement = {}; // la clef API n'est pas renseignée

    if (!_key) {
      // on verifie si l'autoconfiguration est disponible
      if (!_Config__WEBPACK_IMPORTED_MODULE_1__["default"].isConfigLoaded()) {
        // si l'autoconfiguration n'est pas chargée,
        // aucune vérification des droits est possible...
        logger.warn("WARNING : " + "The 'apiKey' parameter is missing, " + "and the contract key configuration has not been loaded, " + "so impossible to check yours rights !");
        return;
      } else {
        // si l'autoconfiguration est chargée,
        // on recupere la/les clef(s) API, et on en profitera ensuite pour controler
        // les droits sur les ressources.
        _key = Object.keys(_Config__WEBPACK_IMPORTED_MODULE_1__["default"].configuration.generalOptions.apiKeys);
        logger.log(_key);
      }
    } // on verifie si l'autoconfiguration est disponible


    if (!_Config__WEBPACK_IMPORTED_MODULE_1__["default"].isConfigLoaded()) {
      // si l'autoconfiguration n'est pas chargée,
      // il est toujours possible de requeter le service avec une clef API,
      // mais les droits sur les ressources ne sont pas garantis, on risque
      // d'obtenir des erreurs 403 forbidden...
      // la responsabilité revient à l'utilisateur (message d'information)...
      logger.warn("WARNING : " + "the contract key configuration has not been loaded, " + "so be carefull !"); // les ressouces non controlées

      var _noRightManagement = {};

      for (var i = 0; i < _services.length; i++) {
        var service = _services[i];
        _noRightManagement[service] = [];

        for (var j = 0; j < _resources.length; j++) {
          var resource = _resources[j];

          _noRightManagement[service].push(resource);
        }
      } // on ajoute la clef


      _noRightManagement.key = _key;
      logger.log("right management not checked", _noRightManagement);
      return _noRightManagement;
    } else {
      // si l'autoconf est chargée,
      // on verifie la correspondance entre la clef et l'autoconfiguration,
      // on previent l'utilisateur (message d'information) s'il n'a
      // pas de droits sur certaines ressources ...
      // doit on ecarter les ressources sans droit ?
      // oui, si possible avec un message d'information pour l'utilisateur...
      for (var k = 0; k < _resources.length; k++) {
        var _resource = _resources[k];

        for (var l = 0; l < _services.length; l++) {
          var _service = _services[l];
          var params = _Config__WEBPACK_IMPORTED_MODULE_1__["default"].getServiceParams(_resource, _service, _key);

          if (!params || Object.keys(params).length === 0) {
            logger.warn("WARNING : " + "The contract key configuration has no rights to load this geoportal " + "resource (" + _resource + ") " + "for this service (" + _service + ") ");
            continue;
          }

          if (!_rightManagement[_service]) {
            _rightManagement[_service] = [];
          }

          _rightManagement[_service].push(_resource);
        }
      }

      if (Object.keys(_rightManagement).length === 0) {
        logger.warn("WARNING : " + "The contract key configuration has been loaded, " + "and the 'apiKey' parameter has been set, " + "but, there is a problem on the mapping between the contract and the key !");
        return;
      } // on ajoute la clef qui correspond à la ressource vérifiée


      _rightManagement.key = params.key;
      logger.log("right management checked", _rightManagement);
      return _rightManagement;
    }
  }
});

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var SearchEngineUtils = {
  /**
   * Advanced Search Filters by default
   */
  advancedSearchFiltersByDefault: {
    PositionOfInterest: [{
      name: "importance",
      title: "Importance"
    }, {
      name: "nature",
      title: "Nature"
    }, {
      name: "territory",
      title: "Territoire"
    }, {
      name: "insee",
      title: "Code INSEE"
    }, {
      name: "municipality",
      title: "Ville"
    }, {
      name: "department",
      title: "Département"
    }],
    StreetAddress: [// INFO
    // ce ne sont pas des filtres mais une location dite structurée !
    // {name : "number", title : "Numéro"},
    // {name : "street", title : "Rue"},
    // {name : "postalCode", title : "Code Postal"},
    // {name : "city", title : "Commune"},
    {
      name: "territory",
      title: "Territoire"
    }, {
      name: "insee",
      title: "Code INSEE"
    }, {
      name: "municipality",
      title: "Ville"
    }, {
      name: "department",
      title: "Département"
    }],
    CadastralParcel: [{
      name: "department",
      title: "Département",
      description: "Numéro du département (ex: 01, 94)"
    }, {
      name: "commune",
      title: "Code commune (INSEE)",
      description: "Code commune (INSEE) : 3 chiffres (ex: 067)"
    }, // {
    //     name : "insee",
    //     title : "Code INSEE"
    // },
    {
      name: "absorbedCity",
      title: "Commune absorbée",
      description: "Commune absorbée : 3 chiffres (ex: 000, 001)"
    }, {
      name: "section",
      title: "Section",
      description: "Section : 2 caractères (ex: AA, 0D)"
    }, {
      name: "number",
      title: "Numéro",
      description: "Numéro de la parcelle : 4 chiffres (ex: 0041, 0250)"
    }],
    Administratif: [{
      name: "prefecture",
      title: "Préfecture"
    }, {
      name: "inseeRegion",
      title: "Code région (INSEE)"
    }, {
      name: "inseeDepartment",
      title: "Code département (INSEE)"
    }, {
      name: "municipality",
      title: "Ville"
    }]
  },

  /**
   * Provides default zoom based on results.
   *
   * @param {Object} info - location information
   * @returns {Integer} zoom level
   */
  zoomToResultsByDefault: function zoomToResultsByDefault(info) {
    // FIXME
    // la classification du geocodage est differente de l'importance de l'autocompletion !
    var zoom = 15;
    var service = info.service;
    var fields = info.fields;
    var type = info.type;
    var importance = {
      1: 11,
      2: 12,
      3: 13,
      4: 14,
      5: 15,
      6: 16,
      7: 17,
      8: 17
    }; // AutoCompletion POI

    if (service === "SuggestedLocation") {
      if (type === "PositionOfInterest") {
        zoom = importance[fields.classification];
      }
    } // Geocodage POI


    if (service === "DirectGeocodedLocation") {
      if (type === "PositionOfInterest") {
        zoom = importance[fields.importance] || 14; // au cas où la recherche est en freeform !
      }
    }

    if (type === "StreetAddress") {
      zoom = 17;
    }

    if (type === "CadastralParcel") {
      zoom = 17;
    }

    if (type === "Administratif") {
      zoom = 12;
    }

    return zoom;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (SearchEngineUtils);

/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);

var SearchEngineDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPsearchEngine");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowSearchEngineElement: function _createShowSearchEngineElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowSearchEngine");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show search engine
   *
   * @returns {DOMElement} DOM element
   */
  _createShowSearchEnginePictoElement: function _createShowSearchEnginePictoElement() {
    // contexte d'execution
    var self = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowSearchEnginePicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowSearchEngine");
    label.title = "Afficher/masquer la recherche par lieux"; // Close all results and panels when minimizing the widget

    label.addEventListener("click", function () {
      document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none";
      document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
      var showAdvancedSearch = document.getElementById(self._addUID("GPshowAdvancedSearch"));

      if (showAdvancedSearch) {
        showAdvancedSearch.style.display = null;
        document.getElementById(self._addUID("GPadvancedSearchPanel")).style.display = "none";
      }

      var id = "#GPsearchInput-" + self._uid;
      document.querySelector(id + " input").disabled = false; // FIXME form[id^=GPsearchInput] = #GPsearchInput ?

      self.onShowSearchEngineClick();
    });
    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowSearchEngineOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },

  /**
   * Simple search input
   * @param {String} placeholder - placeholder
   *
   * @returns {DOMElement} DOM element
   */
  _createSearchInputElement: function _createSearchInputElement(placeholder) {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPsearchInput"); // Open geocode results panel when submitting the input

    form.addEventListener("submit", function (e) {
      e.preventDefault();
      document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "block";
      document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none"; // cf. FIXME
      // document.querySelector("#GPsearchInput input").blur ();
      // gestionnaire d'evenement :
      // on récupère la valeur de saisie pour requête sur le service de geocodage

      self.onGeocodingSearchSubmit(e);
      return false;
    });
    var input = document.createElement("input");
    input.id = this._addUID("GPsearchInputText");
    input.type = "text";
    input.placeholder = placeholder;
    input.autocomplete = "off"; // Manage autocomplete list appearance when filling the address input

    input.addEventListener("keyup", function (e) {
      var charCode = e.which || e.keyCode;

      if (charCode === 13 || charCode === 10 || charCode === 38 || charCode === 40) {
        return;
      }

      document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";

      if (input.value.length > 2) {
        document.getElementById(self._addUID("GPautoCompleteList")).style.display = "block";
      } else {
        document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none";
      } // gestionnaire d'evenement :
      // on récupère la valeur de saisie pour requête sur le service d'autocompletion


      self.onAutoCompleteSearchText(e);
    }); // FIXME ce code interfere avec le click sur la liste des suggested locations !
    // input.addEventListener("blur", function(e) {
    //     document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none";
    // });

    input.addEventListener("keydown", function (e) {
      // FIXME
      // l'action clavier 'enter (13)' lance le submit de la form !
      // Ce comportement n'est pas souhaité car le submit execute un geocodage !
      // Il faut donc trouver le moyen d'eviter le submit sur un return venant
      // seulement d'une selection de suggestion...
      var charCode = e.which || e.keyCode;
      var container = document.getElementById(self._addUID("GPautocompleteResults")); // si aucun container !?

      if (!container) {
        return;
      }

      var curr = container.getElementsByClassName("GPautoCompleteProposal current");
      var list = container.getElementsByClassName("GPautoCompleteProposal"); // si aucune suggestion, on ne va pas plus loin !

      var length = list.length;

      if (!length) {
        return;
      }

      var current = null; // si aucun item courant, on prend le 1er !

      if (!curr.length) {
        current = list[0];
        current.className = "GPautoCompleteProposal current";
        current.style.color = "#000000";
        current.style["background-color"] = "#CEDBEF";
        return;
      } else {
        current = curr[0];
      }

      var index = parseInt(_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(current.id), 10);
      var next = index === length - 1 ? list[0] : list[index + 1];
      var prev = index === 0 ? list[length - 1] : list[index - 1];
      current.style["background-color"] = "";
      current.style.color = "";
      prev.style["background-color"] = "";
      prev.style.color = "";
      next.style["background-color"] = "";
      next.style.color = "";

      switch (charCode) {
        case 38:
          // arrow up
          current.className = "GPautoCompleteProposal";
          prev.className = "GPautoCompleteProposal current";
          prev.style.color = "#000000";
          prev.style["background-color"] = "#CEDBEF";
          break;

        case 40:
          // arrow down
          current.className = "GPautoCompleteProposal";
          next.className = "GPautoCompleteProposal current";
          next.style.color = "#000000";
          next.style["background-color"] = "#CEDBEF";
          break;

        case 13:
          // enter
          // cf. FIXME
          e.preventDefault();
          current.click(e);
          break;
      }

      current.focus();
    });
    form.appendChild(input);
    var div = document.createElement("div");
    div.id = this._addUID("GPsearchInputReset"); // Reset input

    div.addEventListener("click", function () {
      document.getElementById(self._addUID("GPsearchInputText")).value = "";
      document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none";
      document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
      self.onSearchResetClick();
    });
    form.appendChild(div);
    return form;
  },

  /**
   * Show advanced search panel
   *
   * @returns {DOMElement} DOM element
   */
  _createShowAdvancedSearchElement: function _createShowAdvancedSearchElement() {
    // contexte d'execution
    var self = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPshowAdvancedSearch");
    div.className = "GPshowAdvancedToolPicto";
    div.title = "Ouvrir la recherche avancée"; // Open advanced search

    div.addEventListener("click", function () {
      var id = "#GPsearchInput-" + self._uid;
      document.querySelector(id + " input").disabled = true;
      document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none";
      document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
      document.getElementById(self._addUID("GPshowAdvancedSearch")).style.display = "none";
      document.getElementById(self._addUID("GPadvancedSearchPanel")).style.display = "inline-block";
    });
    var span = document.createElement("span");
    span.id = this._addUID("GPshowAdvancedSearchOpen");
    span.className = "GPshowAdvancedToolOpen";
    div.appendChild(span);
    return div;
  },

  /**
   * Advanced search panel
   *
   * FIXME
   * don't call this._createAdvancedSearchPanelHeaderElement
   * don't call this._createAdvancedSearchPanelFormElement
   *
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchPanelElement: function _createAdvancedSearchPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPadvancedSearchPanel");
    div.className = "GPpanel";
    div.style.display = "none"; // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // div.appendChild(this._createAdvancedSearchPanelHeaderElement ());
    // div.appendChild(this._createAdvancedSearchPanelFormElement ());

    return div;
  },

  /**
   * Geocoding results
   *
   * FIXME
   * don't call this._createGeocodeResultsListElement
   *
   * @returns {DOMElement} DOM element
   */
  _createGeocodeResultsElement: function _createGeocodeResultsElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPgeocodeResultsList");
    div.className = "GPpanel";
    div.style.display = "none";
    div.appendChild(this._createGeocodeResultsHeaderElement()); // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // div.appendChild(this._createGeocodeResultsListElement ());

    return div;
  },

  /**
   * Autocompletion results
   *
   * FIXME
   * don't call this._createAutoCompleteListElement
   *
   * @returns {DOMElement} DOM element
   */
  _createAutoCompleteElement: function _createAutoCompleteElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPautoCompleteList");
    div.className = "GPautoCompleteList"; // GPpanel ?

    div.style.display = "none"; // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // div.appendChild(this._createAutoCompleteListElement ());

    return div;
  },
  // ################################################################### //
  // ################### Autocompletion container ###################### //
  // ################################################################### //

  /**
   * Autocompletion results list.
   *
   * @returns {DOMElement} DOM element
   */
  _createAutoCompleteListElement: function _createAutoCompleteListElement() {
    // contexte d'execution
    var self = this;
    var container = document.createElement("div");
    container.id = this._addUID("GPautocompleteResults");

    if (container.addEventListener) {
      container.addEventListener("click", function (e) {
        self.onAutoCompletedResultsItemClick(e);
        document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none";
      }, false);
    } else if (container.attachEvent) {
      container.attachEvent("onclick", function (e) {
        self.onAutoCompletedResultsItemClick(e);
        document.getElementById(self._addUID("GPautoCompleteList")).style.display = "none";
      });
    } // Proposals are dynamically filled in Javascript by autocomplete service
    // <div class="GPautoCompleteProposal">...</div>


    return container;
  },

  /**
   * Autocompletion result.
   * Proposals are dynamically filled in Javascript by autocomplete service
   *
   * TODO formaliser le contenu des reponse
   *
   * @param {Object} location - suggested or geocoded location results
   * @param {Number} id - ID
   */
  _createAutoCompletedLocationElement: function _createAutoCompletedLocationElement(location, id) {
    var container = document.getElementById(this._addUID("GPautocompleteResults"));
    var div = document.createElement("div");
    div.id = this._addUID("AutoCompletedLocation_" + id);
    div.className = "GPautoCompleteProposal";
    div.innerHTML = location.fullText;

    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        container.click(e);
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function (e) {
        container.click(e);
      });
    }

    container.appendChild(div);
  },
  // ################################################################### //
  // ############### Geocoding with advanced container ################# //
  // ################################################################### //

  /**
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchPanelHeaderElement: function _createAdvancedSearchPanelHeaderElement() {
    // contexte d'execution
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle";
    divTitle.innerHTML = "Recherche avancée";
    container.appendChild(divTitle);
    var divClose = document.createElement("div");
    divClose.id = this._addUID("GPadvancedSearchClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer la recherche avancée";

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        var id = "#GPsearchInput-" + self._uid;
        document.querySelector(id + " input").disabled = false;
        document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
        document.getElementById(self._addUID("GPshowAdvancedSearch")).style.display = "inline-block";
        document.getElementById(self._addUID("GPadvancedSearchPanel")).style.display = "none";
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        var id = "#GPsearchInput-" + self._uid;
        document.querySelector(id + " input").disabled = false;
        document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
        document.getElementById(self._addUID("GPshowAdvancedSearch")).style.display = "inline-block";
        document.getElementById(self._addUID("GPadvancedSearchPanel")).style.display = "none";
      });
    }

    container.appendChild(divClose);
    return container;
  },

  /**
   * @param {Object[]} advancedSearchCodes - codes
   *
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchPanelFormElement: function _createAdvancedSearchPanelFormElement(advancedSearchCodes) {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPadvancedSearchForm");
    form.addEventListener("submit", function (e) {
      e.preventDefault(); // data

      var data = []; // liste des attributs de la ressource de geocodage

      var id = "#GPadvancedSearchFilters-" + self._uid;
      var matchesFilters = document.querySelectorAll(id + " > div > div > input");

      for (var i = 0; i < matchesFilters.length; i++) {
        var element = matchesFilters[i];
        data.push({
          key: element.name,
          value: element.value
        });
      } // gestionnaire d'evenement :
      // on récupère les valeurs de saisies pour requête sur le service de geocodage


      self.onGeocodingAdvancedSearchSubmit(e, data);
      document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "block";
      return false;
    });
    var div = document.createElement("div");
    div.className = "GPflexInput";
    var label = document.createElement("label");
    label.className = "GPadvancedSearchCodeLabel";
    label.innerHTML = "Recherche par";
    div.appendChild(label);

    var select = this._createAdvancedSearchFormCodeElement(advancedSearchCodes);

    div.appendChild(select); // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // var filters = this._createAdvancedSearchFormFiltersElement ();
    // form.appendChild(filters);
    // var input = this._createAdvancedSearchFormInputElement ();
    // form.appendChild(input);

    form.appendChild(div);
    return form;
  },

  /**
   * @param {Object[]} codes - codes
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchFormCodeElement: function _createAdvancedSearchFormCodeElement(codes) {
    // contexte d'execution
    var self = this;
    var select = document.createElement("select");
    select.id = this._addUID("GPadvancedSearchCode");
    select.className = "GPadvancedSearchCode";
    select.addEventListener("change", function (e) {
      // var idx   = e.target.selectedIndex;
      // var value = e.target.options[idx].value;
      // gestionnaire d'evenement :
      // permet de recuperer des informations diverses...
      self.onGeocodingAdvancedSearchCodeChange(e);
    }, false); // liste statique au cas où des codes n'ont pas été passés en entrée

    if (!codes) {
      codes = [{
        id: "PositionOfInterest",
        title: "Lieux/toponymes"
      }, {
        id: "StreetAddress",
        title: "Adresses"
      }, {
        id: "CadastralParcel",
        title: "Parcelles cadastrales"
      }, {
        id: "Administratif",
        title: "Administratif"
      }];
    }

    for (var i = 0; i < codes.length; i++) {
      var option = document.createElement("option");
      option.value = codes[i].id;
      option.text = codes[i].title;
      select.appendChild(option);
    }

    return select;
  },

  /**
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchFormInputElement: function _createAdvancedSearchFormInputElement() {
    var input = document.createElement("input");
    input.type = "submit";
    input.id = this._addUID("GPadvancedSearchSubmit");
    input.className = "GPinputSubmit";
    input.value = "Chercher";
    return input;
  },

  /**
   * Filters geocoding.
   *
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchFormFiltersElement: function _createAdvancedSearchFormFiltersElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPadvancedSearchFilters");
    return container;
  },

  /**
   * Create filter container for resources :
   * "PositionOfInterest", "StreetAddress", ...
   *
   * @param {String} code - code of geocoding resource
   * @param {Boolean} display - display
   *
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchFiltersTableElement: function _createAdvancedSearchFiltersTableElement(code, display) {
    var container = document.createElement("div");
    container.id = this._addUID(code);

    if (!display) {
      container.style.display = "none";
    }

    return container;
  },

  /**
   * Create filter attribut for a resource :
   * "PositionOfInterest", "StreetAddress", ...
   * Research filters are filled in Javascript depending on developer choice
   *
   * @param {Object} filterAttributes - filter attributes :
   * @param {String} filterAttributes.code - code of geocoding resource
   * @param {String} filterAttributes.name - ID
   * @param {String} filterAttributes.title - label
   * @param {String} filterAttributes.description - description
   * @param {String} filterAttributes.value - value
   *
   * @returns {DOMElement} DOM element
   */
  _createAdvancedSearchFiltersAttributElement: function _createAdvancedSearchFiltersAttributElement(filterAttributes) {
    // INFORMATION
    // cette methode peut être appelée si le document n'existe pas, elle
    // permet ainsi de creer une div sans insertion dans le container...
    var container = null;
    var name = filterAttributes.name;
    var title = filterAttributes.title;
    var description = filterAttributes.description;
    var code = filterAttributes.code;
    var value = filterAttributes.value;
    var div = document.createElement("div");
    div.className = "GPflexInput";
    var label = document.createElement("label");
    label.className = "GPadvancedSearchFilterLabel";
    label.htmlFor = name;
    label.title = description || title;
    label.innerHTML = title;
    div.appendChild(label);
    var input = document.createElement("input");
    input.id = name;
    input.className = "GPadvancedSearchFilterInput";
    input.type = "text";
    input.name = name;

    if (value) {
      input.value = value;
    }

    div.appendChild(input);
    container = document.getElementById(this._addUID(code));

    if (container) {
      container.appendChild(div);
    } else {
      // le container, c'est la div !
      container = div;
    }

    return container;
  },
  // ################################################################### //
  // ################## Geocoding results container #################### //
  // ################################################################### //

  /**
   * @returns {DOMElement} DOM element
   */
  _createGeocodeResultsHeaderElement: function _createGeocodeResultsHeaderElement() {
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle";
    divTitle.innerHTML = "Résultats de la recherche";
    container.appendChild(divTitle);
    var divClose = document.createElement("div");
    divClose.id = this._addUID("GPgeocodeResultsClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer la fenêtre de résultats";

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
      });
    }

    container.appendChild(divClose);
    return container;
  },

  /**
   * Geocoding results list.
   *
   * @returns {DOMElement} DOM element
   */
  _createGeocodeResultsListElement: function _createGeocodeResultsListElement() {
    // contexte d'execution
    var self = this;
    var container = document.createElement("div");
    container.id = this._addUID("GPgeocodeResults");

    if (container.addEventListener) {
      container.addEventListener("click", function (e) {
        if (!e.ctrlKey) {
          document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
        }

        self.onGeocodedResultsItemClick(e);
      }, false);
    } else if (container.attachEvent) {
      container.attachEvent("onclick", function (e) {
        if (!e.ctrlKey) {
          document.getElementById(self._addUID("GPgeocodeResultsList")).style.display = "none";
        }

        self.onGeocodedResultsItemClick(e);
      });
    } // Results are dynamically filled in Javascript by geocoding service
    // <div class="GPautoCompleteProposal">...</div>


    return container;
  },

  /**
   * Geocoding result.
   * Results are dynamically filled in Javascript by geocoding service
   *
   * TODO formaliser le contenu des reponses
   * FIXME formater la reponse en amont !
   *
   * @param {Object} location - suggested or geocoded location results
   * @param {Number} id - ID
   */
  _createGeocodedLocationElement: function _createGeocodedLocationElement(location, id) {
    var container = document.getElementById(this._addUID("GPgeocodeResults"));
    var div = document.createElement("div");
    div.id = this._addUID("GeocodedLocation_" + id);
    div.className = "GPautoCompleteProposal";

    if (typeof location === "string") {
      div.innerHTML = location;
    } else {
      var places = location.placeAttributes;

      if (places.freeform) {
        // reponse en freeForm
        div.innerHTML = places.freeform;
      } else if (places.postalCode) {
        // cas des StreetAddress, PositionOfInterest, Administratif
        // on affiche uniquement ce qui est commun aux ressources ...
        div.innerHTML = places.postalCode + " " + places.commune;
      } else if (places.cadastralParcel) {
        // cas des CadastralParcel
        div.innerHTML = places.cadastralParcel;
      } else {
        div.innerHTML = "...";
      }
    }

    container.appendChild(div);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (SearchEngineDOM);

/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_MousePosition_GPmousePositionOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);
/* harmony import */ var _CSS_Controls_MousePosition_GPmousePositionOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_MousePosition_GPmousePositionOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(171);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(147);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(179);
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(178);
/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(180);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(184);
/* harmony import */ var _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(185);
/* harmony import */ var _CRS_CRS__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(186);
/* harmony import */ var _Common_Controls_MousePositionDOM__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(193);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import OpenLayers




 // import geoportal library access

 // import local








 // import defs proj4 manually (cf. line 125)
//  import Proj4 from "proj4";
//  import { register } from "ol/proj/proj4";
//  import Register from "../../Common/Utils/Register";
// import local with ol dependencies

 // import "../CRS/AutoLoadCRS";
// DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__["default"].getLogger("GeoportalMousePosition");
/**
 * @classdesc
 * MousePosition Control.
 *
 * @constructor
 * @alias ol.control.GeoportalMousePosition
 * @extends {ol.control.Control}
 * @param {Object} options - options for function call.
 * @param {String}   [options.apiKey] - API key, mandatory if autoconf service has not been charged in advance
 * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Boolean} [options.collapsed = true] - Specify if MousePosition control should be collapsed at startup. Default is true.
 * @param {Array}   [options.units] - list of coordinates units, to be displayed in control units list.
 *      Values may be "DEC" (decimal degrees), "DMS" (sexagecimal), "RAD" (radians) and "GON" (grades) for geographical coordinates,
 *      and "M" or "KM" for metric coordinates
 * @param {Boolean}   [options.displayAltitude = true] - activate (true) or deactivate (false) the altitude panel. True by default
 * @param {Boolean}   [options.displayCoordinates = true] - activate (true) or deactivate (false) the coordinates panel. True by default
 * @param {Boolean} [options.editCoordinates = false] - If true, coordinates from the MousePosition control can be edited by users to re-center the view. False by default.
 * @param {Function} [options.mapCenterCallback] - callback...
 * @param {Array}   [options.systems] - list of projection systems, default are Geographical ("EPSG:4326"), Web Mercator ("EPSG:3857"), Lambert 93 ("EPSG:2154") and extended Lambert 2 ("EPSG:27572").
 *      Each array element (=system) is an object with following properties :
 * @param {String}  options.systems.crs - Proj4 crs alias (from proj4 defs). e.g. : "EPSG:4326". Required
 * @param {String}  [options.systems.label] - CRS label to be displayed in control. Default is crs code (e.g. "EPSG:4326")
 * @param {String}  options.systems.type - CRS units type for coordinates conversion : "Geographical" or "Metric". Default: "Metric"
 * @param {Object}  [options.systems.geoBBox] - Aera covered by the system (WGS84 coordinates).
 * @param {Number}  options.systems.geoBBox.right - Right bound.
 * @param {Number}  options.systems.geoBBox.left - Left bound.
 * @param {Number}  options.systems.geoBBox.top - Top bound.
 * @param {Number}  options.systems.geoBBox.bottom - Bottom bound.
 * @param {Object} [options.positionMarker] - options for position marker
 * @param {String} options.positionMarker.url - Marker url (define in src/Openlayers/Controls/Utils/Markers.js)
 * @param {Array} options.positionMarker.offset - Offsets in pixels used when positioning the marker towards targeted point.
 *      The first element in the array is the horizontal offset. A positive value shifts the marker right.
 *      The second element in the array is the vertical offset. A positive value shifts the marker down. [0,0] value positions the top-left corner of the marker image to the targeted point.
 *      Default is offset associated to default marker image.
 * @param {Boolean} options.positionMarker.hide - if true, marker is not displayed, otherwise displayed (False by default.)
 * @param {Object}  [options.altitude] - elevation configuration
 * @param {Object}  [options.altitude.serviceOptions] - options of elevation service
 * @param {Number}  [options.altitude.responseDelay] - latency for altitude request, 500 ms by default
 * @param {Number}  [options.altitude.triggerDelay] - immobilisation time of movement on the map to trigger the elevation calculation, 200 ms by default
 * @param {Number}  [options.altitude.noDataValue] - value used for altitude service no data (default is -99999). In this case, "---m" will be displayed instead of "-99999m"
 * @param {Number}  [options.altitude.noDataValueTolerance] - tolerance for no data value :
 *                  values in [noDataValue + noDataValueTolerance ; noDataValue - noDataValueTolerance] interval will not be displayed, but "---m" will be displayed instead.
 *                  Default is 90000 (no data values = [-9999 ; -189999])
 *  @example
 *  var MousePosition = new ol.control.GeoportalMousePosition({
 *      "collapsed" : false,
 *      "graggable" : true,
 *      "displayCoordinates" : true,
 *      "displayAltitude" : true,
 *      "altitude" : {
 *           "triggerDelay" : 100,
 *           "responseDelay" : 500,
 *           "noDataValue" : -99999,
 *           "noDataValueTolerance" : 99000,
 *           "serviceOptions" : {}
 *      },
 *      "systems" : [
 *       {
 *          "crs" : "EPSG:3857",
 *          "label" : "Web Mercator",
 *          "type" : "Metric"
 *       },
 *       {
 *          "crs" : "EPSG:4326",
 *          "label" : "Géographiques",
 *          "type" : "Geographical"
 *       },
 *       {
 *           "label" : "Lambert 93",
 *           "crs" : "EPSG:2154",
 *           "type" : "Metric",
 *           "geoBBox" : {
 *               "left" : -9.86,
 *               "bottom" : 41.15,
 *               "right" : 10.38,
 *               "top" : 51.56
 *           }
 *        }
 *      ],
 *      "units" : ["DEC", "DMS"]
 * });
 */

var MousePosition = function (Control) {
  function MousePosition(options) {
    options = options || {};

    if (!(this instanceof MousePosition)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // init Proj4 defs manually
    // Register.load(Proj4);
    // try {
    //     register(Proj4);
    // } catch (e) {}


    this._initialize(options); // init control DOM container


    var container = this._container = this._initContainer(options); // call ol.control.Control constructor


    Control.call(this, {
      element: container,
      target: options.target,
      render: options.render
    });
  }

  ; // Inherits from ol.control.Control

  if (Control) MousePosition.__proto__ = Control;
  /**
   * @lends module:GeoportalMousePosition
   */

  MousePosition.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune MousePositionDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_7__["default"].assign(MousePosition.prototype, _Common_Controls_MousePositionDOM__WEBPACK_IMPORTED_MODULE_15__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  MousePosition.prototype.constructor = MousePosition;
  /**
   * Overload ol.control.Control setMap method, called when
   *
   * @param {Object} map - the map
   *
   */

  MousePosition.prototype.setMap = function (map) {
    var _this = this;

    var context = this;

    if (map) {
      // dans le cas de l'ajout du contrôle à la map
      var center = this._createMapCenter();

      map.getViewport().appendChild(center);

      if (!this.collapsed && !this._isDesktop) {
        center.className = "GPmapCenterVisible";
      } // mode "draggable"


      if (this.draggable) {
        _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_13__["default"].dragElement(this._panelMousePositionContainer, this._panelHeaderMousePositionContainer, map.getTargetElement());
      } // on met en place l'evenement sur la carte pour recuperer les coordonnées,
      // on l'active à l'ouverture du panneau uniquement !


      if (!this.collapsed) {
        // evenement valable pour le mode desktop !
        if (this._isDesktop) {
          this.listenerKey = map.on("pointermove", function (e) {
            _this.onMouseMove(e);
          });
        } else {
          this.listenerKey = map.on("moveend", function (e) {
            return _this.onMapMove(e);
          });
        }
      } // add overlay only if option editCoordinates is true


      if (this.options.editCoordinates) {
        // création de l'élément DOM
        var markerDiv = document.createElement("img");
        markerDiv.id = this._addUID("GPmousePositionMarker");
        markerDiv.src = this._markerUrl;
        markerDiv.title = "Cliquer pour supprimer";
        markerDiv.addEventListener("click", function () {
          context._markerOverlay.setPosition(undefined);
        });
        this._markerOverlay = new ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default.a({
          offset: this._markerOffset,
          element: markerDiv,
          stopEvent: false
        });
        map.addOverlay(this._markerOverlay);
      }
    } else {
      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_3__["unByKey"])(this.listenerKey);
    } // call original setMap method


    Control.prototype.setMap.call(this, map); // HACK: on arrête l'execution de la fonction...

    if (map === null) {
      return;
    } // mode "collapsed"


    if (!this.collapsed) {
      var inputShow = document.getElementById("GPshowMousePosition-" + this._uid);
      inputShow.checked = "checked";

      this._setElevationPanel(this.options.displayAltitude);

      this._setCoordinatesPanel(this.options.displayCoordinates);

      if (!this.options.displayCoordinates) {
        this._setSettingsPanel(false);
      }
    }
  }; // ################################################################### //
  // #################### user interface methods ####################### //
  // ################################################################### //

  /**
   * Set additional projection system
   *
   * @param {Object} system - projection system
   * @param {String} system.crs - Proj4 crs alias (from proj4 defs) e.g. "EPSG:4326"
   * @param {String} [system.label] - CRS label to be displayed in control. Default is system.crs alias
   * @param {String} [system.type] - CRS units type for coordinates conversion (one of control options.units). Default is "Metric"
   */


  MousePosition.prototype.addSystem = function (system) {
    if (_typeof(system) !== "object") {
      logger.log("[ERROR] MousePosition:addSystem - system parameter should be an object");
      return;
    }

    if (!system.crs) {
      logger.error("crs not defined !");
      return;
    }

    if (!system.label) {
      logger.warn("crs label not defined, use crs code by default.");
      system.label = system.crs;
    }

    if (!system.type) {
      logger.warn("type srs not defined, use 'Metric' by default.");
      system.type = "Metric";
    } // chargement de la definition de la projection
    // même si déjà chargé...


    _CRS_CRS__WEBPACK_IMPORTED_MODULE_14__["default"].loadByName(system.crs);

    if (!Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["get"])(system.crs)) {
      logger.error("crs '{}' not available into proj4 definitions !", system.crs);
      return;
    } // 1. add system to control systems


    for (var j = 0; j < this._projectionSystems.length; j++) {
      var obj = this._projectionSystems[j];

      if (system.crs === obj.crs) {
        // warn user
        logger.info("crs '{}' already configured", obj.crs);
      }
    }

    system.code = this._projectionSystems.length;

    this._projectionSystems.push(system); // 2. add system settings option to container (if it was already build)


    var selectSystem = document.getElementById("GPmousePositionProjectionSystem-" + this._uid);

    if (selectSystem) {
      var option = document.createElement("option");
      option.value = system.code;
      option.text = system.label;
      selectSystem.appendChild(option);
    }
  };
  /**
   * Set additional projection systems
   *
   * @param {Array} systems - Array of system object, with following properties :
   * @param {String} systems.crs - Proj4 CRS alias (from proj4 defs) e.g. "EPSG:4326"
   * @param {String} systems.label - CRS label (for coordinates conversion)
   * @param {String} systems.type - CRS units type to be displayed in control (one of control options.units). Default is "Metric"
   */


  MousePosition.prototype.addSystems = function (systems) {
    if (!systems) {
      return;
    }

    if (!Array.isArray(systems)) {
      logger.log("[ERROR] MousePosition:addSystems - systems parameter should be an array");
      return;
    }

    for (var i = 0; i < systems.length; i++) {
      this.addSystem(systems[i]);
    }
  };
  /**
   * Remove projection system (in case there are several system with same code, only the first one will be removed)
   *
   * @param {String} systemCrs - CRS alias (from proj4 defs)
   */


  MousePosition.prototype.removeSystem = function (systemCrs) {
    if (!systemCrs || typeof systemCrs !== "string") {
      logger.log("[ERROR] MousePosition:removeSystem - systemCode parameter should be a string");
      return;
    }

    var systemList = document.getElementById("GPmousePositionProjectionSystem-" + this._uid);
    var systemCode = null; // find system in control projection systems list

    for (var i = 0; i < this._projectionSystems.length; i++) {
      var proj = this._projectionSystems[i];

      if (systemCrs === proj.crs) {
        systemCode = proj.code; // remove system from control projection systems list

        this._projectionSystems.splice(i, 1);

        break;
      }
    }

    if (systemCode == null) {
      logger.log("[WARN] MousePosition:removeSystem - system not found");
      return;
    }
    /* re-initialization of codes */


    var oldNewCodeMap = [];

    for (var j = 0; j < this._projectionSystems.length; j++) {
      oldNewCodeMap[Number(this._projectionSystems[j].code)] = j;
      this._projectionSystems[j].code = j;
    }
    /* find system in control container systems list */


    var indexChildToRemove = null;

    for (var k = 0; k < systemList.childNodes.length; k++) {
      if (systemCode === systemList.childNodes[j].value) {
        indexChildToRemove = k;
        continue;
      }

      systemList.childNodes[j].value = oldNewCodeMap[Number(systemList.childNodes[j].value)];
    }
    /* remove system from control container systems list */


    if (indexChildToRemove != null) {
      systemList.removeChild(systemList.childNodes[indexChildToRemove]);
    } // choose arbitrarily a new current system if needed


    if (this._currentProjectionSystems.code === Number(systemCode)) {
      systemList.childNodes[0].setAttribute("selected", "selected");

      this._setCurrentSystem(systemList.childNodes[0].value);
    }
  };
  /**
   * Set control units (to be displayed)
   *
   * @param {Array} units - list of all coordinates units, to be displayed in control units list.
   *      Values may be "DEC" (decimal degrees), "DMS" (sexagecimal), "RAD" (radians) and "GON" (grades) for geographical coordinates,
   *      and "M" or "KM" for metric coordinates
   */


  MousePosition.prototype.setUnits = function (units) {
    if (!units || !Array.isArray(units)) {
      return;
    }

    this.options.units = units;
    this._projectionUnits = [];

    this._initProjectionUnits();

    if (this._currentProjectionType) {
      this._setTypeUnitsPanel(this._currentProjectionType);
    }
  };
  /**
   * Set control altitude options (useless if displayAltitude == false)
   *
   * @param {Object} options - altitude options
   * @param {Object}  [options.serviceOptions] - options of elevation service
   * @param {Number}  [options.responseDelay] - latency for elevation request, 500 ms by default
   * @param {Number}  [options.triggerDelay] - immobilisation time of movement on the map to trigger the elevation calculation, 200 ms by default
   */


  MousePosition.prototype.setAltitudeOptions = function (options) {
    if (!options || _typeof(options) !== "object") {
      return;
    }

    this.options.altitude.triggerDelay = options.triggerDelay;
    this.options.altitude.responseDelay = options.responseDelay;

    if (options.serviceOptions) {
      for (var opt in options.serviceOptions) {
        if (options.serviceOptions.hasOwnProperty(opt)) {
          this.options.altitude.serviceOptions[opt] = options.serviceOptions[opt];
        }
      }
    }
  };
  /**
   * Display or hide elevation panel
   *
   * @param {Boolean} displayAltitude - true to display elevation panel, false to hide it
   */


  MousePosition.prototype.displayAltitude = function (displayAltitude) {
    if (displayAltitude === undefined) {
      return;
    }

    if (typeof this._noRightManagement === "undefined") {
      this._checkRightsManagement();
    }

    this.options.displayAltitude = displayAltitude;

    this._setElevationPanel(displayAltitude);
  };
  /**
   * Display or hide coordinates panel
   *
   * @param {Boolean} displayCoordinates - true to display coordinates panel, false to hide it
   */


  MousePosition.prototype.displayCoordinates = function (displayCoordinates) {
    if (displayCoordinates === undefined) {
      return;
    }

    this.options.displayCoordinates = displayCoordinates;

    this._setCoordinatesPanel(displayCoordinates);

    this._setSettingsPanel(displayCoordinates);
  };
  /**
   * Collapse or display control main container
   *
   * @param {Boolean} collapsed - True to collapse control, False to display it
   */


  MousePosition.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.log("[ERROR] MousePosition:setCollapsed - missing collapsed parameter");
      return;
    }

    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }

    if (!this._isDesktop) {
      document.getElementById("GPmapCenter").className = collapsed ? "" : "GPmapCenterVisible";
    } // on simule l'ouverture du panneau après un click


    this.onShowMousePositionClick();
    this._showMousePositionContainer.checked = !collapsed;
  }; // ################################################################### //
  // ######################## initialize control ####################### //
  // ################################################################### //

  /**
   * Initialize control (called by MousePosition constructor)
   *
   * @param {Object} options - control options (set by user)
   * @private
   */


  MousePosition.prototype._initialize = function (options) {
    // Set default options
    options = options || {}; // {Object} control options - set by user or by default

    this.options = options;
    this.options.collapsed = options.collapsed !== undefined ? options.collapsed : true;
    /** {Boolean} specify if MousePosition control is collapsed (true) or not (false) */

    this.collapsed = this.options.collapsed;
    this.options.draggable = options.draggable !== undefined ? options.draggable : false;
    /** {Boolean} specify if MousePosition control is draggable (true) or not (false) */

    this.draggable = this.options.draggable; // position marker

    this._markerOverlay = null;
    this._markerUrl = null;
    this._markerOffset = [0, 0];
    this._hideMarker = false;

    this._initMarker(options.positionMarker);

    this.options.units = options.units || [];
    this.options.displayAltitude = options.displayAltitude !== undefined ? options.displayAltitude : true;
    this.options.displayCoordinates = options.displayCoordinates !== undefined ? options.displayCoordinates : true;

    if (this.options.displayCoordinates) {
      this.options.editCoordinates = options.editCoordinates !== undefined ? options.editCoordinates : false;
    } else {
      // si les coordonnées ne sont pas affichées : pas besoin de les éditer...
      this.options.editCoordinates = false;
    }

    this.editing = false;
    this.options.systems = options.systems || [];

    if (options.altitude) {
      var altitude = options.altitude;
      this.options.altitude = {
        triggerDelay: altitude.triggerDelay !== undefined ? altitude.triggerDelay : 200,
        responseDelay: altitude.responseDelay !== undefined ? altitude.responseDelay : 500,
        serviceOptions: altitude.serviceOptions || {},
        noDataValue: altitude.noDataValue !== undefined ? altitude.noDataValue : -99999,
        noDataValueTolerance: altitude.noDataValueTolerance !== undefined ? altitude.noDataValueTolerance : 90000
      };
    } else {
      this.options.altitude = {
        triggerDelay: 200,
        responseDelay: 500,
        serviceOptions: {}
      };
    } // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)


    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_11__["default"].generate(); // initialisation des systemes de projections

    this._projectionSystems = [];

    this._initProjectionSystems(); // initialisation des systemes des unités


    this._projectionUnits = {};

    this._initProjectionUnits(); // detection du support : desktop ou tactile


    this._isDesktop = _Common_Utils__WEBPACK_IMPORTED_MODULE_7__["default"].detectSupport(); // on met en place un seuil sur le timer

    if (this.options.altitude.triggerDelay < 100) {
      this.options.altitude.triggerDelay = 100;
    } // {Number} timer on movestopped delay (altitude calculation)


    this._timer = this.options.altitude.triggerDelay; // {Object} Selected projection system

    this._currentProjectionSystems = this._projectionSystems[0]; // {String} Selected projection units typs : Geographical or metric

    this._currentProjectionType = this._projectionSystems[0].type; // {String} Selected projection unit

    this._currentProjectionUnits = this._projectionUnits[this._currentProjectionType][0].code; // {Object} Projection units container (DOM Element)

    this._projectionUnitsContainer = null; // {Object} control panel container (DOM Element)

    this._showMousePositionContainer = null;
    this._panelMousePositionContainer = null;
    this._panelHeaderMousePositionContainer = null; // gestion de l'affichage du panneau de l'altitude

    if (!this.options.displayAltitude && !this.options.displayCoordinates) {
      // on reactive l'affichage des coordonnées, pour ne pas afficher un panneau vide !
      this.options.displayCoordinates = true;
    } // gestion des droits sur les ressources/services
    // si l'on souhaite un calcul d'altitude, on verifie les droits sur les ressources d'alti...


    if (this.options.displayAltitude) {
      this._checkRightsManagement();
    } // listener key for event on pointermove or moveend map


    this.listenerKey = null;
  };
  /**
   *
   * @param {Object} option - positionMarker option
   * @private
   */


  MousePosition.prototype._initMarker = function (option) {
    if (!this.options.editCoordinates) {
      return;
    }

    if (!option) {
      this._markerUrl = _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"]["lightOrange"];
      this._markerOffset = _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"].defaultOffset;
      return;
    } // hide


    this._hideMarker = option.hide !== undefined ? option.hide : false; // offset

    if (option.offset) {
      if (Array.isArray(option.offset) && option.offset.length === 2) {
        this._markerOffset = option.offset;
      } else {
        logger.log("positionMarker.offset should be an array. e.g. : [0,0]");
        this._markerOffset = _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"].defaultOffset;
      }
    } else {
      this._markerOffset = _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"].defaultOffset;
    }

    var url = option.url;

    if (!url) {
      this._markerUrl = _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"]["lightOrange"];
    } else if (url.match(/^[a-zA-Z]+$/)) {
      // un seul mot
      this._markerUrl = _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"][url] !== undefined ? _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"][url] : _Utils_Markers__WEBPACK_IMPORTED_MODULE_9__["default"]["lightOrange"];
    } else {
      this._markerUrl = url;
    }
  };
  /**
   * this method is called by the constructor and initialize the projection
   * systems.
   * getting coordinates in the requested projection :
   * see this.onMousePositionProjectionSystemChange()
   *
   * @private
   */


  MousePosition.prototype._initProjectionSystems = function () {
    // on donne la possibilité à l'utilisateur de modifier
    // la liste des systèmes à afficher
    // Ex. this.options.systems
    // FIXME doit on charger des projections par defaut dans ce composant ?
    // chargement des projections par defaut
    // CRS.loadByDefault();
    // CRS.overload();
    // systemes de projection disponible par defaut
    var projectionSystemsByDefault = [{
      label: "G\xE9ographique",
      crs: Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["get"])("EPSG:4326").getCode(),
      type: "Geographical"
    }, {
      label: "Web Mercator",
      crs: Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["get"])("EPSG:3857").getCode(),
      type: "Metric"
    }, {
      label: "Lambert 93",
      crs: Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["get"])("EPSG:2154").getCode(),
      type: "Metric",
      geoBBox: {
        left: -9.86,
        bottom: 41.15,
        right: 10.38,
        top: 51.56
      }
    }, {
      label: "Lambert II \xE9tendu",
      crs: Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["get"])("EPSG:27572").getCode(),
      type: "Metric",
      geoBBox: {
        left: -4.87,
        bottom: 42.33,
        right: 8.23,
        top: 51.14
      }
    }];
    var systems = this.options.systems;

    for (var i = 0; i < systems.length; i++) {
      /* definition d'un systeme de reference */
      var sys = systems[i];
      this.addSystem(sys);
    }

    if (this._projectionSystems.length === 0) {
      // on ajoute les systèmes de projections par défaut
      for (var j = 0; j < projectionSystemsByDefault.length; j++) {
        this.addSystem(projectionSystemsByDefault[j]);
      }
    }
  };
  /**
   * this method is called by the constructor and initialize the units.
   * getting coordinates in the requested units :
   * see this.onMousePositionProjectionUnitsChange()
   *
   * @private
   */


  MousePosition.prototype._initProjectionUnits = function () {
    // on donne la possibilité à l'utilisateur de modifier
    // la liste des unités à afficher
    // Ex.
    // this.options.units : ["DEC", "DMS"]
    // unités disponible par defaut
    var projectionUnitsByDefault = {
      Geographical: [{
        code: "DEC",
        label: "degrés décimaux",
        format: this._displayDEC
      }, {
        code: "DMS",
        label: "degrés sexagésimaux",
        format: this._displayDMS
      }, {
        code: "RAD",
        label: "radians",
        format: this._displayRAD
      }, {
        code: "GON",
        label: "grades",
        format: this._displayGON
      }],
      Metric: [{
        code: "M",
        label: "mètres",
        format: this._displayMeter
      }, {
        code: "KM",
        label: "kilomètres",
        format: this._displayKMeter
      }]
    };
    var units = this.options.units;

    for (var type in projectionUnitsByDefault) {
      if (projectionUnitsByDefault.hasOwnProperty(type)) {
        var found = false;

        for (var j = 0; j < projectionUnitsByDefault[type].length; j++) {
          var obj = projectionUnitsByDefault[type][j];

          for (var i = 0; i < units.length; i++) {
            var unit = units[i];

            if (obj.code === unit) {
              found = true;

              if (!this._projectionUnits[type]) {
                this._projectionUnits[type] = [];
              }

              this._projectionUnits[type].push(obj);
            }
          }
        }

        if (!found) {
          this._projectionUnits[type] = projectionUnitsByDefault[type];
        }
      }
    } // au cas où...


    if (_typeof(this._projectionUnits) === "object" && Object.keys(this._projectionUnits).length === 0) {
      this._projectionUnits = projectionUnitsByDefault;
    }
  };
  /**
   * this method get label from the current projection units
   *
   * @returns {String} projection information
   *
   * @private
   */


  MousePosition.prototype._getCurrentProjectionInformation = function () {
    var systemInfo = [this._currentProjectionSystems.label, "en"];
    var units = this._projectionUnits[this._currentProjectionType];

    for (var u = 0; u < units.length; ++u) {
      if (units[u].code === this._currentProjectionUnits) {
        systemInfo.push(units[u].label);
        break;
      }
    }

    return systemInfo.join(" ");
  };
  /**
   * this method is called by constructor
   * and check the rights to resources
   *
   * @private
   */


  MousePosition.prototype._checkRightsManagement = function () {
    var rightManagement = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_10__["default"].check({
      key: this.options.apiKey,
      resources: ["SERVICE_CALCUL_ALTIMETRIQUE_RSC"],
      services: ["Elevation"]
    }); // pas de droit !

    if (!rightManagement) {
      this._noRightManagement = true;
      return;
    } // on recupère les informations utiles
    // sur ce controle, on ne s'occupe pas de la ressource car elle est unique...
    // Ex. la clef API issue de l'autoconfiguration si elle n'a pas
    // été renseignée.


    if (!this.options.apiKey) {
      this.options.apiKey = rightManagement.key;
    }
  }; // ################################################################### //
  // ######################## methods handle dom ####################### //
  // ################################################################### //

  /**
   * Create control main container (called by MousePosition constructor)
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  MousePosition.prototype._initContainer = function () {
    // creation du container principal
    var container = this._createMainContainerElement();

    var inputShow = this._showMousePositionContainer = this._createShowMousePositionElement();

    container.appendChild(inputShow);

    var picto = this._createShowMousePositionPictoElement(this._isDesktop);

    container.appendChild(picto);

    var panel = this._panelMousePositionContainer = this._createMousePositionPanelElement();

    var header = this._panelHeaderMousePositionContainer = this._createMousePositionPanelHeaderElement();

    panel.appendChild(header);

    var basic = this._createMousePositionPanelBasicElement(this.options.displayAltitude, this.options.displayCoordinates, this.options.editCoordinates, this._currentProjectionUnits);

    panel.appendChild(basic);

    var arraySettings = this._createShowMousePositionSettingsElement(this.options.displayCoordinates);

    for (var j = 0; j < arraySettings.length; j++) {
      panel.appendChild(arraySettings[j]);
    }

    var settings = this._createMousePositionSettingsElement();

    var systems = this._projectionSystemsContainer = this._createMousePositionSettingsSystemsElement(this._projectionSystems);

    var units = this._projectionUnitsContainer = this._createMousePositionSettingsUnitsElement(this._projectionUnits[this._currentProjectionType]);

    settings.appendChild(systems);
    settings.appendChild(units);
    panel.appendChild(settings);
    container.appendChild(panel);
    return container;
  };
  /**
   * this method is called by this.()
   * and it changes the elevation view panel into the dom.
   *
   * @param {Boolean} active - true:active, false:disable
   * @private
   */


  MousePosition.prototype._setElevationPanel = function (active) {
    var div = null;

    if (!active) {
      div = document.getElementById("GPmousePositionAltitude-" + this._uid);
      div.style.display = "none";
    } else {
      if (this._noRightManagement) {
        div = document.getElementById("GPmousePositionAlt-" + this._uid);
        div.innerHTML = "No rights!";
      } else {
        div = document.getElementById("GPmousePositionAltitude-" + this._uid);
        div.style.display = "";
      }
    }
  };
  /**
   * this method is called by this.()
   * and it changes the coordinate view panel into the dom.
   *
   * @param {Boolean} active - true:active, false:disable
   * @private
   */


  MousePosition.prototype._setCoordinatesPanel = function (active) {
    var div = document.getElementById("GPmousePositionCoordinate-" + this._uid);

    if (!active) {
      div.style.display = "none";
    } else {
      div.style.display = "";
    }
  };
  /**
   * this method is called by this.()
   * and it changes the settings view panel into the dom.
   *
   * @param {Boolean} active - true:active, false:disable
   * @private
   */


  MousePosition.prototype._setSettingsPanel = function (active) {
    var divPicto = document.getElementById("GPshowMousePositionSettingsPicto-" + this._uid);
    var divPanel = document.getElementById("GPmousePositionSettings-" + this._uid);

    if (!active) {
      divPicto.style.display = "none";
      divPanel.style.display = "none";
    } else {
      divPicto.style.display = "";
      divPanel.style.display = "";
    }
  };
  /**
   * this method is called by this.onMousePositionProjectionSystemChange()
   * when changes to a metric or a geographical units.
   *
   * @param {String} type - Geographical or Metric
   * @private
   */


  MousePosition.prototype._setTypeUnitsPanel = function (type) {
    var container = this._projectionUnitsContainer; // on supprime les enfants...

    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }

    var units = this._projectionUnits[type];

    for (var j = 0; j < units.length; j++) {
      var obj = units[j];
      var option = document.createElement("option");
      option.value = obj.code ? obj.code : j;
      option.text = obj.label || j; // option.label = obj.label;

      container.appendChild(option);
    }

    var projectionUnits = this._projectionUnits[type][0].code;

    if (this._currentProjectionUnits === "DMS" || projectionUnits === "DMS") {
      this._resetCoordinateElements(this.options.editCoordinates, type, projectionUnits);

      this._setEditMode(this.editing);
    } // le nouveau type de system ...


    this._currentProjectionType = type; // Mise a jour des elements labels et unites

    this._resetLabelElements(type);

    this._resetUnitElements(projectionUnits); // et comme on a changé de type de systeme,
    // il faut changer aussi d'unité !


    this._currentProjectionUnits = projectionUnits;
  }; // ################################################################### //
  // ######################## method units format ###################### //
  // ################################################################### //

  /**
   * degreedecimal
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @return {Object} coordinate - coordinate object : {lat : 48, lng : 2} par exemple
   * @private
   */


  MousePosition.prototype._displayDEC = function (olCoordinate) {
    var coordinate = {};
    coordinate.lat = olCoordinate[1].toFixed(6);
    coordinate.lng = olCoordinate[0].toFixed(6);
    coordinate.unit = "°";
    return coordinate;
  };
  /**
   * degreedecimal2sexagecimal
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @return {Object} coordinate - coordinate object : {lng : "2° 00′ 00″ E", lat : "48° 00′ 00″ N"} par exemple
   * @private
   */


  MousePosition.prototype._displayDMS = function (olCoordinate) {
    return {
      lng: _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].decimalToDMS(olCoordinate[0], "EO", 2),
      lat: _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].decimalToDMS(olCoordinate[1], "NS", 2),
      unit: "DMS"
    };
  };
  /**
   * degreedecimal2radian
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @return {Object} coordinate - coordinate object : {lng : "0.02837864", lat : "0.84300269"} par exemple
   * @private
   */


  MousePosition.prototype._displayRAD = function (olCoordinate) {
    var coordinate = {};
    var d = 0.01745329251994329577;
    coordinate.lng = olCoordinate[0] * d;
    coordinate.lng = coordinate.lng.toFixed(8);
    coordinate.lat = olCoordinate[1] * d;
    coordinate.lat = coordinate.lat.toFixed(8);
    coordinate.unit = "rad";
    return coordinate;
  };
  /**
   * degreedecimal2grade
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @return {Object} coordinate - coordinate object : {lng : "4.09545898", lat : "53.68751528"} par exemple
   * @private
   */


  MousePosition.prototype._displayGON = function (olCoordinate) {
    var coordinate = {};
    var d = 1.11111111111111111111;
    coordinate.lng = olCoordinate[0] * d;
    coordinate.lng = coordinate.lng.toFixed(8);
    coordinate.lat = olCoordinate[1] * d;
    coordinate.lat = coordinate.lat.toFixed(8);
    coordinate.unit = "gon";
    return coordinate;
  };
  /**
   * meter
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @return {Object} coordinate - coordinate object : {x : "148593.58", y : "6176560.95"} par exemple
   * @private
   */


  MousePosition.prototype._displayMeter = function (olCoordinate) {
    // on recoit toujours des coordonnées metriques
    var coordinate = {};
    coordinate.x = olCoordinate[0].toFixed(2);
    coordinate.y = olCoordinate[1].toFixed(2);
    coordinate.unit = "m";
    return coordinate;
  };
  /**
   * kilometer
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @return {Object} coordinate - coordinate object : {x : "214.96", y : "6250.09"} par exemple
   * @private
   */


  MousePosition.prototype._displayKMeter = function (olCoordinate) {
    var coordinate = {};
    coordinate.x = (olCoordinate[0] / 1000).toFixed(2);
    coordinate.y = (olCoordinate[1] / 1000).toFixed(2);
    coordinate.unit = "km";
    return coordinate;
  }; // ################################################################### //
  // ##################### handlers events to control ################## //
  // ################################################################### //

  /**
   * this sends the coordinates to the panel.
   * (cf. this.GPdisplayCoords() into the DOM functions)
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @param {Object} crs - coordinate CRS (ol.proj.Projection)
   * @private
   */


  MousePosition.prototype._setCoordinate = function (olCoordinate, crs) {
    // structure
    // ol.Coordinate
    //      [
    //          4   // lon
    //          48  // lat
    //      ]
    // structure pour les coordonnées en fonctin du type demandé :
    // {x:, y:, unit:} ou {lng:, lat:} ou {lon:, lat:} ou {e:, n:, unit:}...
    var coordinate = {}; // on projete le point dans le systeme demandé

    var oSrs = this._currentProjectionSystems.crs;

    if (!oSrs) {
      logger.log("ERROR : system crs not found");
      return;
    } // on reprojette les coordonnées depuis leur CRS d'origine (CRS) vers le CRS demandé (oSrs)


    olCoordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["transform"])(olCoordinate, crs, oSrs); // type de systeme : Geographical ou Metric

    var type = this._currentProjectionSystems.type; // on recherche la fonction de formatage dans l'unité demandée

    var format = null;
    var units = this._projectionUnits[type];

    for (var i = 0; i < units.length; i++) {
      if (units[i].code === this._currentProjectionUnits) {
        format = units[i].format;
        break;
      }
    }

    if (!format || typeof format !== "function") {
      logger.log("WARNING : coordinates format function not found");
      return;
    } else {
      coordinate = format(olCoordinate);
    }

    if (!coordinate || Object.keys(coordinate).length === 0) {
      return;
    }

    this.GPdisplayCoords(coordinate);
  };
  /**
   * this sends the coordinates to the panel.
   * (cf. this.GPdisplayElevation() into the DOM functions)
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @private
   */


  MousePosition.prototype._setElevation = function (olCoordinate) {
    // gestion du timer de la requete du service d'altitude
    var delay = this.options.altitude.responseDelay;
    var noDataValue = this.options.altitude.noDataValue;
    var noDataValueTolerance = this.options.altitude.noDataValueTolerance;
    this.GPdisplayElevation(olCoordinate, delay, noDataValue, noDataValueTolerance);
  };
  /**
   * this method is triggered when the mouse or the map is stopped.
   * (cf. onMouseMove and onMapMove)
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @param {Object} crs - coordinate CRS (ol.proj.Projection)
   * @private
   */


  MousePosition.prototype.onMoveStopped = function (olCoordinate, crs) {
    // reprojection en CRS:84 (EPSG:4326) pour le calcul alti
    var oLatLng = Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["transform"])(olCoordinate, crs, "EPSG:4326");

    this._setElevation(oLatLng);
  };
  /**
   * this method is an handler event to control. The event is 'mousemove' on
   * the map. The handler sends the coordinates to the panel.
   * (cf. this.GPdisplayCoords() into the DOM functions)
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  MousePosition.prototype.onMouseMove = function (e) {
    var self = this; // info: coordinate = [x, y]

    var coordinate = e.coordinate;

    if (!e.map || !e.map.getView()) {
      return;
    }

    var crs = e.map.getView().getProjection();

    this._setCoordinate(coordinate, crs); // calcul de l'altitude après un certain délai après l'arrêt du mouvement de la souris


    clearTimeout(this._timer);
    this._timer = setTimeout(function () {
      self.onMoveStopped(coordinate, crs);
    }, this.options.altitude.triggerDelay);
  };
  /**
   * this method is an handler event to control. The event is 'moveend' on
   * the map. The handler sends the coordinates to the panel.
   * (cf. this.GPdisplayCoords() into the DOM functions)
   *
   * @private
   */


  MousePosition.prototype.onMapMove = function () {
    var self = this;
    var map = this.getMap();

    if (!map || !map.getView()) {
      return;
    }

    var view = map.getView();
    var coordinate = view.getCenter();
    var crs = view.getProjection();

    this._setCoordinate(coordinate, crs); // calcul de l'altitude après un certain délai après l'arrêt du mouvement de la souris


    clearTimeout(this._timer);
    this._timer = setTimeout(function () {
      self.onMoveStopped(coordinate, crs);
    }, this.options.altitude.triggerDelay);
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by this.GPdisplayElevation() in the dom, and
   * it executes a request to the elevation service.
   *
   * @param {Object} coordinate - {lat:..., lng:...}
   * @param {Function} callback - callback
   * @private
   */


  MousePosition.prototype.onRequestAltitude = function (coordinate, callback) {
    // INFORMATION
    // on effectue la requête au service d'altitude...
    // on met en place des callbacks afin de recuperer les resultats ou
    // les messages d'erreurs du service.
    // le resultat est affiché dans une balise du dom.
    if (!coordinate || Object.keys(coordinate).length === 0) {
      return;
    } // si on ne veut pas de calcul d'altitude, on ne continue pas !


    if (!this.options.displayAltitude) {
      return;
    } // si on n'a pas les droits sur la ressource, pas la peine de
    // continuer !


    if (this._noRightManagement) {
      logger.log("[WARNING] contract key configuration has no rights to load geoportal elevation ");
      document.getElementById("GPmousePositionAlt-" + this._uid).innerHTML = "No rights!";
      return;
    } // on recupere les options du service


    var options = this.options.altitude.serviceOptions || {}; // gestion du protocole et du timeout
    // le timeout est indispensable sur le protocole JSONP.

    var _protocol = options.protocol || "XHR";

    var _timeout = options.timeOut || 0;

    if (_protocol === "JSONP" && _timeout === 0) {
      _timeout = 15000;
    } // ainsi que les coordonnées


    var _zonly = true;
    var _positions = [{
      lon: coordinate[0],
      lat: coordinate[1]
    }]; // et les callbacks

    var _scope = this;

    var _rawResponse = options.rawResponse || false;

    var _onSuccess = null;
    var _onFailure = null;

    if (!_rawResponse) {
      // dans le cas général
      // callback onSuccess
      _onSuccess = function _onSuccess(results) {
        if (results && Object.keys(results).length) {
          callback.call(this, results.elevations[0].z);
        }
      };
    } else {
      // callback onSuccess
      _onSuccess = function _onSuccess(results) {
        logger.log("alti service raw response : ", results);
      };
    } // callback onFailure


    _onFailure = function _onFailure(error) {
      logger.log("[getAltitude] ERROR : " + error.message);
    }; // cas où la clef API n'est pas renseignée dans les options du service,
    // on utilise celle de l'autoconf ou celle renseignée au niveau du controle


    var _apiKey = options.apiKey || this.options.apiKey; // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
    // true par défaut (https)


    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }

    var _ssl = options.ssl;
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_5__["default"].Services.getAltitude({
      apiKey: _apiKey,
      protocol: _protocol,
      ssl: _ssl,
      timeOut: _timeout,
      scope: _scope,
      rawResponse: _rawResponse,
      onSuccess: _onSuccess,
      onFailure: _onFailure,
      zonly: _zonly,
      positions: _positions
    });
  };
  /**
   * this method is called by event 'click' on 'GPshowMousePositionPicto' tag label
   * (cf. this._createShowMousePositionPictoElement),
   * and toggles event 'mousemove' on map.
   *
   * @private
   */


  MousePosition.prototype.onShowMousePositionClick = function () {
    var _this2 = this;

    // checked : true - panel close
    // checked : false - panel open
    var map = this.getMap(); // on supprime toutes les interactions

    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_8__["default"].unset(map);
    this.collapsed = this._showMousePositionContainer.checked; // on génère nous même l'evenement OpenLayers de changement de propriété
    // (utiliser mousePosition.on("change:collapsed", function(e) ) pour s'abonner à cet évènement)

    this.dispatchEvent("change:collapsed"); // evenement declenché à l'ouverture/fermeture du panneau,
    // et en fonction du mode : desktop ou tactile !

    if (this._showMousePositionContainer.checked) {
      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_3__["unByKey"])(this.listenerKey);
    } else if (!this.editing) {
      if (this._isDesktop) {
        this.listenerKey = map.on("pointermove", function (e) {
          _this2.onMouseMove(e);
        });
      } else {
        this.listenerKey = map.on("moveend", function (e) {
          return _this2.onMapMove(e);
        }); // on simule un deplacement en mode tactile

        this.onMapMove();
      }
    } // FIXME
    // on gère l'affichage des panneaux ici..., même si ce n'est pas l'endroit
    // adequate...


    this._setElevationPanel(this.options.displayAltitude);

    this._setCoordinatesPanel(this.options.displayCoordinates);

    if (!this.options.displayCoordinates) {
      this._setSettingsPanel(false);
    }
  };
  /**
   * this method is called by event 'click' on 'GPshowMousePositionPicto' tag label
   * (cf. this._createShowMousePositionPictoElement),
   * and toggles event 'mousemove' on map.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  MousePosition.prototype.onShowMousePositionSettingsClick = function (e) {
    if (!this.draggable) {
      this._panelMousePositionContainer.style.transition = "top 0.5s ease-out 0s";
      this._panelMousePositionContainer.style.transitionProperty = "top";
      this._panelMousePositionContainer.style.transitionDuration = "0.5s";
      this._panelMousePositionContainer.style.transitionTimingFunction = "ease-out";
      this._panelMousePositionContainer.style.transitionDelay = "0s";
      var height = -95;
      var top = this._panelMousePositionContainer.offsetTop;

      if (!document.getElementById(e.target.htmlFor).checked) {
        this._panelMousePositionContainer.style.top = top + height + "px";
      } else {
        this._panelMousePositionContainer.style.top = top - height + "px";
      }
    }
  };
  /**
   * this method is called by event 'click' on input coordinate
   *
   * @param {Boolean} editing - editing mode
   */


  MousePosition.prototype.onMousePositionEditModeClick = function (editing) {
    var _this3 = this;

    if (!this.options.editCoordinates) {
      return;
    }

    if (this.editing === editing) {
      return;
    }

    this.editing = editing; // Affichage des outils, input en ecriture

    this._setEditMode(this.editing);

    var map = this.getMap();

    if (this._isDesktop) {
      if (this.editing) {
        // Unlisten for 'pointermove' events
        // map.un("pointermove", (e) => { this.onMouseMove(e); });
        Object(ol_Observable__WEBPACK_IMPORTED_MODULE_3__["unByKey"])(this.listenerKey);
      } else {
        // Listen for 'pointermove' events
        this.listenerKey = map.on("pointermove", function (e) {
          _this3.onMouseMove(e);
        }); // on simule un deplacement

        this.onMapMove();
      }
    } else {
      if (this.editing) {
        // Unlisten for 'moveend' events
        // map.un("moveend", (e) => this.onMapMove(e));
        Object(ol_Observable__WEBPACK_IMPORTED_MODULE_3__["unByKey"])(this.listenerKey);
      } else {
        // Listen for moveend' events
        this.listenerKey = map.on("moveend", function (e) {
          return _this3.onMapMove(e);
        }); // on simule un deplacement

        this.onMapMove();
      }
    } // clear _markerOverlay


    if (!this.editing && this._markerOverlay) {
      this._markerOverlay.setPosition(undefined);
    }
  };
  /**
   * Get coordinate from inputs and select in decimal degrees
   *
   * @param {String} coordType - "Lon" or "Lat"
   * @returns {undefined}
   * @private
   */


  MousePosition.prototype.getCoordinate = function (coordType) {
    var inputDegrees = document.getElementById(this._addUID("GPmousePosition" + coordType + "Degrees"));
    var degrees = inputDegrees.value;

    if (!degrees) {
      return null;
    }

    degrees = degrees.replace(",", ".");

    if (!_Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].isInteger(degrees)) {
      return null;
    }

    var result = _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].toInteger(degrees);

    if (result < Number(inputDegrees.dataset.min) || result > Number(inputDegrees.dataset.max)) {
      return null;
    }

    var direction = document.getElementById(this._addUID("GPmousePosition" + coordType + "Direction")).value;
    var inputMinutes = document.getElementById(this._addUID("GPmousePosition" + coordType + "Minutes"));
    var minutes = inputMinutes.value;

    if (minutes) {
      minutes = minutes.replace(",", ".");

      if (_Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].isInteger(minutes)) {
        var mins = _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].toInteger(minutes);

        if (mins >= Number(inputMinutes.dataset.min) && mins <= Number(inputMinutes.dataset.max)) {
          result += mins / 60;
        }
      }
    }

    var inputSeconds = document.getElementById(this._addUID("GPmousePosition" + coordType + "Seconds"));
    var seconds = inputSeconds.value;

    if (seconds) {
      seconds = seconds.replace(",", ".");
      var secs = _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].toFloat(seconds);

      if (secs && secs >= Number(inputSeconds.dataset.min) && secs <= Number(inputSeconds.dataset.max)) {
        result += secs / 3600;
      }
    }

    if (direction === "O" || direction === "S") {
      result = -result;
    }

    return result;
  };
  /**
   * locate DMS coordinates on map
   *
   * @private
   */


  MousePosition.prototype.locateDMSCoordinates = function () {
    var lonlat = [this.getCoordinate("Lon"), this.getCoordinate("Lat")];

    if (lonlat[0] === null || lonlat[1] === null) {
      return;
    }

    var oSrs = this._currentProjectionSystems.crs;

    if (!oSrs) {
      logger.log("ERROR : system crs not found");
      return;
    }

    var view = this.getMap().getView();
    var coordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["transform"])(lonlat, oSrs, view.getProjection());
    view.setCenter(coordinate);

    if (this._markerOverlay && !this._hideMarker) {
      this._markerOverlay.setPosition(coordinate);
    }
  };
  /**
   * locate coordinates on map (not DMS)
   *
   * @private
   */


  MousePosition.prototype.locateCoordinates = function () {
    var lon = document.getElementById(this._addUID("GPmousePositionLon")).value;
    lon = lon.replace(",", ".");
    lon = _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].toFloat(lon);

    if (lon === null) {
      return;
    }

    var lat = document.getElementById(this._addUID("GPmousePositionLat")).value;
    lat = lat.replace(",", ".");
    lat = _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].toFloat(lat);

    if (lat === null) {
      return;
    }

    var oSrs = this._currentProjectionSystems.crs;

    if (!oSrs) {
      logger.log("ERROR : system crs not found");
      return;
    }

    var xy;

    if (this._currentProjectionSystems.type === "Geographical") {
      xy = [this.convert(lon), this.convert(lat)];
    } else {
      xy = [this.convert(lat), this.convert(lon)];
    }

    var xyWGS84 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["transform"])(xy, this._currentProjectionSystems.crs, "EPSG:4326");
    var geoBBox = this._currentProjectionSystems.geoBBox;

    if (geoBBox) {
      // check if coordinates are in the extent
      var extent = [geoBBox.left, geoBBox.bottom, geoBBox.right, geoBBox.top];

      if (xyWGS84[0] < extent[0] || xyWGS84[0] > extent[2]) {
        return;
      }

      if (xyWGS84[1] < extent[1] || xyWGS84[1] > extent[3]) {
        return;
      }
    }

    var view = this.getMap().getView();
    var coordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["transform"])(xy, oSrs, view.getProjection());
    view.setCenter(coordinate);

    if (this._markerOverlay && !this._hideMarker) {
      this._markerOverlay.setPosition(coordinate);
    }
  };
  /**
   * locate coordinates on map
   *
   * @private
   */


  MousePosition.prototype.onMousePositionEditModeLocateClick = function () {
    if (!this.options.editCoordinates) {
      return;
    }

    if (!this.editing) {
      this.onMousePositionEditModeClick(true);
      return;
    }

    if (this._currentProjectionUnits === "DMS") {
      this.locateDMSCoordinates();
    } else {
      this.locateCoordinates();
    } // fonction


    var mapCenterFunction = this.options.mapCenterCallback; // execution...

    if (typeof mapCenterFunction === "function") {
      var view = this.getMap().getView();
      var center = view.getCenter();
      mapCenterFunction.call(this, center);
    }
  };
  /**
   * this method is called by event 'change' on 'GPmousePositionProjectionSystem'
   * tag select (cf. this._createMousePositionSettingsElement),
   * and selects the system projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  MousePosition.prototype.onMousePositionProjectionSystemChange = function (e) {
    var idx = e.target.selectedIndex; // index

    var value = e.target.options[idx].value; // crs

    this._setCurrentSystem(value);
  };
  /**
   * this method selects the current system projection.
   *
   * @param {String} systemCode - inner code (rank in array _projectionSystems)
   * @private
   */


  MousePosition.prototype._setCurrentSystem = function (systemCode) {
    // si on change de type de systeme, on doit aussi changer le type d'unités !
    var type = null;

    for (var i = 0; i < this._projectionSystems.length; ++i) {
      if (this._projectionSystems[i].code === Number(systemCode)) {
        type = this._projectionSystems[i].type;
        break;
      }
    }

    if (!type) {
      logger.log("system not found in projection systems container");
      return;
    } // on enregistre le systeme courant


    this._currentProjectionSystems = this._projectionSystems[Number(systemCode)];

    if (type !== this._currentProjectionType) {
      this._setTypeUnitsPanel(type);
    } // on simule un deplacement en mode tactile pour mettre à jour les
    // resultats


    if (!this._isDesktop) {
      this.onMapMove();
    }
  };
  /**
   * this method is called by event 'mouseover' on 'GPmousePositionProjectionSystem'
   * tag select (cf. this._createMousePositionSettingsElement),
   * and selects the system projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  MousePosition.prototype.onMousePositionProjectionSystemMouseOver = function (e) {
    logger.trace(e); // map infos

    var map = this.getMap();

    if (!map || !map.getView()) {
      return;
    }

    var view = map.getView();
    var crs = view.getProjection();
    var mapExtent = view.calculateExtent(map.getSize()); // get extent in WGS84 coordinates

    mapExtent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["transformExtent"])(mapExtent, crs, "EPSG:4326");
    /* clear select */

    var systemList = document.getElementById(this._addUID("GPmousePositionProjectionSystem"));
    systemList.innerHTML = ""; // add systems whose extent intersects the map extent

    for (var j = 0; j < this._projectionSystems.length; j++) {
      var proj = this._projectionSystems[j];
      var option = null;

      if (proj.geoBBox) {
        /* bboxes intersection test */
        if (mapExtent[0] > proj.geoBBox.right || mapExtent[1] > proj.geoBBox.top || mapExtent[2] < proj.geoBBox.left || mapExtent[3] < proj.geoBBox.bottom) {
          if (proj === this._currentProjectionSystems) {
            option = document.createElement("option");
            option.value = proj.code;
            option.text = proj.label || j;
            option.setAttribute("selected", "selected");
            option.setAttribute("disabled", "disabled");
            systemList.appendChild(option);
          }

          continue; // do not intersect
        }
      }

      var optionElement = document.createElement("option");
      optionElement.value = proj.code;
      optionElement.text = proj.label || j;

      if (proj === this._currentProjectionSystems) {
        optionElement.setAttribute("selected", "selected");
      }

      systemList.appendChild(optionElement);
    }
  };
  /**
   * this method is called by event 'change' on 'GPmousePositionProjectionUnits'
   * tag select (cf. this._createMousePositionSettingsElement),
   * and selects the units projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  MousePosition.prototype.onMousePositionProjectionUnitsChange = function (e) {
    var idx = e.target.selectedIndex;
    var value = e.target.options[idx].value;
    var oldProjectionUnits = this._currentProjectionUnits;
    this._currentProjectionUnits = value; // Mise a jour des elements lebels et unites

    this._resetLabelElements(this._currentProjectionType);

    this._resetUnitElements(this._currentProjectionUnits); // mise a jour des inputs pour les coordonnees


    if (oldProjectionUnits === "DMS" || this._currentProjectionUnits === "DMS") {
      this._resetCoordinateElements(this.options.editCoordinates, this._currentProjectionType, this._currentProjectionUnits);

      this._setEditMode(this.editing);
    } // on simule un deplacement en mode tactile pour mettre à jour les
    // resultats


    if (!this._isDesktop) {
      this.onMapMove();
    }
  };
  /**
   *
   * @param {Number} value - value to convert (km to meters, radians, grades to decimal degrees)
   * @returns {undefined}
   * @private
   */


  MousePosition.prototype.convert = function (value) {
    var result;

    if (this._currentProjectionUnits === "M" || this._currentProjectionUnits === "DEC") {
      result = value;
    } else if (this._currentProjectionUnits === "KM") {
      result = value * 1000;
    } else if (this._currentProjectionUnits === "RAD") {
      var rd = (180 / Math.PI).toFixed(20);
      result = (value * rd).toFixed(20);
    } else if (this._currentProjectionUnits === "GON") {
      var d = (9 / 10).toFixed(20);
      result = (value * d).toFixed(20);
    }

    return result;
  };
  /**
   * @param {String} coordType - "Lon" or "Lat"
   * @param {String} value - input value
   *
   * @returns {Boolean} value is within extent
   *
   * @private
   */


  MousePosition.prototype.validateExtentCoordinate = function (coordType, value) {
    if (["Lon", "Lat"].indexOf(coordType) === -1) {
      return false;
    }

    var coord = value.replace(",", ".");
    coord = _Common_Utils_MathUtils__WEBPACK_IMPORTED_MODULE_12__["default"].toFloat(coord);

    if (coord === null) {
      return false;
    } // convert depending on _currentProjectionUnits


    coord = this.convert(coord);
    var geoBBox = this._currentProjectionSystems.geoBBox;

    if (geoBBox === undefined) {
      return true;
    } // convert to current projection system


    var extent = [geoBBox.left, geoBBox.bottom, geoBBox.right, geoBBox.top];
    extent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_4__["transformExtent"])(extent, "EPSG:4326", this._currentProjectionSystems.crs); // checking if value is in the right interval

    if (coordType === "Lat" && (coord < extent[0] || coord > extent[2])) {
      return false;
    }

    if (coordType === "Lon" && (coord < extent[1] || coord > extent[3])) {
      return false;
    }

    return true;
  };

  return MousePosition;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (MousePosition); // Expose MousePosition as ol.control.MousePosition (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.GeoportalMousePosition = MousePosition;
}

/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
* @module MathUtils
* @alias Gp.MathUtils
* @description
* ...
*
* @example
* modulo();
* decimalToDMS();
* toInteger();
* isInteger();
* toFloat();
*/
var MathUtils = {
  /**
   * Reste de la division euclidienne
   * @param {Number} a - divisor
   * @param {Number} b - quotient
   * @returns {Number} Modulo
   */
  modulo: function modulo(a, b) {
    var r = a % b;
    return r * b < 0 ? r + b : r;
  },

  /**
   * Transform degrees, minutes, seconds form decimal degrees -
   * Largely inspired by the private function degreesToStringHDMS from ol/coordinate.js
   *
   * @param {Number} degrees - decimal degrees
   * @param {Array} hemispheres - "NS" ou "EO"
   * @param {Number} numDigits - number of digits for seconds
   * @returns {Object} DMS coordinate
   */
  decimalToDMS: function decimalToDMS(degrees, hemispheres, numDigits) {
    var normalizedDegrees = this.modulo(degrees + 180, 360) - 180;
    var x = Math.abs(3600 * normalizedDegrees);
    var dflPrecision = numDigits || 0;
    var precision = Math.pow(10, dflPrecision);
    var deg = Math.floor(x / 3600);
    var min = Math.floor((x - deg * 3600) / 60);
    var sec = x - deg * 3600 - min * 60;
    sec = Math.ceil(sec * precision) / precision;

    if (sec >= 60) {
      sec = 0;
      min += 1;
    }

    if (min >= 60) {
      min = 0;
      deg += 1;
    }

    var direction = hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
    return {
      d: deg,
      m: min,
      s: sec,
      direction: direction
    };
  },

  /**
   * Converts string to Integer
   *
   * @param {String} s - string number
   * @param {Numeric} base - between 2 and 36
   * @returns {null|Numeric} result
   */
  toInteger: function toInteger(s, base) {
    var _base = base || 10;

    var n = parseInt(s, _base);

    if (!isNaN(n) && isFinite(n)) {
      return n;
    }

    return null;
  },

  /**
   * check if s represents an integer
   *
   * @param {String} s - string number
   * @returns {Boolean} is integer
   */
  isInteger: function isInteger(s) {
    if (isNaN(s)) {
      return false;
    }

    var v = parseFloat(s);
    return (v | 0) === v;
  },

  /**
   * Converts s to float
   *
   * @param {String} s - string number
   * @returns {null|Numeric} result
   */
  toFloat: function toFloat(s) {
    var n = parseFloat(s);

    if (!isNaN(n) && isFinite(n)) {
      return n;
    }

    return null;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (MathUtils);

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);

var logger = _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("draggable");
var Draggable = {
  /**
  * A draggable HTML element with JavaScript and CSS.
  *
  * @param {DOMElement} element - element
  * @param {DOMElement} header - header (optional)
  * @param {DOMElement} container - container (optional)
  * @see https://www.w3schools.com/howto/howto_js_draggable.asp
  * @see https://stackoverflow.com/questions/52231588/how-to-constrain-div-drag-space-no-jquery
  * @example
  *   // CSS :
  *       // #element { position: absolute; }
  *   // HTML :
  *       // <div id="container">
  *       //   <div id="element">
  *       //     <div id="header"/>
  *       //      <div/> ...
  *       //     </div>
  *       //   </div>
  *       // </div>
  *   // JS :
  *       var element = document.getElementById("element");
  *       Draggable.dragElement(element, header, container);
  */
  dragElement: function dragElement(element, header, container) {
    var offsetX, offsetY;
    var isDragReady = false;
    var dragoffset = {
      x: 0,
      y: 0
    };

    if (header) {
      header.addEventListener("mousedown", dragMouseDown, true);
    } else {
      element.addEventListener("mousedown", dragMouseDown, true);
    } // TODO mettre en place les contraintes
    // var constraints = {};
    // if (container) {
    //     constraints = {
    //         width : container.clientWidth,
    //         height : container.clientHeight,
    //         top : container.offsetTop,
    //         left : container.offsetLeft
    //     };
    // }


    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      isDragReady = true; // get the mouse cursor position at startup

      e._pageX = e._pageX || e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
      e._pageY = e._pageY || e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      dragoffset.x = e._pageX - element.offsetLeft;
      dragoffset.y = e._pageY - element.offsetTop;
      document.addEventListener("mouseup", closeDragElement, true);
      document.addEventListener("mousemove", elementDrag, true);
    }

    function closeDragElement() {
      /* stop moving when mouse button is released: */
      isDragReady = false;
      document.removeEventListener("mouseup", closeDragElement, true);
      document.removeEventListener("mousemove", elementDrag, true);
    }

    function elementDrag(e) {
      e = e || window.event; // e.preventDefault();
      // cf. https://jsfiddle.net/nbbg08mg/2/

      if (isDragReady) {
        e._pageX = e._pageX || e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
        e._pageY = e._pageY || e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
        var parentLeft = element.parentElement.offsetLeft;
        var parentTop = element.parentElement.offsetTop;
        logger.trace("parent offset", parentLeft, parentTop); // left/right constraint

        if (e._pageX - dragoffset.x < 0 - parentLeft) {
          offsetX = 0 - parentLeft;
        } else if (e._pageX - dragoffset.x + element.clientWidth > document.body.clientWidth) {
          offsetX = document.body.clientWidth - element.clientWidth;
        } else {
          offsetX = e._pageX - dragoffset.x;
        }

        logger.trace("left/right constraint", offsetX); // top/bottom constraint

        if (e._pageY - dragoffset.y < 0 - parentTop) {
          offsetY = 0 - parentTop;
        } else if (e._pageY - dragoffset.y + element.clientHeight > document.body.clientHeight) {
          offsetY = document.body.clientHeight - element.clientHeight;
        } else {
          offsetY = e._pageY - dragoffset.y;
        }

        logger.trace("top/bottom constraint", offsetY); // set the element's new position:

        element.style.top = offsetY + "px";
        element.style.left = offsetX + "px";
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Draggable);

/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(187);
/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(proj4__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Proj4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(189);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(159);
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_extent__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Common_Utils_Register__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(192);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(141);
/*
 * FIXME
 * en mode bundle, l'action register des methodes de chargement est executée 2 fois.
 * mais aucun impact sur performance, car le register teste si la projection a été déjà
 * chargé...
 */
// import external
 // import OpenLayers
// import { register } from "ol/proj/proj4";


 // import { clear as clearProj } from "ol/proj/transforms";

 // import local



var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__["default"].getLogger("CRS");
var CRS = {
  /**
  * List of extent projections
  */
  projectionsExtent: {
    "EPSG:2154": {
      left: -9.62,
      bottom: 41.18,
      right: 10.3,
      top: 51.54
    },
    "EPSG:27572": {
      left: -4.87,
      bottom: 42.33,
      right: 8.23,
      top: 51.14
    }
  },

  /**
  * Load all custom definition projection
  */
  load: function load() {
    logger.trace("Loading custom definitions projections"); // loading except if it's already loaded...

    if (!_Common_Utils_Register__WEBPACK_IMPORTED_MODULE_4__["default"].isLoaded) {
      // load all defs into proj4
      _Common_Utils_Register__WEBPACK_IMPORTED_MODULE_4__["default"].load(proj4__WEBPACK_IMPORTED_MODULE_0___default.a);

      try {
        // register all defs
        Object(_Proj4__WEBPACK_IMPORTED_MODULE_1__["register"])(proj4__WEBPACK_IMPORTED_MODULE_0___default.a); // Expose proj4 with custom defs into OpenLayers global variable

        if (window.ol && window.ol.proj && window.ol.proj.proj4) {
          window.ol.proj.proj4.register = _Proj4__WEBPACK_IMPORTED_MODULE_1__["register"];
          window.ol.proj.proj4.register(proj4__WEBPACK_IMPORTED_MODULE_0___default.a);
        }
      } catch (e) {
        // FIXME ?
        logger.error(e); // clearProj();
      }
    }
  },

  /**
  * Load definition projection by default
  *
  * include into proj4 :
  * - WGS84
  * - ['EPSG:4326']
  * - ['EPSG:3785'], ['EPSG:3857'], GOOGLE, ['EPSG:900913'], ['EPSG:102113']
  * +
  * - ["EPSG:2154"], ["EPSG:27571"],  ["EPSG:27572"],  ["EPSG:27573"],  ["EPSG:2757"],
  * - ["CRS:84"],
  * - ["IGNF:LAMB93"],
  * - ["IGNF:LAMBE"], ["IGNF:LAMB1"],  ["IGNF:LAMB2"],  ["IGNF:LAMB3"],  ["IGNF:LAMB4"],
  * - ["IGNF:RGF93G"],
  * - ["IGNF:WGS84G"]
  */
  loadByDefault: function loadByDefault() {
    logger.trace("Loading custom definitions projections by default"); // loading except if it's already loaded...

    if (!_Common_Utils_Register__WEBPACK_IMPORTED_MODULE_4__["default"].isLoaded) {
      // load defs by default into proj4
      _Common_Utils_Register__WEBPACK_IMPORTED_MODULE_4__["default"].loadByDefault(proj4__WEBPACK_IMPORTED_MODULE_0___default.a);

      try {
        // register all defs
        Object(_Proj4__WEBPACK_IMPORTED_MODULE_1__["register"])(proj4__WEBPACK_IMPORTED_MODULE_0___default.a); // Expose proj4 with custom defs into OpenLayers global variable

        if (window.ol && window.ol.proj && window.ol.proj.proj4) {
          window.ol.proj.proj4.register = _Proj4__WEBPACK_IMPORTED_MODULE_1__["register"];
          window.ol.proj.proj4.register(proj4__WEBPACK_IMPORTED_MODULE_0___default.a);
        }
      } catch (e) {
        // FIXME une projection ne passe pas avec ol.proj/proj4.register()...
        // on fait quoi ?
        logger.error(e); // clearProj();
      }
    }
  },

  /**
  * Load a custom definition projection
  * @param {String} name - ie. EPSG:2154 (Lambert)
  */
  loadByName: function loadByName(name) {
    logger.trace("Loading a custom definition projection : ", name); // loading except if it's already loaded...

    if (!_Common_Utils_Register__WEBPACK_IMPORTED_MODULE_4__["default"].isLoaded) {
      // load defs by default into proj4
      _Common_Utils_Register__WEBPACK_IMPORTED_MODULE_4__["default"].loadByName(proj4__WEBPACK_IMPORTED_MODULE_0___default.a, name);

      try {
        // register all defs
        Object(_Proj4__WEBPACK_IMPORTED_MODULE_1__["register"])(proj4__WEBPACK_IMPORTED_MODULE_0___default.a); // Expose proj4 with custom defs into OpenLayers global variable

        if (window.ol && window.ol.proj && window.ol.proj.proj4) {
          window.ol.proj.proj4.register = _Proj4__WEBPACK_IMPORTED_MODULE_1__["register"];
          window.ol.proj.proj4.register(proj4__WEBPACK_IMPORTED_MODULE_0___default.a);
        }
      } catch (e) {
        // FIXME ?
        logger.error(e); // clearProj();
      }
    }
  },

  /**
   * Overload OpenLayers ol.proj parameters,
   * to manage EPSG:2154 extent restriction
   */
  overload: function overload() {
    logger.trace("Loading projections aera (extent)");

    for (var code in this.projectionsExtent) {
      if (this.projectionsExtent.hasOwnProperty(code)) {
        var extent = this.projectionsExtent[code];
        var proj = Object(ol_proj__WEBPACK_IMPORTED_MODULE_2__["get"])(code);
        var fromLonLat = Object(ol_proj__WEBPACK_IMPORTED_MODULE_2__["getTransform"])("EPSG:4326", proj); // very approximate calculation of projection extent

        var _extent = Object(ol_extent__WEBPACK_IMPORTED_MODULE_3__["applyTransform"])([extent.bottom, extent.right, extent.top, extent.left], fromLonLat);

        proj.setExtent(_extent);
        Object(ol_proj__WEBPACK_IMPORTED_MODULE_2__["addProjection"])(proj); // Expose projection extent with custom defs into OpenLayers global variable

        if (window.ol && window.ol.proj && window.ol.proj.addProjection) {
          window.ol.proj.addProjection(proj);
        }
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (CRS); // Expose proj4 with custom defs into OpenLayers global variable

if (window.ol && window.ol.proj && window.ol.proj.proj4) {
  window.ol.proj.proj4.register = _Proj4__WEBPACK_IMPORTED_MODULE_1__["register"];
}

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["proj4"] = __webpack_require__(188);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(62)))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? module.exports = factory() :
    undefined;
}(this, (function () { 'use strict';

    var globals = function(defs) {
      defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
      defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
      defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

      defs.WGS84 = defs['EPSG:4326'];
      defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
      defs.GOOGLE = defs['EPSG:3857'];
      defs['EPSG:900913'] = defs['EPSG:3857'];
      defs['EPSG:102113'] = defs['EPSG:3857'];
    };

    var PJD_3PARAM = 1;
    var PJD_7PARAM = 2;
    var PJD_GRIDSHIFT = 3;
    var PJD_WGS84 = 4; // WGS84 or equivalent
    var PJD_NODATUM = 5; // WGS84 or equivalent
    var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
    var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
    var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
    var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
    var HALF_PI = Math.PI/2;
    // ellipoid pj_set_ell.c
    var SIXTH = 0.1666666666666666667;
    /* 1/6 */
    var RA4 = 0.04722222222222222222;
    /* 17/360 */
    var RA6 = 0.02215608465608465608;
    var EPSLN = 1.0e-10;
    // you'd think you could use Number.EPSILON above but that makes
    // Mollweide get into an infinate loop.

    var D2R = 0.01745329251994329577;
    var R2D = 57.29577951308232088;
    var FORTPI = Math.PI/4;
    var TWO_PI = Math.PI * 2;
    // SPI is slightly greater than Math.PI, so values that exceed the -180..180
    // degree range by a tiny amount don't get wrapped. This prevents points that
    // have drifted from their original location along the 180th meridian (due to
    // floating point error) from changing their sign.
    var SPI = 3.14159265359;

    var exports$1 = {};
    exports$1.greenwich = 0.0; //"0dE",
    exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
    exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
    exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
    exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
    exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
    exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
    exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
    exports$1.ferro = -17.666666666667; //"17d40'W",
    exports$1.brussels = 4.367975; //"4d22'4.71\"E",
    exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
    exports$1.athens = 23.7163375; //"23d42'58.815\"E",
    exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

    var units = {
      ft: {to_meter: 0.3048},
      'us-ft': {to_meter: 1200 / 3937}
    };

    var ignoredChar = /[\s_\-\/\(\)]/g;
    function match(obj, key) {
      if (obj[key]) {
        return obj[key];
      }
      var keys = Object.keys(obj);
      var lkey = key.toLowerCase().replace(ignoredChar, '');
      var i = -1;
      var testkey, processedKey;
      while (++i < keys.length) {
        testkey = keys[i];
        processedKey = testkey.toLowerCase().replace(ignoredChar, '');
        if (processedKey === lkey) {
          return obj[testkey];
        }
      }
    }

    var parseProj = function(defData) {
      var self = {};
      var paramObj = defData.split('+').map(function(v) {
        return v.trim();
      }).filter(function(a) {
        return a;
      }).reduce(function(p, a) {
        var split = a.split('=');
        split.push(true);
        p[split[0].toLowerCase()] = split[1];
        return p;
      }, {});
      var paramName, paramVal, paramOutname;
      var params = {
        proj: 'projName',
        datum: 'datumCode',
        rf: function(v) {
          self.rf = parseFloat(v);
        },
        lat_0: function(v) {
          self.lat0 = v * D2R;
        },
        lat_1: function(v) {
          self.lat1 = v * D2R;
        },
        lat_2: function(v) {
          self.lat2 = v * D2R;
        },
        lat_ts: function(v) {
          self.lat_ts = v * D2R;
        },
        lon_0: function(v) {
          self.long0 = v * D2R;
        },
        lon_1: function(v) {
          self.long1 = v * D2R;
        },
        lon_2: function(v) {
          self.long2 = v * D2R;
        },
        alpha: function(v) {
          self.alpha = parseFloat(v) * D2R;
        },
        gamma: function(v) {
          self.rectified_grid_angle = parseFloat(v);
        },
        lonc: function(v) {
          self.longc = v * D2R;
        },
        x_0: function(v) {
          self.x0 = parseFloat(v);
        },
        y_0: function(v) {
          self.y0 = parseFloat(v);
        },
        k_0: function(v) {
          self.k0 = parseFloat(v);
        },
        k: function(v) {
          self.k0 = parseFloat(v);
        },
        a: function(v) {
          self.a = parseFloat(v);
        },
        b: function(v) {
          self.b = parseFloat(v);
        },
        r_a: function() {
          self.R_A = true;
        },
        zone: function(v) {
          self.zone = parseInt(v, 10);
        },
        south: function() {
          self.utmSouth = true;
        },
        towgs84: function(v) {
          self.datum_params = v.split(",").map(function(a) {
            return parseFloat(a);
          });
        },
        to_meter: function(v) {
          self.to_meter = parseFloat(v);
        },
        units: function(v) {
          self.units = v;
          var unit = match(units, v);
          if (unit) {
            self.to_meter = unit.to_meter;
          }
        },
        from_greenwich: function(v) {
          self.from_greenwich = v * D2R;
        },
        pm: function(v) {
          var pm = match(exports$1, v);
          self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
        },
        nadgrids: function(v) {
          if (v === '@null') {
            self.datumCode = 'none';
          }
          else {
            self.nadgrids = v;
          }
        },
        axis: function(v) {
          var legalAxis = "ewnsud";
          if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
            self.axis = v;
          }
        },
        approx: function() {
          self.approx = true;
        }
      };
      for (paramName in paramObj) {
        paramVal = paramObj[paramName];
        if (paramName in params) {
          paramOutname = params[paramName];
          if (typeof paramOutname === 'function') {
            paramOutname(paramVal);
          }
          else {
            self[paramOutname] = paramVal;
          }
        }
        else {
          self[paramName] = paramVal;
        }
      }
      if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
        self.datumCode = self.datumCode.toLowerCase();
      }
      return self;
    };

    var NEUTRAL = 1;
    var KEYWORD = 2;
    var NUMBER = 3;
    var QUOTED = 4;
    var AFTERQUOTE = 5;
    var ENDED = -1;
    var whitespace = /\s/;
    var latin = /[A-Za-z]/;
    var keyword = /[A-Za-z84]/;
    var endThings = /[,\]]/;
    var digets = /[\d\.E\-\+]/;
    // const ignoredChar = /[\s_\-\/\(\)]/g;
    function Parser(text) {
      if (typeof text !== 'string') {
        throw new Error('not a string');
      }
      this.text = text.trim();
      this.level = 0;
      this.place = 0;
      this.root = null;
      this.stack = [];
      this.currentObject = null;
      this.state = NEUTRAL;
    }
    Parser.prototype.readCharicter = function() {
      var char = this.text[this.place++];
      if (this.state !== QUOTED) {
        while (whitespace.test(char)) {
          if (this.place >= this.text.length) {
            return;
          }
          char = this.text[this.place++];
        }
      }
      switch (this.state) {
        case NEUTRAL:
          return this.neutral(char);
        case KEYWORD:
          return this.keyword(char)
        case QUOTED:
          return this.quoted(char);
        case AFTERQUOTE:
          return this.afterquote(char);
        case NUMBER:
          return this.number(char);
        case ENDED:
          return;
      }
    };
    Parser.prototype.afterquote = function(char) {
      if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
      }
      if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
    };
    Parser.prototype.afterItem = function(char) {
      if (char === ',') {
        if (this.word !== null) {
          this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
      }
      if (char === ']') {
        this.level--;
        if (this.word !== null) {
          this.currentObject.push(this.word);
          this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
          this.state = ENDED;
        }

        return;
      }
    };
    Parser.prototype.number = function(char) {
      if (digets.test(char)) {
        this.word += char;
        return;
      }
      if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
    };
    Parser.prototype.quoted = function(char) {
      if (char === '"') {
        this.state = AFTERQUOTE;
        return;
      }
      this.word += char;
      return;
    };
    Parser.prototype.keyword = function(char) {
      if (keyword.test(char)) {
        this.word += char;
        return;
      }
      if (char === '[') {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
          this.root = newObjects;
        } else {
          this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
    };
    Parser.prototype.neutral = function(char) {
      if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
      }
      if (char === '"') {
        this.word = '';
        this.state = QUOTED;
        return;
      }
      if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
    };
    Parser.prototype.output = function() {
      while (this.place < this.text.length) {
        this.readCharicter();
      }
      if (this.state === ENDED) {
        return this.root;
      }
      throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
    };

    function parseString(txt) {
      var parser = new Parser(txt);
      return parser.output();
    }

    function mapit(obj, key, value) {
      if (Array.isArray(key)) {
        value.unshift(key);
        key = null;
      }
      var thing = key ? {} : obj;

      var out = value.reduce(function(newObj, item) {
        sExpr(item, newObj);
        return newObj
      }, thing);
      if (key) {
        obj[key] = out;
      }
    }

    function sExpr(v, obj) {
      if (!Array.isArray(v)) {
        obj[v] = true;
        return;
      }
      var key = v.shift();
      if (key === 'PARAMETER') {
        key = v.shift();
      }
      if (v.length === 1) {
        if (Array.isArray(v[0])) {
          obj[key] = {};
          sExpr(v[0], obj[key]);
          return;
        }
        obj[key] = v[0];
        return;
      }
      if (!v.length) {
        obj[key] = true;
        return;
      }
      if (key === 'TOWGS84') {
        obj[key] = v;
        return;
      }
      if (key === 'AXIS') {
        if (!(key in obj)) {
          obj[key] = [];
        }
        obj[key].push(v);
        return;
      }
      if (!Array.isArray(key)) {
        obj[key] = {};
      }

      var i;
      switch (key) {
        case 'UNIT':
        case 'PRIMEM':
        case 'VERT_DATUM':
          obj[key] = {
            name: v[0].toLowerCase(),
            convert: v[1]
          };
          if (v.length === 3) {
            sExpr(v[2], obj[key]);
          }
          return;
        case 'SPHEROID':
        case 'ELLIPSOID':
          obj[key] = {
            name: v[0],
            a: v[1],
            rf: v[2]
          };
          if (v.length === 4) {
            sExpr(v[3], obj[key]);
          }
          return;
        case 'PROJECTEDCRS':
        case 'PROJCRS':
        case 'GEOGCS':
        case 'GEOCCS':
        case 'PROJCS':
        case 'LOCAL_CS':
        case 'GEODCRS':
        case 'GEODETICCRS':
        case 'GEODETICDATUM':
        case 'EDATUM':
        case 'ENGINEERINGDATUM':
        case 'VERT_CS':
        case 'VERTCRS':
        case 'VERTICALCRS':
        case 'COMPD_CS':
        case 'COMPOUNDCRS':
        case 'ENGINEERINGCRS':
        case 'ENGCRS':
        case 'FITTED_CS':
        case 'LOCAL_DATUM':
        case 'DATUM':
          v[0] = ['name', v[0]];
          mapit(obj, key, v);
          return;
        default:
          i = -1;
          while (++i < v.length) {
            if (!Array.isArray(v[i])) {
              return sExpr(v, obj[key]);
            }
          }
          return mapit(obj, key, v);
      }
    }

    var D2R$1 = 0.01745329251994329577;
    function rename(obj, params) {
      var outName = params[0];
      var inName = params[1];
      if (!(outName in obj) && (inName in obj)) {
        obj[outName] = obj[inName];
        if (params.length === 3) {
          obj[outName] = params[2](obj[outName]);
        }
      }
    }

    function d2r(input) {
      return input * D2R$1;
    }

    function cleanWKT(wkt) {
      if (wkt.type === 'GEOGCS') {
        wkt.projName = 'longlat';
      } else if (wkt.type === 'LOCAL_CS') {
        wkt.projName = 'identity';
        wkt.local = true;
      } else {
        if (typeof wkt.PROJECTION === 'object') {
          wkt.projName = Object.keys(wkt.PROJECTION)[0];
        } else {
          wkt.projName = wkt.PROJECTION;
        }
      }
      if (wkt.AXIS) {
        var axisOrder = '';
        for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
          var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
          if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
            axisOrder += 'n';
          } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
            axisOrder += 's';
          } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
            axisOrder += 'e';
          } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
            axisOrder += 'w';
          }
        }
        if (axisOrder.length === 2) {
          axisOrder += 'u';
        }
        if (axisOrder.length === 3) {
          wkt.axis = axisOrder;
        }
      }
      if (wkt.UNIT) {
        wkt.units = wkt.UNIT.name.toLowerCase();
        if (wkt.units === 'metre') {
          wkt.units = 'meter';
        }
        if (wkt.UNIT.convert) {
          if (wkt.type === 'GEOGCS') {
            if (wkt.DATUM && wkt.DATUM.SPHEROID) {
              wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
            }
          } else {
            wkt.to_meter = wkt.UNIT.convert;
          }
        }
      }
      var geogcs = wkt.GEOGCS;
      if (wkt.type === 'GEOGCS') {
        geogcs = wkt;
      }
      if (geogcs) {
        //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
        //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
        //}
        if (geogcs.DATUM) {
          wkt.datumCode = geogcs.DATUM.name.toLowerCase();
        } else {
          wkt.datumCode = geogcs.name.toLowerCase();
        }
        if (wkt.datumCode.slice(0, 2) === 'd_') {
          wkt.datumCode = wkt.datumCode.slice(2);
        }
        if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
          wkt.datumCode = 'nzgd49';
        }
        if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
          if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
            wkt.sphere = true;
          }
          wkt.datumCode = 'wgs84';
        }
        if (wkt.datumCode.slice(-6) === '_ferro') {
          wkt.datumCode = wkt.datumCode.slice(0, - 6);
        }
        if (wkt.datumCode.slice(-8) === '_jakarta') {
          wkt.datumCode = wkt.datumCode.slice(0, - 8);
        }
        if (~wkt.datumCode.indexOf('belge')) {
          wkt.datumCode = 'rnb72';
        }
        if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
          wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
          if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
            wkt.ellps = 'intl';
          }

          wkt.a = geogcs.DATUM.SPHEROID.a;
          wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
        }

        if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
          wkt.datum_params = geogcs.DATUM.TOWGS84;
        }
        if (~wkt.datumCode.indexOf('osgb_1936')) {
          wkt.datumCode = 'osgb36';
        }
        if (~wkt.datumCode.indexOf('osni_1952')) {
          wkt.datumCode = 'osni52';
        }
        if (~wkt.datumCode.indexOf('tm65')
          || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
          wkt.datumCode = 'ire65';
        }
        if (wkt.datumCode === 'ch1903+') {
          wkt.datumCode = 'ch1903';
        }
        if (~wkt.datumCode.indexOf('israel')) {
          wkt.datumCode = 'isr93';
        }
      }
      if (wkt.b && !isFinite(wkt.b)) {
        wkt.b = wkt.a;
      }

      function toMeter(input) {
        var ratio = wkt.to_meter || 1;
        return input * ratio;
      }
      var renamer = function(a) {
        return rename(wkt, a);
      };
      var list = [
        ['standard_parallel_1', 'Standard_Parallel_1'],
        ['standard_parallel_1', 'Latitude of 1st standard parallel'],
        ['standard_parallel_2', 'Standard_Parallel_2'],
        ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
        ['false_easting', 'False_Easting'],
        ['false_easting', 'False easting'],
        ['false-easting', 'Easting at false origin'],
        ['false_northing', 'False_Northing'],
        ['false_northing', 'False northing'],
        ['false_northing', 'Northing at false origin'],
        ['central_meridian', 'Central_Meridian'],
        ['central_meridian', 'Longitude of natural origin'],
        ['central_meridian', 'Longitude of false origin'],
        ['latitude_of_origin', 'Latitude_Of_Origin'],
        ['latitude_of_origin', 'Central_Parallel'],
        ['latitude_of_origin', 'Latitude of natural origin'],
        ['latitude_of_origin', 'Latitude of false origin'],
        ['scale_factor', 'Scale_Factor'],
        ['k0', 'scale_factor'],
        ['latitude_of_center', 'Latitude_Of_Center'],
        ['latitude_of_center', 'Latitude_of_center'],
        ['lat0', 'latitude_of_center', d2r],
        ['longitude_of_center', 'Longitude_Of_Center'],
        ['longitude_of_center', 'Longitude_of_center'],
        ['longc', 'longitude_of_center', d2r],
        ['x0', 'false_easting', toMeter],
        ['y0', 'false_northing', toMeter],
        ['long0', 'central_meridian', d2r],
        ['lat0', 'latitude_of_origin', d2r],
        ['lat0', 'standard_parallel_1', d2r],
        ['lat1', 'standard_parallel_1', d2r],
        ['lat2', 'standard_parallel_2', d2r],
        ['azimuth', 'Azimuth'],
        ['alpha', 'azimuth', d2r],
        ['srsCode', 'name']
      ];
      list.forEach(renamer);
      if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
        wkt.long0 = wkt.longc;
      }
      if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
        wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
        wkt.lat_ts = wkt.lat1;
      }
    }
    var wkt = function(wkt) {
      var lisp = parseString(wkt);
      var type = lisp.shift();
      var name = lisp.shift();
      lisp.unshift(['name', name]);
      lisp.unshift(['type', type]);
      var obj = {};
      sExpr(lisp, obj);
      cleanWKT(obj);
      return obj;
    };

    function defs(name) {
      /*global console*/
      var that = this;
      if (arguments.length === 2) {
        var def = arguments[1];
        if (typeof def === 'string') {
          if (def.charAt(0) === '+') {
            defs[name] = parseProj(arguments[1]);
          }
          else {
            defs[name] = wkt(arguments[1]);
          }
        } else {
          defs[name] = def;
        }
      }
      else if (arguments.length === 1) {
        if (Array.isArray(name)) {
          return name.map(function(v) {
            if (Array.isArray(v)) {
              defs.apply(that, v);
            }
            else {
              defs(v);
            }
          });
        }
        else if (typeof name === 'string') {
          if (name in defs) {
            return defs[name];
          }
        }
        else if ('EPSG' in name) {
          defs['EPSG:' + name.EPSG] = name;
        }
        else if ('ESRI' in name) {
          defs['ESRI:' + name.ESRI] = name;
        }
        else if ('IAU2000' in name) {
          defs['IAU2000:' + name.IAU2000] = name;
        }
        else {
          console.log(name);
        }
        return;
      }


    }
    globals(defs);

    function testObj(code){
      return typeof code === 'string';
    }
    function testDef(code){
      return code in defs;
    }
    var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
    function testWKT(code){
      return codeWords.some(function (word) {
        return code.indexOf(word) > -1;
      });
    }
    var codes = ['3857', '900913', '3785', '102113'];
    function checkMercator(item) {
      var auth = match(item, 'authority');
      if (!auth) {
        return;
      }
      var code = match(auth, 'epsg');
      return code && codes.indexOf(code) > -1;
    }
    function checkProjStr(item) {
      var ext = match(item, 'extension');
      if (!ext) {
        return;
      }
      return match(ext, 'proj4');
    }
    function testProj(code){
      return code[0] === '+';
    }
    function parse(code){
      if (testObj(code)) {
        //check to see if this is a WKT string
        if (testDef(code)) {
          return defs[code];
        }
        if (testWKT(code)) {
          var out = wkt(code);
          // test of spetial case, due to this being a very common and often malformed
          if (checkMercator(out)) {
            return defs['EPSG:3857'];
          }
          var maybeProjStr = checkProjStr(out);
          if (maybeProjStr) {
            return parseProj(maybeProjStr);
          }
          return out;
        }
        if (testProj(code)) {
          return parseProj(code);
        }
      }else{
        return code;
      }
    }

    var extend = function(destination, source) {
      destination = destination || {};
      var value, property;
      if (!source) {
        return destination;
      }
      for (property in source) {
        value = source[property];
        if (value !== undefined) {
          destination[property] = value;
        }
      }
      return destination;
    };

    var msfnz = function(eccent, sinphi, cosphi) {
      var con = eccent * sinphi;
      return cosphi / (Math.sqrt(1 - con * con));
    };

    var sign = function(x) {
      return x<0 ? -1 : 1;
    };

    var adjust_lon = function(x) {
      return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
    };

    var tsfnz = function(eccent, phi, sinphi) {
      var con = eccent * sinphi;
      var com = 0.5 * eccent;
      con = Math.pow(((1 - con) / (1 + con)), com);
      return (Math.tan(0.5 * (HALF_PI - phi)) / con);
    };

    var phi2z = function(eccent, ts) {
      var eccnth = 0.5 * eccent;
      var con, dphi;
      var phi = HALF_PI - 2 * Math.atan(ts);
      for (var i = 0; i <= 15; i++) {
        con = eccent * Math.sin(phi);
        dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }
      //console.log("phi2z has NoConvergence");
      return -9999;
    };

    function init() {
      var con = this.b / this.a;
      this.es = 1 - con * con;
      if(!('x0' in this)){
        this.x0 = 0;
      }
      if(!('y0' in this)){
        this.y0 = 0;
      }
      this.e = Math.sqrt(this.es);
      if (this.lat_ts) {
        if (this.sphere) {
          this.k0 = Math.cos(this.lat_ts);
        }
        else {
          this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
        }
      }
      else {
        if (!this.k0) {
          if (this.k) {
            this.k0 = this.k;
          }
          else {
            this.k0 = 1;
          }
        }
      }
    }

    /* Mercator forward equations--mapping lat,long to x,y
      --------------------------------------------------*/

    function forward(p) {
      var lon = p.x;
      var lat = p.y;
      // convert to radians
      if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
        return null;
      }

      var x, y;
      if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
        return null;
      }
      else {
        if (this.sphere) {
          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
          y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
        }
        else {
          var sinphi = Math.sin(lat);
          var ts = tsfnz(this.e, lat, sinphi);
          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
          y = this.y0 - this.a * this.k0 * Math.log(ts);
        }
        p.x = x;
        p.y = y;
        return p;
      }
    }

    /* Mercator inverse equations--mapping x,y to lat/long
      --------------------------------------------------*/
    function inverse(p) {

      var x = p.x - this.x0;
      var y = p.y - this.y0;
      var lon, lat;

      if (this.sphere) {
        lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
      }
      else {
        var ts = Math.exp(-y / (this.a * this.k0));
        lat = phi2z(this.e, ts);
        if (lat === -9999) {
          return null;
        }
      }
      lon = adjust_lon(this.long0 + x / (this.a * this.k0));

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
    var merc = {
      init: init,
      forward: forward,
      inverse: inverse,
      names: names$1
    };

    function init$1() {
      //no-op for longlat
    }

    function identity(pt) {
      return pt;
    }
    var names$2 = ["longlat", "identity"];
    var longlat = {
      init: init$1,
      forward: identity,
      inverse: identity,
      names: names$2
    };

    var projs = [merc, longlat];
    var names = {};
    var projStore = [];

    function add(proj, i) {
      var len = projStore.length;
      if (!proj.names) {
        console.log(i);
        return true;
      }
      projStore[len] = proj;
      proj.names.forEach(function(n) {
        names[n.toLowerCase()] = len;
      });
      return this;
    }

    function get(name) {
      if (!name) {
        return false;
      }
      var n = name.toLowerCase();
      if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
        return projStore[names[n]];
      }
    }

    function start() {
      projs.forEach(add);
    }
    var projections = {
      start: start,
      add: add,
      get: get
    };

    var exports$2 = {};
    exports$2.MERIT = {
      a: 6378137.0,
      rf: 298.257,
      ellipseName: "MERIT 1983"
    };

    exports$2.SGS85 = {
      a: 6378136.0,
      rf: 298.257,
      ellipseName: "Soviet Geodetic System 85"
    };

    exports$2.GRS80 = {
      a: 6378137.0,
      rf: 298.257222101,
      ellipseName: "GRS 1980(IUGG, 1980)"
    };

    exports$2.IAU76 = {
      a: 6378140.0,
      rf: 298.257,
      ellipseName: "IAU 1976"
    };

    exports$2.airy = {
      a: 6377563.396,
      b: 6356256.910,
      ellipseName: "Airy 1830"
    };

    exports$2.APL4 = {
      a: 6378137,
      rf: 298.25,
      ellipseName: "Appl. Physics. 1965"
    };

    exports$2.NWL9D = {
      a: 6378145.0,
      rf: 298.25,
      ellipseName: "Naval Weapons Lab., 1965"
    };

    exports$2.mod_airy = {
      a: 6377340.189,
      b: 6356034.446,
      ellipseName: "Modified Airy"
    };

    exports$2.andrae = {
      a: 6377104.43,
      rf: 300.0,
      ellipseName: "Andrae 1876 (Den., Iclnd.)"
    };

    exports$2.aust_SA = {
      a: 6378160.0,
      rf: 298.25,
      ellipseName: "Australian Natl & S. Amer. 1969"
    };

    exports$2.GRS67 = {
      a: 6378160.0,
      rf: 298.2471674270,
      ellipseName: "GRS 67(IUGG 1967)"
    };

    exports$2.bessel = {
      a: 6377397.155,
      rf: 299.1528128,
      ellipseName: "Bessel 1841"
    };

    exports$2.bess_nam = {
      a: 6377483.865,
      rf: 299.1528128,
      ellipseName: "Bessel 1841 (Namibia)"
    };

    exports$2.clrk66 = {
      a: 6378206.4,
      b: 6356583.8,
      ellipseName: "Clarke 1866"
    };

    exports$2.clrk80 = {
      a: 6378249.145,
      rf: 293.4663,
      ellipseName: "Clarke 1880 mod."
    };

    exports$2.clrk58 = {
      a: 6378293.645208759,
      rf: 294.2606763692654,
      ellipseName: "Clarke 1858"
    };

    exports$2.CPM = {
      a: 6375738.7,
      rf: 334.29,
      ellipseName: "Comm. des Poids et Mesures 1799"
    };

    exports$2.delmbr = {
      a: 6376428.0,
      rf: 311.5,
      ellipseName: "Delambre 1810 (Belgium)"
    };

    exports$2.engelis = {
      a: 6378136.05,
      rf: 298.2566,
      ellipseName: "Engelis 1985"
    };

    exports$2.evrst30 = {
      a: 6377276.345,
      rf: 300.8017,
      ellipseName: "Everest 1830"
    };

    exports$2.evrst48 = {
      a: 6377304.063,
      rf: 300.8017,
      ellipseName: "Everest 1948"
    };

    exports$2.evrst56 = {
      a: 6377301.243,
      rf: 300.8017,
      ellipseName: "Everest 1956"
    };

    exports$2.evrst69 = {
      a: 6377295.664,
      rf: 300.8017,
      ellipseName: "Everest 1969"
    };

    exports$2.evrstSS = {
      a: 6377298.556,
      rf: 300.8017,
      ellipseName: "Everest (Sabah & Sarawak)"
    };

    exports$2.fschr60 = {
      a: 6378166.0,
      rf: 298.3,
      ellipseName: "Fischer (Mercury Datum) 1960"
    };

    exports$2.fschr60m = {
      a: 6378155.0,
      rf: 298.3,
      ellipseName: "Fischer 1960"
    };

    exports$2.fschr68 = {
      a: 6378150.0,
      rf: 298.3,
      ellipseName: "Fischer 1968"
    };

    exports$2.helmert = {
      a: 6378200.0,
      rf: 298.3,
      ellipseName: "Helmert 1906"
    };

    exports$2.hough = {
      a: 6378270.0,
      rf: 297.0,
      ellipseName: "Hough"
    };

    exports$2.intl = {
      a: 6378388.0,
      rf: 297.0,
      ellipseName: "International 1909 (Hayford)"
    };

    exports$2.kaula = {
      a: 6378163.0,
      rf: 298.24,
      ellipseName: "Kaula 1961"
    };

    exports$2.lerch = {
      a: 6378139.0,
      rf: 298.257,
      ellipseName: "Lerch 1979"
    };

    exports$2.mprts = {
      a: 6397300.0,
      rf: 191.0,
      ellipseName: "Maupertius 1738"
    };

    exports$2.new_intl = {
      a: 6378157.5,
      b: 6356772.2,
      ellipseName: "New International 1967"
    };

    exports$2.plessis = {
      a: 6376523.0,
      rf: 6355863.0,
      ellipseName: "Plessis 1817 (France)"
    };

    exports$2.krass = {
      a: 6378245.0,
      rf: 298.3,
      ellipseName: "Krassovsky, 1942"
    };

    exports$2.SEasia = {
      a: 6378155.0,
      b: 6356773.3205,
      ellipseName: "Southeast Asia"
    };

    exports$2.walbeck = {
      a: 6376896.0,
      b: 6355834.8467,
      ellipseName: "Walbeck"
    };

    exports$2.WGS60 = {
      a: 6378165.0,
      rf: 298.3,
      ellipseName: "WGS 60"
    };

    exports$2.WGS66 = {
      a: 6378145.0,
      rf: 298.25,
      ellipseName: "WGS 66"
    };

    exports$2.WGS7 = {
      a: 6378135.0,
      rf: 298.26,
      ellipseName: "WGS 72"
    };

    var WGS84 = exports$2.WGS84 = {
      a: 6378137.0,
      rf: 298.257223563,
      ellipseName: "WGS 84"
    };

    exports$2.sphere = {
      a: 6370997.0,
      b: 6370997.0,
      ellipseName: "Normal Sphere (r=6370997)"
    };

    function eccentricity(a, b, rf, R_A) {
      var a2 = a * a; // used in geocentric
      var b2 = b * b; // used in geocentric
      var es = (a2 - b2) / a2; // e ^ 2
      var e = 0;
      if (R_A) {
        a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
        a2 = a * a;
        es = 0;
      } else {
        e = Math.sqrt(es); // eccentricity
      }
      var ep2 = (a2 - b2) / b2; // used in geocentric
      return {
        es: es,
        e: e,
        ep2: ep2
      };
    }
    function sphere(a, b, rf, ellps, sphere) {
      if (!a) { // do we have an ellipsoid?
        var ellipse = match(exports$2, ellps);
        if (!ellipse) {
          ellipse = WGS84;
        }
        a = ellipse.a;
        b = ellipse.b;
        rf = ellipse.rf;
      }

      if (rf && !b) {
        b = (1.0 - 1.0 / rf) * a;
      }
      if (rf === 0 || Math.abs(a - b) < EPSLN) {
        sphere = true;
        b = a;
      }
      return {
        a: a,
        b: b,
        rf: rf,
        sphere: sphere
      };
    }

    var exports$3 = {};
    exports$3.wgs84 = {
      towgs84: "0,0,0",
      ellipse: "WGS84",
      datumName: "WGS84"
    };

    exports$3.ch1903 = {
      towgs84: "674.374,15.056,405.346",
      ellipse: "bessel",
      datumName: "swiss"
    };

    exports$3.ggrs87 = {
      towgs84: "-199.87,74.79,246.62",
      ellipse: "GRS80",
      datumName: "Greek_Geodetic_Reference_System_1987"
    };

    exports$3.nad83 = {
      towgs84: "0,0,0",
      ellipse: "GRS80",
      datumName: "North_American_Datum_1983"
    };

    exports$3.nad27 = {
      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
      ellipse: "clrk66",
      datumName: "North_American_Datum_1927"
    };

    exports$3.potsdam = {
      towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
      ellipse: "bessel",
      datumName: "Potsdam Rauenberg 1950 DHDN"
    };

    exports$3.carthage = {
      towgs84: "-263.0,6.0,431.0",
      ellipse: "clark80",
      datumName: "Carthage 1934 Tunisia"
    };

    exports$3.hermannskogel = {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Hermannskogel"
    };

    exports$3.osni52 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "airy",
      datumName: "Irish National"
    };

    exports$3.ire65 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "mod_airy",
      datumName: "Ireland 1965"
    };

    exports$3.rassadiran = {
      towgs84: "-133.63,-157.5,-158.62",
      ellipse: "intl",
      datumName: "Rassadiran"
    };

    exports$3.nzgd49 = {
      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
      ellipse: "intl",
      datumName: "New Zealand Geodetic Datum 1949"
    };

    exports$3.osgb36 = {
      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
      ellipse: "airy",
      datumName: "Airy 1830"
    };

    exports$3.s_jtsk = {
      towgs84: "589,76,480",
      ellipse: 'bessel',
      datumName: 'S-JTSK (Ferro)'
    };

    exports$3.beduaram = {
      towgs84: '-106,-87,188',
      ellipse: 'clrk80',
      datumName: 'Beduaram'
    };

    exports$3.gunung_segara = {
      towgs84: '-403,684,41',
      ellipse: 'bessel',
      datumName: 'Gunung Segara Jakarta'
    };

    exports$3.rnb72 = {
      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
      ellipse: "intl",
      datumName: "Reseau National Belge 1972"
    };

    function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
      var out = {};

      if (datumCode === undefined || datumCode === 'none') {
        out.datum_type = PJD_NODATUM;
      } else {
        out.datum_type = PJD_WGS84;
      }

      if (datum_params) {
        out.datum_params = datum_params.map(parseFloat);
        if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
          out.datum_type = PJD_3PARAM;
        }
        if (out.datum_params.length > 3) {
          if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
            out.datum_type = PJD_7PARAM;
            out.datum_params[3] *= SEC_TO_RAD;
            out.datum_params[4] *= SEC_TO_RAD;
            out.datum_params[5] *= SEC_TO_RAD;
            out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
          }
        }
      }

      if (nadgrids) {
        out.datum_type = PJD_GRIDSHIFT;
        out.grids = nadgrids;
      }
      out.a = a; //datum object also uses these values
      out.b = b;
      out.es = es;
      out.ep2 = ep2;
      return out;
    }

    /**
     * Resources for details of NTv2 file formats:
     * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
     * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
     */

    var loadedNadgrids = {};

    /**
     * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
     * as an ArrayBuffer.
     */
    function nadgrid(key, data) {
      var view = new DataView(data);
      var isLittleEndian = detectLittleEndian(view);
      var header = readHeader(view, isLittleEndian);
      if (header.nSubgrids > 1) {
        console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
      }
      var subgrids = readSubgrids(view, header, isLittleEndian);
      var nadgrid = {header: header, subgrids: subgrids};
      loadedNadgrids[key] = nadgrid;
      return nadgrid;
    }

    /**
     * Given a proj4 value for nadgrids, return an array of loaded grids
     */
    function getNadgrids(nadgrids) {
      // Format details: http://proj.maptools.org/gen_parms.html
      if (nadgrids === undefined) { return null; }
      var grids = nadgrids.split(',');
      return grids.map(parseNadgridString);
    }

    function parseNadgridString(value) {
      if (value.length === 0) {
        return null;
      }
      var optional = value[0] === '@';
      if (optional) {
        value = value.slice(1);
      }
      if (value === 'null') {
        return {name: 'null', mandatory: !optional, grid: null, isNull: true};
      }
      return {
        name: value,
        mandatory: !optional,
        grid: loadedNadgrids[value] || null,
        isNull: false
      };
    }

    function secondsToRadians(seconds) {
      return (seconds / 3600) * Math.PI / 180;
    }

    function detectLittleEndian(view) {
      var nFields = view.getInt32(8, false);
      if (nFields === 11) {
        return false;
      }
      nFields = view.getInt32(8, true);
      if (nFields !== 11) {
        console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
      }
      return true;
    }

    function readHeader(view, isLittleEndian) {
      return {
        nFields: view.getInt32(8, isLittleEndian),
        nSubgridFields: view.getInt32(24, isLittleEndian),
        nSubgrids: view.getInt32(40, isLittleEndian),
        shiftType: decodeString(view, 56, 56 + 8).trim(),
        fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
        fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
        toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
        toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
      };
    }

    function decodeString(view, start, end) {
      return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
    }

    function readSubgrids(view, header, isLittleEndian) {
      var gridOffset = 176;
      var grids = [];
      for (var i = 0; i < header.nSubgrids; i++) {
        var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
        var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
        var lngColumnCount = Math.round(
          1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
        var latColumnCount = Math.round(
          1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
        // Proj4 operates on radians whereas the coordinates are in seconds in the grid
        grids.push({
          ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
          del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
          lim: [lngColumnCount, latColumnCount],
          count: subHeader.gridNodeCount,
          cvs: mapNodes(nodes)
        });
      }
      return grids;
    }

    function mapNodes(nodes) {
      return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
    }

    function readGridHeader(view, offset, isLittleEndian) {
      return {
        name: decodeString(view, offset + 8, offset + 16).trim(),
        parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
        lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
        upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
        lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
        upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
        latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
        longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
        gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
      };
    }

    function readGridNodes(view, offset, gridHeader, isLittleEndian) {
      var nodesOffset = offset + 176;
      var gridRecordLength = 16;
      var gridShiftRecords = [];
      for (var i = 0; i < gridHeader.gridNodeCount; i++) {
        var record = {
          latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
          longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
          latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
          longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
        };
        gridShiftRecords.push(record);
      }
      return gridShiftRecords;
    }

    function Projection(srsCode,callback) {
      if (!(this instanceof Projection)) {
        return new Projection(srsCode);
      }
      callback = callback || function(error){
        if(error){
          throw error;
        }
      };
      var json = parse(srsCode);
      if(typeof json !== 'object'){
        callback(srsCode);
        return;
      }
      var ourProj = Projection.projections.get(json.projName);
      if(!ourProj){
        callback(srsCode);
        return;
      }
      if (json.datumCode && json.datumCode !== 'none') {
        var datumDef = match(exports$3, json.datumCode);
        if (datumDef) {
          json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
          json.ellps = datumDef.ellipse;
          json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
        }
      }
      json.k0 = json.k0 || 1.0;
      json.axis = json.axis || 'enu';
      json.ellps = json.ellps || 'wgs84';
      json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

      var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
      var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
      var nadgrids = getNadgrids(json.nadgrids);
      var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
        nadgrids);

      extend(this, json); // transfer everything over from the projection because we don't know what we'll need
      extend(this, ourProj); // transfer all the methods from the projection

      // copy the 4 things over we calulated in deriveConstants.sphere
      this.a = sphere_.a;
      this.b = sphere_.b;
      this.rf = sphere_.rf;
      this.sphere = sphere_.sphere;

      // copy the 3 things we calculated in deriveConstants.eccentricity
      this.es = ecc.es;
      this.e = ecc.e;
      this.ep2 = ecc.ep2;

      // add in the datum object
      this.datum = datumObj;

      // init the projection
      this.init();

      // legecy callback from back in the day when it went to spatialreference.org
      callback(null, this);

    }
    Projection.projections = projections;
    Projection.projections.start();

    'use strict';
    function compareDatums(source, dest) {
      if (source.datum_type !== dest.datum_type) {
        return false; // false, datums are not equal
      } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
        // the tolerance for es is to ensure that GRS80 and WGS84
        // are considered identical
        return false;
      } else if (source.datum_type === PJD_3PARAM) {
        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
      } else if (source.datum_type === PJD_7PARAM) {
        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
      } else {
        return true; // datums are equal
      }
    } // cs_compare_datums()

    /*
     * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
     * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
     * according to the current ellipsoid parameters.
     *
     *    Latitude  : Geodetic latitude in radians                     (input)
     *    Longitude : Geodetic longitude in radians                    (input)
     *    Height    : Geodetic height, in meters                       (input)
     *    X         : Calculated Geocentric X coordinate, in meters    (output)
     *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
     *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
     *
     */
    function geodeticToGeocentric(p, es, a) {
      var Longitude = p.x;
      var Latitude = p.y;
      var Height = p.z ? p.z : 0; //Z value not always supplied

      var Rn; /*  Earth radius at location  */
      var Sin_Lat; /*  Math.sin(Latitude)  */
      var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
      var Cos_Lat; /*  Math.cos(Latitude)  */

      /*
       ** Don't blow up if Latitude is just a little out of the value
       ** range as it may just be a rounding issue.  Also removed longitude
       ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
       */
      if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
        Latitude = -HALF_PI;
      } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
        Latitude = HALF_PI;
      } else if (Latitude < -HALF_PI) {
        /* Latitude out of range */
        //..reportError('geocent:lat out of range:' + Latitude);
        return { x: -Infinity, y: -Infinity, z: p.z };
      } else if (Latitude > HALF_PI) {
        /* Latitude out of range */
        return { x: Infinity, y: Infinity, z: p.z };
      }

      if (Longitude > Math.PI) {
        Longitude -= (2 * Math.PI);
      }
      Sin_Lat = Math.sin(Latitude);
      Cos_Lat = Math.cos(Latitude);
      Sin2_Lat = Sin_Lat * Sin_Lat;
      Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
      return {
        x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
        y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
        z: ((Rn * (1 - es)) + Height) * Sin_Lat
      };
    } // cs_geodetic_to_geocentric()

    function geocentricToGeodetic(p, es, a, b) {
      /* local defintions and variables */
      /* end-criterium of loop, accuracy of sin(Latitude) */
      var genau = 1e-12;
      var genau2 = (genau * genau);
      var maxiter = 30;

      var P; /* distance between semi-minor axis and location */
      var RR; /* distance between center and location */
      var CT; /* sin of geocentric latitude */
      var ST; /* cos of geocentric latitude */
      var RX;
      var RK;
      var RN; /* Earth radius at location */
      var CPHI0; /* cos of start or old geodetic latitude in iterations */
      var SPHI0; /* sin of start or old geodetic latitude in iterations */
      var CPHI; /* cos of searched geodetic latitude */
      var SPHI; /* sin of searched geodetic latitude */
      var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
      var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

      var X = p.x;
      var Y = p.y;
      var Z = p.z ? p.z : 0.0; //Z value not always supplied
      var Longitude;
      var Latitude;
      var Height;

      P = Math.sqrt(X * X + Y * Y);
      RR = Math.sqrt(X * X + Y * Y + Z * Z);

      /*      special cases for latitude and longitude */
      if (P / a < genau) {

        /*  special case, if P=0. (X=0., Y=0.) */
        Longitude = 0.0;

        /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
         *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
        if (RR / a < genau) {
          Latitude = HALF_PI;
          Height = -b;
          return {
            x: p.x,
            y: p.y,
            z: p.z
          };
        }
      } else {
        /*  ellipsoidal (geodetic) longitude
         *  interval: -PI < Longitude <= +PI */
        Longitude = Math.atan2(Y, X);
      }

      /* --------------------------------------------------------------
       * Following iterative algorithm was developped by
       * "Institut for Erdmessung", University of Hannover, July 1988.
       * Internet: www.ife.uni-hannover.de
       * Iterative computation of CPHI,SPHI and Height.
       * Iteration of CPHI and SPHI to 10**-12 radian resp.
       * 2*10**-7 arcsec.
       * --------------------------------------------------------------
       */
      CT = Z / RR;
      ST = P / RR;
      RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
      CPHI0 = ST * (1.0 - es) * RX;
      SPHI0 = CT * RX;
      iter = 0;

      /* loop to find sin(Latitude) resp. Latitude
       * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
      do {
        iter++;
        RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

        /*  ellipsoidal (geodetic) height */
        Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

        RK = es * RN / (RN + Height);
        RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
        CPHI = ST * (1.0 - RK) * RX;
        SPHI = CT * RX;
        SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
        CPHI0 = CPHI;
        SPHI0 = SPHI;
      }
      while (SDPHI * SDPHI > genau2 && iter < maxiter);

      /*      ellipsoidal (geodetic) latitude */
      Latitude = Math.atan(SPHI / Math.abs(CPHI));
      return {
        x: Longitude,
        y: Latitude,
        z: Height
      };
    } // cs_geocentric_to_geodetic()

    /****************************************************************/
    // pj_geocentic_to_wgs84( p )
    //  p = point to transform in geocentric coordinates (x,y,z)


    /** point object, nothing fancy, just allows values to be
        passed back and forth by reference rather than by value.
        Other point classes may be used as long as they have
        x and y properties, which will get modified in the transform method.
    */
    function geocentricToWgs84(p, datum_type, datum_params) {

      if (datum_type === PJD_3PARAM) {
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: p.x + datum_params[0],
          y: p.y + datum_params[1],
          z: p.z + datum_params[2],
        };
      } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
          y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
          z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
        };
      }
    } // cs_geocentric_to_wgs84

    /****************************************************************/
    // pj_geocentic_from_wgs84()
    //  coordinate system definition,
    //  point to transform in geocentric coordinates (x,y,z)
    function geocentricFromWgs84(p, datum_type, datum_params) {

      if (datum_type === PJD_3PARAM) {
        //if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: p.x - datum_params[0],
          y: p.y - datum_params[1],
          z: p.z - datum_params[2],
        };

      } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        var x_tmp = (p.x - Dx_BF) / M_BF;
        var y_tmp = (p.y - Dy_BF) / M_BF;
        var z_tmp = (p.z - Dz_BF) / M_BF;
        //if( x[io] === HUGE_VAL )
        //    continue;

        return {
          x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
          y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
          z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
        };
      } //cs_geocentric_from_wgs84()
    }

    function checkParams(type) {
      return (type === PJD_3PARAM || type === PJD_7PARAM);
    }

    var datum_transform = function(source, dest, point) {
      // Short cut if the datums are identical.
      if (compareDatums(source, dest)) {
        return point; // in this case, zero is sucess,
        // whereas cs_compare_datums returns 1 to indicate TRUE
        // confusing, should fix this
      }

      // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
      if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
        return point;
      }

      // If this datum requires grid shifts, then apply it to geodetic coordinates.
      var source_a = source.a;
      var source_es = source.es;
      if (source.datum_type === PJD_GRIDSHIFT) {
        var gridShiftCode = applyGridShift(source, false, point);
        if (gridShiftCode !== 0) {
          return undefined;
        }
        source_a = SRS_WGS84_SEMIMAJOR;
        source_es = SRS_WGS84_ESQUARED;
      }

      var dest_a = dest.a;
      var dest_b = dest.b;
      var dest_es = dest.es;
      if (dest.datum_type === PJD_GRIDSHIFT) {
        dest_a = SRS_WGS84_SEMIMAJOR;
        dest_b = SRS_WGS84_SEMIMINOR;
        dest_es = SRS_WGS84_ESQUARED;
      }

      // Do we need to go through geocentric coordinates?
      if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
        return point;
      }

      // Convert to geocentric coordinates.
      point = geodeticToGeocentric(point, source_es, source_a);
      // Convert between datums
      if (checkParams(source.datum_type)) {
        point = geocentricToWgs84(point, source.datum_type, source.datum_params);
      }
      if (checkParams(dest.datum_type)) {
        point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
      }
      point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

      if (dest.datum_type === PJD_GRIDSHIFT) {
        var destGridShiftResult = applyGridShift(dest, true, point);
        if (destGridShiftResult !== 0) {
          return undefined;
        }
      }

      return point;
    };

    function applyGridShift(source, inverse, point) {
      if (source.grids === null || source.grids.length === 0) {
        console.log('Grid shift grids not found');
        return -1;
      }
      var input = {x: -point.x, y: point.y};
      var output = {x: Number.NaN, y: Number.NaN};
      var attemptedGrids = [];
      for (var i = 0; i < source.grids.length; i++) {
        var grid = source.grids[i];
        attemptedGrids.push(grid.name);
        if (grid.isNull) {
          output = input;
          break;
        }
        if (grid.grid === null) {
          if (grid.mandatory) {
            console.log("Unable to find mandatory grid '" + grid.name + "'");
            return -1;
          }
          continue;
        }
        var subgrid = grid.grid.subgrids[0];
        // skip tables that don't match our point at all
        var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
        var minX = subgrid.ll[0] - epsilon;
        var minY = subgrid.ll[1] - epsilon;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
        if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
          continue;
        }
        output = applySubgridShift(input, inverse, subgrid);
        if (!isNaN(output.x)) {
          break;
        }
      }
      if (isNaN(output.x)) {
        console.log("Failed to find a grid shift table for location '"+
          -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
        return -1;
      }
      point.x = -output.x;
      point.y = output.y;
      return 0;
    }

    function applySubgridShift(pin, inverse, ct) {
      var val = {x: Number.NaN, y: Number.NaN};
      if (isNaN(pin.x)) { return val; }
      var tb = {x: pin.x, y: pin.y};
      tb.x -= ct.ll[0];
      tb.y -= ct.ll[1];
      tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
      var t = nadInterpolate(tb, ct);
      if (inverse) {
        if (isNaN(t.x)) {
          return val;
        }
        t.x = tb.x - t.x;
        t.y = tb.y - t.y;
        var i = 9, tol = 1e-12;
        var dif, del;
        do {
          del = nadInterpolate(t, ct);
          if (isNaN(del.x)) {
            console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
            break;
          }
          dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
          t.x += dif.x;
          t.y += dif.y;
        } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
        if (i < 0) {
          console.log("Inverse grid shift iterator failed to converge.");
          return val;
        }
        val.x = adjust_lon(t.x + ct.ll[0]);
        val.y = t.y + ct.ll[1];
      } else {
        if (!isNaN(t.x)) {
          val.x = pin.x + t.x;
          val.y = pin.y + t.y;
        }
      }
      return val;
    }

    function nadInterpolate(pin, ct) {
      var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
      var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
      var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
      var val= {x: Number.NaN, y: Number.NaN};
      var inx;
      if (indx.x < 0 || indx.x >= ct.lim[0]) {
        return val;
      }
      if (indx.y < 0 || indx.y >= ct.lim[1]) {
        return val;
      }
      inx = (indx.y * ct.lim[0]) + indx.x;
      var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx++;
      var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx += ct.lim[0];
      var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx--;
      var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
        m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
      val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
      val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
      return val;
    }

    var adjust_axis = function(crs, denorm, point) {
      var xin = point.x,
        yin = point.y,
        zin = point.z || 0.0;
      var v, t, i;
      var out = {};
      for (i = 0; i < 3; i++) {
        if (denorm && i === 2 && point.z === undefined) {
          continue;
        }
        if (i === 0) {
          v = xin;
          if ("ew".indexOf(crs.axis[i]) !== -1) {
            t = 'x';
          } else {
            t = 'y';
          }

        }
        else if (i === 1) {
          v = yin;
          if ("ns".indexOf(crs.axis[i]) !== -1) {
            t = 'y';
          } else {
            t = 'x';
          }
        }
        else {
          v = zin;
          t = 'z';
        }
        switch (crs.axis[i]) {
        case 'e':
          out[t] = v;
          break;
        case 'w':
          out[t] = -v;
          break;
        case 'n':
          out[t] = v;
          break;
        case 's':
          out[t] = -v;
          break;
        case 'u':
          if (point[t] !== undefined) {
            out.z = v;
          }
          break;
        case 'd':
          if (point[t] !== undefined) {
            out.z = -v;
          }
          break;
        default:
          //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
          return null;
        }
      }
      return out;
    };

    var toPoint = function (array){
      var out = {
        x: array[0],
        y: array[1]
      };
      if (array.length>2) {
        out.z = array[2];
      }
      if (array.length>3) {
        out.m = array[3];
      }
      return out;
    };

    var checkSanity = function (point) {
      checkCoord(point.x);
      checkCoord(point.y);
    };
    function checkCoord(num) {
      if (typeof Number.isFinite === 'function') {
        if (Number.isFinite(num)) {
          return;
        }
        throw new TypeError('coordinates must be finite numbers');
      }
      if (typeof num !== 'number' || num !== num || !isFinite(num)) {
        throw new TypeError('coordinates must be finite numbers');
      }
    }

    function checkNotWGS(source, dest) {
      return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
    }

    function transform(source, dest, point, enforceAxis) {
      var wgs84;
      if (Array.isArray(point)) {
        point = toPoint(point);
      }
      checkSanity(point);
      // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
      if (source.datum && dest.datum && checkNotWGS(source, dest)) {
        wgs84 = new Projection('WGS84');
        point = transform(source, wgs84, point, enforceAxis);
        source = wgs84;
      }
      // DGR, 2010/11/12
      if (enforceAxis && source.axis !== 'enu') {
        point = adjust_axis(source, false, point);
      }
      // Transform source points to long/lat, if they aren't already.
      if (source.projName === 'longlat') {
        point = {
          x: point.x * D2R,
          y: point.y * D2R,
          z: point.z || 0
        };
      } else {
        if (source.to_meter) {
          point = {
            x: point.x * source.to_meter,
            y: point.y * source.to_meter,
            z: point.z || 0
          };
        }
        point = source.inverse(point); // Convert Cartesian to longlat
        if (!point) {
          return;
        }
      }
      // Adjust for the prime meridian if necessary
      if (source.from_greenwich) {
        point.x += source.from_greenwich;
      }

      // Convert datums if needed, and if possible.
      point = datum_transform(source.datum, dest.datum, point);
      if (!point) {
        return;
      }

      // Adjust for the prime meridian if necessary
      if (dest.from_greenwich) {
        point = {
          x: point.x - dest.from_greenwich,
          y: point.y,
          z: point.z || 0
        };
      }

      if (dest.projName === 'longlat') {
        // convert radians to decimal degrees
        point = {
          x: point.x * R2D,
          y: point.y * R2D,
          z: point.z || 0
        };
      } else { // else project
        point = dest.forward(point);
        if (dest.to_meter) {
          point = {
            x: point.x / dest.to_meter,
            y: point.y / dest.to_meter,
            z: point.z || 0
          };
        }
      }

      // DGR, 2010/11/12
      if (enforceAxis && dest.axis !== 'enu') {
        return adjust_axis(dest, true, point);
      }

      return point;
    }

    var wgs84 = Projection('WGS84');

    function transformer(from, to, coords, enforceAxis) {
      var transformedArray, out, keys;
      if (Array.isArray(coords)) {
        transformedArray = transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
        if (coords.length > 2) {
          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
            if (typeof transformedArray.z === 'number') {
              return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
            } else {
              return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
            }
          } else {
            return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
          }
        } else {
          return [transformedArray.x, transformedArray.y];
        }
      } else {
        out = transform(from, to, coords, enforceAxis);
        keys = Object.keys(coords);
        if (keys.length === 2) {
          return out;
        }
        keys.forEach(function (key) {
          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
            if (key === 'x' || key === 'y' || key === 'z') {
              return;
            }
          } else {
            if (key === 'x' || key === 'y') {
              return;
            }
          }
          out[key] = coords[key];
        });
        return out;
      }
    }

    function checkProj(item) {
      if (item instanceof Projection) {
        return item;
      }
      if (item.oProj) {
        return item.oProj;
      }
      return Projection(item);
    }

    function proj4$1(fromProj, toProj, coord) {
      fromProj = checkProj(fromProj);
      var single = false;
      var obj;
      if (typeof toProj === 'undefined') {
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
      } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
        coord = toProj;
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
      }
      toProj = checkProj(toProj);
      if (coord) {
        return transformer(fromProj, toProj, coord);
      } else {
        obj = {
          forward: function (coords, enforceAxis) {
            return transformer(fromProj, toProj, coords, enforceAxis);
          },
          inverse: function (coords, enforceAxis) {
            return transformer(toProj, fromProj, coords, enforceAxis);
          }
        };
        if (single) {
          obj.oProj = toProj;
        }
        return obj;
      }
    }

    /**
     * UTM zones are grouped, and assigned to one of a group of 6
     * sets.
     *
     * {int} @private
     */
    var NUM_100K_SETS = 6;

    /**
     * The column letters (for easting) of the lower left value, per
     * set.
     *
     * {string} @private
     */
    var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

    /**
     * The row letters (for northing) of the lower left value, per
     * set.
     *
     * {string} @private
     */
    var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

    var A = 65; // A
    var I = 73; // I
    var O = 79; // O
    var V = 86; // V
    var Z = 90; // Z
    var mgrs = {
      forward: forward$1,
      inverse: inverse$1,
      toPoint: toPoint$1
    };
    /**
     * Conversion of lat/lon to MGRS.
     *
     * @param {object} ll Object literal with lat and lon properties on a
     *     WGS84 ellipsoid.
     * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
     *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
     * @return {string} the MGRS string for the given location and accuracy.
     */
    function forward$1(ll, accuracy) {
      accuracy = accuracy || 5; // default accuracy 1m
      return encode(LLtoUTM({
        lat: ll[1],
        lon: ll[0]
      }), accuracy);
    }

    /**
     * Conversion of MGRS to lat/lon.
     *
     * @param {string} mgrs MGRS string.
     * @return {array} An array with left (longitude), bottom (latitude), right
     *     (longitude) and top (latitude) values in WGS84, representing the
     *     bounding box for the provided MGRS reference.
     */
    function inverse$1(mgrs) {
      var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
      if (bbox.lat && bbox.lon) {
        return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
      }
      return [bbox.left, bbox.bottom, bbox.right, bbox.top];
    }

    function toPoint$1(mgrs) {
      var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
      if (bbox.lat && bbox.lon) {
        return [bbox.lon, bbox.lat];
      }
      return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
    }
    /**
     * Conversion from degrees to radians.
     *
     * @private
     * @param {number} deg the angle in degrees.
     * @return {number} the angle in radians.
     */
    function degToRad(deg) {
      return (deg * (Math.PI / 180.0));
    }

    /**
     * Conversion from radians to degrees.
     *
     * @private
     * @param {number} rad the angle in radians.
     * @return {number} the angle in degrees.
     */
    function radToDeg(rad) {
      return (180.0 * (rad / Math.PI));
    }

    /**
     * Converts a set of Longitude and Latitude co-ordinates to UTM
     * using the WGS84 ellipsoid.
     *
     * @private
     * @param {object} ll Object literal with lat and lon properties
     *     representing the WGS84 coordinate to be converted.
     * @return {object} Object literal containing the UTM value with easting,
     *     northing, zoneNumber and zoneLetter properties, and an optional
     *     accuracy property in digits. Returns null if the conversion failed.
     */
    function LLtoUTM(ll) {
      var Lat = ll.lat;
      var Long = ll.lon;
      var a = 6378137.0; //ellip.radius;
      var eccSquared = 0.00669438; //ellip.eccsq;
      var k0 = 0.9996;
      var LongOrigin;
      var eccPrimeSquared;
      var N, T, C, A, M;
      var LatRad = degToRad(Lat);
      var LongRad = degToRad(Long);
      var LongOriginRad;
      var ZoneNumber;
      // (int)
      ZoneNumber = Math.floor((Long + 180) / 6) + 1;

      //Make sure the longitude 180.00 is in Zone 60
      if (Long === 180) {
        ZoneNumber = 60;
      }

      // Special zone for Norway
      if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
        ZoneNumber = 32;
      }

      // Special zones for Svalbard
      if (Lat >= 72.0 && Lat < 84.0) {
        if (Long >= 0.0 && Long < 9.0) {
          ZoneNumber = 31;
        }
        else if (Long >= 9.0 && Long < 21.0) {
          ZoneNumber = 33;
        }
        else if (Long >= 21.0 && Long < 33.0) {
          ZoneNumber = 35;
        }
        else if (Long >= 33.0 && Long < 42.0) {
          ZoneNumber = 37;
        }
      }

      LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
      // in middle of
      // zone
      LongOriginRad = degToRad(LongOrigin);

      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

      N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
      T = Math.tan(LatRad) * Math.tan(LatRad);
      C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
      A = Math.cos(LatRad) * (LongRad - LongOriginRad);

      M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

      var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

      var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
      if (Lat < 0.0) {
        UTMNorthing += 10000000.0; //10000000 meter offset for
        // southern hemisphere
      }

      return {
        northing: Math.round(UTMNorthing),
        easting: Math.round(UTMEasting),
        zoneNumber: ZoneNumber,
        zoneLetter: getLetterDesignator(Lat)
      };
    }

    /**
     * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
     * class where the Zone can be specified as a single string eg."60N" which
     * is then broken down into the ZoneNumber and ZoneLetter.
     *
     * @private
     * @param {object} utm An object literal with northing, easting, zoneNumber
     *     and zoneLetter properties. If an optional accuracy property is
     *     provided (in meters), a bounding box will be returned instead of
     *     latitude and longitude.
     * @return {object} An object literal containing either lat and lon values
     *     (if no accuracy was provided), or top, right, bottom and left values
     *     for the bounding box calculated according to the provided accuracy.
     *     Returns null if the conversion failed.
     */
    function UTMtoLL(utm) {

      var UTMNorthing = utm.northing;
      var UTMEasting = utm.easting;
      var zoneLetter = utm.zoneLetter;
      var zoneNumber = utm.zoneNumber;
      // check the ZoneNummber is valid
      if (zoneNumber < 0 || zoneNumber > 60) {
        return null;
      }

      var k0 = 0.9996;
      var a = 6378137.0; //ellip.radius;
      var eccSquared = 0.00669438; //ellip.eccsq;
      var eccPrimeSquared;
      var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
      var N1, T1, C1, R1, D, M;
      var LongOrigin;
      var mu, phi1Rad;

      // remove 500,000 meter offset for longitude
      var x = UTMEasting - 500000.0;
      var y = UTMNorthing;

      // We must know somehow if we are in the Northern or Southern
      // hemisphere, this is the only time we use the letter So even
      // if the Zone letter isn't exactly correct it should indicate
      // the hemisphere correctly
      if (zoneLetter < 'N') {
        y -= 10000000.0; // remove 10,000,000 meter offset used
        // for southern hemisphere
      }

      // There are 60 zones with zone 1 being at West -180 to -174
      LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
      // in middle of
      // zone

      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

      M = y / k0;
      mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

      phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
      // double phi1 = ProjMath.radToDeg(phi1Rad);

      N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
      T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
      C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
      R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
      D = x / (N1 * k0);

      var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
      lat = radToDeg(lat);

      var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
      lon = LongOrigin + radToDeg(lon);

      var result;
      if (utm.accuracy) {
        var topRight = UTMtoLL({
          northing: utm.northing + utm.accuracy,
          easting: utm.easting + utm.accuracy,
          zoneLetter: utm.zoneLetter,
          zoneNumber: utm.zoneNumber
        });
        result = {
          top: topRight.lat,
          right: topRight.lon,
          bottom: lat,
          left: lon
        };
      }
      else {
        result = {
          lat: lat,
          lon: lon
        };
      }
      return result;
    }

    /**
     * Calculates the MGRS letter designator for the given latitude.
     *
     * @private
     * @param {number} lat The latitude in WGS84 to get the letter designator
     *     for.
     * @return {char} The letter designator.
     */
    function getLetterDesignator(lat) {
      //This is here as an error flag to show that the Latitude is
      //outside MGRS limits
      var LetterDesignator = 'Z';

      if ((84 >= lat) && (lat >= 72)) {
        LetterDesignator = 'X';
      }
      else if ((72 > lat) && (lat >= 64)) {
        LetterDesignator = 'W';
      }
      else if ((64 > lat) && (lat >= 56)) {
        LetterDesignator = 'V';
      }
      else if ((56 > lat) && (lat >= 48)) {
        LetterDesignator = 'U';
      }
      else if ((48 > lat) && (lat >= 40)) {
        LetterDesignator = 'T';
      }
      else if ((40 > lat) && (lat >= 32)) {
        LetterDesignator = 'S';
      }
      else if ((32 > lat) && (lat >= 24)) {
        LetterDesignator = 'R';
      }
      else if ((24 > lat) && (lat >= 16)) {
        LetterDesignator = 'Q';
      }
      else if ((16 > lat) && (lat >= 8)) {
        LetterDesignator = 'P';
      }
      else if ((8 > lat) && (lat >= 0)) {
        LetterDesignator = 'N';
      }
      else if ((0 > lat) && (lat >= -8)) {
        LetterDesignator = 'M';
      }
      else if ((-8 > lat) && (lat >= -16)) {
        LetterDesignator = 'L';
      }
      else if ((-16 > lat) && (lat >= -24)) {
        LetterDesignator = 'K';
      }
      else if ((-24 > lat) && (lat >= -32)) {
        LetterDesignator = 'J';
      }
      else if ((-32 > lat) && (lat >= -40)) {
        LetterDesignator = 'H';
      }
      else if ((-40 > lat) && (lat >= -48)) {
        LetterDesignator = 'G';
      }
      else if ((-48 > lat) && (lat >= -56)) {
        LetterDesignator = 'F';
      }
      else if ((-56 > lat) && (lat >= -64)) {
        LetterDesignator = 'E';
      }
      else if ((-64 > lat) && (lat >= -72)) {
        LetterDesignator = 'D';
      }
      else if ((-72 > lat) && (lat >= -80)) {
        LetterDesignator = 'C';
      }
      return LetterDesignator;
    }

    /**
     * Encodes a UTM location as MGRS string.
     *
     * @private
     * @param {object} utm An object literal with easting, northing,
     *     zoneLetter, zoneNumber
     * @param {number} accuracy Accuracy in digits (1-5).
     * @return {string} MGRS string for the given UTM location.
     */
    function encode(utm, accuracy) {
      // prepend with leading zeroes
      var seasting = "00000" + utm.easting,
        snorthing = "00000" + utm.northing;

      return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
    }

    /**
     * Get the two letter 100k designator for a given UTM easting,
     * northing and zone number value.
     *
     * @private
     * @param {number} easting
     * @param {number} northing
     * @param {number} zoneNumber
     * @return the two letter 100k designator for the given UTM location.
     */
    function get100kID(easting, northing, zoneNumber) {
      var setParm = get100kSetForZone(zoneNumber);
      var setColumn = Math.floor(easting / 100000);
      var setRow = Math.floor(northing / 100000) % 20;
      return getLetter100kID(setColumn, setRow, setParm);
    }

    /**
     * Given a UTM zone number, figure out the MGRS 100K set it is in.
     *
     * @private
     * @param {number} i An UTM zone number.
     * @return {number} the 100k set the UTM zone is in.
     */
    function get100kSetForZone(i) {
      var setParm = i % NUM_100K_SETS;
      if (setParm === 0) {
        setParm = NUM_100K_SETS;
      }

      return setParm;
    }

    /**
     * Get the two-letter MGRS 100k designator given information
     * translated from the UTM northing, easting and zone number.
     *
     * @private
     * @param {number} column the column index as it relates to the MGRS
     *        100k set spreadsheet, created from the UTM easting.
     *        Values are 1-8.
     * @param {number} row the row index as it relates to the MGRS 100k set
     *        spreadsheet, created from the UTM northing value. Values
     *        are from 0-19.
     * @param {number} parm the set block, as it relates to the MGRS 100k set
     *        spreadsheet, created from the UTM zone. Values are from
     *        1-60.
     * @return two letter MGRS 100k code.
     */
    function getLetter100kID(column, row, parm) {
      // colOrigin and rowOrigin are the letters at the origin of the set
      var index = parm - 1;
      var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
      var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

      // colInt and rowInt are the letters to build to return
      var colInt = colOrigin + column - 1;
      var rowInt = rowOrigin + row;
      var rollover = false;

      if (colInt > Z) {
        colInt = colInt - Z + A - 1;
        rollover = true;
      }

      if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
        colInt++;
      }

      if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
        colInt++;

        if (colInt === I) {
          colInt++;
        }
      }

      if (colInt > Z) {
        colInt = colInt - Z + A - 1;
      }

      if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
        rollover = true;
      }
      else {
        rollover = false;
      }

      if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
        rowInt++;
      }

      if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
        rowInt++;

        if (rowInt === I) {
          rowInt++;
        }
      }

      if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
      }

      var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
      return twoLetter;
    }

    /**
     * Decode the UTM parameters from a MGRS string.
     *
     * @private
     * @param {string} mgrsString an UPPERCASE coordinate string is expected.
     * @return {object} An object literal with easting, northing, zoneLetter,
     *     zoneNumber and accuracy (in meters) properties.
     */
    function decode(mgrsString) {

      if (mgrsString && mgrsString.length === 0) {
        throw ("MGRSPoint coverting from nothing");
      }

      var length = mgrsString.length;

      var hunK = null;
      var sb = "";
      var testChar;
      var i = 0;

      // get Zone number
      while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
        if (i >= 2) {
          throw ("MGRSPoint bad conversion from: " + mgrsString);
        }
        sb += testChar;
        i++;
      }

      var zoneNumber = parseInt(sb, 10);

      if (i === 0 || i + 3 > length) {
        // A good MGRS string has to be 4-5 digits long,
        // ##AAA/#AAA at least.
        throw ("MGRSPoint bad conversion from: " + mgrsString);
      }

      var zoneLetter = mgrsString.charAt(i++);

      // Should we check the zone letter here? Why not.
      if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
        throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
      }

      hunK = mgrsString.substring(i, i += 2);

      var set = get100kSetForZone(zoneNumber);

      var east100k = getEastingFromChar(hunK.charAt(0), set);
      var north100k = getNorthingFromChar(hunK.charAt(1), set);

      // We have a bug where the northing may be 2000000 too low.
      // How
      // do we know when to roll over?

      while (north100k < getMinNorthing(zoneLetter)) {
        north100k += 2000000;
      }

      // calculate the char index for easting/northing separator
      var remainder = length - i;

      if (remainder % 2 !== 0) {
        throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
      }

      var sep = remainder / 2;

      var sepEasting = 0.0;
      var sepNorthing = 0.0;
      var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
      if (sep > 0) {
        accuracyBonus = 100000.0 / Math.pow(10, sep);
        sepEastingString = mgrsString.substring(i, i + sep);
        sepEasting = parseFloat(sepEastingString) * accuracyBonus;
        sepNorthingString = mgrsString.substring(i + sep);
        sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
      }

      easting = sepEasting + east100k;
      northing = sepNorthing + north100k;

      return {
        easting: easting,
        northing: northing,
        zoneLetter: zoneLetter,
        zoneNumber: zoneNumber,
        accuracy: accuracyBonus
      };
    }

    /**
     * Given the first letter from a two-letter MGRS 100k zone, and given the
     * MGRS table set for the zone number, figure out the easting value that
     * should be added to the other, secondary easting value.
     *
     * @private
     * @param {char} e The first letter from a two-letter MGRS 100´k zone.
     * @param {number} set The MGRS table set for the zone number.
     * @return {number} The easting value for the given letter and set.
     */
    function getEastingFromChar(e, set) {
      // colOrigin is the letter at the origin of the set for the
      // column
      var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
      var eastingValue = 100000.0;
      var rewindMarker = false;

      while (curCol !== e.charCodeAt(0)) {
        curCol++;
        if (curCol === I) {
          curCol++;
        }
        if (curCol === O) {
          curCol++;
        }
        if (curCol > Z) {
          if (rewindMarker) {
            throw ("Bad character: " + e);
          }
          curCol = A;
          rewindMarker = true;
        }
        eastingValue += 100000.0;
      }

      return eastingValue;
    }

    /**
     * Given the second letter from a two-letter MGRS 100k zone, and given the
     * MGRS table set for the zone number, figure out the northing value that
     * should be added to the other, secondary northing value. You have to
     * remember that Northings are determined from the equator, and the vertical
     * cycle of letters mean a 2000000 additional northing meters. This happens
     * approx. every 18 degrees of latitude. This method does *NOT* count any
     * additional northings. You have to figure out how many 2000000 meters need
     * to be added for the zone letter of the MGRS coordinate.
     *
     * @private
     * @param {char} n Second letter of the MGRS 100k zone
     * @param {number} set The MGRS table set number, which is dependent on the
     *     UTM zone number.
     * @return {number} The northing value for the given letter and set.
     */
    function getNorthingFromChar(n, set) {

      if (n > 'V') {
        throw ("MGRSPoint given invalid Northing " + n);
      }

      // rowOrigin is the letter at the origin of the set for the
      // column
      var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
      var northingValue = 0.0;
      var rewindMarker = false;

      while (curRow !== n.charCodeAt(0)) {
        curRow++;
        if (curRow === I) {
          curRow++;
        }
        if (curRow === O) {
          curRow++;
        }
        // fixing a bug making whole application hang in this loop
        // when 'n' is a wrong character
        if (curRow > V) {
          if (rewindMarker) { // making sure that this loop ends
            throw ("Bad character: " + n);
          }
          curRow = A;
          rewindMarker = true;
        }
        northingValue += 100000.0;
      }

      return northingValue;
    }

    /**
     * The function getMinNorthing returns the minimum northing value of a MGRS
     * zone.
     *
     * Ported from Geotrans' c Lattitude_Band_Value structure table.
     *
     * @private
     * @param {char} zoneLetter The MGRS zone to get the min northing for.
     * @return {number}
     */
    function getMinNorthing(zoneLetter) {
      var northing;
      switch (zoneLetter) {
      case 'C':
        northing = 1100000.0;
        break;
      case 'D':
        northing = 2000000.0;
        break;
      case 'E':
        northing = 2800000.0;
        break;
      case 'F':
        northing = 3700000.0;
        break;
      case 'G':
        northing = 4600000.0;
        break;
      case 'H':
        northing = 5500000.0;
        break;
      case 'J':
        northing = 6400000.0;
        break;
      case 'K':
        northing = 7300000.0;
        break;
      case 'L':
        northing = 8200000.0;
        break;
      case 'M':
        northing = 9100000.0;
        break;
      case 'N':
        northing = 0.0;
        break;
      case 'P':
        northing = 800000.0;
        break;
      case 'Q':
        northing = 1700000.0;
        break;
      case 'R':
        northing = 2600000.0;
        break;
      case 'S':
        northing = 3500000.0;
        break;
      case 'T':
        northing = 4400000.0;
        break;
      case 'U':
        northing = 5300000.0;
        break;
      case 'V':
        northing = 6200000.0;
        break;
      case 'W':
        northing = 7000000.0;
        break;
      case 'X':
        northing = 7900000.0;
        break;
      default:
        northing = -1.0;
      }
      if (northing >= 0.0) {
        return northing;
      }
      else {
        throw ("Invalid zone letter: " + zoneLetter);
      }

    }

    function Point(x, y, z) {
      if (!(this instanceof Point)) {
        return new Point(x, y, z);
      }
      if (Array.isArray(x)) {
        this.x = x[0];
        this.y = x[1];
        this.z = x[2] || 0.0;
      } else if(typeof x === 'object') {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z || 0.0;
      } else if (typeof x === 'string' && typeof y === 'undefined') {
        var coords = x.split(',');
        this.x = parseFloat(coords[0], 10);
        this.y = parseFloat(coords[1], 10);
        this.z = parseFloat(coords[2], 10) || 0.0;
      } else {
        this.x = x;
        this.y = y;
        this.z = z || 0.0;
      }
      console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
    }

    Point.fromMGRS = function(mgrsStr) {
      return new Point(toPoint$1(mgrsStr));
    };
    Point.prototype.toMGRS = function(accuracy) {
      return forward$1([this.x, this.y], accuracy);
    };

    var C00 = 1;
    var C02 = 0.25;
    var C04 = 0.046875;
    var C06 = 0.01953125;
    var C08 = 0.01068115234375;
    var C22 = 0.75;
    var C44 = 0.46875;
    var C46 = 0.01302083333333333333;
    var C48 = 0.00712076822916666666;
    var C66 = 0.36458333333333333333;
    var C68 = 0.00569661458333333333;
    var C88 = 0.3076171875;

    var pj_enfn = function(es) {
      var en = [];
      en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
      en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
      var t = es * es;
      en[2] = t * (C44 - es * (C46 + es * C48));
      t *= es;
      en[3] = t * (C66 - es * C68);
      en[4] = t * es * C88;
      return en;
    };

    var pj_mlfn = function(phi, sphi, cphi, en) {
      cphi *= sphi;
      sphi *= sphi;
      return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
    };

    var MAX_ITER = 20;

    var pj_inv_mlfn = function(arg, es, en) {
      var k = 1 / (1 - es);
      var phi = arg;
      for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
        var s = Math.sin(phi);
        var t = 1 - es * s * s;
        //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
        //phi -= t * (t * Math.sqrt(t)) * k;
        t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
        phi -= t;
        if (Math.abs(t) < EPSLN) {
          return phi;
        }
      }
      //..reportError("cass:pj_inv_mlfn: Convergence error");
      return phi;
    };

    // Heavily based on this tmerc projection implementation
    // https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js

    function init$2() {
      this.x0 = this.x0 !== undefined ? this.x0 : 0;
      this.y0 = this.y0 !== undefined ? this.y0 : 0;
      this.long0 = this.long0 !== undefined ? this.long0 : 0;
      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

      if (this.es) {
        this.en = pj_enfn(this.es);
        this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
      }
    }

    /**
        Transverse Mercator Forward  - long/lat to x/y
        long/lat in radians
      */
    function forward$2(p) {
      var lon = p.x;
      var lat = p.y;

      var delta_lon = adjust_lon(lon - this.long0);
      var con;
      var x, y;
      var sin_phi = Math.sin(lat);
      var cos_phi = Math.cos(lat);

      if (!this.es) {
        var b = cos_phi * Math.sin(delta_lon);

        if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
          return (93);
        }
        else {
          x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
          y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
          b = Math.abs(y);

          if (b >= 1) {
            if ((b - 1) > EPSLN) {
              return (93);
            }
            else {
              y = 0;
            }
          }
          else {
            y = Math.acos(y);
          }

          if (lat < 0) {
            y = -y;
          }

          y = this.a * this.k0 * (y - this.lat0) + this.y0;
        }
      }
      else {
        var al = cos_phi * delta_lon;
        var als = Math.pow(al, 2);
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
        var t = Math.pow(tq, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        al = al / Math.sqrt(con);
        var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

        x = this.a * (this.k0 * al * (1 +
          als / 6 * (1 - t + c +
          als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
          als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
          this.x0;

        y = this.a * (this.k0 * (ml - this.ml0 +
          sin_phi * delta_lon * al / 2 * (1 +
          als / 12 * (5 - t + 9 * c + 4 * cs +
          als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
          als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
          this.y0;
      }

      p.x = x;
      p.y = y;

      return p;
    }

    /**
        Transverse Mercator Inverse  -  x/y to long/lat
      */
    function inverse$2(p) {
      var con, phi;
      var lat, lon;
      var x = (p.x - this.x0) * (1 / this.a);
      var y = (p.y - this.y0) * (1 / this.a);

      if (!this.es) {
        var f = Math.exp(x / this.k0);
        var g = 0.5 * (f - 1 / f);
        var temp = this.lat0 + y / this.k0;
        var h = Math.cos(temp);
        con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
        lat = Math.asin(con);

        if (y < 0) {
          lat = -lat;
        }

        if ((g === 0) && (h === 0)) {
          lon = 0;
        }
        else {
          lon = adjust_lon(Math.atan2(g, h) + this.long0);
        }
      }
      else { // ellipsoidal form
        con = this.ml0 + y / this.k0;
        phi = pj_inv_mlfn(con, this.es, this.en);

        if (Math.abs(phi) < HALF_PI) {
          var sin_phi = Math.sin(phi);
          var cos_phi = Math.cos(phi);
          var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
          var c = this.ep2 * Math.pow(cos_phi, 2);
          var cs = Math.pow(c, 2);
          var t = Math.pow(tan_phi, 2);
          var ts = Math.pow(t, 2);
          con = 1 - this.es * Math.pow(sin_phi, 2);
          var d = x * Math.sqrt(con) / this.k0;
          var ds = Math.pow(d, 2);
          con = con * tan_phi;

          lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
            ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
            ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
            ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

          lon = adjust_lon(this.long0 + (d * (1 -
            ds / 6 * (1 + 2 * t + c -
            ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
            ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
        }
        else {
          lat = HALF_PI * sign(y);
          lon = 0;
        }
      }

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$3 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
    var tmerc = {
      init: init$2,
      forward: forward$2,
      inverse: inverse$2,
      names: names$3
    };

    var sinh = function(x) {
      var r = Math.exp(x);
      r = (r - 1 / r) / 2;
      return r;
    };

    var hypot = function(x, y) {
      x = Math.abs(x);
      y = Math.abs(y);
      var a = Math.max(x, y);
      var b = Math.min(x, y) / (a ? a : 1);

      return a * Math.sqrt(1 + Math.pow(b, 2));
    };

    var log1py = function(x) {
      var y = 1 + x;
      var z = y - 1;

      return z === 0 ? x : x * Math.log(y) / z;
    };

    var asinhy = function(x) {
      var y = Math.abs(x);
      y = log1py(y * (1 + y / (hypot(1, y) + 1)));

      return x < 0 ? -y : y;
    };

    var gatg = function(pp, B) {
      var cos_2B = 2 * Math.cos(2 * B);
      var i = pp.length - 1;
      var h1 = pp[i];
      var h2 = 0;
      var h;

      while (--i >= 0) {
        h = -h2 + cos_2B * h1 + pp[i];
        h2 = h1;
        h1 = h;
      }

      return (B + h * Math.sin(2 * B));
    };

    var clens = function(pp, arg_r) {
      var r = 2 * Math.cos(arg_r);
      var i = pp.length - 1;
      var hr1 = pp[i];
      var hr2 = 0;
      var hr;

      while (--i >= 0) {
        hr = -hr2 + r * hr1 + pp[i];
        hr2 = hr1;
        hr1 = hr;
      }

      return Math.sin(arg_r) * hr;
    };

    var cosh = function(x) {
      var r = Math.exp(x);
      r = (r + 1 / r) / 2;
      return r;
    };

    var clens_cmplx = function(pp, arg_r, arg_i) {
      var sin_arg_r = Math.sin(arg_r);
      var cos_arg_r = Math.cos(arg_r);
      var sinh_arg_i = sinh(arg_i);
      var cosh_arg_i = cosh(arg_i);
      var r = 2 * cos_arg_r * cosh_arg_i;
      var i = -2 * sin_arg_r * sinh_arg_i;
      var j = pp.length - 1;
      var hr = pp[j];
      var hi1 = 0;
      var hr1 = 0;
      var hi = 0;
      var hr2;
      var hi2;

      while (--j >= 0) {
        hr2 = hr1;
        hi2 = hi1;
        hr1 = hr;
        hi1 = hi;
        hr = -hr2 + r * hr1 - i * hi1 + pp[j];
        hi = -hi2 + i * hr1 + r * hi1;
      }

      r = sin_arg_r * cosh_arg_i;
      i = cos_arg_r * sinh_arg_i;

      return [r * hr - i * hi, r * hi + i * hr];
    };

    // Heavily based on this etmerc projection implementation
    // https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js

    function init$3() {
      if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
        throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
      }
      if (this.approx) {
        // When '+approx' is set, use tmerc instead
        tmerc.init.apply(this);
        this.forward = tmerc.forward;
        this.inverse = tmerc.inverse;
      }

      this.x0 = this.x0 !== undefined ? this.x0 : 0;
      this.y0 = this.y0 !== undefined ? this.y0 : 0;
      this.long0 = this.long0 !== undefined ? this.long0 : 0;
      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

      this.cgb = [];
      this.cbg = [];
      this.utg = [];
      this.gtu = [];

      var f = this.es / (1 + Math.sqrt(1 - this.es));
      var n = f / (2 - f);
      var np = n;

      this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
      this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

      np = np * n;
      this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
      this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

      np = np * n;
      this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
      this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

      np = np * n;
      this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
      this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

      np = np * n;
      this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
      this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

      np = np * n;
      this.cgb[5] = np * (601676 / 22275);
      this.cbg[5] = np * (444337 / 155925);

      np = Math.pow(n, 2);
      this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

      this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
      this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

      this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
      this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

      np = np * n;
      this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
      this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

      np = np * n;
      this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
      this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

      np = np * n;
      this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
      this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

      np = np * n;
      this.utg[5] = np * (-20648693 / 638668800);
      this.gtu[5] = np * (212378941 / 319334400);

      var Z = gatg(this.cbg, this.lat0);
      this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
    }

    function forward$3(p) {
      var Ce = adjust_lon(p.x - this.long0);
      var Cn = p.y;

      Cn = gatg(this.cbg, Cn);
      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);

      Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
      Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
      Ce = asinhy(Math.tan(Ce));

      var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];

      var x;
      var y;

      if (Math.abs(Ce) <= 2.623395162778) {
        x = this.a * (this.Qn * Ce) + this.x0;
        y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
      }
      else {
        x = Infinity;
        y = Infinity;
      }

      p.x = x;
      p.y = y;

      return p;
    }

    function inverse$3(p) {
      var Ce = (p.x - this.x0) * (1 / this.a);
      var Cn = (p.y - this.y0) * (1 / this.a);

      Cn = (Cn - this.Zb) / this.Qn;
      Ce = Ce / this.Qn;

      var lon;
      var lat;

      if (Math.abs(Ce) <= 2.623395162778) {
        var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

        Cn = Cn + tmp[0];
        Ce = Ce + tmp[1];
        Ce = Math.atan(sinh(Ce));

        var sin_Cn = Math.sin(Cn);
        var cos_Cn = Math.cos(Cn);
        var sin_Ce = Math.sin(Ce);
        var cos_Ce = Math.cos(Ce);

        Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
        Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

        lon = adjust_lon(Ce + this.long0);
        lat = gatg(this.cgb, Cn);
      }
      else {
        lon = Infinity;
        lat = Infinity;
      }

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
    var etmerc = {
      init: init$3,
      forward: forward$3,
      inverse: inverse$3,
      names: names$4
    };

    var adjust_zone = function(zone, lon) {
      if (zone === undefined) {
        zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

        if (zone < 0) {
          return 0;
        } else if (zone > 60) {
          return 60;
        }
      }
      return zone;
    };

    var dependsOn = 'etmerc';
    function init$4() {
      var zone = adjust_zone(this.zone, this.long0);
      if (zone === undefined) {
        throw new Error('unknown utm zone');
      }
      this.lat0 = 0;
      this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
      this.x0 = 500000;
      this.y0 = this.utmSouth ? 10000000 : 0;
      this.k0 = 0.9996;

      etmerc.init.apply(this);
      this.forward = etmerc.forward;
      this.inverse = etmerc.inverse;
    }

    var names$5 = ["Universal Transverse Mercator System", "utm"];
    var utm = {
      init: init$4,
      names: names$5,
      dependsOn: dependsOn
    };

    var srat = function(esinp, exp) {
      return (Math.pow((1 - esinp) / (1 + esinp), exp));
    };

    var MAX_ITER$1 = 20;
    function init$6() {
      var sphi = Math.sin(this.lat0);
      var cphi = Math.cos(this.lat0);
      cphi *= cphi;
      this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
      this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
      this.phic0 = Math.asin(sphi / this.C);
      this.ratexp = 0.5 * this.C * this.e;
      this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
    }

    function forward$5(p) {
      var lon = p.x;
      var lat = p.y;

      p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
      p.x = this.C * lon;
      return p;
    }

    function inverse$5(p) {
      var DEL_TOL = 1e-14;
      var lon = p.x / this.C;
      var lat = p.y;
      var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
      for (var i = MAX_ITER$1; i > 0; --i) {
        lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
        if (Math.abs(lat - p.y) < DEL_TOL) {
          break;
        }
        p.y = lat;
      }
      /* convergence failed */
      if (!i) {
        return null;
      }
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$7 = ["gauss"];
    var gauss = {
      init: init$6,
      forward: forward$5,
      inverse: inverse$5,
      names: names$7
    };

    function init$5() {
      gauss.init.apply(this);
      if (!this.rc) {
        return;
      }
      this.sinc0 = Math.sin(this.phic0);
      this.cosc0 = Math.cos(this.phic0);
      this.R2 = 2 * this.rc;
      if (!this.title) {
        this.title = "Oblique Stereographic Alternative";
      }
    }

    function forward$4(p) {
      var sinc, cosc, cosl, k;
      p.x = adjust_lon(p.x - this.long0);
      gauss.forward.apply(this, [p]);
      sinc = Math.sin(p.y);
      cosc = Math.cos(p.y);
      cosl = Math.cos(p.x);
      k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
      p.x = k * cosc * Math.sin(p.x);
      p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
      p.x = this.a * p.x + this.x0;
      p.y = this.a * p.y + this.y0;
      return p;
    }

    function inverse$4(p) {
      var sinc, cosc, lon, lat, rho;
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      p.x /= this.k0;
      p.y /= this.k0;
      if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
        var c = 2 * Math.atan2(rho, this.R2);
        sinc = Math.sin(c);
        cosc = Math.cos(c);
        lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
        lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
      }
      else {
        lat = this.phic0;
        lon = 0;
      }

      p.x = lon;
      p.y = lat;
      gauss.inverse.apply(this, [p]);
      p.x = adjust_lon(p.x + this.long0);
      return p;
    }

    var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
    var sterea = {
      init: init$5,
      forward: forward$4,
      inverse: inverse$4,
      names: names$6
    };

    function ssfn_(phit, sinphi, eccen) {
      sinphi *= eccen;
      return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
    }

    function init$7() {
      this.coslat0 = Math.cos(this.lat0);
      this.sinlat0 = Math.sin(this.lat0);
      if (this.sphere) {
        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
          this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
        }
      }
      else {
        if (Math.abs(this.coslat0) <= EPSLN) {
          if (this.lat0 > 0) {
            //North pole
            //trace('stere:north pole');
            this.con = 1;
          }
          else {
            //South pole
            //trace('stere:south pole');
            this.con = -1;
          }
        }
        this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
          this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
        }
        this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
        this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
        this.cosX0 = Math.cos(this.X0);
        this.sinX0 = Math.sin(this.X0);
      }
    }

    // Stereographic forward equations--mapping lat,long to x,y
    function forward$6(p) {
      var lon = p.x;
      var lat = p.y;
      var sinlat = Math.sin(lat);
      var coslat = Math.cos(lat);
      var A, X, sinX, cosX, ts, rh;
      var dlon = adjust_lon(lon - this.long0);

      if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
        //case of the origine point
        //trace('stere:this is the origin point');
        p.x = NaN;
        p.y = NaN;
        return p;
      }
      if (this.sphere) {
        //trace('stere:sphere case');
        A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
        p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
        p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
        return p;
      }
      else {
        X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
        cosX = Math.cos(X);
        sinX = Math.sin(X);
        if (Math.abs(this.coslat0) <= EPSLN) {
          ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
          rh = 2 * this.a * this.k0 * ts / this.cons;
          p.x = this.x0 + rh * Math.sin(lon - this.long0);
          p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
          //trace(p.toString());
          return p;
        }
        else if (Math.abs(this.sinlat0) < EPSLN) {
          //Eq
          //trace('stere:equateur');
          A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
          p.y = A * sinX;
        }
        else {
          //other case
          //trace('stere:normal case');
          A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
          p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
        }
        p.x = A * cosX * Math.sin(dlon) + this.x0;
      }
      //trace(p.toString());
      return p;
    }

    //* Stereographic inverse equations--mapping x,y to lat/long
    function inverse$6(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var lon, lat, ts, ce, Chi;
      var rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (this.sphere) {
        var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
        lon = this.long0;
        lat = this.lat0;
        if (rh <= EPSLN) {
          p.x = lon;
          p.y = lat;
          return p;
        }
        lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
        if (Math.abs(this.coslat0) < EPSLN) {
          if (this.lat0 > 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
          }
          else {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
          }
        }
        else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
        }
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        if (Math.abs(this.coslat0) <= EPSLN) {
          if (rh <= EPSLN) {
            lat = this.lat0;
            lon = this.long0;
            p.x = lon;
            p.y = lat;
            //trace(p.toString());
            return p;
          }
          p.x *= this.con;
          p.y *= this.con;
          ts = rh * this.cons / (2 * this.a * this.k0);
          lat = this.con * phi2z(this.e, ts);
          lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
        }
        else {
          ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
          lon = this.long0;
          if (rh <= EPSLN) {
            Chi = this.X0;
          }
          else {
            Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
            lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
          }
          lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
        }
      }
      p.x = lon;
      p.y = lat;

      //trace(p.toString());
      return p;

    }

    var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
    var stere = {
      init: init$7,
      forward: forward$6,
      inverse: inverse$6,
      names: names$8,
      ssfn_: ssfn_
    };

    /*
      references:
        Formules et constantes pour le Calcul pour la
        projection cylindrique conforme à axe oblique et pour la transformation entre
        des systèmes de référence.
        http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
      */

    function init$8() {
      var phy0 = this.lat0;
      this.lambda0 = this.long0;
      var sinPhy0 = Math.sin(phy0);
      var semiMajorAxis = this.a;
      var invF = this.rf;
      var flattening = 1 / invF;
      var e2 = 2 * flattening - Math.pow(flattening, 2);
      var e = this.e = Math.sqrt(e2);
      this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
      this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
      this.b0 = Math.asin(sinPhy0 / this.alpha);
      var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
      var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
      var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
      this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
    }

    function forward$7(p) {
      var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
      var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
      var S = -this.alpha * (Sa1 + Sa2) + this.K;

      // spheric latitude
      var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

      // spheric longitude
      var I = this.alpha * (p.x - this.lambda0);

      // psoeudo equatorial rotation
      var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

      var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

      p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
      p.x = this.R * rotI + this.x0;
      return p;
    }

    function inverse$7(p) {
      var Y = p.x - this.x0;
      var X = p.y - this.y0;

      var rotI = Y / this.R;
      var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

      var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
      var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

      var lambda = this.lambda0 + I / this.alpha;

      var S = 0;
      var phy = b;
      var prevPhy = -1000;
      var iteration = 0;
      while (Math.abs(phy - prevPhy) > 0.0000001) {
        if (++iteration > 20) {
          //...reportError("omercFwdInfinity");
          return;
        }
        //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
        S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
        prevPhy = phy;
        phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
      }

      p.x = lambda;
      p.y = phy;
      return p;
    }

    var names$9 = ["somerc"];
    var somerc = {
      init: init$8,
      forward: forward$7,
      inverse: inverse$7,
      names: names$9
    };

    var TOL = 1e-7;

    function isTypeA(P) {
      var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
      var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
      
      return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
    }


    /* Initialize the Oblique Mercator  projection
        ------------------------------------------*/
    function init$9() {  
      var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
        gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
      
      // only Type A uses the no_off or no_uoff property
      // https://github.com/OSGeo/proj.4/issues/104
      this.no_off = isTypeA(this);
      this.no_rot = 'no_rot' in this;
      
      var alp = false;
      if ("alpha" in this) {
        alp = true;
      }

      var gam = false;
      if ("rectified_grid_angle" in this) {
        gam = true;
      }

      if (alp) {
        alpha_c = this.alpha;
      }
      
      if (gam) {
        gamma = (this.rectified_grid_angle * D2R);
      }
      
      if (alp || gam) {
        lamc = this.longc;
      } else {
        lam1 = this.long1;
        phi1 = this.lat1;
        lam2 = this.long2;
        phi2 = this.lat2;
        
        if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
            Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
            Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
          throw new Error();
        }
      }
      
      var one_es = 1.0 - this.es;
      com = Math.sqrt(one_es);
      
      if (Math.abs(this.lat0) > EPSLN) {
        sinph0 = Math.sin(this.lat0);
        cosph0 = Math.cos(this.lat0);
        con = 1 - this.es * sinph0 * sinph0;
        this.B = cosph0 * cosph0;
        this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
        this.A = this.B * this.k0 * com / con;
        D = this.B * com / (cosph0 * Math.sqrt(con));
        F = D * D -1;
        
        if (F <= 0) {
          F = 0;
        } else {
          F = Math.sqrt(F);
          if (this.lat0 < 0) {
            F = -F;
          }
        }
        
        this.E = F += D;
        this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
      } else {
        this.B = 1 / com;
        this.A = this.k0;
        this.E = D = F = 1;
      }
      
      if (alp || gam) {
        if (alp) {
          gamma0 = Math.asin(Math.sin(alpha_c) / D);
          if (!gam) {
            gamma = alpha_c;
          }
        } else {
          gamma0 = gamma;
          alpha_c = Math.asin(D * Math.sin(gamma0));
        }
        this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
      } else {
        H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
        L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
        F = this.E / H;
        p = (L - H) / (L + H);
        J = this.E * this.E;
        J = (J - L * H) / (J + L * H);
        con = lam1 - lam2;
        
        if (con < -Math.pi) {
          lam2 -=TWO_PI;
        } else if (con > Math.pi) {
          lam2 += TWO_PI;
        }
        
        this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
        gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
        gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      
      this.singam = Math.sin(gamma0);
      this.cosgam = Math.cos(gamma0);
      this.sinrot = Math.sin(gamma);
      this.cosrot = Math.cos(gamma);
      
      this.rB = 1 / this.B;
      this.ArB = this.A * this.rB;
      this.BrA = 1 / this.ArB;
      if (this.no_off) {
        this.u_0 = 0;
      } else {
        this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
        
        if (this.lat0 < 0) {
          this.u_0 = - this.u_0;
        }  
      }
        
      F = 0.5 * gamma0;
      this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
      this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
    }


    /* Oblique Mercator forward equations--mapping lat,long to x,y
        ----------------------------------------------------------*/
    function forward$8(p) {
      var coords = {};
      var S, T, U, V, W, temp, u, v;
      p.x = p.x - this.lam0;
      
      if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
        W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
        
        temp = 1 / W;
        S = 0.5 * (W - temp);
        T = 0.5 * (W + temp);
        V = Math.sin(this.B * p.x);
        U = (S * this.singam - V * this.cosgam) / T;
            
        if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
          throw new Error();
        }
        
        v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
        temp = Math.cos(this.B * p.x);
        
        if (Math.abs(temp) < TOL) {
          u = this.A * p.x;
        } else {
          u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
        }    
      } else {
        v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
        u = this.ArB * p.y;
      }
         
      if (this.no_rot) {
        coords.x = u;
        coords.y = v;
      } else {
        u -= this.u_0;
        coords.x = v * this.cosrot + u * this.sinrot;
        coords.y = u * this.cosrot - v * this.sinrot;
      }
      
      coords.x = (this.a * coords.x + this.x0);
      coords.y = (this.a * coords.y + this.y0);
      
      return coords;
    }

    function inverse$8(p) {
      var u, v, Qp, Sp, Tp, Vp, Up;
      var coords = {};
      
      p.x = (p.x - this.x0) * (1.0 / this.a);
      p.y = (p.y - this.y0) * (1.0 / this.a);

      if (this.no_rot) {
        v = p.y;
        u = p.x;
      } else {
        v = p.x * this.cosrot - p.y * this.sinrot;
        u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
      }
      
      Qp = Math.exp(-this.BrA * v);
      Sp = 0.5 * (Qp - 1 / Qp);
      Tp = 0.5 * (Qp + 1 / Qp);
      Vp = Math.sin(this.BrA * u);
      Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
      
      if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
        coords.x = 0;
        coords.y = Up < 0 ? -HALF_PI : HALF_PI;
      } else {
        coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
        coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
        
        if (coords.y === Infinity) {
          throw new Error();
        }
            
        coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
      }
      
      coords.x += this.lam0;
      
      return coords;
    }

    var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
    var omerc = {
      init: init$9,
      forward: forward$8,
      inverse: inverse$8,
      names: names$10
    };

    function init$10() {
      
      //double lat0;                    /* the reference latitude               */
      //double long0;                   /* the reference longitude              */
      //double lat1;                    /* first standard parallel              */
      //double lat2;                    /* second standard parallel             */
      //double r_maj;                   /* major axis                           */
      //double r_min;                   /* minor axis                           */
      //double false_east;              /* x offset in meters                   */
      //double false_north;             /* y offset in meters                   */
      
      //the above value can be set with proj4.defs
      //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

      if (!this.lat2) {
        this.lat2 = this.lat1;
      } //if lat2 is not defined
      if (!this.k0) {
        this.k0 = 1;
      }
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      // Standard Parallels cannot be equal and on opposite sides of the equator
      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }

      var temp = this.b / this.a;
      this.e = Math.sqrt(1 - temp * temp);

      var sin1 = Math.sin(this.lat1);
      var cos1 = Math.cos(this.lat1);
      var ms1 = msfnz(this.e, sin1, cos1);
      var ts1 = tsfnz(this.e, this.lat1, sin1);

      var sin2 = Math.sin(this.lat2);
      var cos2 = Math.cos(this.lat2);
      var ms2 = msfnz(this.e, sin2, cos2);
      var ts2 = tsfnz(this.e, this.lat2, sin2);

      var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
        this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
      }
      else {
        this.ns = sin1;
      }
      if (isNaN(this.ns)) {
        this.ns = sin1;
      }
      this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
      this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
      if (!this.title) {
        this.title = "Lambert Conformal Conic";
      }
    }

    // Lambert Conformal conic forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$9(p) {

      var lon = p.x;
      var lat = p.y;

      // singular cases :
      if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
        lat = sign(lat) * (HALF_PI - 2 * EPSLN);
      }

      var con = Math.abs(Math.abs(lat) - HALF_PI);
      var ts, rh1;
      if (con > EPSLN) {
        ts = tsfnz(this.e, lat, Math.sin(lat));
        rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
      }
      else {
        con = lat * this.ns;
        if (con <= 0) {
          return null;
        }
        rh1 = 0;
      }
      var theta = this.ns * adjust_lon(lon - this.long0);
      p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
      p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

      return p;
    }

    // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$9(p) {

      var rh1, con, ts;
      var lat, lon;
      var x = (p.x - this.x0) / this.k0;
      var y = (this.rh - (p.y - this.y0) / this.k0);
      if (this.ns > 0) {
        rh1 = Math.sqrt(x * x + y * y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(x * x + y * y);
        con = -1;
      }
      var theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2((con * x), (con * y));
      }
      if ((rh1 !== 0) || (this.ns > 0)) {
        con = 1 / this.ns;
        ts = Math.pow((rh1 / (this.a * this.f0)), con);
        lat = phi2z(this.e, ts);
        if (lat === -9999) {
          return null;
        }
      }
      else {
        lat = -HALF_PI;
      }
      lon = adjust_lon(theta / this.ns + this.long0);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$11 = [
      "Lambert Tangential Conformal Conic Projection",
      "Lambert_Conformal_Conic",
      "Lambert_Conformal_Conic_1SP",
      "Lambert_Conformal_Conic_2SP",
      "lcc"
    ];

    var lcc = {
      init: init$10,
      forward: forward$9,
      inverse: inverse$9,
      names: names$11
    };

    function init$11() {
      this.a = 6377397.155;
      this.es = 0.006674372230614;
      this.e = Math.sqrt(this.es);
      if (!this.lat0) {
        this.lat0 = 0.863937979737193;
      }
      if (!this.long0) {
        this.long0 = 0.7417649320975901 - 0.308341501185665;
      }
      /* if scale not set default to 0.9999 */
      if (!this.k0) {
        this.k0 = 0.9999;
      }
      this.s45 = 0.785398163397448; /* 45 */
      this.s90 = 2 * this.s45;
      this.fi0 = this.lat0;
      this.e2 = this.es;
      this.e = Math.sqrt(this.e2);
      this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
      this.uq = 1.04216856380474;
      this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
      this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
      this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
      this.k1 = this.k0;
      this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
      this.s0 = 1.37008346281555;
      this.n = Math.sin(this.s0);
      this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
      this.ad = this.s90 - this.uq;
    }

    /* ellipsoid */
    /* calculate xy from lat/lon */
    /* Constants, identical to inverse transform function */
    function forward$10(p) {
      var gfi, u, deltav, s, d, eps, ro;
      var lon = p.x;
      var lat = p.y;
      var delta_lon = adjust_lon(lon - this.long0);
      /* Transformation */
      gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
      u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
      deltav = -delta_lon * this.alfa;
      s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
      d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
      eps = this.n * d;
      ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
      p.y = ro * Math.cos(eps) / 1;
      p.x = ro * Math.sin(eps) / 1;

      if (!this.czech) {
        p.y *= -1;
        p.x *= -1;
      }
      return (p);
    }

    /* calculate lat/lon from xy */
    function inverse$10(p) {
      var u, deltav, s, d, eps, ro, fi1;
      var ok;

      /* Transformation */
      /* revert y, x*/
      var tmp = p.x;
      p.x = p.y;
      p.y = tmp;
      if (!this.czech) {
        p.y *= -1;
        p.x *= -1;
      }
      ro = Math.sqrt(p.x * p.x + p.y * p.y);
      eps = Math.atan2(p.y, p.x);
      d = eps / Math.sin(this.s0);
      s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
      u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
      deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
      p.x = this.long0 - deltav / this.alfa;
      fi1 = u;
      ok = 0;
      var iter = 0;
      do {
        p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
        if (Math.abs(fi1 - p.y) < 0.0000000001) {
          ok = 1;
        }
        fi1 = p.y;
        iter += 1;
      } while (ok === 0 && iter < 15);
      if (iter >= 15) {
        return null;
      }

      return (p);
    }

    var names$12 = ["Krovak", "krovak"];
    var krovak = {
      init: init$11,
      forward: forward$10,
      inverse: inverse$10,
      names: names$12
    };

    var mlfn = function(e0, e1, e2, e3, phi) {
      return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
    };

    var e0fn = function(x) {
      return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
    };

    var e1fn = function(x) {
      return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
    };

    var e2fn = function(x) {
      return (0.05859375 * x * x * (1 + 0.75 * x));
    };

    var e3fn = function(x) {
      return (x * x * x * (35 / 3072));
    };

    var gN = function(a, e, sinphi) {
      var temp = e * sinphi;
      return a / Math.sqrt(1 - temp * temp);
    };

    var adjust_lat = function(x) {
      return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
    };

    var imlfn = function(ml, e0, e1, e2, e3) {
      var phi;
      var dphi;

      phi = ml / e0;
      for (var i = 0; i < 15; i++) {
        dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }

      //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
      return NaN;
    };

    function init$12() {
      if (!this.sphere) {
        this.e0 = e0fn(this.es);
        this.e1 = e1fn(this.es);
        this.e2 = e2fn(this.es);
        this.e3 = e3fn(this.es);
        this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
      }
    }

    /* Cassini forward equations--mapping lat,long to x,y
      -----------------------------------------------------------------------*/
    function forward$11(p) {

      /* Forward equations
          -----------------*/
      var x, y;
      var lam = p.x;
      var phi = p.y;
      lam = adjust_lon(lam - this.long0);

      if (this.sphere) {
        x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
        y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
      }
      else {
        //ellipsoid
        var sinphi = Math.sin(phi);
        var cosphi = Math.cos(phi);
        var nl = gN(this.a, this.e, sinphi);
        var tl = Math.tan(phi) * Math.tan(phi);
        var al = lam * Math.cos(phi);
        var asq = al * al;
        var cl = this.es * cosphi * cosphi / (1 - this.es);
        var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

        x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
        y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


      }

      p.x = x + this.x0;
      p.y = y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$11(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var x = p.x / this.a;
      var y = p.y / this.a;
      var phi, lam;

      if (this.sphere) {
        var dd = y + this.lat0;
        phi = Math.asin(Math.sin(dd) * Math.cos(x));
        lam = Math.atan2(Math.tan(x), Math.cos(dd));
      }
      else {
        /* ellipsoid */
        var ml1 = this.ml0 / this.a + y;
        var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
        if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
          p.x = this.long0;
          p.y = HALF_PI;
          if (y < 0) {
            p.y *= -1;
          }
          return p;
        }
        var nl1 = gN(this.a, this.e, Math.sin(phi1));

        var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
        var tl1 = Math.pow(Math.tan(phi1), 2);
        var dl = x * this.a / nl1;
        var dsq = dl * dl;
        phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
        lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

      }

      p.x = adjust_lon(lam + this.long0);
      p.y = adjust_lat(phi);
      return p;

    }

    var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
    var cass = {
      init: init$12,
      forward: forward$11,
      inverse: inverse$11,
      names: names$13
    };

    var qsfnz = function(eccent, sinphi) {
      var con;
      if (eccent > 1.0e-7) {
        con = eccent * sinphi;
        return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
      }
      else {
        return (2 * sinphi);
      }
    };

    /*
      reference
        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
      */

    var S_POLE = 1;

    var N_POLE = 2;
    var EQUIT = 3;
    var OBLIQ = 4;

    /* Initialize the Lambert Azimuthal Equal Area projection
      ------------------------------------------------------*/
    function init$13() {
      var t = Math.abs(this.lat0);
      if (Math.abs(t - HALF_PI) < EPSLN) {
        this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
      }
      else if (Math.abs(t) < EPSLN) {
        this.mode = this.EQUIT;
      }
      else {
        this.mode = this.OBLIQ;
      }
      if (this.es > 0) {
        var sinphi;

        this.qp = qsfnz(this.e, 1);
        this.mmf = 0.5 / (1 - this.es);
        this.apa = authset(this.es);
        switch (this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp);
          this.dd = 1 / this.rq;
          this.xmf = 1;
          this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp);
          sinphi = Math.sin(this.lat0);
          this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
          this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
          this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
          this.ymf = (this.xmf = this.rq) / this.dd;
          this.xmf *= this.dd;
          break;
        }
      }
      else {
        if (this.mode === this.OBLIQ) {
          this.sinph0 = Math.sin(this.lat0);
          this.cosph0 = Math.cos(this.lat0);
        }
      }
    }

    /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
      -----------------------------------------------------------------------*/
    function forward$12(p) {

      /* Forward equations
          -----------------*/
      var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
      var lam = p.x;
      var phi = p.y;

      lam = adjust_lon(lam - this.long0);
      if (this.sphere) {
        sinphi = Math.sin(phi);
        cosphi = Math.cos(phi);
        coslam = Math.cos(lam);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
          if (y <= EPSLN) {
            return null;
          }
          y = Math.sqrt(2 / y);
          x = y * cosphi * Math.sin(lam);
          y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        }
        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
          if (this.mode === this.N_POLE) {
            coslam = -coslam;
          }
          if (Math.abs(phi + this.lat0) < EPSLN) {
            return null;
          }
          y = FORTPI - phi * 0.5;
          y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
          x = y * Math.sin(lam);
          y *= coslam;
        }
      }
      else {
        sinb = 0;
        cosb = 0;
        b = 0;
        coslam = Math.cos(lam);
        sinlam = Math.sin(lam);
        sinphi = Math.sin(phi);
        q = qsfnz(this.e, sinphi);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          sinb = q / this.qp;
          cosb = Math.sqrt(1 - sinb * sinb);
        }
        switch (this.mode) {
        case this.OBLIQ:
          b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
          break;
        case this.EQUIT:
          b = 1 + cosb * coslam;
          break;
        case this.N_POLE:
          b = HALF_PI + phi;
          q = this.qp - q;
          break;
        case this.S_POLE:
          b = phi - HALF_PI;
          q = this.qp + q;
          break;
        }
        if (Math.abs(b) < EPSLN) {
          return null;
        }
        switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          b = Math.sqrt(2 / b);
          if (this.mode === this.OBLIQ) {
            y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
          }
          else {
            y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
          }
          x = this.xmf * b * cosb * sinlam;
          break;
        case this.N_POLE:
        case this.S_POLE:
          if (q >= 0) {
            x = (b = Math.sqrt(q)) * sinlam;
            y = coslam * ((this.mode === this.S_POLE) ? b : -b);
          }
          else {
            x = y = 0;
          }
          break;
        }
      }

      p.x = this.a * x + this.x0;
      p.y = this.a * y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$12(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var x = p.x / this.a;
      var y = p.y / this.a;
      var lam, phi, cCe, sCe, q, rho, ab;
      if (this.sphere) {
        var cosz = 0,
          rh, sinz = 0;

        rh = Math.sqrt(x * x + y * y);
        phi = rh * 0.5;
        if (phi > 1) {
          return null;
        }
        phi = 2 * Math.asin(phi);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          sinz = Math.sin(phi);
          cosz = Math.cos(phi);
        }
        switch (this.mode) {
        case this.EQUIT:
          phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
          x *= sinz;
          y = cosz * rh;
          break;
        case this.OBLIQ:
          phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
          x *= sinz * this.cosph0;
          y = (cosz - Math.sin(phi) * this.sinph0) * rh;
          break;
        case this.N_POLE:
          y = -y;
          phi = HALF_PI - phi;
          break;
        case this.S_POLE:
          phi -= HALF_PI;
          break;
        }
        lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
      }
      else {
        ab = 0;
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          x /= this.dd;
          y *= this.dd;
          rho = Math.sqrt(x * x + y * y);
          if (rho < EPSLN) {
            p.x = this.long0;
            p.y = this.lat0;
            return p;
          }
          sCe = 2 * Math.asin(0.5 * rho / this.rq);
          cCe = Math.cos(sCe);
          x *= (sCe = Math.sin(sCe));
          if (this.mode === this.OBLIQ) {
            ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
            q = this.qp * ab;
            y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
          }
          else {
            ab = y * sCe / rho;
            q = this.qp * ab;
            y = rho * cCe;
          }
        }
        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
          if (this.mode === this.N_POLE) {
            y = -y;
          }
          q = (x * x + y * y);
          if (!q) {
            p.x = this.long0;
            p.y = this.lat0;
            return p;
          }
          ab = 1 - q / this.qp;
          if (this.mode === this.S_POLE) {
            ab = -ab;
          }
        }
        lam = Math.atan2(x, y);
        phi = authlat(Math.asin(ab), this.apa);
      }

      p.x = adjust_lon(this.long0 + lam);
      p.y = phi;
      return p;
    }

    /* determine latitude from authalic latitude */
    var P00 = 0.33333333333333333333;

    var P01 = 0.17222222222222222222;
    var P02 = 0.10257936507936507936;
    var P10 = 0.06388888888888888888;
    var P11 = 0.06640211640211640211;
    var P20 = 0.01641501294219154443;

    function authset(es) {
      var t;
      var APA = [];
      APA[0] = es * P00;
      t = es * es;
      APA[0] += t * P01;
      APA[1] = t * P10;
      t *= es;
      APA[0] += t * P02;
      APA[1] += t * P11;
      APA[2] = t * P20;
      return APA;
    }

    function authlat(beta, APA) {
      var t = beta + beta;
      return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
    }

    var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
    var laea = {
      init: init$13,
      forward: forward$12,
      inverse: inverse$12,
      names: names$14,
      S_POLE: S_POLE,
      N_POLE: N_POLE,
      EQUIT: EQUIT,
      OBLIQ: OBLIQ
    };

    var asinz = function(x) {
      if (Math.abs(x) > 1) {
        x = (x > 1) ? 1 : -1;
      }
      return Math.asin(x);
    };

    function init$14() {

      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2);
      this.e3 = Math.sqrt(this.es);

      this.sin_po = Math.sin(this.lat1);
      this.cos_po = Math.cos(this.lat1);
      this.t1 = this.sin_po;
      this.con = this.sin_po;
      this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
      this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

      this.sin_po = Math.sin(this.lat2);
      this.cos_po = Math.cos(this.lat2);
      this.t2 = this.sin_po;
      this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
      this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

      this.sin_po = Math.sin(this.lat0);
      this.cos_po = Math.cos(this.lat0);
      this.t3 = this.sin_po;
      this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
        this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
      }
      else {
        this.ns0 = this.con;
      }
      this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
      this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
    }

    /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
      -------------------------------------------------------------------*/
    function forward$13(p) {

      var lon = p.x;
      var lat = p.y;

      this.sin_phi = Math.sin(lat);
      this.cos_phi = Math.cos(lat);

      var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
      var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
      var theta = this.ns0 * adjust_lon(lon - this.long0);
      var x = rh1 * Math.sin(theta) + this.x0;
      var y = this.rh - rh1 * Math.cos(theta) + this.y0;

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$13(p) {
      var rh1, qs, con, theta, lon, lat;

      p.x -= this.x0;
      p.y = this.rh - p.y + this.y0;
      if (this.ns0 >= 0) {
        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
        con = -1;
      }
      theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2(con * p.x, con * p.y);
      }
      con = rh1 * this.ns0 / this.a;
      if (this.sphere) {
        lat = Math.asin((this.c - con * con) / (2 * this.ns0));
      }
      else {
        qs = (this.c - con * con) / this.ns0;
        lat = this.phi1z(this.e3, qs);
      }

      lon = adjust_lon(theta / this.ns0 + this.long0);
      p.x = lon;
      p.y = lat;
      return p;
    }

    /* Function to compute phi1, the latitude for the inverse of the
       Albers Conical Equal-Area projection.
    -------------------------------------------*/
    function phi1z(eccent, qs) {
      var sinphi, cosphi, con, com, dphi;
      var phi = asinz(0.5 * qs);
      if (eccent < EPSLN) {
        return phi;
      }

      var eccnts = eccent * eccent;
      for (var i = 1; i <= 25; i++) {
        sinphi = Math.sin(phi);
        cosphi = Math.cos(phi);
        con = eccent * sinphi;
        com = 1 - con * con;
        dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
        phi = phi + dphi;
        if (Math.abs(dphi) <= 1e-7) {
          return phi;
        }
      }
      return null;
    }

    var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
    var aea = {
      init: init$14,
      forward: forward$13,
      inverse: inverse$13,
      names: names$15,
      phi1z: phi1z
    };

    /*
      reference:
        Wolfram Mathworld "Gnomonic Projection"
        http://mathworld.wolfram.com/GnomonicProjection.html
        Accessed: 12th November 2009
      */
    function init$15() {

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.sin_p14 = Math.sin(this.lat0);
      this.cos_p14 = Math.cos(this.lat0);
      // Approximation for projecting points to the horizon (infinity)
      this.infinity_dist = 1000 * this.a;
      this.rc = 1;
    }

    /* Gnomonic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$14(p) {
      var sinphi, cosphi; /* sin and cos value        */
      var dlon; /* delta longitude value      */
      var coslon; /* cos of longitude        */
      var ksp; /* scale factor          */
      var g;
      var x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      dlon = adjust_lon(lon - this.long0);

      sinphi = Math.sin(lat);
      cosphi = Math.cos(lat);

      coslon = Math.cos(dlon);
      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
      ksp = 1;
      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
        x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
      }
      else {

        // Point is in the opposing hemisphere and is unprojectable
        // We still need to return a reasonable point, so we project
        // to infinity, on a bearing
        // equivalent to the northern hemisphere equivalent
        // This is a reasonable approximation for short shapes and lines that
        // straddle the horizon.

        x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
        y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

      }
      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$14(p) {
      var rh; /* Rho */
      var sinc, cosc;
      var c;
      var lon, lat;

      /* Inverse equations
          -----------------*/
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      p.x /= this.k0;
      p.y /= this.k0;

      if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
        c = Math.atan2(rh, this.rc);
        sinc = Math.sin(c);
        cosc = Math.cos(c);

        lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
        lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
        lon = adjust_lon(this.long0 + lon);
      }
      else {
        lat = this.phic0;
        lon = 0;
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$16 = ["gnom"];
    var gnom = {
      init: init$15,
      forward: forward$14,
      inverse: inverse$14,
      names: names$16
    };

    var iqsfnz = function(eccent, q) {
      var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
      if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
        if (q < 0) {
          return (-1 * HALF_PI);
        }
        else {
          return HALF_PI;
        }
      }
      //var phi = 0.5* q/(1-eccent*eccent);
      var phi = Math.asin(0.5 * q);
      var dphi;
      var sin_phi;
      var cos_phi;
      var con;
      for (var i = 0; i < 30; i++) {
        sin_phi = Math.sin(phi);
        cos_phi = Math.cos(phi);
        con = eccent * sin_phi;
        dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }

      //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
      return NaN;
    };

    /*
      reference:
        "Cartographic Projection Procedures for the UNIX Environment-
        A User's Manual" by Gerald I. Evenden,
        USGS Open File Report 90-284and Release 4 Interim Reports (2003)
    */
    function init$16() {
      //no-op
      if (!this.sphere) {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    }

    /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
        ------------------------------------------------------------*/
    function forward$15(p) {
      var lon = p.x;
      var lat = p.y;
      var x, y;
      /* Forward equations
          -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      if (this.sphere) {
        x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
        y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
      }
      else {
        var qs = qsfnz(this.e, Math.sin(lat));
        x = this.x0 + this.a * this.k0 * dlon;
        y = this.y0 + this.a * qs * 0.5 / this.k0;
      }

      p.x = x;
      p.y = y;
      return p;
    }

    /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
        ------------------------------------------------------------*/
    function inverse$15(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var lon, lat;

      if (this.sphere) {
        lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
        lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
      }
      else {
        lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
        lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$17 = ["cea"];
    var cea = {
      init: init$16,
      forward: forward$15,
      inverse: inverse$15,
      names: names$17
    };

    function init$17() {

      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.lat0 = this.lat0 || 0;
      this.long0 = this.long0 || 0;
      this.lat_ts = this.lat_ts || 0;
      this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

      this.rc = Math.cos(this.lat_ts);
    }

    // forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$16(p) {

      var lon = p.x;
      var lat = p.y;

      var dlon = adjust_lon(lon - this.long0);
      var dlat = adjust_lat(lat - this.lat0);
      p.x = this.x0 + (this.a * dlon * this.rc);
      p.y = this.y0 + (this.a * dlat);
      return p;
    }

    // inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$16(p) {

      var x = p.x;
      var y = p.y;

      p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
      p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
      return p;
    }

    var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
    var eqc = {
      init: init$17,
      forward: forward$16,
      inverse: inverse$16,
      names: names$18
    };

    var MAX_ITER$2 = 20;

    function init$18() {
      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
      this.e = Math.sqrt(this.es);
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
    }

    /* Polyconic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$17(p) {
      var lon = p.x;
      var lat = p.y;
      var x, y, el;
      var dlon = adjust_lon(lon - this.long0);
      el = dlon * Math.sin(lat);
      if (this.sphere) {
        if (Math.abs(lat) <= EPSLN) {
          x = this.a * dlon;
          y = -1 * this.a * this.lat0;
        }
        else {
          x = this.a * Math.sin(el) / Math.tan(lat);
          y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
        }
      }
      else {
        if (Math.abs(lat) <= EPSLN) {
          x = this.a * dlon;
          y = -1 * this.ml0;
        }
        else {
          var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
          x = nl * Math.sin(el);
          y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
        }

      }
      p.x = x + this.x0;
      p.y = y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$17(p) {
      var lon, lat, x, y, i;
      var al, bl;
      var phi, dphi;
      x = p.x - this.x0;
      y = p.y - this.y0;

      if (this.sphere) {
        if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
          lon = adjust_lon(x / this.a + this.long0);
          lat = 0;
        }
        else {
          al = this.lat0 + y / this.a;
          bl = x * x / this.a / this.a + al * al;
          phi = al;
          var tanphi;
          for (i = MAX_ITER$2; i; --i) {
            tanphi = Math.tan(phi);
            dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
            phi += dphi;
            if (Math.abs(dphi) <= EPSLN) {
              lat = phi;
              break;
            }
          }
          lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
        }
      }
      else {
        if (Math.abs(y + this.ml0) <= EPSLN) {
          lat = 0;
          lon = adjust_lon(this.long0 + x / this.a);
        }
        else {

          al = (this.ml0 + y) / this.a;
          bl = x * x / this.a / this.a + al * al;
          phi = al;
          var cl, mln, mlnp, ma;
          var con;
          for (i = MAX_ITER$2; i; --i) {
            con = this.e * Math.sin(phi);
            cl = Math.sqrt(1 - con * con) * Math.tan(phi);
            mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
            mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
            ma = mln / this.a;
            dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
            phi -= dphi;
            if (Math.abs(dphi) <= EPSLN) {
              lat = phi;
              break;
            }
          }

          //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
          cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
          lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
        }
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$19 = ["Polyconic", "poly"];
    var poly = {
      init: init$18,
      forward: forward$17,
      inverse: inverse$17,
      names: names$19
    };

    /*
      reference
        Department of Land and Survey Technical Circular 1973/32
          http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
        OSG Technical Report 4.1
          http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
      */

    /**
     * iterations: Number of iterations to refine inverse transform.
     *     0 -> km accuracy
     *     1 -> m accuracy -- suitable for most mapping applications
     *     2 -> mm accuracy
     */


    function init$19() {
      this.A = [];
      this.A[1] = 0.6399175073;
      this.A[2] = -0.1358797613;
      this.A[3] = 0.063294409;
      this.A[4] = -0.02526853;
      this.A[5] = 0.0117879;
      this.A[6] = -0.0055161;
      this.A[7] = 0.0026906;
      this.A[8] = -0.001333;
      this.A[9] = 0.00067;
      this.A[10] = -0.00034;

      this.B_re = [];
      this.B_im = [];
      this.B_re[1] = 0.7557853228;
      this.B_im[1] = 0;
      this.B_re[2] = 0.249204646;
      this.B_im[2] = 0.003371507;
      this.B_re[3] = -0.001541739;
      this.B_im[3] = 0.041058560;
      this.B_re[4] = -0.10162907;
      this.B_im[4] = 0.01727609;
      this.B_re[5] = -0.26623489;
      this.B_im[5] = -0.36249218;
      this.B_re[6] = -0.6870983;
      this.B_im[6] = -1.1651967;

      this.C_re = [];
      this.C_im = [];
      this.C_re[1] = 1.3231270439;
      this.C_im[1] = 0;
      this.C_re[2] = -0.577245789;
      this.C_im[2] = -0.007809598;
      this.C_re[3] = 0.508307513;
      this.C_im[3] = -0.112208952;
      this.C_re[4] = -0.15094762;
      this.C_im[4] = 0.18200602;
      this.C_re[5] = 1.01418179;
      this.C_im[5] = 1.64497696;
      this.C_re[6] = 1.9660549;
      this.C_im[6] = 2.5127645;

      this.D = [];
      this.D[1] = 1.5627014243;
      this.D[2] = 0.5185406398;
      this.D[3] = -0.03333098;
      this.D[4] = -0.1052906;
      this.D[5] = -0.0368594;
      this.D[6] = 0.007317;
      this.D[7] = 0.01220;
      this.D[8] = 0.00394;
      this.D[9] = -0.0013;
    }

    /**
        New Zealand Map Grid Forward  - long/lat to x/y
        long/lat in radians
      */
    function forward$18(p) {
      var n;
      var lon = p.x;
      var lat = p.y;

      var delta_lat = lat - this.lat0;
      var delta_lon = lon - this.long0;

      // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
      // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
      var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
      var d_lambda = delta_lon;
      var d_phi_n = 1; // d_phi^0

      var d_psi = 0;
      for (n = 1; n <= 10; n++) {
        d_phi_n = d_phi_n * d_phi;
        d_psi = d_psi + this.A[n] * d_phi_n;
      }

      // 2. Calculate theta
      var th_re = d_psi;
      var th_im = d_lambda;

      // 3. Calculate z
      var th_n_re = 1;
      var th_n_im = 0; // theta^0
      var th_n_re1;
      var th_n_im1;

      var z_re = 0;
      var z_im = 0;
      for (n = 1; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
        z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
      }

      // 4. Calculate easting and northing
      p.x = (z_im * this.a) + this.x0;
      p.y = (z_re * this.a) + this.y0;

      return p;
    }

    /**
        New Zealand Map Grid Inverse  -  x/y to long/lat
      */
    function inverse$18(p) {
      var n;
      var x = p.x;
      var y = p.y;

      var delta_x = x - this.x0;
      var delta_y = y - this.y0;

      // 1. Calculate z
      var z_re = delta_y / this.a;
      var z_im = delta_x / this.a;

      // 2a. Calculate theta - first approximation gives km accuracy
      var z_n_re = 1;
      var z_n_im = 0; // z^0
      var z_n_re1;
      var z_n_im1;

      var th_re = 0;
      var th_im = 0;
      for (n = 1; n <= 6; n++) {
        z_n_re1 = z_n_re * z_re - z_n_im * z_im;
        z_n_im1 = z_n_im * z_re + z_n_re * z_im;
        z_n_re = z_n_re1;
        z_n_im = z_n_im1;
        th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
        th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
      }

      // 2b. Iterate to refine the accuracy of the calculation
      //        0 iterations gives km accuracy
      //        1 iteration gives m accuracy -- good enough for most mapping applications
      //        2 iterations bives mm accuracy
      for (var i = 0; i < this.iterations; i++) {
        var th_n_re = th_re;
        var th_n_im = th_im;
        var th_n_re1;
        var th_n_im1;

        var num_re = z_re;
        var num_im = z_im;
        for (n = 2; n <= 6; n++) {
          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
          th_n_re = th_n_re1;
          th_n_im = th_n_im1;
          num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
          num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
        }

        th_n_re = 1;
        th_n_im = 0;
        var den_re = this.B_re[1];
        var den_im = this.B_im[1];
        for (n = 2; n <= 6; n++) {
          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
          th_n_re = th_n_re1;
          th_n_im = th_n_im1;
          den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
          den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
        }

        // Complex division
        var den2 = den_re * den_re + den_im * den_im;
        th_re = (num_re * den_re + num_im * den_im) / den2;
        th_im = (num_im * den_re - num_re * den_im) / den2;
      }

      // 3. Calculate d_phi              ...                                    // and d_lambda
      var d_psi = th_re;
      var d_lambda = th_im;
      var d_psi_n = 1; // d_psi^0

      var d_phi = 0;
      for (n = 1; n <= 9; n++) {
        d_psi_n = d_psi_n * d_psi;
        d_phi = d_phi + this.D[n] * d_psi_n;
      }

      // 4. Calculate latitude and longitude
      // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
      var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
      var lon = this.long0 + d_lambda;

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
    var nzmg = {
      init: init$19,
      forward: forward$18,
      inverse: inverse$18,
      names: names$20
    };

    /*
      reference
        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
      */


    /* Initialize the Miller Cylindrical projection
      -------------------------------------------*/
    function init$20() {
      //no-op
    }

    /* Miller Cylindrical forward equations--mapping lat,long to x,y
        ------------------------------------------------------------*/
    function forward$19(p) {
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      var x = this.x0 + this.a * dlon;
      var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

      p.x = x;
      p.y = y;
      return p;
    }

    /* Miller Cylindrical inverse equations--mapping x,y to lat/long
        ------------------------------------------------------------*/
    function inverse$19(p) {
      p.x -= this.x0;
      p.y -= this.y0;

      var lon = adjust_lon(this.long0 + p.x / this.a);
      var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$21 = ["Miller_Cylindrical", "mill"];
    var mill = {
      init: init$20,
      forward: forward$19,
      inverse: inverse$19,
      names: names$21
    };

    var MAX_ITER$3 = 20;
    function init$21() {
      /* Place parameters in static storage for common use
        -------------------------------------------------*/


      if (!this.sphere) {
        this.en = pj_enfn(this.es);
      }
      else {
        this.n = 1;
        this.m = 0;
        this.es = 0;
        this.C_y = Math.sqrt((this.m + 1) / this.n);
        this.C_x = this.C_y / (this.m + 1);
      }

    }

    /* Sinusoidal forward equations--mapping lat,long to x,y
      -----------------------------------------------------*/
    function forward$20(p) {
      var x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
        -----------------*/
      lon = adjust_lon(lon - this.long0);

      if (this.sphere) {
        if (!this.m) {
          lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
        }
        else {
          var k = this.n * Math.sin(lat);
          for (var i = MAX_ITER$3; i; --i) {
            var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
            lat -= V;
            if (Math.abs(V) < EPSLN) {
              break;
            }
          }
        }
        x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
        y = this.a * this.C_y * lat;

      }
      else {

        var s = Math.sin(lat);
        var c = Math.cos(lat);
        y = this.a * pj_mlfn(lat, s, c, this.en);
        x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
      }

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$20(p) {
      var lat, temp, lon, s;

      p.x -= this.x0;
      lon = p.x / this.a;
      p.y -= this.y0;
      lat = p.y / this.a;

      if (this.sphere) {
        lat /= this.C_y;
        lon = lon / (this.C_x * (this.m + Math.cos(lat)));
        if (this.m) {
          lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
        }
        else if (this.n !== 1) {
          lat = asinz(Math.sin(lat) / this.n);
        }
        lon = adjust_lon(lon + this.long0);
        lat = adjust_lat(lat);
      }
      else {
        lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
        s = Math.abs(lat);
        if (s < HALF_PI) {
          s = Math.sin(lat);
          temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
          //temp = this.long0 + p.x / (this.a * Math.cos(lat));
          lon = adjust_lon(temp);
        }
        else if ((s - EPSLN) < HALF_PI) {
          lon = this.long0;
        }
      }
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$22 = ["Sinusoidal", "sinu"];
    var sinu = {
      init: init$21,
      forward: forward$20,
      inverse: inverse$20,
      names: names$22
    };

    function init$22() {}
    /* Mollweide forward equations--mapping lat,long to x,y
        ----------------------------------------------------*/
    function forward$21(p) {

      /* Forward equations
          -----------------*/
      var lon = p.x;
      var lat = p.y;

      var delta_lon = adjust_lon(lon - this.long0);
      var theta = lat;
      var con = Math.PI * Math.sin(lat);

      /* Iterate using the Newton-Raphson method to find theta
          -----------------------------------------------------*/
      while (true) {
        var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
        theta += delta_theta;
        if (Math.abs(delta_theta) < EPSLN) {
          break;
        }
      }
      theta /= 2;

      /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
           this is done here because of precision problems with "cos(theta)"
           --------------------------------------------------------------------------*/
      if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
        delta_lon = 0;
      }
      var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
      var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$21(p) {
      var theta;
      var arg;

      /* Inverse equations
          -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      arg = p.y / (1.4142135623731 * this.a);

      /* Because of division by zero problems, 'arg' can not be 1.  Therefore
           a number very close to one is used instead.
           -------------------------------------------------------------------*/
      if (Math.abs(arg) > 0.999999999999) {
        arg = 0.999999999999;
      }
      theta = Math.asin(arg);
      var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
      if (lon < (-Math.PI)) {
        lon = -Math.PI;
      }
      if (lon > Math.PI) {
        lon = Math.PI;
      }
      arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
      if (Math.abs(arg) > 1) {
        arg = 1;
      }
      var lat = Math.asin(arg);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$23 = ["Mollweide", "moll"];
    var moll = {
      init: init$22,
      forward: forward$21,
      inverse: inverse$21,
      names: names$23
    };

    function init$23() {

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      // Standard Parallels cannot be equal and on opposite sides of the equator
      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }
      this.lat2 = this.lat2 || this.lat1;
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2);
      this.e = Math.sqrt(this.es);
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);

      this.sinphi = Math.sin(this.lat1);
      this.cosphi = Math.cos(this.lat1);

      this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

      if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
        this.ns = this.sinphi;
      }
      else {
        this.sinphi = Math.sin(this.lat2);
        this.cosphi = Math.cos(this.lat2);
        this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
        this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
        this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
      }
      this.g = this.ml1 + this.ms1 / this.ns;
      this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
      this.rh = this.a * (this.g - this.ml0);
    }

    /* Equidistant Conic forward equations--mapping lat,long to x,y
      -----------------------------------------------------------*/
    function forward$22(p) {
      var lon = p.x;
      var lat = p.y;
      var rh1;

      /* Forward equations
          -----------------*/
      if (this.sphere) {
        rh1 = this.a * (this.g - lat);
      }
      else {
        var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
        rh1 = this.a * (this.g - ml);
      }
      var theta = this.ns * adjust_lon(lon - this.long0);
      var x = this.x0 + rh1 * Math.sin(theta);
      var y = this.y0 + this.rh - rh1 * Math.cos(theta);
      p.x = x;
      p.y = y;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$22(p) {
      p.x -= this.x0;
      p.y = this.rh - p.y + this.y0;
      var con, rh1, lat, lon;
      if (this.ns >= 0) {
        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
        con = -1;
      }
      var theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2(con * p.x, con * p.y);
      }

      if (this.sphere) {
        lon = adjust_lon(this.long0 + theta / this.ns);
        lat = adjust_lat(this.g - rh1 / this.a);
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        var ml = this.g - rh1 / this.a;
        lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
        lon = adjust_lon(this.long0 + theta / this.ns);
        p.x = lon;
        p.y = lat;
        return p;
      }

    }

    var names$24 = ["Equidistant_Conic", "eqdc"];
    var eqdc = {
      init: init$23,
      forward: forward$22,
      inverse: inverse$22,
      names: names$24
    };

    /* Initialize the Van Der Grinten projection
      ----------------------------------------*/
    function init$24() {
      //this.R = 6370997; //Radius of earth
      this.R = this.a;
    }

    function forward$23(p) {

      var lon = p.x;
      var lat = p.y;

      /* Forward equations
        -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      var x, y;

      if (Math.abs(lat) <= EPSLN) {
        x = this.x0 + this.R * dlon;
        y = this.y0;
      }
      var theta = asinz(2 * Math.abs(lat / Math.PI));
      if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
        x = this.x0;
        if (lat >= 0) {
          y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
        }
        else {
          y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
        }
        //  return(OK);
      }
      var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
      var asq = al * al;
      var sinth = Math.sin(theta);
      var costh = Math.cos(theta);

      var g = costh / (sinth + costh - 1);
      var gsq = g * g;
      var m = g * (2 / sinth - 1);
      var msq = m * m;
      var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
      if (dlon < 0) {
        con = -con;
      }
      x = this.x0 + con;
      //con = Math.abs(con / (Math.PI * this.R));
      var q = asq + g;
      con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
      if (lat >= 0) {
        //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
        y = this.y0 + con;
      }
      else {
        //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
        y = this.y0 - con;
      }
      p.x = x;
      p.y = y;
      return p;
    }

    /* Van Der Grinten inverse equations--mapping x,y to lat/long
      ---------------------------------------------------------*/
    function inverse$23(p) {
      var lon, lat;
      var xx, yy, xys, c1, c2, c3;
      var a1;
      var m1;
      var con;
      var th1;
      var d;

      /* inverse equations
        -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      con = Math.PI * this.R;
      xx = p.x / con;
      yy = p.y / con;
      xys = xx * xx + yy * yy;
      c1 = -Math.abs(yy) * (1 + xys);
      c2 = c1 - 2 * yy * yy + xx * xx;
      c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
      d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
      a1 = (c1 - c2 * c2 / 3 / c3) / c3;
      m1 = 2 * Math.sqrt(-a1 / 3);
      con = ((3 * d) / a1) / m1;
      if (Math.abs(con) > 1) {
        if (con >= 0) {
          con = 1;
        }
        else {
          con = -1;
        }
      }
      th1 = Math.acos(con) / 3;
      if (p.y >= 0) {
        lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
      }
      else {
        lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
      }

      if (Math.abs(xx) < EPSLN) {
        lon = this.long0;
      }
      else {
        lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
    var vandg = {
      init: init$24,
      forward: forward$23,
      inverse: inverse$23,
      names: names$25
    };

    function init$25() {
      this.sin_p12 = Math.sin(this.lat0);
      this.cos_p12 = Math.cos(this.lat0);
    }

    function forward$24(p) {
      var lon = p.x;
      var lat = p.y;
      var sinphi = Math.sin(p.y);
      var cosphi = Math.cos(p.y);
      var dlon = adjust_lon(lon - this.long0);
      var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
      if (this.sphere) {
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North Pole case
          p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
          p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South Pole case
          p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
          p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
          return p;
        }
        else {
          //default case
          cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
          c = Math.acos(cos_c);
          kp = c ? c / Math.sin(c) : 1;
          p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
          p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
          return p;
        }
      }
      else {
        e0 = e0fn(this.es);
        e1 = e1fn(this.es);
        e2 = e2fn(this.es);
        e3 = e3fn(this.es);
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North Pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
          p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
          p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South Pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
          p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
          p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
          return p;
        }
        else {
          //Default case
          tanphi = sinphi / cosphi;
          Nl1 = gN(this.a, this.e, this.sin_p12);
          Nl = gN(this.a, this.e, sinphi);
          psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
          Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
          if (Az === 0) {
            s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
          }
          else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
            s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
          }
          else {
            s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
          }
          G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
          H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
          GH = G * H;
          Hs = H * H;
          s2 = s * s;
          s3 = s2 * s;
          s4 = s3 * s;
          s5 = s4 * s;
          c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
          p.x = this.x0 + c * Math.sin(Az);
          p.y = this.y0 + c * Math.cos(Az);
          return p;
        }
      }


    }

    function inverse$24(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
      if (this.sphere) {
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        if (rh > (2 * HALF_PI * this.a)) {
          return;
        }
        z = rh / this.a;

        sinz = Math.sin(z);
        cosz = Math.cos(z);

        lon = this.long0;
        if (Math.abs(rh) <= EPSLN) {
          lat = this.lat0;
        }
        else {
          lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
          con = Math.abs(this.lat0) - HALF_PI;
          if (Math.abs(con) <= EPSLN) {
            if (this.lat0 >= 0) {
              lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
            }
            else {
              lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
            }
          }
          else {
            /*con = cosz - this.sin_p12 * Math.sin(lat);
            if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
              //no-op, just keep the lon value as is
            } else {
              var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
              lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
            }*/
            lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
          }
        }

        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        e0 = e0fn(this.es);
        e1 = e1fn(this.es);
        e2 = e2fn(this.es);
        e3 = e3fn(this.es);
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          M = Mlp - rh;
          lat = imlfn(M / this.a, e0, e1, e2, e3);
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
          p.x = lon;
          p.y = lat;
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          M = rh - Mlp;

          lat = imlfn(M / this.a, e0, e1, e2, e3);
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
          p.x = lon;
          p.y = lat;
          return p;
        }
        else {
          //default case
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          Az = Math.atan2(p.x, p.y);
          N1 = gN(this.a, this.e, this.sin_p12);
          cosAz = Math.cos(Az);
          tmp = this.e * this.cos_p12 * cosAz;
          A = -tmp * tmp / (1 - this.es);
          B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
          D = rh / N1;
          Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
          F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
          psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
          lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
          sinpsi = Math.sin(psi);
          lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
          p.x = lon;
          p.y = lat;
          return p;
        }
      }

    }

    var names$26 = ["Azimuthal_Equidistant", "aeqd"];
    var aeqd = {
      init: init$25,
      forward: forward$24,
      inverse: inverse$24,
      names: names$26
    };

    function init$26() {
      //double temp;      /* temporary variable    */

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.sin_p14 = Math.sin(this.lat0);
      this.cos_p14 = Math.cos(this.lat0);
    }

    /* Orthographic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$25(p) {
      var sinphi, cosphi; /* sin and cos value        */
      var dlon; /* delta longitude value      */
      var coslon; /* cos of longitude        */
      var ksp; /* scale factor          */
      var g, x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      dlon = adjust_lon(lon - this.long0);

      sinphi = Math.sin(lat);
      cosphi = Math.cos(lat);

      coslon = Math.cos(dlon);
      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
      ksp = 1;
      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
        x = this.a * ksp * cosphi * Math.sin(dlon);
        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
      }
      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$25(p) {
      var rh; /* height above ellipsoid      */
      var z; /* angle          */
      var sinz, cosz; /* sin of z and cos of z      */
      var con;
      var lon, lat;
      /* Inverse equations
          -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      z = asinz(rh / this.a);

      sinz = Math.sin(z);
      cosz = Math.cos(z);

      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
        p.x = lon;
        p.y = lat;
        return p;
      }
      lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$27 = ["ortho"];
    var ortho = {
      init: init$26,
      forward: forward$25,
      inverse: inverse$25,
      names: names$27
    };

    // QSC projection rewritten from the original PROJ4
    // https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

    /* constants */
    var FACE_ENUM = {
        FRONT: 1,
        RIGHT: 2,
        BACK: 3,
        LEFT: 4,
        TOP: 5,
        BOTTOM: 6
    };

    var AREA_ENUM = {
        AREA_0: 1,
        AREA_1: 2,
        AREA_2: 3,
        AREA_3: 4
    };

    function init$27() {

      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.lat0 = this.lat0 || 0;
      this.long0 = this.long0 || 0;
      this.lat_ts = this.lat_ts || 0;
      this.title = this.title || "Quadrilateralized Spherical Cube";

      /* Determine the cube face from the center of projection. */
      if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
        this.face = FACE_ENUM.TOP;
      } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
        this.face = FACE_ENUM.BOTTOM;
      } else if (Math.abs(this.long0) <= FORTPI) {
        this.face = FACE_ENUM.FRONT;
      } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
        this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
      } else {
        this.face = FACE_ENUM.BACK;
      }

      /* Fill in useful values for the ellipsoid <-> sphere shift
       * described in [LK12]. */
      if (this.es !== 0) {
        this.one_minus_f = 1 - (this.a - this.b) / this.a;
        this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
      }
    }

    // QSC forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$26(p) {
      var xy = {x: 0, y: 0};
      var lat, lon;
      var theta, phi;
      var t, mu;
      /* nu; */
      var area = {value: 0};

      // move lon according to projection's lon
      p.x -= this.long0;

      /* Convert the geodetic latitude to a geocentric latitude.
       * This corresponds to the shift from the ellipsoid to the sphere
       * described in [LK12]. */
      if (this.es !== 0) {//if (P->es != 0) {
        lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
      } else {
        lat = p.y;
      }

      /* Convert the input lat, lon into theta, phi as used by QSC.
       * This depends on the cube face and the area on it.
       * For the top and bottom face, we can compute theta and phi
       * directly from phi, lam. For the other faces, we must use
       * unit sphere cartesian coordinates as an intermediate step. */
      lon = p.x; //lon = lp.lam;
      if (this.face === FACE_ENUM.TOP) {
        phi = HALF_PI - lat;
        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_0;
          theta = lon - HALF_PI;
        } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_1;
          theta = (lon > 0.0 ? lon - SPI : lon + SPI);
        } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
          area.value = AREA_ENUM.AREA_2;
          theta = lon + HALF_PI;
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta = lon;
        }
      } else if (this.face === FACE_ENUM.BOTTOM) {
        phi = HALF_PI + lat;
        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_0;
          theta = -lon + HALF_PI;
        } else if (lon < FORTPI && lon >= -FORTPI) {
          area.value = AREA_ENUM.AREA_1;
          theta = -lon;
        } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_2;
          theta = -lon - HALF_PI;
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
        }
      } else {
        var q, r, s;
        var sinlat, coslat;
        var sinlon, coslon;

        if (this.face === FACE_ENUM.RIGHT) {
          lon = qsc_shift_lon_origin(lon, +HALF_PI);
        } else if (this.face === FACE_ENUM.BACK) {
          lon = qsc_shift_lon_origin(lon, +SPI);
        } else if (this.face === FACE_ENUM.LEFT) {
          lon = qsc_shift_lon_origin(lon, -HALF_PI);
        }
        sinlat = Math.sin(lat);
        coslat = Math.cos(lat);
        sinlon = Math.sin(lon);
        coslon = Math.cos(lon);
        q = coslat * coslon;
        r = coslat * sinlon;
        s = sinlat;

        if (this.face === FACE_ENUM.FRONT) {
          phi = Math.acos(q);
          theta = qsc_fwd_equat_face_theta(phi, s, r, area);
        } else if (this.face === FACE_ENUM.RIGHT) {
          phi = Math.acos(r);
          theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
        } else if (this.face === FACE_ENUM.BACK) {
          phi = Math.acos(-q);
          theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
        } else if (this.face === FACE_ENUM.LEFT) {
          phi = Math.acos(-r);
          theta = qsc_fwd_equat_face_theta(phi, s, q, area);
        } else {
          /* Impossible */
          phi = theta = 0;
          area.value = AREA_ENUM.AREA_0;
        }
      }

      /* Compute mu and nu for the area of definition.
       * For mu, see Eq. (3-21) in [OL76], but note the typos:
       * compare with Eq. (3-14). For nu, see Eq. (3-38). */
      mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
      t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

      /* Apply the result to the real area. */
      if (area.value === AREA_ENUM.AREA_1) {
        mu += HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_2) {
        mu += SPI;
      } else if (area.value === AREA_ENUM.AREA_3) {
        mu += 1.5 * SPI;
      }

      /* Now compute x, y from mu and nu */
      xy.x = t * Math.cos(mu);
      xy.y = t * Math.sin(mu);
      xy.x = xy.x * this.a + this.x0;
      xy.y = xy.y * this.a + this.y0;

      p.x = xy.x;
      p.y = xy.y;
      return p;
    }

    // QSC inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$26(p) {
      var lp = {lam: 0, phi: 0};
      var mu, nu, cosmu, tannu;
      var tantheta, theta, cosphi, phi;
      var t;
      var area = {value: 0};

      /* de-offset */
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      /* Convert the input x, y to the mu and nu angles as used by QSC.
       * This depends on the area of the cube face. */
      nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
      mu = Math.atan2(p.y, p.x);
      if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
        area.value = AREA_ENUM.AREA_0;
      } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
        area.value = AREA_ENUM.AREA_1;
        mu -= HALF_PI;
      } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
        area.value = AREA_ENUM.AREA_2;
        mu = (mu < 0.0 ? mu + SPI : mu - SPI);
      } else {
        area.value = AREA_ENUM.AREA_3;
        mu += HALF_PI;
      }

      /* Compute phi and theta for the area of definition.
       * The inverse projection is not described in the original paper, but some
       * good hints can be found here (as of 2011-12-14):
       * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
       * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
      t = (SPI / 12) * Math.tan(mu);
      tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
      theta = Math.atan(tantheta);
      cosmu = Math.cos(mu);
      tannu = Math.tan(nu);
      cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
      if (cosphi < -1) {
        cosphi = -1;
      } else if (cosphi > +1) {
        cosphi = +1;
      }

      /* Apply the result to the real area on the cube face.
       * For the top and bottom face, we can compute phi and lam directly.
       * For the other faces, we must use unit sphere cartesian coordinates
       * as an intermediate step. */
      if (this.face === FACE_ENUM.TOP) {
        phi = Math.acos(cosphi);
        lp.phi = HALF_PI - phi;
        if (area.value === AREA_ENUM.AREA_0) {
          lp.lam = theta + HALF_PI;
        } else if (area.value === AREA_ENUM.AREA_1) {
          lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
        } else if (area.value === AREA_ENUM.AREA_2) {
          lp.lam = theta - HALF_PI;
        } else /* area.value == AREA_ENUM.AREA_3 */ {
          lp.lam = theta;
        }
      } else if (this.face === FACE_ENUM.BOTTOM) {
        phi = Math.acos(cosphi);
        lp.phi = phi - HALF_PI;
        if (area.value === AREA_ENUM.AREA_0) {
          lp.lam = -theta + HALF_PI;
        } else if (area.value === AREA_ENUM.AREA_1) {
          lp.lam = -theta;
        } else if (area.value === AREA_ENUM.AREA_2) {
          lp.lam = -theta - HALF_PI;
        } else /* area.value == AREA_ENUM.AREA_3 */ {
          lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
        }
      } else {
        /* Compute phi and lam via cartesian unit sphere coordinates. */
        var q, r, s;
        q = cosphi;
        t = q * q;
        if (t >= 1) {
          s = 0;
        } else {
          s = Math.sqrt(1 - t) * Math.sin(theta);
        }
        t += s * s;
        if (t >= 1) {
          r = 0;
        } else {
          r = Math.sqrt(1 - t);
        }
        /* Rotate q,r,s into the correct area. */
        if (area.value === AREA_ENUM.AREA_1) {
          t = r;
          r = -s;
          s = t;
        } else if (area.value === AREA_ENUM.AREA_2) {
          r = -r;
          s = -s;
        } else if (area.value === AREA_ENUM.AREA_3) {
          t = r;
          r = s;
          s = -t;
        }
        /* Rotate q,r,s into the correct cube face. */
        if (this.face === FACE_ENUM.RIGHT) {
          t = q;
          q = -r;
          r = t;
        } else if (this.face === FACE_ENUM.BACK) {
          q = -q;
          r = -r;
        } else if (this.face === FACE_ENUM.LEFT) {
          t = q;
          q = r;
          r = -t;
        }
        /* Now compute phi and lam from the unit sphere coordinates. */
        lp.phi = Math.acos(-s) - HALF_PI;
        lp.lam = Math.atan2(r, q);
        if (this.face === FACE_ENUM.RIGHT) {
          lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
        } else if (this.face === FACE_ENUM.BACK) {
          lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
        } else if (this.face === FACE_ENUM.LEFT) {
          lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
        }
      }

      /* Apply the shift from the sphere to the ellipsoid as described
       * in [LK12]. */
      if (this.es !== 0) {
        var invert_sign;
        var tanphi, xa;
        invert_sign = (lp.phi < 0 ? 1 : 0);
        tanphi = Math.tan(lp.phi);
        xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
        lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
        if (invert_sign) {
          lp.phi = -lp.phi;
        }
      }

      lp.lam += this.long0;
      p.x = lp.lam;
      p.y = lp.phi;
      return p;
    }

    /* Helper function for forward projection: compute the theta angle
     * and determine the area number. */
    function qsc_fwd_equat_face_theta(phi, y, x, area) {
      var theta;
      if (phi < EPSLN) {
        area.value = AREA_ENUM.AREA_0;
        theta = 0.0;
      } else {
        theta = Math.atan2(y, x);
        if (Math.abs(theta) <= FORTPI) {
          area.value = AREA_ENUM.AREA_0;
        } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_1;
          theta -= HALF_PI;
        } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_2;
          theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta += HALF_PI;
        }
      }
      return theta;
    }

    /* Helper function: shift the longitude. */
    function qsc_shift_lon_origin(lon, offset) {
      var slon = lon + offset;
      if (slon < -SPI) {
        slon += TWO_PI;
      } else if (slon > +SPI) {
        slon -= TWO_PI;
      }
      return slon;
    }

    var names$28 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
    var qsc = {
      init: init$27,
      forward: forward$26,
      inverse: inverse$26,
      names: names$28
    };

    // Robinson projection
    // Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
    // Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039

    var COEFS_X = [
        [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
        [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
        [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
        [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
        [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
        [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
        [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
        [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
        [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
        [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
        [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
        [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
        [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
        [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
        [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
        [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
        [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
        [0.5722, -0.00906601, 0.000182, 6.24051e-06],
        [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
    ];

    var COEFS_Y = [
        [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
        [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
        [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
        [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
        [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
        [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
        [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
        [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
        [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
        [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
        [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
        [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
        [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
        [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
        [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
        [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
        [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
        [0.9761, 0.00616527, -0.000256, -4.2106e-06],
        [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
    ];

    var FXC = 0.8487;
    var FYC = 1.3523;
    var C1 = R2D/5; // rad to 5-degree interval
    var RC1 = 1/C1;
    var NODES = 18;

    var poly3_val = function(coefs, x) {
        return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
    };

    var poly3_der = function(coefs, x) {
        return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
    };

    function newton_rapshon(f_df, start, max_err, iters) {
        var x = start;
        for (; iters; --iters) {
            var upd = f_df(x);
            x -= upd;
            if (Math.abs(upd) < max_err) {
                break;
            }
        }
        return x;
    }

    function init$28() {
        this.x0 = this.x0 || 0;
        this.y0 = this.y0 || 0;
        this.long0 = this.long0 || 0;
        this.es = 0;
        this.title = this.title || "Robinson";
    }

    function forward$27(ll) {
        var lon = adjust_lon(ll.x - this.long0);

        var dphi = Math.abs(ll.y);
        var i = Math.floor(dphi * C1);
        if (i < 0) {
            i = 0;
        } else if (i >= NODES) {
            i = NODES - 1;
        }
        dphi = R2D * (dphi - RC1 * i);
        var xy = {
            x: poly3_val(COEFS_X[i], dphi) * lon,
            y: poly3_val(COEFS_Y[i], dphi)
        };
        if (ll.y < 0) {
            xy.y = -xy.y;
        }

        xy.x = xy.x * this.a * FXC + this.x0;
        xy.y = xy.y * this.a * FYC + this.y0;
        return xy;
    }

    function inverse$27(xy) {
        var ll = {
            x: (xy.x - this.x0) / (this.a * FXC),
            y: Math.abs(xy.y - this.y0) / (this.a * FYC)
        };

        if (ll.y >= 1) { // pathologic case
            ll.x /= COEFS_X[NODES][0];
            ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
        } else {
            // find table interval
            var i = Math.floor(ll.y * NODES);
            if (i < 0) {
                i = 0;
            } else if (i >= NODES) {
                i = NODES - 1;
            }
            for (;;) {
                if (COEFS_Y[i][0] > ll.y) {
                    --i;
                } else if (COEFS_Y[i+1][0] <= ll.y) {
                    ++i;
                } else {
                    break;
                }
            }
            // linear interpolation in 5 degree interval
            var coefs = COEFS_Y[i];
            var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
            // find t so that poly3_val(coefs, t) = ll.y
            t = newton_rapshon(function(x) {
                return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
            }, t, EPSLN, 100);

            ll.x /= poly3_val(COEFS_X[i], t);
            ll.y = (5 * i + t) * D2R;
            if (xy.y < 0) {
                ll.y = -ll.y;
            }
        }

        ll.x = adjust_lon(ll.x + this.long0);
        return ll;
    }

    var names$29 = ["Robinson", "robin"];
    var robin = {
      init: init$28,
      forward: forward$27,
      inverse: inverse$27,
      names: names$29
    };

    function init$29() {
        this.name = 'geocent';

    }

    function forward$28(p) {
        var point = geodeticToGeocentric(p, this.es, this.a);
        return point;
    }

    function inverse$28(p) {
        var point = geocentricToGeodetic(p, this.es, this.a, this.b);
        return point;
    }

    var names$30 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
    var geocent = {
        init: init$29,
        forward: forward$28,
        inverse: inverse$28,
        names: names$30
    };

    var mode = {
      N_POLE: 0,
      S_POLE: 1,
      EQUIT: 2,
      OBLIQ: 3
    };

    var params = {
      h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
      azi:   { def: 0, num: true, degrees: true }, // default is North
      tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
      long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
      lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
    };

    function init$30() {
      Object.keys(params).forEach(function (p) {
        if (typeof this[p] === "undefined") {
          this[p] = params[p].def;
        } else if (params[p].num && isNaN(this[p])) {
          throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
        } else if (params[p].num) {
          this[p] = parseFloat(this[p]);
        }
        if (params[p].degrees) {
          this[p] = this[p] * D2R;
        }
      }.bind(this));

      if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
        this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
      } else if (Math.abs(this.lat0) < EPSLN) {
        this.mode = mode.EQUIT;
      } else {
        this.mode = mode.OBLIQ;
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }

      this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

      if (this.pn1 <= 0 || this.pn1 > 1e10) {
        throw new Error("Invalid height");
      }
      
      this.p = 1 + this.pn1;
      this.rp = 1 / this.p;
      this.h1 = 1 / this.pn1;
      this.pfact = (this.p + 1) * this.h1;
      this.es = 0;

      var omega = this.tilt;
      var gamma = this.azi;
      this.cg = Math.cos(gamma);
      this.sg = Math.sin(gamma);
      this.cw = Math.cos(omega);
      this.sw = Math.sin(omega);
    }

    function forward$29(p) {
      p.x -= this.long0;
      var sinphi = Math.sin(p.y);
      var cosphi = Math.cos(p.y);
      var coslam = Math.cos(p.x);
      var x, y;
      switch (this.mode) {
        case mode.OBLIQ:
          y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
          break;
        case mode.EQUIT:
          y = cosphi * coslam;
          break;
        case mode.S_POLE:
          y = -sinphi;
          break;
        case mode.N_POLE:
          y = sinphi;
          break;
      }
      y = this.pn1 / (this.p - y);
      x = y * cosphi * Math.sin(p.x);

      switch (this.mode) {
        case mode.OBLIQ:
          y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
          break;
        case mode.EQUIT:
          y *= sinphi;
          break;
        case mode.N_POLE:
          y *= -(cosphi * coslam);
          break;
        case mode.S_POLE:
          y *= cosphi * coslam;
          break;
      }

      // Tilt 
      var yt, ba;
      yt = y * this.cg + x * this.sg;
      ba = 1 / (yt * this.sw * this.h1 + this.cw);
      x = (x * this.cg - y * this.sg) * this.cw * ba;
      y = yt * ba;

      p.x = x * this.a;
      p.y = y * this.a;
      return p;
    }

    function inverse$29(p) {
      p.x /= this.a;
      p.y /= this.a;
      var r = { x: p.x, y: p.y };

      // Un-Tilt
      var bm, bq, yt;
      yt = 1 / (this.pn1 - p.y * this.sw);
      bm = this.pn1 * p.x * yt;
      bq = this.pn1 * p.y * this.cw * yt;
      p.x = bm * this.cg + bq * this.sg;
      p.y = bq * this.cg - bm * this.sg;

      var rh = hypot(p.x, p.y);
      if (Math.abs(rh) < EPSLN) {
        r.x = 0;
        r.y = p.y;
      } else {
        var cosz, sinz;
        sinz = 1 - rh * rh * this.pfact;
        sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
        cosz = Math.sqrt(1 - sinz * sinz);
        switch (this.mode) {
          case mode.OBLIQ:
            r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
            p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
            p.x *= sinz * this.cosph0;
            break;
          case mode.EQUIT:
            r.y = Math.asin(p.y * sinz / rh);
            p.y = cosz * rh;
            p.x *= sinz;
            break;
          case mode.N_POLE:
            r.y = Math.asin(cosz);
            p.y = -p.y;
            break;
          case mode.S_POLE:
            r.y = -Math.asin(cosz);
            break;
        }
        r.x = Math.atan2(p.x, p.y);
      }

      p.x = r.x + this.long0;
      p.y = r.y;
      return p;
    }

    var names$31 = ["Tilted_Perspective", "tpers"];
    var tpers = {
      init: init$30,
      forward: forward$29,
      inverse: inverse$29,
      names: names$31
    };

    var includedProjections = function(proj4){
      proj4.Proj.projections.add(tmerc);
      proj4.Proj.projections.add(etmerc);
      proj4.Proj.projections.add(utm);
      proj4.Proj.projections.add(sterea);
      proj4.Proj.projections.add(stere);
      proj4.Proj.projections.add(somerc);
      proj4.Proj.projections.add(omerc);
      proj4.Proj.projections.add(lcc);
      proj4.Proj.projections.add(krovak);
      proj4.Proj.projections.add(cass);
      proj4.Proj.projections.add(laea);
      proj4.Proj.projections.add(aea);
      proj4.Proj.projections.add(gnom);
      proj4.Proj.projections.add(cea);
      proj4.Proj.projections.add(eqc);
      proj4.Proj.projections.add(poly);
      proj4.Proj.projections.add(nzmg);
      proj4.Proj.projections.add(mill);
      proj4.Proj.projections.add(sinu);
      proj4.Proj.projections.add(moll);
      proj4.Proj.projections.add(eqdc);
      proj4.Proj.projections.add(vandg);
      proj4.Proj.projections.add(aeqd);
      proj4.Proj.projections.add(ortho);
      proj4.Proj.projections.add(qsc);
      proj4.Proj.projections.add(robin);
      proj4.Proj.projections.add(geocent);
      proj4.Proj.projections.add(tpers);
    };

    proj4$1.defaultDatum = 'WGS84'; //default datum
    proj4$1.Proj = Projection;
    proj4$1.WGS84 = new proj4$1.Proj('WGS84');
    proj4$1.Point = Point;
    proj4$1.toPoint = toPoint;
    proj4$1.defs = defs;
    proj4$1.nadgrid = nadgrid;
    proj4$1.transform = transform;
    proj4$1.mgrs = mgrs;
    proj4$1.version = '2.7.5';
    includedProjections(proj4$1);

    return proj4$1;

})));


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_proj_transforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(190);
/* harmony import */ var ol_proj_transforms__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_proj_transforms__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_proj_Projection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(191);
/* harmony import */ var ol_proj_Projection__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_proj_Projection__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(141);




var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("CRS");
function register(proj4) {
  var projCodes = Object.keys(proj4.defs);
  logger.trace("proj. codes :", projCodes);
  var len = projCodes.length;
  var i, j;

  for (i = 0; i < len; ++i) {
    var code = projCodes[i];

    if (!Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["get"])(code)) {
      var def = proj4.defs(code);
      Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["addProjection"])(new ol_proj_Projection__WEBPACK_IMPORTED_MODULE_2___default.a({
        code: code,
        axisOrientation: def.axis,
        metersPerUnit: def.to_meter,
        units: def.units
      }));
    }
  }

  for (i = 0; i < len; ++i) {
    var code1 = projCodes[i];
    var proj1 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["get"])(code1);

    for (j = 0; j < len; ++j) {
      var code2 = projCodes[j];
      var proj2 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["get"])(code2);

      if (!Object(ol_proj_transforms__WEBPACK_IMPORTED_MODULE_1__["get"])(code1, code2)) {
        if (proj4.defs[code1] === proj4.defs[code2]) {
          Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["addEquivalentProjections"])([proj1, proj2]);
        } else {
          var transform = proj4(code1, code2);
          Object(ol_proj__WEBPACK_IMPORTED_MODULE_0__["addCoordinateTransforms"])(proj1, proj2, transform.forward, transform.inverse);
        }
      }
    }
  }
}

/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = ol.proj.transforms;

/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = ol.proj.Projection;

/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @private
 * @description
 * Register definition for IGNF, and EPSG CRS.
 * @example
 * Gp.Register.IGNF.AMST63
 *   // return : "+title=Amsterdam 1963 +proj=geocent +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs"
 * Gp.Register.get("IGNF:AMST63")
 *   // same as Gp.Register.IGNF.AMST63
 */
var Register = {
  /**
   * instance already loaded into proj4
   */
  isLoaded: false,

  /**
   * get the definition for a code
   *
   * @param {String} name - ie. EPSG:2154 (Lambert)
   * @returns {Object} definition
   * @example
   * Register.get("EPSG:2154");
   * // "+title=RGF93 / Lambert-93 +proj=lcc +lat_1=49 ..."
   */
  get: function get(name) {
    if (name === "" || name === null || typeof name === "undefined") {
      return;
    }

    var s = name.split(":");

    if (s.length !== 2) {
      return;
    }

    var _register = s[0];
    var _code = s[1];

    if (!this.hasOwnProperty(_register)) {
      return;
    }

    if (!this[_register].hasOwnProperty(_code)) {
      return;
    }

    return this[_register][_code];
  },

  /**
   *  does projection code exist ?
   *
   * @param {String} name - ie. EPSG:2154 (Lambert)
   * @returns {Boolean} true/false
   * @example
   * Register.exist("EPSG:2154"); // true
   */
  exist: function exist(name) {
    if (name === "" || name === null || typeof name === "undefined") {
      return false;
    }

    var s = name.split(":");

    if (s.length !== 2) {
      return false;
    }

    var _register = s[0];
    var _code = s[1];

    if (!this.hasOwnProperty(_register)) {
      return false;
    }

    if (!this[_register].hasOwnProperty(_code)) {
      return false;
    }

    return true;
  },

  /**
   * load all defs to proj4
   * @param {Object} Proj4 - proj4 instance
   */
  load: function load(Proj4) {
    // un flag pour savoir si le chargement est déjà realisé
    // (car ceci peut être couteux !)
    if (!this.isLoaded) {
      var registers = ["IGNF", // exception lors du register IGNF ?
      "EPSG", "CRS"];

      for (var i = 0; i < registers.length; i++) {
        var _register = registers[i];
        var codes = this[_register];

        for (var _code in codes) {
          if (codes.hasOwnProperty(_code)) {
            var name = _register + ":" + _code;
            Proj4.defs(name, this.get(name)); // on enlève la dependance à OpenLayers...
            // la fonction register est donc à appeller afin d'enregistrer
            // les definitions dans OpenLayers :
            //  import { get } from "ol/proj";
            //  import proj4 from "proj4";
            //  import { register } from "ol/proj/proj4";
            //      Register.load();
            //      // Make projections defined in proj4 (with proj4.defs()) available in OpenLayers.
            //      // see ol/proj/proj4.register (https://openlayers.org/en/latest/apidoc/module-ol_proj_proj4.html)
            //      register(proj4);
            //      console.log(get("CRS:84").getCode()); // "CRS:84"
          }
        }
      }

      this.isLoaded = true;
    }
  },

  /**
   * load defs by default to proj4
   *
   * include into proj4 :
   * - WGS84
   * - ['EPSG:4326']
   * - ['EPSG:3785'], ['EPSG:3857'], GOOGLE, ['EPSG:900913'], ['EPSG:102113']
   * +
   * - ["EPSG:2154"], ["EPSG:27571"],  ["EPSG:27572"],  ["EPSG:27573"],  ["EPSG:2757"],
   * - ["CRS:84"],
   * - ["IGNF:LAMB93"],
   * - ["IGNF:LAMBE"], ["IGNF:LAMB1"],  ["IGNF:LAMB2"],  ["IGNF:LAMB3"],  ["IGNF:LAMB4"],
   * - ["IGNF:RGF93G"],
   * - ["IGNF:WGS84G"]
   *
   * @param {Object} Proj4 - proj4 instance
   */
  loadByDefault: function loadByDefault(Proj4) {
    // la liste de projections par defaut...
    var registers = {
      EPSG: {
        2154: Register["EPSG"]["2154"],
        27571: Register["EPSG"]["27571"],
        27572: Register["EPSG"]["27572"],
        27573: Register["EPSG"]["27573"],
        27574: Register["EPSG"]["27574"]
      },
      CRS: {
        84: Register["CRS"]["84"]
      },
      IGNF: {
        LAMB93: Register["IGNF"]["LAMB93"],
        LAMBE: Register["IGNF"]["LAMBE"],
        LAMB1: Register["IGNF"]["LAMB1"],
        LAMB2: Register["IGNF"]["LAMB2"],
        LAMB3: Register["IGNF"]["LAMB3"],
        LAMB4: Register["IGNF"]["LAMB4"],
        RGF93G: Register["IGNF"]["RGF93G"],
        WGS84G: Register["IGNF"]["WGS84G"]
      }
    };

    for (var register in registers) {
      if (registers.hasOwnProperty(register)) {
        var codes = registers[register];

        for (var code in codes) {
          if (codes.hasOwnProperty(code)) {
            var name = register + ":" + code;
            Proj4.defs(name, codes[code]);
          }
        }
      }
    }
  },

  /**
   * load only a def to proj4
   * @param {Object} Proj4 - proj4 instance
   * @param {String} name - ie. EPSG:2154 (Lambert)
   * @returns {Boolean} true/false
   */
  loadByName: function loadByName(Proj4, name) {
    if (!this.exist(name)) {
      return false;
    }

    try {
      Proj4.defs(name, this.get(name));
    } catch (e) {
      // FIXME message !?
      return false;
    }

    return true;
  },
  // definitions
  EPSG: {
    4978: "+proj=geocent +datum=WGS84 +units=m +no_defs ",
    3857: "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs",
    3785: "+title=WGS 84 / Pseudo-Mercator (deprecated) +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs",
    4149: "+title=CH1903 +proj=longlat +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +no_defs ",
    4150: "+title=CH1903plus +proj=longlat +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +no_defs ",
    4151: "+title=CHTRF95 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4171: "+title=RGF93 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4230: "+title=ED50 +proj=longlat +ellps=intl +no_defs ",
    4235: "+title=Guyane Francaise +proj=longlat +ellps=intl +no_defs ",
    4258: "+title=ETRS89 +proj=longlat +ellps=GRS80 +no_defs ",
    4275: "+title=NTF +proj=longlat +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +no_defs ",
    4322: "+title=WGS 72 +proj=longlat +ellps=WGS72 +no_defs ",
    4326: "+title=WGS 84 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ",
    4467: "+proj=utm +zone=21 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    4470: "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4471: "+proj=utm +zone=38 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    4474: "+proj=utm +zone=38 +south +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +units=m +no_defs ",
    4558: "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4559: "+proj=utm +zone=20 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    4621: "+title=Fort Marigot +proj=longlat +ellps=intl +towgs84=137,248,-430,0,0,0,0 +no_defs ",
    4622: "+title=Guadeloupe 1948 +proj=longlat +ellps=intl +no_defs ",
    4623: "+title=CSG67 +proj=longlat +ellps=intl +towgs84=-186,230,110,0,0,0,0 +no_defs ",
    4624: "+title=RGFG95 +proj=longlat +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +no_defs ",
    4625: "+title=Martinique 1938 +proj=longlat +ellps=intl +no_defs ",
    4626: "+title=Reunion 1947 +proj=longlat +ellps=intl +no_defs ",
    4627: "+title=RGR92 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4628: "+title=Tahiti 52 +proj=longlat +ellps=intl +towgs84=162,117,154,0,0,0,0 +no_defs ",
    4629: "+title=Tahaa 54 +proj=longlat +ellps=intl +no_defs ",
    4630: "+title=IGN72 Nuku Hiva +proj=longlat +ellps=intl +no_defs ",
    4632: "+title=Combani 1950 +proj=longlat +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +no_defs ",
    4633: "+title=IGN56 Lifou +proj=longlat +ellps=intl +no_defs ",
    4634: "+title=IGN72 Grand Terre +proj=longlat +ellps=intl +no_defs ",
    4637: "+title=Perroud 1950 +proj=longlat +ellps=intl +towgs84=325,154,172,0,0,0,0 +no_defs ",
    4638: "+title=Saint Pierre et Miquelon 1950 +proj=longlat +ellps=clrk66 +towgs84=30,430,368,0,0,0,0 +no_defs ",
    4640: "+title=RRAF 1991 +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4641: "+title=IGN53 Mare +proj=longlat +ellps=intl +no_defs ",
    4645: "+title=RGNC 1991 +proj=longlat +ellps=intl +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4687: "+proj=longlat +ellps=GRS80 +no_defs ",
    4662: "+title=IGN72 Grande Terre +proj=longlat +ellps=intl +no_defs ",
    4689: "+title=IGN63 Hiva Oa +proj=longlat +ellps=intl +no_defs ",
    4690: "+title=Tahiti 79 +proj=longlat +ellps=intl +no_defs ",
    4691: "+title=Moorea 87 +proj=longlat +ellps=intl +towgs84=215.525,149.593,176.229,-3.2624,-1.692,-1.1571,10.4773 +no_defs ",
    4692: "+title=Maupiti 83 +proj=longlat +ellps=intl +towgs84=217.037,86.959,23.956,0,0,0,0 +no_defs ",
    4698: "+title=IGN 1962 Kerguelen +proj=longlat +ellps=intl +towgs84=145,-187,103,0,0,0,0 +no_defs ",
    4749: "+title=RGNC91-93 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4750: "+title=ST87 Ouvea +proj=longlat +ellps=WGS84 +towgs84=-56.263,16.136,-22.856,0,0,0,0 +no_defs ",
    4807: "+title=NTF (Paris) +proj=longlat +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +no_defs ",
    2056: "+title=CH1903+ / LV95 +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ",
    2154: "+title=RGF93 / Lambert-93 +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2213: "+title=ETRS89 / TM 30 NE +proj=tmerc +lat_0=0 +lon_0=30 +k=0.9996 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs ",
    2969: "+title=Fort Marigot / UTM zone 20N +proj=utm +zone=20 +ellps=intl +towgs84=137,248,-430,0,0,0,0 +units=m +no_defs ",
    2970: "+title=Guadeloupe 1948 / UTM zone 20N +proj=utm +zone=20 +ellps=intl +units=m +no_defs ",
    2971: "+title=CSG67 / UTM zone 22N +proj=utm +zone=22 +ellps=intl +towgs84=-186,230,110,0,0,0,0 +units=m +no_defs ",
    2972: "+title=RGFG95 / UTM zone 22N +proj=utm +zone=22 +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +units=m +no_defs ",
    2973: "+title=Martinique 1938 / UTM zone 20N +proj=utm +zone=20 +ellps=intl +units=m +no_defs ",
    2975: "+title=RGR92 / UTM zone 40S +proj=utm +zone=40 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2976: "+title=Tahiti 52 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +towgs84=162,117,154,0,0,0,0 +units=m +no_defs ",
    2977: "+title=Tahaa 54 / UTM zone 5S +proj=utm +zone=5 +south +ellps=intl +units=m +no_defs ",
    2978: "+title=IGN72 Nuku Hiva / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +units=m +no_defs ",
    2980: "+title=Combani 1950 / UTM zone 38S +proj=utm +zone=38 +south +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +units=m +no_defs ",
    2981: "+title=IGN56 Lifou / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    2982: "+title=IGN72 Grand Terre / UTM zone 58S (deprecated) +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    2984: "+title=RGNC 1991 / Lambert New Caledonia (deprecated) +proj=lcc +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5 +lon_0=166 +x_0=400000 +y_0=300000 +ellps=intl +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2986: "+title=Terre Adelie 1950 +proj=stere +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-90.000000000 +lon_0=140.000000000 +lat_ts=-67.000000000 +k=0.96027295 +x_0=300000.000 +y_0=-2299363.482 +units=m +no_defs",
    2987: "+title=Saint Pierre et Miquelon 1950 / UTM zone 21N +proj=utm +zone=21 +ellps=clrk66 +towgs84=30,430,368,0,0,0,0 +units=m +no_defs ",
    2989: "+title=RRAF 1991 / UTM zone 20N +proj=utm +zone=20 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2990: "+title=Reunion 1947 / TM Reunion (deprecated) +proj=tmerc +lat_0=-21.11666666666667 +lon_0=55.53333333333333 +k=1 +x_0=50000 +y_0=160000 +ellps=intl +units=m +no_defs ",
    2995: "+title=IGN53 Mare / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    3038: "+proj=utm +zone=26 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3039: "+proj=utm +zone=27 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3040: "+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3041: "+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 3042 : "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 3043 : "+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 3044 : "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3045: "+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3046: "+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3047: "+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3048: "+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3049: "+proj=utm +zone=37 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3050: "+proj=utm +zone=38 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3051: "+proj=utm +zone=39 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3034: "+title=ETRS89 / ETRS-LCC +proj=lcc +lat_1=35 +lat_2=65 +lat_0=52 +lon_0=10 +x_0=4000000 +y_0=2800000 +ellps=GRS80 +units=m +no_defs ",
    3035: "+title=ETRS89 / ETRS-LAEA +proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ",
    3042: "+title=ETRS89 / ETRS-TM30 +proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs ",
    3043: "+title=ETRS89 / ETRS-TM31 +proj=utm +zone=31 +ellps=GRS80 +units=m +no_defs ",
    3044: "+title=ETRS89 / ETRS-TM32 +proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs ",
    25828: "+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25829: "+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 25830 : "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 25831 : "+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 25832 : "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25833: "+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25834: "+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25835: "+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25836: "+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25837: "+proj=utm +zone=37 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25838: "+proj=utm +zone=38 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3060: "+title=IGN72 Grande Terre / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    3163: "+title=RGNC91-93 / Lambert New Caledonia +proj=lcc +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5 +lon_0=166 +x_0=400000 +y_0=300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3164: "+title=ST87 Ouvea / UTM zone 58S +proj=utm +zone=58 +south +ellps=WGS84 +towgs84=-56.263,16.136,-22.856,0,0,0,0 +units=m +no_defs ",
    3165: "+title=NEA74 Noumea / Noumea Lambert +proj=lcc +lat_1=-22.24469175 +lat_2=-22.29469175 +lat_0=-22.26969175 +lon_0=166.44242575 +x_0=0.66 +y_0=1.02 +ellps=intl +units=m +no_defs ",
    3166: "+title=NEA74 Noumea / Noumea Lambert 2 +proj=lcc +lat_1=-22.24472222222222 +lat_2=-22.29472222222222 +lat_0=-22.26972222222222 +lon_0=166.4425 +x_0=8.313000000000001 +y_0=-2.354 +ellps=intl +units=m +no_defs ",
    3169: "+title=RGNC91-93 / UTM zone 57S +proj=utm +zone=57 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3170: "+title=RGNC91-93 / UTM zone 58S +proj=utm +zone=58 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3171: "+title=RGNC91-93 / UTM zone 59S +proj=utm +zone=59 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3172: "+title=IGN53 Mare / UTM zone 59S +proj=utm +zone=59 +south +ellps=intl +units=m +no_defs ",
    3296: "+title=RGPF / UTM zone 5S +proj=utm +zone=5 +south +ellps=GRS80 +units=m +no_defs ",
    3297: "+title=RGPF / UTM zone 6S +proj=utm +zone=6 +south +ellps=GRS80 +units=m +no_defs ",
    3298: "+title=RGPF / UTM zone 7S +proj=utm +zone=7 +south +ellps=GRS80 +units=m +no_defs ",
    3299: "+title=RGPF / UTM zone 8S +proj=utm +zone=8 +south +ellps=GRS80 +units=m +no_defs ",
    3302: "+title=IGN63 Hiva Oa / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +units=m +no_defs ",
    3303: "+title=Fatu Iva 72 / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +towgs84=347.103,1078.12,2623.92,-33.8875,70.6773,-9.3943,186.074 +units=m +no_defs ",
    3304: "+title=Tahiti 79 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +units=m +no_defs ",
    3305: "+title=Moorea 87 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +towgs84=215.525,149.593,176.229,-3.2624,-1.692,-1.1571,10.4773 +units=m +no_defs ",
    3306: "+title=Maupiti 83 / UTM zone 5S +proj=utm +zone=5 +south +ellps=intl +towgs84=217.037,86.959,23.956,0,0,0,0 +units=m +no_defs ",
    3312: "+title=CSG67 / UTM zone 21N +proj=utm +zone=21 +ellps=intl +towgs84=-186,230,110,0,0,0,0 +units=m +no_defs ",
    3313: "+title=RGFG95 / UTM zone 21N +proj=utm +zone=21 +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +units=m +no_defs ",
    3336: "+title=IGN 1962 Kerguelen / UTM zone 42S +proj=utm +zone=42 +south +ellps=intl +towgs84=145,-187,103,0,0,0,0 +units=m +no_defs ",
    3395: "+title=WGS 84 / World Mercator +proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    3727: "+title=Reunion 1947 / TM Reunion +proj=tmerc +lat_0=-21.11666666666667 +lon_0=55.53333333333333 +k=1 +x_0=160000 +y_0=50000 +ellps=intl +units=m +no_defs ",
    21781: "+title=CH1903 / LV03 +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ",
    25830: "+title=ETRS89 / UTM zone 30N +proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs ",
    25831: "+title=ETRS89 / UTM zone 31N +proj=utm +zone=31 +ellps=GRS80 +units=m +no_defs ",
    25832: "+title=ETRS89 / UTM zone 32N +proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs ",
    27561: "+title=NTF (Paris) / Lambert Nord France +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27562: "+title=NTF (Paris) / Lambert Centre France +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27563: "+title=NTF (Paris) / Lambert Sud France +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27564: "+title=NTF (Paris) / Lambert Corse +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27571: "+title=NTF (Paris) / Lambert zone I +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=1200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27572: "+title=NTF (Paris) / Lambert zone II +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27573: "+title=NTF (Paris) / Lambert zone III +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=3200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27574: "+title=NTF (Paris) / Lambert zone IV +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=4185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27581: "+title=NTF (Paris) / France I (deprecated) +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=1200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27582: "+title=NTF (Paris) / France II (deprecated) +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27583: "+title=NTF (Paris) / France III (deprecated) +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=3200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27584: "+title=NTF (Paris) / France IV (deprecated) +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=4185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27591: "+title=NTF (Paris) / Nord France (deprecated) +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27592: "+title=NTF (Paris) / Centre France (deprecated) +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27593: "+title=NTF (Paris) / Sud France (deprecated) +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27594: "+title=NTF (Paris) / Corse (deprecated) +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    32601: "+proj=utm +zone=1 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32602: "+proj=utm +zone=2 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32603: "+proj=utm +zone=3 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32604: "+proj=utm +zone=4 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32605: "+proj=utm +zone=5 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32606: "+proj=utm +zone=6 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32607: "+proj=utm +zone=7 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32608: "+proj=utm +zone=8 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32609: "+proj=utm +zone=9 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32610: "+proj=utm +zone=10 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32611: "+proj=utm +zone=11 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32612: "+proj=utm +zone=12 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32613: "+proj=utm +zone=13 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32614: "+proj=utm +zone=14 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32615: "+proj=utm +zone=15 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32616: "+proj=utm +zone=16 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32617: "+proj=utm +zone=17 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32618: "+proj=utm +zone=18 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32619: "+proj=utm +zone=19 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32620: "+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32621: "+proj=utm +zone=21 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32622: "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32623: "+proj=utm +zone=23 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32624: "+proj=utm +zone=24 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32625: "+proj=utm +zone=25 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32626: "+proj=utm +zone=26 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32627: "+proj=utm +zone=27 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32628: "+proj=utm +zone=28 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32629: "+proj=utm +zone=29 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32630: "+proj=utm +zone=30 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32631: "+proj=utm +zone=31 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32632: "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32633: "+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32634: "+proj=utm +zone=34 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32635: "+proj=utm +zone=35 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32636: "+proj=utm +zone=36 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32637: "+proj=utm +zone=37 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32638: "+proj=utm +zone=38 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32639: "+proj=utm +zone=39 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32640: "+proj=utm +zone=40 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32641: "+proj=utm +zone=41 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32642: "+proj=utm +zone=42 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32643: "+proj=utm +zone=43 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32644: "+proj=utm +zone=44 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32645: "+proj=utm +zone=45 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32646: "+proj=utm +zone=46 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32647: "+proj=utm +zone=47 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32648: "+proj=utm +zone=48 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32649: "+proj=utm +zone=49 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32650: "+proj=utm +zone=50 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32651: "+proj=utm +zone=51 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32652: "+proj=utm +zone=52 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32653: "+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32654: "+proj=utm +zone=54 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32655: "+proj=utm +zone=55 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32656: "+proj=utm +zone=56 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32657: "+proj=utm +zone=57 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32658: "+proj=utm +zone=58 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32659: "+proj=utm +zone=59 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32660: "+proj=utm +zone=60 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32661: "+proj=stere +lat_0=90 +lat_ts=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32662: "+title=WGS 84 / Plate Carree +proj=eqc +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32701: "+proj=utm +zone=1 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32702: "+proj=utm +zone=2 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32703: "+proj=utm +zone=3 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32704: "+proj=utm +zone=4 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32705: "+proj=utm +zone=5 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32706: "+proj=utm +zone=6 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32707: "+proj=utm +zone=7 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32708: "+proj=utm +zone=8 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32709: "+proj=utm +zone=9 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32710: "+proj=utm +zone=10 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32711: "+proj=utm +zone=11 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32712: "+proj=utm +zone=12 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32713: "+proj=utm +zone=13 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32714: "+proj=utm +zone=14 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32715: "+proj=utm +zone=15 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32716: "+proj=utm +zone=16 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32717: "+proj=utm +zone=17 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32718: "+proj=utm +zone=18 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32719: "+proj=utm +zone=19 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32720: "+proj=utm +zone=20 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32721: "+proj=utm +zone=21 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32722: "+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32723: "+proj=utm +zone=23 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32724: "+proj=utm +zone=24 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32725: "+proj=utm +zone=25 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32726: "+proj=utm +zone=26 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32727: "+proj=utm +zone=27 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32728: "+proj=utm +zone=28 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32729: "+proj=utm +zone=29 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32730: "+proj=utm +zone=30 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32731: "+proj=utm +zone=31 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32732: "+proj=utm +zone=32 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32733: "+proj=utm +zone=33 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32734: "+proj=utm +zone=34 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32735: "+proj=utm +zone=35 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32736: "+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32737: "+proj=utm +zone=37 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32738: "+proj=utm +zone=38 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32739: "+proj=utm +zone=39 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32740: "+proj=utm +zone=40 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32741: "+proj=utm +zone=41 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32742: "+proj=utm +zone=42 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32743: "+proj=utm +zone=43 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32744: "+proj=utm +zone=44 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32745: "+proj=utm +zone=45 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32746: "+proj=utm +zone=46 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32747: "+proj=utm +zone=47 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32748: "+proj=utm +zone=48 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32749: "+proj=utm +zone=49 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32750: "+proj=utm +zone=50 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32751: "+proj=utm +zone=51 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32752: "+proj=utm +zone=52 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32753: "+proj=utm +zone=53 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32754: "+proj=utm +zone=54 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32755: "+proj=utm +zone=55 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32756: "+proj=utm +zone=56 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32757: "+proj=utm +zone=57 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32758: "+proj=utm +zone=58 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32759: "+proj=utm +zone=59 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32760: "+proj=utm +zone=60 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32761: "+proj=stere +lat_0=-90 +lat_ts=-90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    310024802: "+title=Geoportail - France metropolitaine +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=46.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310915814: "+title=Geoportail - Antilles francaises +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310486805: "+title=Geoportail - Guyane +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=4.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310700806: "+title=Geoportail - Reunion et dependances +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-21.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310702807: "+title=Geoportail - Mayotte +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-12.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310706808: "+title=Geoportail - Saint-Pierre et Miquelon +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=47.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310547809: "+title=Geoportail - Nouvelle-Caledonie +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-22.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642810: "+title=Geoportail - Wallis et Futuna +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.000000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-14.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310032811: "+title=Geoportail - Polynesie francaise +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642812: "+title=Geoportail - Kerguelen +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-49.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642801: "+title=Geoportail - Crozet +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-46.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642813: "+title=Geoportail - Amsterdam et Saint-Paul +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-38.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642901: "+title=Geoportail - Monde +proj=mill +towgs84=0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.000000 +a=6378137.0000 +rf=298.2572221010000 +lon_0=0.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    5489: "+title=RGAF09 geographiques (dms) +proj=longlat +nadgrids=@null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137 +rf=298.257222101 +units=m +no_defs",
    5490: "+title=RGAF09 UTM Nord Fuseau 20 +proj=tmerc +nadgrids=@null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137 +rf=298.257222101 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs"
  },
  CRS: {
    84: "+title=WGS 84 longitude-latitude +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "
  },
  IGNF: {
    AMST63: "+title=Amsterdam 1963 +proj=geocent +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CROZ63: "+title=Crozet 1963 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CSG67: "+title=Guyane CSG67 +proj=geocent +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    ED50: "+title=ED50 +proj=geocent +towgs84=-84.0000,-97.0000,-117.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    ETRS89: "+title=Systeme de reference terrestre Europeen (1989) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    GUAD48: "+title=Guadeloupe Ste Anne +proj=geocent +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    GUADFM49: "+title=Guadeloupe Fort Marigot +proj=geocent +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN63: "+title=IGN 1963 (Hiva Oa, Tahuata, Mohotani) +proj=geocent +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN72: "+title=IGN 1972 Grande-Terre / Ile des Pins +proj=geocent +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    KERG62CAR: "+title=Kerguelen - K0 +proj=geocent +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MART38: "+title=Martinique Fort-Desaix +proj=geocent +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MAYO50: "+title=Mayotte Combani +proj=geocent +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MOOREA87: "+title=Moorea 1987 +proj=geocent +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    NTF: "+title=Nouvelle Triangulation Francaise +proj=geocent +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +units=m +no_defs",
    NUKU72: "+title=IGN 1972 Nuku Hiva +proj=geocent +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    REUN47: "+title=Reunion 1947 +proj=geocent +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    RGF93: "+title=Reseau geodesique francais 1993 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGFG95: "+title=Reseau geodesique francais de Guyane 1995 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGM04: "+title=RGM04 (Reseau Geodesique de Mayotte 2004) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGNC: "+title=Reseau Geodesique de Nouvelle-Caledonie +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGPF: "+title=RGPF (Reseau Geodesique de Polynesie Francaise) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGR92: "+title=Reseau geodesique Reunion 1992 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGSPM06: "+title=Reseau Geodesique Saint-Pierre-et-Miquelon (2006) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGTAAF07: "+title=Reseau Geodesique des TAAF (2007) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RRAF91: "+title=RRAF 1991 (Reseau de Reference des Antilles Francaises) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    STPL69: "+title=Saint-Paul 1969 +proj=geocent +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    STPM50: "+title=St Pierre et Miquelon 1950 +proj=geocent +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +units=m +no_defs",
    TAHAA: "+title=Raiatea - Tahaa 51-54 (Tahaa, Base Terme Est) +proj=geocent +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TAHI79: "+title=IGN79 (Tahiti) Iles de la Societe +proj=geocent +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TERA50: "+title=Pointe Geologie - Perroud 1950 +proj=geocent +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WALL78: "+title=Wallis-Uvea 1978 (MOP78) +proj=geocent +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WGS72: "+title=World Geodetic System 1972 +proj=geocent +towgs84=0.0000,12.0000,6.0000 +a=6378135.0000 +rf=298.2600000000000 +units=m +no_defs",
    WGS84: "+title=World Geodetic System 1984 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    AMST63GEO: "+title=Amsterdam 1963 +proj=longlat +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CROZ63GEO: "+title=Crozet 1963 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CSG67GEO: "+title=Guyane CSG67 +proj=longlat +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    ED50G: "+title=ED50 +proj=longlat +towgs84=-84.0000,-97.0000,-117.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    GUAD48GEO: "+title=Guadeloupe Ste Anne +proj=longlat +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    GUADFM49GEO: "+title=Guadeloupe Fort Marigot +proj=longlat +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN63GEO: "+title=IGN 1963 (Hiva Oa, Tahuata, Mohotani) +proj=longlat +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN72GEO: "+title=IGN 1972 Grande-Terre / Ile des Pins +proj=longlat +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    KERG62GEO: "+title=Kerguelen - K0 +proj=longlat +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MART38GEO: "+title=Martinique Fort-Desaix +proj=longlat +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MAYO50GEO: "+title=Mayotte Combani +proj=longlat +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MOOREA87GEO: "+title=Moorea 1987 +proj=longlat +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    NTFG: "+title=Nouvelle Triangulation Francaise Greenwich degres sexagesimaux +proj=longlat +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +units=m +no_defs",
    NTFP: "+title=Nouvelle Triangulation Francaise Paris grades +proj=longlat +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +units=m +no_defs",
    NUKU72GEO: "+title=IGN 1972 Nuku Hiva +proj=longlat +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    REUN47GEO: "+title=Reunion 1947 +proj=longlat +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    RGF93G: "+title=Reseau geodesique francais 1993 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGFG95GEO: "+title=Reseau geodesique francais de Guyane 1995 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGM04GEO: "+title=RGM04 (Reseau Geodesique de Mayotte 2004) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGNCGEO: "+title=Reseau Geodesique de Nouvelle-Caledonie +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGPFGEO: "+title=RGPF (Reseau Geodesique de Polynesie Francaise) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGR92GEO: "+title=Reseau geodesique de la Reunion 1992 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGSPM06GEO: "+title=Saint-Pierre-et-Miquelon (2006) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGTAAF07G: "+title=Reseau Geodesique des TAAF (2007) (dms) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    STPL69GEO: "+title=Saint-Paul 1969 +proj=longlat +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    STPM50GEO: "+title=St Pierre et Miquelon 1950  +proj=longlat +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +units=m +no_defs",
    TAHAAGEO: "+title=Raiatea - Tahaa 51-54 (Tahaa, Base Terme Est) +proj=longlat +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TAHI79GEO: "+title=IGN79 (Tahiti) Iles de la Societe +proj=longlat +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TERA50G: "+title=Pointe Geologie - Perroud 1950 +proj=longlat +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WALL78GEO: "+title=Wallis - Uvea 1978 (MOP78) +proj=longlat +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WGS72G: "+title=WGS72 +proj=longlat +towgs84=0.0000,12.0000,6.0000 +a=6378135.0000 +rf=298.2600000000000 +units=m +no_defs",
    WGS84G: "+title=World Geodetic System 1984 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    WGS84RRAFGEO: "+title=Reseau de reference des Antilles francaises (1988-1991) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    XGEO: "+title=Systeme CIO-BIH +proj=longlat +towgs84=0.0000,0.0000,0.5000,0.0000,0.0000,0.0140,-0.100000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    AMST63UTM43S: "+title=Amsterdam 1963 UTM fuseau 43 Sud +proj=tmerc +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    CROZ63UTM39S: "+title=Crozet 1963 +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    CSG67UTM21: "+title=Guyane CSG67 UTM fuseau 21 +proj=tmerc +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    CSG67UTM22: "+title=Guyane CSG67 UTM fuseau 22 +proj=tmerc +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALANF: "+title=Geoportail - Antilles francaises +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALASP: "+title=Geoportail - Amsterdam et Saint-Paul +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-38.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALCRZ: "+title=Geoportail - Crozet +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-46.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALFXX: "+title=Geoportail - France metropolitaine +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=46.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALGUF: "+title=Geoportail - Guyane +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=4.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALKER: "+title=Geoportail - Kerguelen +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-49.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALMYT: "+title=Geoportail - Mayotte +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-12.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALNCL: "+title=Geoportail - Nouvelle-Caledonie +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-22.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALPYF: "+title=Geoportail - Polynesie francaise +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALREU: "+title=Geoportail - Reunion et dependances +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-21.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALSPM: "+title=Geoportail - Saint-Pierre et Miquelon +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=47.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALWLF: "+title=Geoportail - Wallis et Futuna +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-14.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GUAD48UTM20: "+title=Guadeloupe Ste Anne +proj=tmerc +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    GUADFM49U20: "+title=Guadeloupe Fort Marigot  +proj=tmerc +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    IGN63UTM7S: "+title=IGN 1963 - Hiva Oa, Tahuata, Mohotani - UTM fuseau 7 Sud +proj=tmerc +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    IGN72UTM58S: "+title=IGN 1972 - UTM fuseau 58 Sud +proj=tmerc +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=165.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    KERG62UTM42S: "+title=Kerguelen 1962 +proj=tmerc +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=69.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    LAMB1: "+title=Lambert I +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=49.500000000 +lon_0=0.000000000 +k_0=0.99987734 +lat_1=49.500000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs",
    LAMB1C: "+title=Lambert I Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=49.500000000 +lon_0=0.000000000 +k_0=0.99987734 +lat_1=49.500000000 +x_0=600000.000 +y_0=1200000.000 +units=m +no_defs",
    LAMB2: "+title=Lambert II +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs",
    LAMB2C: "+title=Lambert II Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=2200000.000 +units=m +no_defs",
    LAMB3: "+title=Lambert III +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=44.100000000 +lon_0=0.000000000 +k_0=0.99987750 +lat_1=44.100000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs",
    LAMB3C: "+title=Lambert III Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=44.100000000 +lon_0=0.000000000 +k_0=0.99987750 +lat_1=44.100000000 +x_0=600000.000 +y_0=3200000.000 +units=m +no_defs",
    LAMB4: "+title=Lambert IV +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=42.165000000 +lon_0=0.000000000 +k_0=0.99994471 +lat_1=42.165000000 +x_0=234.358 +y_0=185861.369 +units=m +no_defs",
    LAMB4C: "+title=Lambert IV Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=42.165000000 +lon_0=0.000000000 +k_0=0.99994471 +lat_1=42.165000000 +x_0=234.358 +y_0=4185861.369 +units=m +no_defs",
    LAMB93: "+title=Lambert 93 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=46.500000000 +lon_0=3.000000000 +lat_1=44.000000000 +lat_2=49.000000000 +x_0=700000.000 +y_0=6600000.000 +units=m +no_defs",
    RGF93CC42: "+title=Lambert conique conforme Zone 1 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=42.000000000 +lon_0=3.000000000 +lat_1=41.200000000 +lat_2=42.800000000 +x_0=1700000.000 +y_0=1200000.000 +units=m +no_defs",
    RGF93CC43: "+title=Lambert conique conforme Zone 2 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=43.000000000 +lon_0=3.000000000 +lat_1=42.200000000 +lat_2=43.800000000 +x_0=1700000.000 +y_0=2200000.000 +units=m +no_defs",
    RGF93CC44: "+title=Lambert conique conforme Zone 3 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=44.000000000 +lon_0=3.000000000 +lat_1=43.200000000 +lat_2=44.800000000 +x_0=1700000.000 +y_0=3200000.000 +units=m +no_defs",
    RGF93CC45: "+title=Lambert conique conforme Zone 4 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=45.000000000 +lon_0=3.000000000 +lat_1=44.200000000 +lat_2=45.800000000 +x_0=1700000.000 +y_0=4200000.000 +units=m +no_defs",
    RGF93CC46: "+title=Lambert conique conforme Zone 5 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=46.000000000 +lon_0=3.000000000 +lat_1=45.200000000 +lat_2=46.800000000 +x_0=1700000.000 +y_0=5200000.000 +units=m +no_defs",
    RGF93CC47: "+title=Lambert conique conforme Zone 6 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=47.000000000 +lon_0=3.000000000 +lat_1=46.200000000 +lat_2=47.800000000 +x_0=1700000.000 +y_0=6200000.000 +units=m +no_defs",
    RGF93CC48: "+title=Lambert conique conforme Zone 7 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=48.000000000 +lon_0=3.000000000 +lat_1=47.200000000 +lat_2=48.800000000 +x_0=1700000.000 +y_0=7200000.000 +units=m +no_defs",
    RGF93CC49: "+title=Lambert conique conforme Zone 8 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=49.000000000 +lon_0=3.000000000 +lat_1=48.200000000 +lat_2=49.800000000 +x_0=1700000.000 +y_0=8200000.000 +units=m +no_defs",
    RGF93CC50: "+title=Lambert conique conforme Zone 9 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=50.000000000 +lon_0=3.000000000 +lat_1=49.200000000 +lat_2=50.800000000 +x_0=1700000.000 +y_0=9200000.000 +units=m +no_defs",
    LAMBE: "+title=Lambert II etendu +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=2200000.000 +units=m +no_defs",
    MART38UTM20: "+title=Martinique Fort-Desaix +proj=tmerc +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    MAYO50UTM38S: "+title=Mayotte Combani +proj=tmerc +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    MILLER: "+title=Geoportail - Monde +proj=mill +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lon_0=0.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    MOOREA87U6S: "+title=Moorea 1987 - UTM fuseau 6 Sud +proj=tmerc +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    NUKU72U7S: "+title=IGN 1972 Nuku Hiva - UTM fuseau 7 Sud +proj=tmerc +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    // REUN47GAUSSL : "+title=Reunion Gauss Laborde +proj=gstmerc +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-21.116666667 +lon_0=55.533333333 +k_0=1.00000000 +x_0=160000.000 +y_0=50000.000 +units=m +no_defs",
    RGM04UTM38S: "+title=UTM fuseau 38 Sud (Reseau Geodesique de Mayotte 2004) +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGNCUTM57S: "+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 57 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=159.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGNCUTM58S: "+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 58 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=165.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGNCUTM59S: "+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 59 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=171.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGPFUTM5S: "+title=RGPF - UTM fuseau 5 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-153.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGPFUTM6S: "+title=RGPF - UTM fuseau 6 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGPFUTM7S: "+title=RGPF - UTM fuseau 7 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGR92UTM40S: "+title=RGR92 UTM fuseau 40 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGSPM06U21: "+title=Saint-Pierre-et-Miquelon (2006) UTM Fuseau 21 Nord +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    STPL69UTM43S: "+title=Saint-Paul 1969 UTM fuseau 43 Sud +proj=tmerc +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    STPM50UTM21: "+title=St Pierre et Miquelon 1950 +proj=tmerc +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    TAHAAUTM05S: "+title=Tahaa 1951 +proj=tmerc +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-153.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    TAHI51UTM06S: "+title=Tahiti-Terme Nord UTM fuseau 6 Sud +proj=tmerc +towgs84=162.0000,117.0000,154.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    TAHI79UTM6S: "+title=Tahiti 1979 +proj=tmerc +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    TERA50STEREO: "+title=Terre Adelie 1950 +proj=stere +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-90.000000000 +lon_0=140.000000000 +lat_ts=-67 +k=0.96027295 +x_0=300000.000 +y_0=-2299363.482 +units=m +no_defs",
    UTM01SW84: "+title=World Geodetic System 1984 UTM fuseau 01 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-177.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    UTM20W84GUAD: "+title=World Geodetic System 1984 UTM fuseau 20 Nord-Guadeloupe +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM20W84MART: "+title=World Geodetic System 1984 UTM fuseau 20 Nord-Martinique +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM22RGFG95: "+title=RGFG95 UTM fuseau 22 Nord-Guyane +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM39SW84: "+title=World Geodetic System 1984 UTM fuseau 39 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    UTM42SW84: "+title=World Geodetic System 1984 UTM fuseau 42 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=69.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    UTM43SW84: "+title=World Geodetic System 1984 UTM fuseau 43 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    WALL78UTM1S: "+title=Wallis-Uvea 1978 (MOP78) UTM 1 SUD +proj=tmerc +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-177.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    ETRS89GEO: "+title=ETRS89 geographiques (dms) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    ETRS89LAEA: "+title=ETRS89 Lambert Azimutal Equal Area +proj=laea +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=52.000000000 +lon_0=10.000000000 +x_0=4321000.000 +y_0=3210000.000 +units=m +no_defs",
    ETRS89LCC: "+title=ETRS89 Lambert Conformal Conic +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=52.000000000 +lon_0=9.999999995 +lat_1=35.000000000 +lat_2=65.000000000 +x_0=4000000.000 +y_0=2800000.000 +units=m +no_defs",
    UTM26ETRS89: "+title=Europe - de 30d a 24d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-27.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM27ETRS89: "+title=Europe - de 24d a 18d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-21.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM28ETRS89: "+title=Europe - de 18d a 12d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-15.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM29ETRS89: "+title=Europe - de 12d a 6d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-9.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM30ETRS89: "+title=Europe - de -6d a 0d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-3.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM31ETRS89: "+title=Europe - de 0d a 6d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=3.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM32ETRS89: "+title=Europe - de 6d a 12d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=9.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM33ETRS89: "+title=Europe - de 12d a 18d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=15.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM34ETRS89: "+title=Europe - de 18d a 24d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=21.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM35ETRS89: "+title=Europe - de 24d a 30d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=27.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM36ETRS89: "+title=Europe - de 30d a 36d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=33.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM37ETRS89: "+title=Europe - de 36d a 42d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=39.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM38ETRS89: "+title=Europe - de 42d a 48d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs"
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Register);

/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var MousePositionDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmousePosition");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMousePositionElement: function _createShowMousePositionElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowMousePosition");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show mouse position control
   * @param {Boolean} isDesktop - specifies if the support is desktop or tactile
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMousePositionPictoElement: function _createShowMousePositionPictoElement(isDesktop) {
    // contexte d'execution
    var self = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowMousePositionPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowMousePosition");
    label.title = "Afficher les coordonnées du curseur"; // FIXME detection disponible dans le JS !
    // Detection : test for desktop or tactile
    // var isDesktop = true;
    // var userAgent = window.navigator.userAgent.toLowerCase();
    // if (userAgent.indexOf("iphone") !== -1 ||
    // userAgent.indexOf("ipod") !== -1 ||
    // userAgent.indexOf("ipad") !== -1 ||
    // userAgent.indexOf("android") !== -1 ||
    // userAgent.indexOf("mobile") !== -1 ||
    // userAgent.indexOf("blackberry") !== -1 ||
    // userAgent.indexOf("tablet") !== -1 ||
    // userAgent.indexOf("phone") !== -1 ||
    // userAgent.indexOf("touch") !== -1 ) {
    //     isDesktop = false;
    // }
    // if (userAgent.indexOf("msie") !== -1 ||
    // userAgent.indexOf("trident") !== -1) {
    //     isDesktop = true;
    // }
    // Show map center localisation if panel opened and tactile support

    label.addEventListener("click", function (e) {
      var mapCenterClass = "";

      if (!document.getElementById(self._addUID("GPshowMousePosition")).checked && !isDesktop) {
        mapCenterClass = "GPmapCenterVisible";
      }

      document.getElementById("GPmapCenter").className = mapCenterClass;
      self.onShowMousePositionClick(e);
    });
    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowMousePositionOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },

  /**
   * mouse position panel
   *
   * @returns {DOMElement} DOM element
   */
  _createMousePositionPanelElement: function _createMousePositionPanelElement() {
    var panel = document.createElement("div");
    panel.id = this._addUID("GPmousePositionPanel");
    panel.className = "GPpanel"; // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // div.appendChild(this._createMousePositionPanelHeaderElement());
    // div.appendChild(this._createMousePositionPanelBasicElement());
    // div.appendChild(this._createShowMousePositionSettingsElement());
    // div.appendChild(this._createMousePositionSettingsElement());

    return panel;
  },

  /**
   * Map center localisation (tactile use)
   *
   * @returns {DOMElement} container
   */
  _createMapCenter: function _createMapCenter() {
    var div = document.createElement("div");
    div.id = "GPmapCenter";
    div.className = "";
    return div;
  },
  // ################################################################### //
  // ####################### Panel container ########################### //
  // ################################################################### //

  /**
   * @returns {DOMElement} container
   */
  _createMousePositionPanelHeaderElement: function _createMousePositionPanelHeaderElement() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle";
    divTitle.innerHTML = "Coordonnées";
    container.appendChild(divTitle);
    var divClose = document.createElement("div");
    divClose.id = "GPmousePositionPanelClose";
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer le panneau"; // Link panel close / visibility checkbox

    var self = this;

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowMousePositionPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowMousePositionPicto")).click();
      });
    }

    container.appendChild(divClose);
    return container;
  },

  /**
   * coordinate panel
   * @param {Boolean} [displayAltitude] - specifies if the altitude panel must be displayed
   * @param {Boolean} [displayCoordinates] - specifies if the coordinates panel must be displayed
   * @param {Boolean} [editCoordinates] - specifies if the coordinates edition is allowed
   * @param {Boolean} [currentProjectionUnits] - specifies if the current projection units
   *
   * FIXME
   * call this._createMousePositionPanelBasicCoordinateElement
   * call this._createMousePositionPanelBasicAltitudeElement
   *
   * @returns {DOMElement} DOM element
   */
  _createMousePositionPanelBasicElement: function _createMousePositionPanelBasicElement(displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits) {
    // default Values
    displayAltitude = typeof displayAltitude === "undefined" ? true : displayAltitude;
    displayCoordinates = typeof displayCoordinates === "undefined" ? true : displayCoordinates;
    editCoordinates = typeof editCoordinates === "undefined" ? false : editCoordinates;
    var container = document.createElement("div");
    container.id = this._addUID("GPmousePositionBasicPanel"); // FIXME on devrait decomposer la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...

    container.appendChild(this._createMousePositionPanelBasicCoordinateElement(displayCoordinates, editCoordinates, currentProjectionUnits));
    container.appendChild(this._createMousePositionPanelEditToolsElement(editCoordinates));
    container.appendChild(this._createMousePositionPanelBasicAltitudeElement(displayAltitude));
    return container;
  },

  /**
   * create coordinate elements
   *
   * @param {String} coordType - ("Lon" ou "Lat")
   * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed
   *
   * @returns {Array} list of DOM elements
   */
  _createCoordinateElement: function _createCoordinateElement(coordType, editCoordinates) {
    var context = this;

    if (["Lon", "Lat"].indexOf(coordType) === -1) {
      return [];
    }

    var list = [];
    var input = document.createElement("input");
    input.id = this._addUID("GPmousePosition" + coordType);
    input.title = editCoordinates === true ? "Cliquer pour saisir des coordonnées" : "";
    input.readOnly = true;

    if (editCoordinates) {
      input.addEventListener("click", function () {
        context.onMousePositionEditModeClick(true);
      });
      input.addEventListener("change", function (e) {
        this.classList.remove("error");
        var valid = context.validateExtentCoordinate(coordType, this.value, e);
        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }

    list.push(input);
    var span = document.createElement("span");
    span.className = "GPmousePositionUnits";
    list.push(span);
    return list;
  },

  /**
   *
   * @param {String} coordType - ("Lon" ou "Lat")
   * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed
   *
   * @returns {Array} list of DOM elements
   */
  _createDMSCoordinateElement: function _createDMSCoordinateElement(coordType, editCoordinates) {
    if (["Lon", "Lat"].indexOf(coordType) === -1) {
      return [];
    }

    var context = this;
    var list = [];
    var input = document.createElement("input");
    input.id = this._addUID("GPmousePosition" + coordType + "Degrees");
    input.className = "GPSexagesimal";
    input.setAttribute("name", "degrees");
    input.title = editCoordinates === true ? "Cliquer pour saisir des coordonnées" : "";
    input.readOnly = true;
    input.dataset.min = 0;
    input.dataset.max = coordType === "Lon" ? 180 : 90;

    if (editCoordinates) {
      input.addEventListener("click", function () {
        context.onMousePositionEditModeClick(true);
      });
      input.addEventListener("change", function () {
        this.classList.remove("error");

        var valid = context._checkDMSDegrees(coordType, this);

        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }

    list.push(input);
    var span = document.createElement("span");
    span.className = "GPmousePositionSexagesimalLabel";
    span.innerHTML = "°";
    list.push(span);
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPmousePosition" + coordType + "Minutes");
    input1.className = "GPSexagesimal";
    input1.setAttribute("name", "minutes");
    input1.title = editCoordinates === true ? "Cliquer pour saisir des coordonnées" : "";
    input1.readOnly = true;
    input1.dataset.min = 0;
    input1.dataset.max = 59;

    if (editCoordinates) {
      input1.addEventListener("click", function () {
        context.onMousePositionEditModeClick(true);
      });
      input1.addEventListener("change", function () {
        this.classList.remove("error");

        var valid = context._checkDMSElement(this);

        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }

    list.push(input1);
    var span1 = document.createElement("span");
    span1.className = "GPmousePositionSexagesimalLabel";
    span1.innerHTML = "'";
    list.push(span1);
    var input2 = document.createElement("input");
    input2.id = this._addUID("GPmousePosition" + coordType + "Seconds");
    input2.className = "GPSexagesimalsec";
    input2.setAttribute("name", "seconds");
    input2.title = editCoordinates === true ? "Cliquer pour saisir des coordonnées" : "";
    input2.readOnly = true;
    input2.dataset.min = 0;
    input2.dataset.max = 59;

    if (editCoordinates) {
      input2.addEventListener("click", function () {
        context.onMousePositionEditModeClick(true);
      });
      input2.addEventListener("change", function () {
        this.classList.remove("error");

        var valid = context._checkDMSElement(this, true);

        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }

    list.push(input2);
    var span2 = document.createElement("span");
    span2.className = "GPmousePositionSexagesimalLabel";
    span2.innerHTML = "''";
    list.push(span2);
    var select = document.createElement("select");
    select.id = this._addUID("GPmousePosition" + coordType + "Direction");
    select.className = "GPmousePositionDirection";
    select.setAttribute("name", "direction");
    select.disabled = true;
    var option = document.createElement("option");
    option.value = coordType === "Lon" ? "E" : "N";
    option.innerHTML = coordType === "Lon" ? "E" : "N";
    select.appendChild(option);
    var option1 = document.createElement("option");
    option1.value = coordType === "Lon" ? "O" : "S";
    option1.innerHTML = coordType === "Lon" ? "O" : "S";
    select.appendChild(option1);
    list.push(select);
    return list;
  },

  /**
   * @param {Boolean} [display=false] - specifies if the coordinates panel must be displayed
   * @param {Boolean} [editCoordinates] - specifies if the coordinates edition is allowed
   * @param {Boolean} [currentProjectionUnits] - specifies if the current projection units
   *
   * @returns {DOMElement} container
   */
  _createMousePositionPanelBasicCoordinateElement: function _createMousePositionPanelBasicCoordinateElement(display, editCoordinates, currentProjectionUnits) {
    var div = document.createElement("div");
    div.id = this._addUID("GPmousePositionCoordinate");
    div.style.display = display ? "block" : "none"; // latitude

    var divLat = document.createElement("div");
    var spanLat = document.createElement("span");
    spanLat.className = "GPmousePositionLabel";
    spanLat.id = this._addUID("GPmousePositionLatLabel");
    spanLat.innerHTML = "Latitude : ";
    divLat.appendChild(spanLat);
    var span = document.createElement("span");
    span.id = this._addUID("GPmousePositionLatCoordinate");
    var arrayCoords;

    if (currentProjectionUnits === "DMS") {
      arrayCoords = this._createDMSCoordinateElement("Lat", editCoordinates);
    } else {
      arrayCoords = this._createCoordinateElement("Lat", editCoordinates);
    }

    for (var i = 0; i < arrayCoords.length; i++) {
      span.appendChild(arrayCoords[i]);
    }

    divLat.appendChild(span);
    div.appendChild(divLat); // longitude

    var divLon = document.createElement("div");
    var spanLon = document.createElement("span");
    spanLon.className = "GPmousePositionLabel";
    spanLon.id = this._addUID("GPmousePositionLonLabel");
    spanLon.innerHTML = "Longitude : ";
    divLon.appendChild(spanLon);
    var span1 = document.createElement("span");
    span1.id = this._addUID("GPmousePositionLonCoordinate");
    var arrayCoords1;

    if (currentProjectionUnits === "DMS") {
      arrayCoords1 = this._createDMSCoordinateElement("Lon", editCoordinates);
    } else {
      arrayCoords1 = this._createCoordinateElement("Lon", editCoordinates);
    }

    for (var j = 0; j < arrayCoords1.length; j++) {
      span1.appendChild(arrayCoords1[j]);
    }

    divLon.appendChild(span1);
    div.appendChild(divLon);
    return div;
  },

  /**
   * @param {Boolean} [display=false] - specifies if the altitude panel must be displayed
   *
   * @returns {DOMElement} container
   */
  _createMousePositionPanelBasicAltitudeElement: function _createMousePositionPanelBasicAltitudeElement(display) {
    var div = document.createElement("div");
    div.id = this._addUID("GPmousePositionAltitude");
    div.style.display = display ? "block" : "none";
    var spanLabel = document.createElement("span");
    spanLabel.className = "GPmousePositionLabel";
    spanLabel.innerHTML = "Altitude : ";
    div.appendChild(spanLabel);
    var spanAlt = document.createElement("span");
    spanAlt.className = "GPmousePositionCoords";
    spanAlt.id = this._addUID("GPmousePositionAlt");
    spanAlt.innerHTML = "...";
    div.appendChild(spanAlt);
    var spanUnits = document.createElement("span");
    spanUnits.className = "GPmousePositionAltitudeUnits";
    spanUnits.innerHTML = "m";
    div.appendChild(spanUnits);
    return div;
  },

  /**
   * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed
   *
   * @returns {DOMElement} container
   */
  _createMousePositionPanelEditToolsElement: function _createMousePositionPanelEditToolsElement(editCoordinates) {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPmousePositionPanelEditTools";
    div.id = this._addUID("GPmousePositionPanelEditTools");

    if (!editCoordinates) {
      div.style.display = "none";
    }

    var span1 = document.createElement("span");
    span1.className = "GPmousePositionEditTool";
    span1.id = this._addUID("GPmousePositionLocate");
    span1.title = editCoordinates === true ? "Cliquer pour saisir des coordonnées" : "";

    if (editCoordinates) {
      span1.addEventListener("click", function () {
        context.onMousePositionEditModeLocateClick();
      });
    }

    div.appendChild(span1);
    var span2 = document.createElement("span");
    span2.className = "GPmousePositionEditTool";
    span2.id = this._addUID("GPmousePositionCloseEdit");
    span2.title = "Quitter la saisie des coordonnées";
    span2.style.display = "none";

    if (editCoordinates) {
      span2.addEventListener("click", function () {
        context.onMousePositionEditModeClick(false);
      });
    }

    div.appendChild(span2);
    return div;
  },
  // ################################################################### //
  // #################### Settings container ########################### //
  // ################################################################### //

  /**
   * @param {Boolean} [display=false] - specifies if the settings panel must be displayed
   *
   * @returns {DOMElement[]} array containing input and label elements
   */
  _createShowMousePositionSettingsElement: function _createShowMousePositionSettingsElement(display) {
    var list = [];
    var context = this;
    var input = document.createElement("input");
    input.type = "checkbox";
    input.id = this._addUID("GPshowMousePositionSettings");
    var label = document.createElement("label");
    label.id = this._addUID("GPshowMousePositionSettingsPicto");
    label.htmlFor = this._addUID("GPshowMousePositionSettings");
    label.title = "Réglages";
    label.className = "GPshowMoreOptionsImage GPshowMoreOptions GPshowMousePositionSettingsPicto"; // FIXME classname and id ?

    label.style.display = display ? "block" : "none";

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        if (typeof context.onShowMousePositionSettingsClick === "function") {
          context.onShowMousePositionSettingsClick(e);
        }
      }, false);
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        if (typeof context.onShowMousePositionSettingsClick === "function") {
          context.onShowMousePositionSettingsClick(e);
        }
      });
    }

    list.push(input);
    list.push(label);
    return list;
  },

  /**
   * settings panel
   * @param {Boolean} [display=true] - specifies if the settings panel must be displayed
   *
   * FIXME
   * don't call this._createMousePositionSettingsSystemsElement
   * don't call this._createMousePositionSettingsUnitsElement
   *
   * @returns {DOMElement} DOM element
   */
  _createMousePositionSettingsElement: function _createMousePositionSettingsElement(display) {
    var container = document.createElement("div");
    container.id = this._addUID("GPmousePositionSettings");
    container.style.display = display === undefined || display ? "block" : "none";
    var span = document.createElement("span");
    span.className = "GPmousePositionSettingsLabel";
    span.innerHTML = "Système de référence";
    container.appendChild(span); // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // FIXME tableau statique !
    // var systems = [
    //     {
    //         code : "GEOGRAPHIC",
    //         label : "Géographique"
    //     },
    //     {
    //         code : "MERCATOR",
    //         label : "Mercator"
    //     },
    //     {
    //         code : "LAMB93",
    //         label : "Lambert 93"
    //     },
    //     {
    //         code : "LAMB2E",
    //         label : "Lambert II étendu"
    //     }
    // ];
    //
    // var selectSystem = this._createMousePositionSettingsSystemsElement(systems);
    //
    // container.appendChild(selectSystem);
    // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // FIXME tableau statique !
    // var units = [
    //     {
    //         code : "DEC",
    //         label : "degrés décimaux",
    //     },
    //     {
    //         code : "DMS",
    //         label : "degrés sexagésimaux",
    //     },
    //     {
    //         code : "RAD",
    //         label : "radians",
    //     },
    //     {
    //         code : "GON",
    //         label : "grades"
    //     }
    // ];
    //
    // var selectUnits = this._createMousePositionSettingsUnitsElement(units);
    //
    // container.appendChild(selectUnits);

    return container;
  },

  /**
   * @param {Object[]} systems - list of systems
   *
   * @returns {DOMElement} DOM element select
   */
  _createMousePositionSettingsSystemsElement: function _createMousePositionSettingsSystemsElement(systems) {
    // contexte d'execution
    var context = this;
    var selectSystem = document.createElement("select");
    selectSystem.id = this._addUID("GPmousePositionProjectionSystem");
    selectSystem.className = "GPinputSelect GPmousePositionSettingsSelect";
    selectSystem.addEventListener("change", function (e) {
      context.onMousePositionProjectionSystemChange(e);
    });
    selectSystem.addEventListener("mouseover", function (e) {
      // FIXME mettre une condition si target === option
      if (e.target.nodeName !== "OPTION") {
        context.onMousePositionProjectionSystemMouseOver(e);
      }
    });

    for (var i = 0; i < systems.length; i++) {
      var obj = systems[i];
      var option = document.createElement("option");
      option.value = obj.code;
      option.text = obj.label || i; // option.label = obj.label;

      selectSystem.appendChild(option);
    }

    return selectSystem;
  },

  /**
   * @param {Object[]} units - list of units
   *
   * @returns {DOMElement} DOM element select
   */
  _createMousePositionSettingsUnitsElement: function _createMousePositionSettingsUnitsElement(units) {
    // contexte d'execution
    var context = this;
    var selectUnits = document.createElement("select");
    selectUnits.id = this._addUID("GPmousePositionProjectionUnits");
    selectUnits.className = "GPinputSelect GPmousePositionSettingsSelect";
    selectUnits.addEventListener("change", function (e) {
      context.onMousePositionProjectionUnitsChange(e);
    });

    for (var j = 0; j < units.length; j++) {
      var obj = units[j];
      var option = document.createElement("option");
      option.value = obj.code ? obj.code : j;
      option.text = obj.label || j; // option.label = obj.label;

      selectUnits.appendChild(option);
    }

    return selectUnits;
  },

  /**
   * @param {String} [currentProjectionType="Metric"] - "Geographical" or "Metric"
   */
  _resetLabelElements: function _resetLabelElements(currentProjectionType) {
    // Changement des labels dans le formulaire de saisie
    var spanLat = document.getElementById(this._addUID("GPmousePositionLatLabel"));
    spanLat.innerHTML = currentProjectionType === "Geographical" ? "Latitude :" : "X :";
    var spanLon = document.getElementById(this._addUID("GPmousePositionLonLabel"));
    spanLon.innerHTML = currentProjectionType === "Geographical" ? "Longitude :" : "Y :";
  },

  /**
   * @param {String} currentProjectionUnits - projection units
   */
  _resetUnitElements: function _resetUnitElements(currentProjectionUnits) {
    var value = "";

    if (currentProjectionUnits === "M" || currentProjectionUnits === "KM") {
      value = currentProjectionUnits.toLowerCase();
    }

    var elts = document.getElementsByClassName("GPmousePositionUnits");

    for (var e = 0; e < elts.length; e++) {
      elts[e].innerHTML = value;
    }
  },

  /**
   * @param {Boolean} editCoordinates - edit coordinates option
   * @param {String} currentProjectionType - current projection type
   * @param {String} currentProjectionUnits - current projection unit
   */
  _resetCoordinateElements: function _resetCoordinateElements(editCoordinates, currentProjectionType, currentProjectionUnits) {
    // Suppression de tous les enfants de GPmousePositionLatCoordinate
    var latElt = document.getElementById(this._addUID("GPmousePositionLatCoordinate"));

    while (latElt.firstChild) {
      latElt.removeChild(latElt.firstChild);
    }

    var arrayCoords;

    if (currentProjectionUnits === "DMS") {
      arrayCoords = this._createDMSCoordinateElement("Lat", editCoordinates);
    } else {
      arrayCoords = this._createCoordinateElement("Lat", editCoordinates);
    }

    for (var i = 0; i < arrayCoords.length; i++) {
      latElt.appendChild(arrayCoords[i]);
    } // Suppression de tous les enfants de GPmousePositionLonCoordinate


    var lonElt = document.getElementById(this._addUID("GPmousePositionLonCoordinate"));

    while (lonElt.firstChild) {
      lonElt.removeChild(lonElt.firstChild);
    }

    var arrayCoords1;

    if (currentProjectionUnits === "DMS") {
      arrayCoords1 = this._createDMSCoordinateElement("Lon", editCoordinates);
    } else {
      arrayCoords1 = this._createCoordinateElement("Lon", editCoordinates);
    }

    for (var j = 0; j < arrayCoords1.length; j++) {
      lonElt.appendChild(arrayCoords1[j]);
    } // FIXME on simule un deplacement ?
    // this.onMapMove();

  },

  /**
   * Set/unset editing mode
   *
   * @param {Boolean} editing - active edit coordinates mode
   */
  _setEditMode: function _setEditMode(editing) {
    var locateElt = document.getElementById(this._addUID("GPmousePositionLocate"));
    locateElt.title = editing ? "Aller à la position ..." : "Cliquer pour saisir des coordonnées";
    var closeEditElt = document.getElementById(this._addUID("GPmousePositionCloseEdit"));
    closeEditElt.style.display = editing ? "inline-block" : "none";
    var selector = "div[id^=" + this._addUID("GPmousePositionCoordinate") + "]";
    var inputs = document.querySelectorAll(selector + " input");

    for (var i = 0; i < inputs.length; i++) {
      inputs[i].readOnly = !editing;

      if (editing) {
        inputs[i].value = "";
        inputs[i].classList.remove("error");
      }
    }

    var selects = document.querySelectorAll(selector + " select");

    for (var j = 0; j < selects.length; j++) {
      selects[j].disabled = !editing;
    }
  },

  /**
   *
   * @param {DOMElement} input - input element
   * @param {Boolean} isFloat - check for float value
   *
   * @returns {Boolean} true if input value is within bounds
   */
  _checkDMSElement: function _checkDMSElement(input, isFloat) {
    var b = isFloat !== undefined;
    var value = input.value;

    if (b) {
      value = value.replace(",", ".");
    }

    if (isNaN(value)) {
      return false;
    }

    var v = parseFloat(value);

    if (!b && (v | 0) !== v) {
      // is it an integer
      return false;
    }

    var min = Number(input.dataset.min);
    var max = Number(input.dataset.max);
    return v >= min && v <= max;
  },

  /**
   * @param {String} coordType - "Lon" or "Lat"
   * @param {DOMElement} input - input element
   *
   * @returns {Boolean} true if input value is within bounds
   */
  _checkDMSDegrees: function _checkDMSDegrees(coordType, input) {
    if (isNaN(input.value)) {
      return false;
    }

    var v = parseFloat(input.value);

    if ((v | 0) !== v) {
      // is it an integer
      return false;
    }

    var min = Number(input.dataset.min);
    var max = Number(input.dataset.max);

    if (v < min || v > max) {
      return false;
    }

    var inputMinutes = document.getElementById(this._addUID("GPmousePosition" + coordType + "Minutes"));
    var inputSeconds = document.getElementById(this._addUID("GPmousePosition" + coordType + "Seconds"));

    if (v >= max) {
      inputMinutes.dataset.max = 0;
      inputSeconds.dataset.max = 0;
    } else {
      inputMinutes.dataset.max = 59;
      inputSeconds.dataset.max = 59.9999;
    }

    return true;
  },
  // ################################################################### //
  // ####################### handlers Event ############################ //
  // ################################################################### //

  /**
   * Function displaying coordinates from cursor position (desktop)
   * or map center (tactile)
   * @param {Object} coordinate - coordinates
   */
  GPdisplayCoords: function GPdisplayCoords(coordinate) {
    // Compute coords in case of cursor position (desktop)
    if (coordinate) {
      var labelLon = document.getElementById(this._addUID("GPmousePositionLonLabel"));
      var labelLat = document.getElementById(this._addUID("GPmousePositionLatLabel"));

      if (coordinate.x || coordinate.y) {
        labelLat.innerHTML = "X : ";
        labelLon.innerHTML = "Y : ";
      } else if (coordinate.e || coordinate.n) {
        labelLat.innerHTML = "E : ";
        labelLon.innerHTML = "N : ";
      } else {
        labelLat.innerHTML = "Latitude : ";
        labelLon.innerHTML = "Longitude : ";
      }

      if (_typeof(coordinate.lat) === "object" && _typeof(coordinate.lng) === "object") {
        var parts = {
          lng: "Lon",
          lat: "Lat"
        };
        var units = ["Degrees", "Minutes", "Seconds"];

        for (var p in parts) {
          for (var u = 0; u < units.length; ++u) {
            var selector = "GPmousePosition" + parts[p] + units[u];
            var elt = document.getElementById(this._addUID(selector));
            var key = units[u].charAt(0).toLowerCase();
            elt.value = coordinate[p][key];
          }
        } // directions


        document.getElementById(this._addUID("GPmousePositionLonDirection")).value = coordinate.lng.direction;
        document.getElementById(this._addUID("GPmousePositionLatDirection")).value = coordinate.lat.direction;
      } else {
        var elLat = document.getElementById(this._addUID("GPmousePositionLat"));
        var elLon = document.getElementById(this._addUID("GPmousePositionLon"));
        elLat.value = coordinate.x || coordinate.lat || coordinate.e || "0";
        elLon.value = coordinate.y || coordinate.lng || coordinate.lon || coordinate.n || "0"; // les unites

        var unit = coordinate.unit === undefined ? "" : coordinate.unit;
        var elements = document.getElementsByClassName("GPmousePositionUnits");

        for (var n = 0; n < elements.length; ++n) {
          elements[n].innerHTML = unit;
        }
      }
    }
  },

  /**
   * Function displaying altitude from cursor position (desktop)
   * or map center (tactile)
   * @param {Object} coordinate - coordinates
   * @param {Number} altitudeTimeoutDelay - when the mouse stop moving, delay before the altitude request is launched
   * @param {Number} noDataValue - the no data value
   * @param {Number} noDataValueTolerance - the no data value tolerance
   */
  GPdisplayElevation: function GPdisplayElevation(coordinate, altitudeTimeoutDelay, noDataValue, noDataValueTolerance) {
    // contexte d'execution
    var self = this; // Latency for altitude request

    var altitudeTimeout;

    if (!altitudeTimeoutDelay) {
      altitudeTimeoutDelay = 500;
    }

    clearTimeout(altitudeTimeout);
    document.getElementById(this._addUID("GPmousePositionAlt")).innerHTML = "...";

    if (noDataValue == null) {
      noDataValue = -99999;
    }

    if (noDataValueTolerance == null) {
      noDataValueTolerance = 99980;
    }

    var maxThreshold = noDataValue + noDataValueTolerance;
    var minThreshold = noDataValue - noDataValueTolerance; // Compute coords in case of cursor position (desktop)

    if (coordinate) {
      // If no altitude panel, don't call altitude request
      if (document.getElementById(this._addUID("GPmousePositionAltitude"))) {
        altitudeTimeout = setTimeout(function () {
          self.onRequestAltitude(coordinate, function (z) {
            if (minThreshold < z && z < maxThreshold) {
              self.GPresetElevation();
            } else {
              document.getElementById(self._addUID("GPmousePositionAlt")).innerHTML = z;
            }
          });
        }, altitudeTimeoutDelay);
      }
    }
  },

  /**
   * Function reseting altitude value
   */
  GPresetElevation: function GPresetElevation() {
    if (document.getElementById(this._addUID("GPmousePositionAltitude"))) {
      document.getElementById(this._addUID("GPmousePositionAlt")).innerHTML = "---";
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (MousePositionDOM);

/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Drawing_GPdrawingOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _CSS_Controls_Drawing_GPdrawingOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Drawing_GPdrawingOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(171);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(195);
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Collection__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(197);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_geom__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_geom_LinearRing__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(198);
/* harmony import */ var ol_geom_LinearRing__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_geom_LinearRing__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(48);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(199);
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(ol_events_condition__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(200);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(ol_sphere__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(141);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(179);
/* harmony import */ var _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(185);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(155);
/* harmony import */ var _Common_Controls_DrawingDOM__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(201);
/* harmony import */ var _Formats_KML__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(143);
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(156);
/* harmony import */ var _Formats_GPX__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(148);
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(169);
// import CSS
 // import OpenLayers









 // FIXME not include into ol/geom !?




 // import local





 // DOM

 // import local with ol dependencies





var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_14__["default"].getLogger("Drawing");
/**
 * @classdesc
 *
 * Drawing Control.
 *
 * @constructor
 * @alias ol.control.Drawing
 * @extends {ol.control.Control}
 * @param {Object} options - options for function call.
 * @param {Boolean} [options.collapsed = true] - Specify if Drawing control should be collapsed at startup. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Object} [options.layer = {}] - Openlayers layer that will hosts created features. If none, an empty vector layer will be created.
 * @param {Object} [options.popup = {}] - Popup informations
 * @param {Boolean} [options.popup.display = true] - Specify if popup is displayed when create a drawing
 * @param {Function} [options.popup.function] - Function to display popup informations if you want to cutomise it. You may also provide your own function with params : {geomType / feature / saveFunc(message) / closeFunc()}. This function must return the DOM object of the popup content.
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Croquis"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Mon croquis"] - Layer description to be displayed in LayerSwitcher
 * @param {Object} options.tools - Tools to display in the drawing toolbox. All by default.
 * @param {Boolean} [options.tools.points = true] - Display points drawing tool
 * @param {Boolean} [options.tools.lines = true] - Display lines drawing tool
 * @param {Boolean} [options.tools.polygons = true] - Display polygons drawing tool
 * @param {Boolean} [options.tools.holes = false] - Display polygons with holes drawing tool
 * @param {Boolean} [options.tools.text = true] - Display text drawing tool
 * @param {Boolean} [options.tools.remove = true] - Display feature removing tool
 * @param {Boolean} [options.tools.display = true] - Display style editing tool
 * @param {Boolean} [options.tools.tooltip = true] - Display text editing tool
 * @param {Boolean} [options.tools.edit = true] - Display editing tool
 * @param {Boolean} [options.tools.export = true] - Display exporting tool
 * @param {Boolean} [options.tools.measure = false] - Display measure drawing into popup info
 * @param {String} [options.labels] - Labels for Control
 * @param {String} [options.labels.control] - Label for Control
 * @param {String} [options.labels.points] - Label for points drawing tool
 * @param {String} [options.labels.lines] - Label for lines drawing tool
 * @param {String} [options.labels.polygons] - Label for polygons drawing tool
 * @param {String} [options.labels.holes] - Label for polygons with holes drawing tool
 * @param {String} [options.labels.text] - Label for text drawing tool
 * @param {String} [options.labels.edit] - Label for editing tool
 * @param {String} [options.labels.display] - Label for style editing tool
 * @param {String} [options.labels.tooltip] - Label for text editing tool
 * @param {String} [options.labels.remove] - Label for feature removing tool
 * @param {String} [options.labels.export] - Label for exporting tool.
 * @param {String} [options.labels.exportTitle] - Title for exporting tool.
 * @param {String} [options.labels.applyToObject] - Label for apply to object button.
 * @param {String} [options.labels.saveDescription] - Label for save description button.
 * @param {String} [options.labels.setAsDefault] - Label for set as default style button.
 * @param {String} [options.labels.strokeColor] - Label for stroke color.
 * @param {String} [options.labels.strokeWidth] - Label for stroke width.
 * @param {String} [options.labels.fillColor] - Label for fill color.
 * @param {String} [options.labels.fillOpacity] - Label for fillOpacity.
 * @param {String} [options.labels.markerSize] - Label for markerSize.
 * @param {Array.<Object>} [options.markersList = [{"src" : "data:image/png;base64,xxxx", "anchor" : [0.5,1]}]] - List of markers src to be used for points with their anchor offsets See {@link http://openlayers.org/en/latest/apidoc/ol.style.Icon.html OpenLayers params} for anchor offset options.
 * @param {Object} options.defaultStyles - Default styles applying to geometries (labels, lines and polygons).
 * @param {String} [options.defaultStyles.textFillColor = "#000000"] - Text fill color for labels (RGB hex value).
 * @param {String} [options.defaultStyles.textStrokeColor = "#FFFFFF"] - Text surrounding color for labels (RGB hex value).
 * @param {String} [options.defaultStyles.strokeColor = "#ffcc33"] - Stroke color (RGB hex value).
 * @param {Number} [options.defaultStyles.strokeWidth = 2] - Stroke width in pixels.
 * @param {String} [options.defaultStyles.polyStrokeColor = "#ffcc33"] - Stroke color (RGB hex value) for polygons.
 * @param {Number} [options.defaultStyles.polyStrokeWidth = 2] - Stroke width in pixels for polygons.
 * @param {String} [options.defaultStyles.polyFillColor = "#ffffff"] - Polygons fill color (RGB hex value).
 * @param {Number} [options.defaultStyles.polyFillOpacity = 0.2] - Polygon fill opacity (alpha value between 0:transparent and 1:opaque).
 * @param {Object} options.cursorStyle - cursor (circle) style when drawing or editing.
 * @param {String} [options.cursorStyle.fillColor = "rgba(0, 153, 255, 1)"] - Cursor fill color.
 * @param {String} [options.cursorStyle.strokeColor = "#FFF"] - Cursor stroke color.
 * @param {String} [options.cursorStyle.strokeWidth = 1] - Cursor surrounding stroke width.
 * @param {String} [options.cursorStyle.radius = 6] - Cursor radius.
 * @example
 * var drawing = new ol.control.Drawing({
 *   collapsed : false,
 *   draggable : true,
 *   layerswitcher : {
 *      title : "Dessins",
 *      description : "Mes dessins..."
 *   },
 *   markersList : [{
 *      src : "http://api.ign.fr/api/images/api/markers/marker_01.png",
 *      anchor : [0.5, 1]
 *   }],
 *   defaultStyles : {},
 *   cursorStyle : {},
 *   tools : {
 *      points : true,
 *      lines : true,
 *      polygons :true,
 *      holes : true,
 *      text : false,
 *      remove : true,
 *      display : true,
 *      tooltip : true,
 *      export : true,
 *      measure : true
 *   },
 *   popup : {
 *      display : true,
 *      function : function (params) {
 *          var container = document.createElement("div");
 *          // - params.geomType;
 *          // - params.feature;
 *          // Les 2 fonctions ferment la popup avec ou sans sauvegarde des informations
 *          // dans les properties de la feature (key : description)
 *          // - params.saveFunc(message);
 *          // - params.closeFunc();
 *          return container;
 *      }
 * });
 */

var Drawing = function (Control) {
  function Drawing(options) {
    options = options || {};

    if (!(this instanceof Drawing)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    this._initialize(options); // init control DOM container


    var container = this._container = this._initContainer(); // call ol.control.Control constructor


    Control.call(this, {
      element: container,
      target: options.target,
      render: options.render
    });
  }

  ; // Inherits from ol.control.Control
  // olInherits(Drawing, Control);

  if (Control) Drawing.__proto__ = Control;
  /**
   * Default tools to display for widget
   *
   * @private
   */

  Drawing.DefaultTools = {
    points: true,
    lines: true,
    polygons: true,
    holes: false,
    text: true,
    remove: true,
    display: true,
    tooltip: true,
    edit: true,
    "export": true,
    measure: false
  };
  /**
   * Default labels for widget
   *
   * @private
   */

  Drawing.DefaultLabels = {
    control: "Annoter la carte",
    creatingTools: "Outils de création",
    points: "Placer des points",
    lines: "Dessiner des lignes",
    polygons: "Dessiner des polygones",
    holes: "Créer des trous sur un polygone",
    text: "Ecrire sur la carte",
    editingTools: "Outils d'édition",
    edit: "Editer les tracés",
    display: "Modifier l'apparence des objets",
    tooltip: "Modifier les textes / infos-bulles",
    remove: "Supprimer des objets",
    "export": "Exporter",
    exportTitle: "Exporter en KML",
    applyToObject: "Appliquer à l'objet",
    saveDescription: "Enregistrer",
    setAsDefault: "Définir par défaut",
    strokeColor: "Couleur du trait : ",
    strokeWidth: "Epaisseur du trait : ",
    fillColor: "Couleur de remplissage : ",
    fillOpacity: "Opacité du remplissage : ",
    markerSize: "Taille du pictogramme : ",
    markerColor: "Couleur du pictogramme : "
  };
  /**
   * Default styles applyied to drawn features.
   *
   * @private
   */

  Drawing.DefaultStyles = {
    textFillColor: "#000000",
    textStrokeColor: "#FFFFFF",
    // INFO : cette option n'est pas surchargeable via les options du constructeur !
    textIcon1x1: {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
      anchor: [0, 0]
    },
    polyFillColor: "#ffffff",
    polyFillOpacity: 0.4,
    polyStrokeColor: "#ffcc33",
    polyStrokeWidth: 4,
    strokeColor: "#ffcc33",
    strokeWidth: 4,
    markerSize: 1,
    markerColor: "#ffcc33"
  };
  /**
   * Default styles when drawing
   *
   * @private
   */

  Drawing.DefaultCursorStyle = {
    radius: 6,
    strokeColor: "#FFF",
    strokeWidth: 1,
    fillColor: "rgba(0, 153, 255, 1)"
  };
  /**
   * @lends module:Drawing
   */

  Drawing.prototype = Object.create(Control.prototype, {});
  /**
   * Copies all source object members to Drawing prototype
   *
   * @param {Object} source - source object whose properties will be copied.
   * @private
   */

  Drawing.prototype.assign = function (source) {
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        this[prop] = source[prop];
      }
    }
  };

  Drawing.prototype.assign(_Common_Controls_DrawingDOM__WEBPACK_IMPORTED_MODULE_19__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  Drawing.prototype.constructor = Drawing;
  /**
   * Overload of {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html#setMap ol.control.Control.setMap()} method, called when control is added to or removed from map.
   *
   * @param {Object} map - {@link http://openlayers.org/en/latest/apidoc/ol.Map.html ol.Map} object.
   */

  Drawing.prototype.setMap = function (map) {
    var _this = this;

    // call original setMap method
    Control.prototype.setMap.call(this, map);

    if (this.getMap() && this.eventKey) {
      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this.eventKey);
    } // nothing else to do if map == null


    if (map == null) {
      return;
    } // mode "draggable"


    if (this.draggable) {
      _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_16__["default"].dragElement(this._drawingPanel, this._drawingPanelHeader, map.getTargetElement());
    } // mode "collapsed"


    if (!this.collapsed) {
      var inputShow = document.getElementById(this._addUID("GPshowDrawing"));
      inputShow.checked = "checked";
    }

    if (this.layer) {
      // ajout du layer de dessin à la carte s'il n'y est pas déjà
      this.setLayer(this.layer);
    } // gestion des suppressions "externes" de la couche de dessin.


    this.eventKey = this.getMap().getLayers().on("remove", function (evtRm) {
      if (evtRm.element === _this.layer) {
        // FIXME object comparison
        // found layer removed.
        _this.layer = null; // on supprime l'interaction en cours si besoin

        if (_this.interactionCurrent) {
          _this.getMap().removeInteraction(_this.interactionCurrent);

          _this.interactionCurrent = null;
        }
      }
    });
  };
  /**
   * Export features of current drawing layer (KML by default).
   *
   * @returns {String} a representation of drawn features (KML, GPX or GeoJSON) or null if not possible.
   */


  Drawing.prototype.exportFeatures = function () {
    var result = null;

    if (Control.prototype.getMap.call(this) == null) {
      logger.log("Impossible to export : control isn't attached to any map.");
      return result;
    }

    if (!this.layer) {
      logger.log("Impossible to export : no layer is hosting features.");
      return result;
    }

    if (!this.layer.getSource() || !this.layer.getSource().getFeatures() || !this.layer.getSource().getFeatures().length) {
      logger.log("Impossible to export : no features found.");
      return result;
    }

    var ClassName = null;

    switch (this.getExportFormat()) {
      case "KML":
        ClassName = new _Formats_KML__WEBPACK_IMPORTED_MODULE_20__["default"]({
          writeStyles: true
        });
        break;

      case "GPX":
        ClassName = new _Formats_GPX__WEBPACK_IMPORTED_MODULE_22__["default"]({// readExtensions : function (ext) {/* only extensions nodes from wpt, rte and trk can be processed */ }
        });
        break;

      case "GEOJSON":
        ClassName = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_21__["default"]({});
        break;

      default:
        break;
    }

    if (!ClassName) {
      logger.log("Impossible to export : format unknown !?");
      return result;
    }

    var featProj = this.layer.getSource().getProjection();
    featProj = featProj || this.getMap().getView().getProjection();
    result = ClassName.writeFeatures(this.layer.getSource().getFeatures(), {
      dataProjection: "EPSG:4326",
      featureProjection: featProj
    });
    return result;
  }; // ################################################################### //
  // #################### user interface methods ####################### //
  // ################################################################### //

  /**
   * Collapse or display control main container
   *
   * @param {Boolean} collapsed - True to collapse control, False to display it
   */


  Drawing.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.error("[ERROR] Drawing:setCollapsed - missing collapsed parameter");
      return;
    }

    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    } // on simule l'ouverture du panneau après un click


    this.onShowDrawingClick();
    this._showDrawingContainer.checked = !collapsed;
  };
  /**
   * Setter for Export Name.
   *
   * @param {String} name - Export Name. By default, "Croquis".
   */


  Drawing.prototype.setExportName = function (name) {
    this._exportName = name;
  };
  /**
   * getter for Export Name.
   *
   * @returns {String} export name
   */


  Drawing.prototype.getExportName = function () {
    return this._exportName;
  };
  /**
   * Setter for Export format (KML, GPX or GeoJSON).
   *
   * @param {String} format - Export format. By default, "KML".
   */


  Drawing.prototype.setExportFormat = function (format) {
    this._exportFormat = format ? format.toUpperCase() : "KML";

    switch (format.toUpperCase()) {
      case "KML":
        this._exportExt = ".kml";
        this._exportMimeType = "application/vnd.google-earth.kml+xml";
        break;

      case "GPX":
        this._exportExt = ".gpx";
        this._exportMimeType = "application/gpx+xml";
        break;

      case "GEOJSON":
        this._exportExt = ".geojson";
        this._exportMimeType = "application/geo+json";
        break;

      default:
        // redefine format by default !
        this._exportFormat = "KML";
        break;
    }
  };
  /**
   * getter for Export format.
   *
   * @returns {String} export format
   */


  Drawing.prototype.getExportFormat = function () {
    return this._exportFormat;
  }; // ################################################################### //
  // ######################## initialize control ####################### //
  // ################################################################### //

  /**
   * Gets marker options in options.markersList given its src.
   *
   * @param {String} src - marker image URI,
   * @returns {Object} markers options
   * @private
   */


  Drawing.prototype._getsMarkersOptionsFromSrc = function (src) {
    var markerOptions = null;

    for (var i = 0; i < this.options.markersList.length; i++) {
      if (src && this.options.markersList[i].src === src) {
        markerOptions = this.options.markersList[i];
        return markerOptions;
      }
    }

    return markerOptions;
  };
  /**
   * Converts markerElement options into Openlayers IconStyles options.
   *
   * @param {Object} markerElement - marker element
   * @returns {Object} ol.Style.Icon constructor options.
   * @private
   */


  Drawing.prototype._getIconStyleOptions = function (markerElement) {
    var iconOptions = {};
    Object.keys(markerElement).forEach(function (key) {
      switch (key) {
        case "src":
        case "size":
        case "scale":
        case "color":
        case "anchor":
        case "anchorOrigin":
        case "anchorXUnits":
        case "anchorYUnits":
          iconOptions[key] = markerElement[key];
          break;
      }
    });
    return iconOptions;
  };
  /**
   * Initialize control (called by Drawing constructor)
   *
   * @method _initialize
   * @param {Object} options - control options (set by user)
   * @private
   */


  Drawing.prototype._initialize = function (options) {
    var _this2 = this;

    // determination d'un uid
    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_17__["default"].generate(); // export name / format / ...

    this._exportName = "Croquis";
    this._exportFormat = "KML";
    this._exportMimeType = "application/vnd.google-earth.kml+xml";
    this._exportExt = ".kml";
    options = options || {}; // Set default options

    this.options = options;

    if (!this.options.layerDescription) {
      this.options.layerDescription = {
        title: "Croquis",
        description: "Mon croquis"
      };
    } // applying default tools


    if (!this.options.tools) {
      this.options.tools = {};
    }

    Object.keys(Drawing.DefaultTools).forEach(function (key) {
      if (!_this2.options.tools.hasOwnProperty(key)) {
        _this2.options.tools[key] = Drawing.DefaultTools[key];
      }
    }); // styles par defaut lors du dessin

    if (!this.options.cursorStyle) {
      this.options.cursorStyle = {};
    }

    Object.keys(Drawing.DefaultCursorStyle).forEach(function (key) {
      if (!_this2.options.cursorStyle.hasOwnProperty(key)) {
        _this2.options.cursorStyle[key] = Drawing.DefaultCursorStyle[key];
      }
    });
    this.options.collapsed = options.collapsed !== undefined ? options.collapsed : true;
    /** {Boolean} specify if Drawing control is collapsed (true) or not (false) */

    this.collapsed = this.options.collapsed;
    this.options.draggable = options.draggable !== undefined ? options.draggable : false;
    /** {Boolean} specify if Drawing control is draggable (true) or not (false) */

    this.draggable = this.options.draggable;
    this.options.markersList = options.markersList || [{
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARfSURBVFiF3ZhfbBRVGMV/d2Z3212tbSkCbuNaqzaRiL6QyAMPjSFoYqgx4oOiRmMFUzQG479o2lQ0QXk1EhYFgmlD2mIRkYhRwqLEaA2GiKWV7rZLQ0sLwbZId7t/Zq4PFK1125m5s/vCedz7nXO+M9/N3jsD1xFEvgXlTkrI8hBQBywFbgEqgEvAMHAayZcYHBYbuZJP77yFkdsoR+ct4GXAb4OSQPARXj4QzzGejx7yEkZuZy2CMLBAgf4nkhfEi3S67UNzQ5YSIXfQhKAdtSAACxDsk2EapXT3cF2FYQdNSN7F/YQFsJkw77gVUcL01mp3o5EDJoK1Yj37VchKjcjdlJEmhvrWmg9jGNwhGhhzSlTbZmnepjBBAMrReF2F6Hgy0+fIKPb+flWRIMtip+eQ88lcPRCtg3gCCVZ3RqhPDbJepqlPDbJ6XwSvP2nDJYCXB522prLN6iwrPIEETw33U/VoLZovBPjQfCGqHqtl3XDUZiBrn1lQCXO3ZcUDLV34Su/JueYrW0btnp8tNSRLnTamEiZoWRF6uHre9dseuT0vPrOgEqbCWtW3xNX6VSy02c+/sk4JwF+WFWZ6xGL9vA2fyzb7+QcqYUYtKwYP9s+7PrA/bsNn/geSA87DSLosa44+fT/p8VM511Jjp4g8u8KGk7XPLKhM5qhlRSbppzV4JwMdEcz0WSCNmT5LrC1CS/AujKliSw1BxGljzm8AH3MjHs4BpU65DjCBn0rxDJNOSI4nM33F2O2U58yEnU6DgOpF02AzcEGJa40LZHlfhagUZvp6vkmFawObVK7/4PLFSoZpBZ50ozEThsne6i2hjZqmFRVJ6U8JUeSVUmQNzQvg0c1MVtNMIUTSl0pNLhsaGu8A4xrfbZhS4CRQ5SoFcCWtja/5NBg+N+GZsu0vhSEkcY8mf+iNx+OuX3llmJVABNCVNUA2fl3xWdvJkriqRBb2uPugAYgNHEey1Y3Gt3/ccNxFEAChm2al6zAAjNAEWF/rc1Ev6+ffOLTwmBt7E0xD02J5CSOayQLrsHMJnYGMITJvHrr588mUMKyr54CUaaHrnfF4fCQ/kwHEBmLAa044rb+WHP4xXnxJ0VJK6CkyjO2xWOx3KMSH8zDtwONWdb2jvt41u4JtChZJKeVveDwnYrHYfw5uj4KYFRpSWbGqyCPL5ypIpMTkKwcWfWVXUEqRRcio1LTuUCjUE4lEsrnq8j4ZgKEP9bpgmfHFHPpyy3fle3f9Uto3n4aUIqNhDghN6zZ1vTcajaasfAsSBmBwq7f11tLM/24Hx2L+n+rbF38zBy2JEP0anPEGAj3d3d1pJ56F2GYAGInM82M+bWW53wxd++3ipH7x1QMLj8ysk5BAyj6Ppp2+d/nyaEdHh/I/W8EmA3Ci2b/iviVT3+tCerMmxkudiz450hcYBSYQIqrDmScGBvqawSxkH3lDV2Pxe6ltItnWcFNLTXX1qpqamkoK/BCvC/wNB+l5MdQKNHsAAAAASUVORK5CYII=",
      anchor: [0.5, 1] // FIXME l'impl. sur le KML connait qq souci dont la gestion de
      // la balise hotspot du format KML
      // size : [51, 38],
      // anchor : [25.5 , 38],
      // anchorOrigin : "top-left",
      // anchorXUnits : "pixels",
      // anchorYUnits : "pixels"

    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS7SURBVFiF3VhNTFxVFP7OfTNvOjMtM9AoJSSYEEVMCv6kJi5NoCa1TRqNxDTaFhcWNSmxaaxNQ0w3mqgLdGeRhKFYXVC7qDU2BhVt/YdqEQRhRgYTKD8VZqAMzM+7xwVCcIR58+6b2fRb3nO+853v3fvuu+8CtxEo1wX5pTu2IpasBfEeSFSCUAygCMAsgEkAQyD6DClXF3VMLeZSO2dmuN7vB+MYiBsAbDEn8BIIZ6BrzdQyF81FDzkxw8/594P5HQCFCvQ5QDRSYO4Tu30IO2QGiA/5XgVzAGpGsMKTZ/mw7wTbfLi2yFzvOwngpJ0aaXidAtG3VcnKZv5dWgE7Nf5fFBJCHqK2hUsqdKVG+EihDwn5K9SXViZEAHqAApGIVaLaO5Pg48iPEQDwg2WjCtHyzKx8RxJBZLP9qoJ5CdJ9t9XvkPWZiSVrkY0R3b2MxnM9aJ2Ooi3iRut0FEc/6IHuiZtyidwQ8RqrrVk3Q7zHNEd3L6N5eAYP7q2BppcB0KHpZXhoXw2aB6eyM8SPW23NuhnGvaY5L7T2w7Nt54Yxj68KDS19WSiZ66RBZQPYYZpRvfuejPH7H8scX0FJlv2sQcVMkWmGpmc2bBbPVicNKsvslmmOkZg0id/IQmkhy47WoLABYNo05/rnIxnjv1wOmtbgLHTSoDIz10xzzhypQiz624axWLQPLQ3V5kLUa7U1la35G9OcRMyFY/cV49qlLhiJMQAJGIkx9FzswsuVO5BccpnryKuWW7NK4IPFXmjLgwAKrHItYB66t5JaJmJWSJZnhjqmFiFxzirPIjqsGgFUD5qC3gRjRolrBsYMQEr/NEpmKBCJgHBKhWteHKdUjv8rVBvgw773QaizU2M9DMb58q98rwghXC5md5zI5WSmlCGcAODQZDIlhCSiJT0eX6waH490AsYq356ZZ4oK4DSuAihT4UuGYIaQILGQ4vknen2BibhYzlqfySBG2CH4ylA4HLb9y8v1BY8A9CkAzVwcZDA0BgkG0+oFBjP49Ij3o48n9b9U20gB7bZuZwCAAvM/gPndTDmSIZKS9CRDNwCHBIv1NzFdfzu/t2EEAEiTstS2GQDA2PwbAHrSh9ebSDewihtxMdn0h/dbO/ISkIYQoZyYoW6kYOD59YdQg8mRYjgleFONpKRk07D34qJBxmY5pmBOkKZdCIfDk7mZGQDUER0FUROwaoQdZpd6H07oXT/OOWYVJZmBQZdhvBcKhfqBfFyc1xcEEpKeNjMytOgYfqp32wUFiSVm7oPD0RsKhf5zsnYoFMsMyccTUtvtFHL7ZimxFC2eGPJezrYkM6VAHGQhBsrKyga7u7tTG+XlfGYAIFxXuLfEzZ288fvCb4U858+Ou0KZajBTUkCOkhADUtOGgsGg6SVIXswAQKiuqK3UbRxIH78yq//8Yr/3i01oSyD6UwDDTo9ncGBgIGFFM29mRh/FFm+J/3qBk+9aHbsZFzf39WwN3DK0tWXCQAzMIw4hfq/etSvY2dmpvLPlzQwA/PTk9od3eowvhWCnZEodHfC2fz3rnAEQBVFQA4YPjI6OnAZkPvvIGb7bX/Ta/LP+SEftne0V5eW1FRUVpcjzQ7wt8A+9at5zXMB2DQAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAP0SURBVFiF3ZnLbxtVFIe/e8eOPU5DapI2whEWyiILJGDTBQuWSGTTSkVlQRGs2MGSh4RoQWLB4x/gpVIViNokJUV0U4RQXKgQr0ookCYkdjONSJtQJTGltjO2Zw6LJlEbkszLTgQ/6Ww859xzPt97556Zgf+RVKMHFGgD+oADwP3APUAHsABcBS4BXwDnFNxsdP6GSCAt8LZAWUB8WEngLYHdO137HRI4JLDgE2K9LQg8vtMMCCiBowJuSJBVcwWOSBOWfRCY1yJCrLdXdwrkUANmZL05Age3G2R3hD3iZYsC6TB16ZA8rwB3h4z1Uhp4MUxg4A23co7MA2aYhD5VBrqCnkNhZqYPPyCpVJnh4Ry2PYNIFdue4fTpHKZZ8ZEjBTwWorZgEvjEc92nUiUpFn+VjbS0NCqm6edgPbEdMD97FjI8PLIhyKoGB0d8wPy0HTBXPQux7Stbwti25QNmNmhtYW4ANtCytZNUPXxslEp4pKoq8PK5Q2FuAH97elSrcx7Xr/nIc8NnPWsKAzPv6XH27OUtr585Y/nIs/Uf0ggJHPdc76ZZlqWl0Q33y+LiqCSTFR975th2wDzjqy0xzbIMDo6IbVsiYottW3Lq1IhPEBF4ejtgdgkUm9SXrVpRoDVobYH3zEqLcTxoXEAdU1Bqco5bkluPyPNNmpV5Cdk1RwE63CSYw2FrivSYKtBPhOTr5cDJnmz2Oa11IiFi2kol4iKq7ug4QMxwa3WtXaVUpcW2Sw/MzhaHwFmNjwrTDvwC3BeJAripdXF/JvP+H7HYsu/8ohwlWDEt305YlhX5BYLAI0AOMCKMIUc6Oj4eaGuzwg5RhxNhnzTXpOAC8E6UMb5qbb0QAQRAGa7bHRlmRUeBH8IEzhnGtZc6O89HSe6C62hdaAiMgjrwFH6a0NtUU6r28p49n5WUcry9N5FIVRnGsGVZc42aGRQUgBeCxPS3tZ37LplcCJlSBMYTjvNeoVD4baWGxkpgEHjCy2+ipWVifyYzECJFRURGicUuFgqFP2+/0AyYTlupyYTIpqd4WanSwe7udy/HYr5aFhFVR0letB7LZrPjuVyuvpFfU97tzhrGgYzjfL7J+PJmOn3yo/b2qa3GEFE1jTuttB5zDWMin8/bXnmb9qJ6Jh7vv7dW+1d3cN40v3+2q+vLTcIqKHVZw2Q8lRofGxurBsnZNJhpSLZr/XvadbOrv103jOt9mcwHNwxjbZkIlBGZiml96cF9+/JDQ0Oh72xN/YRw0TQffmh5+RtDJF4H5/m9ez/8OpWaB/5CqbwBk09OT0+9Dm4z62iYfkwm37CVqgzsuuvT3p6eR3t7e7vZye8w/xX9A0ynxee2hlfFAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASKSURBVFiF3ZhdbBRVHMV/9+5uPwikFExEiCtWbSKCCEsCiU1EJIEXeMIHxZgYPzBUYzB+RUPlwwTl1UhYFIiGhrQVFCMRAoQFidGaEgIuVLrbLgSkhWBb2N3uzs7M3weBILadnZndF87j3P8553/m3ty5c+Eugiq1oDy5dRw5czGKpQjTgPuAicBV4C+E02j5gSFrn4o3pkvpXbIwMmNTLaHAByjeBKqLoGRBfY4V+lSdeGmgFD2UJIzM2bwMUVFgggf634i8qo6/vttvH9oPWRAlkS1NiGrFWxCACSj1rUSiqwXx9XJ9hWH2liaQtfifYQWsIxL9yK+IJ9xYWq1+NIaBjahl6vhr33khe2pEntg+noCRxPvSGg39GNZD6tTKfrdEb8ssaHxIeYIA1FKh3/VCdD0zN74jfRS3/XpFlpx5r9vvUNC1Tc5cTDFBqoJZ1i9opyFcR0hPomD3cvR8N02H55IvOPHHUB1aBOxy05r7ZaZY6lhTFcyy74Vunp46n5AOAxWEdJhnps5n//IElaEhRw0pwucOuA8jPOpYs35BO2Mrpg87NrZiBmvn/+aooWSa29a8bACTHSsawnWjjj/1wIOOGlKEzx3wEmaiY0VIT/I1/i/uKbKfW/AS5rpjRcHudRi/VITPtSL7uQUvYfocK46e7x51PNaTKsJn9BcyDDyEkXbHkqbDc0kbp4Ydu54/xcexec42OPvcAS9b82HHmnyhmkXND3OwJ0bBPgcYFOxzHEjGWLTjEQyryrkzFXPfmkvIY1+MpSp4Aahxy3WBQQrVU9TJFzNuSK5nRsUb0yi2u+W5dNnqNgh4PWjmrXXAZU9cZ1zGMD/xQvQU5sbxfJUXbhFY5eX4Dz5/rCQSbQae96NxOyzsnXVXNjRqrSsrRarzSlWGRJRp6RBAMGAXTK1tpdRQRT6fmXHx4kAbWDf5fsPUACeAqb5SAGkxBpYMfBW9YA/mivYXZSkhFdTyc2cqlfL9yyuRaAMQAwKeNUBWZ376piV3IuVVwoSv/V1oAKpjxTGQjX40Dhh/HvMRBEAFbHuK7zAAjOttApyP9cOg17526b303iN+7G2wLa2TJQmjYmtMYDnFHEJvQwGr8H5m766M5C3n6hEgYqhAYHcqleotzcwAqmNFEuEdN5zm3PF9vxipqx4tReBMpWVtTiaTf0A5Ls4j0VbgWae6TrOvc8ngthYPFkMicpJgsCOZTP7nw+3+QsMZK/NiLqxUwdqRCrJ2PvNWes+PxQqKKBMlCdE6Hg6Hz8RiMXO4upLPDMDFWZ8tnazHfz+CvmzIHNy5Lfd712gaIqqgsXuU1nE7EOhMJBJ5J9+yhAE4P2tj8/265n+ngyNG8tdXrrfuH4E2hFLdGs6Gxow5E4/HDTee5VhmAFj92Zf7J1Q01Krq8M1nV+zMlbfTew7dXieQRaQrqPXpx+fMSbS1tXne2co2MwAds9fMm6kmHQ2gQia29ca13V8eKnT1AYMolQjA2ed6errWgF3OPkqG9pmr1+cjm4ZapjfuqK+rW1hfXz+FMr/EuwL/AGOdsbn1H7gQAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATNSURBVFiF3VhZTFxlFP7Of+8Mi12Eot2Sia36IIJCIWmT0lhSK30wfaoaNcampBhrfGhSl5hIW9HE5VFTpWilNpUI0hrTh1YwjJSkthFEcABhBoZ0YekCFGa72/FBSLAF7jY86Pc453znO9/9//nvuT/wPwIlu2DLns1Lo3J8hwDtZHA2gNUAVgC4SYRrzNxFJH6UpNjZ4iOBqWRqJ83MmVdzM7y6520CvQ4gzQIlSoxPJVX/sLi6fTwZPSTFTOMrhbuYuRJApgP6LRDv3V7ZdsptH8INmQH6aW9BOTPXwpkRAMgE0/eNZQXvssuHK7khF5VtOEhEh+F+hQlAcX/hGu1E61CzmyKOML21at3UmAMGM+96qqrttBOyo0aadufdq3mlEJxvrXlBwFhcUh58+vPOMbtcR/8ZzSu/g0UwAgAMZHgN7xtOuLZXpmXP5qUxOT4Ca8evU0RlOb7S7ntItq8S30EWjEje1GhOacWlrNyi9SR5VrGuDo92NPd3HSvfqCsJM366pqaVAKi305vtbSZAO81yJG9qdMsnZ/vvyyveSpLHB8BLkse3Mn/b1i0fnQtK3pSYuRKb6tzdm10QP2KWklNacUlOXZIzV0xOX5KbvfvwRXMdyrbbmm0zzFhjlpOVW7R+ofj9eU+ss6BkqnMnnJxmK8wSSPKschOfRpbljqbhxMykWQLr6rBJfMiCzm3LHU3DiZkRs4TRjub+BeO/+8MWdBZ8IHPBthkiXDLL6TpWvlGLTnXOFVOjk52B6oObzJXYVOdO2D8AQE1mObqSSDv/VslDI62NftbVQQAK6+rgyG8N/vNvljxsqEqqqQ4Lv93ebE8ATfseXaJpqVcALLfLtYEJI6auLTnREbFDsr0y/4wY9LVdnh0w4yu7RgCHg2ZCSrwHYNQJ1wJGFVl53wnRkZnp8Xy/E64F7Hcy/gMuP6waygpOAnjBTY3Z0Bk1ZeeuvyaESElhTksQpXiYSdOFBwBkyVA1IQwiinkTiUju1avjdYA+w3drZjkB7Qw84NIH4hqPV1wYr7wVM+JWOcykEyMsCz7fEw6HXX/yNpQVFAHww819AoNP9kS+abkcDzutoAHHXd3OAMD2o60tTPjYTY3260qLCyMAQJJhrHVtBgA8q5eWAzAf6+fAeNwYqu6c+sWNvgEYuhChpJgpPuTXBPAiLAyhs6Ez1ONdkfqEzrp59jxgVkiSToXD4eGkmAGAbUdbQ0R8wA7Hfzl+tueGctOhJDPQnaLrX4RCoT+BRbg4bywrqGXgGbO8K5NazwcXJr5zIBFj5g7IcmsoFPrXi9v2hYYZJGBfzOAnPYIy5stJaEbky86pM1ZrMpMG4iALEfD5fN1+v1+bKy/pKwMAtS/n78xIET/MU5/r/4rUNA7G+xaqwUyqgDFAQgQMSeoJBoMJM91FMQMANS/ln8xKE3dNB4Ebyq+ftU2em4cWA1G/AHo96endgUBAsaOZ9G02g7g0VhpRMovu8ZJv5rcJxbh+rHPq59l5DETB3CcL0fVYYWGwrq7O8cm2aCsDAFXPbdjkW0bNguDRDehV7ber/rihjgCYAFFQAnqfHxjoOwQYydBbVDMAcOTZxyvWLZMPXBxS6r/tjlRDlrt7e3uvAeDF1v5P42/pFun0pc2xBwAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARrSURBVFiF3ZhNbFRVFMd/985H26m1VEoL0zj0Ayqi6IZElpiQ2MSgIeJCDZGFuEEXJH4bG9QN6spoImiMIaExbREEYoIxhgEb1CZNjFg6lHnTacNHW8QW7Mx0pjPvuKDVprR9X1MX/Jfvnv/5n/89N++d++AOgip2QolRQZAWhCeA9cAqYDlwHbiCcB7NcTKcVA8wUUztopmRQarI8wbwMlBmg5IGPkGzTzUwXowaimJGEmxHOADc44L+F7BLNXHEax3aC1kEJQatCB24M8I077DEeUfE2+Z6MkOCVuBdvHdYoXgPg7e9JXGJ6aPV4SXHPDARtqs1HHVDdlWIDLAMEwP3R2sxjOGnSa1mzCnR3TET3mJpjABUkedVN0THnZEYFQQYwd7r1y3STFLr9DvkvDNBWrBjRIfS1B6J0pAdolFyNGSHqD0cRZVlbKiEKOUxp6U5N3Pry26RNZRm9ZUE5ds2o4IRIIgKRih/ajOrr8RtGVI2dObKOiUA91tGrDjUjap8cH7FZRuoOfirZQ5hvdPC3JgJW0aEHm9cfP3JBsscYkNnDtyYWW4ZoYIrPa0DKKptVzQN52YUf1vGSG548YDcVRtKN+0V9B/cvABGLGPSJxKLrqeOJm0oWWzI7XBzzLotI0Z3PII5fm7eNXPsHKM7NxVFZw7cdOaUdUymjMHwGlKdUSQ3COSQ3CCp9iiD4bXIZKllDkXUaWnOJ4Be7qKUS0ClU64D3KCcOrWSlBOS485MjxhfOeU5xJdOjYDbqfnWFTkG1LjhW2AUP+v+t6l5WmiPG64N7HFjBDxerMSgDXjWS47ZKBT4unFLZLfWuqREpCyrVElAROULOgDg95lTea1NpVQmmM2mNly+PN4JhRm+VzOVwG9AvScXwERaj2/dFT5wadg/aVtfVEEJSb+Wn2LJZNLTPwDVxA1gB7N2xw1EkH37q445MQKglPjQ0pSH5+vr6+u9/dAAVBNdwIdecvzQVd7V/l1F0ksZPtOs82wGgCFaAeuxfh4MX/Ndfe2D6tNe5E0wC1obRTGjHiWPyXNgYwidhakpNfX6Ryu+SWWU+2MqklM+35FkMjlcnM4Aai0GwitOOG0nKk6e7Sm97lJSBPpKCoX9hmH8AUvx49ygA3jaKi5mBGNbXwy3u5DIiMjv+P09hmGMzl4ovpkLVGcLqr+kRKoWikmnVWrb7rrPEkN+WyOLiMqjJC5a90Yikb5oNJqfL87vtuiFoO7jz8s/653hmsK3zL9Z8vHBZcesjIioKY05oLTuNf2+WDwezwIkEgtflYremRkMdQXa7l01ddt0cLq77JcX3qz9fgFaBqUSGvoDoVBfb29vzonmkpkZOEVpZaW+UFVpRmaeXRvzXWvZGf785oTv32MikEbkol/r8w9t3Bjv7Ox0/WZbMjMAPcfLNj28bvKMzyeBfIHCS3trvvjxbGgEuIFScR/0PzMwcHEvmEtZR9HQfaz0/WxMZdo/vftQc2Pjlubm5jqWeBPvCPwD/KOH+jnO5aMAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASxSURBVFiF3ZhdbBRVGIafc2Z2210hbeWnpcQVUC8kwBUJXJBIgwkgBEPEC1GMxhgE4gUJJsYERMWI3orYaiqgrYSWH/mvMaQLciE1RAKUkrLbbhMobQ20/LT7N3OOF0CC0O7szGwv9L3c73u/93vnnD3zzYH/EUTBKx6sHUvQWgR6GTAdmASMA26A6AYuofUhQnYTVevuFlK6cGaObC9DGh8i9PtAKA/GEIKvSRZtZfnbA4VooTBmjlWvQFADPOmBfRN4l8Xv7ffbhvTF1lpwrHoTgga8GeE+by9NNRvR2tfDNfyQmVv5MYJP8L/CAqgidtai/sgpP0W84d7WavBV43Eo0CtYvOaAF7K3Rg7sKKU4Hcf71sqFfmz1DEvX9rslevvPFKc/YnSMAJRhyA+8EN2vzMHasQSzveR3/HrFEMV2udv3kOlaJmgtIg8jYcMcqpu1oGXJhMi0oJQVGaV6Dvd1day62DwnaWWd+GHSciGwz01rHraZXuaUETbMoe6qVR3Ly6fMD0oZAYJBKSOvVEyd3z3/jVjIDCSddYSjzqPwYEY875RRN2tBS4kZnDFcrNQMztw144UzjjKa6W4787IylU4ZSyZEpuWKv1w+dWohdB6Fl9NsnFNCUMqKnHGRO34PYnz+Ld2DFzN3nBIySvXkjGt1PQ+d23l3dB9ezPQ6JRzu6+rIFT/Q25lwVNHkfCDDwYuZFqeEVReb5wxYmQvDxfqz6QtvnW+e69yZcNR5jOKWgKbZKSVpZUOV0bpnG3vi0YxWXUAmo1XXnp54tLL5p+dSyi52FlJRt625nwCavxlDyrgKlLjm5o9byPBkFr456IbkfmWq1t1FsMM1zx1q3RoBr4OmpT4F+jxxndGHrbZ4IXozs3RtP0Ks98R1ghDrvYz/4PfD6ti39Qix0leNh6H07siaL9ZJKYuKtA6lhSgKaC0sWwYATENlLSmVECIZTKcHZ167NtAI9gO6PzO/1ZRg6XPAFF91AJnKDES21NaYN26l8uVoLWyhSZhS/345kUj4/+Q9XjMPdBR/9wl6Qn3TjyWnzyW88i3Y5e92BmDx6tPAV35KjDnXftqHEQBhKDXZvxmA4p5NCJzH+mFg3rxzvXzn0ZN+5BUoW8p4YcxUbbZQ4nXyGEIfhrDt7MS6o/tEOm07Z48ArTPCMPYnEomewpgBeGl1HMQGN5SSk381hdsSNzwqag1tRbZdHY/HL8JoXJwfr24AXnVKK7rae/mpz3fs8aCQ1FqfxzTPxuPxf7243V9oOMESa4XOvqgDZtlIKTKVHpz4w6Ej+ZbUWlgIHdNStkYikbZoNGoNl1f4lQGM3V8us0tLfhmhvh6/98Tu0hN/XslVQ2uRlahOIWWrMozLsVgs7aQ7KmYAAnVb67PjSh+bDsKtHX9Ubmv4dQRaEiE6JLQHwuG21tbWjBvNwm+z+8hmU+/Iu8l5akwo8uA34/bg3+W1B088nKdhCK2vmFJemjV7dqyxsdHzyTZqKwMQ2r55bmpK+SktRABb2ZO+2//9E+djvcAthIgZ0P5aZ+eVzaAKoTeqZgCKt238LP10xYaxZy7tq/j5+E5Ms629vb0b0KOt/Z/GP4jqqfL5oxVsAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS8SURBVFiF3VhdTBxVGD3f3Rl2oRAstZXaBGxpoxaxhSVpE0ha0ib0qU/1QX009UHjQ5Oa+BO3pdTEn0QffNDGGH+SprGUqlUTSGtcKfGHBELALYTuwGJsSyEVKLuz87Mzny80sQjMzp3lQc/j3O+c8525N3fuXOB/BCq0YNNoU5lRZBwipsMM3glgM4ANAO4AuMnM14QQl7LZbFeiNpEupHfBwtRN1q1Xc+orBHoJQHEeFB3AB45w3hrcOjhXiB4KEqZxvPEIM58BUCFB/4vBRwdqBi4G7UMEYjMoqkVjzHweckEAoIJAF6LJ6BvgYC83UJiG8YYYgDYEn2EC4VRUi74eTEQSi0vrfBCNZeAy85GB7QNfyZClGtk9sfuBkBvSIL+0VsOspVg1w9XDs36JUstMYeU1rE0QAFhflCt6WYboe2aaRpvKDNW4jfy2X1nohmE85Pc7pPh1MYqMQ2DvIBER0ds3tvc1lzRvU0mttNme6tF7xmPTsT0mm178kuJIcSuATj+9+V5mxHTYqyYiInpXddd4y7qW/SqpVQCKVFKrDqw7sL+7ujsZpnDWS4OJPX2WwncYBj/uVdO+sb2vlEqfWG6sVJTWtW1q+81Lg5h2+u1NZgN42KuguaR522rj+0r2bfXSYGZPn6WQCbPBq0AltTLIOACA8KCPngDIhCEseJXYbE+tOg77Vh5Od/PuaRH+wzBue5X06D3jq43HM/FUHk6rvpDlILPM+rwKYtOxPWk3Pbzc2IK7MHxi+sReLw0Ge/oshczW/KNXjclmcetk6/YrmStxm+1JAJbN9uTlzOV462TrDoutiGdjJOK+e/NLqE3UlkYikT8BlPvl+sC8vc7eMlQ5lPFD8j0zidpEmkCf+uX5xCd+gwCSB01TMU8BmJbh5oFpS7FOyxClwiwez4/JcPPAMZnjPxDwxyqqRc8CeCaIxn1wcG7m4MyLQohwmLnYJAqrzJRzhAoASsi1c0K4RJQtMs1M3Y0bcx2Ac48eNEw5gEEAjwQKAYB1nksfnTvjTrlG3hwmhxgpRfDV0VQqFfiXN6pFmwHEAYSkRRisv5/5wv7eSMkq5IDPg93OAOiv6e8F8E4QDbvX6g0QBAAo5LpbAocBgLI/ymIAPI/1y4Fn3FvZt9M/BfF3AdcRQitImHhLPAcXzwLeh9D7YMPW3810cpYd7+IVwGxRKHQxlUpNFSQMAPTv6NeY+bgfjvmt0ZXrt+5IWjIDI2HH+UjTtN+BNbg4j2rR8wCe8qpztdzowvPzX0pYZJl5CIrSr2nafR9u3xcansjhBXb4IIVp/UolrLuZ9On0d/lKMlMOxEkWIlFVVTUSj8dzy9UVfGYAoP6X+sNik/h6BX02PsycMy8Y11fTYCZbwJ0gIRJuKDSaTCZNL981CQMA9b31Z8Vm8a/Tgd1n/aq/utC9Ai0LonEBjKklJSOJRMLy41n4ZbaIWXv2uYr5imYqp6p7z9xZdyb7ZvqHf9YxoIP5uiLEtScbG5MdHR3SO9uazQwANFxq2EuPUQ9CUOHA0U/e/dj+2b4NYB5EyRAw9vTExPWTgFsIvzUNAwC7vtnVrjyqHLeuWJ3me5nPoCgjY2NjNwHwWnv/p/E3iQfm3w9KV7kAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATaSURBVFiF3VhbbBRVGP7+M9NddtmyvcYKSbGoAYn4REJNIGmRpMREfMEH5YEYY6ptfCCBxEgEvMR4eeCBtBYa1EIIsbVAFAIIsis0og1GpJbWdrdsiUBLuXQp3e3MzpzfB23Cpe3pzGwf9Huc83/f939z5nLOAf5HoGwL7m4ryjWssdVgWkPEi5npURAKwbgJ4CoYF5n4WyBwrLZy6G42vbMWpv5MOJ9s+TYz3gIQUDtzCkw7DGgfb6gcHs5GD1kJUxcJrSWinWAUuOjgFkt+vXbl3QNe+xBeyMyg+lOhLQRqdhUEABgFRPTN59HQu8zebq7mhVxSEdoKovfgfYYJoMpzCZ91pMk87UHEHeoiobUEavai8RAYkgTWvlkxctAN3VUj2yN5eX6y464fralxG7p4vGZF8rZToqt3xs/2OzMUBADykZGb3BAdz8zutqJcI2MMYjqfX7cgTjEHHnH6H9Kd+hjW2GqAlEF0PZhataixfX5h1QJBvhLJ5kD/jaN9J7url1l2amo+U1BwugpAq5PenD9mTGtUJboeTK0v7+0rK3qhQpCvFIBPkK+0rPjFivXP/hnTtWBaaSPUPg/CzTvzlKpg1aLGdp+e+/REYz49vGTlooZfVBrMWOy0MTdh5qoK5hdWLZhqvKzo+TKVBpHa50E4D0MoVIqSr8TL+L8omnZP47pOCWCMqEokmwOK8WvT8LnjoCsA7mZmUFXSf+No31TjfTeOJKbhNOUNmQiOwxCjXVVzsrt6mWklOyYaMzLDHae63ihXaTCpfR6E4zCSKaKqsexUoOnswifiQ4eiks1+AKZksz82dDDadHbhk7ZMz1I3RlGnvTleAdRFikOEsb8AhJ1yHSA5agbnbaoaHHVCcjwz/ywx+EunPEcg7HYaBHC7OdO190G47oqrAuE6NPGhG6qrMDUrkrchaYMbrhKSNrhZ/gMeN1b10dA+ML3iReNe2JL3f/ZqQa0Qwu9nDhhE/hxmsmyRAwC6JjOWEJKI0j7DGF1y5cpwC2CP8z2F2XkiP2zr1nkAj3mLAZhpMbx3a3hnckiMTZfDTDYxErrgM92JRMLzlrcukrucgCi8nCcw+MSe2Xs6orMSbhUsoMnT6QwA1FaOtIHxqReN2G/+Ng9BAIA0Ked5DgMA12lkCwDlsn4ijNyia8d3zf7Ri78EpC1EPCthtlXC0qRYB6gXofc1YSNz/Is5rYZBtrp6EjCbpGkHEonEQFbCAED1c8k4GBudcM6fmnXscqd+06UlM9Dlt+2GeDz+BzADB+f1kTnNAL+kqhu6rHfv3Rr+2oVFmpkvQNd/jcfj9/24HR9oqKCBawyTVuk+zp+sxhyj0cMNocPT1WQmC8QxFqKztLS0KxqNWhPVZX1mAOCT1rw1uQX2oUn0+fT+4P5z3wd6p9JgpoyAvERCdEpN647FYobKd0bCAMBHzeF9ecXyodVB4kLOzwe2zzk+CS0Noj4B9OQEg12dnZ2mE8+sP2bjMEeTr6UD4eWBkCwdvzZ6Rwwd2TX7h3vrGEiBuVcX4uIzS5fGWlpaXH/ZZmxmAGBzY0H53AXWaRKcI23Y3+0INcZ/9w8CSIIopgE9L1+61LsNkNnwm9EwALB5V8EHJWWZjV0/BVpPNoW+gq539fT0XAXAM+39n8bfE7XcWzV66JYAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAR4SURBVFiF3ZhbbBRVGMd/58x2u7vQbmtvssSNAjaRiE8k8oAPBowkVTAGTVAJJMYXiTGYNFxisHiJ7ZMPQiIxxhRLCG1tjSBRubiAJEhiNDaFSlu6baRQELsI7e7sZY4PlKT2sjNzZvvC/3HO9//+33++M2e+GbiPIAqesYkSLNYgWAssBRYAFcBNYBjFBSTfkuR7GrhTSOnCmfmYcgTbgbeAoAPGOIJP8dPIVhKFKKEwZppYj2If8IAG+x8Eb7CNDq9lGJ7YCkGQXcBeIKSZJQi8zDNYHOMMu/XL8WYmxHvAbrx3WABPc5YsxzntJYke7m6tVk85psNCsZ4ddOqQ9Qr5hDJM+tF7RuwwimIxOxh1S5Racml2MjdGAMqBeh2i+840UYJiBGfHry7GSVHj9j3kvjMWa3BgJOQPjXe82BEz680htU2lzXpzqP2F9ljQF0w6UAlRzLNuS3PfmUa+Al7LW4k/ND68Zfhy2B9+fOpawkx0RfZEliSzSbsbsp/tbHJTms4z85hdQMtzLednMgJQVly2rLmu+RcHOkvdFqZjJmIXULe4blG+9XW16x4phM5U6JipsAvwS/+DXtYnUOm4ognomLltF5C20tds1q860PnXcUUT0DEzYhdwuPfw5XzrnZc647Yqgrw3ZCbomDlvF7DxyMYnE2aia6a10dRo1+bvNq+wVVH2OlOhY+Ynu4BkNhmM7Iksaetpi6Wt9CCQTlvpwUM9h2KRvZFHU9lUwFZFEHNbmPv3TAPzCfAXEHbNdY5bGCyknjE3JPeduTtifOma5w5fuDUCuoOm4n3guhbXHtdRfKhD1DNzdzzfqsW1x1ad8R+8flg1cgB4xVOOybA4GP0sukVKWVysVNAUorhIKZHNySIAn2FlslJaQoik3zTHll25kmiD3D26VzNh4HfgYU95AJmRiWhrZJ/vti/llKOUyAlF3CfVmZ54PO79k7eRlUAMb/8TVNWpiv3hiyVxXX4Wmr390AA4zhCrCCB4SjfF/IF5P1eeK//NQxVCWNYNvQNgKkx2AU7G+mnw3TGu1pysPOVF3gIrJ2V/Ycw0kEXyKg6G0MkQlshUn6r6WmREzj56FiiVFobREY/Hr3nfZvdwjFFWcRPB804pZV2lR8PdJXmH0jxQCnoCuVzrn4ODgzA3P85bUbxkF1b8t7/nofbIIQ2FpFLqD3y+X/v7+//34vZpJMsPgzeFKVYrQ5XPFiIzYqz6ZPURpymVElmE6lNSdkej0YuxWCw7U1zhOwMY7xprc/Nz38ySX1WeLT9Y1hXuzZdDKZGRWANCym7LMHr6+vpMO905MQNQtLPoQKY0M206CA0Fz0WO1vwwCy2JEJclXCoKhS52d3en3WgWfptNIOPPvC5TcqUVsKL3rhnjxo2aE5UnJscpGEepXp+UF55Yvryvra1N+2Sbs84ABN8JrkhVpU4roYqwyC34sfrzefHQCHALIfoMuLRhYKC3Aay5rKNgCLwd+EB8JJKlm0pbahctWl1bW7uQOb6J9wX+A8zucxGCTS9IAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARZSURBVFiF3ZhbbFRVFIa/vedSZkTbClJow1irNpGIvpDIAw+NIYghqTHig6JGIoLSGEK8xEhoKpKovBoJg1aCaVNpsYhIRINh1D5oDYaIvUhn2qGhNwi2RabtXM7ZPrQk0Ns5Z5+ZF/7Hs9e//vXvtXP2OgduI4isZ1S1d0JmPVAJrACWAYuAq0A/0A7qWzBOIaquZ1M6e2bU/kLwvAu8AQRsMMZAfAK+jxCbR7JRQnbMqAMbQYSBuzXY/4J6FfFas9sypCu2UgJ1sBpEI3pGmOSJo6jwbpRytbnuzHCwGtT7uO+wAPZAeJfbJHqYPFqNrnLMhAliI2LrMR2yXiHqUAGkYugfrfkwDMb9iO3DTomaxyz1HrkxAlAI8m0dovPOTN4jQ9h7/epiDDJFTu8hjc5k1mPDSBDvWDPrIkm29Cq2ppJs6T3KukgA37gNkSD4nnBamc4xq7SuxDvWzwvdT1Na4UeGAL8fGXqG0op+NkVtGrLUmQ4dMw9ZBdTxeGs+/odnWyvAv/IwFb9by6gVTgvTMVNsFbCBUNl8609x733Z0JkOHTOLrAL8yKVu1qew2HZFU9Ax859VQApz0GJ9wIbONdsVTUHHzJBVwAl6u+dbP0ZP3IbOvBsyGzTMqFariBc589gIqfOzrQ2TPP8ykdU2hCx1pkOnM2esAsZJB4qpf6CJnkgK8yKQSmFePEIsUkzdgxMYC6xlRMRpYRoTwKcLwXsJyHfMtY9RCJQgXko4ITnvzOSIccgxz5lIrVMjoD1oGnuAy3pcS1yGzF4dop6ZyfF8pxbXGjt1xn9w+2GlwvXA865y3AzDbAiVfVglpczLUyqQFCLPp5TIGNIH4PWY6YyUphBi3J9MJlb29Y00gXGD7tZMPnAOKHWVB5DXUyOhJz8Pey+NTtiWV8IQirhXql874/G4+09eFV4DRACPfg7UPbu+/zK/4VxcN0MGDrv8oQGIbS2g9rlJsfDHf1pcGAEQHtMscW8GgMFqwMZYPxPegWsDRW+e/NmNugmmIWUsO2ZETQbYhI0h9BZa2kgveefk1yKRNKyj54BSKeHxNMfj8cEsdQYQ22LAW04o+XV/ngq2xK9qKioFHXmGcSAWi/0NOflxHm4EnrUKy2sf6ly+4YsjGgrjSqm/8HrPxmKxWy5ur0YyK2wXycxalectnCtAJpKJJTuOf2c3oVIig1BRJWVbKBTqiEQimdnist8ZwNP3caVRXPDNHPnV4r2nGwpq/+iaL4dSIi0xe4SUbabH0xmNRpNWujkxA+Dr3VefXp4/YzoIRmK/FW9u/GEO2jhCdEu44AsGO9ra2lJONHNxzABIG2OvyGH/GrMwELrxzHMlcaVox/Gfbo5TMIZSXV4p2x9ZtSra1NSk/WbLWWcAAmdrVk88uvQX5RE+Mqax7PXmz+443TUEjCJE1AMXnuvp6aoBM5d1ZA0LWnd/IJL7x+/6qqquvKxsbXl5eQk53sTbAv8DzFJ5Mvw8/r8AAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQLSURBVFiF3ZnPT1xVHMU/983QYcbqlNZoCmEkqCxMtJsm+gfQ2KaJqaYurDHaZeO2dmH8lZg06qZLtYY0RhqkKFrd1KYJE2VhqiQG5YftDAwEShFpARmGN8y84wIxhQLvx8xA0pPczbzv955z7u97B+4hmLLXKN0PHASeA54A9gJ7gGngBtAPfAdcwpj5svOXBVIN0odIC0jyULJIHyDt2m7pqyEdRZr2aGJtmUZ6YbstgGSQ3kFyAhpZKQ7S20jlH/Y+zLxboom15a3tMnK0DD2ythSRnt9qI7tKmCNu5RZSTRBZVkA7bwK7A+a6oQZ4I0ii/wm3vI9MAtEghB6xADzsdx8K0jMH8WAkBgudkLRhVJC3YfQrSEYh54EjBjwbQJtPSF+4jfuYlJ2Rftc6uC31Rr1trJ9vhZlf3YR0Sl3rGVnBBanLg5lftsLMDTchtjSymRlbyngwM+5XWpAFwAZ2bBoCeZcY20DEhSmPMW4xqxBkAfjHLSAPN12+T3jgmfOs6D8EMTPpFvA9DG32/RvIeODZtEHKA+mc23iPSgu3pd715sstqbdaynmYMy1+pQXpmS63gBxEa+GxDkjmYQTI52GkHZK18PgiVHvgSfoVFmQB2AmMAXHfud4xC9RhTNZPkv+eWT5inPOd5w8tfo0Ex/IVebJCp+bJoKfmUgwdq5CZY0EllXZNlc4DgcnvQrHYlmhsfN2yrEhEitrGRKokUyhaVQDhkLNUsCzHGJPbYdvZJ8fHZzqguJJeqpk48BvQUFI9gDU/P5M4dOjT8NjYond6UzQiE7b002Amkwl6OVuGMbPAK9zROoEgac/p0xf9GFmmVwhLjxbg1YaGhobSzCzX2A18VEoVOy9f7o63tWVKURFynLryPO1IYaAbeNpvanhiYuKRAwdaTDYbuHcdcBw4W3rPABhTAF7GwyF0VdrS0tJDp059XYoRpLwJhTozmczN8pgBMCYNnPSTEm9tvRTr7p4OyCjBQKRY/CSdTv8BlXk4vwC86BYW6e8frD98uD0AQ05SL+FwTzqd/uvOD5Uw86Cx7WuKRDbcxa1sNlt35MjHkVTK05FFMgWMUrKsvkQiMZBMJgvrxYWDat4QxvxtjY+/Vqyt/Zb1G0u7z5y56GZEMksWzrCxrD4nHBpMpVI2wNDQxlelij1UV42Onl+qr7/rdBBLJn+uPX78hw3SchgzZMG1qlhsoK+vL++Hs3Kv7sPD1VY8/qdTU5NY+Sk0NTWVaG4+G5qb+3+YCBaQroctq/+p/ftTHR0dgVe2iv6FEO3peWZx374fFQpVUSgU95448dl9V65MArMYkwrBtZeGh6+/B04ldZQN1Vevvm9sO/fAl+2tTY2NzU1NTXVUuBHvCfwLna16k1MlopgAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATaSURBVFiF3VhdbBRVFP7Ondlddvqz/aERARtFMUos4YFIH3iAxESICfCABtqkCRiJtjGRBBODivhH1PigEovFGKhJXWktpdgQfDCugEFrCEhbitvdditSKIhtge52d3bu8YE2AWx7d2a2D/o97jnf+c43996Zsxf4H4GyXXD25ta8MSOxiiWvAWERCPeCUQzCNYAGwHyOGIf90I5erX3mZja1s2Ym8EJDYZq0V0D8IgB/BpQ4gN0ez9h7wx9tGs5GD1kxk1sdXM+EOgBFDuh/E9NzN2s3HHTbh3BHZzJqvt7BhEY4MwIARUz8jVEdfB1gVw9Xc0M2qh95gwhvwv0KExFWeh7vTJu/Nh9zXMQpcXxrNbqpMQmkBNYnPt3Y4oTsqJGCl/YVmOasKJxvrekwpEv54MieyiG7REdnxjR92zEzRgCgMC3Ey06Itldm9ubWvIQ/PojMXr9OETdYu8fud0i3qzJmJFaB1UZyvHp8b1V5++qyuQu8mpiTsuTlIx0DvVvqTy6Lm5aKbyRE+kkAzXZ6s73NWPIaVU6OV4+Hd63tXbtk/gqvJkoBeL2aKF23ZP6K8LvrIoZHSyh1AKXO3bB/ZgQ9qkrZW1XeHpjleWyyWIHhKaurKv9FqcO0yHZrdgkAz1VlrC6bu2C6+FOL5z2QgZBS527YN8MoVqV4NTHHTXwcszPuaRxOXs03VAkpS15WxC9loHM9447G4WSbDaoyjnQM9E4X//bMhZhShjDtA5kMDsxQuypjS/3JZcNxs2Oy2HA81fF8Q3u5Uoah1LkbDs4M/aBKiZuW/+FXDz3UcvpCKGXJfgCplCX7m0/1hxa+1rowkbJmZaAUstua7QmgpLoxN07WnwACdrk2MDLqN+fhw6pROyTbK3NrxKB9dnn2wF/YNQI4HDR1ab0F4IoTbga4okt+xwnRkZmRPZVDIGx1wlWCsNXJ+H+L6gI5NcEGABVuatwBtoLFbdtrhBA+H7M/SeTzMFPaEh4A0DVppoWQRJTwJpOjZRcvDjcB1gTdlZnCLY2BlMc6A+B+dy4AkU4Olxz7uE4khsYy5TCTRYyYLvj4+Vgs5vovb171V8slUQhu7hMYHOhs+dL4oz3mtEIaqHd5OwPcqK04AeADNzX8g10nXBgBANKknOfaDACMlszZAUA91k8CbWzkUuBs049u9CUgLSGiWTGDnSvTuqBKgJVD6O0gaZmB35qbyUxa6uwpwJwiTTsYi8UuZ8cMgJHdG6JMYpsdjr//5FHfXz3XHEoyA90+y/osGo12AjNwcZ5TE2wE8LQqz3v90vni458ccCCRYOaz0PVT0Wj0jg+37QsNFYTJ1axZT7DQC6fOSY7mnw62ZVqTmdIgjrAQXaWlpd2hUCg9WV7WVwYA8jbXrpH+wkNT1Of8c23BnL6feqarwUymgOwjIbqkpp2PRCJJle6MmAGA/E21DZZR+K/pwHf195+L2vd/NwUtAaJeAYQ9htHd1dWVsqOZ9W02gevsfzY3NbqcvTmlE7+J5M2rgdMHvr89j4E4mHt0Ic4tXro00tTU5PjNNmMrAwBFle+XpwLzjzEJD6RlFZ1q+Nx3pXsQwAiIIhoQ3tjX17MTkNnQm1EzAFBQsettM3DfNv/FM81FnS37oevd4XB4AADPtPZ/Gv8AkvXQkIP4nXQAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASpSURBVFiF3ZhbbBRlFMd/3ze7bXdp0yKlQI2NIqZlK8YHjDxgFEIikVhKAibeooH4otFIosFLgvdEn9QQHojxAkoIFChRMWBCXC5GxRgb6sJSWrrlDgXbUrrbndmZ44Mlwdru7MxsH/T/ON/5n//5z5n55swH/yOoomesb6rAMBaDNAExYAYwBbiC4hxwFORrKNlDouVaMaWLZ2bOksk44VeA5xEiBTDSiFpHqbxP267+YpRQHDONS5cjagNwkw/2n2j1DH+07gxahhGQr2hcthZhPRD1mSOC8Ag1DQ69yYNBiglmJtb8BvAWwTusgAVUN+S4nDzgN4l/M41Ll4NaTzHfO8UDVNe3c/l40h/dD+5ursKkC3/viBv6MKzbad/d55WofclZ8hoTYwRgMnb4ZT9E752pb6ogpC8WuP36RRoVnub1O+S9M4axuBAj0bLS9M6P18SzbdtPSaLVzLZtP7X9ozXxSKQkU4BKFKwHvZbmvTOx5i+BJ/JWUlaaPrf/s5OV5dE7R6/1Dw611y5YOSuTMfPfEKU2kWh9yktp3jujmO0W8tUHLx4eywhAVcWkORvfe+EXVx1HYl5L825GqHULWXL/PTPzrS9dOO82Vx3lrjMafnazKW4BJWFjepD1EVQXXNEI/JgZdAswLfuCy/r5AnSuFlzRCPyYuegW8E3815P51lv3/ZQqQCfvDRkLfswcdgt48tUP7+0fHGofa61v4Fr706+vm1cMndHwsQHID24hmYwZqV2wclbL3h/jpmX3AKZp2T1b9xyK1y5cdcfwsFnmrkPca2nevzONK8rBOoNQ6ZlbKBQDGOmbOfL9kBea9878PWJ87pnnBcKnXo2A30FTW28Dl3xx3XEJw3rXD9GfmfbdfShZ7YvrBiWr/Yz/EPTHKta8GXgsUI4bIc6WuqG257TWpaUikaxSpWERlbN1GCBkOFZOa0cplSnJZofmnD3b3wL2dXowMzNXVFJmtQG3BsoDaJz+uuHkhpBjDhfKEVG2ElIhLQeTqVQq+C9v47L5IHEkyHmCyFTrzKZK60rKb4IcbAx6OgO9yVNMbSgD7vObotweOFRtnv89QBVKOU6vvw1gNGr61wLuY/0YCIl5fpp5en8QeQccW+uu4piJx3NoHqeAIfRGKLBqzNM7lNi2e/Q4EDGVYexMpVIXgj9m13Ep2UdNwxXg4UIpVVbvd5W5y3mH0jwQgWSZbW873tPTAxNxcB5r3gascAsrdTLJW4aPb/WhkBGRI4RCv3V1df3jwx3ykSw/cvazKqQWCXryeCFa7KEaq+fbQlOKqBxKOkXrRF1d3bF4PJ4bK674nQGM+iVNthHeNU5+qTbPbqnK9Z7Il0NEWRqnW2mdcAwj2dnZmXXTnRAzAOHYQ5stSv41HURzgz/Xml17x6FlUOqkho5wNHoskUiYXjSL/5iNwEqnV+mInu+oUN31a4bkeqdlU/tuvIUCaUROhLQ+etfcuZ0tLS2+d7YJ6wxAZPaiecO6/IAIYUTsGWb3J5PsqxeBAZTqNKDj0e7uE2+CUwy9CTUDUFa/6J2sEX2pwurfMd0+8wWh0LGOjo5zgEy09n8afwEcs7T5cvn0GwAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS2SURBVFiF3VhbTBxVGP7+szPscmkq1FZqE2pvUYvYwpK0SUla0ib0iaf6oD6a+qDxoUlNvMTthZp4ifHBB22M8ZI0jVCqVk0gbeOKxAsJpAG3ENiBxdiWSypQdmd3Znbm9wGaCAKzc2b3Qb/HOf/3ff835+TMmQP8j0D5FjxwYGhdJlN0lIibmbEbwGYAGwDcBXCbmW8KIa6k0+mOWKw6mU/vvIWpqRkvV9XsK0R4CUBxDhQdwAe2Ld66cWPbbD56yEuY+vrRY8x8HkCFBP0vZhzv69tx2W8fwh+dKRzWIszcCrkgAFBBhEvhcPwNgH29XF9h6upGIwDOwP8ME0Bnw2HtdZ8iclhcWq1+NFaAw8zH+vp2fiVDlmpk796xBwIBR4P80loLM6ap7BgY2DrjlSi1zBSFX0NhggBAeVFR9mUZoueZWfiOqJPIbfuVhZ7JZB7y+h1SvLpkMkVHAXYNEgoJvaVlY09DQ8l2VaVKy+KJri59NBKZ2mcYrvyS4uJQE4B2L715XmZE3OxWEwoJvaNj62hjY+khVaUqAEWqSlWHD5ce6uzcGg8GKe2mwUyuPsvhOQwzHneraWnZ2FNWRk+sNFZWJmrOnNn0m5sGEe/22pvMBvCwW0FDQ8n2tcYPHizZ5qbBzK4+yyETZoNbgapSpZ/xBdCDube0AIkwNO9WYVk8sfY47uRgdC/nlhYhEYYn3Sq6uvTRtcaj0VQiB6M1X8hKkFlmPW4FkcjUvmTSGVhpbH7eGTh1amq/mwazu89yyGzNP7jVGAYXNzWN77x2LRW1LB4HYFoWj1+9moo2NY3vMk0OuTYmKOq5N6+E6upYWSgU+hPAeq9cD5izrNIt/f2VKS8kzzMTi1UnifCpV55HfOI1CCB50DQM5SyAKRluDpgyTeWcDFEqzOLx/IQMNweckDn+Az5/rMJh7QKAZ/xoLIV9cXr6yItCiGCQudggCqrMlLWFCgBKwLGyQjhElC4yjFTNrVuzbYB9n+03zHoANwA84isDAGZ9Njl7/LzjTGRy55BNjIQi+KehRCLh+5c3HNYaAEQBBORVmPXU+19Yme8TsgJZ4HOftzNAb++ObgDv+NGwzO5uH0EAgAKOs8V3GABYt+6PCADXY/1KYGf6Tjr59o9+/B3AsYXQ8hImGm3MAs6zAFwPoUthWXrq3XbmtO1euwqYTQoELicSiYm8hAGA3t5dGjOf9MIxMt92ZM3eu5KWzMBg0LY/0jTtd6AAF+fhsNYK4Cm3OierDc3PPf+lhEWamfuhKL2api35cHu+0HBH9gVm+whRsHy1Cnb0VDJ57rtcFZkpC+I4CxGrqqoajEaj2ZXq8j4zAFBb+0uzEJu+XkWfM6kPLxqZSyNraTCTJeCMkRAxJxAYisfjhptvQcIAQG1t9wUhNv/rdGCZPb/q8692rkJLg2hUAMNqSclgLBYzvXgWYJktYGbGeq6iYq6BaH3V/WeOMzOdTr55/Z91DOhgHlGEuPlkfX28ra1Nemcr2MwAQF3dlf1Ej3UBARWwbf3e6Y8t6+dJAHMgigeA4afHxkZOA04+/AoaBgD27PmmRVEePWka19sN/b3PoCiDw8PDtwFwob3/0/gbh/Lm30zcQi4AAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASdSURBVFiF3ZhbbBRVHMZ/58xeSgNCqRegsamt1EhEXwjw4AMmJGpAEhNoVOItxgdFQ1C5qqQiKiVRHtQIGuKDXNItFJGSoFFYpIltExIj9EK7WxbTUi7BFqHbTndm/r60CWDp7MxsX/ge9/y/7/t/55ydOXPgDoLKtWDVQZnkDPGUgiUIs4DpQCFwBTgv0KLhpwE4UlmhrufSO2dhPtstBSrEOhRvAxOyoKSV4stIiC2rnlV9ueghJ2GqYrJUYAcw1Qf9H6V4fe0yVRu0Dx2ELCJqS0w2CsTwFwRgqgj7qqrlQxEJNLmBwmzdx0bgI4KvsBLFpqp9vB9IxC9xeGvFgmiMAkdg6foKdcAP2Vcj2w7IFDNDEv9bayz0Soay9ctVr1eir202lGED4xMEoIAQq/0QPa9M1UGZJCYXye7x6xfpQbjP63so5NVl+IXoGiQSIr14Lk1l0ynVmmmOw4WOHjrrGpln2a78/KjwJLDfS2+et5mCJW41kRDpFYvpnFnEAq0pBiJaU/xQEQveeoZEyGAgFz63wvt/RnjYrWTxXJoiYR4ZbSwaZvaiuTS6+ihmeW3NzwNghltB2XRKxxovn8EDufC5FX7CFLqKaqYFGR/G3Vl3NKLrlQBccytwHC6MOS70ZOHzb9YdDcNPmItuBR09dI413t5Nyk1DMfaEjAY/YZrcCuoamWdmODXa2OAQpw43Md9NQ5S7z63wHkZxzK3Espnw1SEebOsi7jicA4Ych3NtXcS/rmOmZZPnaiPEvbfmEZUxmZgHXcBkr1wPuGoMUrT6JdXvheR5ZSor1HWE773yPGKn1yDg86ApFpuAS364WeCSZNjsh+grzPDxfJUfbhZY5ef4DwE/rLbEZDfwQhCNG+HY9t7ta0tXaK2jUZEJplLRsIiybB0GCBlOxtLaUUoNREyzf3Z3d18N2CP8oGEmA38CJYFSABnzel/tF0/vuNbbNZgtR0TZSkiFtJxoS6VSge4A1lWoq8CL3DA7/iDScPjTg16CACglBlrKLHi5pKSkJFAYgHUVql6ErUE0Uqd/qT/TsDcVQEIZjlMUOAyAeS8bIYtj/Sjo7+vpOV797vEg/g44ttbJnISpfEJZ2mE5WRxCb2rCzmSO16zZnzH7/W9TkSFlGLWpVOpCTsIArHlOJQXe88Jp+WPXkfMd9Vd8WopAa9S2tyeTydMwHhfnMYkJLHOru9LT0nZg26JqHxYDIvIXodDJZDJ504vb84WGGwyLN00xFxrhaMHtaiyzv//onpV12WqKKAslCdG6ubi4uDUej1uj1eV8ZQA++LZ7ycQpM368jb40HNq89/SJnR1jaYiojMY5q7RudgyjLZFImG6+4xIGYMM3f+++q/D+/50Ous7EG47sfPXn29AGUKpTQ3s4P7+1ubl5yItnzrfZCCJ59muD6d7H8/ILikd+S1+7fPnYnpW/3VgnkEakI6R1y6Nz5iRqamp8P9nGbWUA3vn85Px7ih77XWkj7NiWffSHN75Ltfx6EbiKUgkD2p8/e7ajEpzx7CNnWLm16eNP9pgDr6yu3lVeWrqwvLy8iHGexDsC/wHqq7fSQTg4DwAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARmSURBVFiF3ZhfbBRVFMZ/d2Z3y1aatoCAbVyxahON6AuJPPDQGIIakhojPihqJCIoxBDinxgJTUUSlVcjYTENYNo0UCiKRKrRdFUetJGEWAuE7rZLA+VPg22Fbdk/M8cHtkmtbWfmzu4L3+Pc833nfPfczD0zcAdBFVqwCSnLwdNAPfAIcA8wH7gODAJnBI5Z0LEZdbOQuQtmZjdSacIHwNtA2AVlTMHnQfh0HWqkEDUUxMweZI2CKDBPg/63wBtvotr91mH4IQui9iINCg6hZwRgnoLDUWS7IL4215eZvdAg8BH+O6yAHVHY5ldEC/mjdciPxjSwFazZgDqqQ9YqZB9SkYEE+kdrNgxb8MAm1LBXotYxy8CHFMcIQKUB7+kQPXcmf49cxd3rVxdjOVjk9R7y3Jn8hehoJFDK2Kp2YuvTDGwQMuvTDKw6TCwYZtxFmtIgPOW1Np1jVu8UEChl7OVB+pY8R50RIgKEjBCRJc9Tt3aQuEtDjnmmQsfMw04BTzbTFSrn0enWQhUsrTvA704acnsU8gQdM1VOAZHV1My2ft+z3F+IPFOhY2a+o2iIxX7W81jguqIJXa8E4IZTgJ3hisP6ZRd5/nFdUR46Zq46BQx8S99s6/1HSbrIM+uGTAfPZgS6nGI6X+GJzAjd062lh+mOvcZyF6kc80yFTmc6nQKy44Rbqniwv42YneECkLEzXEgcJNZcxUPWLeY4aSiIeS3M8wTwBTI3ABeBcq9cDxgNQ/WrqJQXkufO5EeMfV55XqCgyasR0Bw0LdgBXNPhusC1HOzUIWqZyY/nW3W4LrBVZ/wHnx9WUaQFeMmPxmTYWK2fRGo2G4ZRUiISTitVEhRROcsIAgRMO5szDFspNR5Kp1NLL10aaQNrgu/XTDlwGljiywWQMW6O7K96JjoauHjLLUdEWUpIBgz59VwymfT9yRtFVnD7NWrqq4h0zN/2VXdZa1JXIAcHfP3QANiIOimwy49G710/nPRhBECZtl3t2wzAFWgA57F+OtwwL18+seCdn/3kt8G2DCNREDONqBywFhdD6GRYKpv97u73j6RVynKOngEiGWWa7clk8kpBzABsRCWAd71wTpc1dwzMOXldM6UInC2xrD2JROIvKMKP8yhyCHjBKW4odObc/qrVBzVSjIvInwQCpxKJxH8u7oCGmBM25VR6ZUBKKmcKyKhU6puFW467FRRROZTExTB6IpHI2VgslpsuruCdAfjMvFRfYVV9PYO+dFbubP2jvKl3Ng0RlTWw+5Vh9NimeS4ej6ed8hbFDMCu4EBLefbe/00HfeHYb0cWrft+Bto4SvUZcD5YWnq2p6cn4yVnMY4ZAGNZ6/WQMbwibFdGJp6lzKGh4wu2/DQ5TmAMkd6AYZx5bNmyeFtbm/abrWidAWgMn1q++NbjvygxgzY569jCt77sLf3xKjCKUnETzr/Y39/bCHYx6ygYts/p+ni3So9vnnuwubamZmVtbW01Rd7EOwL/Ai1BeTIkgAbWAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAQMSURBVFiF3ZnLT1xlGIef78zAMFgCeGscLCGoLEy0myb6B9SIMTXW1IU1Rk3cGF16SYy3xMRUN8aVWkMaY0lDUbS6qbcwKjGmSmKwXKQzMBAoINICMgxnLufnoqWhCJzLzEDSX/Ju5rzved/nu39n4BqSKfULhWqAVuAh4E7gFuAGYA44DwwAXwGnDWap1PlLIqF6oXeEloXkwdJCR4Tqdrr2qyR0SGjOI8R6mxN6ZKcZEDJCrws5AUFWzRF6Tajkw94PzBtFQqy3V3cK5FAJemS9FYQObjdIXRFzxM0uCNUHqcsKyPMKcH3AWDfVAy8GCfQ94S7vIzNANEhCj1oGdvvdh4L0TCteQKpZpos4NuOILDbjfEacKBkPOaqB+wPU5k9Cn7qO+2qlNa8/tZEuqk9RTxvrJ9sB87trIV3q3hBkVSfV7QHmt+2AOe9aiK2xLWFspTzATPqtLcgCYAOVLk5ZFx8bQ8QlVdZg3HyuUpAF4F9XjyzTLs+nPORZ9FjPFQWBmXH1+JqRLZ9/QcpDnq0bpBQSOuY63qNa1kX1bThfLqhPVcp4mDNtfmsL0jPdrh4ZosS4nU7iZBkDsmQZo4M4Me5ghSoPeeJ+CwuyAOwCJoBav7E+tAA0GEzaT5Dvnrl8xDjmN86n2vyCBJYuXZFnynRqngl6ai4G6HCZYA4Hramoa6pQOxA4+XoVKJxobmx+zrKsSESK2sZEKiSTL1gVAOGQk8tblmOMyVTadvquycn5TiisxhcLUwv8ATQVRQEsWUvzB2IPfDQRnljxnF+mYEQqbOnnoVQqFfRyBoDBLABPsKZ1gkhIR+rfPuUHBMAYhbB0Wx6ebGpqaioKBsBgeoB3i3nHd9d929NRcyJVTBkhx2koyacdoTDQA9zjN3Y6NDXVeut9bWmTDty7DjgOHC26ZwAMJg88jpdD6BrlTC738k0vfV4MCFLWhEJdqVRquiQwAAaTBF7wE9Nec/z0L1U9cwFTSjAYKRQ+TCaTZy/VUGIJnQQedfMbqhwYOhB7sCNAioykPsLh3mQy+ffaB+WAudE29nBEkU138WWTTh9sePiDkXDC05FFMnmMErKs/sbGxsF4PJ7fyC8ctOjNZDD/TFqTT8UKsS/ZuLH0ft17p9xAJJOzcEaNZfU74dBQIpGwAUZGNr8qle1D9XjFePue3J7/nQ5+jMZ/fWb3099sEpbBmBELhiuqqwf7+/uzfnKWDWaU0apaq/aveqe+cfW32dDsbGts/9HF0OKVYSJYRjoXtqyBu/ftS3R2dgZe2cr6F0JvtPfevSt7fwopVJEnX3j+5mc//qH6+xlgAWMSIRh+bHT03JvglLOOkulM1Zm3bGNnOnZ1HG9pbt7f0tLSQJkb8ZrQf5kyepAtajIBAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASoSURBVFiF3VhNbFRVFP7OffMY6EjnvYGMrW2atmijRNyUBJcsTGRFQkJTKwpuXBliSDQxGolVEo0rjAuBhLCRGFuL4AoXTauWaBtNTHHoD/NHImXoOH2vY9+Uzvs5blpSoO37m7rgW777feec794zb867wGMEqnXAYrG4XQhxgIgOAtgNoBHADgAlADMAbjDzD7ZtX00mkwu1zF0zM7quq47jvAfgOIBtHiQVAF8S0Weqquq1qKEmZkql0mEiOgsgEUA+R0Rvqqp6KWwdIoyYmUnTtJNE1IdgRgAgwczfaZr2ITOH2txQZnRdP8nMvQh/wsTMH+u6/kGoIEGFy63VFybGGnCI6LCqqt8HEQcqRNM0hZkzCN5aG4YXQuxSFEXzKwzUZsz8PjbHCACojuO8G0To+2SKxeJ2SZLuwtvrNygqlmU96fd/KOI3ixDiADwYIaJKLBYbk2W5HUADgIJpmlnDMPYxs5u+TpKklwEM+KrND3m5yIMeOJV4PJ6VZXk/gBYAWwC0yLK8Px6Pp4losRZ5HkaQ38xzboRYLDZGRM+vtUZEe2Kx2KhbDGbe7bewIGaeciMst9ZG621uMYjINc/DCGJmhwdOQ8h1ANjpgfMAgpj51wOn4LJ+x0OMsgfOAwhi5q4bwTTNrMt63kMetw15BL7NMPOYG2f59Xt9Hf31SqXyolsMInLN8zB8mxFCDLlxmHnb/Pz806ZpDgO4BaAK4JZpmsPlcvkZx3G2ekg17Lc23xPA7OzsE5FI5G8Acb9aH5ivVqtNDQ0Nhh+R75NJJpMLzHzBr84PiOi8XyNAwKlZ13XVtu1JIkoG0W8EZp6VJOnZ/21qVhRFI6ITQbRuIKITQYwAIT+s5ubmLgJ4NUyM1bBt+5vOzs63hBDRKPO2JaKozEyWLWQAiEiOaQnhENHilqUlY8/t23o/YK/ow5qJA/gTQGsoFwAMw9CPdHefnZmZuedVw0w2MfIRwb9M5vP5UHcAiURiHsDrWLU7QcDM/MXp01f8GAEAIpYgeJcFHGttbW0NZQYAEonECIDPw8T4aWho5PLAQD5ECJIcp6kmlxHMHNE0bQTAPr/au4XCnVe6us4bhhH4dB3AcYBzoU8GAIjIEkIcgbch9D4syzJ7e3sHwhgBc5Uk6VI+ny/UxAwAKIqSAfCOH01/X9/V30dHSwFTMgMTUds+k8lk/gI24eJc07Q+Zu5y401PTU2+1tPzbYAUi8w8jkjkj0wmM7t6oeZmyuXyTsMwpqPRqLpuNZWKcezo0a/y2aynkYWZLBCnWYhUS0vLxPDwsLUWz/ftjBvq6+v/SaVSbzQ2Nl7G2pvF586cueJmhJlMASdHQqSciDSZTqeXACCbXf9TqeYns4Lx8fGLzc3Nj0wHv1679tvbx4//uI5sEURZAUzLdXUTqVSq6ifnppnJ5XJbmXlKUZSWlWelUqnYdejQuYWFhfttwkAFzDcjQtx4Ye/edH9/f+A3W83bbAVtbW33hoaGuuvr638WQsiWZdmfnjo1sGxkHkRpCZjuyeVufgQ4ADCVy21WObXB4ODgJ4VCYfHC+Qtfd7S3v9TR0dGETeyIxwb/Abxf6DIUZxAeAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS9SURBVFiF3VhNbFRVFP7Ond9OlBnApihJM1N0EqltQzoJLFxAQiKrruhCjXFh3GhcEGowGomiJEhYUJtUiTFCGEJsBX9CU2pQqzZB6WtLOgw0MNN5TUSggtNp6Tw6fe8dNyWp0Pa9d9/Mhm8593zfOd+9J/educAjBCq34MDAwOPBYHAHM7cQ0UYATwJYC+AOgL+J6LJpmj+EQqGz9fX1d8uZu2xmRkdHV8/Pz7/DzG8BqLJBKQLo8Hg8BzZt2jRVjhrKYmZwcHAnER0BsEaC/i8Rvd7c3HzabR3CDZmZSVGUvUTUBTkjALCGmb9RFOV9Zna1ua7MDA8P7wXwIdyfMAHYNzQ09J5bESkstFaXG40lYBLRzubm5m9lyFKFjIyMRAzDyEK+tVZC3u/3b2hsbMw7JUq1ma7r76IyRgBgdalUeluG6PhkFr4jt2Dv+pVFsaqqqsbpd8jrNEswGNwBG0aEEMVYLHYhHA7XEdE6Zr5ZKBTGc7ncZtM0rfihYrH4AoBTTmpz3GbM3GIpKkSxqalpPBKJbCWiWgB+IqqNRCJbGxoaMkIIzUqDiCzzPJTXKYGInrWKicViF4QQzy215vV6G6LR6J9WGsy80WltMhfAU1YB4XC4bqX1SCQSs9IgIss8D0LGzFobhaxzs76AJ2xXtAAZMzNWAcx802L9ho0807YrWoCMmVtWAYVCYXyl9ampKdVGnhU3ZCnImLlgFZDL5Tbrup5aak3X9ZSqqlusNIjIMs+DkLmaf7GKMU2zKpVKPZ3P5/uZeQJAiZkn8vl8fyqVesY0zaANjX6ntTmeANLp9GOapv0FIOyU6wAFn8+3vqmpadYJyfHJ1NfX32Xmr5zyHOJLp0YAyUEzEAjsAzApw7WBSb/f/7EMUcrMwni+S4ZrA7tkxn/A5R8rRVFOAHjJjcZiGIZxsrW19U0hRCDAXDVHFPAxk24IHwB4Pea8LoRJRJp/bm624fr1qW7AuM93ayYM4CKAqCsXADRNm9qze/eRycnJe3Y5zGQQQ/UK/n1MVVVXbwCJRKIA4BUs2h0ZMDMfP3bseydGAICIPRC8QQdejUajUVdmACCRSAwAOOhGQxkcHPj53DnVhQR5THO9azMAMDMzsxeA5Vi/FO7cvn2js6PjVzf5TcA0hMiWxcy2bdt0AC/DxhC6GLquz3/W2XlK0zT5NmUukcdzWlXVm2UxAwCJRCJLRG1OOD/29Z29NDp6RzIlM3AlYBifZ7PZS0AFHs4VRekC0GoVN6GqY3va2r6WSKEx8yi83qFsNvu/D7fjBw0beKNUKm33+/2rlwu4p2mz7e3tZ+wKMpMO4gwLka6trb3S39+vLxVX9pMBgN7e3pbq6urvltHn40ePnuw5c+baShrMNC9g5kiItOnxjGUymTmrvBUxAwA9PT0nampqHpoOLo6M/HFg//6+ZWgaiMYFcNUXCl1Jp9MlJzkr0WYAgFAo9Nr09PTzq1atqr3/W6FQ+OfTw4d/WhzHQBHM17xCXG5MJDLd3d3SN1vFTgYAksnklng8/psQwqfrunH40KEvFEW5BaAAoowHuPpiLnftA8CsZB1lQzKZ/Oj8+fPawU8OJuN1ddvj8fh6VHgTHwn8B/S71Ufd4vUbAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATTSURBVFiF3VhPTBRXHP7e2xmBTYwgDXVdQ6m2hxrsyaweeoCkSXtQExOZ0JLSQ9NLmx5MbGya1P49NCRoQg9UG1MTA5RZEbegsYemVE1gMU1JBRZhF9dkccHGAkUXZmfe/HooJJTCzs6b5dB+yV7m/b7v9/veezvvNw/4H4EVWjASiWzNZrOvAjhCRHsBBACUA3gE4AGAUQDfA7iuadrjQuYumJm2trYyRVE+YIy9B6AkD0qGMfaVoihfHj16dK4QNRTEjK7rxwCcBbBdgv4HY+zturq6y17r4F7IRMR0XT8FQIecEQDYTkSXOjs7PyIiT5Pr80Kurq7+GMCn8L7CjDFWG4vFrHA4fENaRJa4vLV0LxrrwAZwTNO0bhmyVCHd3d2lpmkmIL+1cmHWNM09DQ0Ns26JUv8Z0zQ/xOYYAYAyRVHelyG6XplIJLLVMIwZ5Pf6lUUGwNNuzyHFbZblA9HRiKIomVAoNBgIBHZzznfYtj2dTqcno9HoASGEE99PRK8A6HJTm8w2O+IUoChK5tChQ5PBYLCGc14JYAvnvDIYDNYcPnw47vP5FguRZy1cmyGiF5xiQqHQoKqq1euNqaq6LxQKRZ00GGN73dYmszI7nQICgcDunAI7dz5biDxrIWOm3FGU8x1expfxVN4Vrei6JQBYcAqwbXs61zgRpfPI82feFS1DxsyMU0A6nZ7MNT41NZXMI0/OCVkPMmYGnQKi0egB0zTvrDeWzWbvDA4OHnTSYIw55lkL12YYYz85xQghSnp6ep5LpVJ9tm3fB5C1bft+KpXq6+3tfV4IUeykQUR9bmtzfWgS0WUALQC25YoTQpT09/fXrHr0zPIvH8wvLS25/r5xvTKapj0mom/d8lzifGNj4xO3JKlG07KszwA8lOHmgYemaX4hQ5Qys9yeH5fh5oHjMu0/4PHDStf1NgCve9FYDSFEx8mTJ9/lnBcVEZUYjBWpRMwSXAUAxWebFuc2Y2xxi2E82Tc1NRcGxArfq5ltAIYAVHlyAcAwjLmW06fPzs7OLuXLIWKCEZIKp5tjyWTS04WGpmnzAN7AqtmRBF27ejXixggAMEY+cNpjAW9WVVVVeTIDAJqm3SKiJi8ao8PDt24PDCQ9SDCfbQc9mwGAioqKUwAc2/r1MD83lw53dv7sJb8N2ILzREHM1NbWWrZtNyCPJnQ1hBDmpXC4yzAM+W1KlGU+3+VkMjldEDMAUF9fnwBwwg0n2t9/PTEx8UgyJREQKxLi60QiMQxswsW5rus6gDqnuOl0eqzlzJlOiRSLRPQbFOWXRCLxj4PbdW/mBMuy3iGil1VVLdsoJmsYTzra23vz1SRiFhjFifORysrKWF9fn7VeXMFXBgDOnTt3pLS09MoG+nStp6fj1s2bE7k0iJjJYd9jnI/YPt9YPB43nPJuihkAaG1tbSsvL/9XdzB+9+7AhfPnf9iAtgjGJjkwrvr9sZGRkaybnAXfZisoLi5+K5PJvOT3+ytXni0sLPz+XXv7j6vjCMiAaELhfPTF/fvj4XBY+s22aSsDAM3NzQeDweANzrkqhBAdFy9+Mzo6OgNgHozFfcD4a/fuTXzy94W5Z2yqGQBoamr6fNeuXSeGfh3qutJ16QIUJTY+Pv4AAG127v80/gIGr+iWe+FGsAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAToSURBVFiF3VhdbFNlGH7ec05/F6IUE9GLIYgXXYpXJBBZE0xM9EausIl6ObzBGSHRdnEJ1p+RhnBBNF4YY/xJFigNaIwxLpFYB2WwMWCW0bG1W7eEdUBwQ0fb7fy83nQJjK3nnO90F/okvTnf+7zP+/Q75/ve7wP+R6BGJ4xGo+skSXqFmfcAaAHwFIANAO4CmCai64Zh/OT3+3+Nx+PzjdRumJmOjo71zNwB4B0APguUMjN/vri4mDh27NhcI2poiJloNLqXiL4EEBCg/8XMbx05cuS00zpkh3yKxWKHiOgLAH7BHD4iiuzatcvIZDJnnRTjyEw0Gv2QiD6C8xkmInqxtbVVy2QyvcJJRIm1V+ukkxwrwCCivYlE4gcRslAhBw4ceNzj8RQg9o2YYZaInk0kErN2iZKImtvt/gBrYwQA1gN4X4Roe2ai0eg6IroFa8uvKMo+n+9Ju/uQYleltiGaGnG73eVIJNIfDAa3yLK8Udf1mVwuN55MJneoqmrG91er1ZcBnLJVm51gAKjt7HXhdrvLnZ2d46FQaLcsy80A3LIsN4dCod2dnZ15l8tVaYTOcoh8M0GzgEgk0u/xeEIrjXm93m2RSOSiBZ0Wu4WJmHnaLCAYDG6pN97S0rK5ETrLIWJmg1mALMsbnYzX8ITlimoQMfOPWYCu6zMm4yULOn9brqgGETO3zAJyudx4vfFr164VzXIwc90/ZCWImOk3C0gmkzuq1Wp2pbFyuZxNpVI7zXIQkanOcoiY+d0sQFVVX1dX19ZsNpvWdX0SwKKu65NDQ0Ppw4cPP6dpmtcsBzOn7RZme9P0+XynK5XKZwAeqxenqqqvu7t79wOPNtV+VnDPMAzb5xvbM1NrMb6xy7OJr48ePXrfLkmo0SSijwHcFuFawG0i+lSEKGSm1p4fFOFawEGR9h9weLCKxWLdAN5wkuNBMPPxEydOvC1JksfD7Fsg8riYSdMlFwAosqFqkmQQUcW9sHB/282bcylAX+LbXgCWYT+AFwA84zAPVFWdO9PTM+WWpHcBQCeCAoCJICsMAGAQZGaAGZrLhcubNutbGUVF4rMjxWLR8ZE3Fou1AkjDwX0CM/OVwcHvJwqFomgKDfjO6e0MMpnMVDgc9gIIi+YoTU+fyw4NXXFQBpFh3BFaAJbD6/UeAmClrX8ElXK5dOnixT+c6BuAoUtSoSFm4vG4ZhjGm7DQhD5UhGGoAwMDp1RV1c2jVwHzIsny6WKxOOP4NVvC+fPnZ8Ph8F0Ar1rlFPL5X8bHxuo2pXXADIx4df3kjcnJSWANLs5jsdhJAK+Zxd2bmxv5racnKSBRYeY/oSiDhULhoY3b6dL8CDRN209EL8myvH7VGFW9f6Gv72erOZlJA3GeJWm4ubk5l06ntZXiGj4zANDe3r6nqanpx1Xyc/bq1eOjN26M1cvBTKoEY4IkadiQ5ZF8Pr9gprsmZgCgvb29u6mp6ZHuYKZUupDp7e1ZhVYB0bgEjLr8/tzw8PCiHc2Gv2ZLmJ+fb1MUpdXj8TQvPatWq3f6+/rOPBjHQBnMY4okXX9++/Z8KpUSXtnWbGYAYN++fTsDgUAvEbkMw9AvnDv3ValUugXgHojyMjD6+sTEWBwwGqG3pmYAoK2t7ZNAIPDe1OTUqSuXBr6FouRGR0enAfBaa/+n8S8PPeWMetb8+wAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATISURBVFiF3VhNbBtFGH0z3vXGbqpSikQBKSIOHKgop0quYtMadSsqVfRCoQo9IjiAuAXJ4lB+D0Q5Ig4VQvxIVZREKQhRRNoiNi2VcBECUaUNjmM7VRPHcdP81HGc/ZmPSyKVNMnuzjoHeEfPe9/73s54dnaA/xFYowsmEont0Wj0iBDiGGNsD4BHAOwCMANgEsB1IvrOcZwfDcOoNtK7YWGOHj260zTNNBG9BSDiQVID8Ilt2x8bhjHXiB4aEubQoUPHGWOnATwoIb8D4LWLFy+eDdpHKKCeHT58+BSATwFEJWtEALzc2toqCoXC5SDNBAqj6/q7AN5H8BlmjLHnYrGYnc/nL0kXkRWuLK2+IDXWgWCMHb9w4cI3MmKpRlKp1AOKooxB7j/ihllN09rOnTs361fIZdwURXkHWxMEAHaapvm2jND3zCQSie2RSKQMb9uvLGq2bT/s9z2k+HWJRqNHiMg1iKZptXQ6fTUej8dUVd1tWdZUJpPJd3V1xev1ups+qijK8wAG/PTme5kJIY65cTRNq/X29uaTyWRKVdUWAGFVVVuSyWSqp6cn19TUtOTBytVnLXyHYYw95cZJp9NXt23b9vR6Y83NzXs7OzszHqz2+O1NZgN41I0Qj8djm423t7e3NsJnLWTC7HIjqKq6O8j4Ch7y3NEKZMLcdSNYljXlMl7y4LPguaMVyIQpuxEymUx+s/ErV64UPfhs+kDWg+8wRHTVjdPV1RWvVqvX1hurVqvXuru793uwcvVZC5nd7Gc3Tr1ej3R0dDwxNDRkWJY1DsC0LGvcMAzjxIkTT5qm2eTBx/Ddm19BKpVqVhTlFoAdfrU+MM85f+z8+fOLfkS+Z2bliPGFX50fMMY+9xsEkDxoapr2AYBpGa0HTIfD4Y9khFIfZ6Ojo/VYLDYJ4EUZvQteHxwc/E1GGOjDStf1MwBeCVJjDXqy2eybnHNNI4osM6apRMx2uAoASkhYNueCMbYUXl5e3DsxMdcPOKvioGF2ENGfjLHHg2UAhBBzpVu3TlumWfeqIWIOIxQVTpdHisVi4E9eXdeTAAwEuE8gIpqpVL6uLiwUZUvYwFdBb2eQz+dvtrW1NQF4VrbGUq32y+zMzB8B2mBMiIrUbrYWlmWdAuDlWH8fbMsqzUxPDwXxF4BwOB9rSBjDMGwhxEl4OITeCyKyKpXKgOM4jjt7wyImC4XOFovFqcDLbBWFQmE2FovNAHjBq+buwsIP1fn5TQ+lm4AIGGlynL6/x8fHgS24ONd1vQ/AS248yzRHJm7e7JWwWCKiv6Aov4+Njf3rxe37QsMNtm2/wTnXOec7N+KQEIvlcvl7rzWJmA1GOeJ8uKWl5YZhGPZ6vIbPDAAcOHDgWDgc/naD+jR7+3bP/Nzc6GY1iJjFIQqM82ERCo3kcrllN98tCQMABw8ePKOq6n2ng6Va7dfy5OTgBrIlMJbnQFaNRm8MDw+bfjwbvsxWwRh71XGcZCgUaln9zXGcynSp9NO9PAJqIBpVOL/+zL59uf7+fumdbctmBgASicT+SCRyCYBKRE6lVPqsVquVAcyDsVwIyHYUCqPvAaIRflsaBgCSyeSHmqZ1Lt5dHLhze/pLKMqNbDY7CYC22vs/jX8A/Nff8x41WYEAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }, {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAmCAYAAABpuqMCAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAPjSURBVFiF3ZlNbxtVFIafe2cceyZxEitfqiMs1EUWSLDqggXskOiGSqCyoAj+AH8BChISAv5ABahCBaoGJziISAhWMR8LECBQUNo0cZpJpLQNVWMDTZxre+ayMIGQOp7J2DMFXuls5p57zvver7lzBv5HEBHETAMngVPAA8AxYAi4DVwHLgOfAJ8BdyLI3xVkgDeAHUAHsG3gdWDwXpBth9M0Rz6IiIN2G3gqfsp3QwBnAY9wQvbMA14immUfGC/TmYiD9mK89P/GaTqfkYPmAk/GKQKamzbsHvGzLZqHSWx4MwIR++21uISkCX78hrVtoO+oxGQIMScBy8/Jtu2dQqFQVEqta61rSqn16enpomVZ1QA5bODxENyOjPfxGVnbtrcrlcrPugXK5fK8ZVlBZvZCHGK+9yNSKBTmWgnZQz6fnwsg5rs4xFz3I6KUWmsnRinlBBCzcVRiYd64Cuhp56C1rvn4KCFE0idPDfDz+QfCHAC/+znUarWbPu03AuT5LTCjPxFGzKafw+zs7LV27TMzM06APG0HpFt4F5/1blnWTrlcnm+1X7a2tuZTqVTVLwZwPg4xzwcgoi3L2snn83NKKae555UzOTk5F1CIBp6LQ0wfUAlIKKxVgN6jEguzZ+7QXGpR4jzNK00syNA8CKKYlU1ivjUDnOkC8VZ2JiyhTj9TL3aSvAUu5XK5F6SUyaTWlhIimdBaNFyZADANr96Q0hNCVHuU2n5wY6My1fygAzoXMwD8BNzfYRyklJVcNvuWaZq7QftoLVyhcUypv1p0HKcbBYRHgCJgdBBDjwwNvTeQTjth+zfgQicE9rAOpIBHwwbo6+39ejiT+bEDDkJ43q0wR3MrnAW+DdPRNIwbY8PDX3SS3APPlXKlW2IawLMEuITuhxCiPjoy8pEQwvX3PgRa14RhFBzHudmNZbaHMs2KzRNBOwz29386kE63vZS2gdawmHLd/NW1tTWIpoKYB572c0r29Czel81+GCJ+VWs9j2n+sLKy8sv+hijEDAshlrTWh77FpRDb4+Pj55KmGejKorVoIHRJS7mQy+WuFIvFRiu/SGq7hmGccl3340Pi6+FM5tLgwMByuxhai7rEWxVSLniGsVgqlZRf3sgK1YlE4mK9Xr/rdmBb1jfZsbHPD+lWRYhrEpYStn1lYWGhdpScUVbdU1LKq57n5fYeGIZxK5fNvm0Yxl/LRMMOWi+bUl5+6MSJ0tTUVOiTLdJfCJZlPby7u/ul1joBuMdGR9/pte1N4FeEKBmw9Mzq6vIrzQL8vx+pVOpVIUS1v6//g4njxx+bmJgY5x7/h/lP4A+AJ7grnrOyCgAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    }]; // applying default labels

    if (!this.options.labels) {
      this.options.labels = {};
    }

    Object.keys(Drawing.DefaultLabels).forEach(function (key) {
      if (!_this2.options.labels.hasOwnProperty(key)) {
        _this2.options.labels[key] = Drawing.DefaultLabels[key];
      }
    }); // applying default styles

    if (!this.options.defaultStyles) {
      this.options.defaultStyles = {};
    }

    Object.keys(Drawing.DefaultStyles).forEach(function (key) {
      if (!options.defaultStyles.hasOwnProperty(key)) {
        _this2.options.defaultStyles[key] = Drawing.DefaultStyles[key];
        return;
      }

      if (key === "polyFillOpacity" && (options.defaultStyles[key] < 0 || options.defaultStyles[key] > 1)) {
        logger.log("Wrong value (" + options.defaultStyles[key] + ") for defaultStyles.polyFillOpactity. Must be between 0 and 1");
        _this2.options.defaultStyles[key] = Drawing.DefaultStyles[key];
        return;
      }

      if (key === "strokeWidth" || key === "polyStrokeWidth") {
        var intValue = parseInt(options.defaultStyles[key], 10);

        if (isNaN(intValue) || intValue < 0) {
          logger.log("Wrong value (" + options.defaultStyles[key] + ") for defaultStyles.strokeWidth. Must be a positive interger value.");
          _this2.options.defaultStyles[key] = Drawing.DefaultStyles[key];
          return;
        }

        _this2.options.defaultStyles[key] = intValue;
      }

      if (key === "markerSize") {
        var floatValue = parseFloat(options.defaultStyles[key]);

        if (isNaN(floatValue) || floatValue < 0) {
          logger.log("Wrong value (" + options.defaultStyles[key] + ") for defaultStyles.markerSize. Must be a positive value.");
          _this2.options.defaultStyles[key] = Drawing.DefaultStyles[key];
          return;
        }

        _this2.options.defaultStyles[key] = floatValue;
      }
    });
    this.interactionCurrent = null;
    this.interactionSelectEdit = null;
    this.stylingOvl = null;
    this.popupOvl = null;
    this.layer = null;

    if (this.options.layer && this.options.layer instanceof ol_layer_Vector__WEBPACK_IMPORTED_MODULE_7___default.a) {
      this.layer = this.options.layer;
    } // detection du support : desktop ou tactile
    // FIXME : utile ?


    this._isDesktop = this._detectSupport(); // applying default popup

    if (!this.options.popup) {
      this.options.popup = {
        display: true,
        apply: null
      };
    }
  };
  /**
   * Creates empty layer to host features
   *
   * @private
   */


  Drawing.prototype._createEmptyLayer = function () {
    var features = new ol_Collection__WEBPACK_IMPORTED_MODULE_3___default.a();
    var layer = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_7___default.a({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_6___default.a({
        features: features
      })
    }); // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant.

    layer.gpResultLayerId = "drawing"; // on le rajoute au controle (et à la carte)

    this.setLayer(layer);
  };
  /**
   * Sets vector layer to hosts feature.
   *
   * @param {ol.layer.Vector} vlayer - vector layer
   */


  Drawing.prototype.setLayer = function (vlayer) {
    var _this3 = this;

    if (!vlayer) {
      this.layer = null;
      return;
    }

    if (!(vlayer instanceof ol_layer_Vector__WEBPACK_IMPORTED_MODULE_7___default.a)) {
      logger.log("no valid layer given for hosting drawn features.");
      return;
    } // ajout du layer de dessin à la carte s'il n'y est pas déjà


    var layers = this.getMap().getLayers();

    if (layers) {
      var found = false;
      layers.forEach(function (mapLayer) {
        if (mapLayer === vlayer) {
          // FIXME object comparison
          logger.trace("layer already in map. Not adding.");
          found = true;
        }
      }); // si le layer n'est pas sur la carte, on l'ajoute.

      if (!found) {
        this.getMap().addLayer(vlayer);
      } // TODO style par defaut du geoportail !
      // application des styles ainsi que ceux par defaut de ol sur le layer


      vlayer.getSource().getFeatures().forEach(function (feature) {
        var featureStyleFunction = feature.getStyleFunction();

        if (featureStyleFunction) {
          var styles = featureStyleFunction(feature, 0); // var styles = featureStyleFunction.call(feature, 0);

          if (styles && styles.length !== 0) {
            feature.setStyle(styles[0]);
          }
        }
      });
      this.layer = vlayer; // Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche

      this.getMap().getControls().forEach(function (control) {
        if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_23__["default"]) {
          // un layer switcher est présent dans la carte
          var layerId = _this3.layer.gpLayerId; // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)

          if (control._layers[layerId].title === layerId) {
            control.addLayer(_this3.layer, {
              title: _this3.options.layerDescription.title,
              description: _this3.options.layerDescription.description
            });
          }
        }
      });
    }
  };
  /**
   * this method is called by the constructor.
   * this information is useful to switch to touch mode.
   * Detection : test for desktop or tactile
   *
   * @method _detectSupport
   *
   * @returns {Boolean} is desktop
   * @private
   */


  Drawing.prototype._detectSupport = function () {
    // TODO
    // Choix de gérer la détection dans le code du composant au lieu du DOM car :
    // Utilisation de l'implémentation Leaflet
    // http://leafletjs.com/reference.html#browser
    var isDesktop = true;
    var userAgent = window.navigator.userAgent.toLowerCase();

    if (userAgent.indexOf("iphone") !== -1 || userAgent.indexOf("ipod") !== -1 || userAgent.indexOf("ipad") !== -1 || userAgent.indexOf("android") !== -1 || userAgent.indexOf("mobile") !== -1 || userAgent.indexOf("blackberry") !== -1 || userAgent.indexOf("tablet") !== -1 || userAgent.indexOf("phone") !== -1 || userAgent.indexOf("touch") !== -1) {
      isDesktop = false;
    }

    if (userAgent.indexOf("msie") !== -1 || userAgent.indexOf("trident") !== -1) {
      isDesktop = true;
    }

    return isDesktop;
  }; // ################################################################### //
  // ######################## methods handle dom ####################### //
  // ################################################################### //

  /**
   * Create control main container (called by Drawing constructor)
   *
   * @method _initContainer
   *
   * @returns {DOMElement} DOM element
   * @private
   */


  Drawing.prototype._initContainer = function () {
    // creation du container principal
    var container = this._createMainContainerElement();

    var inputShow = this._showDrawingContainer = this._createShowDrawingElement();

    container.appendChild(inputShow);

    var picto = this._createShowDrawingPictoElement();

    container.appendChild(picto);

    var panel = this._drawingPanel = this._createDrawingPanelElement();

    var header = this._drawingPanelHeader = this._createDrawingPanelHeaderElement();

    panel.appendChild(header);

    var tools = this._createDrawingToolsSections();

    for (var i = 0; i < tools.length; i++) {
      panel.appendChild(tools[i]);
    }

    container.appendChild(panel);
    return container;
  }; // ################################################################### //
  // ##################### handlers events to control ################## //
  // ################################################################### //

  /**
   * Callback de fin de dessin de geometrie
   * @param {Object} feature - ol feature
   * @param {String} geomType - geometry type
   * @param {Boolean} clean - clean last feature
   *
   * @private
   */


  Drawing.prototype._drawEndFeature = function (feature, geomType) {
    // application des styles par defaut.
    var style = null;

    switch (geomType) {
      case "Point":
        style = new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
          image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"](this._getIconStyleOptions(this.options.markersList[0]))
        });
        break;

      case "LineString":
        style = new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
            color: this.options.defaultStyles.strokeColor,
            width: this.options.defaultStyles.strokeWidth
          })
        });
        break;

      case "Polygon":
        style = new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
            color: _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].hexToRgba(this.options.defaultStyles.polyFillColor, this.options.defaultStyles.polyFillOpacity)
          }),
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
            color: this.options.defaultStyles.polyStrokeColor,
            width: this.options.defaultStyles.polyStrokeWidth
          })
        });
        break;
    }

    feature.setStyle(style); // gestion des mesures

    this._updateMeasure(feature, geomType);

    if (this.options.popup.display) {
      // creation overlay pour saisie du label
      // contexte
      var context = this;
      /**
      * Enregistrement de la valeur saisie dans l'input.
      *
      * @param {String} key - clef de l'attribut.
      * @param {String} value - valeur de l'attribut.
      * @param {Boolean} save - true si on garde le label.
      */

      var setAttValue = function setAttValue(key, value, save) {
        context.getMap().removeOverlay(context.popupOvl);
        context.popupOvl = null;

        if (save && value && value.trim().length > 0) {
          var obj = {};
          obj[key] = value.replace(/\n/g, "<br>");
          feature.setProperties(obj);
        }
      };

      var popup = null;
      var popupByDefault = true;
      var displayFunction = this.options.popup["function"];

      if (displayFunction && typeof displayFunction === "function") {
        // la sauvegarde et la fermeture sont des actions à implementer par l'utilisateur
        // par contre, la destruction est à gerer en interne
        popup = displayFunction.call(context, {
          feature: feature,
          geomType: geomType,
          closeFunc: function closeFunc() {
            setAttValue(null, false);
          },
          saveFunc: function saveFunc(message) {
            setAttValue(message, true);
          }
        });

        if (popup) {
          // on est sûr que la popup customisée existe,
          // donc on n'utilise pas celle par defaut...
          popupByDefault = false; // FIXME comment forcer le focus sur une div ?

          popup.tabIndex = -1; // hack sur le focus sur une div ?

          popup.onblur = function () {
            context.getMap().removeOverlay(context.popupOvl);
            context.popupOvl = null;
          };
        }
      } // use popup by default


      if (popupByDefault) {
        // function by default
        popup = this._createLabelDiv({
          applyFunc: setAttValue,
          inputId: this._addUID("att-input"),
          placeholder: "Saisir une description...",
          measure: this.options.tools.measure ? feature.getProperties().measure : null,
          geomType: geomType,
          key: "description"
        });
      } // un peu de menage...


      if (this.popupOvl) {
        this.getMap().removeOverlay(this.popupOvl);
        this.popupOvl = null;
      } // creation de l'overlay


      this.popupOvl = new ol_Overlay__WEBPACK_IMPORTED_MODULE_4___default.a({
        element: popup,
        // FIXME : autres valeurs.
        positioning: "top-center" // stopEvent : false

      });
      this.getMap().addOverlay(this.popupOvl);
      var geomExtent = feature.getGeometry().getExtent();
      this.popupOvl.setPosition([(geomExtent[0] + geomExtent[2]) / 2, (geomExtent[1] + geomExtent[3]) / 2]);

      if (document.getElementById(this._addUID("att-input"))) {
        document.getElementById(this._addUID("att-input")).focus();
      }
    }
  };
  /**
   * Creates Interaction for features removal.
   *
   * @returns {SelectInteraction} created interaction.
   * @private
   */


  Drawing.prototype._createRemoveInteraction = function () {
    var _this4 = this;

    var interaction = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Select"]({
      // features : this.layer.getSource().getFeaturesCollection(),
      layers: [this.layer],
      style: false
    });
    interaction.on("select", function (seEv) {
      if (!seEv || !seEv.selected || seEv.selected.length === 0) {
        return;
      }

      _this4.layer.getSource().removeFeature(seEv.selected[0]); // suppression puis rajout de l'interaction pour appliquer le changement tout de suite...


      _this4.getMap().removeInteraction(_this4.interactionCurrent);

      _this4.interactionCurrent = _this4._createRemoveInteraction();

      _this4.getMap().addInteraction(_this4.interactionCurrent);
    });
    return interaction;
  };
  /**
   * Creates Interaction for features style definition.
   *
   * @returns {ol.interaction.Select} created interaction.
   * @private
   */


  Drawing.prototype._createStylingInteraction = function () {
    var _this5 = this;

    var interaction = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Select"]({
      layers: [this.layer],
      style: false
    });
    interaction.on("select", function (seEv) {
      // suppression de toute popup existante
      if (_this5.stylingOvl) {
        _this5.getMap().removeOverlay(_this5.stylingOvl);
      }

      if (!seEv || !seEv.selected || seEv.selected.length === 0) {
        return;
      }

      var valuesColor = null;
      var hexColor = null;
      var popupOvl = null;
      var geomType = null;
      var initValues = {}; // FIXME
      // l'appel feature.getStyle() est parfois nul pour des geometries Point
      // avec un style par defaut !

      var geom = seEv.selected[0].getGeometry();
      var style = seEv.selected[0].getStyle();

      if (geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["Point"] || geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["MultiPoint"]) {
        // on determine si c'est un marker ou un label.
        var _label = seEv.selected[0].getProperties().name;

        if (style && style.getText() && _label) {
          geomType = "Text";

          if (style.getText().getStroke() && style.getText().getStroke().getColor()) {
            valuesColor = style.getText().getStroke().getColor();

            if (Array.isArray(valuesColor)) {
              // FIXME Array !?
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.strokeColor = valuesColor;
            }

            hexColor = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].isRGB(valuesColor) ? _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.strokeColor = hexColor.hex;
            initValues.strokeOpacity = hexColor.opacity;
          }

          if (style.getText().getFill() && style.getText().getFill().getColor()) {
            valuesColor = style.getText().getFill().getColor();

            if (Array.isArray(valuesColor)) {
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.fillColor = valuesColor;
            }

            hexColor = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].isRGB(valuesColor) ? _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.fillColor = hexColor.hex;
            initValues.fillOpacity = hexColor.opacity;
          }

          initValues.strokeColor = initValues.hasOwnProperty("strokeColor") ? initValues.strokeColor : _this5.options.defaultStyles.textStrokeColor;
          initValues.fillColor = initValues.hasOwnProperty("fillColor") ? initValues.fillColor : _this5.options.defaultStyles.textFillColor;
        } else if (style && style.getImage()) {
          geomType = "Point";

          if (style.getImage().getSrc()) {
            initValues.markerSrc = style.getImage().getSrc();
            initValues.markerSize = style.getImage().getScale() || 1;
            initValues.markerAnchor = style.getImage().getAnchor();

            if (style.getImage().getColor()) {
              valuesColor = style.getImage().getColor();

              if (Array.isArray(valuesColor)) {
                // FIXME Array !?
                valuesColor = "rgba(" + valuesColor.join() + ")";
              } else {
                initValues.markerColor = valuesColor;
              }

              hexColor = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].isRGB(valuesColor) ? _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].rgbaToHex(valuesColor) : {
                hex: valuesColor,
                opacity: 1
              };
              initValues.markerColor = hexColor.hex;
              initValues.markerOpacity = hexColor.opacity;
            } else {
              initValues.markerColor = _this5.options.markersList[0].color || "#ffffff";
            }
          } else {
            initValues.markerSrc = _this5.options.markersList[0].src;
            initValues.markerSize = _this5.options.markersList[0].scale || 1;
            initValues.markerColor = _this5.options.markersList[0].color || "#ffffff";
            initValues.markerAnchor = _this5.options.markersList[0].anchor;
          }

          initValues.markerCustom = !_this5._getsMarkersOptionsFromSrc(initValues.markerSrc);
        }
      } else if (geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["LineString"] || geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["MultiLineString"]) {
        geomType = "Line";

        if (style && style.getStroke()) {
          if (style.getStroke().getWidth()) {
            initValues.strokeWidth = style.getStroke().getWidth();
          }

          if (style.getStroke().getColor()) {
            valuesColor = style.getStroke().getColor();

            if (Array.isArray(valuesColor)) {
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.strokeColor = valuesColor;
            }

            hexColor = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].isRGB(valuesColor) ? _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.strokeColor = hexColor.hex;
            initValues.strokeOpacity = hexColor.opacity;
          }
        }

        initValues.strokeWidth = initValues.hasOwnProperty("strokeWidth") ? initValues.strokeWidth : _this5.options.defaultStyles.strokeWidth;
        initValues.strokeColor = initValues.hasOwnProperty("strokeColor") ? initValues.strokeColor : _this5.options.defaultStyles.strokeColor;
      } else if (geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["Polygon"] || geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["MultiPolygon"]) {
        geomType = "Polygon";

        if (style && style.getStroke()) {
          if (style.getStroke().getWidth()) {
            initValues.strokeWidth = style.getStroke().getWidth();
          }

          if (style.getStroke().getColor()) {
            valuesColor = style.getStroke().getColor();

            if (Array.isArray(valuesColor)) {
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.strokeColor = valuesColor;
            }

            hexColor = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].isRGB(valuesColor) ? _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.strokeColor = hexColor.hex;
            initValues.strokeOpacity = hexColor.opacity;
          }
        }

        if (style && style.getFill()) {
          if (style.getFill().getColor()) {
            valuesColor = style.getFill().getColor();

            if (Array.isArray(valuesColor)) {
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.fillColor = valuesColor;
            }

            hexColor = _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].isRGB(valuesColor) ? _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.fillColor = hexColor.hex;
            initValues.fillOpacity = hexColor.opacity;
          }
        }

        initValues.strokeWidth = initValues.hasOwnProperty("strokeWidth") ? initValues.strokeWidth : _this5.options.defaultStyles.polyStrokeWidth;
        initValues.strokeColor = initValues.hasOwnProperty("strokeColor") ? initValues.strokeColor : _this5.options.defaultStyles.polyStrokeColor;
        initValues.fillColor = initValues.hasOwnProperty("fillColor") ? initValues.fillColor : _this5.options.defaultStyles.polyFillColor;
        initValues.fillOpacity = initValues.hasOwnProperty("fillOpacity") ? initValues.fillOpacity : _this5.options.defaultStyles.polyFillOpacity;
      }

      if (!geomType) {
        logger.log("Unhandled geometry type for styling.");
        return;
      }

      var dtObj = _this5;
      /**
      * function called when apply button is pressed.
      *
      * @param {String} action - "apply" (to selected object), "default" (set as default), "cancel" (do nothing).
      */

      var applyStyle = function applyStyle(action) {
        if (action === "cancel") {
          dtObj.getMap().removeOverlay(popupOvl);
          return;
        }

        var setDefault = action !== "apply";
        var fillColorElem = document.getElementById(dtObj._addUID("fillColor"));
        var fillOpacityElem = document.getElementById(dtObj._addUID("fillOpacity"));
        var strokeColorElem = document.getElementById(dtObj._addUID("strokeColor"));
        var strokeWidthElem = document.getElementById(dtObj._addUID("strokeWidth"));
        var markerSizeElem = document.getElementById(dtObj._addUID("markerSize"));
        var markerColorElem = document.getElementById(dtObj._addUID("markerColor"));

        switch (geomType.toLowerCase()) {
          case "text":
            if (setDefault) {
              dtObj.options.defaultStyles.textStrokeColor = strokeColorElem.value;
              dtObj.options.defaultStyles.textFillColor = fillColorElem.value;
            } else {
              seEv.selected[0].setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
                text: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Text"]({
                  font: "16px sans",
                  textAlign: "left",
                  text: style.getText().getText(),
                  fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                    color: fillColorElem.value
                  }),
                  stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                    color: strokeColorElem.value,
                    width: 3
                  })
                })
              }));
            }

            break;

          case "point":
            // FIXME cas où le marker n'est pas dans la liste ?
            // si le marker n'existe pas dans le liste, on ne souhaite donc que changer la couleur du
            // pictogramme ou la taille..., on garde donc le picto initial.
            var markerSelected = null;
            var scale = parseInt(markerSizeElem.value, 10) / 10;
            var markerChecked = document.querySelector("input[name='marker']:checked");

            if (markerChecked) {
              markerSelected = dtObj._getsMarkersOptionsFromSrc(markerChecked.value);
              markerSelected.scale = scale;
            }

            if (setDefault) {
              dtObj.options.defaultStyles.markerSize = scale;

              if (dtObj.options.markersList.length > 1) {
                // index du marker dans la liste des markers
                var idxMarker = dtObj.options.markersList.findIndex(function (mrk) {
                  if (mrk === markerSelected) {
                    // FIXME object comparison
                    return true;
                  }

                  return false;
                });

                if (idxMarker > 0) {
                  // on enleve le marker de son ancienne position
                  dtObj.options.markersList.splice(idxMarker, 1); // on le place en tête de liste

                  dtObj.options.markersList.splice(0, 0, markerSelected);
                }
              }
            } else {
              if (markerSelected) {
                seEv.selected[0].setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
                  image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"](dtObj._getIconStyleOptions(markerSelected))
                }));
              } else {
                // FIXME anchor !?
                seEv.selected[0].setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
                  image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"]({
                    src: initValues.markerSrc,
                    // on garde le pictogramme initial !
                    color: markerColorElem.value,
                    // on recupère la couleur !
                    anchor: initValues.markerAnchor,
                    // on garde la position initial !
                    anchorOrigin: "top-left",
                    anchorXUnits: "pixels",
                    anchorYUnits: "pixels",
                    scale: scale
                  })
                }));
              }
            }

            break;

          case "line":
            if (setDefault) {
              dtObj.options.defaultStyles.strokeColor = strokeColorElem.value;
              dtObj.options.defaultStyles.strokeWidth = parseInt(strokeWidthElem.value, 10);
            } else {
              seEv.selected[0].setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                  width: parseInt(strokeWidthElem.value, 10),
                  color: strokeColorElem.value
                })
              }));
            }

            break;

          case "polygon":
            var opacity = parseInt(fillOpacityElem.value, 10) / 10;

            if (setDefault) {
              dtObj.options.defaultStyles.polyStrokeColor = strokeColorElem.value;
              dtObj.options.defaultStyles.polyFillColor = fillColorElem.value;
              dtObj.options.defaultStyles.polyFillOpacity = opacity;
              dtObj.options.defaultStyles.polyStrokeWidth = parseInt(strokeWidthElem.value, 10);
            } else {
              seEv.selected[0].setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                  width: parseInt(strokeWidthElem.value, 10),
                  color: strokeColorElem.value
                }),
                fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                  // color : fillColorElem.value
                  color: _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].hexToRgba(fillColorElem.value, opacity)
                })
              }));
            }

            break;
        }

        if (!setDefault) {
          // application des styles par defaut
          // fermeture de la popup (si on applique le style à l'objet)
          dtObj.getMap().removeOverlay(popupOvl);
        }
      };

      var popupDiv = _this5._createStylingDiv({
        geomType: geomType,
        initValues: initValues,
        applyFunc: applyStyle
      });

      popupOvl = new ol_Overlay__WEBPACK_IMPORTED_MODULE_4___default.a({
        element: popupDiv,
        // FIXME : autres valeurs.
        positioning: "top-center" // stopEvent : false

      });

      _this5.getMap().addOverlay(popupOvl);

      popupOvl.setPosition(seEv.mapBrowserEvent.coordinate);
      _this5.stylingOvl = popupOvl; // suppression puis rajout de l'interaction pour appliquer le changement tout de suite...

      _this5.getMap().removeInteraction(_this5.interactionCurrent);

      _this5.interactionCurrent = _this5._createStylingInteraction();

      _this5.getMap().addInteraction(_this5.interactionCurrent);
    });
    return interaction;
  };
  /**
   * Creates Interaction for text definition.
   *
   * @returns {SelectInteraction} created interaction.
   * @private
   */


  Drawing.prototype._createLabelInteraction = function () {
    var _this6 = this;

    var interaction = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Select"]({
      layers: [this.layer],
      style: false
    });
    interaction.on("select", function (seEv) {
      // suppression de toute popup existante
      if (_this6.labelOvl) {
        _this6.getMap().removeOverlay(_this6.labelOvl);
      }

      if (!seEv || !seEv.selected || seEv.selected.length === 0) {
        return;
      }

      var popupOvl = null;
      var geomType = null;
      var _textValue = null;
      var _measure = null;
      var geom = seEv.selected[0].getGeometry();
      var style = seEv.selected[0].getStyle();

      if (geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["Point"] || geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["MultiPoint"]) {
        // on determine si c'est un marker ou un label.
        var _label = seEv.selected[0].getProperties().name;

        if (style && style.getText() && _label) {
          geomType = "Text";
        } else if (style && style.getImage()) {
          geomType = "Point";
        }
      } else if (geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["LineString"] || geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["MultiLineString"]) {
        geomType = "Line";
      } else if (geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["Polygon"] || geom instanceof ol_geom__WEBPACK_IMPORTED_MODULE_9__["MultiPolygon"]) {
        geomType = "Polygon";
      } else {
        logger.log("Geometry type for styling not supported .");
        return;
      }

      if (!geomType) {
        logger.log("Unhandled geometry type for styling.");
        return;
      }

      if (geomType === "Text") {
        // pour les labels on récupère la valeur dans le style
        _textValue = style.getText().getText();
      } else {
        // pour les autres, c'est un attribut du feature
        // choix à faire entre description (KML et GeoJSON) ou desc (GPX)
        var featProps = seEv.selected[0].getProperties();

        if (featProps && featProps.hasOwnProperty("description")) {
          _textValue = featProps["description"];
        }

        if (featProps && featProps.hasOwnProperty("measure")) {
          _measure = featProps["measure"];
        }
      }

      var context = _this6;
      /**
       * Enregistrement de la valeur saisie dans l'input.
       *
       * @param {String} key - clef de l'attribut.
       * @param {String} value - valeur de l'attribut.
       * @param {Boolean} save - true si on garde le label.
       */

      var setTextValue = function setTextValue(key, value, save) {
        context.getMap().removeOverlay(popupOvl);

        if (!save) {
          return;
        }

        var feature = seEv.selected[0];

        if (geomType === "Text") {
          var style = feature.getStyle();
          style.getText().setText(value);
          feature.setProperties({
            name: value
          });
          feature.setStyle(style);
          return;
        }

        var obj = {};
        obj[key] = value.replace(/\n/g, "<br>");
        feature.setProperties(obj);
      };

      var popupDiv = _this6._createLabelDiv({
        applyFunc: setTextValue,
        inputId: _this6._addUID("label-input"),
        placeholder: geomType === "Text" ? "Saisir un label..." : "Saisir une description...",
        text: _textValue,
        key: "description",
        measure: _this6.options.tools.measure ? _measure : null,
        geomType: geomType
      });

      popupOvl = new ol_Overlay__WEBPACK_IMPORTED_MODULE_4___default.a({
        element: popupDiv,
        // FIXME : autres valeurs.
        positioning: "top-center" // stopEvent : false

      });

      _this6.getMap().addOverlay(popupOvl);

      popupOvl.setPosition(seEv.mapBrowserEvent.coordinate);
      document.getElementById(_this6._addUID("label-input")).focus();
      _this6.labelOvl = popupOvl; // suppression puis rajout de l'interaction pour appliquer le changement tout de suite...

      _this6.getMap().removeInteraction(_this6.interactionCurrent);

      _this6.interactionCurrent = _this6._createLabelInteraction();

      _this6.getMap().addInteraction(_this6.interactionCurrent);
    });
    return interaction;
  };
  /**
   * Callback de fin de modification du dessin afin de mettre à jour la mesure
   * TODO
   * @param {Object} feature - ol feature
   * @param {String} geomType - geometry type
   *
   * @private
   */


  Drawing.prototype._updateMeasure = function (feature, geomType) {
    logger.log(feature);
    var measure = null;
    var projection = this.getMap().getView().getProjection(); // arrondi

    function __roundDecimal(nombre, precision) {
      precision = precision || 2;
      var factor = Math.pow(10, precision);
      return Math.round(nombre * factor) / factor;
    }

    var type = geomType || feature.getProperties().type;

    switch (type) {
      case "Point":
        var coordinatesPoint = feature.getGeometry().getCoordinates();
        var c = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])(coordinatesPoint, projection, "EPSG:4326");
        measure = "lon : ";
        measure += __roundDecimal(c[0], 4) + "°";
        measure += " / ";
        measure += "lat : ";
        measure += __roundDecimal(c[1], 4) + "°";
        break;

      case "LineString":
        var measureLength = 0;
        var coordinatesLine = feature.getGeometry().getCoordinates();

        for (var i = 0, ii = coordinatesLine.length - 1; i < ii; ++i) {
          var c1 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])(coordinatesLine[i], projection, "EPSG:4326");
          var c2 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])(coordinatesLine[i + 1], projection, "EPSG:4326");
          measureLength += Object(ol_sphere__WEBPACK_IMPORTED_MODULE_13__["getDistance"])(c1, c2);
        }

        measure = measureLength > 1000 ? __roundDecimal(measureLength / 1000, 3) + " km" : __roundDecimal(measureLength, 3) + " m";
        break;

      case "Polygon":
        var measureArea = 0;
        var geom = feature.getGeometry().clone();
        var coordinatesAera = geom.getLinearRing(0).getCoordinates();
        measureArea = Math.abs(Object(ol_sphere__WEBPACK_IMPORTED_MODULE_13__["getArea"])(new ol_geom__WEBPACK_IMPORTED_MODULE_9__["Polygon"]([coordinatesAera]))); // FIXME on se limite à des trous uniquement !
        // cad les polygones sont strictement contenus dans le 1er !

        var rings = geom.getLinearRings();

        if (rings.length > 1) {
          for (var ij = 1; ij < rings.length; ij++) {
            var coordinatesRings = rings[ij].getCoordinates();
            measureArea -= Math.abs(Object(ol_sphere__WEBPACK_IMPORTED_MODULE_13__["getArea"])(new ol_geom__WEBPACK_IMPORTED_MODULE_9__["Polygon"]([coordinatesRings])));
          }
        }

        measure = measureArea > 1000000 ? __roundDecimal(measureArea / 1000000, 3) + " km^2" : __roundDecimal(measureArea, 2) + " m^2";
        break;
    } // enregistrement de la mesure dans la feature


    feature.setProperties({
      measure: measure,
      type: type
    });
  };
  /**
   * Handles click on drawing tools icons
   *
   * @param {Event} clickEvent - click event
   * @param {String} toolId - selected tool Id
   * @param {Drawing} context - Drawing control.
   * @private
   */


  Drawing.prototype._handleToolClick = function (clickEvent, toolId, context) {
    var _this7 = this;

    var map = context.getMap();

    if (!map) {
      logger.trace("Drawing control not attached to any map.");
      return;
    } // on supprime  les interactions des autres extensions


    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_15__["default"].unset(map, {
      current: "Drawing"
    }); // on supprime l'interaction courante s'il y en a une.

    if (context.interactionCurrent) {
      map.removeInteraction(context.interactionCurrent);
      context.interactionCurrent = null;
    } // on supprime l'interaction de selection courante s'il y en a une.


    if (context.interactionSelectEdit) {
      map.removeInteraction(context.interactionSelectEdit);
      context.interactionSelectEdit = null;
    } // on supprime la popup courante s'il y en a une.


    if (context.popupOvl) {
      context.getMap().removeOverlay(context.popupOvl);
      context.popupOvl = null;
    } // si aucune couche de dessin, on en crée une vide.


    if (!this.layer) {
      this._createEmptyLayer();
    }

    switch (toolId) {
      case this._addUID("drawing-tool-point"):
        if (context.dtOptions["points"].active) {
          context.interactionCurrent = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Draw"]({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
              image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"](this._getIconStyleOptions(this.options.markersList[0]))
            }),
            type: "Point"
          });
          context.interactionCurrent.on("drawend", function (deEv) {
            // ajout eventuel d'un attribut description sur le feature
            context._drawEndFeature(deEv.feature, "Point");
          }, context);
        }

        break;

      case this._addUID("drawing-tool-line"):
        if (context.dtOptions["lines"].active) {
          context.interactionCurrent = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Draw"]({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
              image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Circle"]({
                radius: this.options.cursorStyle.radius,
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                  color: this.options.cursorStyle.fillColor
                })
              }),
              stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                color: this.options.defaultStyles.strokeColor,
                width: this.options.defaultStyles.strokeWidth
              })
            }),
            type: "LineString"
          });
          context.interactionCurrent.on("drawend", function (deEv) {
            // ajout eventuel d'un attribut description sur le feature
            context._drawEndFeature(deEv.feature, "LineString");
          }, context);
        }

        break;

      case this._addUID("drawing-tool-polygon"):
        if (context.dtOptions["polygons"].active) {
          context.interactionCurrent = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Draw"]({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
              image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Circle"]({
                radius: this.options.cursorStyle.radius,
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                  color: this.options.cursorStyle.fillColor
                })
              }),
              stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                color: this.options.defaultStyles.polyStrokeColor,
                width: this.options.defaultStyles.polyStrokeWidth
              }),
              fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                color: _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].hexToRgba(this.options.defaultStyles.polyFillColor, this.options.defaultStyles.polyFillOpacity)
              })
            }),
            type: "Polygon"
          });
          context.interactionCurrent.on("drawend", function (deEv) {
            // ajout eventuel d'un attribut description sur le feature
            context._drawEndFeature(deEv.feature, "Polygon");
          }, context);
        }

        break;

      case this._addUID("drawing-tool-holes"):
        if (context.dtOptions["holes"].active) {
          // selection du polygone à modifier
          context.interactionSelectEdit = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Select"]({
            stopClick: true,
            condition: ol_events_condition__WEBPACK_IMPORTED_MODULE_12__["pointerMove"],
            layers: [this.layer]
          });
          context.interactionSelectEdit.setProperties({
            name: "Drawing",
            source: context
          });
          map.addInteraction(context.interactionSelectEdit); // saisie

          context.interactionCurrent = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Draw"]({
            stopClick: true,
            features: this.interactionSelectEdit.getFeatures(),
            style: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
              image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Circle"]({
                radius: this.options.cursorStyle.radius,
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                  color: this.options.cursorStyle.fillColor
                })
              }),
              stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                color: this.options.defaultStyles.polyStrokeColor,
                width: this.options.defaultStyles.polyStrokeWidth
              }),
              fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                color: _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_18__["default"].hexToRgba(this.options.defaultStyles.polyFillColor, this.options.defaultStyles.polyFillOpacity)
              })
            }),
            type: "Polygon"
          });
          context.interactionCurrent.on("drawstart", function (deEv) {}, context);
          context.interactionCurrent.on("drawend", function (deEv) {
            // recuperation du feature selectionné
            var features = context.interactionSelectEdit.getFeatures();

            if (features.getLength()) {
              // choix sur le 1er feature de la liste
              var feature = features.item(0);
              var hole = deEv.feature.getGeometry().getCoordinates()[0]; // test pour savoir si le polygone est entièrement
              // inclu dans l'autre afin de faciliter les calculs d'aire !

              var bHoleIsIncluded = true;

              for (var i = 0; i < hole.length; i++) {
                if (!feature.getGeometry().intersectsCoordinate(hole[i])) {
                  bHoleIsIncluded = false;
                  break;
                }
              }

              if (!bHoleIsIncluded) {
                return;
              } // ajout du rings


              feature.getGeometry().appendLinearRing(new ol_geom_LinearRing__WEBPACK_IMPORTED_MODULE_10___default.a(hole)); // enregistrement !

              deEv.feature = feature; // finalisation du dessin...

              context._drawEndFeature(deEv.feature, "Polygon");
            }
          }, context);
        }

        break;

      case this._addUID("drawing-tool-text"):
        // text : creation de points invisibles avec un label.
        if (context.dtOptions["text"].active) {
          context.interactionCurrent = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Draw"]({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
              image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Circle"]({
                radius: this.options.cursorStyle.radius,
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                  color: this.options.cursorStyle.fillColor
                })
              })
            }),
            type: "Point"
          });
          context.interactionCurrent.on("drawend", function (deEv) {
            // creation overlay pour saisie du label
            var popupOvl = null;
            /**
            * Enregistrement de la valeur saisie dans l'input.
            *
            * @param {String} key - clef du label
            * @param {String} value - valeur du label
            * @param {Boolean} save - true si on garde le label.
            */

            var setTextValue = function setTextValue(key, value, save) {
              context.getMap().removeOverlay(popupOvl);

              if (!save) {
                // removes feature from overlay.
                context.layer.getSource().removeFeature(deEv.feature);
                return;
              }

              var obj = {};
              obj[key] = value;
              deEv.feature.setProperties(obj);
              deEv.feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
                image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"](context._getIconStyleOptions(context.options.defaultStyles.textIcon1x1)),
                text: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Text"]({
                  textAlign: "left",
                  font: "16px sans",
                  text: value,
                  fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                    color: context.options.defaultStyles.textFillColor
                  }),
                  stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                    color: context.options.defaultStyles.textStrokeColor,
                    width: 3
                  })
                })
              }));
            };

            var popup = _this7._createLabelDiv({
              applyFunc: setTextValue,
              inputId: context._addUID("label-input"),
              geomType: "Text",
              key: "name",
              placeholder: "Saisir un label..."
            });

            popupOvl = new ol_Overlay__WEBPACK_IMPORTED_MODULE_4___default.a({
              element: popup,
              // FIXME : autres valeurs.
              positioning: "top-center" // par defaut, top-left...
              // stopEvent : false

            });
            context.getMap().addOverlay(popupOvl);
            popupOvl.setPosition(deEv.feature.getGeometry().getCoordinates());
            document.getElementById(_this7._addUID("label-input")).focus();
          });
        }

        break;

      case this._addUID("drawing-tool-edit"):
        if (context.dtOptions["edit"].active) {
          context.interactionSelectEdit = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Select"]({
            condition: ol_events_condition__WEBPACK_IMPORTED_MODULE_12__["singleClick"],
            layers: [this.layer]
          });
          context.interactionSelectEdit.setProperties({
            name: "Drawing",
            source: context
          });
          map.addInteraction(context.interactionSelectEdit);
          context.interactionCurrent = new ol_interaction__WEBPACK_IMPORTED_MODULE_11__["Modify"]({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            features: this.interactionSelectEdit.getFeatures(),
            style: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
              image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Circle"]({
                radius: this.options.cursorStyle.radius,
                stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                  color: this.options.cursorStyle.fillColor
                })
              })
            }) // deleteCondition : function (/* event */) { return false },
            // insertVertexCondition : function (/* event */) { return false }

          });
          context.interactionCurrent.on("modifyend", function (deEv) {
            var feature = deEv.features.item(0);

            context._updateMeasure(feature);
          });
        }

        break;

      case this._addUID("drawing-tool-display"):
        if (context.dtOptions["display"].active) {
          context.interactionCurrent = this._createStylingInteraction();
        }

        break;

      case this._addUID("drawing-tool-tooltip"):
        if (context.dtOptions["tooltip"].active) {
          context.interactionCurrent = this._createLabelInteraction();
        }

        break;

      case this._addUID("drawing-tool-remove"):
        if (context.dtOptions["remove"].active) {
          context.interactionCurrent = context._createRemoveInteraction();
        }

        break;

      default:
        logger.trace("unhandled tool type");
    }

    if (context.interactionCurrent) {
      context.interactionCurrent.setProperties({
        name: "Drawing",
        source: this
      });
      map.addInteraction(context.interactionCurrent);
    }

    logger.log("interactions", map.getInteractions());
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on 'GPshowDrawingPicto' tag label
   * (cf. this._createShowDrawingPictoElement),
   * and toggles event 'mousemove' on map.
   *
   * @method onShowDrawingClick
   * @private
   */


  Drawing.prototype.onShowDrawingClick = function () {
    var map = this.getMap(); // on supprime toutes les interactions

    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_15__["default"].unset(map); // checked : true - panel close
    // checked : false - panel open

    this.collapsed = this._showDrawingContainer.checked; // on génère nous même l'evenement OpenLayers de changement de propriété
    // (utiliser mousePosition.on("change:collapsed", function(e) ) pour s'abonner à cet évènement)

    this.dispatchEvent("change:collapsed"); // on deselectionne les Tools

    for (var toolsType in this.dtOptions) {
      if (this.dtOptions.hasOwnProperty(toolsType)) {
        if (this.dtOptions[toolsType].active) {
          var toolsId = this._addUID("drawing-tool-" + this.dtOptions[toolsType].id);

          document.getElementById(toolsId).className = "drawing-tool";
          this.dtOptions[toolsType].active = false;
        }
      }
    }
  };
  /**
   * this method is called by event 'click' on 'drawing-export' tag button.
   *
   * @method onExportFeatureClick
   * @private
   */


  Drawing.prototype.onExportFeatureClick = function () {
    var content = this.exportFeatures();

    if (!content) {
      return;
    }

    var link = document.createElement("a"); // FIXME : determiner le bon charset !

    var charset = "utf-8";
    link.setAttribute("href", "data:" + this._exportMimeType + ";charset=" + charset + "," + encodeURIComponent(content));
    link.setAttribute("download", this.getExportName() + this._exportExt);

    if (document.createEvent) {
      var event = document.createEvent("MouseEvents");
      event.initEvent("click", true, true);
      link.dispatchEvent(event);
    } else {
      link.click();
    }
  };

  return Drawing;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (Drawing); // Expose Drawing as ol.control.Drawing (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.Drawing = Drawing;
}

/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports = ol.Collection;

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = ol.layer.Vector;

/***/ }),
/* 197 */
/***/ (function(module, exports) {

module.exports = ol.geom;

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = ol.geom.LinearRing;

/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = ol.events.condition;

/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = ol.sphere;

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("DrawingDOM");
var DrawingDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPdrawing");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowDrawingElement: function _createShowDrawingElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowDrawing");
    input.className = "GPshowDrawing";
    input.type = "checkbox";
    return input;
  },

  /**
   * Show mouse position control
   *
   * @returns {DOMElement} DOM element
   */
  _createShowDrawingPictoElement: function _createShowDrawingPictoElement() {
    var self = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowDrawingPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowDrawing");
    label.title = this.options.labels.control; // gestionnaire d'evenement :
    // on ouvre le menu de saisie de saisie
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        self.onShowDrawingClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        self.onShowDrawingClick(e);
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowDrawingOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },

  /**
   * Drawing panel
   *
   * @returns {DOMElement} DOM element
   */
  _createDrawingPanelElement: function _createDrawingPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPdrawingPanel");
    div.className = "GPpanel";
    return div;
  },
  // ################################################################### //
  // ####################### Panel container ########################### //
  // ################################################################### //

  /**
  * Creates drawing Panel header DOM structure
  * @returns {DOMElement} DOM element
  */
  _createDrawingPanelHeaderElement: function _createDrawingPanelHeaderElement() {
    /*
     * <div class="GPpanelHeader">
     *     <div class="GPpanelTitle">Annoter la carte</div>
     *     <div id="GPdrawingPanelClose" class="GPpanelClose" title="Fermer le panneau"></div>
     * </div>
     */
    var container = document.createElement("div");
    container.className = "GPpanelHeader";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle";
    divTitle.innerHTML = this.options.controlLabel || "Annoter la carte";
    container.appendChild(divTitle);
    var divClose = document.createElement("div");
    divClose.id = this._addUID("GPdrawingPanelClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer le panneau"; // Link panel close / visibility checkbox

    var dtObj = this;

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(dtObj._addUID("GPshowDrawingPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(dtObj._addUID("GPshowDrawingPicto")).click();
      });
    }

    container.appendChild(divClose);
    return container;
  },

  /**
   * Creates drawing tools section.
   *
   * @returns {DOMElement} DOM element
   */
  _createDrawingToolsSections: function _createDrawingToolsSections() {
    var tools = [];
    this.dtOptions = {};

    if (this.options.tools.points) {
      this.dtOptions.points = {
        label: this.options.labels.points,
        active: false,
        panel: "draw",
        id: "point"
      };
    }

    if (this.options.tools.lines) {
      this.dtOptions.lines = {
        label: this.options.labels.lines,
        active: false,
        panel: "draw",
        id: "line"
      };
    }

    if (this.options.tools.polygons) {
      this.dtOptions.polygons = {
        label: this.options.labels.polygons,
        active: false,
        panel: "draw",
        id: "polygon"
      };
    }

    if (this.options.tools.holes) {
      this.dtOptions.holes = {
        label: this.options.labels.holes,
        active: false,
        panel: "draw",
        id: "holes"
      };
    }

    if (this.options.tools.text) {
      this.dtOptions.text = {
        label: this.options.labels.text,
        active: false,
        panel: "draw",
        id: "text"
      };
    }

    if (this.options.tools.edit) {
      this.dtOptions.edit = {
        label: this.options.labels.edit,
        active: false,
        panel: "edit",
        id: "edit"
      };
    }

    if (this.options.tools.display) {
      this.dtOptions.display = {
        label: this.options.labels.display,
        active: false,
        panel: "edit",
        id: "display"
      };
    }

    if (this.options.tools.tooltip) {
      this.dtOptions.tooltip = {
        label: this.options.labels.tooltip,
        active: false,
        panel: "edit",
        id: "tooltip"
      };
    }

    if (this.options.tools.remove) {
      this.dtOptions.remove = {
        label: this.options.labels.remove,
        active: false,
        panel: "edit",
        id: "remove"
      };
    } // ajout drawing tools


    if (this.dtOptions.points || this.dtOptions.lines || this.dtOptions.polygons || this.dtOptions.text) {
      tools.push(this._createDrawingToolSection(this.options.labels.creatingTools, "draw"));
    } // ajout editing tools


    if (this.dtOptions.edit || this.dtOptions.display || this.dtOptions.tooltip || this.dtOptions.remove) {
      tools.push(this._createDrawingToolSection(this.options.labels.editingTools, "edit"));
    } // ajout export tools


    if (this.options.tools["export"]) {
      tools.push(this._createSavingSection(this.options.labels["export"], this.options.labels.exportTitle));
    }

    return tools;
  },

  /**
   * Creates drawing tool section DOM structure.
   *
   * @param {String} sectionLabel - section title
   * @param {String} panelType - Drawing ("draw") or editing ("edit") tools panel
   * @returns {DOMElement} DOM element
   */
  _createDrawingToolSection: function _createDrawingToolSection(sectionLabel, panelType) {
    /*
     * Exemple panelType == "draw"
     *
     * <div class="drawing-tool-section">
     *     <p class="drawing-tool-section-title">Outils de création</p>
     *     <ul class="drawing-tools-flex-display">
     *         <li id="drawing-tool-point" class="drawing-tool" title="Placer des points"></li>
     *         <li id="drawing-tool-line" class="drawing-tool" title="Dessiner des lignes"></li>
     *         <li id="drawing-tool-polygon" class="drawing-tool" title="Dessiner des polygones"></li>
     *         <li id="drawing-tool-text" class="drawing-tool" title="Ecrire sur la carte"></li>
     *     </ul>
     * </div>
     */
    var container = document.createElement("div");
    container.className = "drawing-tool-section";
    var p = document.createElement("p");
    p.className = "drawing-tool-section-title";
    p.innerHTML = sectionLabel;
    container.appendChild(p);
    var ul = document.createElement("ul");
    ul.className = "drawing-tools-flex-display";
    var context = this; // li click handler function

    function liClickHandler(e) {
      /* jshint validthis: true */
      // this == elem clicked
      context._handleDOMToolClick(e, this.id, context);

      context._handleToolClick(e, this.id, context);
    }

    for (var type in this.dtOptions) {
      if (this.dtOptions[type].panel !== panelType) {
        continue;
      }

      var li = document.createElement("li");
      li.className = "drawing-tool";
      li.id = this._addUID("drawing-tool-" + this.dtOptions[type].id);
      li.title = this.dtOptions[type].label;
      li.addEventListener("click", liClickHandler);
      ul.appendChild(li);
    }

    container.appendChild(ul);
    return container;
  },

  /**
   * Creates drawing tool section DOM structure.
   *
   * @param {String} buttonLabel - Button label
   * @param {String} buttonTitle - Button title
   * @returns {DOMElement} DOM element
   */
  _createSavingSection: function _createSavingSection(buttonLabel, buttonTitle) {
    /*
     * <div class="drawing-tool-section drawing-tools-flex-display">
     *     <button title="Exporter en KML" class="tool-form-submit drawing-button" id="drawing-export" type="button">Exporter</button>
     * </div>
     */
    var container = document.createElement("div");
    container.className = "drawing-tool-section drawing-tools-flex-display";
    var button = document.createElement("button");
    button.title = buttonTitle;
    button.className = "tool-form-submit drawing-button";
    button.id = this._addUID("drawing-export");
    button.type = "button";
    button.textContent = buttonLabel;
    var context = this;
    /** export function */

    button.onclick = function () {
      context.onExportFeatureClick();
    };

    container.appendChild(button);
    return container;
  },

  /**
   * Creates input for color choosing
   *
   * @param {Object} options - options
   * @param {String} options.defaultValue - defaultValue
   * @param {String} options.className - input className
   * @returns {DOMElement} - created li element
   */
  _createMarkersChooser: function _createMarkersChooser(options) {
    var li = document.createElement("li");
    li.className = options.className;

    for (var i = 0; i < this.options.markersList.length; i++) {
      // radio bouton pour la selection
      var inputElem = document.createElement("input");
      inputElem.type = "radio";
      inputElem.name = "marker";
      inputElem.id = this._addUID("marker-" + i);
      inputElem.value = this.options.markersList[i].src;
      inputElem.className = "marker-input-radio";

      if (options.defaultValue === inputElem.value) {
        inputElem.checked = true;
      }

      li.appendChild(inputElem); // label pour l'affichage du marker

      var labelElem = document.createElement("label");
      labelElem.className = "marker-label"; // utile ?

      labelElem.setAttribute("for", inputElem.id);
      var imgElem = document.createElement("img");
      imgElem.src = inputElem.value;
      labelElem.appendChild(imgElem);
      li.appendChild(labelElem);
    }

    return li;
  },

  /**
   * Creates input for color choosing
   *
   * @param {Object} options - options
   * @param {String} options.label - label
   * @param {String} options.type - input type for element ("color")
   * @param {String} options.defaultValue - defaultValue
   * @param {String} options.id - input id
   * @param {String} options.title - input title
   * @param {String} options.className - input className
   * @returns {DOMElement} - created li element
   */
  _createStylingElement: function _createStylingElement(options) {
    var li = document.createElement("li");
    li.className = options.className;
    var textNode = document.createTextNode(options.label);
    li.appendChild(textNode);
    var inputElem = document.createElement("input");

    try {
      inputElem.type = options.type;
    } catch (e) {
      // ie 11 input type== color ne marche pas...
      inputElem.type = "text";
    }

    inputElem.id = options.id;
    inputElem.value = options.defaultValue;

    if (options.title) {
      inputElem.title = options.title;
    } // si options.type == "range"


    if (options.min !== undefined) {
      inputElem.min = options.min;
    }

    if (options.max !== undefined) {
      inputElem.max = options.max;
    }

    if (options.step !== undefined) {
      inputElem.step = options.step;
    }

    li.appendChild(inputElem);
    return li;
  },

  /**
   * Creates Styling div to include in popup.
   *
   * @param {Object} options - toolId selected
   * @param {String} options.geomType - gemeotryType selected ("Point", "Line" or "Polygon")
   * @param {Object} options.labels - values to title
   * @param {Object} options.initValues - values to init fields
   * @param {Function} options.applyFunc - function called when apply is selected
   * @returns {DOMElement} DOM element created
   */
  _createStylingDiv: function _createStylingDiv(options) {
    var div = document.createElement("div");
    div.className = "gp-styling-div";
    var ul = document.createElement("ul");
    var li = null;
    /*
     * TODO : finir de remplir la div pour tous les styles éditables.
     */

    switch (options.geomType.toLowerCase()) {
      case "point":
        li = this._createMarkersChooser({
          className: "gp-styling-option",
          // defaultValue : this.options.markersList[0].src
          defaultValue: options.initValues.markerSrc
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option",
          label: this.options.labels.markerSize,
          title: "petit, moyen ou grand",
          id: this._addUID("markerSize"),
          min: 5,
          max: 15,
          step: 5,
          defaultValue: options.initValues.markerSize * 10
        });
        ul.appendChild(li);

        if (options.initValues.markerCustom) {
          li = this._createStylingElement({
            type: "color",
            className: "gp-styling-option",
            label: this.options.labels.markerColor,
            id: this._addUID("markerColor"),
            defaultValue: options.initValues.markerColor
          });
          ul.appendChild(li);
        }

        break;

      case "text":
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.fillColor,
          id: this._addUID("fillColor"),
          defaultValue: options.initValues.fillColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.strokeColor,
          id: this._addUID("strokeColor"),
          defaultValue: options.initValues.strokeColor
        });
        ul.appendChild(li);
        break;

      case "line":
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.strokeColor,
          id: this._addUID("strokeColor"),
          defaultValue: options.initValues.strokeColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option",
          label: this.options.labels.strokeWidth,
          title: "1 à 10 pixels",
          id: this._addUID("strokeWidth"),
          min: 1,
          max: 10,
          step: 1,
          defaultValue: options.initValues.strokeWidth
        });
        ul.appendChild(li);
        break;

      case "polygon":
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.strokeColor,
          id: this._addUID("strokeColor"),
          defaultValue: options.initValues.strokeColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option",
          label: this.options.labels.strokeWidth,
          title: "1 à 10 pixels",
          id: this._addUID("strokeWidth"),
          min: 1,
          max: 10,
          step: 1,
          defaultValue: options.initValues.strokeWidth
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.fillColor,
          id: this._addUID("fillColor"),
          defaultValue: options.initValues.fillColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option",
          label: this.options.labels.fillOpacity,
          title: "0 (transparent) à 100% (opaque)",
          id: this._addUID("fillOpacity"),
          min: 0,
          max: 10,
          step: 1,
          defaultValue: options.initValues.fillOpacity * 10
        });
        ul.appendChild(li);
        break;

      default:
        logger.log("Unhandled geometry type for styling.");
    }

    div.appendChild(ul); // apply button

    var applyButton = document.createElement("input");
    applyButton.type = "button";
    applyButton.className = "gp-styling-button";
    applyButton.value = this.options.labels.applyToObject;
    /** click sur applyButton */

    applyButton.onclick = function () {
      options.applyFunc.call(this, "apply");
    };

    div.appendChild(applyButton); // set default button

    var setDefaultButton = document.createElement("input");
    setDefaultButton.type = "button";
    setDefaultButton.value = this.options.labels.setAsDefault;
    setDefaultButton.className = "gp-styling-button";
    /** click sur set Default Button */

    setDefaultButton.onclick = function () {
      options.applyFunc.call(this, "default");
    };

    div.appendChild(setDefaultButton); // cancel Button

    var cancelButton = document.createElement("input");
    cancelButton.type = "button"; // cancelButton.value = "X" ;

    cancelButton.className = "gp-styling-button closer";
    /** click sur cancel Button */

    cancelButton.onclick = function () {
      options.applyFunc.call(this, "cancel");
    };

    div.appendChild(cancelButton);
    return div;
  },

  /**
   * Creates Text editing div to include in popup.
   *
   * @param {Object} options - options for popup
   * @param {String} options.geomType - gemeotryType selected ("Point", "Line" or "Polygon")
   * @param {String} options.text - text to fill input.
   * @param {String} options.key - property name called when text is to be saved.
   * @param {String} options.measure - measure to fill input.
   * @param {String} options.placeholder - placeholder for text input.
   * @param {String} options.inputId - text input id.
   * @param {Function} options.applyFunc - function called when text is to be saved.
   * @returns {DOMElement} DOM element created
   * @private
   */
  _createLabelDiv: function _createLabelDiv(options) {
    var popup = document.createElement("div");
    popup.className = "gp-label-div";
    var inputLabel = null;

    if (options.geomType === "Text") {
      inputLabel = document.createElement("input");
      inputLabel.type = "text";
      inputLabel.className = "gp-input-label-style";
    } else {
      inputLabel = document.createElement("textArea");
      inputLabel.rows = 2;
      inputLabel.cols = 40;
      inputLabel.className = "gp-textarea-att-label-style";
    }

    if (options.text) {
      inputLabel.value = options.text;
    }

    inputLabel.autocomplete = "off";
    inputLabel.placeholder = options.placeholder;
    inputLabel.id = options.inputId;
    popup.appendChild(inputLabel); // blur

    inputLabel.onblur = function () {
      options.applyFunc.call(this, options.key, inputLabel.value, true);
    }; // keyup


    inputLabel.onkeyup = function (evtk) {
      if (options.geomType === "Text" && evtk.keyCode === 13) {
        options.applyFunc.call(this, options.key, inputLabel.value, true);
      }

      if (evtk.keyCode === 27) {
        options.applyFunc.call(this, options.key, inputLabel.value, false);
      }
    };

    if (options.measure && options.geomType !== "Text") {
      var inputMeasure = document.createElement("input");
      inputMeasure.type = "text";
      inputMeasure.readonly = true;
      inputMeasure.className = "gp-input-measure-style";
      inputMeasure.value = options.measure;
      popup.appendChild(inputMeasure);
    }

    if (options.geomType !== "Text") {
      // apply button
      var applyButton = document.createElement("input");
      applyButton.type = "button";
      applyButton.className = "gp-styling-button";
      applyButton.value = this.options.labels.saveDescription;
      /** click sur applyButton */

      applyButton.onclick = function () {
        options.applyFunc.call(this, options.key, inputLabel.value, true);
      };

      popup.appendChild(applyButton); // cancel Button

      var cancelButton = document.createElement("input");
      cancelButton.type = "button";
      cancelButton.className = "gp-styling-button closer";
      /** click sur cancel Button */

      cancelButton.onclick = function () {
        options.applyFunc.call(this, options.key, inputLabel.value, false);
      };

      popup.appendChild(cancelButton);
    }

    return popup;
  },

  /**
   * Handles drawing tool selection from a DOM point of view.
   *
   * @param {Event} e - DOM Event
   * @param {String} toolId - toolId selected
   * @param {DrawingDOM} context - Drawing control instance
   */
  _handleDOMToolClick: function _handleDOMToolClick(e, toolId, context) {
    for (var availType in context.dtOptions) {
      var availToolId = context._addUID("drawing-tool-" + context.dtOptions[availType].id);

      var li = document.getElementById(availToolId); // ce n'est pas l'outil selectionne : on le desactive (s'il ne l'était pas déjà).

      if (availToolId !== toolId) {
        li.className = "drawing-tool";
        context.dtOptions[availType].active = false;
        continue;
      } // ici, c'est le l'outil selectionne


      if (context.dtOptions[availType].active) {
        li.className = "drawing-tool";
      } else {
        li.className = "drawing-tool drawing-tool-active";
      }

      context.dtOptions[availType].active = !context.dtOptions[availType].active;
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (DrawingDOM);

/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Route_GProuteOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _CSS_Controls_Route_GProuteOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Route_GProuteOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(171);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(157);
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(199);
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_events_condition__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(48);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(180);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(172);
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(178);
/* harmony import */ var _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(185);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(179);
/* harmony import */ var _LocationSelector__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(203);
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(169);
/* harmony import */ var _Common_Controls_RouteDOM__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(205);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import OpenLayers










 // import geoportal library access

 // import local







 // import local with ol dependencies


 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_12__["default"].getLogger("route");
/**
 * @classdesc
 *
 * Route Control.
 *
 * @constructor
 * @alias ol.control.Route
 * @extends {ol.control.Control}
 * @param {Object} options - route control options
 * @param {String}   [options.apiKey] - API key for services call (route and autocomplete services), mandatory if autoconf service has not been charged in advance
 * @param {Boolean}   [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Object}  [options.exclusions = {"toll" : false, "tunnel" : false, "bridge" : false}] - list of exclusions with status (true = checked). By default : no exclusions checked.
 * @param {Array}   [options.graphs = ["Voiture", "Pieton"]] - list of resources, by default : ["Voiture", "Pieton"]. The first element is selected.
 * @param {Object} [options.routeOptions = {}] - route service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~route Gp.Services.route()} to know all route options.
 * @param {Object} [options.autocompleteOptions = {}] - autocomplete service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options
 * @param {Object} [options.markersOpts] - options to use your own markers. Object properties can be "departure", "stages" or "arrival". Corresponding value is an object with following properties :
 * @param {String} [options.markersOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
 * @param {Array} [options.markersOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see http://openlayers.org/en/latest/apidoc/ol.Overlay.html)
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Itinéraire"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Itinéraire basé sur un graphe"] - Layer description to be displayed in LayerSwitcher
 * @fires route:drawstart
 * @fires route:drawend
 * @fires route:compute
 * @example
 *  var route = ol.control.Route({
 *      "collapsed" : true
 *      "draggable" : true,
 *      "exclusions" : {
 *         "toll" : true,
 *         "bridge" : false,
 *         "tunnel" : true
 *      },
 *      "graphs" : ['Pieton', 'Voiture'],
 *      "markersOpts" : {
 *          "departure" : {
 *              "url" : "...",
 *              "offset" : [0,0]
 *          },
 *          "stages" : {
 *              "url" : "...",
 *              "offset" : [0,0]
 *          },
 *          "arrival" : {
 *              "url" : "...",
 *              "offset" : [0,0]
 *          }
 *      }
 *      "autocompleteOptions" : {},
 *      "routeOptions" : {}
 *  });
 */

var Route = function (Control) {
  function Route(options) {
    options = options || {};

    if (!(this instanceof Route)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // initialisation du composant


    this.initialize(options); // Widget main DOM container

    this._container = this._createMainContainerElement();
    this._containerElement = null; // on peut éventuellement encapsuler le composant dans une div passée par l'utilisateur

    if (options.element && options.element.appendChild) {
      // dans ce cas on stocke les deux container
      options.element.appendChild(this._container);
      this._containerElement = options.element;
    } // call ol.control.Control constructor


    Control.call(this, {
      element: this._containerElement || this._container,
      target: options.target,
      render: options.render
    });
  } // Inherits from ol.control.Control


  if (Control) Route.__proto__ = Control;
  /**
   * @lends module:Route
   */

  Route.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune RouteDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_13__["default"].assign(Route.prototype, _Common_Controls_RouteDOM__WEBPACK_IMPORTED_MODULE_21__["default"]);
  /**
   * Constructor (alias)
   * @private
   */

  Route.prototype.constructor = Route; // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */

  Route.prototype.getCollapsed = function () {
    return this.collapsed;
  };
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */


  Route.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.log("[ERROR] Route:setCollapsed - missing collapsed parameter");
      return;
    }

    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }

    if (collapsed) {
      document.getElementById("GProutePanelClose-" + this._uid).click();
    } else {
      document.getElementById("GPshowRoute-" + this._uid).click();
    }

    this.collapsed = collapsed;
  };
  /**
   * Get vector layer where geoJson route is drawn
   *
   * @returns {Object} layer - ol.layer.Vector route layer
   */


  Route.prototype.getLayer = function () {
    return this._geojsonSections;
  };
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */


  Route.prototype.setMap = function (map) {
    if (map) {
      // enrichissement du DOM du container
      this._container = this._initContainer(map); // mode "draggable"

      if (this.draggable) {
        _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_17__["default"].dragElement(this._panelRouteContainer, this._panelHeaderRouteContainer, map.getTargetElement());
      }
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Get route informations
   *
   * @returns {Object} data - route informations
   */


  Route.prototype.getData = function () {
    return this._currentRouteInformations;
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize route control (called by Route constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */


  Route.prototype.initialize = function (options) {
    this._checkInputOptions(options); // set default options


    this.options = {
      collapsed: true,
      draggable: false,
      graphs: ["Voiture", "Pieton"],
      exclusions: {
        toll: false,
        tunnel: false,
        bridge: false
      },
      routeOptions: {},
      autocompleteOptions: {},
      layerDescription: {
        title: "Itinéraire",
        description: "Itinéraire basé sur un graphe"
      }
    }; // merge with user options

    _Common_Utils__WEBPACK_IMPORTED_MODULE_13__["default"].assign(this.options, options); // cas particulier des markers par défaut

    var defaultMarkersOpts = {
      departure: {
        url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_16__["default"]["red"],
        offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_16__["default"].defaultOffset
      },
      stages: {
        url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_16__["default"]["lightOrange"],
        offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_16__["default"].defaultOffset
      },
      arrival: {
        url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_16__["default"]["darkOrange"],
        offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_16__["default"].defaultOffset
      }
    }; // on récupère les options de chaque type de marker si spécifié

    this.options.markersOpts = _Common_Utils__WEBPACK_IMPORTED_MODULE_13__["default"].assign(defaultMarkersOpts, options.markersOpts);
    /** {Boolean} specify if Route control is collapsed (true) or not (false) */

    this.collapsed = this.options.collapsed;
    /** {Boolean} specify if Route control is draggable (true) or not (false) */

    this.draggable = this.options.draggable;
    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_15__["default"].generate(); // containers principaux

    this._panelRouteContainer = null;
    this._panelHeaderRouteContainer = null;
    this._waitingContainer = null;
    this._formRouteContainer = null;
    this._resultsRouteContainer = null;
    this._showRouteExclusionsElement = null; // liste de points selectionnée

    this._currentPoints = []; // Mode de transport selectionné : 'Voiture' ou 'Pieton'

    this._currentTransport = null;

    this._initTransport(); // Mode de calcul selectionné : 'Plus rapide' ou 'plus court'


    this._currentComputation = null;

    this._initComputation(); // Exclusions selectionnées : Tunnel, Toll et Bridge


    this._currentExclusions = [];

    this._initExclusions(); // si un calcul est en cours ou non


    this._waiting = false; // timer pour cacher la patience après un certain temps

    this._timer = null; // la geometrie du parcours

    this._geojsonRoute = null; // la geometrie des troncons

    this._geojsonSections = null; // le container de la popup (pour les troncons selectionnés)

    this._popupContent = null;
    this._popupDiv = this._initPopupDiv(); // l'overlay ol.Overlay correspondant à la popup (pour les troncons selectionnés)

    this._popupOverlay = null; // ol.interaction.Select associées à la couche des résultats (troncons)

    this._resultsSelectInteraction = null;
    this._resultsHoverInteraction = null; // styles pour les sélections des features

    this._defaultFeatureStyle = new ol_style__WEBPACK_IMPORTED_MODULE_9__["Style"]({
      stroke: new ol_style__WEBPACK_IMPORTED_MODULE_9__["Stroke"]({
        color: "rgba(0,183,152,0.9)",
        width: 12
      })
    });
    this._selectedFeatureStyle = new ol_style__WEBPACK_IMPORTED_MODULE_9__["Style"]({
      stroke: new ol_style__WEBPACK_IMPORTED_MODULE_9__["Stroke"]({
        color: "rgba(255,102,0,0.9)",
        width: 12
      })
    }); // reponse du service
    // Ex. {
    //   totalTime, totalDistance, bbox, routeGeometry,
    //   routeInstructions : [{duration, distance, code, instruction, bbox, geometry}]
    // }

    this._currentRouteInformations = null; // liste des ressources avec droits par service
    // Ex. {
    //   "Route" : {
    //       key : "ger4g456re45er456t4er5ge5",
    //       resources : ["Pieton", "Voiture"]
    //   }
    // }

    this._resources = {}; // gestion des droits sur les ressources

    this._noRightManagement = false; // gestion des droits sur les ressources/services

    this._checkRightsManagement(); // listener key for event on pointermove or moveend map


    this.listenerKey = null;
  };
  /**
   * this method is called by this.initialize()
   *
   * @param {Object} options - options
   *
   * @private
   */


  Route.prototype._checkInputOptions = function (options) {
    // vérification des options
    // mode de transport
    if (options.graphs) {
      // on ne permet pas de passer un tableau vide : on spécifie au moins un graph
      if (Array.isArray(options.graphs) && options.graphs.length) {
        for (var i = 0; i < options.graphs.length; i++) {
          if (typeof options.graphs[i] === "string") {
            if (options.graphs[i].toLowerCase() === "pieton") {
              options.graphs[i] = "Pieton";
            }

            if (options.graphs[i].toLowerCase() === "voiture") {
              options.graphs[i] = "Voiture";
            }
          } else {
            logger.log("[ol.control.Route] ERROR : parameter 'graphs' elements should be of type 'string'");
            options.graphs[i] = null;
          }
        }
      } else {
        logger.warn("'graphs' parameter should be an array");
        options.graphs = null;
      }
    } // collapsed


    if (options.collapsed === "true") {
      options.collapsed = true;
    }

    if (options.collapsed === "false") {
      options.collapsed = false;
    }
  };
  /**
   * Check rights to resources (called by constructor)
   *
   * @private
   */


  Route.prototype._checkRightsManagement = function () {
    var _opts = null;
    var _res = [];
    var _key = null; // les ressources du service du calcul d'Itineraire

    _key = this.options.routeOptions.apiKey;
    _opts = this.options.routeOptions.filterOptions;
    _res = _opts ? _opts.type : [];

    if (!_res || _res.length === 0) {
      _res = ["Voiture", "Pieton"];
    }

    var rightManagementRoute = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_14__["default"].check({
      key: _key || this.options.apiKey,
      resources: _res,
      services: ["Itineraire"]
    });
    logger.log("rightManagementRoute", rightManagementRoute); // les ressources du service d'autocompletion

    _key = this.options.autocompleteOptions.apiKey;
    _opts = this.options.autocompleteOptions.filterOptions;
    _res = _opts ? _opts.type : [];

    if (!_res || _res.length === 0) {
      _res = ["PositionOfInterest", "StreetAddress"];
    }

    var rightManagementAutoComplete = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_14__["default"].check({
      key: _key || this.options.apiKey,
      resources: _res,
      services: ["AutoCompletion"]
    });
    logger.log("rightManagementAutoComplete", rightManagementAutoComplete); // au cas où pas de droit !

    if (!rightManagementRoute && !rightManagementAutoComplete) {
      this._noRightManagement = true;
    } // FIXME je reconstruis differement la structure pour la gestion des clefs differentes
    // pour chaque service...


    if (rightManagementAutoComplete) {
      this._resources["AutoCompletion"] = {};
      this._resources["AutoCompletion"]["resources"] = rightManagementAutoComplete["AutoCompletion"];
      this._resources["AutoCompletion"]["key"] = rightManagementAutoComplete["key"];
    }

    if (rightManagementRoute) {
      this._resources["Itineraire"] = {};
      this._resources["Itineraire"]["resources"] = rightManagementRoute["Itineraire"];
      this._resources["Itineraire"]["key"] = rightManagementRoute["key"];
    }
  };
  /**
   * initialize component container (DOM)
   *
   * @param {Object} map - the map
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  Route.prototype._initContainer = function (map) {
    var _this = this;

    // get main container
    var container = this._container;

    var inputShow = this._showRouteContainer = this._createShowRouteElement();

    container.appendChild(inputShow); // mode "collapsed"

    if (!this.collapsed) {
      inputShow.checked = true;
    }

    var picto = this._createShowRoutePictoElement();

    container.appendChild(picto);

    var routePanel = this._panelRouteContainer = this._createRoutePanelElement(); // header form


    var routeHeader = this._panelHeaderRouteContainer = this._createRoutePanelHeaderElement();

    routePanel.appendChild(routeHeader); // form

    var routeForm = this._formRouteContainer = this._createRoutePanelFormElement(); // form: menu des points


    var points = this._createRoutePanelFormPointsElement(map);

    for (var i = 0; i < points.length; i++) {
      routeForm.appendChild(points[i]);
    } // form: menu des modes


    var choice = this._createRoutePanelFormModeChoiceElement();

    choice.appendChild(this._createRoutePanelFormModeChoiceTransportElement(this.options.graphs));
    choice.appendChild(this._createRoutePanelFormModeChoiceComputeElement());
    routeForm.appendChild(choice); // form: menu des exclusions

    routeForm.appendChild(this._createShowRouteExclusionsElement());
    this._showRouteExclusionsElement = this._createShowRouteExclusionsPictoElement();
    routeForm.appendChild(this._showRouteExclusionsElement);

    var exclusion = this._createRoutePanelFormExclusionsElement();

    exclusion.appendChild(this._createRoutePanelFormExclusionOptionsElement(this.options.exclusions));
    routeForm.appendChild(exclusion);

    var divReset = this._createRouteFormResetElement();

    routeForm.appendChild(divReset); // form: bouton du calcul

    var submit = this._createRouteSubmitFormElement();

    routeForm.appendChild(submit);
    routePanel.appendChild(routeForm); // results

    var routeResults = this._resultsRouteContainer = this._createRoutePanelResultsElement();

    routePanel.appendChild(routeResults); // waiting

    var waiting = this._waitingContainer = this._createRouteWaitingElement();

    routePanel.appendChild(waiting);
    container.appendChild(routePanel); // hide autocomplete suggested locations on container click

    if (container.addEventListener) {
      container.addEventListener("click", function (e) {
        return _this._hideRouteSuggestedLocations(e);
      });
    }

    return container;
  }; // ################################################################### //
  // ####################### init application ########################## //
  // ################################################################### //

  /**
   * this method is called by the constructor and initialize transport mode
   * ("Voiture" ou "Pieton")
   *
   * @private
   */


  Route.prototype._initTransport = function () {
    // Mode de transport selectionné
    this._currentTransport = "Voiture"; // par defaut
    // par defaut

    var transport = this.options.graphs;

    if (!transport || transport.length === 0) {
      this.options.graphs = ["Voiture", "Pieton"];
    } // option


    if (Array.isArray(transport) && transport.length) {
      // FIXME pb si le 1er graphe n'est pas une ressource connue !
      if (transport[0] === "Voiture" || transport[0] === "Pieton") {
        this._currentTransport = transport[0];
      }
    } // TODO option sur le service


    var serviceOptions = this.options.routeOptions;

    if (serviceOptions.graph) {
      this._currentTransport = serviceOptions.graph;
    }
  };
  /**
   * this method is called by the constructor and initialize computation mode
   * (fastest or shortest)
   *
   * @private
   */


  Route.prototype._initComputation = function () {
    // Mode de calcul selectionné
    this._currentComputation = "fastest"; // par defaut
    // TODO option sur le service

    var serviceOptions = this.options.routeOptions;

    if (serviceOptions.routePreference) {
      this._currentComputation = serviceOptions.routePreference;
    }
  };
  /**
   * this method is called by the constructor and initialize exclusions
   *
   * @private
   */


  Route.prototype._initExclusions = function () {
    // Exclusions selectionnées : Tunnel, Toll et Bridge
    this._currentExclusions = []; // par defaut
    // par defaut

    var exclusion = this.options.exclusions;

    if (!exclusion || _typeof(exclusion) === "object" && Object.keys(exclusion).length === 0) {
      this.options.exclusions = {
        toll: false,
        tunnel: false,
        bridge: false
      };
    } // option


    if (exclusion && _typeof(exclusion) === "object" && Object.keys(exclusion).length) {
      for (var k in exclusion) {
        if (exclusion.hasOwnProperty(k)) {
          if (exclusion[k]) {
            this._currentExclusions.push(k);
          }
        }
      }
    } // TODO option sur le service


    var serviceOptions = this.options.routeOptions;

    if (Array.isArray(serviceOptions.exclusions)) {
      this._currentExclusions = serviceOptions.exclusions;
    }
  };
  /**
   * this method is called by this.initialize() and initialize popup div
   * (to display results information on route result click)
   *
   * @return {Object} element - DOM element for popup
   * @private
   */


  Route.prototype._initPopupDiv = function () {
    var context = this;
    var element = document.createElement("div");
    element.className = "gp-feature-info-div";
    var closer = document.createElement("input");
    closer.type = "button";
    closer.className = "gp-styling-button closer"; // on closer click : remove popup

    closer.onclick = function () {
      if (context._popupOverlay != null) {
        context._popupOverlay.setPosition(undefined);
      }

      return false;
    };

    this._popupContent = document.createElement("div");
    this._popupContent.className = "gp-features-content-div";
    element.appendChild(this._popupContent);
    element.appendChild(closer);
    return element;
  }; // ################################################################### //
  // ############################## DOM ################################ //
  // ################################################################### //

  /**
   * Create List Points
   * Overwrite RouteDOM method !
   *
   * @param {Object} map - the map
   *
   * @returns {Array} List DOM element
   * @private
   */


  Route.prototype._createRoutePanelFormPointsElement = function (map) {
    var points = [];
    var count = 1; // point de depart

    var start = new _LocationSelector__WEBPACK_IMPORTED_MODULE_19__["default"]({
      apiKey: this.options.apiKey || null,
      tag: {
        id: count,
        groupId: this._uid,
        markerOpts: this.options.markersOpts["departure"],
        label: "Départ",
        display: true
      },
      autocompleteOptions: this.options.autocompleteOptions || null
    });
    start.setMap(map); // on ajoute des écouteurs d'évènements (en plus de ceux de LocationSelector),
    // pour prendre en compte les CSS spécifiques de GProuteForm

    this._addFormPointsEventListeners(start);

    points.push(start._container);

    this._currentPoints.push(start); // points intermediaires


    for (count = 2; count < 7; count++) {
      var step = new _LocationSelector__WEBPACK_IMPORTED_MODULE_19__["default"]({
        apiKey: this.options.apiKey || null,
        tag: {
          id: count,
          groupId: this._uid,
          label: "Etape",
          markerOpts: this.options.markersOpts["stages"],
          display: false,
          removeOption: true
        },
        autocompleteOptions: this.options.autocompleteOptions || null
      });
      step.setMap(map);

      this._addFormPointsEventListeners(step);

      points.push(step._container);

      this._currentPoints.push(step);
    } // point d'arrivée


    var end = new _LocationSelector__WEBPACK_IMPORTED_MODULE_19__["default"]({
      apiKey: this.options.apiKey || null,
      tag: {
        id: count,
        groupId: this._uid,
        markerOpts: this.options.markersOpts["arrival"],
        label: "Arrivée",
        display: true,
        addOption: true
      },
      autocompleteOptions: this.options.autocompleteOptions || null
    });
    end.setMap(map);

    this._addFormPointsEventListeners(end);

    points.push(end._container);

    this._currentPoints.push(end);

    return points;
  };
  /**
   * Attach events listeners to route form points (locationSelector)
   *
   * @param {Object} formPoint - route form point (locationSelector)
   * @private
   */


  Route.prototype._addFormPointsEventListeners = function (formPoint) {
    var _this2 = this;

    if (!formPoint) {
      return;
    }

    if (formPoint._inputLabelContainer.addEventListener) {
      // display form on origin label click
      formPoint._inputLabelContainer.addEventListener("click", function (e) {
        return _this2.onRouteOriginLabelClick(e);
      }); // minimize form on input show pointer, and set map event listeners (see this.onRouteOriginPointerClick)


      formPoint._inputShowPointer.addEventListener("click", function (e) {
        return _this2.onRouteOriginPointerClick(e, formPoint);
      });

      if (formPoint._removePointElement) {
        formPoint._removePointElement.addEventListener("click", function (e) {
          logger.trace("click on _removePointElement", e); // Moving up exclusions picto
          // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
          // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + "px";
        });
      }

      if (formPoint._addPointElement) {
        formPoint._addPointElement.addEventListener("click", function (e) {
          logger.trace("click on _addPointElement", e); // Moving down exclusions picto
          // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
          // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + "px";
        });
      }
    } else if (formPoint._inputLabelContainer.attachEvent) {
      // attachEvent: Internet explorer event listeners management
      formPoint._inputLabelContainer.attachEvent("onclick", function (e) {
        return _this2.onRouteOriginLabelClick(e);
      });

      formPoint._inputShowPointer.attachEvent("onclick", function (e) {
        return _this2.onRouteOriginPointerClick(e, formPoint);
      });

      if (formPoint._removePointElement) {
        formPoint._removePointElement.attachEvent("onclick", function (e) {// Moving up exclusions picto
          // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
          // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + "px";
        });
      }

      if (formPoint._addPointElement) {
        formPoint._addPointElement.attachEvent("onclick", function (e) {// Moving down exclusions picto
          // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
          // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + "px";
        });
      }
    }
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'submit' on 'GProuteForm' tag form
   * (cf. this._createRoutePanelFormElement), and it displays the results.
   *
   * @param {Object} options - options
   * @private
   */


  Route.prototype.onRouteComputationSubmit = function (options) {
    logger.log("onRouteComputationSubmit", options); // FIXME on lance une requête en EPSG:4326, les coordonnées
    // doivent donc être du type cad en lat/lon.
    // or, BUG du service du calcul d'itineraire car les
    // coordonnées envoyées doivent être en lon/lat avec une SRS en EPSG:4326 !?
    // sinon, ça plante...
    // Liste des points

    var points = this._currentPoints; // - point de depart (info: points[0].getCoordinate est du type [lon, lat], en EPSG:4326)

    var start;

    if (points[0] && points[0].getCoordinate) {
      var startCoordinate = points[0].getCoordinate();
      start = {
        x: startCoordinate[0],
        y: startCoordinate[1]
      };
      logger.log("start", start);
    } // - point d'arrivée


    var end;
    var endPoint = points[points.length - 1];

    if (endPoint && endPoint.getCoordinate) {
      var endCoordinate = endPoint.getCoordinate();
      end = {
        x: endCoordinate[0],
        y: endCoordinate[1]
      };
      logger.log("end", end);
    } // - les étapes


    var step = [];

    for (var i = 1; i < points.length - 1; i++) {
      if (points[i] && points[i].getCoordinate) {
        var iCoordinate = points[i].getCoordinate();

        if (iCoordinate) {
          var coordinate = {
            x: iCoordinate[0],
            y: iCoordinate[1]
          };
          logger.log("step", coordinate);
          step.push(coordinate);
        }
      }
    } // oups, aucun droits !
    // on evite donc une requête inutile ...


    if (this._noRightManagement) {
      return;
    } // valeurs selectionnées


    this._currentTransport = options.transport;
    this._currentComputation = options.computation;
    this._currentExclusions = options.exclusions; // on recupere les éventuelles options du service passées par l'utilisateur

    var routeOptions = this.options.routeOptions; // gestion du protocole et du timeout
    // le timeout est indispensable sur le protocole JSONP.

    var _protocol = routeOptions.protocol || "XHR";

    var _timeout = routeOptions.timeOut || 0;

    if (_protocol === "JSONP" && _timeout === 0) {
      // FIXME le timeout est obligatoire pour ce type de protocole...
      _timeout = 15000;
    } // gestion des callback


    var bOnFailure = !!(routeOptions.onFailure !== null && typeof routeOptions.onFailure === "function"); // cast variable to boolean

    var bOnSuccess = !!(routeOptions.onSuccess !== null && typeof routeOptions.onSuccess === "function"); // on met en place l'affichage des resultats dans la fenetre de resultats.

    var context = this;

    this._requestRouting({
      startPoint: start,
      endPoint: end,
      viaPoints: step,
      graph: routeOptions.graph || this._currentTransport,
      routePreference: routeOptions.routePreference || this._currentComputation,
      exclusions: routeOptions.exclusions || this._currentExclusions,
      geometryInInstructions: true,
      distanceUnit: "m",
      timeOut: _timeout,
      protocol: _protocol,
      // callback onSuccess
      onSuccess: function onSuccess(results) {
        logger.log(results);

        if (results) {
          context._fillRouteResultsDetails(results);
        }

        if (bOnSuccess) {
          routeOptions.onSuccess.call(context, results);
        }
      },
      // callback onFailure
      onFailure: function onFailure(error) {
        context._hideWaitingContainer();

        context._clearRouteResultsDetails();

        logger.log(error.message);

        if (bOnFailure) {
          routeOptions.onFailure.call(context, error);
        }
      }
    });
  };
  /**
   * this method is called by event 'click' on 'GPlocationOriginLabel' label
   * and set 'GProuteForm' CSS class to "" (normal)
   *
   * @param {Object} routeControl - context : route Control (this)
   * @private
   */


  Route.prototype.onRouteOriginLabelClick = function () {
    this._formRouteContainer.className = ""; // on désactive l'écouteur d'événements sur la carte (pour ne pas placer un marker au clic)
    // map.un(
    //     "click",
    //     () => {
    //         // on ne rétablit pas le mode "normal" si on est dans le panel des résultats (où className = "GProuteComponentHidden")
    //         if (this._formRouteContainer.className === "GProuteFormMini") {
    //             this._formRouteContainer.className = "";
    //         }
    //     }
    // );

    Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this.listenerKey);
    this.dispatchEvent("route:drawend");
  };
  /**
   * this method is called by event 'click' on 'GPlocationOriginPointerImg' label
   * and display or minimize 'GProuteForm', using CSS class ("GProuteFormMini" or "")
   *
   * @param {Object} e - context : route Control (equivalent to this)
   * @param {Object} locationSelector - context : locationSelector input (one of this._currentPoints)
   * @private
   */


  Route.prototype.onRouteOriginPointerClick = function (e, locationSelector) {
    var _this3 = this;

    var map = this.getMap();

    if (locationSelector._inputShowPointerContainer.checked) {
      // au click sur l'input pour pointer sur la carte: on minimise le formulaire
      this._formRouteContainer.className = "GProuteFormMini"; // et au clic sur la carte, on réaffichera le formulaire "normal"

      this.listenerKey = map.on("click", function () {
        // on ne rétablit pas le mode "normal" si on est dans le panel des résultats (où className = "GProuteComponentHidden")
        if (_this3._formRouteContainer.className === "GProuteFormMini") {
          _this3._formRouteContainer.className = "";
        }

        Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(_this3.listenerKey);
        /**
        * event triggered at the end of drawing input
        *
        * @event route:drawend
        */

        _this3.dispatchEvent("route:drawend");
      });
      /**
      * event triggered at the start of drawing input
      *
      * @event route:drawstart
      */

      this.dispatchEvent("route:drawstart");
    } else {
      // si on déselectionne le pointer, on rétablit le formulaire en mode normal
      this._formRouteContainer.className = ""; // et on enlève l'écouteur d'évènement sur la carte
      // map.un(
      //     "click",
      //     () => {
      //         // on ne rétablit pas le mode "normal" si on est dans le panel des résultats (où className = "GProuteComponentHidden")
      //         if (this._formRouteContainer.className === "GProuteFormMini") {
      //             this._formRouteContainer.className = "";
      //         }
      //     }
      // );

      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this.listenerKey);
      this.dispatchEvent("route:drawend");
    }
  };
  /**
   * this method is called by event 'click' on 'GPshowRoutePicto'
   * tag label (cf. this._createShowRoutePictoElement),
   * and it cleans all value of input.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onShowRoutePanelClick = function (e) {
    var map = this.getMap(); // on supprime toutes les interactions

    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_18__["default"].unset(map); // clean !

    if (!this._geojsonSections && !this._waiting) {
      this._clear();
    }

    this.collapsed = document.getElementById("GPshowRoute-" + this._uid).checked; // on génère nous même l'evenement OpenLayers de changement de pté
    // (utiliser ol.control.Route.on("change:collapsed", function ) pour s'abonner à cet évènement)

    this.dispatchEvent("change:collapsed");
  };
  /**
   * this method is called by event 'change' on 'GProuteComputationSelect' tag select
   * (cf. this._createRoutePanelFormModeChoiceComputeElement).
   * this value is saved as a parameter for the service route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onRouteModeComputationChange = function (e) {
    var idx = e.target.selectedIndex;
    var value = e.target.options[idx].value;

    if (!value) {
      return;
    }

    logger.log(value);
    this._currentComputation = value;
  };
  /**
   * this method is called by event 'change' on 'GProuteResultsComputationSelect' tag select
   * (cf. this._createRouteResultsElement).
   * this value is saved as a parameter for the service route,
   * and this launches the route request !
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onRouteModeComputationChangeAndRun = function (e) {
    // event choice computation
    this.onRouteModeComputationChange(e); // clean avant un nouveau calcul !

    this._clearRouteResultsDetails();

    this._clearRouteResultsGeometry();

    this._clearRouteResultsFeatureGeometry(); // submit request


    this.onRouteComputationSubmit({
      computation: this._currentComputation,
      transport: this._currentTransport,
      exclusions: this._currentExclusions
    });
  };
  /**
   * this method is called by event 'change' on 'GProuteTransportCar' or 'GProuteTransportPedestrian' tag input
   * (cf. this._createRoutePanelFormModeChoiceTransportElement).
   * this value is saved as a parameter for the service route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onRouteModeTransportChange = function (e) {
    var value = e.target.value;

    if (!value) {
      return;
    }

    this._currentTransport = value;
  };
  /**
   * TODO this method is called by event 'click' on 'GPshowRouteExclusionsPicto' tag input
   * (cf. this._createShowRouteExclusionsPictoElement), and it displays the panel options of exclusions.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onShowRouteExclusionsClick = function (e) {
    logger.log("onShowRouteExclusionsClick", e); // FIXME not use ?!
  };
  /**
   * this method is called by event 'change' on 'GProuteExclusionsToll'
   * or 'GProuteExclusionsTunnel' or 'GProuteExclusionsBridge' tag input
   * (cf. this._createRoutePanelFormExclusionOptionsElement).
   * this value is saved as a parameter for the service route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onRouteExclusionsChange = function (e) {
    var value = e.target.value;
    var checked = e.target.checked;

    if (!value || typeof value !== "string") {
      return;
    }

    value = value.toLowerCase();
    var bFound = false;
    var iFound = null;

    for (var i = 0; i < this._currentExclusions.length; i++) {
      if (this._currentExclusions[i] === value) {
        iFound = i;
        bFound = true;
      }
    } // on l'ajoute si la valeur n'existe pas et est déselectionnée
    // info : checked = passage autorisé (ce n'est pas une exclusion)


    if (!bFound && !checked) {
      this._currentExclusions.push(value);
    } // on la retire si la valeur existe et est selectionnée


    if (bFound && checked) {
      this._currentExclusions.splice(iFound, 1);
    }
  };
  /**
   * this method is called by event 'click' on 'GProuteReset'
   * tag label (cf. this._createRouteFormResetElement),
   * and it cleans all route input options and results.
   *
   * @private
   */


  Route.prototype.onRouteResetClick = function () {
    // clear points
    var currentPoints = this._currentPoints;

    for (var i = 0; i < currentPoints.length; i++) {
      currentPoints[i].clear();
    } // clear results


    this._clear();

    this._clearRouteInputOptions();
  };
  /**
   * this method is called by event 'click' on 'GProuteSubmit'
   * tag label (cf. this._createRouteSubmitFormElement),
   * and it cleans the route geometry.
   *
   * @private
   */


  Route.prototype.onShowRouteResultsNewClick = function () {
    // clean avant un nouveau calcul !
    this._clearRouteResultsDetails();

    this._clearRouteResultsGeometry();

    this._clearRouteResultsFeatureGeometry();
  };
  /**
   * this method is called by event 'mouseover' on 'GProuteResultsDetailsInstruction_'
   * tag label (cf. this._addRouteResultsDetailsElement),
   * and it makes a style on feature route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onRouteResultsDetailsMouseOver = function (e) {
    // récupération de l'id de l'instruction survolée
    var tagid = e.target.id; // ex GProuteResultsDetailsInstruction_125

    var idx = tagid.substring(tagid.indexOf("_") + 1); // ex. 125
    // on passe le texte en gras

    if (e.target.classList) {
      e.target.classList.add("GProuteResultsDetailsInstructionHighlight");
    }

    if (!this._geojsonSections) {
      return;
    } // on récupère l'entité correspondante à l'instruction survolée


    var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10)); // et on lui affecte un nouveau style


    f.setStyle(this._selectedFeatureStyle);
  };
  /**
   * this method is called by event 'mouseout' on 'GProuteResultsDetailsInstruction_'
   * tag label (cf. this._addRouteResultsDetailsElement),
   * and it deletes a style on feature route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Route.prototype.onRouteResultsDetailsMouseOut = function (e) {
    // récupération de l'id de l'instruction survolée
    var tagid = e.target.id; // ex GProuteResultsDetailsInstruction_125

    var idx = tagid.substring(tagid.indexOf("_") + 1); // ex. 125
    // on repasse le texte en style normal

    if (e.target.classList) {
      e.target.classList.remove("GProuteResultsDetailsInstructionHighlight");
    }

    if (!this._geojsonSections) {
      return;
    } // on récupère l'entité correspondante à l'instruction qui était survolée


    var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10)); // et on lui réaffecte un style normal


    f.setStyle(null);
  }; // ################################################################### //
  // ########################### Routing ############################### //
  // ############## (methods to request and results) ################### //

  /**
   * this method is called by this.onRouteComputationSubmit()
   * and executes a request to the service.
   *
   * @param {Object} options - route service request options
   * @param {Function} options.onSuccess - callback
   * @param {Function} options.onFailure - callback
   * @private
   */


  Route.prototype._requestRouting = function (options) {
    // on ne fait pas de requête si on n'a pas renseigné de parametres !
    if (!options || _typeof(options) === "object" && Object.keys(options).length === 0) {
      return;
    } // on ne fait pas de requête si
    // - la parametre 'startPoint' est vide !


    if (!options.startPoint) {
      return;
    } // - la parametre 'endPoint' est vide !


    if (!options.endPoint) {
      return;
    } // on ne fait pas de requête si aucun droit !


    if (this._noRightManagement || !this._resources["Itineraire"]) {
      return;
    } // gestion des droits !


    var resources = this._resources["Itineraire"].resources;

    if (!resources || _typeof(resources) === "object" && Object.keys(resources).length === 0) {
      return;
    } // gestion de la clef !


    var key = this._resources["Itineraire"]["key"]; // la ressource donne elle des droits ?

    var bFound = false;

    for (var i = 0; i < resources.length; i++) {
      if (resources[i] === options.graph) {
        bFound = true;
      }
    } // on fait quoi ?


    if (!bFound) {
      logger.log("no rights for this service !?");
      return;
    } // cas où la clef API n'est pas renseignée dans les options du service,
    // on utilise celle de l'autoconf ou celle renseignée au niveau du controle


    options.apiKey = this.options.routeOptions.apiKey || this.options.apiKey || key; // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
    // true par défaut (https)

    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }

    logger.log(options); // mise en place de la patience

    this._displayWaitingContainer(); // appel du service de calcul d'itinéraires


    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_11__["default"].Services.route(options);
  };
  /**
   * this method is called by this.onRouteComputationSubmit() (in case of route computation success)
   * and fills the container of the route instructions list, distance and time
   * information, also, constructs the geometry route.
   *
   * @param {Object} results - results of the route calculation
   *
   * @private
   */


  Route.prototype._fillRouteResultsDetails = function (results) {
    // 1. Affichage des distances et durées
    var distance = results.totalDistance;
    var duration = results.totalTime; // Détails avec simplifications des troncons

    var instructions = this._simplifiedInstructions(results.routeInstructions); // var instructions = results.routeInstructions;


    if (instructions) {
      this._fillRouteResultsDetailsContainer(distance, duration, instructions);
    } // 2. Affichage des géométries
    // Geometrie simplifiée (si renseignée)


    var geometry = results.routeGeometry;

    if (geometry) {
      this._fillRouteResultsDetailsGeometry(geometry, this._defaultFeatureStyle);
    } // Geometries des tronçon (si renseignée)


    if (instructions && instructions[0].geometry) {
      this._fillRouteResultsDetailsFeatureGeometry(instructions, this._defaultFeatureStyle);
    } // 3. Zoom sur l'emprise de l'itinéraire (si spécifiée)


    var bbox = results.bbox;

    if (bbox) {
      var map = this.getMap();
      var bounds = [bbox.left, bbox.bottom, bbox.right, bbox.top]; // reprojection dans la projection de la carte (bbox initialement en EPSG:4326)

      var mapProj = map.getView().getProjection().getCode();

      if (mapProj !== "EPSG:4326") {
        bounds = Object(ol_proj__WEBPACK_IMPORTED_MODULE_10__["transformExtent"])(bounds, "EPSG:4326", mapProj);
      }

      map.getView().fit(bounds, map.getSize());
    } // sauvegarde de l'etat des resultats


    this._currentRouteInformations = results;
    /**
     * event triggered when the compute is finished
     *
     * @event route:compute
     * @property {Object} type - event
     * @property {Object} target - instance Route
     * @example
     * Route.on("route:compute", function (e) {
     *   console.log(e.target.getData());
     * })
     */

    this.dispatchEvent({
      type: "route:compute"
    }); // mise à jour du controle !

    this._formRouteContainer.className = "GProuteComponentHidden";

    this._hideWaitingContainer();

    this._resultsRouteContainer.className = "";
  };
  /**
   * this method is called by this._fillRouteResultsDetails()
   * and fills the container of the route instructions list, distance and time
   * information.
   *
   * @param {Number} distance - distance
   * @param {Number} duration - duration
   * @param {Object[]} instructions - list of instructions
   *
   * @private
   */


  Route.prototype._fillRouteResultsDetailsContainer = function (distance, duration, instructions) {
    // Distance et Durée
    this._resultsRouteValuesContainer = this._addRouteResultsValuesElement(distance, duration, this._convertSecondsToTime); // Détails

    this._resultsRouteDetailsContainer = this._addRouteResultsDetailsElement(instructions, this._convertSecondsToTime);
  };
  /**
   * this method is called by this._fillRouteResultsDetails()
   * and constructs the geometry route.
   *
   * @param {Object} geometry - geoJSON object for route geometry
   * @param {Object} style - route ol.style.Style object
   * @private
   */


  Route.prototype._fillRouteResultsDetailsGeometry = function (geometry, style) {
    this._clearRouteResultsGeometry();

    var map = this.getMap();

    if (!geometry) {
      return;
    } // création de l'objet geoJSON


    var geojsonObject = {
      type: "Feature",
      crs: {
        type: "name",
        properties: {
          name: "EPSG:4326"
        }
      },
      geometry: geometry
    };
    var geojsonformat = new ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_6___default.a({
      defaultDataProjection: "EPSG:4326"
    });
    var features = geojsonformat.readFeatures(geojsonObject, {
      dataProjection: "EPSG:4326",
      featureProjection: "EPSG:3857"
    }); // ajout de la géométrie comme nouvelle couche vecteur à la carte

    this._geojsonRoute = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4___default.a({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_5___default.a({
        features: features
      }),
      style: style
    });
    map.addLayer(this._geojsonRoute);
  };
  /**
   * this method is called by this._fillRouteResultsDetails()
   * and constructs the geometries street with informations.
   *
   * @param {Array} instructions - route instructions list (containing geoJSON geometry)
   * @param {Object} style - route ol.style.Style object
   * @private
   */


  Route.prototype._fillRouteResultsDetailsFeatureGeometry = function (instructions, style) {
    var _this4 = this;

    this._clearRouteResultsFeatureGeometry();

    var map = this.getMap(); // 1. création de l'objet geoJSON

    var geojsonObject = {
      type: "FeatureCollection",
      crs: {
        type: "name",
        properties: {
          name: "EPSG:4326"
        }
      },
      features: []
    }; // 2. Remplissage de l'objet geoJSON : ajout des géométries de chaque instruction

    for (var i = 0; i < instructions.length; i++) {
      var o = instructions[i];
      var id = i + 1;
      var coords = o.geometry.coordinates;

      for (var j = 0; j < coords.length; j++) {
        // remarque : les coordonnées sont au format string, à convertir en nombres
        if (typeof coords[j][0] === "string") {
          coords[j][0] = parseFloat(coords[j][0]);
          coords[j][1] = parseFloat(coords[j][1]);
        }
      }

      geojsonObject.features.push({
        type: "Feature",
        geometry: o.geometry,
        properties: {
          popupContent: "(" + id + ") distance : " + this._convertDistance(o.distance) + " / temps : " + this._convertSecondsToTime(o.duration)
        },
        id: id
      });
    }

    logger.log(geojsonObject); // Création du format GeoJSON, avec reprojection des géométries

    var geojsonformat = new ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_6___default.a({
      defaultDataProjection: "EPSG:4326"
    });
    var mapProj = this.getMap().getView().getProjection().getCode();
    var features = geojsonformat.readFeatures(geojsonObject, {
      dataProjection: "EPSG:4326",
      featureProjection: mapProj
    }); // 3. Ajout du tracé de l'itinéraire (geoJSON) comme nouvelle couche vecteur à la carte

    this._geojsonSections = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4___default.a({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_5___default.a({
        features: features
      }),
      style: style,
      opacity: 0.9
    });
    var graph;

    if (this._currentTransport === "Pieton") {
      graph = "piéton";
      this._geojsonSections.gpResultLayerId = "Pieton$OGC:OPENLS;Itineraire";
    } else {
      graph = "voiture";
      this._geojsonSections.gpResultLayerId = "Voiture$OGC:OPENLS;Itineraire";
    } // ajout à la carte


    map.addLayer(this._geojsonSections); // 4. Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche

    map.getControls().forEach(function (control) {
      if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_20__["default"]) {
        // un layer switcher est présent dans la carte
        var layerId = _this4._geojsonSections.gpLayerId; // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)

        if (control._layers[layerId].title === layerId) {
          control.addLayer(_this4._geojsonSections, {
            title: _this4.options.layerDescription.title + " (" + graph + ")",
            description: _this4.options.layerDescription.description
          });
        }
      }
    }, this); // 5. Ajout de popups aux troncons
    // Création de l'interaction : survol des features (=troncons de l'itinéraire)

    this._resultsHoverInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_8__["Select"]({
      condition: ol_events_condition__WEBPACK_IMPORTED_MODULE_7__["pointerMove"],
      layers: [this._geojsonSections],
      style: this._selectedFeatureStyle
    });

    this._resultsHoverInteraction.on("select", function (e) {
      return _this4._onResultsFeatureMouseOver(e);
    });

    map.addInteraction(this._resultsHoverInteraction); // Création de l'interaction : selection des features (=troncons de l'itinéraire)

    this._resultsSelectInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_8__["Select"]({
      layers: [this._geojsonSections],
      style: this._selectedFeatureStyle
    });

    this._resultsSelectInteraction.on("select", function (e) {
      return _this4._onResultsFeatureSelect(e);
    });

    map.addInteraction(this._resultsSelectInteraction);
  };
  /**
   * this method is called on route features hover
   * and highlight instruction label
   *
   * @param {Object} e - event
   *
   * @private
   */


  Route.prototype._onResultsFeatureMouseOver = function (e) {
    if (e.selected.length !== 0) {
      // si on a bien survolé un tronçon, on surligne l'instruction correspondante
      var f = e.selected[0];
      var selectedInstruction = document.getElementById("GProuteResultsDetailsInstruction_" + f.getId() + "-" + this._uid);

      if (selectedInstruction && selectedInstruction.classList) {
        selectedInstruction.classList.add("GProuteResultsDetailsInstructionHighlight");
      }
    } // si on déselectionne un tronçon (mouseout), on rétablit un style normal pour l'instruction


    if (e.deselected.length !== 0) {
      var deselectedFeature = e.deselected[0]; // on repasse l'instruction correspondante en normal

      var deSelectedInstruction = document.getElementById("GProuteResultsDetailsInstruction_" + deselectedFeature.getId() + "-" + this._uid);

      if (deSelectedInstruction && deSelectedInstruction.classList) {
        deSelectedInstruction.classList.remove("GProuteResultsDetailsInstructionHighlight");
      }
    }
  };
  /**
   * this method is called on route features select
   * and set a popup with feature information
   *
   * @param {Object} e - on select event
   * @private
   */


  Route.prototype._onResultsFeatureSelect = function (e) {
    var map = this.getMap();

    if (e.selected.length !== 0) {
      // si on a sélectionné un troncon, on lui ajoute une popup
      var f = e.selected[0];
      this._popupContent.innerHTML = f.getProperties().popupContent;

      if (!this._popupOverlay) {
        // ajout de la popup a la carte comme un overlay
        this._popupOverlay = new ol_Overlay__WEBPACK_IMPORTED_MODULE_3___default.a({
          element: this._popupDiv,
          positioning: "bottom-center",
          position: e.mapBrowserEvent.coordinate
        });
        map.addOverlay(this._popupOverlay);
      } else {
        // si l'overlay est déjà créé, on modifie juste sa position
        this._popupOverlay.setPosition(e.mapBrowserEvent.coordinate);
      }
    } else {
      // si aucun troncon n'est sélectionné (click à côté du tracé),
      // on fait disparaitre la popup si elle existe
      if (this._popupOverlay != null) {
        this._popupOverlay.setPosition(undefined);
      }
    }
  }; // ################################################################### //
  // ############################# Clean ############################### //
  // ################################################################### //

  /**
   * this method is called by this.onShowRoutePanelClick()
   * and it clears all elements (reinit).
   *
   * @private
   */


  Route.prototype._clear = function () {
    this._currentTransport = null;
    this._currentExclusions = [];
    this._currentComputation = null; // les resultats

    this._clearRouteResultsDetails(); // la geometrie


    this._clearRouteResultsGeometry();

    this._clearRouteResultsFeatureGeometry(); // les points


    for (var i = 0; i < this._currentPoints.length; i++) {
      this._currentPoints[i].clear();
    } // suppression des points intermédiaires


    this._removeRouteStepLocations();
  };
  /**
   * this method is called by this.onRouteResetClick()
   * and it clears all options inputs (reinit).
   *
   * @private
   */


  Route.prototype._clearRouteInputOptions = function () {
    // reinit options to default
    this._initTransport();

    this._initComputation();

    this._initExclusions(); // set transport mode to default


    var transportdiv;

    if (this._currentTransport === "Pieton") {
      transportdiv = document.getElementById("GProuteTransportPedestrian-" + this._uid);

      if (transportdiv) {
        transportdiv.checked = "true";
      }
    } else {
      transportdiv = document.getElementById("GProuteTransportCar-" + this._uid);

      if (transportdiv) {
        transportdiv.checked = "true";
      }
    } // set computation mode to default


    var computationdiv = document.getElementById("GProuteComputationSelect-" + this._uid);

    if (computationdiv) {
      computationdiv.value = this._currentComputation;
    } // set exclusions to default


    var tollInput = document.getElementById("GProuteExclusionsToll-" + this._uid);

    if (tollInput) {
      if (this._currentExclusions.indexOf("toll") !== -1) {
        tollInput.checked = false;
      } else {
        tollInput.checked = true;
      }
    }

    var tunnelInput = document.getElementById("GProuteExclusionsTunnel-" + this._uid);

    if (tunnelInput) {
      if (this._currentExclusions.indexOf("tunnel") !== -1) {
        tunnelInput.checked = false;
      } else {
        tunnelInput.checked = true;
      }
    }

    var bridgeInput = document.getElementById("GProuteExclusionsBridge-" + this._uid);

    if (bridgeInput) {
      if (this._currentExclusions.indexOf("bridge") !== -1) {
        bridgeInput.checked = false;
      } else {
        bridgeInput.checked = true;
      }
    }
  };
  /**
   * this method is called by this._clear()
   * and it removes step location inputs (excepted departure and arrival)
   *
   * @private
   */


  Route.prototype._removeRouteStepLocations = function () {
    var points = document.querySelectorAll("div[id^=\"GPlocationPoint\"]");

    if (points.length !== 0) {
      var goodPoints = [];

      for (var k = 0; k < points.length; k++) {
        if (points[k].id.indexOf(this._uid) !== -1) {
          goodPoints.push(points[k]);
        }
      } // on boucle sur les points intermédiaires


      for (var i = 1; i < goodPoints.length - 1; i++) {
        // on va regarder les classes associées
        var classList = goodPoints[i].classList;

        if (classList.length !== 0) {
          for (var j = 0; j < classList.length; j++) {
            if (classList[j] === "GPlocationStageFlexInput") {
              // si l'élément est visible, on le supprime en simulant un clic sur la croix (x)
              document.getElementById(this._addUID("GPlocationStageRemove_" + (i + 1))).click();
            }
          }
        }
      }
    }
  };
  /**
   * this method is called by this.onRouteComputationSubmit() (in case of failure)
   * and it clears all route instructions.
   *
   * @private
   */


  Route.prototype._clearRouteResultsDetails = function () {
    this._currentRouteInformations = null; // doit on nettoyer le container "GProuteResultsDetails" ?
    // il sera de toute façon écrasé par la prochaine requête...

    if (this._resultsRouteDetailsContainer) {
      var detailsDiv = this._resultsRouteDetailsContainer;

      if (detailsDiv.childElementCount) {
        while (detailsDiv.firstChild) {
          detailsDiv.removeChild(detailsDiv.firstChild);
        }
      }
    }

    if (this._resultsRouteValuesContainer) {
      var valuesDiv = this._resultsRouteValuesContainer;

      if (valuesDiv.childElementCount) {
        while (valuesDiv.firstChild) {
          valuesDiv.removeChild(valuesDiv.firstChild);
        }
      }
    }
  };
  /**
   * this method is called by this.onRouteComputationSubmit()
   * and it clears all route geometries.
   *
   * @private
   */


  Route.prototype._clearRouteResultsGeometry = function () {
    var map = this.getMap();

    if (this._geojsonRoute != null) {
      map.removeLayer(this._geojsonRoute);
      this._geojsonRoute = null;
    }
  };
  /**
   * this method is called by this.onRouteComputationSubmit()
   * and it clears all route geometries.
   *
   * @private
   */


  Route.prototype._clearRouteResultsFeatureGeometry = function () {
    var map = this.getMap(); // on retire la couche itinéraire de la carte

    if (this._geojsonSections != null) {
      map.removeLayer(this._geojsonSections);
      this._geojsonSections = null;
    } // on retire l'overlay de la popup de la carte


    if (this._popupOverlay != null) {
      map.removeOverlay(this._popupOverlay);
      this._popupOverlay = null;
    } // et les interactions liées à cette couche


    if (this._resultsSelectInteraction != null) {
      map.removeInteraction(this._resultsSelectInteraction);
      this._resultsSelectInteraction = null;
    }

    if (this._resultsHoverInteraction != null) {
      map.removeInteraction(this._resultsHoverInteraction);
      this._resultsHoverInteraction = null;
    }
  };
  /**
   * this method is called by event 'click' on control main container
   * and hide suggested Locations (unless target is an autocomplete input)
   *
   * @param {Object} e - event
   *
   * @private
   */


  Route.prototype._hideRouteSuggestedLocations = function (e) {
    // si on clique sur un input de saisie de locationSelector
    if (e.target && e.target.id && e.target.id.indexOf("GPlocationOrigin_") !== -1) {
      // on récupère le numéro du point
      var pointId = parseInt(e.target.id.split("_")[1][0], 10) - 1; // et on cache les autres résultats d'autocomplétion (sauf celui sur lequel on clique)

      for (var j = 0; j < this._currentPoints.length; j++) {
        if (j !== parseInt(pointId, 10)) {
          this._currentPoints[j]._hideSuggestedLocation();
        }
      }
    } else {
      // si on clique ailleurs dans le DOM du control, on cache tous les résultats d'autocomplétion
      for (var i = 0; i < this._currentPoints.length; i++) {
        this._currentPoints[i]._hideSuggestedLocation();
      }
    }
  };
  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */


  Route.prototype._displayWaitingContainer = function () {
    this._waitingContainer.className = "GProuteCalcWaitingContainerVisible";
    this._waiting = true; // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)
    // si on est toujours en attente (si la requête est bloquée par exemple)
    // ceci est vrai, uniquement sur le protocole JSONP !

    var opts = this.options.routeOptions;

    if (opts && opts.timeOut) {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }

      var context = this;
      this._timer = setTimeout(function () {
        if (context._waiting === true) {
          context._hideWaitingContainer();
        } else {
          if (context._timer) {
            clearTimeout(context._timer);
          }
        }
      }, 16000);
    }
  };
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */


  Route.prototype._hideWaitingContainer = function () {
    if (this._waiting) {
      this._waitingContainer.className = "GProuteCalcWaitingContainerHidden";
      this._waiting = false;
      var opts = this.options.routeOptions;

      if (opts && opts.timeOut) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    }
  }; // ################################################################### //
  // ########################## Geometry ############################### //
  // ################################################################### //

  /**
   * simplified instructions
   *
   * @param {Object[]} instructions - list of instructions
   *
   * @returns {Object[]} simplified instructions
   *
   * @private
   */


  Route.prototype._simplifiedInstructions = function (instructions) {
    var newInstructions = []; // cas où...

    var current = instructions[0];

    if (instructions.length === 1) {
      newInstructions.push(current);
    }

    for (var i = 1; i < instructions.length; i++) {
      var o = instructions[i];

      if (o.instruction === current.instruction) {
        current.distance = (parseFloat(o.distance) + parseFloat(current.distance)).toString();
        current.duration = (parseFloat(o.duration) + parseFloat(current.duration)).toString();

        for (var j = 1; j < o.geometry.coordinates.length; j++) {
          current.geometry.coordinates.push(o.geometry.coordinates[j]);
        }
      } else {
        newInstructions.push(current);
        current = o; // last

        if (i === instructions.length - 1) {
          newInstructions.push(o);
          current = null;
        }
      }
    }

    logger.log(newInstructions);
    return newInstructions;
  }; // ################################################################### //
  // ################# Utils for Distance/Duration ##################### //
  // ################################################################### //

  /**
   * convert seconds to time : HH:MM:SS
   *
   * @param {Number} duration - duration in seconds
   *
   * @returns {String} time in hours/minutes/seconds
   *
   * @private
   */


  Route.prototype._convertSecondsToTime = function (duration) {
    var time = "";
    duration = Math.round(duration);
    var hours = Math.floor(duration / (60 * 60));
    var divisor4minutes = duration % (60 * 60);
    var minutes = Math.floor(divisor4minutes / 60); // if (!minutes) {
    //     minutes = "00";
    // }
    // var divisor4seconds = divisor4minutes % 60;
    // var seconds = Math.ceil(divisor4seconds);
    // if (!seconds) {
    //     seconds = "00";
    // }

    if (hours) {
      time = hours + "h ";
    }

    time += minutes + " min";
    return time;
  };
  /**
   * convert distance in meters or kilometers
   *
   * @param {Number} distance - distance in meters
   *
   * @returns {String} distance in km
   *
   * @private
   */


  Route.prototype._convertDistance = function (distance) {
    var d = "";
    var distanceKm = parseInt(distance / 1000, 10);

    if (!distanceKm) {
      d = parseInt(distance, 10) + " m"; // arrondi !
    } else {
      d = distanceKm + " km";
    }

    return d;
  };

  return Route;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (Route); // Expose Route as ol.control.Route (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.Route = Route;
}

/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_LocationSelector_GPlocationOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _CSS_Controls_LocationSelector_GPlocationOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_LocationSelector_GPlocationOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(171);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(180);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(172);
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(178);
/* harmony import */ var _Common_Controls_LocationSelectorDOM__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(204);
// import CSS
 // import OpenLayers




 // import geoportal library access

 // import local





 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__["default"].getLogger("locationselector");
/**
 * @classdesc
 *
 * LocationSelector component. Enables to select a location, using autocompletion or picking location on the map
 *
 * @private
 * @param {Object} [options] - component options
 * @param {String} [options.apiKey] - API key for autocomplete service call, mandatory if autoconf service has not been charged in advance
 * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.displayInfo = true] - whether to display info in a popup or not (not implemented yet) Default is true
 * @param {Object} [options.tag] - tag options
 * @param {Number} [options.tag.id = 1] - order id number in a locations group, in case several LocationSelector are used. For instance in route case : departure tag id should be 0, arrival tag id should be 1, and other ones : 2, 3, ...
 * @param {Number} [options.tag.groupId = null] - locationSelector global component id (in case locationSelector is called by another graphic component, e.g. route control)
 * @param {String} [options.tag.label] - text to display in component (e.g. "Departure"). Default is ">"
 * @param {Object} [options.tag.markerOpts] - options to use your own marker. Default is a lightOrange marker.
 * @param {String} [options.tag.markerOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
 * @param {Array} [options.tag.markerOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see {@link http://openlayers.org/en/latest/apidoc/ol.Overlay.html ol.Overlay})
 * @param {Boolean} [options.tag.display = true] - whether to display or hide component. Default is true
 * @param {Boolean} [options.tag.addOption = false] - whether to display picto to add another LocationSelector (in case of route control)
 * @param {Boolean} [options.tag.removeOption = false] - whether to display picto to remove a LocationSelector (in case of route control)
 * @param {Object} [options.autocompleteOptions] - autocomplete service options (see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options)
 * @example
 *  var locationselector = new LocationSelector({
 *      apiKey : "",
 *      tag : {
 *         id : 1,
 *         groupId : null,
 *         label : "Départ",
 *         markerOpts : {
 *              url : "...",
 *              offset : [0,0]
 *         },
 *         display : true
 *      },
 *      autocompleteOptions : {}
 *  });
 */

var LocationSelector = function (Control) {
  function LocationSelector(options) {
    options = options || {};

    if (!(this instanceof LocationSelector)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // initialisation du composant


    this.initialize(options); // creation du DOM

    this._container = this._initContainer(); // on peut éventuellement encapsuler le composant dans une div passée par l'utilisateur
    // (le composant étant positionné en relatif, il doit être positionné dans une div si utilisé seul)

    if (options.element && options.element.appendChild) {
      options.element.appendChild(this._container);
      this._container = options.element;
    } // call ol.control.Control constructor


    Control.call(this, {
      element: this._container,
      target: options.target,
      render: options.render
    });
  }

  ; // Inherits from ol.control.Control

  if (Control) LocationSelector.__proto__ = Control;
  /**
   * @lends module:LocationSelector
   */

  LocationSelector.prototype = Object.create(Control.prototype, {});
  _Common_Utils__WEBPACK_IMPORTED_MODULE_7__["default"].assign(LocationSelector.prototype, _Common_Controls_LocationSelectorDOM__WEBPACK_IMPORTED_MODULE_11__["default"]);
  /**
   * Constructor (alias)
   */

  LocationSelector.prototype.constructor = LocationSelector;
  /**
   * initialize component
   *
   * @param {Object} options - options
   */

  LocationSelector.prototype.initialize = function (options) {
    // set default options
    this.options = {
      tag: {
        id: 1,
        // numero d'ordre sur un groupe de locations
        groupId: null,
        // id du composant global contenant le LocationSelector
        label: ">",
        display: true,
        addOption: false,
        removeOption: false
      },
      displayInfo: true,
      autocompleteOptions: {}
    }; // merge with user options

    _Common_Utils__WEBPACK_IMPORTED_MODULE_7__["default"].mergeParams(this.options, options);
    /** uuid */

    this._uid = this.options.tag.groupId || _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__["default"].generate(); // info : si un uid (groupId) est spécifié
    // (par ex si ce composant est appélé par un autre composant graphique)
    // alors on le récupère, sinon c'est qu'il est indépendant : on génère donc un uuid

    /** container map */

    this._map = null;
    /** container principal des entrées  */

    this._inputsContainer = null;
    /** container du label du point */

    this._inputLabelContainer = null;
    /** container de la saisi de l'autocompletion */

    this._inputAutoCompleteContainer = null;
    /** container du pointer de saisi sur la carte */

    this._inputShowPointerContainer = null;
    /** label du pointer de saisi sur la carte (avec img) */

    this._inputShowPointer = null;
    /** container des coordonnées */

    this._inputCoordinateContainer = null;
    /** elements pour ajouter ou supprimer un nouveau point */

    this._addPointElement = null;
    this._removePointElement = null;
    /** coordonnées du point selectionné, en EPSG:4326 */

    this._coordinate = null;
    /** container des reponses de l'autocompletion */

    this._suggestedContainer = null;
    /** listes des reponses de l'autocompletion */

    this._suggestedLocations = [];
    /** localisant */

    this._currentLocation = null;
    /** marker */

    this._initMarker();
    /** ressources du services d'autocompletion (ayant droit!) */


    this._resources = {};
    /** a t on des droits sur les ressources du service ? */

    this._noRightManagement = false; // gestion des droits sur les ressources/services

    this._checkRightsManagement(); // listener key for event click on map


    this.listenerKey = null;
  };
  /**
   * initialize marker : url and offset
   *
   * @private
   */


  LocationSelector.prototype._initMarker = function () {
    // init marker properties
    this._marker = null;
    this._markerUrl = "";
    this._markerOffset = [0, 0];

    if (this.options.tag.markerOpts && this.options.tag.markerOpts.url) {
      // get marker src url
      this._markerUrl = this.options.tag.markerOpts.url; // get marker offset

      var offset = this.options.tag.markerOpts.offset;

      if (offset) {
        if (Array.isArray(offset) && offset.length === 2) {
          this._markerOffset = offset;
        } else {
          logger.log("markerOpts.offset should be an array. e.g. : [0,0]");
        }
      }
    } else {
      // set default options for marker
      this._markerUrl = _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__["default"]["lightOrange"];
      this._markerOffset = _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__["default"].defaultOffset;
    }
  }; // ################################################################### //
  // ########################## publics methods ######################## //
  // ################################################################### //

  /**
   * get coordinate
   *
   * @returns {Array} this._coordinate - point coordinate (EPSG:4326) : [lon, lat]
   */


  LocationSelector.prototype.getCoordinate = function () {
    return this._coordinate;
  };
  /**
   * set coordinate
   * @param {Object} coordinate - Coordinate in the projection map
   */


  LocationSelector.prototype.setCoordinate = function (coordinate) {
    var map = this.getMap();
    var crs = map.getView().getProjection();

    this._setCoordinate(coordinate, crs);

    this._setMarker([coordinate[0], coordinate[1]], null, false);
  };
  /**
   * clean input
   */


  LocationSelector.prototype.clear = function () {
    this._clearResults();

    this._inputLabelContainer.click();
  }; // ################################################################### //
  // ##################### init component (private) #################### //
  // ################################################################### //

  /**
   * check
   */


  LocationSelector.prototype._checkRightsManagement = function () {
    // les ressources du service d'autocompletion
    var _opts = this.options.autocompleteOptions.filterOptions;

    var _res = _opts ? _opts.type : [];

    if (!_res || _res.length === 0) {
      _res = ["PositionOfInterest", "StreetAddress"];
    }

    var rightManagement = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_8__["default"].check({
      key: this.options.apiKey,
      resources: _res,
      services: ["AutoCompletion"]
    }); // pas de droit !

    if (!rightManagement) {
      this._noRightManagement = true;
      return;
    } // on recupère les informations utiles
    // sur ce controle, on ne s'occupe pas de la ressource car elle est unique...
    // Ex. la clef API issue de l'autoconfiguration si elle n'a pas
    // été renseignée.


    if (!this.options.apiKey) {
      this.options.apiKey = rightManagement.key;
    }

    _Common_Utils__WEBPACK_IMPORTED_MODULE_7__["default"].assign(this._resources, rightManagement);
  };
  /**
   * initialize component container
   *
   * @returns {DOMElement} DOM element
   */


  LocationSelector.prototype._initContainer = function () {
    var _this = this;

    var id = this.options.tag.id; // create main container

    var container = this._createMainContainerElement();

    var inputs = this._inputsContainer = this._createLocationPointElement(id, this.options.tag.display);

    container.appendChild(inputs);

    var _inputLabel = this._inputLabelContainer = this._createLocationPointLabelElement(id, this.options.tag.label);

    inputs.appendChild(_inputLabel);

    var _inputAutoComplete = this._inputAutoCompleteContainer = this._createLocationAutoCompleteteInputElement(id);

    if (_inputAutoComplete.addEventListener) {
      _inputAutoComplete.addEventListener("click", function () {
        return _this.onAutoCompleteInputClick();
      });
    } else if (_inputAutoComplete.attachEvent) {
      _inputAutoComplete.attachEvent("onclick", function () {
        return _this.onAutoCompleteInputClick();
      });
    }

    inputs.appendChild(_inputAutoComplete);

    var _inputCoordinate = this._inputCoordinateContainer = this._createLocationCoordinateInputElement(id);

    inputs.appendChild(_inputCoordinate);

    var _inputShowPointer = this._inputShowPointerContainer = this._createLocationPointerShowInputElement(id);

    inputs.appendChild(_inputShowPointer);

    var _inputPointer = this._inputShowPointer = this._createLocationPointerInputElement(id);

    inputs.appendChild(_inputPointer);

    if (this.options.tag.addOption) {
      var _inputAddStage = this._addPointElement = this._createLocationAddPointElement();

      inputs.appendChild(_inputAddStage);
    }

    if (this.options.tag.removeOption) {
      var _inputRemoveStage = this._removePointElement = this._createLocationRemovePointElement(id);

      inputs.appendChild(_inputRemoveStage);
    }

    var results = this._suggestedContainer = this._createLocationAutoCompleteResultElement(id);

    container.appendChild(results);
    return container;
  }; // ################################################################### //
  // ###################### handlers events (dom) ###################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on 'GPlocationOrigin' input
   *
   * @private
   */


  LocationSelector.prototype.onAutoCompleteInputClick = function () {
    if (this._inputAutoCompleteContainer && this._inputAutoCompleteContainer.value.length > 2) {
      this._displaySuggestedLocation();
    }
  };
  /**
   * this method is called by event 'keyup' on 'GProuteOrigin' tag input
   * (cf. this._createRouteAutoCompleteteInputElement), and it gets the value of input.
   * this value is passed as a parameter for the service autocomplete (text).
   * the results of the request are displayed into a drop down menu.
   * FIXME
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LocationSelector.prototype.onAutoCompleteSearchText = function (e) {
    var _this2 = this;

    var value = e.target.value;

    if (!value) {
      return;
    } // aucun droits !
    // on evite une requête...


    if (this._noRightManagement) {
      logger.log("no rights for this service !?");
      return;
    } // on sauvegarde le localisant


    this._currentLocation = value; // on limite les requêtes à partir de 3 car. saisie !

    if (value.length < 3) {
      this._clearSuggestedLocation();

      return;
    } // INFORMATION
    // on effectue la requête au service d'autocompletion.
    // on met en place des callbacks afin de recuperer les resultats ou
    // les messages d'erreurs du service.
    // les resultats sont affichés dans une liste deroulante.
    // les messages d'erreurs sont affichés sur la console (?)


    var context = this;

    this._requestAutoComplete({
      text: value,
      maximumResponses: 5,
      // FIXME je limite le nombre de reponse car le container DOM est limité dans l'affichage !!!
      // callback onSuccess
      onSuccess: function onSuccess(results) {
        if (results) {
          var locations = results.suggestedLocations;

          context._fillAutoCompletedLocationListContainer(locations);
        }
      },
      // callback onFailure
      onFailure: function onFailure(error) {
        // FIXME
        // où affiche t on les messages : ex. 'No suggestion matching the search' ?
        // doit on nettoyer la liste des suggestions dernierement enregistrée :
        context._clearSuggestedLocation();

        logger.log(error.message);
      }
    });

    var map = this.getMap();
    map.on("click", function () {
      return _this2._hideSuggestedLocation();
    });
    map.on("pointerdrag", function () {
      return _this2._hideSuggestedLocation();
    });
  };
  /**
   * this method is called by event 'click' on 'GPautoCompleteResultsList' tag div
   * (cf. this._createAutoCompleteListElement), and it selects the location.
   * this location displays a marker on the map.
   * FIXME
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LocationSelector.prototype.onAutoCompletedResultsItemClick = function (e) {
    var idx = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__["default"].index(e.target.id);

    if (!idx) {
      return;
    } // FIXME
    // les coordonnées sont inversées entre les 2 services !?
    // AutoCompletion : lon/lat ("EPSG:4326")
    // Geocoding : lat/lon


    var position = [this._suggestedLocations[idx].position.x, this._suggestedLocations[idx].position.y]; // on sauvegarde le point courant (en EPSG:4326, [lon, lat])

    this._coordinate = position;
    var info = {
      type: this._suggestedLocations[idx].type,
      fields: this._suggestedLocations[idx]
    }; // on ajoute le texte de l'autocomplétion dans l'input

    var label = this._suggestedLocations[idx].fullText;

    this._setLabel(label); // Info : la position est en EPSG:4326, à transformer dans la projection de la carte


    var view = this.getMap().getView();
    var mapProj = view.getProjection().getCode();

    if (mapProj !== "EPSG:4326") {
      // on retransforme les coordonnées de la position dans la projection de la carte
      position = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(position, "EPSG:4326", mapProj);
    } // on centre la vue et positionne le marker, à la position reprojetée dans la projection de la carte


    this._setPosition(position);

    this._setMarker(position, info, this.options.displayInfo);
  };
  /**
   * this method is called by event 'click' on 'GProuteOriginPointerImg' tag input
   * (cf. this._createRoutePointerInputElement), and it create or remove the event of click map.
   *
   * @private
   */


  LocationSelector.prototype.onActivateMapPointClick = function () {
    var _this3 = this;

    var map = this.getMap();

    if (this._inputShowPointerContainer.checked) {
      // on efface l'ancien resultat
      this._clearResults();

      this.listenerKey = map.on("click", function (e) {
        return _this3.onMouseMapClick(e);
      });

      this._setCursor("crosshair");
    } else {
      // map.un("click", (e) => this.onMouseMapClick(e));
      Object(ol_Observable__WEBPACK_IMPORTED_MODULE_4__["unByKey"])(this.listenerKey);

      this._setCursor();
    }
  };
  /**
   * this method is called by event 'click' on 'GProuteOriginLabel' tag label
   * (cf. this._createRoutePointLabelElement).
   * this point is erased.
   *
   * @private
   */


  LocationSelector.prototype.onLocationClearPointClick = function () {
    this._setCursor();

    this._clearResults();
  };
  /**
   * this method is called by event 'click' on 'GProuteStageRemove' tag input
   * (cf. this._createRouteRemovePointElement).
   * this point is deleted
   *
   * @private
   */


  LocationSelector.prototype.onLocationRemovePointClick = function () {
    this._setCursor();

    this._clearResults();
  };
  /**
   * TODO this method is called by event 'click' on 'GProuteStageAdd' tag input
   * (cf. this._createRouteAddPointElement).
   * this point is added as a parameter for the service route.
   *
   * @param {Object} e - HTMLElement
   */


  LocationSelector.prototype.onLocationAddPointClick = function (e) {
    logger.log("onRouteAddPointClick", e);
  }; // ################################################################### //
  // #################### handlers events (control) #################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on map
   * (cf. this.onRouteMapPointClick), and it gets the coordinate of click on map.
   * this point is saved as a parameter for the service route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LocationSelector.prototype.onMouseMapClick = function (e) {
    var coordinate = e.coordinate;

    if (!e.map || !e.map.getView()) {
      return;
    }

    var crs = e.map.getView().getProjection();

    this._setCoordinate(coordinate, crs);

    this._setMarker([coordinate[0], coordinate[1]], null, false); // on desactive l'event sur la map !


    this.onActivateMapPointClick(e);
  }; // ################################################################### //
  // ################# pivates methods use by events ################### //
  // ################################################################### //

  /**
   * this sends the label to the panel.
   *
   * @param {String} label - label suggested location
   * @private
   */


  LocationSelector.prototype._setLabel = function (label) {
    this._inputAutoCompleteContainer.value = label;
  };
  /**
   * this change the cursor of the map when entering a point.
   *
   * @param {String} cursor - cursor style
   * @private
   */


  LocationSelector.prototype._setCursor = function (cursor) {
    var map = this.getMap();
    var div = map.getTargetElement();

    if (cursor) {
      div.style.cursor = cursor;
    } else {
      div.style.cursor = null;
    }
  };
  /**
   * this sends the coordinates to the panel.
   *
   * @method _setCoordinate
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat] ou [x, y] (proj = map proj system)
   * @param {Object} crs - coordinate CRS (ol.proj.Projection)
   * @private
   */


  LocationSelector.prototype._setCoordinate = function (olCoordinate, crs) {
    // structure
    // ol.Coordinate
    //      [
    //          4   // lon ou x
    //          48  // lat ou y
    //      ]
    // on transforme olCoodinate (dont la projection est celle de la carte) en EPSG:4326
    this._coordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(olCoordinate, crs, "EPSG:4326"); // INFO : si on veut des DMS
    // var coords = ol.coordinate.toStringHDMS(this._coordinate, 2).split("N ");
    // // coords est du type : "48° 00′ 00″ N 2° 00′ 00″ E". On veut récupérer les 2 coordonnées séparément.
    // var lat = coords[0] + "N";
    // var lng = coords[1];
    // Pour avoir des degrés décimaux :

    var lat = this._coordinate[0].toFixed(4);

    var lng = this._coordinate[1].toFixed(4);

    var value = lng + " / " + lat;
    this.GPdisplayCoordinate(value);
  };
  /**
   * this method is called by this.on*ResultsItemClick()
   * and set center at given position.
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] (en lat/lon : "EPSG:4326")
   * @private
   */


  LocationSelector.prototype._setPosition = function (position) {
    var view = this.getMap().getView();
    view.setCenter(position);
  };
  /**
   * this method is called by this.on*ResultsItemClick()
   * and displays a marker.
   * FIXME : marker IGN et informations ?
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] ou [x, y]
   * @param {Object} information - suggested or geocoded information
   * @param {Boolean} display - display a popup information
   * @private
   */


  LocationSelector.prototype._setMarker = function (position, information, display) {
    var map = this.getMap(); // remove previous markers

    if (this._marker != null) {
      map.removeOverlay(this._marker);
      this._marker = null;
    }

    if (position) {
      var markerDiv = document.createElement("img");
      markerDiv.src = this._markerUrl;
      this._marker = new ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default.a({
        position: position,
        offset: this._markerOffset,
        element: markerDiv,
        stopEvent: false
      });
      map.addOverlay(this._marker);

      if (display) {
        logger.log("marker information : ", information);
      } // // FIXME
      // // doit on mettre une information
      // // - correctement construite ?
      // // - uniquement informatif ?
      // // - RIEN ?
      // if (display) {
      //     var popupContent = null;
      //
      //     var values = [];
      //
      //     values.push(information.fields.fullText || "");
      //     values.push(information.fields.street || "");
      //     values.push(information.fields.postalCode || "");
      //     values.push(information.fields.commune || "");
      //
      //     if (information.type === "PositionOfInterest") {
      //         values.push(information.fields.poi || "");
      //         values.push(information.fields.kind || "");
      //     }
      //
      //     popupContent = values.join(" | ");
      //
      //     this._marker.bindPopup(popupContent);
      // }

    }
  };
  /**
   * this method is called by this.()
   * and it clears all results and the marker.
   *
   * @private
   */


  LocationSelector.prototype._clearResults = function () {
    this._currentLocation = null;
    this._coordinate = null;

    this._hideSuggestedLocation();

    this._clearSuggestedLocation();

    this._setMarker(); // map.un("click", (e) => this.onMouseMapClick(e));


    Object(ol_Observable__WEBPACK_IMPORTED_MODULE_4__["unByKey"])(this.listenerKey);
  };
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and it clears all suggested location.
   *
   * @private
   */


  LocationSelector.prototype._clearSuggestedLocation = function () {
    // suppression du dom
    this._suggestedLocations = [];

    if (this._suggestedContainer) {
      while (this._suggestedContainer.firstChild) {
        this._suggestedContainer.removeChild(this._suggestedContainer.firstChild);
      }
    }
  };
  /**
   * this method is called by event 'click' on map
   * and it hide suggested locations
   *
   * @private
   */


  LocationSelector.prototype._hideSuggestedLocation = function () {
    if (this._suggestedContainer) {
      this._suggestedContainer.style.display = "none";
    }
  };
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and it clears all suggested location.
   *
   * @private
   */


  LocationSelector.prototype._displaySuggestedLocation = function () {
    if (this._suggestedContainer) {
      this._suggestedContainer.style.display = "block";
    }
  };
  /**
   * this method is called by this.onAutoCompleteSearch()
   * and executes a request to the service.
   *
   * @param {Object} settings - service settings
   * @param {String}   settings.text - text
   * @param {Function} settings.onSuccess - callback
   * @param {Function} settings.onFailure - callback
   * @private
   */


  LocationSelector.prototype._requestAutoComplete = function (settings) {
    logger.log("_requestAutoComplete()", settings); // on ne fait pas de requête si on n'a pas renseigné de parametres !

    if (!settings || Object.keys(settings).length === 0) {
      return;
    } // on ne fait pas de requête si la parametre 'text' est vide !


    if (!settings.text) {
      return;
    }

    logger.log(settings);
    var options = {}; // on recupere les options du service

    _Common_Utils__WEBPACK_IMPORTED_MODULE_7__["default"].assign(options, this.options.autocompleteOptions); // ainsi que la recherche et les callbacks

    _Common_Utils__WEBPACK_IMPORTED_MODULE_7__["default"].assign(options, settings); // les ressources

    var resources = this._resources["AutoCompletion"] || null;

    if (resources && Array.isArray(resources)) {
      if (!options.filterOptions) {
        options.filterOptions = {};
      }

      options.filterOptions.type = resources;
    } // cas où la clef API n'est pas renseignée dans les options du service,
    // on utilise celle de l'autoconf ou celle renseignée au niveau du controle


    options.apiKey = options.apiKey || this.options.apiKey; // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
    // true par défaut (https)

    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }

    logger.log(options);
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_5__["default"].Services.autoComplete(options);
  };
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and fills the container of the location list.
   * it creates a HTML Element per location
   * (cf. this. ...)
   *
   * @param {Object[]} locations - locations
   *
   * @private
   */


  LocationSelector.prototype._fillAutoCompletedLocationListContainer = function (locations) {
    if (!locations || locations.length === 0) {
      return;
    } // on vide la liste avant de la construire


    var element = this._suggestedContainer;

    if (element.childElementCount) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    for (var i = 0; i < locations.length; i++) {
      // Proposals are dynamically filled in Javascript by autocomplete service
      this._createLocationAutoCompletedLocationElement(this.options.tag.id, locations[i], i);
    } // sauvegarde de l'etat des locations


    this._suggestedLocations = locations;
  };

  return LocationSelector;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (LocationSelector); // Expose LocationSelector as ol.control.LocationSelector (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.LocationSelector = LocationSelector;
}

/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(141);


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("LocationSelectorDOM");
var LocationSelectorDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.className = this._addUID("GPlocationPoint"); // ceci permet de gerer les groupes de points !

    container.className += " GPwidget";
    return container;
  },

  /**
   * Create Container Point
   * see event !
   *
   * @param {Number} id - tag ID
   * @param {Number} display  - display
   * @returns {DOMElement} DOM element
   */
  _createLocationPointElement: function _createLocationPointElement(id, display) {
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationPoint_" + id);
    div.className = display ? "GPflexInput GPlocationStageFlexInput" : "GPflexInput GPlocationStageFlexInputHidden";
    div.style.cssText = "";
    return div;
  },

  /**
   * Create Container Point
   * see event !
   *
   * @param {Number} id - tag ID
   * @param {String} text - label
   * @returns {DOMElement} DOM element
   */
  _createLocationPointLabelElement: function _createLocationPointLabelElement(id, text) {
    // contexte d'execution
    var self = this;
    var labelOrigin = document.createElement("label");
    labelOrigin.id = this._addUID("GPlocationOriginLabel_" + id);
    labelOrigin.htmlFor = this._addUID("GPlocationOrigin_" + id);
    labelOrigin.innerHTML = text;
    labelOrigin.addEventListener("click", function (e) {
      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));

      for (var j = 0; j < points.length; j++) {
        var tag = points[j].childNodes[0].id;
        var id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
        document.getElementById(self._addUID("GPlocationPoint_" + id)).style.cssText = "";
      }

      document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "";
      document.getElementById(self._addUID("GPlocationOrigin_" + i)).value = "";
      document.getElementById(self._addUID("GPlocationPoint_" + i)).style.cssText = "";
      document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked = false;
      document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPlocationOriginVisible";
      document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPlocationOriginHidden";

      if (document.getElementById(self._addUID("GPlocationStageRemove_" + i))) {
        document.getElementById(self._addUID("GPlocationStageRemove_" + i)).className = "GPlocationStageRemove";
      }

      if (document.getElementById(self._addUID("GPlocationStageAdd"))) {
        document.getElementById(self._addUID("GPlocationStageAdd")).className = "";
      } // document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).disabled = true;


      self.onLocationClearPointClick(e);
    });
    return labelOrigin;
  },

  /**
   * Create Input AutoComplete Point tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationAutoCompleteteInputElement: function _createLocationAutoCompleteteInputElement(id) {
    // contexte d'execution
    var self = this;
    var inputOrigin = document.createElement("input");
    inputOrigin.id = this._addUID("GPlocationOrigin_" + id);
    inputOrigin.className = "GPlocationOriginVisible";
    inputOrigin.type = "text";
    inputOrigin.placeholder = "Saisir une adresse";
    inputOrigin.autocomplete = "off";
    inputOrigin.addEventListener("keyup", function (e) {
      var charCode = e.which || e.keyCode;

      if (charCode === 13 || charCode === 10 || charCode === 38 || charCode === 40) {
        return;
      }

      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);

      if (document.getElementById(self._addUID("GPlocationOrigin_" + i)).value.length > 2) {
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + i)).style.display = "block";
      } else {
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + i)).style.display = "none";
      } // gestionnaire d'evenement :
      // on récupère la valeur de saisie pour une requête sur le service d'autocompletion.
      // le resultat de la requête nous permet de recuperer les coordonnées du point...


      self.onAutoCompleteSearchText(e);
    });
    inputOrigin.addEventListener("keydown", function (e) {
      var charCode = e.which || e.keyCode;
      var container = document.getElementById(self._addUID("GPlocationAutoCompleteList_" + id)); // si aucun container !?

      if (!container) {
        return;
      }

      var curr = container.getElementsByClassName("GPautoCompleteProposal current");
      var list = container.getElementsByClassName("GPautoCompleteProposal"); // si aucune suggestion, on ne va pas plus loin !

      var length = list.length;

      if (!length) {
        return;
      }

      var current = null; // si aucun item courant, on prend le 1er !

      if (!curr.length) {
        current = list[0];
        current.className = "GPautoCompleteProposal current";
        current.style.color = "#000000";
        current.style["background-color"] = "#CEDBEF";
        return;
      } else {
        current = curr[0];
      }

      var index = parseInt(_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(current.id), 10);
      var next = index === length - 1 ? list[0] : list[index + 1];
      var prev = index === 0 ? list[length - 1] : list[index - 1];
      current.style["background-color"] = "";
      current.style.color = "";
      prev.style["background-color"] = "";
      prev.style.color = "";
      next.style["background-color"] = "";
      next.style.color = "";

      switch (charCode) {
        case 38:
          // arrow up
          logger.log("arrow up");
          current.className = "GPautoCompleteProposal";
          prev.className = "GPautoCompleteProposal current";
          prev.style.color = "#000000";
          prev.style["background-color"] = "#CEDBEF";
          break;

        case 40:
          // arrow down
          logger.log("arrow down");
          current.className = "GPautoCompleteProposal";
          next.className = "GPautoCompleteProposal current";
          next.style.color = "#000000";
          next.style["background-color"] = "#CEDBEF";
          break;

        case 13:
          // enter
          logger.log("enter");
          current.click(e);
          break;
      }

      current.focus();
    });
    return inputOrigin;
  },

  /**
   * Create Input Coordinate Point tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationCoordinateInputElement: function _createLocationCoordinateInputElement(id) {
    // contexte d'execution
    var self = this;
    var inputOriginCoord = document.createElement("input");
    inputOriginCoord.id = this._addUID("GPlocationOriginCoords_" + id);
    inputOriginCoord.className = "GPlocationOriginHidden";
    inputOriginCoord.type = "text";
    inputOriginCoord.disabled = false;
    inputOriginCoord.addEventListener("click", function () {
      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
      document.getElementById(self._addUID("GPlocationOriginLabel_" + i)).click();
    });
    return inputOriginCoord;
  },

  /**
   * Create Show Pointer tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationPointerShowInputElement: function _createLocationPointerShowInputElement(id) {
    var inputOriginPointer = document.createElement("input");
    inputOriginPointer.id = this._addUID("GPlocationOriginPointer_" + id);
    inputOriginPointer.type = "checkbox";
    return inputOriginPointer;
  },

  /**
   * Create Input Pointer tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationPointerInputElement: function _createLocationPointerInputElement(id) {
    // contexte d'execution
    var self = this;
    var labelOriginPointer = document.createElement("label");
    labelOriginPointer.id = this._addUID("GPlocationOriginPointerImg_" + id);
    labelOriginPointer.htmlFor = this._addUID("GPlocationOriginPointer_" + id);
    labelOriginPointer.className = "GPlocationOriginPointerImg";
    labelOriginPointer.title = "Pointer un lieu sur la carte";
    labelOriginPointer.addEventListener("click", function (e) {
      e.preventDefault();
      e.stopPropagation();
      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));
      var j;
      var tag;
      var id;

      for (j = 0; j < points.length; j++) {
        tag = points[j].childNodes[0].id;
        id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);

        if (i !== id) {
          document.getElementById(self._addUID("GPlocationOriginPointer_" + id)).checked = false;

          if (document.getElementById(self._addUID("GPlocationOriginCoords_" + id)).value === "Pointer un lieu sur la carte") {
            document.getElementById(self._addUID("GPlocationOriginCoords_" + id)).value = "";
            document.getElementById(self._addUID("GPlocationOrigin_" + id)).className = "GPlocationOriginVisible";
            document.getElementById(self._addUID("GPlocationOriginCoords_" + id)).className = "GPlocationOriginHidden";
          }
        }
      }

      if (document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked) {
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "";

        for (j = 0; j < points.length; j++) {
          tag = points[j].childNodes[0].id;
          id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
          document.getElementById(self._addUID("GPlocationPoint_" + id)).style.cssText = "";
        }

        if (document.getElementById(self._addUID("GPlocationStageRemove_" + i))) {
          document.getElementById(self._addUID("GPlocationStageRemove_" + i)).className = "GPlocationStageRemove";
        }

        if (document.getElementById(self._addUID("GPlocationStageAdd"))) {
          document.getElementById(self._addUID("GPlocationStageAdd")).className = "";
        }

        document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked = false;
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPlocationOriginVisible";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPlocationOriginHidden";
      } else {
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "Pointer un lieu sur la carte";

        for (j = 0; j < points.length; j++) {
          tag = points[j].childNodes[0].id;
          id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);

          if (i === id) {
            document.getElementById(self._addUID("GPlocationPoint_" + id)).style.cssText = "";
          } else {
            document.getElementById(self._addUID("GPlocationPoint_" + id)).style.display = "none";
          }
        }

        if (document.getElementById(self._addUID("GPlocationStageRemove_" + i))) {
          document.getElementById(self._addUID("GPlocationStageRemove_" + i)).className = "GPlocationOriginHidden";
        }

        if (document.getElementById(self._addUID("GPlocationStageAdd"))) {
          document.getElementById(self._addUID("GPlocationStageAdd")).className = "GPlocationOriginHidden";
        }

        document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked = true;
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPlocationOriginHidden";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPlocationOriginVisible";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).disabled = true;
      } // gestionnaire d'evenement :
      // on stocke la valeur du point, utilisée pour la requête sur le service de calcul d'itiniraire


      self.onActivateMapPointClick(e);
    });
    return labelOriginPointer;
  },

  /**
   * Create Remove Point tag
   * see event !
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationRemovePointElement: function _createLocationRemovePointElement(id) {
    // contexte d'execution
    var self = this;
    var divRm = document.createElement("div");
    divRm.id = this._addUID("GPlocationStageRemove_" + id);
    divRm.className = "GPlocationStageRemove";
    divRm.title = "Supprimer l'étape";
    divRm.addEventListener("click", function (e) {
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));
      var last = points.length - 1;
      var start = points[0].childNodes[0].id;
      var end = points[last].childNodes[0].id;
      var startID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(start);
      var endID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(end);

      if (id !== startID && id !== endID) {
        var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
        document.getElementById(self._addUID("GPlocationPoint_" + i)).className = "GPflexInput GPlocationStageFlexInputHidden";
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).value = "";
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPlocationOriginVisible";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPlocationOriginHidden";
        document.getElementById(self._addUID("GPlocationStageAdd")).style.display = ""; // Moving up exclusions picto
        // var exclusionsPictoTop = document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top;
        // document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top = (parseInt(exclusionsPictoTop) - 33).toString() + "px";
        // gestionnaire d'evenement :
        // on supprime le point, utilisé pour la requête sur le service d'itiniraire

        self.onLocationRemovePointClick(e);
      }
    });
    return divRm;
  },

  /**
   * Create Add Point tag
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createLocationAddPointElement: function _createLocationAddPointElement() {
    // contexte d'execution
    var self = this;
    var divAdd = document.createElement("div");
    divAdd.id = this._addUID("GPlocationStageAdd");
    divAdd.title = "Ajouter une étape";
    divAdd.addEventListener("click", function (e) {
      var lastStage = 1;
      var nbStages = 0;
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));

      for (var i = 1; i < points.length - 1; i++) {
        var tag = points[i].childNodes[0].id;
        var id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);

        if (document.getElementById(self._addUID("GPlocationPoint_" + id))) {
          if (document.getElementById(self._addUID("GPlocationPoint_" + id)).className === "GPflexInput GPlocationStageFlexInputHidden") {
            if (lastStage === 1) {
              lastStage = id;
            }
          } else {
            nbStages++;
          }
        }
      } // FIXME algo à revoir : lastStage = id hors si id = 300 sur 3 points !?


      if (lastStage < points.length) {
        document.getElementById(self._addUID("GPlocationPoint_" + lastStage)).className = "GPflexInput GPlocationStageFlexInput"; // Moving down exclusions picto
        // var exclusionsPictoTop = document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top;
        // document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top = (parseInt(exclusionsPictoTop) + 33).toString() + "px";
      }

      if (nbStages === 4) {
        document.getElementById(self._addUID("GPlocationStageAdd")).style.display = "none";
      } // gestionnaire d'evenement :
      // on ajoute le point, utilisé pour la requête sur le service d'itiniraire


      self.onLocationAddPointClick(e);
    });
    return divAdd;
  },

  /**
   * Create Results autocompletion to the point
   * see event!
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationAutoCompleteResultElement: function _createLocationAutoCompleteResultElement(id) {
    // contexte d'execution
    var self = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationAutoCompleteList_" + id);
    div.className = "GPadvancedAutoCompleteList";

    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        self.onAutoCompletedResultsItemClick(e);
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + id)).style.display = "none";
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function (e) {
        self.onAutoCompletedResultsItemClick(e);
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + id)).style.display = "none";
      });
    }

    return div;
  },

  /**
   * Autocompletion result to a point.
   * Proposals are dynamically filled in Javascript by autocomplete service
   *
   * TODO formaliser le contenu des reponse
   *
   * @param {Number} id - tag ID
   * @param {Object} location - suggested location result
   * @param {Number} n  - number of the point
   */
  _createLocationAutoCompletedLocationElement: function _createLocationAutoCompletedLocationElement(id, location, n) {
    var container = document.getElementById(this._addUID("GPlocationAutoCompleteList_" + id));
    var div = document.createElement("div");
    div.id = this._addUID("AutoCompletedLocation_" + n);
    div.className = "GPautoCompleteProposal";
    div.innerHTML = location.fullText;
    container.appendChild(div);
  },

  /**
  * Display Coordinate
  * @param {String} value - a Coordinate
  */
  GPdisplayCoordinate: function GPdisplayCoordinate(value) {
    var points = document.getElementsByClassName(this._addUID("GPlocationPoint"));

    for (var i = 0; i < points.length; i++) {
      var tag = points[i].childNodes[0].id;
      var id1 = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);

      if (document.getElementById(this._addUID("GPlocationOriginPointer_" + id1)).checked) {
        document.getElementById(this._addUID("GPlocationOriginCoords_" + id1)).value = value;
        document.getElementById(this._addUID("GPlocationOriginCoords_" + id1)).disabled = false;

        for (var j = 0; j < points.length; j++) {
          tag = points[j].childNodes[0].id;
          var id2 = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
          document.getElementById(this._addUID("GPlocationPoint_" + id2)).style.cssText = "";

          if (document.getElementById(this._addUID("GPlocationStageRemove_" + id2))) {
            document.getElementById(this._addUID("GPlocationStageRemove_" + id2)).className = "GPlocationStageRemove";
          }
        }

        document.getElementById(this._addUID("GPlocationOriginPointer_" + id1)).checked = false;

        if (document.getElementById(this._addUID("GPlocationStageAdd"))) {
          document.getElementById(this._addUID("GPlocationStageAdd")).className = "";
        }

        return;
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (LocationSelectorDOM);

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(141);


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("RouteDOM");
var RouteDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GProute");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing panel
   *
   * @returns {DOMElement} DOM element
   */
  _createShowRouteElement: function _createShowRouteElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowRoute");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show route control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowRoutePictoElement: function _createShowRoutePictoElement() {
    // contexte d'execution
    var context = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowRoutePicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowRoute");
    label.title = "Ouvrir le calcul d'itinéraire"; // gestionnaire d'evenement :
    // on ouvre le menu de saisie du calcul d'itiniraire
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        context.onShowRoutePanelClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        context.onShowRoutePanelClick(e);
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowRouteOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },
  // ################################################################### //
  // ################## Methods to display Inputs Panel ################ //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createRoutePanelHeaderElement
   * don't call this._createRoutePanelFormElement
   * don't call this._createRoutePanelResultsElement
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelElement: function _createRoutePanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProutePanel");
    div.className = "GPpanel"; // div.appendChild(this._createRoutePanelHeaderElement());
    // div.appendChild(this._createRoutePanelFormElement());
    // div.appendChild(this._createRoutePanelResultsElement());

    return div;
  },

  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelHeaderElement: function _createRoutePanelHeaderElement() {
    // contexte d'execution
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader";
    var div = document.createElement("div");
    div.className = "GPpanelTitle";
    div.innerHTML = "Calcul d'itinéraire";
    container.appendChild(div);
    var divClose = document.createElement("div");
    divClose.id = this._addUID("GProutePanelClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Masquer le panneau"; // Link panel close / visibility checkbox

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowRoutePicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowRoutePicto")).click();
      });
    }

    container.appendChild(divClose);
    return container;
  },

  /**
   * Create Form
   * see evenement !
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormElement: function _createRoutePanelFormElement() {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GProuteForm");
    form.setAttribute("onkeypress", "return event.keyCode != 13;"); // FIXME hack pour desactiver l'execution via 'enter' au clavier !

    form.addEventListener("submit", function (e) {
      logger.log(e);
      e.preventDefault(); // points

      var points = document.getElementsByClassName(self._addUID("GPlocationPoint")); // Must have at least two origin points

      var start = points[0].childNodes[0].id;
      var end = points[points.length - 1].childNodes[0].id;
      var startID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(start);
      var endID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(end);

      if (document.getElementById(self._addUID("GPlocationOrigin_" + startID)).value === "" && document.getElementById(self._addUID("GPlocationOriginCoords_" + startID)).value === "" || document.getElementById(self._addUID("GPlocationOrigin_" + endID)).value === "" && document.getElementById(self._addUID("GPlocationOriginCoords_" + endID)).value === "") {
        return false;
      } // Send stages to results panel


      var id;
      document.getElementById(self._addUID("GProuteResultsStages")).innerHTML = "";

      for (var i = 0; i < points.length; i++) {
        var tag = points[i].childNodes[0].id;
        id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);

        if (document.getElementById(self._addUID("GPlocationPoint_" + id)).className === "GPflexInput GPlocationStageFlexInput") {
          var resultStage = document.createElement("div");
          resultStage.className = "GProuteResultsStages";
          var resultStageLabel = document.createElement("div");
          resultStageLabel.className = "GProuteResultStageLabel";
          resultStageLabel.innerHTML = document.getElementById(self._addUID("GPlocationOriginLabel_" + id)).innerHTML + " :";
          resultStage.appendChild(resultStageLabel);
          var resultStageValue = document.createElement("div");
          resultStageValue.className = "GProuteResultStageValue";
          var elementCoords = document.getElementById(self._addUID("GPlocationOriginCoords_" + id));
          var stageCoords = elementCoords.value;
          var visible = elementCoords.className === "GPlocationOriginVisible";

          if (stageCoords !== null && stageCoords !== "" && visible) {
            resultStageValue.innerHTML = stageCoords;
          } else {
            resultStageValue.innerHTML = document.getElementById(self._addUID("GPlocationOrigin_" + id)).value;
          }

          resultStage.appendChild(resultStageValue);

          if (resultStageValue.innerHTML !== "") {
            document.getElementById(self._addUID("GProuteResultsStages")).appendChild(resultStage);
          }
        }
      } // on peut récuperer les valeurs utiles pour les transmettre au service d'iti...
      // - le mode de calcul
      // - le mode de transport
      // - les exclusions
      // Les points sont déjà stockés dans l'application.
      // computation mode params


      var modeComputation = null;

      if (document.getElementById(self._addUID("GProuteComputationSelect"))) {
        var select = document.getElementById(self._addUID("GProuteResultsComputationSelect"));
        select.selectedIndex = document.getElementById(self._addUID("GProuteComputationSelect")).selectedIndex;
        modeComputation = select.options[select.selectedIndex].value;
      } // transport mode params


      var modeTransport = null; // voiture ?

      if (document.getElementById(self._addUID("GProuteTransportCar"))) {
        if (document.getElementById(self._addUID("GProuteTransportCar")).checked) {
          modeTransport = document.getElementById(self._addUID("GProuteTransportCar")).value;
        }
      } // pieton ?


      if (document.getElementById(self._addUID("GProuteTransportPedestrian"))) {
        if (document.getElementById(self._addUID("GProuteTransportPedestrian")).checked) {
          modeTransport = document.getElementById(self._addUID("GProuteTransportPedestrian")).value;
        }
      } // exclusions params


      var exclusions = [];
      var exclusionsElement = document.getElementsByClassName("GProuteExclusionsOption");

      for (var j = 0; j < exclusionsElement.length; j++) {
        id = exclusionsElement[j].htmlFor;
        var el = document.getElementById(id);

        if (!el.checked) {
          exclusions.push(el.value);
        }
      }

      self.onRouteComputationSubmit({
        computation: modeComputation,
        transport: modeTransport,
        exclusions: exclusions
      }); // FIXME mise à jour du controle dans le composant JS !
      // document.getElementById(self._addUID("GProuteForm")).className = "GProuteComponentHidden";
      // document.getElementById(self._addUID("GProuteResultsPanel")).className = "";

      return false;
    });
    return form;
  },

  /**
   * Create Results Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelResultsElement: function _createRoutePanelResultsElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GProuteResultsPanel");
    container.className = "GProuteComponentHidden";
    container.appendChild(this._createRouteResultsStagesElement());
    container.appendChild(this._createRouteResultsElement());
    var divBorderUp = document.createElement("div");
    divBorderUp.className = "GPfakeBorder GPfakeBorderLeft";
    container.appendChild(divBorderUp);
    container.appendChild(this._createRouteShowResultsDetailsElement());
    var labelShow = document.createElement("label");
    labelShow.htmlFor = this._addUID("GProuteResultsShowDetails");
    labelShow.innerHTML = "Afficher le détail";
    container.appendChild(labelShow);
    var labelHide = document.createElement("label");
    labelHide.htmlFor = this._addUID("GProuteResultsShowDetails");
    labelHide.innerHTML = "Masquer le détail";
    container.appendChild(labelHide);
    var divBorderDown = document.createElement("div");
    divBorderDown.className = "GPfakeBorder";
    container.appendChild(divBorderDown);
    container.appendChild(this._createRouteResultsDetailsElement());
    return container;
  },

  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteWaitingElement: function _createRouteWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteCalcWaitingContainer");
    div.className = "GProuteCalcWaitingContainerHidden";
    var p = document.createElement("p");
    p.className = "GProuteCalcWaiting";
    p.innerHTML = "Calcul en cours...";
    div.appendChild(p);
    return div;
  },
  // ################################################################### //
  // ############### Methods to the window results ##################### //
  // ################################################################### //

  /**
   * Create Results Stages
   * (results dynamically generate !)
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteResultsStagesElement: function _createRouteResultsStagesElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteResultsStages");
    return div;
  },

  /**
   * Create Show Results
   * see event!
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteResultsElement: function _createRouteResultsElement() {
    // contexte
    var self = this;
    var container = document.createElement("div");
    container.id = this._addUID("GProuteResults"); // FIXME Route results are dynamically filled in Javascript by route service

    var divValue = document.createElement("div");
    divValue.id = this._addUID("GProuteResultsValues");
    container.appendChild(divValue);
    var divMode = document.createElement("div");
    divMode.id = this._addUID("GProuteResultsMode");
    var select = document.createElement("select");
    select.id = this._addUID("GProuteResultsComputationSelect");
    select.className = "GPinputSelect"; // gestionnaire d'evenement :
    // on stocke la valeur du mode de calcul, et on relance le calcul d'itiniraire

    select.addEventListener("change", function (e) {
      self.onRouteModeComputationChangeAndRun(e);
    });
    var computes = [{
      code: "fastest",
      label: "Plus rapide"
    }, {
      code: "shortest",
      label: "Plus court"
    }];

    for (var i = 0; i < computes.length; i++) {
      var option = document.createElement("option");
      option.value = computes[i].code;
      option.text = computes[i].label;
      select.appendChild(option);
    }

    divMode.appendChild(select);
    container.appendChild(divMode);
    var divNew = document.createElement("div");
    divNew.id = this._addUID("GProuteResultsNew");
    divNew.title = "Modifier le calcul";
    divNew.addEventListener("click", function (e) {
      document.getElementById(self._addUID("GProuteResultsPanel")).className = "GProuteComponentHidden";
      document.getElementById(self._addUID("GProuteForm")).className = "";
      self.onShowRouteResultsNewClick(e);
    });
    container.appendChild(divNew);
    return container;
  },

  /**
   * Add Results Duration and Distance
   * (results dynamically generate !)
   * see event!
   * @param {Number} distance - distance
   * @param {Number} duration - duration
   * @param {Function} fconvert - fconvert
   *
   * @returns {DOMElement} DOM element
   */
  _addRouteResultsValuesElement: function _addRouteResultsValuesElement(distance, duration, fconvert) {
    var div = document.getElementById(this._addUID("GProuteResultsValues")); // clean !

    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    }

    var containerDistance = document.createElement("div");
    containerDistance.className = "GProuteResultsValue";
    var labelDistance = document.createElement("label");
    labelDistance.className = "GProuteResultsValueLabel";
    labelDistance.innerHTML = "Distance :";
    containerDistance.appendChild(labelDistance);
    var distanceLabel = 0;
    var isKm = parseInt(distance / 1000, 10);

    if (!isKm) {
      distanceLabel = Math.round(distance) + " m";
    } else {
      var distanceArrondi = Math.round(distance);
      distanceArrondi = distanceArrondi / 1000;
      distanceLabel = distanceArrondi + " km";
    }

    var divDistance = document.createElement("div");
    divDistance.id = this._addUID("GProuteResultsValueDist");
    divDistance.innerHTML = distanceLabel;
    containerDistance.appendChild(divDistance);
    div.appendChild(containerDistance);
    var containerDuration = document.createElement("div");
    containerDuration.className = "GProuteResultsValue";
    var labelDuration = document.createElement("label");
    labelDuration.className = "GProuteResultsValueLabel";
    labelDuration.innerHTML = "Durée :";
    containerDuration.appendChild(labelDuration);
    var divDuration = document.createElement("div");
    divDuration.id = this._addUID("GProuteResultsValueDist");
    divDuration.innerHTML = fconvert(duration);
    containerDuration.appendChild(divDuration);
    div.appendChild(containerDuration);
    return div;
  },

  /**
   * Create Show Results Details
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteShowResultsDetailsElement: function _createRouteShowResultsDetailsElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GProuteResultsShowDetails");
    input.type = "checkbox";
    return input;
  },

  /**
   *  Create Results Details
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteResultsDetailsElement: function _createRouteResultsDetailsElement() {
    // <!-- Route results details are dynamically filled in Javascript by route service -->
    var div = document.createElement("div");
    div.id = this._addUID("GProuteResultsDetails");
    return div;
  },

  /**
   *  Add Results Details
   * (results dynamically generate !)
   * @param {Object[]} instructions - instructions
   * @param {Function} fconvert - fconvert
   *
   * @returns {DOMElement} DOM element
   */
  _addRouteResultsDetailsElement: function _addRouteResultsDetailsElement(instructions, fconvert) {
    // contexte
    var context = this;
    var div = document.getElementById(this._addUID("GProuteResultsDetails")); // clean !

    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    } // calcul des valeurs cumulé !


    var distanceCumul = 0;
    var durationCumul = 0;
    /* jshint -W083 */

    for (var i = 0; i < instructions.length; i++) {
      var id = i + 1;
      var o = instructions[i];
      var divNum = document.createElement("div");
      divNum.className = "GProuteResultsDetailsNumber";
      divNum.innerHTML = id + ".";
      div.appendChild(divNum);
      durationCumul += parseFloat(o.duration);
      distanceCumul += parseFloat(o.distance);
      var distance = 0;
      var isCumulKm = parseInt(distanceCumul / 1000, 10);

      if (!isCumulKm) {
        distance = Math.round(distanceCumul) + " m";
      } else {
        var distanceArrondi = Math.round(distanceCumul);
        distanceArrondi = distanceArrondi / 1000;
        distance = distanceArrondi + " km";
      }

      var divIns = document.createElement("div");
      divIns.className = "GProuteResultsDetailsInstruction";
      divIns.id = this._addUID("GProuteResultsDetailsInstruction_" + id);
      divIns.title = "distance : " + distance + " / " + "temps : " + fconvert(durationCumul);
      divIns.innerHTML = o.instruction;
      divIns.addEventListener("mouseover", function (e) {
        context.onRouteResultsDetailsMouseOver(e);
      });
      divIns.addEventListener("mouseout", function (e) {
        context.onRouteResultsDetailsMouseOut(e);
      });
      divIns.addEventListener("click", function (e) {
        // mode mobile !
        if (typeof context.onRouteResultsDetailsClick === "function") {
          context.onRouteResultsDetailsClick(e);
        }
      });
      div.appendChild(divIns);
    }

    return div;
  },
  // ################################################################### //
  // ################### Methods to the form points #################### //
  // ################# OVERWRITTEN BY LOCATIONSELECTOR ! ################# //

  /**
   * Create Point
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   * @param {String} text - text
   * @param {Boolean} visibility - visibility
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormPointElement: function _createRoutePanelFormPointElement(n, text, visibility) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = "GProutePoint" + n;
    div.className = visibility ? "GPflexInput GProuteStageFlexInput" : "GPflexInput GProuteStageFlexInputHidden";
    var labelOrigin = document.createElement("label");
    labelOrigin.id = "GProuteOriginLabel" + n;
    labelOrigin.htmlFor = "GProuteOrigin" + n;
    labelOrigin.innerHTML = text;
    labelOrigin.addEventListener("click", function () {
      var i = this.id.charAt(this.id.length - 1);
      document.getElementById("GProuteOriginCoords" + i).value = "";

      for (var j = 1; j < 8; j++) {
        document.getElementById("GProutePoint" + j).style.display = "flex";
      }

      document.getElementById("GProuteForm").className = "";
      document.getElementById("GProuteOriginPointer" + i).checked = false;
      document.getElementById("GProuteOrigin" + i).className = "GProuteOriginVisible";
      document.getElementById("GProuteOriginCoords" + i).className = "GProuteOriginHidden";
    });
    div.appendChild(labelOrigin);
    var inputOrigin = document.createElement("input");
    inputOrigin.id = "GProuteOrigin" + n;
    inputOrigin.className = "GProuteOriginVisible";
    inputOrigin.type = "text";
    inputOrigin.placeholder = "Saisir une adresse";
    inputOrigin.addEventListener("keyup", function (e) {
      var charCode = e.which || e.keyCode;

      if (charCode === 13 || charCode === 10) {
        return;
      }

      var i = this.id.charAt(this.id.length - 1);

      if (document.getElementById("GProuteOrigin" + i).value.length > 2) {
        document.getElementById("GProuteAutoCompleteList" + i).style.display = "block";
      } else {
        document.getElementById("GProuteAutoCompleteList" + i).style.display = "none";
      } // gestionnaire d'evenement :
      // on récupère la valeur de saisie pour une requête sur le service d'autocompletion.
      // le resultat de la requête nous permet de recuperer les coordonnées du point...


      context.onAutoCompleteSearchText(e);
    });
    inputOrigin.addEventListener("blur", function () {
      var i = this.id.charAt(this.id.length - 1);
      document.getElementById("GProuteAutoCompleteList" + i).style.display = "none";
    });
    div.appendChild(inputOrigin);
    var inputOriginCoord = document.createElement("input");
    inputOriginCoord.id = "GProuteOriginCoords" + n;
    inputOriginCoord.className = "GProuteOriginHidden";
    inputOriginCoord.type = "text";
    inputOriginCoord.disabled = true;
    div.appendChild(inputOriginCoord);
    var inputOriginPointer = document.createElement("input");
    inputOriginPointer.id = "GProuteOriginPointer" + n;
    inputOriginPointer.type = "checkbox";
    div.appendChild(inputOriginPointer);
    var labelOriginPointer = document.createElement("label");
    labelOriginPointer.id = "GProuteOriginPointerImg" + n;
    labelOriginPointer.htmlFor = "GProuteOriginPointer" + n;
    labelOriginPointer.className = "GProuteOriginPointerImg";
    labelOriginPointer.title = "Pointer un lieu sur la carte";
    labelOriginPointer.addEventListener("click", function (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      var i = this.id.charAt(this.id.length - 1);
      var j;

      for (j = 1; j < 8; j++) {
        if (i !== j) {
          document.getElementById("GProuteOriginPointer" + j).checked = false;

          if (document.getElementById("GProuteOriginCoords" + j).value === "Pointer un lieu sur la carte") {
            document.getElementById("GProuteOriginCoords" + j).value = "";
            document.getElementById("GProuteOrigin" + j).className = "GProuteOriginVisible";
            document.getElementById("GProuteOriginCoords" + j).className = "GProuteOriginHidden";
          }
        }
      }

      if (document.getElementById("GProuteOriginPointer" + i).checked) {
        document.getElementById("GProuteOriginCoords" + i).value = "";

        for (j = 1; j < 8; j++) {
          document.getElementById("GProutePoint" + j).style.display = "flex";
        }

        document.getElementById("GProuteForm").className = "";
        document.getElementById("GProuteOriginPointer" + i).checked = false;
        document.getElementById("GProuteOrigin" + i).className = "GProuteOriginVisible";
        document.getElementById("GProuteOriginCoords" + i).className = "GProuteOriginHidden";
      } else {
        document.getElementById("GProuteOriginCoords" + i).value = "Pointer un lieu sur la carte";

        for (j = 1; j < 8; j++) {
          if (i === j) {
            document.getElementById("GProutePoint" + j).style.display = "flex";
          } else {
            document.getElementById("GProutePoint" + j).style.display = "none";
          }
        }

        document.getElementById("GProuteForm").className = "GProuteFormMini";
        document.getElementById("GProuteOriginPointer" + i).checked = true;
        document.getElementById("GProuteOrigin" + i).className = "GProuteOriginHidden";
        document.getElementById("GProuteOriginCoords" + i).className = "GProuteOriginVisible";
      } // gestionnaire d'evenement :
      // on stocke la valeur du point, utilisée pour la requête sur le service de calcul d'itiniraire


      context.onRouteMapPointClick(evt);
    });
    div.appendChild(labelOriginPointer);
    return div;
  },

  /**
   * Create Remove Point tag
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormRemoveStageElement: function _createRoutePanelFormRemoveStageElement(n) {
    // contexte d'execution
    var context = this;
    var divRm = document.createElement("div");
    divRm.id = "GProuteStageRemove" + n;
    divRm.className = "GProuteStageRemove";
    divRm.title = "Supprimer l'étape";

    if (n !== 1 && n !== 7) {
      divRm.addEventListener("click", function (e) {
        var i = this.id.charAt(this.id.length - 1);
        document.getElementById("GProutePoint" + i).className = "GPflexInput GProuteStageFlexInputHidden";
        document.getElementById("GProuteOrigin" + i).value = "";
        document.getElementById("GProuteOrigin" + i).className = "GProuteOriginVisible";
        document.getElementById("GProuteOriginCoords" + i).value = "";
        document.getElementById("GProuteOriginCoords" + i).className = "GProuteOriginHidden";
        document.getElementById("GProuteStageAdd").style.display = ""; // Moving up exclusions picto
        // var exclusionsPictoTop = document.getElementById("GPshowRouteExclusionsPicto").style.top;
        // document.getElementById("GPshowRouteExclusionsPicto").style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + "px";
        // gestionnaire d'evenement :
        // on supprime le point, utilisé pour la requête sur le service d'itiniraire

        context.onRouteRemovePointClick(e);
      });
    }

    return divRm;
  },

  /**
   * Create Add Point tag
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormAddStageElement: function _createRoutePanelFormAddStageElement() {
    // contexte d'execution
    var context = this;
    var divAdd = document.createElement("div");
    divAdd.id = "GProuteStageAdd";
    divAdd.title = "Ajouter une étape";
    divAdd.addEventListener("click", function (e) {
      var lastStage = 1;
      var nbStages = 0;

      for (var i = 2; i < 7; i++) {
        if (document.getElementById("GProutePoint" + i).className === "GPflexInput GProuteStageFlexInputHidden") {
          if (lastStage === 1) {
            lastStage = i;
          }
        } else {
          nbStages++;
        }
      }

      if (lastStage < 7) {
        document.getElementById("GProutePoint" + lastStage).className = "GPflexInput GProuteStageFlexInput"; // Moving down exclusions picto
        // var exclusionsPictoTop = document.getElementById("GPshowRouteExclusionsPicto").style.top;
        // document.getElementById("GPshowRouteExclusionsPicto").style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + "px";
      }

      if (nbStages === 4) {
        document.getElementById("GProuteStageAdd").style.display = "none";
      } // gestionnaire d'evenement :
      // on ajoute le point, utilisé pour la requête sur le service d'itiniraire


      context.onRouteAddPointClick(e);
    });
    return divAdd;
  },

  /**
   * Create Results autocompletion to the point
   * see event!
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormAutoCompleteListElement: function _createRoutePanelFormAutoCompleteListElement(n) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = "GProuteAutoCompleteList" + n;
    div.className = "GPadvancedAutoCompleteList";

    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        context.onAutoCompletedResultsItemClick(e);
        document.getElementById("GProuteAutoCompleteList" + n).style.display = "none";
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function (e) {
        context.onAutoCompletedResultsItemClick(e);
        document.getElementById("GProuteAutoCompleteList" + n).style.display = "none";
      });
    } // Proposals are dynamically filled in Javascript by autocomplete service
    // <div class="GPautoCompleteProposal">...</div>


    return div;
  },

  /**
   * Autocompletion result to a point.
   * Proposals are dynamically filled in Javascript by autocomplete service
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   *
   *
   * @param {Object} location - suggested location results
   * @param {Number} n  - number of the point
   * @param {Number} id - ID
   */
  _createRouteAutoCompletedLocationElement: function _createRouteAutoCompletedLocationElement(location, n, id) {
    var container = document.getElementById("GProuteAutoCompleteList" + n);
    var div = document.createElement("div");
    div.id = "AutoCompletedLocation" + id;
    div.className = "GPautoCompleteProposal";
    div.innerHTML = location.fullText;
    container.appendChild(div);
  },
  // ################################################################### //
  // ############## Methods to the choice mode into form ############### //
  // ################################################################### //

  /**
   * Create Container to Mode choice transport
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormModeChoiceElement: function _createRoutePanelFormModeChoiceElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteModeChoice"); // div.appendChild(this._createRoutePanelFormModeChoiceTransportElement());
    // div.appendChild(this._createRoutePanelFormModeChoiceComputeElement());

    return div;
  },

  /**
   * Create Mode choice transport
   * see event !
   * FIXME event not useful
   * @param {String[]} transports - transports
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormModeChoiceTransportElement: function _createRoutePanelFormModeChoiceTransportElement(transports) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GProuteTransportChoice");
    var span = document.createElement("span");
    span.className = "GProuteModeLabel";
    span.innerHTML = "Mode de transport";
    div.appendChild(span);
    /* jshint -W083 */

    for (var i = 0; i < transports.length; i++) {
      var transport = transports[i];

      if (transport === "Voiture") {
        var inputCar = document.createElement("input");
        inputCar.id = this._addUID("GProuteTransportCar");
        inputCar.type = "radio";
        inputCar.name = "GProuteTransport";
        inputCar.value = "Voiture";

        if (i === 0) {
          inputCar.checked = true;
        } // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire


        if (inputCar.addEventListener) {
          inputCar.addEventListener("change", function (e) {
            context.onRouteModeTransportChange(e);
          });
        } else if (inputCar.attachEvent) {
          inputCar.attachEvent("onchange", function (e) {
            context.onRouteModeTransportChange(e);
          });
        }

        div.appendChild(inputCar);
        var labelCar = document.createElement("label");
        labelCar.className = "GProuteTransportImg";
        labelCar.htmlFor = this._addUID("GProuteTransportCar");
        labelCar.title = "Voiture";
        div.appendChild(labelCar);
      }

      if (transport === "Pieton") {
        var inputPedestrian = document.createElement("input");
        inputPedestrian.id = this._addUID("GProuteTransportPedestrian");
        inputPedestrian.type = "radio";
        inputPedestrian.name = "GProuteTransport";
        inputPedestrian.value = "Pieton";

        if (i === 0) {
          inputPedestrian.checked = true;
        } // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire


        if (inputPedestrian.addEventListener) {
          inputPedestrian.addEventListener("change", function (e) {
            context.onRouteModeTransportChange(e);
          });
        } else if (inputPedestrian.attachEvent) {
          inputPedestrian.attachEvent("onchange", function (e) {
            context.onRouteModeTransportChange(e);
          });
        }

        div.appendChild(inputPedestrian);
        var labelPedestrian = document.createElement("label");
        labelPedestrian.className = "GProuteTransportImg";
        labelPedestrian.htmlFor = this._addUID("GProuteTransportPedestrian");
        labelPedestrian.title = "Piéton";
        div.appendChild(labelPedestrian);
      }
    }

    return div;
  },

  /**
   * Create Mode choice computation
   * see event!
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormModeChoiceComputeElement: function _createRoutePanelFormModeChoiceComputeElement() {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GProuteComputationChoice");
    var label = document.createElement("label");
    label.htmlFor = this._addUID("GProuteComputationSelect");
    label.innerHTML = "Mode de calcul";
    var span = document.createElement("span");
    span.className = "GProuteModeLabel";
    span.appendChild(label);
    div.appendChild(span);
    var select = document.createElement("select");
    select.id = this._addUID("GProuteComputationSelect");
    select.className = "GPinputSelect"; // gestionnaire d'evenement :
    // on stocke la valeur du mode de calcul,
    // utilisation pour la requête sur le service de calcul d'itiniraire

    select.addEventListener("change", function (e) {
      context.onRouteModeComputationChange(e);
    });
    var computes = [{
      code: "fastest",
      label: "Plus rapide"
    }, {
      code: "shortest",
      label: "Plus court"
    }];

    for (var i = 0; i < computes.length; i++) {
      var option = document.createElement("option");
      option.value = computes[i].code;
      option.text = computes[i].label;
      select.appendChild(option);
    }

    div.appendChild(select);
    return div;
  },
  // ################################################################### //
  // ################# Methods to the choice exclusions ################ //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing Exclusions Options
   *
   * @returns {DOMElement} DOM element
   */
  _createShowRouteExclusionsElement: function _createShowRouteExclusionsElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowRouteExclusions");
    input.type = "checkbox";
    return input;
  },

  /**
   * Label to Exclusions Options
   * see event !
   * FIXME event not useful
   *
   * @returns {DOMElement} DOM element
   */
  _createShowRouteExclusionsPictoElement: function _createShowRouteExclusionsPictoElement() {
    // contexte d'execution
    var context = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowRouteExclusionsPicto");
    label.className = "GPshowMoreOptionsImage GPshowMoreOptions GPshowRouteExclusionsPicto";
    label.htmlFor = this._addUID("GPshowRouteExclusions");
    label.title = "Exclusions"; // label.style.top = "185px";
    // gestionnaire d'evenement :
    // on ouvre le menu des options des exclusions

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        context.onShowRouteExclusionsClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        context.onShowRouteExclusionsClick(e);
      });
    }

    return label;
  },

  /**
   * Create Container to Exclusions
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormExclusionsElement: function _createRoutePanelFormExclusionsElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteExclusions");
    var span = document.createElement("span");
    span.className = "GProuteExclusionsLabel";
    span.innerHTML = "Passages autorisés";
    div.appendChild(span); // div.appendChild(this._createRoutePanelFormExclusionOptionsElement());

    return div;
  },

  /**
   * Create Exclusions Options
   * see event !
   * FIXME event not useful
   * @param {Object[]} exclusions - exclusions
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormExclusionOptionsElement: function _createRoutePanelFormExclusionOptionsElement(exclusions) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.className = "GProuteExclusionsOptions";
    /* jshint -W083 */

    for (var value in exclusions) {
      if (exclusions.hasOwnProperty(value)) {
        var status = exclusions[value];

        switch (value) {
          case "toll":
            var inputToll = document.createElement("input");
            inputToll.id = this._addUID("GProuteExclusionsToll");
            inputToll.type = "checkbox";
            inputToll.value = "Toll";
            inputToll.checked = !status; // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire

            if (inputToll.addEventListener) {
              inputToll.addEventListener("change", function (e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputToll.attachEvent) {
              inputToll.attachEvent("onchange", function (e) {
                context.onRouteExclusionsChange(e);
              });
            }

            div.appendChild(inputToll);
            var labelToll = document.createElement("label");
            labelToll.className = "GProuteExclusionsOption";
            labelToll.htmlFor = this._addUID("GProuteExclusionsToll");
            labelToll.innerHTML = "Péages";
            div.appendChild(labelToll);
            break;

          case "tunnel":
            var inputTunnel = document.createElement("input");
            inputTunnel.id = this._addUID("GProuteExclusionsTunnel");
            inputTunnel.type = "checkbox";
            inputTunnel.value = "Tunnel";
            inputTunnel.checked = !status; // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire

            if (inputTunnel.addEventListener) {
              inputTunnel.addEventListener("change", function (e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputTunnel.attachEvent) {
              inputTunnel.attachEvent("onchange", function (e) {
                context.onRouteExclusionsChange(e);
              });
            }

            div.appendChild(inputTunnel);
            var labelTunnel = document.createElement("label");
            labelTunnel.className = "GProuteExclusionsOption";
            labelTunnel.htmlFor = this._addUID("GProuteExclusionsTunnel");
            labelTunnel.innerHTML = "Tunnels";
            div.appendChild(labelTunnel);
            break;

          case "bridge":
            var inputBridge = document.createElement("input");
            inputBridge.id = this._addUID("GProuteExclusionsBridge");
            inputBridge.type = "checkbox";
            inputBridge.value = "Bridge";
            inputBridge.checked = !status; // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire

            if (inputBridge.addEventListener) {
              inputBridge.addEventListener("change", function (e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputBridge.attachEvent) {
              inputBridge.attachEvent("onchange", function (e) {
                context.onRouteExclusionsChange(e);
              });
            }

            div.appendChild(inputBridge);
            var labelBridge = document.createElement("label");
            labelBridge.className = "GProuteExclusionsOption";
            labelBridge.htmlFor = this._addUID("GProuteExclusionsBridge");
            labelBridge.innerHTML = "Ponts";
            div.appendChild(labelBridge);
            break;
        }
      }
    }

    return div;
  },
  // ################################################################### //
  // ############################### Submit Form ####################### //
  // ################################################################### //

  /**
   * Create Submit Form Element
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteSubmitFormElement: function _createRouteSubmitFormElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GProuteSubmit");
    input.className = "GPinputSubmit";
    input.type = "submit";
    input.value = "Calculer";
    return input;
  },
  // ################################################################### //
  // ############################### Reset picto ####################### //
  // ################################################################### //

  /**
   * Create Reset Picto Element
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteFormResetElement: function _createRouteFormResetElement() {
    var self = this;
    var divReset = document.createElement("div");
    divReset.id = this._addUID("GProuteReset");
    divReset.title = "Réinitialiser les paramètres";
    divReset.addEventListener("click", function (e) {
      self.onRouteResetClick(e);
    });
    return divReset;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (RouteDOM);

/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Isochrone_GPisochronOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _CSS_Controls_Isochrone_GPisochronOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Isochrone_GPisochronOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(171);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(157);
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(180);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(172);
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(178);
/* harmony import */ var _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(185);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(179);
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(169);
/* harmony import */ var _LocationSelector__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(203);
/* harmony import */ var _Common_Controls_IsoDOM__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(207);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import OpenLayers






 // import geoportal library access

 // import local







 // import local with ol dependencies


 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_9__["default"].getLogger("isocurve");
/**
 * @classdesc
 *
 * Isocurve Control.
 *
 * @constructor
 * @alias ol.control.Isocurve
 * @extends {ol.control.Control}
 * @param {Object} options - Isocurve control options
 * @param {String}   [options.apiKey] - API key for services call (isocurve and autocomplete services), mandatory if autoconf service has not been charged in advance
 * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Object}  [options.exclusions = {"toll" : false, "tunnel" : false, "bridge" : false}] - list of exclusions with status (true = checked). By default : no exclusions checked.
 * @param {Array}   [options.graphs = ["Voiture", "Pieton"]] - list of graph resources to be used for isocurve calculation, by default : ["Voiture", "Pieton"]. Possible values are "Voiture" and "Pieton". The first element is selected.
 * @param {Array}   [options.methods = ["time", "distance"]] - list of methods, by default : ["time", "distance"]. Possible values are "time" and "distance". The first element is selected by default.
 * @param {Array}   [options.directions = ["departure", "arrival"]] - list of directions to be displayed, by default : ["departure", "arrival"]. The first element is selected by default. Possible values are "departure" and "arrival".
 *      Directions enable to specify if input location point will be used as a departure point ("departure") or as an arrival point ("arrival")
 * @param {Object} [options.isocurveOptions = {}] - isocurve service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~isoCurve Gp.Services.isoCurve()} to know all isocurve options.
 * @param {Object} [options.autocompleteOptions = {}] - autocomplete service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options
 * @param {Object} [options.markerOpts] - options to use your own marker. Default is a lightOrange marker.
 * @param {String} [options.markerOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
 * @param {Array} [options.markerOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see http://openlayers.org/en/latest/apidoc/ol.Overlay.html)
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Isochrone/Isodistance"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "isochrones/isodistance basé sur un graphe"] - Layer description to be displayed in LayerSwitcher
 * @fires isocurve:drawstart
 * @fires isocurve:drawend
 * @fires isocurve:compute
 * @example
 *  var iso = ol.control.Isocurve({
 *      "collapsed" : false,
 *      "draggable" : true,
 *      "methods" : ["time", "distance"],
 *      "exclusions" : {
 *         "toll" : true,
 *         "bridge" : false,
 *         "tunnel" : true
 *      },
 *      "graphs" : ["Pieton", "Voiture"],
 *      "markerOpts" : {
 *          "url" : "...",
 *          "offset" : [0,0]
 *      }
 *      "isocurveOptions" : {},
 *      "autocompleteOptions" : {}
 *  });
 */

var Isocurve = function (Control) {
  function Isocurve(options) {
    options = options || {};

    if (!(this instanceof Isocurve)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // initialisation du composant


    this.initialize(options); // // Widget main DOM container

    this._container = this._createMainContainerElement(); // info: le container sera complété lors de l'ajout à la carte (setMap), car certains composants nécessitent d'être liés à la map.

    this._containerElement = null; // on peut éventuellement encapsuler le composant dans une div passée par l'utilisateur

    if (options.element && options.element.appendChild) {
      // dans ce cas on stocke les deux container
      options.element.appendChild(this._container);
      this._containerElement = options.element;
    } // call ol.control.Control constructor


    Control.call(this, {
      element: this._containerElement || this._container,
      target: options.target,
      render: options.render
    });
  }

  ; // Inherits from ol.control.Control

  if (Control) Isocurve.__proto__ = Control;
  /**
   * @lends module:Isocurve
   */

  Isocurve.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune IsoDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_8__["default"].assign(Isocurve.prototype, _Common_Controls_IsoDOM__WEBPACK_IMPORTED_MODULE_17__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  Isocurve.prototype.constructor = Isocurve; // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */

  Isocurve.prototype.getCollapsed = function () {
    return this.collapsed;
  };
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */


  Isocurve.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.log("[ERROR] Isocurve:setCollapsed - missing collapsed parameter");
      return;
    }

    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }

    if (collapsed) {
      document.getElementById("GPisochronPanelClose-" + this._uid).click();
    } else {
      document.getElementById("GPshowIsochronPicto-" + this._uid).click();
    }

    this.collapsed = collapsed;
  };
  /**
   * Get vector layer where Isocurve geometry is drawn
   *
   * @returns {Object} layer - ol.layer.Vector isocurve layer
   */


  Isocurve.prototype.getLayer = function () {
    return this._geojsonLayer;
  };
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */


  Isocurve.prototype.setMap = function (map) {
    if (map) {
      // enrichissement du DOM du container lors de l'ajout à la carte
      this._container = this._initContainer(map); // mode "draggable"

      if (this.draggable) {
        _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_13__["default"].dragElement(this._IsoPanelContainer, this._IsoPanelHeaderContainer, map.getTargetElement());
      }
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Get isocurve data
   *
   * @returns {Object} data - process results
   */


  Isocurve.prototype.getData = function () {
    return this._currentIsoResults;
  };
  /**
   * This method is public.
   * It allows to control the execution of a traitment.
   *
   * @param {Array} position - position in the projection map [ x, y ]
   * @param {Object} value - distance in km or hours-minutes
   * @param {Object} options - options = {...}
   */


  Isocurve.prototype.compute = function (position, value, options) {
    this._clear();

    if (!this._showIsoContainer.checked) {
      this._pictoIsoContainer.click();
    }

    var map = this.getMap();

    if (!map) {
      return;
    } // Les options par defauts


    var settings = {
      direction: "departure",
      method: "time",
      transport: "Voiture",
      exclusions: []
    }; // On recupere les options

    _Common_Utils__WEBPACK_IMPORTED_MODULE_8__["default"].assign(settings, options);

    this._originPoint.setCoordinate(position);

    var coordinate = this._originPoint.getCoordinate();

    var input = document.getElementById("GPlocationOrigin_" + 1 + "-" + this._uid);
    input.value = coordinate[0].toFixed(4) + " / " + coordinate[1].toFixed(4);
    this._currentTransport = settings.transport;

    if (settings.transport === "Voiture") {
      document.getElementById("GPisochronTransportCar-" + this._uid).checked = true;
    } else {
      document.getElementById("GPisochronTransportPedestrian-" + this._uid).checked = true;
    }

    this._currentExclusions = settings.exclusions;
    this._currentComputation = settings.method;

    if (settings.method === "time") {
      var time = value.split(".");
      this._currentTimeHour = time[0] || 0;
      document.getElementById("GPisochronValueChronInput1-" + this._uid).value = this._currentTimeHour;
      this._currentTimeMinute = time[1] || 0;
      document.getElementById("GPisochronValueChronInput2-" + this._uid).value = this._currentTimeMinute;
      document.getElementById("GPisochronChoiceAltChron-" + this._uid).click();
    } else {
      this._currentDistance = value;
      document.getElementById("GPisochronValueDistInput-" + this._uid).value = this._currentDistance;
      document.getElementById("GPisochronChoiceAltDist-" + this._uid).click();
    }

    this._currentDirection = settings.direction;
    settings.direction === "departure" ? document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 0 : document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 1;
    this.onIsoComputationSubmit();
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize Isocurve control (called by Isocurve constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */


  Isocurve.prototype.initialize = function (options) {
    this._checkInputOptions(options); // set default options


    this.options = {
      collapsed: true,
      draggable: false,
      methods: ["time", "distance"],
      graphs: ["Voiture", "Pieton"],
      exclusions: {
        toll: false,
        tunnel: false,
        bridge: false
      },
      directions: ["departure", "arrival"],
      markerOpts: {
        url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_12__["default"]["lightOrange"],
        offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_12__["default"].defaultOffset
      },
      isocurveOptions: {},
      autocompleteOptions: {},
      layerDescription: {
        title: "Isochrone/Isodistance",
        description: "isochrones/isodistance basé sur un graphe"
      }
    }; // merge with user options

    _Common_Utils__WEBPACK_IMPORTED_MODULE_8__["default"].assign(this.options, options);
    /** {Boolean} specify if isocurve control is collapsed (true) or not (false) */

    this.collapsed = this.options.collapsed;
    /** {Boolean} specify if isocurve control is draggable (true) or not (false) */

    this.draggable = this.options.draggable; // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_11__["default"].generate(); // Options du service paramétrables via l'interface (graph, method, exclusions)
    // Mode de transport selectionné : 'Voiture' ou 'Pieton'

    this._currentTransport = null;

    this._initTransport(); // Mode de calcul selectionné : 'time' (isochron) ou 'distance' (isodistance)


    this._currentComputation = null;

    this._initComputation(); // Exclusions selectionnées : Tunnel, Toll et Bridge


    this._currentExclusions = [];

    this._initExclusions(); // sens de parcours : "departure" ou "arrival"


    this._currentDirection = null;

    this._initDirection(); // point de saisie


    this._originPoint = null; // // containers principaux

    this._showIsoContainer = null;
    this._pictoIsoContainer = null;
    this._waitingContainer = null;
    this._formContainer = null;
    this._IsoPanelContainer = null;
    this._IsoPanelHeaderContainer = null; // les résultats du calcul

    this._currentIsoResults = null; // la géométrie

    this._geojsonLayer = null; // si un calcul est en cours ou non

    this._waiting = false; // timer pour cacher la patience après un certain temps

    this._timer = null; // styles pour les sélections des features

    this._defaultFeatureStyle = new ol_style__WEBPACK_IMPORTED_MODULE_6__["Style"]({
      fill: new ol_style__WEBPACK_IMPORTED_MODULE_6__["Fill"]({
        color: "rgba(0, 183, 152, 0.7)"
      })
    }); // liste des ressources avec droits par service
    // Ex. {
    //   "Isocurve" : {
    //       key : "ger4g456re45er456t4er5ge5",
    //       resources : ["Pieton", "Voiture"]
    //   }
    // }

    this._resources = {}; // gestion des droits sur les ressources

    this._noRightManagement = false; // gestion des droits sur les ressources/services

    this._checkRightsManagement(); // listener key for event click on map


    this.listenerKey = null;
  };
  /**
   * this method is called by this.initialize()
   *
   * @param {Object} options - options
   *
   * @private
   */


  Isocurve.prototype._checkInputOptions = function (options) {
    // vérification des options
    // on ne permet pas de n'afficher aucun mode de calcul ou aucun mode de transport ?
    var i; // modes de calcul

    if (options.methods) {
      if (Array.isArray(options.methods)) {
        // on ne permet pas de passer un tableau vide : on spécifie au moins une méthode
        if (options.methods.length === 0) {
          options.methods = null;
        } else {
          for (i = 0; i < options.methods.length; i++) {
            if (typeof options.methods[i] !== "string") {
              logger.log("[ol.control.Isocurve] ERROR : parameter 'methods' elements should be of type 'string'");
            }
          }
        }
      } else {
        logger.warn("'methods' parameter should be an array");
        options.methods = null;
      }
    } // mode de transport


    if (options.graphs) {
      if (Array.isArray(options.graphs)) {
        // on ne permet pas de passer un tableau vide : on spécifie au moins un graph
        if (options.graphs.length === 0) {
          options.graphs = null;
        } else {
          for (i = 0; i < options.graphs.length; i++) {
            if (typeof options.graphs[i] !== "string") {
              logger.log("[ol.control.Isocurve] ERROR : parameter 'graphs' elements should be of type 'string'");
            } else {
              if (options.graphs[i].toLowerCase() === "pieton") {
                options.graphs[i] = "Pieton";
              }

              if (options.graphs[i].toLowerCase() === "voiture") {
                options.graphs[i] = "Voiture";
              }
            }
          }
        }
      } else {
        logger.warn("'graphs' parameter should be an array");
        options.graphs = null;
      }
    } // sens du parcours


    if (options.directions) {
      if (Array.isArray(options.directions)) {
        // on ne permet pas de passer un tableau vide : on spécifie au moins une direction
        if (options.directions.length === 0) {
          options.directions = null;
        } else {
          for (i = 0; i < options.directions.length; i++) {
            if (typeof options.directions[i] !== "string") {
              logger.log("[ol.control.Isocurve] ERROR : parameter 'directions' elements should be of type 'string'");
            }
          }
        }
      } else {
        logger.warn("'directions' parameter should be an array");
        options.directions = null;
      }
    } // collapsed


    if (options.collapsed === "true") {
      options.collapsed = true;
    }

    if (options.collapsed === "false") {
      options.collapsed = false;
    }
  };
  /**
   * this method is called by this.initialize() and initialize transport mode
   * ("Voiture" ou "Pieton")
   *
   * @private
   */


  Isocurve.prototype._initTransport = function () {
    // Mode de transport selectionné
    this._currentTransport = "Voiture"; // par defaut
    // par defaut

    var transports = this.options.graphs;

    if (!transports || transports.length === 0) {
      this.options.graphs = ["Voiture", "Pieton"];
    } // option


    if (Array.isArray(transports) && transports.length) {
      // FIXME pb si le 1er graphe n'est pas une ressource connue !
      if (transports[0] === "Voiture" || transports[0] === "Pieton") {
        this._currentTransport = transports[0];
      }
    } // si l'utilisateur a spécifié un graph dans le service, on surcharge les options du widget


    var serviceOptions = this.options.isocurveOptions;

    if (serviceOptions.graph) {
      this._currentTransport = serviceOptions.graph;
    }
  };
  /**
   * this method is called by this.initialize() and initialize computation mode
   * (time or distance)
   *
   * @private
   */


  Isocurve.prototype._initComputation = function () {
    // Mode de calcul selectionné
    this._currentComputation = "time"; // par defaut
    // par defaut

    var methods = this.options.methods;

    if (!methods || methods.length === 0) {
      this.options.methods = ["time", "distance"];
    } // option


    if (Array.isArray(methods) && methods.length) {
      // FIXME pb si le 1er graphe n'est pas une ressource connue !
      if (methods[0] === "time" || methods[0] === "distance") {
        this._currentComputation = methods[0];
      }
    } // si l'utilisateur a spécifié une méthode dans le service, on surcharge les options du widget


    var serviceOptions = this.options.isocurveOptions;

    if (serviceOptions.method) {
      this._currentComputation = serviceOptions.method;
    }

    if (serviceOptions.time) {
      this._currentComputation = "time";
    }

    if (serviceOptions.distance) {
      this._currentComputation = "distance";
    }
  };
  /**
   * this method is called by this.initialize() and initialize direction mode
   * (departure or arrival)
   *
   * @private
   */


  Isocurve.prototype._initDirection = function () {
    // Mode de calcul selectionné
    this._currentDirection = "departure"; // par defaut
    // par defaut

    var directions = this.options.directions;

    if (!directions || directions.length === 0) {
      this.options.directions = ["departure", "arrival"];
    } // option


    if (Array.isArray(directions) && directions.length) {
      // FIXME pb si le 1er graphe n'est pas une ressource connue !
      if (directions[0] === "departure" || directions[0] === "arrival") {
        this._currentDirection = directions[0];
      }
    } // si l'utilisateur a spécifié une méthode dans le service, on surcharge les options du widget


    var serviceOptions = this.options.isocurveOptions;

    if (!serviceOptions.reverse) {
      this._currentDirection = "departure";
    }

    if (serviceOptions.reverse === true) {
      this._currentDirection = "arrival";
      this.options.directions = ["arrival", "departure"];
    }
  };
  /**
   * this method is called by this.initialize() and initialize exclusions
   *
   * @private
   */


  Isocurve.prototype._initExclusions = function () {
    // Exclusions selectionnées : Tunnel, Toll et Bridge
    this._currentExclusions = []; // par defaut
    // par defaut

    var exclusion = this.options.exclusions;

    if (!exclusion || _typeof(exclusion) === "object" && Object.keys(exclusion).length === 0) {
      this.options.exclusions = {
        toll: false,
        tunnel: false,
        bridge: false
      };
    } // option


    if (exclusion && _typeof(exclusion) === "object" && Object.keys(exclusion).length) {
      for (var k in exclusion) {
        if (exclusion.hasOwnProperty(k)) {
          if (exclusion.k) {
            this._currentExclusions.push(k);
          }
        }
      }
    } // si l'utilisateur a spécifié des exclusions dans le service, on surcharge les options du widget


    var serviceOptions = this.options.isocurveOptions;

    if (Array.isArray(serviceOptions.exclusions)) {
      this._currentExclusions = serviceOptions.exclusions;
    }
  };
  /**
   * Check rights to resources (called by this.initialize())
   *
   * @private
   */


  Isocurve.prototype._checkRightsManagement = function () {
    var _opts = null;
    var _res = [];
    var _key = null; // les ressources du service du calcul d'isocurve

    _key = this.options.isocurveOptions.apiKey;
    _opts = this.options.isocurveOptions.filterOptions;
    _res = _opts ? _opts.type : [];

    if (!_res || _res.length === 0) {
      _res = ["Voiture", "Pieton"];
    }

    var rightManagementIsocurve = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_10__["default"].check({
      key: _key || this.options.apiKey,
      resources: _res,
      services: ["Isochrone"]
    });
    logger.log("rightManagementIsocurve", rightManagementIsocurve); // les ressources du service d'autocompletion

    _key = this.options.autocompleteOptions.apiKey;
    _opts = this.options.autocompleteOptions.filterOptions;
    _res = _opts ? _opts.type : [];

    if (!_res || _res.length === 0) {
      _res = ["PositionOfInterest", "StreetAddress"];
    }

    var rightManagementAutoComplete = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_10__["default"].check({
      key: _key || this.options.apiKey,
      resources: _res,
      services: ["AutoCompletion"]
    });
    logger.log("rightManagementAutoComplete", rightManagementAutoComplete); // au cas où pas de droit !

    if (!rightManagementIsocurve && !rightManagementAutoComplete) {
      this._noRightManagement = true;
    } // FIXME je reconstruis differement la structure pour la gestion des clefs differentes
    // pour chaque service...


    if (rightManagementAutoComplete) {
      this._resources["AutoCompletion"] = {};
      this._resources["AutoCompletion"]["resources"] = rightManagementAutoComplete["AutoCompletion"];
      this._resources["AutoCompletion"]["key"] = rightManagementAutoComplete["key"];
    }

    if (rightManagementIsocurve) {
      this._resources["Isocurve"] = {};
      this._resources["Isocurve"]["resources"] = rightManagementIsocurve["Isochrone"];
      this._resources["Isocurve"]["key"] = rightManagementIsocurve["key"];
    }
  }; // ################################################################### //
  // ######################## DOM initialize ########################### //
  // ################################################################### //

  /**
   * initialize component container (DOM)
   *
   * @param {Object} map - the map
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  Isocurve.prototype._initContainer = function (map) {
    var _this = this;

    // get main container
    var container = this._container;

    var inputShow = this._showIsoContainer = this._createShowIsoElement();

    container.appendChild(inputShow); // mode "collapsed"

    if (!this.collapsed) {
      inputShow.checked = true;
    }

    var picto = this._pictoIsoContainer = this._createShowIsoPictoElement();

    container.appendChild(picto); // panneau

    var panel = this._IsoPanelContainer = this._createIsoPanelElement(); // header


    var header = this._IsoPanelHeaderContainer = this._createIsoPanelHeaderElement();

    panel.appendChild(header); // form

    var form = this._formContainer = this._createIsoPanelFormElement(); // form: input de saisie de la localisation (fonction de Isocurve, voir ci-dessous)


    var point = this._createIsoPanelFormPointElement(map);

    form.appendChild(point);
    var isoChronChecked = false;
    var isoDistChecked = false;

    var typeChoice = this._createIsoPanelFormTypeChoiceElement();

    for (var i = 0; i < this.options.methods.length; i++) {
      if (this.options.methods[i] === "time") {
        isoChronChecked = i === 0;
        typeChoice.appendChild(this._createIsoPanelFormTypeChoiceChronElement(isoChronChecked));
      }

      if (this.options.methods[i] === "distance") {
        isoDistChecked = i === 0;
        typeChoice.appendChild(this._createIsoPanelFormTypeChoiceDistElement(isoDistChecked));
      }
    }

    form.appendChild(typeChoice); // form: menu du choix des valeurs

    form.appendChild(this._createIsoPanelFormValueIsochronElement(isoChronChecked));
    form.appendChild(this._createIsoPanelFormValueIsodistanceElement(isoDistChecked)); // form: menu du choix du transport et du sens du parcours

    var modeChoice = this._createIsoPanelFormModeChoiceElement();

    modeChoice.appendChild(this._createIsoPanelFormModeChoiceTransportElement(this.options.graphs)); // FIXME : doit on passer le paramètre defaultDirection ?

    modeChoice.appendChild(this._createIsoPanelFormModeChoiceDirectionElement(this.options.directions));
    form.appendChild(modeChoice); // form: menu des exclusions

    if (this.options.exclusions && _typeof(this.options.exclusions) === "object" && Object.keys(this.options.exclusions).length !== 0) {
      form.appendChild(this._createShowIsoExclusionsElement());
      form.appendChild(this._createShowIsoExclusionsPictoElement());

      var exclusion = this._createIsoPanelFormExclusionsElement();

      exclusion.appendChild(this._createIsoPanelFormExclusionOptionsElement(this.options.exclusions));
      form.appendChild(exclusion);
    }

    var divReset = this._createIsoFormResetElement();

    form.appendChild(divReset); // form: bouton du calcul

    var submit = this._submitContainer = this._createIsoSubmitFormElement();

    form.appendChild(submit);
    panel.appendChild(form); // waiting

    var waiting = this._waitingContainer = this._createIsoWaitingElement();

    panel.appendChild(waiting);
    container.appendChild(panel); // hide autocomplete suggested locations on container click

    if (container.addEventListener) {
      container.addEventListener("click", function (e) {
        return _this._hideIsoSuggestedLocations(e);
      });
    }

    return container;
  };
  /**
   * Create start point
   *
   * @param {Object} map - the map
   *
   * @returns {Object} DOM element
   * @private
   */


  Isocurve.prototype._createIsoPanelFormPointElement = function (map) {
    this._originPoint = new _LocationSelector__WEBPACK_IMPORTED_MODULE_16__["default"]({
      apiKey: this.options.apiKey || null,
      tag: {
        id: 1,
        groupId: this._uid,
        markerOpts: this.options.markerOpts,
        label: "Départ",
        display: true
      },
      autocompleteOptions: this.options.autocompleteOptions || null
    });

    this._originPoint.setMap(map); // a la sélection d'un nouveau point, on réinitialise aussi le tracé


    var self = this;
    /** click sur le pointer */

    document.getElementById("GPlocationOriginPointerImg_1-" + this._uid).onclick = function () {
      self._clearGeojsonLayer();

      var map = self.getMap();

      if (self._originPoint._inputShowPointerContainer.checked) {
        // au click sur l'input pour pointer sur la carte: on minimise le formulaire
        self._formContainer.className = "GPisochronFormMini"; // et au clic sur la carte, on réaffichera le formulaire "normal"

        this.listenerKey = map.on("click", function () {
          self._formContainer.className = "";
          self.dispatchEvent("isocurve:drawend");
        });
      } else {
        // si on déselectionne le pointer, on rétablit le formulaire en mode normal
        self._formContainer.className = ""; // et on enlève l'écouteur d'évènement sur la carte
        // map.un("click", () => { self._formContainer.className = ""; });

        Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(this.listenerKey);
      }
      /**
      * event triggered at the start of drawing input
      *
      * @event isocurve:drawstart
      */


      self.dispatchEvent("isocurve:drawstart");
    };
    /** click sur le label */


    document.getElementById("GPlocationOriginLabel_1-" + this._uid).onclick = function () {
      self._clearGeojsonLayer();

      self._formContainer.className = ""; // on désactive l'écouteur d'événements sur la carte (pour ne pas placer un marker au clic)

      map.un("click", function () {
        self._formContainer.className = "";
      });
      self.dispatchEvent("isocurve:drawend");
    };
    /** click sur la zone de saisie */


    document.getElementById("GPlocationOrigin_1-" + this._uid).onclick = function () {
      self._clearGeojsonLayer();
      /**
      * event triggered at the end of drawing input
      *
      * @event isocurve:drawend
      */


      self.dispatchEvent("isocurve:drawend");
    };

    return this._originPoint._container;
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'submit' on 'GPisochronForm' tag form
   * (cf. this._createIsoPanelFormElement),
   * and call isocurve service to display results
   *
   * @private
   */


  Isocurve.prototype.onIsoComputationSubmit = function () {
    // si on n'a pas de valeur récupérée pour notre point origine, on ne fait rien
    if (!this._originPoint || !this._originPoint.getCoordinate || !this._originPoint.getCoordinate()) {
      logger.log("[Isocurve] Missing position parameter to submit isocurve request");
      return;
    } // récupération de l'origine


    var positionCoordinates = this._originPoint.getCoordinate();

    var position = {
      x: positionCoordinates[0],
      y: positionCoordinates[1]
    };
    logger.log("origin : ", position); // récupération du temps ou de la distance

    var time;
    var distance;

    if (this._currentComputation.toLowerCase() === "time") {
      var timeHourInput = document.getElementById("GPisochronValueChronInput1-" + this._uid);
      var hours = parseInt(timeHourInput.value, 10);

      if (isNaN && isNaN(hours)) {
        hours = 0;
      }

      var timeMinutesInput = document.getElementById("GPisochronValueChronInput2-" + this._uid);
      var minutes = parseInt(timeMinutesInput.value, 10);

      if (isNaN && isNaN(minutes)) {
        minutes = 0;
      } // durée exprimée en secondes


      time = hours * 3600 + minutes * 60;
      logger.log("time : " + time);
    }

    if (this._currentComputation.toLowerCase() === "distance") {
      var distInput = document.getElementById("GPisochronValueDistInput-" + this._uid); // distance exprimée en mètres

      distance = parseFloat(distInput.value) * 1000;
      logger.log("distance : " + distance);
    } // si on n'a pas de valeur de calcul renseignée, on ne lance pas la requête.


    if (!time && !distance) {
      logger.log("[Isocurve] Missing time or distance parameter to submit isocurve request");
      return;
    } // oups, aucun droits !
    // on evite donc une requête inutile ...


    if (this._noRightManagement) {
      logger.log("[Isocurve] no rights for this service");
      return;
    } // on recupere les éventuelles options du service passées par l'utilisateur


    var options = this.options.isocurveOptions || {}; // gestion du protocole et du timeout
    // le timeout est indispensable sur le protocole JSONP.

    var _protocol = options.protocol || "XHR";

    var _timeout = options.timeOut || 0;

    if (_protocol === "JSONP" && _timeout === 0) {
      // FIXME le timeout est obligatoire pour ce type de protocole...
      _timeout = 15000;
    } // gestion des callback


    var bOnFailure = !!(options.onFailure !== null && typeof options.onFailure === "function"); // cast variable to boolean

    var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function"); // on met en place l'affichage des resultats dans la fenetre de resultats.

    var context = this;
    var isoRequestOptions = {
      position: position,
      graph: options.graph || this._currentTransport,
      exclusions: options.exclusions || this._currentExclusions,
      method: options.method || this._currentComputation,
      smoothing: options.smoothing || true,
      timeOut: _timeout,
      protocol: _protocol,
      // callback onSuccess
      onSuccess: function onSuccess(results) {
        logger.log(results);

        if (results) {
          context._drawIsoResults(results);
        }

        if (bOnSuccess) {
          options.onSuccess.call(context, results);
        }
      },
      // callback onFailure
      onFailure: function onFailure(error) {
        // FIXME mise à jour du controle mais le service ne repond pas en 200 !?
        context._hideWaitingContainer();

        logger.log(error.message);

        if (bOnFailure) {
          options.onFailure.call(context, error);
        }
      }
    };

    if (this._currentDirection.toLowerCase() === "arrival" || options.reverse) {
      isoRequestOptions.reverse = true;
    }

    if (time) {
      isoRequestOptions.time = time;
    }

    if (distance) {
      isoRequestOptions.distance = distance;
    }

    this._requestIsoCurve(isoRequestOptions);
  };
  /**
   * this method is called by event 'click' on 'GPshowIsochronPicto' picto
   * (cf. this._createShowIsoPictoElement),
   * and clear inputs and previous isocurve drawings
   *
   * @private
   */


  Isocurve.prototype.onShowIsoPanelClick = function () {
    var map = this.getMap(); // on supprime toutes les interactions

    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_14__["default"].unset(map);
    this.collapsed = this._showIsoContainer.checked; // on génère nous même l'evenement OpenLayers de changement de propriété
    // (utiliser ol.control.Isocurve.on("change:collapsed", function ) pour s'abonner à cet évènement)

    this.dispatchEvent("change:collapsed");
  };
  /**
   * this method is called by event 'change' on 'GPisochronChoiceAltDist' or 'GPisochronChoiceAltChron'
   * input (cf. this._createIsoPanelFormTypeChoiceElement),
   * and updates current computation mode
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Isocurve.prototype.onIsoTypeChoiceChange = function (e) {
    var value = e.target.value;

    if (!value) {
      return;
    }

    if (value === "isodistance") {
      this._currentComputation = "distance";
    }

    if (value === "isochron") {
      this._currentComputation = "time";
    }
  };
  /**
   * this method is called by event 'click' on 'GPisochronTransportPedestrian' or 'GPisochronTransportCar'
   * input (cf. this._createIsoPanelFormModeChoiceTransportElement),
   * and updates current transport mode
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Isocurve.prototype.onIsoModeTransportChange = function (e) {
    var value = e.target.value;

    if (!value) {
      return;
    }

    this._currentTransport = value;
  };
  /**
   * this method is called by event 'change' on 'GPisochronDirectionSelect' select
   * (cf. this._createIsoPanelFormModeChoiceDirectionElement),
   * and updates current direction mode
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Isocurve.prototype.onIsoModeDirectionChange = function (e) {
    var value = e.target.value;

    if (!value) {
      return;
    }

    if (value.toLowerCase() === "arrival") {
      this._originPoint._inputLabelContainer.innerHTML = "Arrivée";
    } else {
      this._originPoint._inputLabelContainer.innerHTML = "Départ";
    }

    this._currentDirection = value;
  };
  /**
   * this method is called by event 'change' on 'GPIsoExclusionsToll'
   * or 'GPIsoeExclusionsTunnel' or 'GPIsoExclusionsBridge' tag input
   * (cf. this._createIsoPanelFormExclusionOptionsElement).
   * this value is saved as a parameter for the service isocurve.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  Isocurve.prototype.onIsoExclusionsChange = function (e) {
    var value = e.target.value;
    var checked = e.target.checked;

    if (!value) {
      return;
    }

    var bFound = false;
    var iFound = null;

    for (var i = 0; i < this._currentExclusions.length; i++) {
      if (deepEqual(this._currentExclusions[i], value.toLowerCase())) {
        iFound = i;
        bFound = true;
      }
    } // on l'ajoute si la valeur n'existe pas et est selectionnée


    if (!bFound && !checked) {
      this._currentExclusions.push(value.toLowerCase());
    } // on la retire si la valeur existe et est deselectionnée


    if (bFound && checked) {
      this._currentExclusions[iFound] = null;
    }
  };
  /**
   * this method is called by event 'click' on 'GPisoReset'
   * tag label (cf. this._createIsoFormResetElement),
   * and it cleans all isochron input options and results.
   *
   * @private
   */


  Isocurve.prototype.onIsoResetClick = function () {
    // clear
    this._clear();
  }; // ################################################################### //
  // ######################## isocurve calculation ##################### //
  // ################################################################### //

  /**
   * this method is called by this.onIsoComputationSubmit
   * and executes a request to the service.
   *
   * @param {Object} options - isocurve service request options
   * @private
   */


  Isocurve.prototype._requestIsoCurve = function (options) {
    // on ne fait pas de requête si on n'a pas renseigné de parametres !
    if (!options || _typeof(options) === "object" && Object.keys(options).length === 0) {
      return;
    } // on ne fait pas de requête si on n'a pas de point d'origine


    if (!options.position) {
      return;
    } // ni si on n'a aucun droit


    if (this._noRightManagement || !this._resources["Isocurve"]) {
      logger.log("no rights for this service");
      return;
    } // gestion des droits !


    var resources = this._resources["Isocurve"].resources;

    if (!resources || _typeof(resources) === "object" && Object.keys(resources).length === 0) {
      logger.log("no rights for this service");
      return;
    } // la ressource donne elle des droits ?


    var bFound = false;

    for (var i = 0; i < resources.length; i++) {
      if (resources[i] === options.graph) {
        bFound = true;
      }
    } // on fait quoi ?


    if (!bFound) {
      logger.log("no rights for this service !?");
      return;
    } // cas où la clef API n'est pas renseignée dans les options du service,
    // on utilise celle de l'autoconf ou celle renseignée au niveau du controle


    var key = this._resources["Isocurve"]["key"];
    options.apiKey = this.options.isocurveOptions.apiKey || this.options.apiKey || key; // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
    // true par défaut (https)

    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }

    logger.log(options); // on efface une éventuelle précédente couche

    this._clearGeojsonLayer(); // mise en place de la patience


    this._displayWaitingContainer(); // appel du service de calcul d'isochrones


    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_7__["default"].Services.isoCurve(options);
  };
  /**
   * this method is called by this.onIsoComputationSubmit (in case of success)
   * and draw isocurve results geometry on map
   *
   * @param {Object} results - isocurve response results
   * @private
   */


  Isocurve.prototype._drawIsoResults = function (results) {
    var _this2 = this;

    // sauvegarde de l'etat des resultats
    this._currentIsoResults = results; // cache la patience

    this._hideWaitingContainer();

    if (!results.geometry) {
      return;
    }

    var map = this.getMap(); // 1. création de l'objet geoJSON

    var geojsonObject = {
      type: "Feature",
      crs: {
        type: "name",
        properties: {
          name: "EPSG:4326"
        }
      },
      geometry: results.geometry
    };
    var geojsonformat = new ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_5___default.a({
      defaultDataProjection: "EPSG:4326"
    });
    var mapProj = map.getView().getProjection().getCode();
    var features = geojsonformat.readFeatures(geojsonObject, {
      dataProjection: "EPSG:4326",
      featureProjection: mapProj
    }); // 2. ajout de la géométrie comme nouvelle couche vecteur à la carte

    this._geojsonLayer = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default.a({
      source: new ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default.a({
        features: features
      }),
      style: this._defaultFeatureStyle,
      opacity: 0.9
    }); // ajout d'un identifiant à la couche

    var graph;

    if (this._currentTransport === "Pieton") {
      graph = "piéton";
      this._geojsonLayer.gpResultLayerId = "Pieton$GEOPORTAIL:GPP:Isocurve";
    } else {
      graph = "voiture";
      this._geojsonLayer.gpResultLayerId = "Voiture$GEOPORTAIL:GPP:Isocurve";
    } // ajout à la carte


    map.addLayer(this._geojsonLayer);
    /**
     * event triggered when the compute is finished
     *
     * @event isocurve:compute
     * @typedef {Object}
     * @property {Object} type - event
     * @property {Object} target - instance Isocurve
     * @example
     * Isocurve.on("isocurve:compute", function (e) {
     *   console.log(e.target.getData());
     * })
     */

    this.dispatchEvent({
      type: "isocurve:compute"
    }); // 3. Zoom sur l'emprise de la geometry

    if (features[0] && features[0].getGeometry() && features[0].getGeometry().getExtent()) {
      var extent = features[0].getGeometry().getExtent();
      map.getView().fit(extent, map.getSize());
    } // 5. Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche


    var method = this._currentComputation === "time" ? "Isochrone" : "Isodistance";
    map.getControls().forEach(function (control) {
      if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_15__["default"]) {
        // un layer switcher est présent dans la carte
        var layerId = _this2._geojsonLayer.gpLayerId; // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)

        if (control._layers[layerId].title === layerId) {
          control.addLayer(_this2._geojsonLayer, {
            title: _this2.options.layerDescription.title + " (" + method + "/" + graph + ")",
            description: _this2.options.layerDescription.description
          });
        }
      }
    });
  }; // ################################################################### //
  // ############################# Clean ############################### //
  // ################################################################### //

  /**
   * this method is called by this.onShowIsoPanelClick()
   * and it clears all elements (reinit).
   *
   * @private
   */


  Isocurve.prototype._clear = function () {
    // clear inputs
    this._clearIsoInputs(); // clear origin point (and marker)


    this._originPoint.clear(); // remove geometry layer


    this._clearGeojsonLayer(); // clear results


    this._currentIsoResults = null;
  };
  /**
   * this method is called by this._clear()
   * and it clears all input elements (dist and time)
   *
   * @private
   */


  Isocurve.prototype._clearIsoInputs = function () {
    // 1. clear inputs
    // clear time inputs (if exists) :
    // hours
    var timeHourInput = document.getElementById("GPisochronValueChronInput1-" + this._uid);

    if (timeHourInput) {
      timeHourInput.value = "0";
    } // minutes


    var timeMinutesInput = document.getElementById("GPisochronValueChronInput2-" + this._uid);

    if (timeMinutesInput) {
      timeMinutesInput.value = "0";
    } // clear distance input (if exists)


    var distInput = document.getElementById("GPisochronValueDistInput-" + this._uid);

    if (distInput) {
      distInput.value = "0";
    } // 2. reinit options to default


    this._initTransport();

    this._initComputation();

    this._initDirection();

    this._initExclusions(); // 3. set transport mode to default


    var transportdiv;

    if (this._currentTransport === "Pieton") {
      transportdiv = document.getElementById("GPisochronTransportPedestrian-" + this._uid);

      if (transportdiv) {
        transportdiv.checked = "true";
      }
    } else {
      transportdiv = document.getElementById("GPisochronTransportCar-" + this._uid);

      if (transportdiv) {
        transportdiv.checked = "true";
      }
    } // 4. set computation mode to default (distance or time)


    var computationdiv;

    if (this._currentComputation.toLowerCase() === "distance") {
      computationdiv = document.getElementById("GPisochronChoiceAltDist-" + this._uid);

      if (computationdiv) {
        computationdiv.checked = "true";
      }

      if (document.getElementById("GPisochronValueDist-" + this._uid)) {
        document.getElementById("GPisochronValueDist-" + this._uid).className = "GPflexInput";
      }

      if (document.getElementById("GPisochronValueChron-" + this._uid)) {
        document.getElementById("GPisochronValueChron-" + this._uid).className = "GPisochronValueHidden";
      }
    } else {
      computationdiv = document.getElementById("GPisochronChoiceAltChron-" + this._uid);

      if (computationdiv) {
        computationdiv.checked = "true";
      }

      if (document.getElementById("GPisochronValueChron-" + this._uid)) {
        document.getElementById("GPisochronValueChron-" + this._uid).className = "GPflexInput";
      }

      if (document.getElementById("GPisochronValueDist-" + this._uid)) {
        document.getElementById("GPisochronValueDist-" + this._uid).className = "GPisochronValueHidden";
      }
    } // 5. set direction mode to default (arrival or departure)


    var directionSelect = document.getElementById("GPisochronDirectionSelect-" + this._uid);

    if (directionSelect) {
      directionSelect.value = this._currentDirection;
    }

    if (this._currentDirection === "arrival") {
      this._originPoint._inputLabelContainer.innerHTML = "Arrivée";
    } else {
      this._originPoint._inputLabelContainer.innerHTML = "Départ";
    } // 6. set exclusions to default


    var tollInput = document.getElementById("GPisoExclusionsToll-" + this._uid);

    if (tollInput) {
      if (this._currentExclusions.indexOf("toll") !== -1) {
        tollInput.checked = false;
      } else {
        tollInput.checked = true;
      }
    }

    var tunnelInput = document.getElementById("GPisoExclusionsTunnel-" + this._uid);

    if (tunnelInput) {
      if (this._currentExclusions.indexOf("tunnel") !== -1) {
        tunnelInput.checked = false;
      } else {
        tunnelInput.checked = true;
      }
    }

    var bridgeInput = document.getElementById("GPisoExclusionsBridge-" + this._uid);

    if (bridgeInput) {
      if (this._currentExclusions.indexOf("bridge") !== -1) {
        bridgeInput.checked = false;
      } else {
        bridgeInput.checked = true;
      }
    }
  };
  /**
   * this method is called by this.onIsoComputationSubmit (in case of failure)
   * and it clears all geometries
   *
   * @private
   */


  Isocurve.prototype._clearGeojsonLayer = function () {
    var map = this.getMap(); // remove layer

    if (this._geojsonLayer) {
      map.removeLayer(this._geojsonLayer);
      this._geojsonLayer = null;
    }
  };
  /**
   * this method is called by event 'click' on control main container
   * and hide suggested Locations (unless target is an autocomplete input)
   *
   * @param {Object} e - event
   *
   * @private
   */


  Isocurve.prototype._hideIsoSuggestedLocations = function (e) {
    // si on clique sur l'input de saisie du point d'origine
    if (e.target && e.target.id && e.target.id.indexOf("GPlocationOrigin_") !== -1) {} else {
      // si on clique ailleurs dans le DOM du control, on cache tous les résultats d'autocomplétion
      this._originPoint._hideSuggestedLocation();
    }
  };
  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */


  Isocurve.prototype._displayWaitingContainer = function () {
    this._waitingContainer.className = "GPisochronCalcWaitingContainerVisible";
    this._waiting = true; // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)
    // si on est toujours en attente (si la requête est bloquée par exemple)

    var opts = this.options.isocurveOptions;

    if (opts && opts.timeOut) {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }

      var context = this;
      this._timer = setTimeout(function () {
        if (context._waiting === true) {
          context._hideWaitingContainer();
        } else {
          if (context._timer) {
            clearTimeout(context._timer);
          }
        }
      }, 16000);
    }
  };
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */


  Isocurve.prototype._hideWaitingContainer = function () {
    if (this._waiting) {
      this._waitingContainer.className = "GPisochronCalcWaitingContainerHidden";
      this._waiting = false;
      var opts = this.options.isocurveOptions;

      if (opts && opts.timeOut) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    }
  };

  return Isocurve;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (Isocurve); // Expose Isocurve as ol.control.Isocurve (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.Isocurve = Isocurve;
}

var deepEqual = function deepEqual(x, y) {
  if (x === y) {
    return true;
  } else if (_typeof(x) == "object" && x != null && _typeof(y) == "object" && y != null) {
    if (Object.keys(x).length != Object.keys(y).length) {
      return false;
    }

    for (var prop in x) {
      if (y.hasOwnProperty(prop)) {
        if (!deepEqual(x[prop], y[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }

    return true;
  } else {
    return false;
  }
};

/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var IsoDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPisochron");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing panel
   *
   * @returns {DOMElement} DOM element
   */
  _createShowIsoElement: function _createShowIsoElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowIsochron");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show iso control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowIsoPictoElement: function _createShowIsoPictoElement() {
    // contexte d'execution
    var context = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowIsochronPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowIsochron");
    label.title = "Calculer une isochrone"; // gestionnaire d'evenement :
    // on ouvre le menu de saisie du calcul d'isochrone
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        context.onShowIsoPanelClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        context.onShowIsoPanelClick(e);
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowIsochronOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },
  // ################################################################### //
  // ################## Methods to display Inputs Panel ################ //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createIsoPanelHeaderElement
   * don't call this._createIsoPanelFormElement
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelElement: function _createIsoPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronPanel");
    div.className = "GPpanel"; // div.appendChild(this._createIsoPanelHeaderElement());
    // div.appendChild(this._createIsoPanelFormElement());

    return div;
  },

  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelHeaderElement: function _createIsoPanelHeaderElement() {
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader";
    var div = document.createElement("div");
    div.className = "GPpanelTitle";
    div.innerHTML = "Calcul d'isochrone";
    container.appendChild(div); // on desactive l'impl. reduction de la fenetre
    // var divReduce  = document.createElement("div");
    // divReduce.id = this._addUID("GPisochronPanelReduce");
    // divReduce.className = "GPpanelReduce";
    // divReduce.title = "Masquer le panneau";
    //
    // if (divReduce.addEventListener) {
    //     divReduce.addEventListener("click", function () {
    //         if ( typeof self.onReduceIsoPanelClick === "function") {
    //             document.getElementById(self._addUID("GPshowIsochron")).checked = false;
    //             self.onReduceIsoPanelClick();
    //         }
    //     }, false);
    // } else if (divReduce.attachEvent) {
    //     divReduce.attachEvent("onclick", function () {
    //         if ( typeof self.onReduceIsoPanelClick === "function") {
    //             document.getElementById(self._addUID("GPshowIsochron")).checked = false;
    //             self.onReduceIsoPanelClick();
    //         }
    //     });
    // }
    // container.appendChild(divReduce);

    var divClose = document.createElement("div");
    divClose.id = this._addUID("GPisochronPanelClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer le panneau"; // Link panel close / visibility checkbox

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowIsochronPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowIsochronPicto")).click();
      });
    }

    container.appendChild(divClose);
    return container;
  },

  /**
   * Create Form
   * see evenement !
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormElement: function _createIsoPanelFormElement() {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPisochronForm");
    form.addEventListener("submit", function (e) {
      e.preventDefault();
      self.onIsoComputationSubmit(e);
      return false;
    });
    return form;
  },

  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoWaitingElement: function _createIsoWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronCalcWaitingContainer");
    div.className = "GPisochronCalcWaitingContainerHidden";
    var p = document.createElement("p");
    p.className = "GPisochronCalcWaiting";
    p.innerHTML = "Calcul en cours...";
    div.appendChild(p);
    return div;
  },
  // ################################################################### //
  // ############# Methods to the type choice into form ################ //
  // ################################################################### //

  /**
   * Create Container to type choice
   *
   * FIXME
   * don't call this._createIsoPanelFormTypeChoiceChronElement
   * don't call this._createIsoPanelFormTypeChoiceDistElement
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormTypeChoiceElement: function _createIsoPanelFormTypeChoiceElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronChoice"); // div.appendChild(this._createIsoPanelFormTypeChoiceChronElement());
    // div.appendChild(this._createIsoPanelFormTypeChoiceDistElement());

    return div;
  },

  /**
   * Create Type choice Chron
   * see event !
   * FIXME event not useful
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormTypeChoiceChronElement: function _createIsoPanelFormTypeChoiceChronElement(checked) {
    var self = this;
    var div = document.createElement("div");
    div.className = "GPisochronChoiceAlt";
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronChoiceAltChron");
    input.name = "GPisochronChoiceMode";
    input.type = "radio";
    input.checked = !!checked;

    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPflexInput";
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPisochronValueHidden";
        self.onIsoTypeChoiceChange(e);
      }, false);
    } else if (input.attachEvent) {
      input.attachEvent("onchange", function () {
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPflexInput";
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPisochronValueHidden";
        self.onIsoTypeChoiceChange();
      });
    } // info: Internet explorer support


    input.value = "isochron";
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPisochronChoiceAltImg";
    label.htmlFor = this._addUID("GPisochronChoiceAltChron");
    div.appendChild(label);
    var span = document.createElement("span");
    span.id = this._addUID("GPisochronChoiceAltChronTxt");
    span.innerHTML = "isochrone";

    if (span.addEventListener) {
      span.addEventListener("click", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltChron")).click();
      }, false);
    } else if (span.attachEvent) {
      span.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltChron")).click();
      });
    }

    div.appendChild(span);
    return div;
  },

  /**
   * Create Type choice Dist
   * see event !
   * FIXME event not useful
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormTypeChoiceDistElement: function _createIsoPanelFormTypeChoiceDistElement(checked) {
    var self = this;
    var div = document.createElement("div");
    div.className = "GPisochronChoiceAlt";
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronChoiceAltDist");
    input.name = "GPisochronChoiceMode";
    input.type = "radio";
    input.checked = !!checked;

    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPflexInput";
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPisochronValueHidden";
        self.onIsoTypeChoiceChange(e);
      }, false);
    } else if (input.attachEvent) {
      input.attachEvent("onchange", function () {
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPflexInput";
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPisochronValueHidden";
        self.onIsoTypeChoiceChange();
      });
    } // info: Internet explorer support


    input.value = "isodistance";
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPisochronChoiceAltImg";
    label.htmlFor = this._addUID("GPisochronChoiceAltDist");
    div.appendChild(label);
    var span = document.createElement("span");
    span.id = this._addUID("GPisochronChoiceAltDistTxt");
    span.innerHTML = "isodistance";

    if (span.addEventListener) {
      span.addEventListener("click", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltDist")).click();
      }, false);
    } else if (span.attachEvent) {
      span.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltDist")).click();
      });
    }

    div.appendChild(span);
    return div;
  },
  // ################################################################### //
  // ############### Methods to the value iso into form ################ //
  // ################################################################### //

  /**
   * Create isochron inputs values
   * see event !
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormValueIsochronElement: function _createIsoPanelFormValueIsochronElement(checked) {
    // contexte
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronValueChron");
    div.className = checked ? "GPflexInput" : "GPisochronValueHidden";
    var label = document.createElement("label");
    label.id = this._addUID("GPisochronValueChronLabel");
    label.htmlFor = this._addUID("GPisochronValueChronInput");
    label.innerHTML = "Temps";
    div.appendChild(label);
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPisochronValueChronInput1");
    input1.min = "0";
    input1.step = "1";
    input1.value = "0";
    input1.type = "number";

    if (input1.addEventListener) {
      input1.addEventListener("change", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeHourChange(e);
        }
      });
    } else if (input1.attachEvent) {
      input1.attachEvent("onchange", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeHourChange(e);
        }
      });
    }

    div.appendChild(input1);
    var label1 = document.createElement("label");
    label1.innerHTML = "h";
    div.appendChild(label1);
    var input2 = document.createElement("input");
    input2.id = this._addUID("GPisochronValueChronInput2");
    input2.min = "0";
    input2.max = "59";
    input2.step = "1";
    input2.value = "0";
    input2.type = "number";

    if (input2.addEventListener) {
      input2.addEventListener("change", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeMinuteChange(e);
        }
      });
    } else if (input2.attachEvent) {
      input2.attachEvent("onchange", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeMinuteChange(e);
        }
      });
    }

    div.appendChild(input2);
    var label2 = document.createElement("label");
    label2.innerHTML = "min";
    div.appendChild(label2);
    return div;
  },

  /**
   * Create isodistance inputs values
   * see event !
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormValueIsodistanceElement: function _createIsoPanelFormValueIsodistanceElement(checked) {
    // contexte
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronValueDist");
    div.className = checked ? "GPflexInput" : "GPisochronValueHidden";
    var label = document.createElement("label");
    label.id = this._addUID("GPisochronValueDistLabel");
    label.htmlFor = this._addUID("GPisochronValueDistInput");
    label.innerHTML = "Distance";
    div.appendChild(label);
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPisochronValueDistInput");
    input1.min = "0";
    input1.step = "any";
    input1.value = "0";
    input1.type = "number";

    if (input1.addEventListener) {
      input1.addEventListener("change", function (e) {
        if (typeof context.onIsoValueDistChange === "function") {
          context.onIsoValueDistChange(e);
        }
      });
    } else if (input1.attachEvent) {
      input1.attachEvent("onchange", function (e) {
        if (typeof context.onIsoValueDistChange === "function") {
          context.onIsoValueDistChange(e);
        }
      });
    }

    div.appendChild(input1);
    var label1 = document.createElement("label");
    label1.innerHTML = "km";
    div.appendChild(label1);
    return div;
  },
  // ################################################################### //
  // ############ Methods to the mode choice into form ################# //
  // ################################################################### //

  /**
   * Create Container to Mode choice
   *
   * FIXME
   * don't call this._createIsoPanelFormModeChoiceTransportElement
   * don't call this._createIsoPanelFormModeChoiceDirectionElement
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormModeChoiceElement: function _createIsoPanelFormModeChoiceElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronModeChoice"); // div.appendChild(this._createIsoPanelFormModeChoiceTransportElement());
    // div.appendChild(this._createIsoPanelFormModeChoiceDirectionElement());

    return div;
  },

  /**
   * Create Mode choice transport
   * see event !
   * FIXME event not useful
   * @param {Array} transports - transports in a list
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormModeChoiceTransportElement: function _createIsoPanelFormModeChoiceTransportElement(transports) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronTransportChoice");
    var span = document.createElement("span");
    span.className = "GPisochronModeLabel";
    span.innerHTML = "Mode de transport";
    div.appendChild(span);
    /* jshint -W083 */

    for (var i = 0; i < transports.length; i++) {
      var transport = transports[i];

      if (transport === "Voiture") {
        var inputCar = document.createElement("input");
        inputCar.id = this._addUID("GPisochronTransportCar");
        inputCar.type = "radio";
        inputCar.name = "GPisochronTransport";

        if (i === 0) {
          inputCar.checked = true;
        } // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire


        if (inputCar.addEventListener) {
          inputCar.addEventListener("change", function (e) {
            context.onIsoModeTransportChange(e);
          });
        } else if (inputCar.attachEvent) {
          inputCar.attachEvent("onchange", function (e) {
            context.onIsoModeTransportChange(e);
          });
        } // info : internet explorer support


        inputCar.value = "Voiture";
        div.appendChild(inputCar);
        var labelCar = document.createElement("label");
        labelCar.className = "GPisochronTransportImg";
        labelCar.htmlFor = this._addUID("GPisochronTransportCar");
        labelCar.title = "Voiture";
        div.appendChild(labelCar);
      }

      if (transport === "Pieton") {
        var inputPedestrian = document.createElement("input");
        inputPedestrian.id = this._addUID("GPisochronTransportPedestrian");
        inputPedestrian.type = "radio";
        inputPedestrian.name = "GPisochronTransport";

        if (i === 0) {
          inputPedestrian.checked = true;
        } // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire


        if (inputPedestrian.addEventListener) {
          inputPedestrian.addEventListener("change", function (e) {
            context.onIsoModeTransportChange(e);
          });
        } else if (inputPedestrian.attachEvent) {
          inputPedestrian.attachEvent("onchange", function (e) {
            context.onIsoModeTransportChange(e);
          });
        } // info : internet explorer support


        inputPedestrian.value = "Pieton";
        div.appendChild(inputPedestrian);
        var labelPedestrian = document.createElement("label");
        labelPedestrian.className = "GPisochronTransportImg";
        labelPedestrian.htmlFor = this._addUID("GPisochronTransportPedestrian");
        labelPedestrian.title = "Piéton";
        div.appendChild(labelPedestrian);
      }
    }

    return div;
  },

  /**
   * Create Mode choice direction
   * see event!
   *
   * @param {Array} directions - directions to display in list ("Departure", "Arrival"). First element will be selected by default
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormModeChoiceDirectionElement: function _createIsoPanelFormModeChoiceDirectionElement(directions) {
    // contexte d'execution
    var self = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronDirectionChoice");
    var span = document.createElement("span");
    span.className = "GPisochronModeLabel";
    span.innerHTML = "Sens de parcours";
    div.appendChild(span);
    var select = document.createElement("select");
    select.id = this._addUID("GPisochronDirectionSelect");
    select.className = "GPinputSelect"; // gestionnaire d'evenement :
    // on stocke la valeur du mode de calcul,
    // utilisation pour la requête sur le service de calcul d'iso

    select.addEventListener("change", function (e) {
      self.onIsoModeDirectionChange(e);
    });

    for (var i = 0; i < directions.length; i++) {
      var direction = directions[i];

      if (direction.toLowerCase() === "departure") {
        var departureOption = document.createElement("option");

        if (i === 0) {
          departureOption.selected = "selected";
        }

        departureOption.value = "departure";
        departureOption.text = "Départ";
        select.appendChild(departureOption);
      }

      if (direction.toLowerCase() === "arrival") {
        var arrivalOption = document.createElement("option");

        if (i === 0) {
          arrivalOption.selected = "selected";
        }

        arrivalOption.value = "arrival";
        arrivalOption.text = "Arrivée";
        select.appendChild(arrivalOption);
      }
    }

    div.appendChild(select);
    return div;
  },
  // ################################################################### //
  // ################# Methods to the choice exclusions ################ //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing Exclusions Options
   *
   * @returns {DOMElement} DOM element
   */
  _createShowIsoExclusionsElement: function _createShowIsoExclusionsElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowIsoExclusions");
    input.type = "checkbox";
    return input;
  },

  /**
   * Label to Exclusions Options
   *
   * @returns {DOMElement} DOM element
   */
  _createShowIsoExclusionsPictoElement: function _createShowIsoExclusionsPictoElement() {
    var label = document.createElement("label");
    label.id = this._addUID("GPshowIsoExclusionsPicto");
    label.className = "GPshowMoreOptionsImage GPshowMoreOptions GPshowIsoExclusionsPicto";
    label.htmlFor = this._addUID("GPshowIsoExclusions");
    label.title = "Exclusions";
    label.style.top = "240px";
    return label;
  },

  /**
   * Create Container to Exclusions
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormExclusionsElement: function _createIsoPanelFormExclusionsElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisoExclusions");
    var span = document.createElement("span");
    span.className = "GPisoExclusionsLabel";
    span.innerHTML = "Passages autorisés";
    div.appendChild(span); // div.appendChild(this._createIsoPanelFormExclusionOptionsElement());

    return div;
  },

  /**
   * Create Exclusions Options
   * see event !
   * FIXME event not useful
   * @param {Array} exclusions - exclusions to display in list
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormExclusionOptionsElement: function _createIsoPanelFormExclusionOptionsElement(exclusions) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.className = "GPisoExclusionsOptions";
    /* jshint -W083 */

    for (var value in exclusions) {
      if (exclusions.hasOwnProperty(value)) {
        var status = exclusions[value];

        switch (value) {
          case "toll":
            var inputToll = document.createElement("input");
            inputToll.id = this._addUID("GPisoExclusionsToll");
            inputToll.type = "checkbox";
            inputToll.checked = !status; // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire

            if (inputToll.addEventListener) {
              inputToll.addEventListener("change", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputToll.attachEvent) {
              inputToll.attachEvent("onchange", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } // info : internet explorer support


            inputToll.value = "Toll";
            div.appendChild(inputToll);
            var labelToll = document.createElement("label");
            labelToll.className = "GPisoExclusionsOption";
            labelToll.htmlFor = this._addUID("GPisoExclusionsToll");
            labelToll.innerHTML = "Péages";
            div.appendChild(labelToll);
            break;

          case "tunnel":
            var inputTunnel = document.createElement("input");
            inputTunnel.id = this._addUID("GPisoExclusionsTunnel");
            inputTunnel.type = "checkbox";
            inputTunnel.checked = !status; // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire

            if (inputTunnel.addEventListener) {
              inputTunnel.addEventListener("change", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputTunnel.attachEvent) {
              inputTunnel.attachEvent("onchange", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } // info : internet explorer support


            inputTunnel.value = "Tunnel";
            div.appendChild(inputTunnel);
            var labelTunnel = document.createElement("label");
            labelTunnel.className = "GPisoExclusionsOption";
            labelTunnel.htmlFor = this._addUID("GPisoExclusionsTunnel");
            labelTunnel.innerHTML = "Tunnels";
            div.appendChild(labelTunnel);
            break;

          case "bridge":
            var inputBridge = document.createElement("input");
            inputBridge.id = this._addUID("GPisoExclusionsBridge");
            inputBridge.type = "checkbox";
            inputBridge.checked = !status; // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire

            if (inputBridge.addEventListener) {
              inputBridge.addEventListener("change", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputBridge.attachEvent) {
              inputBridge.attachEvent("onchange", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } // info : internet explorer support


            inputBridge.value = "Bridge";
            div.appendChild(inputBridge);
            var labelBridge = document.createElement("label");
            labelBridge.className = "GPisoExclusionsOption";
            labelBridge.htmlFor = this._addUID("GPisoExclusionsBridge");
            labelBridge.innerHTML = "Ponts";
            div.appendChild(labelBridge);
            break;
        }
      }
    }

    return div;
  },
  // ################################################################### //
  // ############################### Submit Form ####################### //
  // ################################################################### //

  /**
   * Create Submit Form Element
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoSubmitFormElement: function _createIsoSubmitFormElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronSubmit");
    input.className = "GPinputSubmit";
    input.type = "submit";
    input.value = "Calculer";
    return input;
  },
  // ################################################################### //
  // ############################### Reset picto ####################### //
  // ################################################################### //

  /**
   * Create Reset Picto Element
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoFormResetElement: function _createIsoFormResetElement() {
    var self = this;
    var divReset = document.createElement("div");
    divReset.id = this._addUID("GPisochronReset");
    divReset.title = "Réinitialiser les paramètres";
    divReset.addEventListener("click", function (e) {
      self.onIsoResetClick(e);
    });
    return divReset;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (IsoDOM);

/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_ReverseGeocoding_GPreverseGeocodingOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _CSS_Controls_ReverseGeocoding_GPreverseGeocodingOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ReverseGeocoding_GPreverseGeocodingOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(195);
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Collection__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(209);
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_Feature__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(197);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_geom__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(48);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(199);
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_events_condition__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(180);
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(178);
/* harmony import */ var _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(185);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(179);
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(169);
/* harmony import */ var _Common_Controls_ReverseGeocodingDOM__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(210);
// import CSS
 // import OpenLayers











 // import geoportal library access

 // import local







 // import local with ol dependencies

 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_14__["default"].getLogger("reversegeocoding");
/**
 * @classdesc
 *
 * ReverseGeocode Control.
 *
 * @constructor
 * @alias ol.control.ReverseGeocode
 * @extends {ol.control.Control}
 * @param {Object} options - ReverseGeocode control options
 * @param {String}   [options.apiKey] - API key for services call (reverse geocode service), mandatory if autoconf service has not been charged in advance
 * @param {String}   [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Object}   [options.resources =  ["StreetAddress", "PositionOfInterest", "CadastralParcel"]] - resources for geocoding, by default : ["StreetAddress", "PositionOfInterest", "CadastralParcel"]. Possible values are : "StreetAddress", "PositionOfInterest", "CadastralParcel", "Administratif". Resources will be displayed in the same order in widget list.
 * @param {Object}   [options.delimitations = ["Point", "Circle", "Extent"]] - delimitations for reverse geocoding, by default : ["Point", "Circle", "Extent"]. Possible values are : "Point", "Circle", "Extent". Delimitations will be displayed in the same order in widget list.
 * @param {Object}  [options.reverseGeocodeOptions = {}] - reverse geocode service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~reverseGeocode Gp.Services.reverseGeocode()} to know all reverse geocode options.
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Saisie (recherche inverse)"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Couche de saisie d'une zone de recherche pour la recherche inverse"] - Layer description to be displayed in LayerSwitcher
 * @fires reversegeocode:compute
 * @example
 *  var iso = ol.control.ReverseGeocode({
 *      "collapsed" : false,
 *      "draggable" : true,
 *      "resources" : ["StreetAddress", "PositionOfInterest"],
 *      "delimitations" : ["Point", "Circle"],
 *      "reverseGeocodeOptions" : {}
 *  });
 */

var ReverseGeocode = function (Control) {
  function ReverseGeocode(options) {
    options = options || {};

    if (!(this instanceof ReverseGeocode)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // initialisation du composant


    this.initialize(options); // Widget main DOM container

    this._container = this._initContainer();
    this._containerElement = null; // on peut éventuellement encapsuler le composant dans une div passée par l'utilisateur

    if (options.element && options.element.appendChild) {
      // dans ce cas on stocke les deux container
      options.element.appendChild(this._container);
      this._containerElement = options.element;
    } // call ol.control.Control constructor


    Control.call(this, {
      element: this._containerElement || this._container,
      target: options.target,
      render: options.render
    });
  }

  ; // Inherits from ol.control.Control

  if (Control) ReverseGeocode.__proto__ = Control;
  /**
   * @lends module:ReverseGeocode
   */

  ReverseGeocode.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune ReverseGeocodingDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_13__["default"].assign(ReverseGeocode.prototype, _Common_Controls_ReverseGeocodingDOM__WEBPACK_IMPORTED_MODULE_21__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  ReverseGeocode.prototype.constructor = ReverseGeocode; // ################################################################### //
  // ############## public methods (getters, setters) ################## //
  // ################################################################### //

  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */

  ReverseGeocode.prototype.getCollapsed = function () {
    return this.collapsed;
  };
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */


  ReverseGeocode.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.log("[ERROR] ReverseGeocode:setCollapsed - missing collapsed parameter");
      return;
    }

    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }

    if (collapsed) {
      document.getElementById("GPreverseGeocodingPanelClose-" + this._uid).click();
    } else {
      document.getElementById("GPshowReverseGeocoding-" + this._uid).click();
    }

    this.collapsed = collapsed;
  };
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */


  ReverseGeocode.prototype.setMap = function (map) {
    if (map) {
      // lors de l'ajout à la map, on active la saisie du point ou de la zone de recherche sur la carte,
      // mais seulement si le widget est ouvert
      this._activateMapInteraction(map); // mode "draggable"


      if (this.draggable) {
        _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_18__["default"].dragElement(this._panelContainer, this._panelHeaderContainer, map.getTargetElement());
      }
    } else {
      var _map = this.getMap(); // on remet à zéro = on efface les géométries + interactions + valeurs stockées
      // suppression des résultats précédents


      this._clearResults(); // on efface les points qui ont pu être saisis précédemment


      this._clearInputFeatures(); // on supprime l'éventuelle précédente interaction


      this._removeMapInteraction(_map); // on retire aussi la couche de saisie de la zone de recherche à la fermeture du widget


      if (this._inputFeaturesLayer != null) {
        _map.removeLayer(this._inputFeaturesLayer);

        this._inputFeaturesLayer = null;
        this._inputFeaturesSources = null;
        this._inputFeatures = null;
      }
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Get locations data
   *
   * @returns {Object} data - locations
   */


  ReverseGeocode.prototype.getData = function () {
    return this._reverseGeocodingLocations;
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize ReverseGeocode control (called by ReverseGeocode constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */


  ReverseGeocode.prototype.initialize = function (options) {
    // ############################################################ //
    // ################### Options du composant ################### //
    // check input options format (resources and delimitations arrays)
    this._checkInputOptions(options); // set default options


    this.options = {
      collapsed: true,
      draggable: false,
      resources: ["StreetAddress", "PositionOfInterest", "CadastralParcel"],
      delimitations: ["Point", "Circle", "Extent"],
      reverseGeocodeOptions: {},
      layerDescription: {
        title: "Saisie (recherche inverse)",
        description: "Couche de saisie d'une zone de recherche pour la recherche inverse"
      }
    }; // merge with user options

    _Common_Utils__WEBPACK_IMPORTED_MODULE_13__["default"].assign(this.options, options);
    /** {Boolean} specify if reverseGeocoding control is collapsed (true) or not (false) */

    this.collapsed = this.options.collapsed;
    /** {Boolean} specify if reverseGeocoding control is draggable (true) or not (false) */

    this.draggable = this.options.draggable; // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_15__["default"].generate(); // #################################################################### //
    // ################### informations sur les droits #################### //
    // ressources des services d'autocompletion et de geocodage

    this._servicesRightManagement = {}; // gestion des droits sur les ressources

    this._noRightManagement = false; // gestion des droits sur les ressources/services

    this._checkRightsManagement(); // #################################################################### //
    // ################### informations sur les droits #################### //
    // Type de géocodage sélectionné (StreetAddress, PositionOfInterest, ...)


    this._currentGeocodingType = null;

    this._initGeocodingType(); // Type de délimitation à utiliser pour la requête + pour sélection sur la containerDistance


    this._currentGeocodingDelimitation = null;

    this._initGeocodingDelimitation(); // ################################################################## //
    // ################### Elements principaux du DOM ################### //
    // containers principaux


    this._showReverseGeocodingInput = null; // panel

    this._panelContainer = null;
    this._panelHeaderContainer = null;
    this._panelTitleContainer = null;
    this._returnPictoContainer = null; // form

    this._formContainer = null; // results

    this._resultsContainer = null;
    this._resultsListContainer = null; // waiting

    this._waitingContainer = null; // ###################################################################### //
    // ################### informations des points saisis ################### //
    // collection des points saisis sur la carte

    this._inputFeatures = null; // source contenant les features ci-dessus

    this._inputFeaturesSource = null; // couche vectorielle dans laquelle seront saisis les points (features ci-dessus)

    this._inputFeaturesLayer = null; // interaction avec la carte (de type "Point", "Circle" ou "Polygon")

    this._mapInteraction = null; // #################################################################### //
    // ################### informations pour la requête ################### //
    // options pour la requête de géocodage inverse

    this._requestOptions = null; // position du géocodage inverse qui sera envoyée dans la requête

    this._requestPosition = null; // eventuels filtres géométriques saisis par l'utilisateur : cercle ou bbox

    this._requestCircleFilter = null;
    this._requestBboxFilter = null; // pour savoir si un calcul est en cours ou non

    this._waiting = false; // timer pour cacher la patience après un certain temps

    this._timer = null; // #################################################################### //
    // #################### informations des résultats #################### //

    this._reverseGeocodingLocations = [];
    this._reverseGeocodingLocationsMarkers = [];
    this._resultsDefaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_5__["Style"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Icon"]({
        src: _Utils_Markers__WEBPACK_IMPORTED_MODULE_17__["default"]["lightOrange"],
        anchor: [0.5, 1]
      })
    });
    this._resultsSelectedStyle = new ol_style__WEBPACK_IMPORTED_MODULE_5__["Style"]({
      image: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Icon"]({
        src: _Utils_Markers__WEBPACK_IMPORTED_MODULE_17__["default"]["red"],
        anchor: [0.5, 1]
      })
    });
    this._resultsHoverInteraction = null;
    this._resultsSelectInteraction = null; // container de la popup (affichage des infos au clic sur les markers)

    this._popupContent = null;
    this._popupDiv = this._initPopupDiv();
    this._popupOverlay = null;
  };
  /**
   * this method is called by this.initialize()
   * and makes sure input options are correctly formated
   *
   * @param {Object} options - options
   *
   * @private
   */


  ReverseGeocode.prototype._checkInputOptions = function (options) {
    var i;
    var j; // on vérifie le tableau des resources

    if (options.resources) {
      var resources = options.resources; // on vérifie que la liste des ressources de geocodage est bien un tableau

      if (Array.isArray(resources)) {
        var resourcesList = ["StreetAddress", "PositionOfInterest", "CadastralParcel", "Administratif"];
        var wrongResourcesIndexes = [];

        for (i = 0; i < resources.length; i++) {
          if (resourcesList.indexOf(resources[i]) === -1) {
            // si la resource n'est pas référencée, on stocke son index pour la retirer du tableau (après avoir terminé de parcourir le tableau)
            wrongResourcesIndexes.push(i);
            logger.log("[ReverseGeocode] options.resources : " + resources[i] + " is not a resource for reverse geocode");
          }
        } // on retire les ressoures non référencées qu'on a pu rencontrer


        if (wrongResourcesIndexes.length !== 0) {
          for (j = 0; j < wrongResourcesIndexes.length; j++) {
            resources.splice(wrongResourcesIndexes[j], 1);
          }
        }
      } else {
        logger.log("[ReverseGeocode] 'options.resources' parameter should be an array");
        resources = null;
      }
    } // et le tableau des délimitations


    if (options.delimitations) {
      var delimitations = options.delimitations; // on vérifie que la liste des delimitations est bien un tableau

      if (Array.isArray(delimitations)) {
        var delimitationsList = ["Circle", "Point", "Extent"];
        var wrongDelimitationsIndexes = [];

        for (i = 0; i < delimitations.length; i++) {
          if (delimitationsList.indexOf(delimitations[i]) === -1) {
            // si la delimitations n'est pas référencée, on stocke son index pour la retirer du tableau (après avoir terminé de parcourir le tableau)
            wrongDelimitationsIndexes.push(i);
            logger.log("[ReverseGeocode] options.delimitations : " + delimitations[i] + " is not a delimitation for reverse geocode");
          }
        } // on retire les ressoures non référencées qu'on a pu rencontrer


        if (wrongDelimitationsIndexes.length !== 0) {
          for (j = 0; j < wrongDelimitationsIndexes.length; j++) {
            delimitations.splice(wrongDelimitationsIndexes[j], 1);
          }
        }
      } else {
        logger.log("[ReverseGeocode] 'options.delimitations' parameter should be an array");
        delimitations = null;
      }
    }
  };
  /**
   * this method is called by this.initialize() and initialize geocoding type (=resource)
   * ("StreetAddress", "PositionOfInterest", "CadastralParcel", "Administratif")
   *
   * @private
   */


  ReverseGeocode.prototype._initGeocodingType = function () {
    // Type de géocodage selectionné
    this._currentGeocodingType = "StreetAddress"; // par defaut
    // par defaut

    var resources = this.options.resources;

    if (!resources || resources.length === 0) {
      this.options.resources = ["StreetAddress", "PositionOfInterest", "CadastralParcel"];
    } // pas de droit ou pas d'autoconf chargée,
    // ce n'est pas la peine de tester les droits !


    if (this._noRightManagement) {
      return;
    } // options utilisateur


    if (Array.isArray(resources) && resources.length) {
      // vérification des droits
      var noRightsIndexes = [];

      for (var i = 0; i < resources.length; i++) {
        if (this._servicesRightManagement["Geocode"].indexOf(resources[i]) < 0) {
          // si on n'a pas les droits sur la ressource, on va la supprimer : on stocke son index
          noRightsIndexes.push(i);
          logger.log("[ReverseGeocode] no rights for options.resources : " + resources[i]);
        }
      } // on retire les ressoures non autorisées qu'on a pu rencontrer


      if (noRightsIndexes.length !== 0) {
        for (var j = 0; j < noRightsIndexes.length; j++) {
          resources.splice(noRightsIndexes[j], 1);
        }
      } // récupération du type par défaut


      if (resources[0] === "StreetAddress" || resources[0] === "PositionOfInterest" || resources[0] === "CadastralParcel" || resources[0] === "Administratif") {
        this._currentGeocodingType = resources[0];
      }
    } // si l'utilisateur a spécifié au moins une ressource dans le service, on surcharge les options du widget


    var serviceOptions = this.options.reverseGeocodeOptions;

    if (serviceOptions.filterOptions && Array.isArray(serviceOptions.filterOptions.type) && serviceOptions.filterOptions.type.length !== 0) {
      this._currentGeocodingType = serviceOptions.filterOptions.type[0];
    }
  };
  /**
   * this method is called by this.initialize() and initialize geocoding delimitation
   * ("Point", "Circle", "Extent")
   *
   * @private
   */


  ReverseGeocode.prototype._initGeocodingDelimitation = function () {
    // Type de délimitation selectionné
    this._currentGeocodingDelimitation = "Point"; // par defaut
    // par defaut

    var delimitations = this.options.delimitations;

    if (!delimitations || delimitations.length === 0) {
      this.options.delimitations = ["Point", "Circle", "Extent"];
    } // options utilisateur


    if (Array.isArray(delimitations) && delimitations.length) {
      var d = delimitations[0].toLowerCase();

      if (d === "point" || d === "circle" || d === "extent") {
        this._currentGeocodingDelimitation = delimitations[0];
      }
    }
  };
  /**
   * this method is called by this.initialize() and initialize popup div
   * (to display results information on marker click)
   *
   * @return {Object} element - DOM element for popup
   * @private
   */


  ReverseGeocode.prototype._initPopupDiv = function () {
    var context = this;
    var element = document.createElement("div");
    element.className = "gp-feature-info-div";
    var closer = document.createElement("input");
    closer.type = "button";
    closer.className = "gp-styling-button closer"; // on closer click : remove popup

    closer.onclick = function () {
      if (context._popupOverlay != null) {
        context._popupOverlay.setPosition(undefined);
      }

      return false;
    };

    this._popupContent = document.createElement("div");
    this._popupContent.className = "gp-features-content-div";
    element.appendChild(this._popupContent);
    element.appendChild(closer);
    return element;
  };
  /**
   * Check rights to resources (called by this.initialize())
   *
   * @private
   */


  ReverseGeocode.prototype._checkRightsManagement = function () {
    var _resources = [];

    var _key;

    var _opts = null; // les ressources du service de geocodage

    _key = this.options.reverseGeocodeOptions.apiKey;
    _opts = this.options.reverseGeocodeOptions.filterOptions; // on récupère les éventuelles ressources passées en option, soit dans reverseGeocodeOptions :

    _resources = _opts ? _opts.type : []; // soit directement dans options.resources.geocode :

    if (!_resources || _resources.length === 0) {
      _resources = this.options.resources;
    } // ou celles par défaut sinon.


    if (!_resources || _resources.length === 0) {
      _resources = ["StreetAddress", "PositionOfInterest"];
    }

    var rightManagementGeocode = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_16__["default"].check({
      key: _key || this.options.apiKey,
      resources: _resources,
      services: ["Geocode"]
    });
    logger.log("rightManagementGeocode", rightManagementGeocode); // aucun droit !

    if (!rightManagementGeocode) {
      this._noRightManagement = true;
      return;
    } // on recupère les informations utiles
    // Ex. la clef API issue de l'autoconfiguration si elle n'a pas
    // été renseignée.


    if (!this.options.apiKey) {
      this.options.apiKey = rightManagementGeocode.key;
    }

    this._servicesRightManagement["Geocode"] = rightManagementGeocode["Geocode"];
  };
  /**
   * Create control main container (DOM initialize)
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  ReverseGeocode.prototype._initContainer = function () {
    // create main container
    var container = this._createMainContainerElement(); // create show ReverseGeocode element


    var inputShow = this._showReverseGeocodingInput = this._createShowReverseGeocodingElement();

    container.appendChild(inputShow); // mode "collapsed"

    if (!this.collapsed) {
      inputShow.checked = true;
    } // create ReverseGeocode picto


    var picto = this._createShowReverseGeocodingPictoElement();

    container.appendChild(picto); // panel

    var reverseGeocodingPanel = this._panelContainer = this._createReverseGeocodingPanelElement(); // header


    var panelHeader = this._panelHeaderContainer = this._createReverseGeocodingPanelHeaderElement(); // return picto (hidden at start)


    var returnPicto = this._returnPictoContainer = this._createReverseGeocodingPanelReturnPictoElement();

    panelHeader.appendChild(returnPicto); // pane title

    var panelTitle = this._panelTitleContainer = this._createReverseGeocodingPanelTitleElement();

    panelHeader.appendChild(panelTitle); // close picto

    var closeDiv = this._createReverseGeocodingPanelCloseElement();

    panelHeader.appendChild(closeDiv);
    reverseGeocodingPanel.appendChild(panelHeader); // form

    var reverseGeocodingForm = this._formContainer = this._createReverseGeocodingPanelFormElement(); // choices element


    reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingTypeElement(this.options.resources));
    reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingDelimitationElement(this.options.delimitations)); // submit (bouton "Chercher")

    var submit = this._createReverseGeocodingSubmitFormElement();

    reverseGeocodingForm.appendChild(submit);
    reverseGeocodingPanel.appendChild(reverseGeocodingForm); // waiting

    var waiting = this._waitingContainer = this._createReverseGeocodingWaitingElement();

    reverseGeocodingPanel.appendChild(waiting); // results (dans le panel)

    var resultsPanel = this._resultsContainer = this._createReverseGeocodingResultsPanelElement();

    var reverseGeocodingResultsList = this._resultsListContainer = this._createReverseGeocodingResultsListElement();

    resultsPanel.appendChild(reverseGeocodingResultsList);
    reverseGeocodingPanel.appendChild(resultsPanel);
    container.appendChild(reverseGeocodingPanel);
    logger.log(container);
    return container;
  }; // ################################################################### //
  // ################### Map interactions management ################### //
  // ################################################################### //

  /**
   * this method is called by this.setMap,
   * or by this.onShowReverseGeocodingClick,
   * and calls method corresponding to current delimitation, if widget is not collapsed.
   *
   * @param {ol.Map} map - control map.
   * @private
   */


  ReverseGeocode.prototype._activateMapInteraction = function (map) {
    var _this = this;

    if (!this.collapsed) {
      // 1. Creation de la couche vectorielle sur laquelle on va dessiner
      if (this._inputFeaturesLayer == null) {
        // on crée une collection, qui accueillera les points saisis sur la carte par les interactions,
        // sous formes de features (dans une couche vectorielle).
        // on les stocke de sorte à pouvoir les supprimer facilement
        this._inputFeatures = new ol_Collection__WEBPACK_IMPORTED_MODULE_3___default.a(); // on crée la couche qui va accueillir les features

        this._inputFeaturesSource = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_11___default.a({
          features: this._inputFeatures
        });
        this._inputFeaturesLayer = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_10___default.a({
          source: this._inputFeaturesSource,
          style: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Style"]({
            fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Fill"]({
              color: "rgba(0, 183, 152, 0.3)"
            }),
            stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Stroke"]({
              color: "rgba(0, 183, 152, 0.8)",
              width: 3
            }),
            image: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Icon"]({
              src: _Utils_Markers__WEBPACK_IMPORTED_MODULE_17__["default"]["turquoiseBlue"],
              anchor: [0.5, 1]
            })
          })
        }); // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)

        this._inputFeaturesLayer.gpResultLayerId = "reverseGeocoding"; // on ajoute la couche à la carte

        map.addLayer(this._inputFeaturesLayer);
      } // 2. Création de l'interaction de dessin, selon le type de délimitation sélectionné


      var delimitation = this._currentGeocodingDelimitation.toLowerCase();

      switch (delimitation) {
        case "point":
          this._activatePointInteraction(map);

          break;

        case "circle":
          this._activateCircleInteraction(map);

          break;

        case "extent":
          this._activateBoxInteraction(map);

          break;

        default:
          break;
      } // 3. Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche


      map.getControls().forEach(function (control) {
        if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_20__["default"]) {
          // un layer switcher est présent dans la carte
          var layerId = _this._inputFeaturesLayer.gpLayerId; // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)

          if (control._layers[layerId].title === layerId) {
            control.addLayer(_this._inputFeaturesLayer, {
              title: _this.options.layerDescription.title,
              description: _this.options.layerDescription.description
            });
            control.setRemovable(_this._inputFeaturesLayer, false);
          }
        }
      });
    }
  };
  /**
   * this method is called by this._activateMapInteraction,
   * and creates map point drawing interaction.
   *
   * @param {ol.Map} map - control map.
   * @private
   */


  ReverseGeocode.prototype._activatePointInteraction = function (map) {
    var _this2 = this;

    // interaction permettant de dessiner un point
    this._mapInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_7__["Draw"]({
      style: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Style"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Circle"]({
          radius: 0,
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Fill"]({
            color: "rgba(0, 183, 152, 0.8)"
          })
        })
      }),
      type: "Point",
      source: this._inputFeaturesSource
    });

    this._mapInteraction.on("drawstart", function (e) {
      logger.log("on drawstart ", e); // on efface les points qui ont pu être saisis précédemment (on vide la collection des features de la couche)

      _this2._inputFeatures.clear(); // on récupère les coordonnées du point qui vient d'être saisi


      _this2._onDrawStart(e, "point");
    });

    map.addInteraction(this._mapInteraction);

    this._setCursor("crosshair", map);
  };
  /**
   * this method is called by this._activateMapInteraction,
   * and creates map circle drawing interaction.
   *
   * @param {ol.Map} map - control map.
   * @private
   */


  ReverseGeocode.prototype._activateCircleInteraction = function (map) {
    var _this3 = this;

    // interaction permettant de dessiner un cercle
    this._mapInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_7__["Draw"]({
      style: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Style"]({
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Fill"]({
          color: "rgba(0, 183, 152, 0.3)"
        }),
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Stroke"]({
          color: "rgba(0, 183, 152, 0.8)",
          width: 3
        }),
        image: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Circle"]({
          radius: 4,
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Fill"]({
            color: "rgba(0, 183, 152, 0.8)"
          })
        })
      }),
      type: "Circle",
      source: this._inputFeaturesSource
    });

    this._mapInteraction.on("drawstart", function (e) {
      logger.log("on drawstart ", e); // on efface les points qui ont pu être saisis précédemment (on vide la collection des features de la couche)

      _this3._inputFeatures.clear(); // on récupère les coordonnées du centre du cercle = premier point du tracé


      _this3._onDrawStart(e, "circle");
    });

    this._mapInteraction.on("drawend", function (e) {
      logger.log("on drawend", e); // on récupère le rayon du cercle qui vient d'être tracé

      if (e.feature && e.feature.getGeometry) {
        var radius = e.feature.getGeometry().getRadius(); // et on le stocke comme filtre pour la requête

        _this3._requestCircleFilter = {};
        _this3._requestCircleFilter.radius = radius;

        if (_this3._requestPosition) {
          _this3._requestCircleFilter.x = _this3._requestPosition.x;
          _this3._requestCircleFilter.y = _this3._requestPosition.y;
        }

        logger.log("circle radius : ", radius);
      }
    });

    map.addInteraction(this._mapInteraction);
  };
  /**
   * this method is called by this._activateMapInteraction,
   * and creates map box drawing interaction.
   *
   * @param {ol.Map} map - control map.
   * @private
   */


  ReverseGeocode.prototype._activateBoxInteraction = function (map) {
    var _this4 = this;

    // info : il n'y a pas de geometry de type rectangle, donc on va créer un objet de type "LineString",
    // avec seulement 2 points qui formeront les extrémités du rectangle.
    // on aura donc une géométrie LineString avec 5 coordonnées : start, point2, end, point4, start,
    // où les coordonnées de point2 et point4 sont calculées à partir de start et end, et start est répété à la fin pour fermer la géométrie.
    // function to draw rectangle with only 2 points
    var geometryFunction = function geometryFunction(coordinates, geometry) {
      if (!geometry) {
        geometry = new ol_geom__WEBPACK_IMPORTED_MODULE_6__["Polygon"]([]);
      }

      var start = coordinates[0];
      var end = coordinates[1]; // on crée les 5 coordonnées de la ligne à partir des 2 points saisis.

      geometry.setCoordinates([[start, [start[0], end[1]], end, [end[0], start[1]], start]]);
      return geometry;
    }; // interaction permettant de dessiner un rectangle (= LineString de 5 points, à partir de 2 points saisis)


    this._mapInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_7__["Draw"]({
      style: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Style"]({
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Fill"]({
          color: "rgba(0, 183, 152, 0.3)"
        }),
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Stroke"]({
          color: "rgba(0, 183, 152, 0.8)",
          width: 3
        }),
        image: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Circle"]({
          radius: 4,
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__["Fill"]({
            color: "rgba(0, 183, 152, 0.8)"
          })
        })
      }),
      type: "LineString",
      source: this._inputFeaturesSource,
      maxPoints: 2,
      geometryFunction: geometryFunction
    });

    this._mapInteraction.on("drawstart", function (e) {
      logger.log("on drawstart", e); // on efface les points qui ont pu être saisis précédemment (on vide la collection des features de la couche)

      _this4._inputFeatures.clear();
    });

    this._mapInteraction.on("drawend", function (e) {
      logger.log("on drawend", e); // on va récupérer les coordonnées du rectangle qui vient d'être tracé

      _this4._onBoxDrawEnd(e);
    });

    map.addInteraction(this._mapInteraction);
  };
  /**
   * remove draw interaction from map (if exists)
   *
   * @param {ol.Map} map - control map.
   * @private
   */


  ReverseGeocode.prototype._removeMapInteraction = function (map) {
    if (this._mapInteraction != null) {
      map.removeInteraction(this._mapInteraction);
      this._mapInteraction = null;
    }

    this._setCursor();
  };
  /**
   * this method is called by event 'drawstart' on map point or circle drawing interaction
   * (cf. this._activatePointInteraction), and it gets map click coordinates.
   * this point is saved as a parameter for reverse Geocode service.
   *
   * @param {Object} e - HTMLElement
   * @param {String} type - geometry type : "point" or "circle"
   * @private
   */


  ReverseGeocode.prototype._onDrawStart = function (e, type) {
    var coordinate;

    if (e.feature && e.feature.getGeometry) {
      var geometry = e.feature.getGeometry();

      if (type === "point") {
        coordinate = geometry.getCoordinates();
      }

      if (type === "circle") {
        coordinate = geometry.getCenter();
      }
    }

    if (!coordinate) {
      return;
    }

    var crs;

    if (this.options.reverseGeocodeOptions && this.options.reverseGeocodeOptions.srs) {
      crs = this.options.reverseGeocodeOptions.srs;
    } else {
      var map = this.getMap();

      if (!map || !map.getView()) {
        return;
      }

      crs = map.getView().getProjection();
    }

    var geoCoordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_9__["transform"])(coordinate, crs, "EPSG:4326");
    this._requestPosition = {
      x: geoCoordinate[0],
      y: geoCoordinate[1]
    };
    logger.log("position coordinates : ", this._requestPosition);
  };
  /**
   * this method is called by event 'drawend' on map box drawing interaction
   * (cf. this._activateBoxInteraction), and it gets geometry coordinates,
   * to be saved as a filter parameter for reverse Geocode service.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  ReverseGeocode.prototype._onBoxDrawEnd = function (e) {
    // on va récupérer les coordonnées du rectangle qui vient d'être tracé
    if (e.feature && e.feature.getGeometry) {
      // info: coordinates est un tableau [start, point2, end, point4, start]
      // car c'est une linestring donc on a 5 coordonnées pour boucler
      var coordinates = e.feature.getGeometry().getCoordinates()[0];
      var start = coordinates[0];
      var end = coordinates[2];
      var crs;

      if (this.options.reverseGeocodeOptions && this.options.reverseGeocodeOptions.srs) {
        crs = this.options.reverseGeocodeOptions.srs;
      } else {
        var map = this.getMap();

        if (!map || !map.getView()) {
          return;
        }

        crs = map.getView().getProjection();
      } // on reprojette les coordonnées des deux extrémités du rectangle (start et end)


      var startGeoCoordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_9__["transform"])(start, crs, "EPSG:4326");
      var endGeoCoordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_9__["transform"])(end, crs, "EPSG:4326");
      this._requestPosition = {};
      this._requestBboxFilter = {}; // on récupère les valeurs left, right, top et bottom, pour le filtre bbox du service reverseGeocode

      if (startGeoCoordinate[0] < endGeoCoordinate[0]) {
        this._requestBboxFilter.left = startGeoCoordinate[0];
        this._requestBboxFilter.right = endGeoCoordinate[0];
      } else {
        this._requestBboxFilter.left = endGeoCoordinate[0];
        this._requestBboxFilter.right = startGeoCoordinate[0];
      }

      if (startGeoCoordinate[1] < endGeoCoordinate[1]) {
        this._requestBboxFilter.bottom = startGeoCoordinate[1];
        this._requestBboxFilter.top = endGeoCoordinate[1];
      } else {
        this._requestBboxFilter.bottom = endGeoCoordinate[1];
        this._requestBboxFilter.top = startGeoCoordinate[1];
      } // ainsi que le centre du rectangle pour le paramètre "position" du service reverseGeocode


      this._requestPosition.x = (startGeoCoordinate[0] + endGeoCoordinate[0]) / 2;
      this._requestPosition.y = (startGeoCoordinate[1] + endGeoCoordinate[1]) / 2;
      logger.log("bbox filter : ", this._requestBboxFilter);
      logger.log("center coordinates : ", this._requestPosition);
    }
  };
  /**
   * this change the cursor of the map when entering a point.
   *
   * @param {String} cursor - cursor style
   * @param {ol.Map} map - control map (optional)
   * @private
   */


  ReverseGeocode.prototype._setCursor = function (cursor, map) {
    map = map || this.getMap();

    if (!map) {
      return;
    }

    var div = map.getTargetElement();

    if (cursor) {
      div.style.cursor = cursor;
    } else {
      div.style.cursor = null;
    }
  }; // ################################################################### //
  // ##################### Reverse Geocoding request ################### //
  // ################################################################### //

  /**
   * this methode is called by this.onReverseGeocodingSubmit method,
   * it generates and sends reverse geocode request, then displays results
   *
   * @private
   */


  ReverseGeocode.prototype._reverseGeocodingRequest = function () {
    var map = this.getMap(); // on construit les options pour la requête

    this._requestOptions = this._getReverseGeocodingRequestOptions(); // retrait de l'interaction sur la map pendant l'attente (et l'affichage des résultats)

    this._removeMapInteraction(map); // affichage d'une patience pendant l'attente


    this._displayWaitingContainer(); // envoi de la requête


    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_12__["default"].Services.reverseGeocode(this._requestOptions);
  };
  /**
   * this methode is called by this._reverseGeocodingRequest method,
   * and returns options object for Gp.Services.reverseGeocode request
   *
   * @returns {Object} requestOptions - reverse geocode options
   * @private
   */


  ReverseGeocode.prototype._getReverseGeocodingRequestOptions = function () {
    var map = this.getMap(); // on recupere les éventuelles options du service passées par l'utilisateur

    var reverseGeocodeOptions = this.options.reverseGeocodeOptions; // on crée les options pour le service reverseGeocode

    var context = this;

    if (typeof this.options.ssl !== "boolean") {
      this.options.ssl = true;
    } // gestion des callback


    var bOnFailure = !!(reverseGeocodeOptions.onFailure !== null && typeof reverseGeocodeOptions.onFailure === "function"); // cast variable to boolean

    var bOnSuccess = !!(reverseGeocodeOptions.onSuccess !== null && typeof reverseGeocodeOptions.onSuccess === "function");
    var requestOptions = {
      apiKey: reverseGeocodeOptions.apiKey || this.options.apiKey,
      ssl: this.options.ssl,
      position: this._requestPosition,
      filterOptions: {
        type: [this._currentGeocodingType]
      },
      srs: "CRS:84",
      returnFreeForm: false,
      maximumResponses: reverseGeocodeOptions.maximumResponses || 25,
      timeOut: reverseGeocodeOptions.timeOut || 30000,
      protocol: reverseGeocodeOptions.protocol || "XHR",
      // callback onSuccess
      onSuccess: function onSuccess(response) {
        if (response.locations) {
          logger.log("reverseGeocode results : ", response.locations);

          context._displayGeocodedLocations(response.locations);
        }

        if (bOnSuccess) {
          reverseGeocodeOptions.onSuccess.call(context, response.locations);
        }
      },
      // callback onFailure
      onFailure: function onFailure(error) {
        // FIXME mise à jour du controle mais le service ne repond pas en 200 !?
        // on cache la patience
        context._hideWaitingContainer(); // suppression d'éventuels résultats précédents


        context._clearResults(); // on efface les points qui ont été saisis précédemment


        context._clearInputFeatures(); // et on réactive l'interaction sur la map


        context._activateMapInteraction(map);

        logger.log(error.message);

        if (bOnFailure) {
          reverseGeocodeOptions.onFailure.call(context, error);
        }
      }
    }; // on récupère d'éventuels filtres

    if (this._currentGeocodingDelimitation.toLowerCase() === "circle" && this._requestCircleFilter) {
      // FIXME : a confirmer !
      if (this._requestCircleFilter.radius > 1000) {
        logger.log("INFO : initial circle radius (" + this._requestCircleFilter.radius + ") limited to 1000m.");
        this._requestCircleFilter.radius = 1000;
      }

      requestOptions.filterOptions.circle = this._requestCircleFilter;
    }

    if (this._currentGeocodingDelimitation.toLowerCase() === "extent" && this._requestBboxFilter) {
      requestOptions.filterOptions.bbox = this._requestBboxFilter;
    }

    logger.log("reverseGeocode request options : ", requestOptions);
    return requestOptions;
  };
  /**
   * this method is called by this._reverseGeocodingRequest() (in case of reverse geocode success)
   * and display results : in both container list and map
   *
   * @param {Array} locations - array of geocoded locations (reverse geocode results)
   * @private
   */


  ReverseGeocode.prototype._displayGeocodedLocations = function (locations) {
    // 1. on vide les résultats précédents
    this._clearResults();

    this._reverseGeocodingLocations = locations;
    /**
     * event triggered when the compute is finished
     *
     * @event reversegeocode:compute
     * @property {Object} type - event
     * @property {Object} target - instance ReverseGeocode
     * @example
     * ReverseGeocode.on("reversegeocode:compute", function (e) {
     *   console.log(e.target.getData());
     * })
     */

    this.dispatchEvent({
      type: "reversegeocode:compute"
    }); // 2. cache de la patience et du formulaire

    this._formContainer.className = "GPreverseGeocodingComponentHidden";

    this._hideWaitingContainer(); // affichage de la div des résultats (et changement du titre)


    this._panelTitleContainer.innerHTML = "Résultats de la recherche";
    this._returnPictoContainer.className = "";
    this._resultsContainer.className = "GPpanel"; // 3. ajout de la liste des résultats dans le container des resultats

    this._fillGeocodedLocationListContainer(locations); // 4. affichage des résultats sur la carte (+ zoom ?)


    this._displayGeocodedLocationsOnMap(locations);
  }; // ################################################################### //
  // ############################# results list ######################## //
  // ################################################################### //

  /**
   * this method is called by this._displayGeocodedLocations()
   * and fills the container with results list
   *
   * @param {Array} locations - array of geocoded locations (reverse geocode results)
   * @private
   */


  ReverseGeocode.prototype._fillGeocodedLocationListContainer = function (locations) {
    //  ajout de la liste des résultats dans le container des resultats
    for (var i = 0; i < locations.length; i++) {
      var location = locations[i];
      logger.log(location); // on récupère la description à afficher dans la liste

      var locationDescription = this._fillGeocodedLocationDescription(location); // on ajoute chaque résutat à la liste


      if (locationDescription.length !== 0) {
        this._createReverseGeocodingResultElement(locationDescription, i);
      }
    }
  };
  /**
   * this method is called by this._fillGeocodedLocationListContainer()
   * and fills location description (String), depending on matchType
   *
   * @param {Object} location - geocoded location (from reverse geocode results)
   * @returns {String} locationDescription - geocoded location description to be displayed
   * @private
   */


  ReverseGeocode.prototype._fillGeocodedLocationDescription = function (location) {
    if (!location || !location.placeAttributes) {
      return;
    }

    var attr = location.placeAttributes;
    var locationDescription = ""; // on sélectionne les infos à afficher selon le type

    switch (location.type) {
      case "StreetAddress":
        if (attr.street) {
          locationDescription += attr.number ? attr.number + " " : "";
          locationDescription += attr.street + ", ";
        }

        locationDescription += attr.postalCode + " " + attr.commune;
        break;

      case "PositionOfInterest":
        if (location.matchType === "City" && attr.commune) {
          locationDescription += attr.commune;
          locationDescription += attr.postalCode ? ", " + attr.postalCode : "";
        } else if (location.matchType === "Département" && attr.municipality) {
          locationDescription += attr.municipality;
          locationDescription += attr.postalCode ? ", " + attr.postalCode : "";
        } else if (location.matchType === "Toponym" && attr.municipality) {
          locationDescription += attr.municipality;
          locationDescription += attr.postalCode ? ", " + attr.postalCode : "";
          locationDescription += attr.commune ? " " + attr.commune : "";
        } else {
          locationDescription += attr.municipality ? attr.municipality : "";
        }

        locationDescription += attr.nature ? " (" + attr.nature + ") " : "";
        break;

      case "CadastralParcel":
        locationDescription += attr.cadastralParcel ? attr.cadastralParcel : "";
        locationDescription += attr.municipality ? " (" + attr.municipality + ")" : "";
        break;

      case "Administratif":
        locationDescription += attr.municipality ? attr.municipality : "";

        if (attr.inseeDepartment) {
          locationDescription += "(Département)";
        } else if (attr.inseeRegion) {
          locationDescription += "(Région)";
        }

        break;

      default:
        locationDescription += attr.municipality ? attr.municipality : "";
        break;
    }

    ;
    return locationDescription;
  }; // ################################################################### //
  // ######################## map results (markers) #################### //
  // ################################################################### //

  /**
   * this method is called by this._displayGeocodedLocations()
   * and display locations in map (markers)
   *
   * @param {Object} locations - geocoded locations (reverse geocode result)
   * @private
   */


  ReverseGeocode.prototype._displayGeocodedLocationsOnMap = function (locations) {
    var _this5 = this;

    if (this._reverseGeocodingLocations.length !== 0) {
      var map = this.getMap(); // 1. création de la couche où seront ajoutés les résultats

      this._createResultsLayer(); // ajout de chaque résultat à la couche (marker)


      for (var i = 0; i < locations.length; i++) {
        this._addResultFeature(locations[i], i);
      } // 2. Zoom sur l'étendue des résultats (features)


      if (this._resultsFeatures.getLength() > 1) {
        if (this._resultsFeaturesSource && this._resultsFeaturesSource.getExtent) {
          var extent = this._resultsFeaturesSource.getExtent();

          map.getView().fit(extent, map.getSize());
        }
      } else {
        // dans le cas où on n'a qu'un seul résultat, l'étendue n'est pas définie, on zoome donc sur le résulat
        var feature = this._resultsFeatures.item(0);

        var coords = feature.getGeometry().getCoordinates();
        map.getView().setCenter(coords);
        map.getView().setZoom(17);
      } // 3. ajout des interactions (survol, click)
      // au survol : modification des styles (marker et list)


      this._resultsHoverInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_7__["Select"]({
        condition: ol_events_condition__WEBPACK_IMPORTED_MODULE_8__["pointerMove"],
        layers: [this._resultsFeaturesLayer]
      });

      this._resultsHoverInteraction.on("select", function (e) {
        return _this5._onResultsFeatureMouseOver(e);
      });

      map.addInteraction(this._resultsHoverInteraction); // au click : affichage popup

      this._resultsSelectInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_7__["Select"]({
        layers: [this._resultsFeaturesLayer]
      });

      this._resultsSelectInteraction.on("select", function (e) {
        return _this5._onResultsFeatureSelect(e);
      });

      map.addInteraction(this._resultsSelectInteraction); // 4. Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche

      var geocodeType = "";

      switch (this._currentGeocodingType) {
        case "StreetAddress":
          geocodeType = "adresses";
          break;

        case "PositionOfInterest":
          geocodeType = "toponymes";
          break;

        case "CadastralParcel":
          geocodeType = "parcelles cadastrales";
          break;

        case "Administratif":
          geocodeType = "unités administratives";
          break;

        default:
          break;
      }

      map.getControls().forEach(function (control) {
        if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_20__["default"]) {
          // un layer switcher est présent dans la carte
          var layerId = _this5._resultsFeaturesLayer.gpLayerId; // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)

          if (control._layers[layerId].title === layerId) {
            control.addLayer(_this5._resultsFeaturesLayer, {
              title: "Résultats de la recherche inverse",
              description: "Résultats de la recherche inverse sur les " + geocodeType
            });
            control.setRemovable(_this5._resultsFeaturesLayer, false);
          }
        }
      });
    }
  };
  /**
   * this method is called by this._displayGeocodedLocations()
   * and creates result layer (where geocoded locations will be displayed)
   *
   * @private
   */


  ReverseGeocode.prototype._createResultsLayer = function () {
    var map = this.getMap();
    this._resultsFeatures = new ol_Collection__WEBPACK_IMPORTED_MODULE_3___default.a(); // on crée la couche qui va accueillir les features

    this._resultsFeaturesSource = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_11___default.a({
      features: this._resultsFeatures
    });
    this._resultsFeaturesLayer = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_10___default.a({
      source: this._resultsFeaturesSource
    }); // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)

    this._resultsFeaturesLayer.gpResultLayerId = "reverseGeocodingResults"; // on ajoute la couche à la carte

    map.addLayer(this._resultsFeaturesLayer);
  };
  /**
   * this method is called by this._displayGeocodedLocations()
   * and displays locations in map (markers) : add new feature to results layer
   *
   * @param {Object} location - geocoded location (reverse geocode result)
   * @param {Number} i - geocoded location index in response list
   * @private
   */


  ReverseGeocode.prototype._addResultFeature = function (location, i) {
    var map = this.getMap(); // récupération de la position

    var position = [location.position.x, location.position.y];

    if (position.length === 0) {
      return;
    }

    var view = map.getView();
    var mapProj = view.getProjection().getCode();

    if (mapProj !== "EPSG:4326") {
      // on retransforme les coordonnées de la position dans la projection de la carte
      position = Object(ol_proj__WEBPACK_IMPORTED_MODULE_9__["transform"])(position, "EPSG:4326", mapProj);
    } // on ajoute le résultat à la collection de points existantes (composant la couche vectorielle this._inputFeaturesLayer)


    var feature = new ol_Feature__WEBPACK_IMPORTED_MODULE_4___default.a({
      geometry: new ol_geom__WEBPACK_IMPORTED_MODULE_6__["Point"](position)
    });
    feature.setStyle(this._resultsDefaultStyle);
    feature.setId(i);
    feature.setProperties({
      popupContent: this._fillPopupContent(location)
    });

    this._resultsFeatures.push(feature);
  };
  /**
   * this method is called by this._addResultFeature()
   * and fills popup content (to be displayed on marker click) for a given geocoded location
   *
   * @param {Object} location - geocoded location (reverse geocode result)
   * @returns {String} popupContent - text to be displayed in popup
   * @private
   */


  ReverseGeocode.prototype._fillPopupContent = function (location) {
    var popupContent = "<ul>";
    var attributes = location.placeAttributes;

    for (var attr in attributes) {
      if (attributes.hasOwnProperty(attr)) {
        if (attr !== "bbox") {
          popupContent += "<li>";
          popupContent += "<span class=\"gp-attname-others-span\">" + attr.toUpperCase() + " : </span>";
          popupContent += attributes[attr];
          popupContent += " </li>";
        }
      }
    }

    popupContent += " </ul>";
    return popupContent;
  };
  /**
   * this method is called on 'pointerMove' on this._resultsFeaturesLayer (ol.interaction.Select)
   * (cf. this._displayGeocodedLocationsOnMap() )
   * and highlights result in list container
   *
   * @param {Object} e - on select event
   * @private
   */


  ReverseGeocode.prototype._onResultsFeatureMouseOver = function (e) {
    var f; // si on survole un résultat, on change son style (marker)

    if (e.selected.length !== 0) {
      // on change le style du marker (red)
      f = e.selected[0];
      f.setStyle(this._resultsSelectedStyle); // on surligne le résultat correspondant dans la liste des résultats

      if (f.getId() != null) {
        var selectedResultDiv = document.getElementById("ReverseGeocodedLocation_" + f.getId() + "-" + this._uid);

        if (selectedResultDiv && selectedResultDiv.classList) {
          selectedResultDiv.classList.add("GPreverseGeocodedLocationHighlight");
        }
      }

      document.getElementById("ReverseGeocodedLocation_" + f.getId() + "-" + this._uid);
    } // si on déselectionne un résultat (mouseout), on rétablit un style normal pour le marker


    if (e.deselected.length !== 0) {
      // on change le style du marker (lightOrange)
      f = e.deselected[0];
      f.setStyle(this._resultsDefaultStyle); // on rétablit un style normal pour le résultat correspondant dans la liste des résultats

      var deSelectedResultDiv = document.getElementById("ReverseGeocodedLocation_" + f.getId() + "-" + this._uid);

      if (deSelectedResultDiv && deSelectedResultDiv.classList) {
        deSelectedResultDiv.classList.remove("GPreverseGeocodedLocationHighlight");
      }
    }
  };
  /**
   * this method is called on 'click' on this._resultsFeaturesLayer (ol.interaction.Select)
   * (cf. this._displayGeocodedLocationsOnMap() )
   * and sets a popup with feature information
   *
   * @param {Object} e - on select event
   * @private
   */


  ReverseGeocode.prototype._onResultsFeatureSelect = function (e) {
    var map = this.getMap();

    if (e.selected.length !== 0) {
      // si on a sélectionné un marker, on lui ajoute une popup
      var f = e.selected[0];
      this._popupContent.innerHTML = f.getProperties().popupContent;

      if (!this._popupOverlay) {
        // ajout de la popup a la carte comme un overlay
        this._popupOverlay = new ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default.a({
          element: this._popupDiv,
          positioning: "bottom-center",
          position: e.mapBrowserEvent.coordinate
        });
        map.addOverlay(this._popupOverlay);
      } else {
        // si l'overlay est déjà créé, on modifie juste sa position
        this._popupOverlay.setPosition(e.mapBrowserEvent.coordinate);
      }
    } else {
      // si aucun troncon n'est sélectionné (click à côté du tracé),
      // on fait disparaitre la popup si elle existe
      if (this._popupOverlay != null) {
        this._popupOverlay.setPosition(undefined);
      }
    }
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on 'GPshowReverseGeocodingPicto' tag label
   * (cf. ReverseGeocodingDOM._createShowReverseGeocodingPictoElement), and it cleans the component
   * when it's closed.
   *
   * @private
   */


  ReverseGeocode.prototype.onShowReverseGeocodingClick = function () {
    var map = this.getMap(); // on supprime toutes les interactions

    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_19__["default"].unset(map);
    this.collapsed = this._showReverseGeocodingInput.checked; // info : on génère nous même l'evenement OpenLayers de changement de propriété
    // (utiliser ol.control.ReverseGeocode.on("change:collapsed", function ) pour s'abonner à cet évènement)

    this.dispatchEvent("change:collapsed");

    if (!this._waiting && !this._reverseGeocodingLocations.length) {
      // Cas 1 : input panel (ni en attente, ni sur le panel des résultats)
      if (this.collapsed) {
        // on remet à zéro = on efface les géométries + interactions + valeurs stockées
        // suppression des résultats précédents
        this._clearResults(); // on efface les points qui ont pu être saisis précédemment


        this._clearInputFeatures(); // on supprime l'éventuelle précédente interaction


        this._removeMapInteraction(map); // on retire aussi la couche de saisie de la zone de recherche à la fermeture du widget


        if (this._inputFeaturesLayer != null) {
          map.removeLayer(this._inputFeaturesLayer);
          this._inputFeaturesLayer = null;
          this._inputFeaturesSources = null;
          this._inputFeatures = null;
        }
      } else {
        // on réactive l'interaction
        this._activateMapInteraction(map);
      }
    } // info : si on est en attente ou sur le panel des résultats : on ne fait rien.

  };
  /**
   * this method is called by event 'change' on 'GPreverseGeocodingCode' tag select
   * (cf. ReverseGeocodingDOM._createReverseGeocodingFormModeChoiceGeocodingTypeElement).
   * this value is saved as a parameter for reverseGeocode service.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  ReverseGeocode.prototype.onReverseGeocodingTypeChange = function (e) {
    var idx = e.target.selectedIndex;
    var value = e.target.options[idx].value;

    if (!value) {
      return;
    }

    logger.log(value);
    this._currentGeocodingType = value;
  };
  /**
   * this method is called by event 'change' on 'GPreverseGeocodingCode' tag select
   * (cf. ReverseGeocodingDOM._createReverseGeocodingFormModeChoiceGeocodingDelimitationElement).
   * this value is saved as a parameter for reverseGeocode service.
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  ReverseGeocode.prototype.onReverseGeocodingDelimitationChange = function (e) {
    var idx = e.target.selectedIndex;
    var value = e.target.options[idx].value;

    if (!value) {
      return;
    }

    logger.log(value);
    this._currentGeocodingDelimitation = value; // on met à jour l'interaction de la map en fonction de la nouvelle délimitation

    var map = this.getMap(); // on supprime l'interaction précédente, ainsi que les géométries et valeurs stockées (filtres, position)

    this._clearInputFeatures(); // on supprime l'éventuelle précédente interaction


    this._removeMapInteraction(map); // on crée une nouvelle interaction


    this._activateMapInteraction(map);
  };
  /**
   * this method is called by event 'click' on 'GPreverseGeocodingReturnPicto' div
   * (cf. ReverseGeocodingDOM._createReverseGeocodingPanelReturnPictoElement),
   * and clear geocoded location (from both list container and map)
   *
   * @private
   */


  ReverseGeocode.prototype.onGPreverseGeocodingReturnPictoClick = function () {
    // suppression des résultats précédents
    this._clearResults(); // on efface les points qui ont pu être saisis précédemment


    this._clearInputFeatures(); // et on réactive l'interaction sur la map


    this._activateMapInteraction(this.getMap());
  };
  /**
   * this methode is called by event 'submit' on reverseGeocoding form ('GPreverseGeocodingForm')
   * (cf. ReverseGeocodingDOM._createReverseGeocodingPanelFormElement),
   * it checks reverse geocode mandatory parameters,
   * then call this._reverseGeocodingRequest() to generate and send request
   *
   * @private
   */


  ReverseGeocode.prototype.onReverseGeocodingSubmit = function () {
    // le paramètre position est obligatoire
    if (!this._requestPosition) {
      logger.log("missing position");
      return;
    } // si on n'a trouvé aucun droit, on evite une requête inutile ...


    if (this._noRightManagement) {
      return;
    }

    this._reverseGeocodingRequest();
  };
  /**
   * this method is called by event 'click' on 'ReverseGeocodedLocation_' div
   * (cf. ReverseGeocodingDOM._createReverseGeocodingResultElement),
   * and zoom to location ?
   * TODO
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  ReverseGeocode.prototype.onReverseGeocodingResultClick = function (e) {
    logger.log("onReverseGeocodingResultClick", e);
  };
  /**
   * this method is called by event 'mouseover' on 'ReverseGeocodedLocation_' div
   * (cf. ReverseGeocodingDOM._createReverseGeocodingResultElement),
   * and changes style of matching marker on map (selected)
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  ReverseGeocode.prototype.onReverseGeocodingResultMouseOver = function (e) {
    // récupération de l'id du résultat survolé
    var tagid = e.target.id; // ex ReverseGeocodedLocation_21

    var idx = tagid.substring(tagid.indexOf("_") + 1); // ex. 21
    // on passe le texte en gras

    if (e.target.classList) {
      e.target.classList.add("GPreverseGeocodedLocationHighlight");
    }

    if (!this._resultsFeaturesSource) {
      return;
    } // on récupère l'entité correspondante au résultat survolé


    var f = this._resultsFeaturesSource.getFeatureById(parseInt(idx, 10)); // et on lui affecte un nouveau style


    f.setStyle(this._resultsSelectedStyle);
  };
  /**
   * this method is called by event 'mouseout' on 'ReverseGeocodedLocation_' div
   * (cf. ReverseGeocodingDOM._createReverseGeocodingResultElement),
   * and changes style of matching marker on map (default)
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  ReverseGeocode.prototype.onReverseGeocodingResultMouseOut = function (e) {
    // récupération de l'id du résultat survolé
    var tagid = e.target.id; // ex GProuteResultsDetailsInstruction_125

    var idx = tagid.substring(tagid.indexOf("_") + 1); // ex. 125
    // on repasse le texte en style normal

    if (e.target.classList) {
      e.target.classList.remove("GPreverseGeocodedLocationHighlight");
    }

    if (!this._resultsFeaturesSource) {
      return;
    } // on récupère l'entité correspondante au résultat qui était survolé


    var f = this._resultsFeaturesSource.getFeatureById(parseInt(idx, 10)); // et on lui réaffecte un style normal


    f.setStyle(this._resultsDefaultStyle);
  }; // ################################################################### //
  // ################################ clean ############################ //
  // ################################################################### //

  /**
   * this method clears previous location results
   *
   * @private
   */


  ReverseGeocode.prototype._clearResults = function () {
    var map = this.getMap();
    this._reverseGeocodingLocations = []; // on vide le container avec la liste des résultats

    if (this._resultsListContainer) {
      while (this._resultsListContainer.firstChild) {
        this._resultsListContainer.removeChild(this._resultsListContainer.firstChild);
      }
    } // on retire la couche des résultats


    if (this._resultsFeaturesLayer) {
      map.removeLayer(this._resultsFeaturesLayer);
      this._resultsFeaturesLayer = null;
    } // on retire l'overlay de la popup de la carte


    if (this._popupOverlay != null) {
      map.removeOverlay(this._popupOverlay);
      this._popupOverlay = null;
    } // on retire les interactions sur les markers (select et mouseover)


    if (this._resultsSelectInteraction != null) {
      map.removeInteraction(this._resultsSelectInteraction);
      this._resultsSelectInteraction = null;
    }

    if (this._resultsHoverInteraction != null) {
      map.removeInteraction(this._resultsHoverInteraction);
      this._resultsHoverInteraction = null;
    }
  };
  /**
   * this method clears previous input features (features, layer, position and filters)
   *
   * @private
   */


  ReverseGeocode.prototype._clearInputFeatures = function () {
    // on efface les points qui ont pu être saisis précédemment (on vide la collection des features de la couche)
    if (this._inputFeatures) {
      this._inputFeatures.clear();
    } // on supprime les valeurs stockées (filtres, position)


    this._requestPosition = null;
    this._requestCircleFilter = null;
    this._requestBboxFilter = null;
  };
  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */


  ReverseGeocode.prototype._displayWaitingContainer = function () {
    this._waitingContainer.className = "GProuteCalcWaitingContainerVisible";
    this._waiting = true; // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)
    // si on est toujours en attente (si la requête est bloquée par exemple)

    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }

    var context = this;
    this._timer = setTimeout(function () {
      if (context._waiting === true) {
        context._hideWaitingContainer();
      } else {
        if (context._timer) {
          clearTimeout(context._timer);
        }
      }
    }, 16000);
  };
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */


  ReverseGeocode.prototype._hideWaitingContainer = function () {
    if (this._waiting) {
      this._waitingContainer.className = "GProuteCalcWaitingContainerHidden";
      this._waiting = false;
      clearTimeout(this._timer);
      this._timer = null;
    }
  };

  return ReverseGeocode;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocode); // Expose ReverseGeocode as ol.control.ReverseGeocode (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.ReverseGeocode = ReverseGeocode;
}

/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = ol.Feature;

/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var ReverseGeocodingDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPreverseGeocoding");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowReverseGeocodingElement: function _createShowReverseGeocodingElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowReverseGeocoding");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show ReverseGeocoding
   *
   * @returns {DOMElement} DOM element
   */
  _createShowReverseGeocodingPictoElement: function _createShowReverseGeocodingPictoElement() {
    // contexte d'execution
    var self = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowReverseGeocodingPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowReverseGeocoding");
    label.title = "Ouvrir la recherche inverse"; // Close all results and panels when minimizing the widget

    if (label.addEventListener) {
      label.addEventListener("click", function () {
        self.onShowReverseGeocodingClick();
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function () {
        self.onShowReverseGeocodingClick();
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowReverseGeocodingOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },

  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingWaitingElement: function _createReverseGeocodingWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPreverseGeocodingCalcWaitingContainer");
    div.className = "GPreverseGeocodingCalcWaitingContainerHidden";
    var p = document.createElement("p");
    p.className = "GPreverseGeocodingCalcWaiting";
    p.innerHTML = "Recherche en cours...";
    div.appendChild(p);
    return div;
  },

  /**
   * Reverse geocoding results panel element.
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingResultsPanelElement: function _createReverseGeocodingResultsPanelElement() {
    var resultsPanelDiv = document.createElement("div");
    resultsPanelDiv.id = this._addUID("GPreverseGeocodingResultsPanel");
    resultsPanelDiv.className = "GPpanel GPreverseGeocodingComponentHidden";
    return resultsPanelDiv;
  },

  /**
   * Reverse geocoding results list.
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingResultsListElement: function _createReverseGeocodingResultsListElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPreverseGeocodingResultsList"); // Results are dynamically filled in Javascript by reverse geocoding service

    return container;
  },

  /**
   *  Add Result
   * (results dynamically generate !)
   *
   * @param {String} locationDescription - reverse geocoded location results
   * @param {Number} id - ID
   */
  _createReverseGeocodingResultElement: function _createReverseGeocodingResultElement(locationDescription, id) {
    // contexte
    var context = this;
    var container = document.getElementById(this._addUID("GPreverseGeocodingResultsList"));
    var div = document.createElement("div");
    div.id = this._addUID("ReverseGeocodedLocation_" + id);
    div.className = "GPautoCompleteProposal";
    div.innerHTML = locationDescription;
    div.title = locationDescription;

    if (div.addEventListener) {
      div.addEventListener("mouseover", function (e) {
        context.onReverseGeocodingResultMouseOver(e);
      });
      div.addEventListener("mouseout", function (e) {
        context.onReverseGeocodingResultMouseOut(e);
      });
      div.addEventListener("click", function (e) {
        if (typeof context.onReverseGeocodingResultClick === "function") {
          context.onReverseGeocodingResultClick(e);
        }
      });
    } else if (div.attachEvent) {
      div.attachEvent("onmouseover", function (e) {
        context.onReverseGeocodingResultMouseOver(e);
      });
      div.attachEvent("onmouseout", function (e) {
        context.onReverseGeocodingResultMouseOut(e);
      });
      div.attachEvent("onclick", function (e) {
        if (typeof context.onReverseGeocodingResultClick === "function") {
          context.onReverseGeocodingResultClick(e);
        }
      });
    }

    container.appendChild(div);
  },
  // ################################################################### //
  // ######################### Inputs panel ############################ //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingPanelElement: function _createReverseGeocodingPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPreverseGeocodingPanel");
    div.className = "GPpanel";
    return div;
  },

  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingPanelHeaderElement: function _createReverseGeocodingPanelHeaderElement() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader"; // info: on sépare les appels pour la création du picto de retour,
    // du titre et de la croix de fermeture pour les récupérer dans le composant

    return container;
  },

  /**
   * Create return picto in panel header
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingPanelReturnPictoElement: function _createReverseGeocodingPanelReturnPictoElement() {
    // contexte
    var self = this;
    var divNew = document.createElement("div");
    divNew.id = this._addUID("GPreverseGeocodingReturnPicto");
    divNew.title = "Nouvelle recherche";
    divNew.className = "GPreverseGeocodingReturnPictoHidden";

    if (divNew.addEventListener) {
      divNew.addEventListener("click", function (e) {
        document.getElementById(self._addUID("GPreverseGeocodingResultsPanel")).className = "GProuteComponentHidden";
        document.getElementById(self._addUID("GPreverseGeocodingForm")).className = "";
        document.getElementById(self._addUID("GPreverseGeocodingHeaderTitle")).innerHTML = "Recherche inverse";
        document.getElementById(self._addUID("GPreverseGeocodingReturnPicto")).className = "GPreverseGeocodingReturnPictoHidden";
        self.onGPreverseGeocodingReturnPictoClick(e);
      });
    } else if (divNew.attachEvent) {
      divNew.attachEvent("onclick", function (e) {
        document.getElementById(self._addUID("GPreverseGeocodingResultsPanel")).className = "GProuteComponentHidden";
        document.getElementById(self._addUID("GPreverseGeocodingForm")).className = "";
        document.getElementById(self._addUID("GPreverseGeocodingHeaderTitle")).innerHTML = "Recherche inverse";
        document.getElementById(self._addUID("GPreverseGeocodingReturnPicto")).className = "GPreverseGeocodingReturnPictoHidden";
        self.onGPreverseGeocodingReturnPictoClick(e);
      });
    }

    return divNew;
  },

  /**
   * Create Header Title Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingPanelTitleElement: function _createReverseGeocodingPanelTitleElement() {
    var div = document.createElement("div");
    div.className = "GPpanelTitle";
    div.id = this._addUID("GPreverseGeocodingHeaderTitle");
    div.innerHTML = "Recherche inverse";
    return div;
  },

  /**
   * Create Header close div
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingPanelCloseElement: function _createReverseGeocodingPanelCloseElement() {
    // contexte
    var self = this;
    var divClose = document.createElement("div");
    divClose.id = this._addUID("GPreverseGeocodingPanelClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer le panneau"; // Link panel close / visibility checkbox

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowReverseGeocodingPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowReverseGeocodingPicto")).click();
      });
    }

    return divClose;
  },

  /**
   * Create Form
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingPanelFormElement: function _createReverseGeocodingPanelFormElement() {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPreverseGeocodingForm");

    if (form.addEventListener) {
      form.addEventListener("submit", function (e) {
        e.preventDefault();
        self.onReverseGeocodingSubmit();
      });
    } else if (form.attachEvent) {
      form.attachEvent("onsubmit", function (e) {
        e.preventDefault();
        self.onReverseGeocodingSubmit();
      });
    }

    return form;
  },
  // ################################################################### //
  // ####################### Choice mode into form ##################### //
  // ################################################################### //

  /**
   * Create Container to Mode choice geocoding type
   *
   * @param {Array} resources - geocoding resources to be displayed (and used)
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingFormModeChoiceGeocodingTypeElement: function _createReverseGeocodingFormModeChoiceGeocodingTypeElement(resources) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.className = "GPflexInput";
    var label = document.createElement("label");
    label.className = "GPreverseGeocodingCodeLabel";
    label.innerHTML = "Recherche par";
    label.title = "Recherche par";
    div.appendChild(label);
    var select = document.createElement("select");
    select.className = "GPreverseGeocodingCode"; // gestionnaire d'evenement : on stocke la valeur du type de geocodage,
    // utilisé dans la requête de géocodage inverse

    if (select.addEventListener) {
      select.addEventListener("change", function (e) {
        context.onReverseGeocodingTypeChange(e);
      });
    } else if (select.attachEvent) {
      select.attachEvent("onchange", function (e) {
        context.onReverseGeocodingTypeChange(e);
      });
    } // on prend soit les valeurs passées par l'utilisateur, soit des valeurs par défaut


    if (!resources || !Array.isArray(resources)) {
      resources = ["StreetAddress", "PositionOfInterest", "CadastralParcel"];
    }

    for (var i = 0; i < resources.length; i++) {
      switch (resources[i]) {
        case "PositionOfInterest":
          var POIOption = document.createElement("option");
          POIOption.value = "PositionOfInterest";
          POIOption.text = "Lieux/toponymes";
          select.appendChild(POIOption);
          break;

        case "StreetAddress":
          var SAOption = document.createElement("option");
          SAOption.value = "StreetAddress";
          SAOption.text = "Adresses";
          select.appendChild(SAOption);
          break;

        case "CadastralParcel":
          var CPOption = document.createElement("option");
          CPOption.value = "CadastralParcel";
          CPOption.text = "Parcelles cadastrales";
          select.appendChild(CPOption);
          break;

        case "Administratif":
          var adminOption = document.createElement("option");
          adminOption.value = "Administratif";
          adminOption.text = "Unités administratives";
          select.appendChild(adminOption);
          break;

        default:
          break;
      }
    }

    div.appendChild(select);
    return div;
  },

  /**
   * Create Container to Mode choice geocoding delimitation
   *
   * @param {Array} delimitations - geocoding delimitations to be displayed (and used)
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingFormModeChoiceGeocodingDelimitationElement: function _createReverseGeocodingFormModeChoiceGeocodingDelimitationElement(delimitations) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.className = "GPflexInput";
    var label = document.createElement("label");
    label.className = "GPreverseGeocodingCodeLabel";
    label.innerHTML = "Délimitation";
    label.title = "Délimitation";
    div.appendChild(label);
    var select = document.createElement("select");
    select.className = "GPreverseGeocodingCode"; // gestionnaire d'evenement : on stocke la valeur du type de délimitation,
    // et on modifie l'événement de pointage sur la carte en fonction

    if (select.addEventListener) {
      select.addEventListener("change", function (e) {
        context.onReverseGeocodingDelimitationChange(e);
      });
    } else if (select.attachEvent) {
      select.attachEvent("onchange", function (e) {
        context.onReverseGeocodingDelimitationChange(e);
      });
    } // on prend soit les valeurs passées par l'utilisateur, soit des valeurs par défaut


    if (!delimitations || !Array.isArray(delimitations)) {
      delimitations = ["Point", "Circle", "Extent"];
    }

    for (var i = 0; i < delimitations.length; i++) {
      switch (delimitations[i].toLowerCase()) {
        case "point":
          var pointOption = document.createElement("option");
          pointOption.value = "point";
          pointOption.text = "Pointer un lieu";
          select.appendChild(pointOption);
          break;

        case "circle":
          var circleOption = document.createElement("option");
          circleOption.value = "circle";
          circleOption.text = "Dessiner un cercle";
          select.appendChild(circleOption);
          break;

        case "extent":
          var extentOption = document.createElement("option");
          extentOption.value = "extent";
          extentOption.text = "Dessiner une emprise";
          select.appendChild(extentOption);
          break;

        default:
          break;
      }
    }

    div.appendChild(select);
    return div;
  },
  // ################################################################### //
  // ########################### Submit Form ########################### //
  // ################################################################### //

  /**
   * Create Submit Form Element
   *
   * @returns {DOMElement} DOM element
   */
  _createReverseGeocodingSubmitFormElement: function _createReverseGeocodingSubmitFormElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPreverseGeocodingSubmit");
    input.className = "GPinputSubmit";
    input.type = "submit";
    input.value = "Rechercher";
    return input;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (ReverseGeocodingDOM);

/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_LayerImport_GPimportOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _CSS_Controls_LayerImport_GPimportOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_LayerImport_GPimportOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(171);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(195);
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Collection__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(161);
/* harmony import */ var ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_tilegrid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(212);
/* harmony import */ var ol_tilegrid__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_tilegrid__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_format_MVT__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(213);
/* harmony import */ var ol_format_MVT__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_format_MVT__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(214);
/* harmony import */ var ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(215);
/* harmony import */ var ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(216);
/* harmony import */ var ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(167);
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(43);
/* harmony import */ var ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(45);
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(46);
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(217);
/* harmony import */ var ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(218);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(49);
/* harmony import */ var _Editor__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(263);
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(178);
/* harmony import */ var _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(185);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(179);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(142);
/* harmony import */ var _Common_Controls_LayerImportDOM__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(274);
/* harmony import */ var _Formats_KML__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(143);
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(156);
/* harmony import */ var _Formats_GPX__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(148);
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(169);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import OpenLayers



 // import RenderFeature from "ol/render/Feature"; // FIXME RenderFeature n'est pas dispo dans le bundle !?


 // FIXME olCreateXYZTileGrid !?













 // import olms : module ES6

 // import olms : bundle
// import olms from "ol-mapbox-style";
// import geoportal library access

 // import local









 // import local with ol dependencies





var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_26__["default"].getLogger("layerimport");
/**
 * @classdesc
 *
 * LayerImport Control. Allows users to add geographical data in standards formats from their own sources to the map.
 *
 * @constructor
 * @alias ol.control.LayerImport
 * @extends {ol.control.Control}
 * @param {Object} options - options for function call.
 * @param {Boolean} [options.collapsed = true] - Specify if LayerImport control should be collapsed at startup. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Array} [options.layerTypes = ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"]] - data types that could be imported : "KML", "GPX", "GeoJSON", "WMS", "WMTS" and "MAPBOX". Values will be displayed in the same order in widget list.
 * @param {Object} [options.webServicesOptions = {}] - Options to import WMS or WMTS layers
 * @param {String} [options.webServicesOptions.proxyUrl] - Proxy URL to avoid cross-domain problems. Mandatory to import WMS and WMTS layer.
 * @param {Array.<String>} [options.webServicesOptions.noProxyDomains] - Proxy will not be used for this list of domain names. Only use if you know what you're doing.
 * @param {Object} [options.vectorStyleOptions] - Options for imported vector layer styling (KML, GPX, GeoJSON)
 * @param {Object} [options.vectorStyleOptions.KML] - Options for KML layer styling
 * @param {Boolean} [options.vectorStyleOptions.KML.extractStyles = true] - Extract styles from the KML. Default is true.
 * @param {Boolean} [options.vectorStyleOptions.KML.showPointNames = true] - Show names as labels for KML placemarks which contain points. Default is true.
 * @param {Object} [options.vectorStyleOptions.KML.defaultStyle] - default style to be applied to KML imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.GPX] - Options for GPX layer styling
 * @param {Object} [options.vectorStyleOptions.GPX.defaultStyle] - default style to be applied to GPX imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.GeoJSON] - Options for GeoJSON layer styling
 * @param {Object} [options.vectorStyleOptions.GeoJSON.defaultStyle] - default style to be applied to GeoJSON imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.MapBox] - Options for MapBox layer styling
 * @param {Object} [options.vectorStyleOptions.MapBox.defaultStyle] - default style to be applied to MapBox imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.MapBox.tools] - options for style editor
 * @param {Boolean} [options.vectorStyleOptions.MapBox.tools.style] - display edit style menu for every layers. By default, no display.
 * @param {Boolean} [options.vectorStyleOptions.MapBox.tools.filter] - display edit filter menu for every layers By default, no display.
 * @example
 *  var LayerImport = new ol.control.LayerImport({
 *      "collapsed" : false,
 *      "draggable" : true,
 *      "layerTypes" : ["KML", "GPX"],
 *      "webServicesOptions" : {
 *          "proxyUrl" : "http://localhost/proxy/php/proxy.php?url=",
 *          "noProxyDomains" : []
 *      },
 *      "vectorStyleOptions" : {
 *          "KML" : {
 *              extractStyles : true,
 *              defaultStyle : new ol.style.Style({
 *                  image : new ol.style.Icon({
 *                       src : "data:image/png;base64....",
 *                       size : [51, 38],
 *                  }),
 *                  stroke : new ol.style.Stroke({
 *                       color : "#ffffff",
 *                       width : 7
 *                  }),
 *                  fill : new ol.style.Fill({
 *                       color : "rgba(255, 183, 152, 0.2)"
 *                  }),
 *                  text : new ol.style.Text({
 *                      font : "16px Sans",
 *                      textAlign : "left",
 *                      fill : new ol.style.Fill({
 *                          color : "rgba(255, 255, 255, 1)"
 *                      }),
 *                      stroke : new ol.style.Stroke({
 *                          color : "rgba(0, 0, 0, 1)",
 *                          width : 2
 *                      })
 *                  })
 *              })
 *          },
 *          "GPX" : {
 *              defaultStyle : new ol.style.Style({
 *                  image : new ol.style.Icon({
 *                       src : "path/to/my/icon.png",
 *                       size : [51, 38],
 *                  }),
 *                  stroke : new ol.style.Stroke({
 *                       color : "#ffffff",
 *                       width : 7
 *                  })
 *              })
 *          }
 *      }
 *  });
 */

var LayerImport = function (Control) {
  function LayerImport(options) {
    options = options || {};

    if (!(this instanceof LayerImport)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    this._initialize(options); // init control DOM container


    var container = this._container = this._initContainer(options); // call ol.control.Control constructor


    Control.call(this, {
      element: container,
      target: options.target,
      render: options.render
    });
  }

  ; // Inherits from ol.control.Control

  if (Control) LayerImport.__proto__ = Control;
  /**
   * Default styles applyied to KML, GPX and GeoJSON features.
   *
   * @private
   */

  LayerImport.DefaultStyles = {
    image: new ol_style__WEBPACK_IMPORTED_MODULE_18__["Icon"]({
      src: _Utils_Markers__WEBPACK_IMPORTED_MODULE_22__["default"]["lightOrange"],
      anchor: [25.5, 38],
      anchorOrigin: "top-left",
      anchorXUnits: "pixels",
      anchorYUnits: "pixels"
    }),
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_18__["Stroke"]({
      color: "rgba(0,42,80,0.8)",
      width: 4
    }),
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_18__["Fill"]({
      color: "rgba(0, 183, 152, 0.5)"
    }),
    text: new ol_style__WEBPACK_IMPORTED_MODULE_18__["Text"]({
      font: "16px Sans",
      textAlign: "left",
      fill: new ol_style__WEBPACK_IMPORTED_MODULE_18__["Fill"]({
        color: "rgba(255, 255, 255, 1)"
      }),
      stroke: new ol_style__WEBPACK_IMPORTED_MODULE_18__["Stroke"]({
        color: "rgba(0, 0, 0, 1)",
        width: 2
      })
    })
  };
  /**
   * @lends module:LayerImport
   */

  LayerImport.prototype = Object.create(Control.prototype, {}); // on récupère les méthodes de la classe commune LayerImportDOM

  _Common_Utils__WEBPACK_IMPORTED_MODULE_25__["default"].assign(LayerImport.prototype, _Common_Controls_LayerImportDOM__WEBPACK_IMPORTED_MODULE_29__["default"]);
  /**
   * Constructor (alias)
   *
   * @private
   */

  LayerImport.prototype.constructor = LayerImport; // ################################################################### //
  // ############## public methods (getters, setters) ################## //
  // ################################################################### //

  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */

  LayerImport.prototype.setMap = function (map) {
    // ajout de la patience pour le chargement des tuiles
    if (map) {
      // Animation au centre de la carte ?
      // var center = this._loadingContainer = this._createLoadingElement();
      // map.getViewport().appendChild(center);
      map.getLayers().on("remove", function (e) {
        // import de type layerimport:MapBox ?
        if (e.element.gpResultLayerId === "layerimport:MapBox") {
          // layer ayant le bon ID ?
          if (this._mapBoxLayerId && this._mapBoxLayerId === e.element.id) {
            // le panneau des résultats existe t il ?
            if (this._mapBoxPanel && this._mapBoxPanel.style.display) {
              this.cleanMapBoxResultsList();
              this._mapBoxPanel.style.display = "none";
              this._importPanel.style.display = "";
            }
          }
        }
      }, this); // mode "draggable"

      if (this.draggable) {
        _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__["default"].dragElement(this._importPanel, this._importPanelHeader, map.getTargetElement()); // panneau draggable pour les resultats ?

        _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__["default"].dragElement(this._getCapPanel, null, map.getTargetElement());
        _Common_Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__["default"].dragElement(this._mapBoxPanel, null, map.getTargetElement());
      }
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */


  LayerImport.prototype.getCollapsed = function () {
    return this.collapsed;
  };
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */


  LayerImport.prototype.setCollapsed = function (collapsed) {
    if (collapsed === undefined) {
      logger.error("[ERROR] LayerImport:setCollapsed - missing collapsed parameter");
      return;
    }

    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }

    if (collapsed) {
      document.getElementById("GPimportPanelClose-" + this._uid).click();
    } else {
      document.getElementById("GPshowImport-" + this._uid).click();
    }

    this.collapsed = collapsed;
  };
  /**
   * Returns content of a static import (KML, GPX or GeoJSON)
   *
   * @returns {String} contentStatic  - content static
   */


  LayerImport.prototype.getStaticImportContent = function () {
    return this.contentStatic;
  };
  /**
   * Returns content of a service import (GetCapabilities)
   *
   * @returns {String} contentService  - content service
   */


  LayerImport.prototype.getServiceImportContent = function () {
    return this.contentService;
  };
  /**
   * Returns layer name
   *
   * @returns {String} name - layer name
   */


  LayerImport.prototype.getName = function () {
    return this._name;
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize LayerImport control (called by LayerImport constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */


  LayerImport.prototype._initialize = function (options) {
    // ############################################################ //
    // ################### Options du composant ################### //
    // check input options format
    this._checkInputOptions(options); // set default options


    this.options = {
      collapsed: true,
      draggable: false,
      layerTypes: ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"],
      webServicesOptions: {},
      vectorStyleOptions: {
        KML: {
          extractStyles: true,
          showPointNames: true,
          defaultStyle: {}
        },
        GPX: {
          defaultStyle: {}
        },
        GeoJSON: {
          defaultStyle: {}
        },
        MapBox: {
          defaultStyle: {},
          // TODO
          tools: {
            filter: false,
            // TODO edition des filtres de styles
            style: false // TODO edition des styles

          }
        }
      }
    }; // TODO gestion du proxy
    // set extractStyles parameter

    if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.extractStyles) {
      this.options.vectorStyleOptions.KML.extractStyles = options.vectorStyleOptions.KML.extractStyles;
    } // TODO
    // set showPointNames parameter


    if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.showPointNames) {
      this.options.vectorStyleOptions.KML.showPointNames = options.vectorStyleOptions.KML.showPointNames;
    } // set vector layers default styles (KML, GPX, GeoJSON, MapBox)


    if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.defaultStyle) {
      // get from options if specified
      this.options.vectorStyleOptions.KML.defaultStyle = options.vectorStyleOptions.KML.defaultStyle;
    } else {
      // get from control default options otherwise
      this.options.vectorStyleOptions.KML.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
        image: LayerImport.DefaultStyles.image,
        stroke: LayerImport.DefaultStyles.stroke,
        fill: LayerImport.DefaultStyles.fill,
        text: LayerImport.DefaultStyles.text
      });
    }

    if (options.vectorStyleOptions && options.vectorStyleOptions.GPX && options.vectorStyleOptions.GPX.defaultStyle) {
      // get from options if specified
      this.options.vectorStyleOptions.GPX.defaultStyle = options.vectorStyleOptions.GPX.defaultStyle;
    } else {
      // get from control default options otherwise
      this.options.vectorStyleOptions.GPX.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
        image: LayerImport.DefaultStyles.image,
        stroke: LayerImport.DefaultStyles.stroke,
        fill: LayerImport.DefaultStyles.fill
      });
    }

    if (options.vectorStyleOptions && options.vectorStyleOptions.GeoJSON && options.vectorStyleOptions.GeoJSON.defaultStyle) {
      // get from options if specified
      this.options.vectorStyleOptions.GeoJSON.defaultStyle = options.vectorStyleOptions.GeoJSON.defaultStyle;
    } else {
      // get from control default options otherwise
      this.options.vectorStyleOptions.GeoJSON.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
        image: LayerImport.DefaultStyles.image,
        stroke: LayerImport.DefaultStyles.stroke,
        fill: LayerImport.DefaultStyles.fill
      });
    }

    if (options.vectorStyleOptions && options.vectorStyleOptions.MapBox && options.vectorStyleOptions.MapBox.defaultStyle) {
      // get from options if specified
      this.options.vectorStyleOptions.MapBox.defaultStyle = options.vectorStyleOptions.MapBox.defaultStyle;
    } else {
      // get from control default options otherwise
      this.options.vectorStyleOptions.MapBox.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
        image: LayerImport.DefaultStyles.image,
        stroke: LayerImport.DefaultStyles.stroke,
        fill: LayerImport.DefaultStyles.fill,
        text: LayerImport.DefaultStyles.text
      });
    } // merge layer types


    if (Array.isArray(options.layerTypes)) {
      var layerTypes = [];

      for (var i = 0; i < options.layerTypes.length; i++) {
        layerTypes.push(options.layerTypes[i]);
      }

      this.options.layerTypes = layerTypes;
    } // merge with user options


    _Common_Utils__WEBPACK_IMPORTED_MODULE_25__["default"].mergeParams(this.options, options);
    /** {Boolean} specify if LayerImport control is collapsed (true) or not (false) */

    this.collapsed = this.options.collapsed;
    /** {Boolean} specify if LayerImport control is draggable (true) or not (false) */

    this.draggable = this.options.draggable; // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_27__["default"].generate(); // si une requête est en cours ou non

    this._waiting = false; // timer pour cacher la patience après un certain temps

    this._timer = null; // initialisation des types d'import

    this._initImportTypes(); // initialisation des styles par défaut


    this._initDefaultStyles(); // ################################################################## //
    // ################### Elements principaux du DOM ################### //
    // containers principaux (FIXME : tous utiles ?)


    this._showImportInput = null;
    this._importPanel = null;
    this._importPanelHeader = null;
    this._formContainer = null;
    this._staticLocalImportInput = null;
    this._staticUrlImportInput = null;
    this._serviceUrlImportInput = null;
    this._getCapPanel = null;
    this._getCapResultsListContainer = null;
    this._mapBoxPanel = null;
    this._mapBoxResultsListContainer = null;
    this._waitingContainer = null;
    this._loadingContainer = null; // ################################################################## //
    // ################ Interrogation du GetCapabilities ################ //

    this._getCapRequestUrl = null;
    this._getCapResponseWMS = null;
    this._getCapResponseWMSLayers = [];
    this._getCapResponseWMTS = null;
    this._getCapResponseWMTSLayers = []; // ################################################################## //
    // ########################### MapBox ############################### //

    this.editor = null;
    this._mapBoxObj = null;
    this._mapBoxLayerId = null; // ################################################################## //
    // ########################### file or url ########################## //

    this.contentStatic = null;
    this._url = null;
    this._file = null;
    this._name = null;
  };
  /**
   * this method is called by this.initialize()
   * and makes sure input options are correctly formated
   *
   * @param {Object} options - control input options
   * @private
   */


  LayerImport.prototype._checkInputOptions = function (options) {
    // on vérifie le tableau des types
    if (options.layerTypes) {
      var layerTypes = options.layerTypes; // on vérifie que la liste des types est bien un tableau

      if (!Array.isArray(layerTypes)) {
        logger.warn("[ol.control.LayerImport] 'options.layerTypes' parameter should be an array. Set default values [\"KML\", \"GPX\", \"GeoJSON\", \"WMS\", \"WMTS\"]");
        options.layerTypes = ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"];
      } else {
        var typesList = ["KML", "GPX", "GEOJSON", "WMS", "WMTS", "WFS", "MAPBOX"];
        var wrongTypesIndexes = [];

        for (var i = 0; i < layerTypes.length; i++) {
          if (typeof layerTypes[i] !== "string") {
            // si l'élément du tableau n'est pas une chaine de caractères, on stocke l'index pour le retirer du tableau
            wrongTypesIndexes.push(i);
            logger.warn("[ol.control.LayerImport] 'options.layerTypes' elements should be of type string (" + layerTypes[i] + ")");
          } else {
            // on passe en majuscules pour comparer
            layerTypes[i] = layerTypes[i].toUpperCase();

            if (typesList.indexOf(layerTypes[i]) === -1) {
              // si le type n'est pas référencé, on stocke son index pour le retirer du tableau (après avoir terminé de parcourir le tableau)
              wrongTypesIndexes.push(i);
              logger.log("[ol.control.LayerImport] options.layerTypes : " + layerTypes[i] + " is not a supported type");
            } // cas spécial du GeoJSON qu'on ne laisse pas en majuscules


            if (layerTypes[i] === "GEOJSON") {
              layerTypes[i] = "GeoJSON";
            }

            if (layerTypes[i] === "MAPBOX") {
              layerTypes[i] = "MAPBOX";
            }
          }
        } // on retire les types non référencés qu'on a pu rencontrer


        if (wrongTypesIndexes.length !== 0) {
          for (var j = wrongTypesIndexes.length - 1; j >= 0; j--) {
            layerTypes.splice(wrongTypesIndexes[j], 1);
          }
        }
      }
    }
  };
  /**
   * this method is called by this.initialize()
   * and initializes default styles for vector layers (KML/GPX/GeoJSON)
   *
   * @private
   */


  LayerImport.prototype._initDefaultStyles = function () {
    var kmlDefaultStyles = this.options.vectorStyleOptions.KML.defaultStyle;
    this._defaultKMLStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
      image: kmlDefaultStyles.image,
      stroke: kmlDefaultStyles.stroke,
      fill: kmlDefaultStyles.fill,
      text: kmlDefaultStyles.text
    });
    var gpxDefaultStyles = this.options.vectorStyleOptions.GPX.defaultStyle;
    this._defaultGPXStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
      image: gpxDefaultStyles.image,
      stroke: gpxDefaultStyles.stroke,
      fill: gpxDefaultStyles.fill
    });
    var geoJSONDefaultStyles = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
    this._defaultGeoJSONStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
      image: geoJSONDefaultStyles.image,
      stroke: geoJSONDefaultStyles.stroke,
      fill: geoJSONDefaultStyles.fill
    });
    var MapBoxDefaultStyles = this.options.vectorStyleOptions.MapBox.defaultStyle;
    this._defaultMapBoxStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__["Style"]({
      image: MapBoxDefaultStyles.image,
      stroke: MapBoxDefaultStyles.stroke,
      fill: MapBoxDefaultStyles.fill,
      text: MapBoxDefaultStyles.text
    });
  };
  /**
   * this method is called by this.initialize()
   * and initializes import types parameter
   *
   * @private
   */


  LayerImport.prototype._initImportTypes = function () {
    this._currentImportType = this.options.layerTypes[0] || "KML";

    if (this._currentImportType === "KML" || this._currentImportType === "GPX" || this._currentImportType === "GeoJSON" || this._currentImportType === "MAPBOX") {
      this._isCurrentImportTypeStatic = true;
    } else if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
      this._isCurrentImportTypeStatic = false;
    }

    this._currentStaticImportType = "local";
  };
  /**
   * Create control main container (DOM initialize)
   *
   * @private
   * @returns {DOMElement} container - control main container
   */


  LayerImport.prototype._initContainer = function () {
    // create main container
    var container = this._createMainContainerElement(); // create show Import element


    var inputShow = this._showImportInput = this._createShowImportElement();

    container.appendChild(inputShow); // mode "collapsed"

    if (!this.collapsed) {
      inputShow.checked = true;
    } // create Import picto


    var picto = this._createShowImportPictoElement();

    container.appendChild(picto); // panel

    var importPanel = this._importPanel = this._createImportPanelElement(); // header


    var panelHeader = this._importPanelHeader = this._createImportPanelHeaderElement();

    importPanel.appendChild(panelHeader); // form : initialisation du formulaire d'import des couches (types d'import et saisie de l'url / du fichier)

    var importForm = this._formContainer = this._initInputFormElement();

    importPanel.appendChild(importForm);
    container.appendChild(importPanel); // results (dans le panel)

    var getCapPanel = this._getCapPanel = this._createImportGetCapPanelElement();

    var getCapPanelHeader = this._createImportGetCapPanelHeaderElement();

    getCapPanel.appendChild(getCapPanelHeader);

    var importGetCapResultsList = this._getCapResultsListContainer = this._createImportGetCapResultsContainer();

    getCapPanel.appendChild(importGetCapResultsList);
    container.appendChild(getCapPanel); // mapbox panel results

    var mapBoxPanel = this._mapBoxPanel = this._createImportMapBoxPanelElement();

    var mapBoxPanelHeader = this._createImportMapBoxPanelHeaderElement();

    mapBoxPanel.appendChild(mapBoxPanelHeader);

    var importMapBoxResultsList = this._mapBoxResultsListContainer = this._createImportMapBoxResultsContainer();

    mapBoxPanel.appendChild(importMapBoxResultsList); // loading element mapbox

    var loading = this._loadingContainer = this._createLoadingElement();

    mapBoxPanel.appendChild(loading);
    container.appendChild(mapBoxPanel); // waiting

    var waiting = this._waitingContainer = this._createImportWaitingElement();

    container.appendChild(waiting);
    return container;
  };
  /**
   * Create control main container (DOM initialize)
   *
   * @private
   * @returns {DOMElement} importForm - form main container
   */


  LayerImport.prototype._initInputFormElement = function () {
    // form main container
    var importForm = this._createImportPanelFormElement(); // Format choice


    var importTypeChoiceDiv = this._createImportTypeLineElement(this.options.layerTypes);

    importForm.appendChild(importTypeChoiceDiv); // params for KML/GPX/GeoJSON

    var importStaticParamsContainer = this._createImportStaticParamsContainer(this.options.layerTypes[0]); // static file name


    var staticNameLabel = this._createStaticNameLabel();

    importStaticParamsContainer.appendChild(staticNameLabel); // static import choice (local / url)

    var staticImportChoice = this._createStaticModeChoiceDiv(); // TODO : passer un paramètre "checked" ??


    var staticLocalImportChoice = this._createStaticLocalChoiceDiv();

    staticImportChoice.appendChild(staticLocalImportChoice);

    var staticUrlImportChoice = this._createStaticUrlChoiceDiv();

    staticImportChoice.appendChild(staticUrlImportChoice);
    importStaticParamsContainer.appendChild(staticImportChoice); // div for local file import

    var staticLocalInputDiv = this._createStaticLocalInputDiv(); // label


    staticLocalInputDiv.appendChild(this._createStaticLocalInputLabel()); // file input

    this._staticLocalImportInput = this._createStaticLocalInput();
    staticLocalInputDiv.appendChild(this._staticLocalImportInput); // append div to params container

    importStaticParamsContainer.appendChild(staticLocalInputDiv); // div for url input (info: séparation pour récupérer l'élément input)

    var staticUrlInputDiv = this._createStaticUrlInputDiv(); // label


    staticUrlInputDiv.appendChild(this._createStaticUrlInputLabel()); // url input

    this._staticUrlImportInput = this._createStaticUrlInput();
    staticUrlInputDiv.appendChild(this._staticUrlImportInput); // append div to params container

    importStaticParamsContainer.appendChild(staticUrlInputDiv); // append static params container to form container

    importForm.appendChild(importStaticParamsContainer); // params for WMS/WMTS/WFS

    var importServiceParamsContainer = this._createServiceParamsContainer(this.options.layerTypes[0]); // div for service url


    var importServiceUrlDiv = this._createServiceUrlDiv(); // label


    importServiceUrlDiv.appendChild(this._createServiceUrlInputLabel()); // input

    this._serviceUrlImportInput = this._createServiceUrlInput();
    importServiceUrlDiv.appendChild(this._serviceUrlImportInput); // append div to params container

    importServiceParamsContainer.appendChild(importServiceUrlDiv); // append service params container to form container

    importForm.appendChild(importServiceParamsContainer); // submit (bouton "Importer")

    var submit = this._createImportSubmitFormElement();

    importForm.appendChild(submit);
    return importForm;
  }; // ################################################################### //
  // ######################### DOM events ############################## //
  // ################################################################### //

  /**
   * this method is called by event 'click' on 'GPshowImportPicto' picto
   * (cf. LayerImportDOM._createShowImportPictoElement),
   * and dispatch event change:collapsed (for tools listening this property)
   *
   * @private
   */


  LayerImport.prototype._onShowImportClick = function () {
    var map = this.getMap(); // on supprime toutes les interactions

    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_24__["default"].unset(map); // on affiche les resultats d'une couche MapBox

    if (this._mapBoxObj) {
      this._mapBoxPanel.style.display = "block";
    } // info : on génère nous même l'evenement OpenLayers de changement de propriété
    // (utiliser ol.control.LayerImport.on("change:collapsed", function ) pour s'abonner à cet évènement)


    this.collapsed = this._showImportInput.checked;
    this.dispatchEvent("change:collapsed");
  };
  /**
   * this method is called by event 'change' on 'GPimportType' tag form
   * (cf. LayerImportDOM._createImportTypeLineElement),
   * and change current import type
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onImportTypeChange = function (e) {
    this._currentImportType = e.target.value;

    if (this._currentImportType === "KML" || this._currentImportType === "GPX" || this._currentImportType === "GeoJSON" || this._currentImportType === "MAPBOX") {
      this._isCurrentImportTypeStatic = true;
    } else if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
      this._isCurrentImportTypeStatic = false;
    }
  };
  /**
   * this method is called by event 'change' on 'GPimportType' tag form
   * (cf. LayerImportDOM._createImportTypeLineElement),
   * and change current import type
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onStaticImportTypeChange = function (e) {
    this._currentStaticImportType = e.target.value;
  };
  /**
   * this method is called by event 'click' on 'GPimportGetCapPanelClose' tag form
   * (cf. LayerImportDOM._createImportGetCapPanelHeaderElement),
   * and reset getCapabilities information
   *
   * @private
   */


  LayerImport.prototype._onGetCapPanelClose = function () {
    // this._clearGetCapParams();
    if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
      this.cleanGetCapResultsList();
    }
  };
  /**
   * this method is called by event 'click' on 'GPimportMapBoxPanelClose' tag form
   * (cf. LayerImportDOM._createImportMapBoxPanelHeaderElement),
   * and reset mapbox information
   *
   * @private
   */


  LayerImport.prototype._onMapBoxPanelClose = function () {
    this.cleanMapBoxResultsList();
    this._loadingContainer.className = "";
  };
  /**
   * this method is called by event 'click' on 'GPimportMapBoxPanelReturnPicto' tag form
   * (cf. LayerImportDOM._createImportMapBoxPanelHeaderElement),
   * and return to information
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onMapBoxReturnPictoClick = function (e) {
    // on bascule sur l'icone d'ouverture du composant
    this._mapBoxPanel.style.display = "none";
    this._showImportInput.checked = false;
    this._loadingContainer.className = "";
  }; // ################################################################### //
  // ######################## Submit form ############################## //
  // ################################################################### //

  /**
   * this method is called by event 'submit' on 'GPimportForm' tag form
   * (cf. LayerImportDOM._createImportPanelFormElement),
   * and import static layer or call getCap service (according to import type)
   *
   * @private
   */


  LayerImport.prototype._onImportSubmit = function () {
    logger.log("import d'une couche de type : " + this._currentImportType); // reinitialisation du contenu d'un import de type
    // - static (KML ou GPX ou GeoJSON)

    this.contentStatic = null; // - service (WMS, ...)

    this.contentService = null;

    if (this._isCurrentImportTypeStatic) {
      this._importStaticLayer();
    } else {
      this._importServiceLayers();
    }
  }; // ################################################################### //
  // ############## Import KML/GPX/GeoJSON/MapBox layers ############### //
  // ################################################################### //

  /**
   * this method is called by this_onImportSubmit method
   * and import static layer (KML/GPX/GeoJSON) from url or file
   *
   * @private
   */


  LayerImport.prototype._importStaticLayer = function () {
    var layerName;
    var staticImportNameInput = document.getElementById(this._addUID("GPimportName"));

    if (staticImportNameInput) {
      layerName = staticImportNameInput.value || "";
      logger.log("import layer name : " + layerName);
    }

    if (this._currentStaticImportType === "local") {
      logger.log("import static layer from local file");

      this._importStaticLayerFromLocalFile(layerName);
    } else if (this._currentStaticImportType === "url") {
      logger.log("import static layer from url");

      this._importStaticLayerFromUrl(layerName);
    }
  };
  /**
   * this method is called by _importStaticLayer method
   * and import static layer (KML/GPX/GeoJSON) from url
   *
   * @param {String} layerName - imported layer name
   * @private
   */


  LayerImport.prototype._importStaticLayerFromUrl = function (layerName) {
    // 1. Récupération de l'url
    var url = this._staticUrlImportInput.value;
    logger.log("url : ", url);

    if (url.length === 0) {
      logger.error("[ol.control.LayerImport] url parameter is mandatory");
      return;
    } // on supprime les éventuels espaces avant ou après


    if (url.trim) {
      url = url.trim();
    } // sauvegarde


    this._url = url; // si le nom n'est pas renseigné, on extrait le nom du fichier

    if (!layerName) {
      layerName = this._url.substring(this._url.lastIndexOf("/") + 1, this._url.lastIndexOf("."));
    } // sauvegarde


    this._name = layerName; // 2. récupération proxy

    if (!this.options.webServicesOptions || !this.options.webServicesOptions.proxyUrl && !this.options.webServicesOptions.noProxyDomains) {
      logger.error("[ol.control.LayerImport] options.webServicesOptions.proxyUrl parameter is mandatory to request resources on another domain (cross-domain)");
      return;
    }

    ;
    url = _Common_Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_28__["default"].proxifyUrl(url, this.options.webServicesOptions); // FIXME pb de surcharge en mode UMD !? ça ne marche pas...
    // this._hideWaitingContainer();
    // this._addFeaturesFromImportStaticLayerUrl(url, layerName);

    var context = this;
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_20__["default"].Protocols.XHR.call({
      url: url,
      method: "GET",
      timeOut: 15000,
      // on success callback : display results in container
      onResponse: function onResponse(response) {
        context._hideWaitingContainer();

        context._addFeaturesFromImportStaticLayer(response, layerName);
      },
      // on error callback : log error
      onFailure: function onFailure(error) {
        // en cas d'erreur, on revient au panel initial et on cache la patience
        context._hideWaitingContainer();

        logger.error("[ol.control.LayerImport] KML/GPX/GeoJSON/MapBox request failed : ", error);
      }
    });
  };
  /**
   * this method is called by _importStaticLayer method
   * and import static layer (KML/GPX/GeoJSON) from local file
   *
   * @param {String} layerName - imported layer name
   * @private
   */


  LayerImport.prototype._importStaticLayerFromLocalFile = function (layerName) {
    var file = this._staticLocalImportInput.files[0];

    if (!file) {
      logger.warn("[ol.control.LayerImport] missing file");
      return;
    } // sauvegarde


    this._file = file; // si le nom n'est pas renseigné, on extrait le nom du fichier

    if (!layerName) {
      layerName = this._file.name.substring(this._file.name.lastIndexOf("/") + 1, this._file.name.lastIndexOf("."));
    } // sauvegarde


    this._name = layerName; // Création d'un objet FileReader qui permet de lire le contenu du fichier chargé

    var fReader = new FileReader(); // Définition des fonctions de callbacks associées au reader,
    // notamment la fonction onload qui affichera les entités chargées à la carte

    var context = this; // on readAsText error

    fReader.onerror = function (e) {
      // en cas d'erreur, on revient au panel initial et on cache la patience
      context._hideWaitingContainer();

      logger.error("error fileReader : ", e);
    };
    /** on readAsText progress */


    fReader.onprogress = function () {
      logger.log("onprogress");
    };
    /** on load start */


    fReader.onloadstart = function () {
      // affichage d'une patience le temps du chargement
      context._displayWaitingContainer();

      logger.log("onloadstart");
    };
    /** on readAsText abort */


    fReader.onabort = function () {
      // en cas d'erreur, on revient au panel initial et on cache la patience
      context._hideWaitingContainer();

      logger.log("onabort");
    }; // on readAsText loadend


    fReader.onloadend = function (e) {
      // fReader = null ?
      // en cas d'erreur, on revient au panel initial et on cache la patience
      // context._hideWaitingContainer();
      // TODO : replier le formulaire ?
      logger.log("onloadend : ", e);
    }; // on readAsText load


    fReader.onload = function (e) {
      logger.log("fileReader onload - file content : ", e.target.result); // on cache la patience

      context._hideWaitingContainer();

      context._addFeaturesFromImportStaticLayer(e.target.result, layerName);
    }; // Lecture du fichier chargé à l'aide de fileReader


    fReader.readAsText(file);
  };
  /**
   * this method is called by _importStaticLayerFom* method
   * and add features to the map
   *
   * @param {String} fileContent - content file
   * @param {String} layerName - imported layer name
   * @private
   */


  LayerImport.prototype._addFeaturesFromImportStaticLayer = function (fileContent, layerName) {
    // récupération du contenu du fichier
    var map = this.getMap();

    if (!map || !fileContent) {
      return;
    }

    var vectorLayer = null;
    var vectorSource = null;
    var vectorFormat = null;
    var vectorStyle = null; // sauvegarde du content KML/GPX/GeoJSON/MapBox

    this.contentStatic = fileContent;

    if (this._currentImportType === "MAPBOX") {
      // FIXME
      // on ne nettoie pas délibérément la liste de résultats de type MapBox
      // car on souhaite pouvoir interagir sur les couches (editeur).
      // du coup, à chaque import, on empile les éditeurs.
      // this.cleanMapBoxResultsList();
      // contexte
      var self = this; // style mapbox

      var _glStyle = this._mapBoxObj = JSON.parse(fileContent); // liste des sources


      var _glSources = _glStyle.sources; // FIXME a t on du multi-sources ?
      // mais comment doit on les traiter ?
      // EXPERIMENTAL !

      var _multiSources = Object.keys(_glSources).length > 1 ? 1 : 0;

      for (var _glSourceId in _glSources) {
        if (_glSources.hasOwnProperty(_glSourceId)) {
          var _title = "";
          var _description = "";
          var _quicklookUrl = null;
          var _legends = null;
          var _metadata = null;
          var _originators = null; // lecture des informations dans le style
          // ex. metadata : {
          //    geoportail:[title | description | quicklookUrl | legends | originators | metadata]
          // }

          if (_glStyle.metadata) {
            for (var ns in _glStyle.metadata) {
              if (_glStyle.metadata.hasOwnProperty(ns)) {
                var _keys = ns.split(":");

                if (_keys[0] === "geoportail") {
                  var key = _keys[1];

                  if (key === "title") {
                    _title = _glStyle.metadata[ns];
                    continue;
                  }

                  if (key === "description") {
                    _description = _glStyle.metadata[ns];
                    continue;
                  }

                  if (key === "quicklookUrl") {
                    _quicklookUrl = _glStyle.metadata[ns];
                    continue;
                  }

                  if (key === "legends") {
                    _legends = _glStyle.metadata[ns];
                    continue;
                  }

                  if (key === "metadata") {
                    _metadata = _glStyle.metadata[ns];
                    continue;
                  }

                  if (key === "originators") {
                    _originators = _glStyle.metadata[ns];
                    continue;
                  }
                }
              }
            }
          } // titre par defaut


          if (!_title) {
            _title = "Couche MapBox";
          } // description par defaut


          if (!_description) {
            _description = "Couche MapBox";
          } // cas des multisources


          _title = _multiSources ? _title + "(" + _glSourceId + ")" : _title; // source mapbox

          var _glSource = _glSources[_glSourceId]; // construction de la couche en fonction du type

          var _glType = _glSource.type;

          if (_glType === "vector") {
            // url du tilejson ou flux mapbox
            var _glUrl = _glSource.url; // url du service tuilé

            var _glTiles = _glSource.tiles; // sprites

            var _glSprite = _glStyle.sprite; // FIXME si on a un import par fichier local (this._file),
            // - comment passe t on la clef / le token ?
            // - comment remplacer un flux mapbox sur une url de service tuilé avec un import local ?

            if (_glUrl && _glUrl.indexOf("mapbox://") === 0) {
              var _urlService = this._url; // FIXME si fichier local !?

              if (_urlService) {
                _glTiles = ["a", "b", "c", "d"].map(function (host) {
                  var path = _glUrl.replace("mapbox://", "");

                  var accessToken = _urlService.split("?")[1];

                  return "https://" + host + ".tiles.mapbox.com/v4/" + path + "/{z}/{x}/{y}.vector.pbf?" + accessToken;
                }); // conversion des sprites sur un autre scheme que "mapbox://"

                if (_glSprite.indexOf("mapbox://") === 0) {
                  var s = _urlService.split("?"); // FIXME si fichier local !?


                  _glStyle.sprite = s[0] + "/sprite" + "?" + s[1];
                }
              } else {
                logger.warn("Not yet implemented, can't use the local import scheme with a 'mapbox://' in the file.!");
              }
            }

            if (_glTiles) {
              // service tuilé et/ou mapbox
              vectorFormat = new ol_format_MVT__WEBPACK_IMPORTED_MODULE_7___default.a();
              vectorSource = new ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default.a({
                attributions: _glSource.attribution,
                format: vectorFormat,
                tileGrid: Object(ol_tilegrid__WEBPACK_IMPORTED_MODULE_5__["createXYZ"])({
                  // TODO scheme tms ?
                  extent: _glSource.bounds,
                  // [minx, miny, maxx, maxy]
                  maxZoom: _glSource.maxzoom || 22,
                  minZoom: _glSource.minzoom || 1,
                  tileSize: _glSource.tileSize || 256
                }),
                urls: _glTiles
              });
              vectorSource._title = _title;
              vectorSource._description = _description;
              vectorSource._quicklookUrl = _quicklookUrl;
              vectorSource._metadata = _metadata;
              vectorSource._legends = _legends;
              vectorSource._originators = _originators; // waiting

              vectorSource.on("tileloadstart", function (e) {
                self._loadingContainer.className = "GPmapLoadingVisible";
              });
              vectorSource.on("tileloadend", function (e) {
                self._loadingContainer.className = "";
              });
              vectorSource.on("tileloaderror", function (e) {
                self._loadingContainer.className = "";
              });
              vectorLayer = new ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default.a({
                source: vectorSource,
                visible: false,
                // zIndex: 0, // FIXME gerer l'ordre sur des multisources ?
                declutter: true // TODO utile ?

              });
              this._mapBoxLayerId = vectorLayer.id = _glSourceId;
              vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
            } else if (_glUrl) {
              // service avec un tilejson
              vectorFormat = new ol_format_MVT__WEBPACK_IMPORTED_MODULE_7___default.a();
              vectorLayer = new ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default.a({
                visible: false,
                // zIndex : 0
                declutter: true
              });
              this._mapBoxLayerId = vectorLayer.id = _glSourceId;
              vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
              var vectorTileJson = new ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17___default.a({
                url: _glUrl
              }); // lecture du tilejson avec extension IGN
              // les extensions sont enregistrées
              // dans les propriétés de la couche : layer.set(mapbox-extension)
              // pour une utilisation ulterieur (ex. editeur)

              var _key = vectorTileJson.on("change", function () {
                if (vectorTileJson.getState() === "ready") {
                  var _tileJSONDoc = vectorTileJson.getTileJSON();

                  var tiles = Array.isArray(_tileJSONDoc.tiles) ? _tileJSONDoc.tiles : [_tileJSONDoc.tiles];

                  for (var i = 0; i < tiles.length; i++) {
                    var tile = tiles[i];

                    if (tile.indexOf("http") !== 0) {
                      tiles[i] = _glUrl + tile;
                    }
                  }

                  vectorSource = new ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default.a({
                    attributions: vectorTileJson.getAttributions() || _tileJSONDoc.attribution,
                    format: vectorFormat,
                    tileGrid: Object(ol_tilegrid__WEBPACK_IMPORTED_MODULE_5__["createXYZ"])({
                      extent: _glSource.bounds,
                      // [minx, miny, maxx, maxy]
                      maxZoom: _tileJSONDoc.maxzoom || _glSource.maxzoom || 22,
                      minZoom: _tileJSONDoc.minzoom || _glSource.minzoom || 0,
                      tileSize: _tileJSONDoc.tileSize || _glSource.tileSize || 256
                    }),
                    urls: tiles
                  });
                  vectorSource._title = _title;
                  vectorSource._description = _description;
                  vectorSource._quicklookUrl = _quicklookUrl;
                  vectorSource._metadata = _metadata;
                  vectorSource._legends = _legends;
                  vectorSource._originators = _originators; // waiting

                  vectorSource.on("tileloadstart", function (e) {
                    self._loadingContainer.className = "GPmapLoadingVisible";
                  });
                  vectorSource.on("tileloadend", function (e) {
                    self._loadingContainer.className = "";
                  });
                  vectorLayer.setSource(vectorSource);
                  vectorLayer.set("mapbox-extension", _tileJSONDoc["vector_layers"]);
                  Object(ol_Observable__WEBPACK_IMPORTED_MODULE_2__["unByKey"])(_key);
                }
              });
            }
          } else if (_glType === "geojson") {
            // FIXME
            // - cas avec un objet de type features ?
            // - cas avec une url relative ?
            var _glData = _glSource.data;
            vectorFormat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__["default"]();
            vectorSource = new ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default.a({
              attributions: _glSource.attribution,
              format: vectorFormat,
              url: _glData
            });
            vectorSource._title = _title;
            vectorSource._description = _description;
            vectorSource._quicklookUrl = _quicklookUrl;
            vectorSource._metadata = _metadata;
            vectorSource._legends = _legends;
            vectorSource._originators = _originators;
            vectorLayer = new ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default.a({
              source: vectorSource,
              visible: false,
              // zIndex: 0, // FIXME gerer l'ordre sur des multisources ?
              declutter: true // TODO utile ?

            });
            this._mapBoxLayerId = vectorLayer.id = _glSourceId;
            vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
          } else {
            logger.warn("Type MapBox format unknown !");
            return;
          } // parametre à transmettre à la fonction auto-invoquée


          var params = {
            id: _glSourceId,
            styles: _glStyle,
            layer: vectorLayer,
            options: {
              title: layerName || _title,
              description: _description,
              quicklookUrl: _quicklookUrl,
              metadata: _metadata,
              legends: _legends,
              originators: _originators
            }
          }; // fonction auto-invoquée

          (function (p) {
            // TODO ajouter le style de type background !
            // fonction de style de la couche
            var setStyle = function setStyle() {
              Object(ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__["applyStyle"])(p.layer, p.styles, p.id).then(function () {
                var visibility = true;
                p.layer.setVisible(visibility);
                var opacity = 1;
                p.layer.setOpacity(opacity);
              }).then(function () {
                // gestion du centre sur la carte si center renseigné !
                var projCode = map.getView().getProjection().getCode();

                if (map.getView() && p.styles.center && p.styles.center.length) {
                  map.getView().setCenter(Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["transform"])(p.styles.center, "EPSG:4326", projCode));
                } // gestion du zoom sur la carte si zoom renseigné !


                if (map.getView() && (p.styles.zoom || p.styles.zoom === 0)) {
                  map.getView().setZoom(p.styles.zoom);
                } // zoom sur l'étendue des entités récupérées (si possible)


                var source = p.layer.getSource();

                if (map.getView() && map.getSize() && source.getExtent) {
                  var sourceExtent = source.getExtent();

                  if (sourceExtent && sourceExtent[0] !== Infinity) {
                    map.getView().fit(source.getExtent(), map.getSize());
                  }
                }
              }).then(function () {})["catch"](function (e) {
                logger.error(e);
              });
            }; // etat des layers en cours


            logger.warn(p.layer); // ajout des styles dans la carte pour une utilisation
            // eventuelle (ex. editeur)
            // > map.set("mapbox-styles")

            var _allStyles = map.get("mapbox-styles") || {};

            _allStyles[p.id] = p.styles;
            map.set("mapbox-styles", _allStyles); // ajout des differents styles de la couche
            // pour une utilisation eventuelle (ex. editeur)
            // > layer.set("mapbox-styles")

            var _styles = [];
            var _glLayers = p.styles.layers;

            for (var ii = 0; ii < _glLayers.length; ii++) {
              var _glLayer = _glLayers[ii];

              if (_glLayer.source === p.id) {
                _styles.push(_glLayer);

                continue;
              }
            }

            p.layer.set("mapbox-styles", _styles); // ajout du layer sur la carte

            map.addLayer(p.layer); // application du style

            if (p.layer.getSource()) {
              setStyle();
            } else {
              p.layer.once("change:source", setStyle);
            } // maj du gestionnaire de couche


            map.getControls().forEach(function (control) {
              if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_33__["default"]) {
                control.addLayer(p.layer, p.options);
              }
            });
          })(params);
        }
      } // affichage du panneau des couches accessibles à l'edition


      this._importPanel.style.display = "none";
      this._mapBoxPanel.style.display = "block"; // editeur de styles

      this.editor = new _Editor__WEBPACK_IMPORTED_MODULE_21__["default"]({
        target: this._mapBoxResultsListContainer,
        style: this._mapBoxObj,
        scope: this,
        events: {
          "editor:layer:onclickvisibility": this._onChangeVisibilitySourceMapBox,
          "editor:style:scale:onchangemin": this._onChangeScaleMinSourceMapBox,
          "editor:style:scale:onchangemax": this._onChangeScaleMaxSourceMapBox,
          "editor:legend:onchangevalue": this._onChangeLegendValueSourceMapBox
        },
        tools: {
          themes: false,
          layers: true,
          style: this.options.vectorStyleOptions.MapBox.tools.style,
          filter: this.options.vectorStyleOptions.MapBox.tools.filter,
          legend: true,
          group: false
        }
      });
      this.editor.createElement(); // TODO style par defaut au cas où l'application du style échoue !
      // FIXME bug avec le geojson, très bizarre !?
      //      Si on desactive l'editeur, OK
      //      Sinon NOK !?
      // FIXME event sur la suppression de la couche afin de fermer le panneau !
      // TODO au niveau de la couche : minResolution et maxResolution
    } else {
      if (this._currentImportType === "KML") {
        // lecture du fichier KML : création d'un format ol.format.KML, qui possède une méthode readFeatures (et readProjection)
        vectorStyle = this.options.vectorStyleOptions.KML.defaultStyle;
        vectorFormat = new _Formats_KML__WEBPACK_IMPORTED_MODULE_30__["default"]({
          showPointNames: this.options.vectorStyleOptions.KML.showPointNames,
          extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
          defaultStyle: [vectorStyle]
        });
      } else if (this._currentImportType === "GPX") {
        // lecture du fichier GPX : création d'un format ol.format.GPX, qui possède une méthode readFeatures (et readProjection)
        vectorStyle = this.options.vectorStyleOptions.GPX.defaultStyle;
        vectorFormat = new _Formats_GPX__WEBPACK_IMPORTED_MODULE_32__["default"]({
          defaultStyle: vectorStyle
        });
      } else if (this._currentImportType === "GeoJSON") {
        // lecture du fichier GeoJSON : création d'un format ol.format.GeoJSON, qui possède une méthode readFeatures (et readProjection)
        vectorStyle = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
        vectorFormat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__["default"]({
          defaultStyle: vectorStyle
        });
      } // lecture de la géométrie des entités à partir du fichier, pour éventuelle reprojection.


      var fileProj = vectorFormat.readProjection(fileContent); // récupération de la projection de la carte pour reprojection des géométries

      var mapProj = this._getMapProjectionCode(); // récupération des entités avec reprojection éventuelle des géométries


      var features = null;
      features = vectorFormat.readFeatures(fileContent, {
        dataProjection: fileProj,
        featureProjection: mapProj
      });
      logger.log("loaded features : ", features); // création d'une couche vectorielle à partir de ces features

      vectorSource = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_14___default.a({
        features: new ol_Collection__WEBPACK_IMPORTED_MODULE_3___default.a()
      });
      vectorSource.addFeatures(features);
      logger.trace(vectorSource); // ajout des informations pour le layerSwitcher (titre, description)

      vectorSource._title = vectorSource._description = layerName;
      vectorLayer = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11___default.a({
        source: vectorSource,
        style: vectorStyle
      }); // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)

      vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
      map.addLayer(vectorLayer); // TODO : appeler fonction commune
      // zoom sur l'étendue des entités récupérées (si possible)

      if (map.getView() && map.getSize() && vectorSource.getExtent) {
        var sourceExtent = vectorSource.getExtent();

        if (sourceExtent && sourceExtent[0] !== Infinity) {
          map.getView().fit(vectorSource.getExtent(), map.getSize());
        }
      }
    }
  };
  /**
   * NOT USE : this method is called by _importStaticLayerFom* method
   * and add features to the map
   *
   * @param {String} url - url
   * @param {String} layerName - imported layer name
   * @private
   */


  LayerImport.prototype._addFeaturesFromImportStaticLayerUrl = function (url, layerName) {
    // récupération du contenu du fichier
    var map = this.getMap();

    if (!map || !url) {
      return;
    }

    var vectorSource;
    var vectorLayer;
    var vectorFormat;

    if (this._currentImportType === "MAPBOX") {
      // TODO
      logger.trace("Not yet implemented !");
    } else {
      if (this._currentImportType === "KML") {
        // lecture du fichier KML : création d'un format ol.format.KML, qui possède une méthode readFeatures (et readProjection)
        vectorFormat = new _Formats_KML__WEBPACK_IMPORTED_MODULE_30__["default"]({
          showPointNames: true,
          // FIXME option !
          extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
          defaultStyle: [this.options.vectorStyleOptions.KML.defaultStyle]
        });
      } else if (this._currentImportType === "GPX") {
        // lecture du fichier GPX : création d'un format ol.format.GPX, qui possède une méthode readFeatures (et readProjection)
        vectorFormat = new _Formats_GPX__WEBPACK_IMPORTED_MODULE_32__["default"]({
          defaultStyle: this.options.vectorStyleOptions.GPX.defaultStyle
        });
      } else if (this._currentImportType === "GeoJSON") {
        // lecture du fichier GeoJSON : création d'un format ol.format.GeoJSON, qui possède une méthode readFeatures (et readProjection)
        vectorFormat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__["default"]({
          defaultStyle: this.options.vectorStyleOptions.GeoJSON.defaultStyle
        });
      } // création d'une couche vectorielle à partir de ces features


      vectorSource = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_14___default.a({
        url: url,
        format: vectorFormat
      });

      if (this._currentImportType === "GPX") {
        vectorSource.forEachFeature(function (feature) {
          // si aucun style n'est associé au feature
          if (feature.getStyle() == null) {
            logger.log("[ol.control.LayerImport] set default style for GPX feature");
            feature.setStyle(this.options.vectorStyleOptions.GPX.defaultStyle);
          }
        });
      }

      if (this._currentImportType === "GeoJSON") {
        vectorSource.forEachFeature(function (feature) {
          // si aucun style n'est associé au feature
          if (feature.getStyle() == null) {
            logger.log("[ol.control.LayerImport] set default style for GeoJSON feature");
            feature.setStyle(this.options.vectorStyleOptions.GeoJSON.defaultStyle);
          }
        });
      } // ajout des informations pour le layerSwitcher (titre, description)


      vectorSource._title = vectorSource._description = layerName;
      vectorLayer = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11___default.a({
        source: vectorSource
      });
    } // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)


    vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
    map.addLayer(vectorLayer); // TODO : appeler fonction commune
    // zoom sur l'étendue des entités récupérées (si possible)

    if (map.getView() && map.getSize() && vectorSource.getExtent) {
      var sourceExtent = vectorSource.getExtent();

      if (sourceExtent && sourceExtent[0] !== Infinity) {
        map.getView().fit(vectorSource.getExtent(), map.getSize());
      }
    }
  }; // Events MapBox DOM

  /**
   * this method is called on '_addImportMapBoxVisibilitySource' input click
   * and change visibility source to map
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onChangeVisibilitySourceMapBox = function (e) {
    var _this = this;

    var data = e.target.data.obj;
    var target = e.target.srcElement;
    var map = this.getMap();
    map.getLayers().forEach(function (layer) {
      // logger.trace(layer);
      if (layer.get("mapbox-source") === data.source) {
        // reload style with new param : layout.visibility : "visible" or "none"...
        var layers = _this._mapBoxObj.layers;

        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            var layout = layers[i].layout;

            if (layout) {
              layout.visibility = target.checked ? "visible" : "none";
            } else {
              layers[i].layout = {
                visibility: target.checked ? "visible" : "none"
              };
            }

            break;
          }
        }

        Object(ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__["applyStyle"])(layer, _this._mapBoxObj, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    });
  };
  /**
   * this method is called on '_addImportMapBoxScaleSource' input slide
   * and change zoom source to map
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onChangeScaleMinSourceMapBox = function (e) {
    var _this2 = this;

    var data = e.target.data.obj;
    var target = e.target.srcElement;
    var map = this.getMap();
    map.getLayers().forEach(function (layer) {
      // logger.trace(layer);
      if (layer.get("mapbox-source") === data.source) {
        // reload style with new param : minZoom = ...
        var layers = _this2._mapBoxObj.layers;

        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            layers[i].minzoom = target.value;
            target.title = target.value;
            break;
          }
        }

        Object(ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__["applyStyle"])(layer, _this2._mapBoxObj, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    });
  };
  /**
   * this method is called on '_addImportMapBoxScaleSource' input slide
   * and change zoom source to map
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onChangeScaleMaxSourceMapBox = function (e) {
    var _this3 = this;

    var data = e.target.data.obj;
    var target = e.target.srcElement;
    var map = this.getMap();
    map.getLayers().forEach(function (layer) {
      // logger.trace(layer);
      if (layer.get("mapbox-source") === data.source) {
        // reload style with new param : minZoom = ...
        var layers = _this3._mapBoxObj.layers;

        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            layers[i].maxzoom = target.value;
            target.title = target.value;
            break;
          }
        }

        Object(ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__["applyStyle"])(layer, _this3._mapBoxObj, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    });
  };
  /**
   * this method is called on ''
   * and change zoom source to map
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onChangeLegendValueSourceMapBox = function (e) {
    var _this4 = this;

    var data = e.target.data.obj;
    var target = e.target.srcElement;
    var map = this.getMap();
    map.getLayers().forEach(function (layer) {
      // logger.trace(layer);
      if (layer.get("mapbox-source") === data.source) {
        // reload style with new param :
        var layers = _this4._mapBoxObj.layers;

        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            var paint = layers[i].paint;

            if (paint) {
              paint[target.id] = target.value;
            }

            break;
          }
        }

        Object(ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__["applyStyle"])(layer, _this4._mapBoxObj, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    });
  }; // ################################################################### //
  // #################### Import WMS/WMTS layers ####################### //
  // ################################################################### //

  /**
   * this method is called by this_onImportSubmit method
   * and call getCap service from specified url, then display layers list in new panel
   *
   * @private
   */


  LayerImport.prototype._importServiceLayers = function () {
    if (this._currentImportType === "WFS") {
      logger.warn("[ol.control.LayerImport] WFS layer import is not implemented yet");
      return;
    } // 0. on vide d'éventuels résultats précédents dans le panel GetCapResults


    this.cleanGetCapResultsList(); // 1. récupération de l'url renseignée

    var url = this._getCapRequestUrl = this._serviceUrlImportInput.value;

    if (!url) {
      logger.error("[ol.control.LayerImport] url parameter is mandatory");
      return;
    }

    logger.log("url : ", url); // on supprime les éventuels espaces avant ou après

    if (url.trim) {
      url = url.trim();
    } // Info : on ajoute des paramètres uniquement si l'utilisateur n'en a pas déjà saisi (on vérifie la position du caractère "?")


    var questionMarkIndex = url.indexOf("?");

    if (questionMarkIndex < 0) {
      // dans le cas d'une url du type http://wxs.ign.fr/geoportail/wmts
      url += "?SERVICE=" + this._currentImportType + "&REQUEST=GetCapabilities";
    } else if (questionMarkIndex === url.length - 1) {
      // dans le cas où l'url se termine par "?"
      url += "SERVICE=" + this._currentImportType + "&REQUEST=GetCapabilities";
    } // si on n'est pas dans ces deux cas : l'utilisateur a déjà saisit des paramètres après "?" => on ne fait rien.
    // 2. récupération proxy


    if (!this.options.webServicesOptions || !this.options.webServicesOptions.proxyUrl && !this.options.webServicesOptions.noProxyDomains) {
      logger.error("[ol.control.LayerImport] options.webServicesOptions.proxyUrl parameter is mandatory to request web service layers (getcapabilities request)");
      return;
    }

    ;
    var proxyUrl = this.options.webServicesOptions.proxyUrl;
    var noProxyDomains = this.options.webServicesOptions.noProxyDomains; // on regarde si l'url nest pas dans les domaines sans proxy

    var bfound = false;

    if (noProxyDomains && Array.isArray(noProxyDomains) && noProxyDomains.length > 0) {
      for (var i in noProxyDomains) {
        logger.log("analyzing " + noProxyDomains[i]);

        if (url.indexOf(noProxyDomains[i]) !== -1) {
          logger.log(url + " found in noProxyDomains list (" + noProxyDomains[i] + ").");
          bfound = true;
        }
      }
    } // si on n'est pas dans un domaine sans proxy, on ajoute le proxy (+ encodage)


    if (bfound === false) {
      url = proxyUrl + encodeURIComponent(url);
    } // 3. affichage d'une patience le temps de la requête


    this._displayWaitingContainer(); // 4. send getcapabilities request (XHR protocol => proxy Url is needed)


    var context = this;
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_20__["default"].Protocols.XHR.call({
      url: url,
      method: "GET",
      timeOut: 15000,
      // on success callback : display results in container
      onResponse: function onResponse(response) {
        context._hideWaitingContainer();

        context._displayGetCapResponseLayers(response);
      },
      // on error callback : log error
      onFailure: function onFailure(error) {
        // en cas d'erreur, on revient au panel initial et on cache la patience
        context._hideWaitingContainer();

        logger.error("[ol.control.LayerImport] getCapabilities request failed : ", error);
      }
    });
  };
  /**
   * this method is called by this._importServiceLayers method
   * and display layers list from getcapabilities response
   *
   * @param {Object} xmlResponse - getCapabilities response (xml format)
   * @private
   */


  LayerImport.prototype._displayGetCapResponseLayers = function (xmlResponse) {
    var parser;
    var layers;
    var layerDescription = {
      content: null,
      title: null
    };
    var projection;
    this._getCapResponseWMSLayers = []; // sauvegarde du content d'un GetCapabilities

    this.contentService = xmlResponse; // Affichage du panel des couches accessibles

    this._importPanel.style.display = "none";
    this._getCapPanel.style.display = "block"; // Parse GetCapabilities Response

    if (this._currentImportType === "WMS") {
      parser = new ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8___default.a();
      var getCapResponseWMS = this._getCapResponseWMS = parser.read(xmlResponse);
      logger.log("getCapabilities response : ", getCapResponseWMS);

      if (getCapResponseWMS && getCapResponseWMS.Capability && getCapResponseWMS.Capability.Layer) {
        // info: le parser Openlayers récupère la première layer de <Capability> comme un unique objet (il écrase les précédents s'il y a pls <Layer> à la racine de <Capability>)
        // /!\ être vigilant si le parser est modifié (notamment pour récupérer les différentes layers à la racine. ex  http://geoservices.brgm.fr/geologie?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetCapabilities)
        var getCapLayer = getCapResponseWMS.Capability.Layer; // on va lire le contenu de la (ou les) <Layer> pour l'afficher ou en afficher les couches disponibles

        if (Array.isArray(getCapLayer)) {
          // cas où on a plusieurs <Layer> à la racine, mais non géré encore par ol.format.WMSCapabilities jusqu'à la v3.18.2.
          for (var i = 0; i < getCapLayer.length; i++) {
            this._displayGetCapResponseWMSLayer(getCapLayer[i]);
          }
        } else {
          // cas du parser ol.format.WMSCapabilities jusqu'à la v3.18.2.
          this._displayGetCapResponseWMSLayer(getCapLayer);
        }
      }
    } else if (this._currentImportType === "WMTS") {
      parser = new ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9___default.a();
      var getCapResponseWMTS = this._getCapResponseWMTS = parser.read(xmlResponse);
      logger.log("getCapabilities response : ", getCapResponseWMTS);

      if (getCapResponseWMTS && getCapResponseWMTS.Contents && getCapResponseWMTS.Contents.Layer) {
        layers = getCapResponseWMTS.Contents.Layer;

        if (Array.isArray(layers)) {
          // on stocke la liste des couches pour faire le lien avec le DOM
          this._getCapResponseWMTSLayers = layers;

          for (var j = 0; j < layers.length; j++) {
            // on vérifie que la projection de la couche WMTS est compatible avec celle de la carte
            // (ie elle doit être connue par ol.proj)
            projection = this._getWMTSLayerProjection(layers[j], getCapResponseWMTS);

            if (projection && typeof projection === "string") {
              if (Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(projection) || Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(projection.toUpperCase())) {
                // si la projection de la couche est connue par ol.proj,
                // on ajoute chaque couche de la réponse dans la liste des couches accessibles
                layerDescription = {
                  content: layers[j].Title,
                  title: layers[j].Abstract || layers[j].Title
                };

                if (this._getCapResultsListContainer) {
                  this._addImportGetCapResultLayer(layerDescription, j, this._getCapResultsListContainer);
                }
              } else {
                // si la projection de la couche n'est pas connue par ol.proj,
                // on n'affiche pas la couche dans le panel des résultats
                logger.warn("[ol.control.LayerImport] wmts layer cannot be added to map : unknown projection", layers[j]);
                continue;
              }
            }
          }
        }
      }
    }
  };
  /**
   * this method is called by this._displayGetCapResponseLayers method
   * and display WMS layer in list from getcapabilities response
   *
   * @param {Object} layerObj - object corresponding to <Layer> content in WMS GetCapabilities response
   * @param {Object} [parentLayersInfos] - object corresponding to parents <Layer> content in WMS GetCapabilities response (without children <Layer> infos)
   * @private
   */


  LayerImport.prototype._displayGetCapResponseWMSLayer = function (layerObj, parentLayersInfos) {
    if (!layerObj) {
      logger.warn("[ol.control.LayerImport] _displayGetCapResponseWMSLayer : getCapabilities layer object not found");
      return;
    }

    logger.log("[ol.control.LayerImport] _displayGetCapResponseWMSLayer - layerObj : ", layerObj); // récupération de la projection de la map (pour vérifier que l'on peut reprojeter les couches disponibles)

    var mapProjCode = this._getMapProjectionCode();

    var projection;
    var layerDescription = {
      content: null,
      title: null
    }; // 1. héritage éventuels des informations de la couche parent

    if (parentLayersInfos) {
      var key;
      var i; // propriétés héritées à ajouter aux propriétés parent

      var addKeys = ["CRS", "Style" // "AuthorityURL" // TODO
      ];

      for (i = 0; i < addKeys.length; i++) {
        key = addKeys[i];

        if (Array.isArray(parentLayersInfos[key]) && parentLayersInfos[key].length !== 0) {
          if (Array.isArray(layerObj[key]) && layerObj[key].length !== 0) {
            // on ajoute celles de la couche parent
            for (var n = 0; n < parentLayersInfos[key].length; n++) {
              if (layerObj[key].indexOf(parentLayersInfos[key][n]) === -1) {
                // si le CRS/Style parent n'est pas dans les CRS/Style de la couche, on l'ajoute
                layerObj[key].push(parentLayersInfos[key][n]);
              }
            }
          } else {
            // si la couche n'a pas de CRS ou Style, on récupère ceux de la couche parent
            layerObj[key] = parentLayersInfos[key];
          }
        }
      } // propriétés qui remplacent les valeurs des propriétés héritées,
      // càd on récupère la propriété parent seulement si elle n'est pas définie pour l'élément enfant


      var replaceKeys = ["BoundingBox", "EX_GeographicBoundingBox", "MaxScaleDenominator", "MinScaleDenominator", "Attribution", "Dimension", "queryable", "cascaded", "opaque", "noSubsets", "fixedWidth", "fixedHeight"];

      for (i = 0; i < replaceKeys.length; i++) {
        key = replaceKeys[i];

        if (parentLayersInfos[key] && !layerObj[key]) {
          layerObj[key] = parentLayersInfos[key];
        }
      }
    } else {
      // si on n'a pas d'infos de couche parent, on est à la racine du Capability, on le note
      layerObj._isRootLayer = true;
      layerObj._container = this._getCapResultsListContainer;

      if (!layerObj.Title) {
        layerObj.Title = "Liste des couches";
      }
    } // 2. si on a d'autres couches <Layer> imbriquées, on descend d'un niveau, sinon on affiche la couche dans la liste des résultats


    if (layerObj.Layer) {
      if (Array.isArray(layerObj.Layer)) {
        var _container = layerObj ? layerObj._container : parentLayersInfos._container;

        var _title = layerObj ? layerObj.Title : parentLayersInfos.Title;

        layerObj._container = this._addImportGetCapResultListRubrique(_title, _container).lastChild;

        for (var j = 0; j < layerObj.Layer.length; j++) {
          // on recommence pour chaque sous couche, avec les infos éventuellement héritées
          var bRubriqueExist = false;

          var lstRubrique = layerObj._container.getElementsByClassName("GPimportGetCapRubriqueTitle");

          for (var ii = 0; ii < lstRubrique.length; ii++) {
            if (lstRubrique[ii].title === layerObj.Title) {
              bRubriqueExist = true;
              layerObj.Layer[j]._container = lstRubrique[ii].parentElement;
            }
          }

          if (!bRubriqueExist) {
            layerObj.Layer[j]._container = this._addImportGetCapResultRubrique(layerObj.Title, layerObj._container).lastChild;
          }

          this._displayGetCapResponseWMSLayer(layerObj.Layer[j], layerObj);
        }
      }
    } else {
      // on récupère la longueur de la liste des couches déjà récupérées, pour avoir ce qui sera l'index de la couche à ajouter.
      var lastIndex = this._getCapResponseWMSLayers.length; // on vérifie que la couche ait une projection compatible avec celle de la carte
      // ou soit connue par proj4js, et on stocke cette projection dans les infos de la couche.

      projection = this._getWMSLayerProjection(layerObj, mapProjCode);

      if (!projection) {
        // si aucune projection n'est compatible avec celle de la carte ou connue par ol.proj,
        // on n'affiche pas la couche dans le panel des résultats
        logger.warn("[ol.control.LayerImport] wms layer cannot be added to map : unknown projection", layerObj);
      } else {
        // si on a une projection compatible : on la stocke et la couche sera éventuellement reprojetée à l'ajout
        layerObj._projection = projection; // on ajoute chaque couche de la réponse dans la liste des couches accessibles

        layerDescription = {
          content: layerObj.Title,
          title: layerObj.Abstract || layerObj.Title
        }; // FIXME beurk !?

        var _isGoodContainer = layerObj._container;

        if (_isGoodContainer.localName === "ul") {
          _isGoodContainer = _isGoodContainer.lastChild;
        }

        this._addImportGetCapResultLayer(layerDescription, lastIndex, _isGoodContainer); // puis on stoke la couche dans la liste pour faire le lien avec le DOM


        this._getCapResponseWMSLayers[lastIndex] = layerObj;
      }
    }
  };
  /**
   * this method is called on 'GPimportGetCapProposal' div click
   * and add corresponding layer to map
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  LayerImport.prototype._onGetCapResponseLayerClick = function (e) {
    if (e.target && e.target.id) {
      var proposalId = parseInt(e.target.id.substr(23), 10);

      if (isNaN(proposalId)) {
        return;
      }

      var layerInfo;

      if (this._currentImportType === "WMS") {
        // récupération des informations liées à la couche
        layerInfo = this._getCapResponseWMSLayers[proposalId]; // ajout de la couche à la carte

        this._addGetCapWMSLayer(layerInfo);
      } else if (this._currentImportType === "WMTS") {
        // récupération des informations liées à la couche
        layerInfo = this._getCapResponseWMTSLayers[proposalId]; // ajout de la couche à la carte

        this._addGetCapWMTSLayer(layerInfo);
      }
    }
  }; // ################################################################### //
  // ######### create WMS layer from getCapabilities response ######### //
  // ################################################################### //

  /**
   * this method is called by this._onGetCapResponseLayerClick
   * and add WMS layer to map using parameters from getCapabilities response
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @private
   */


  LayerImport.prototype._addGetCapWMSLayer = function (layerInfo) {
    var map = this.getMap();

    if (!map) {
      logger.warn("[ol.control.LayerImport] _addGetCapWMSLayer error : map is not defined");
      return;
    }

    if (!layerInfo) {
      logger.warn("[ol.control.LayerImport] _addGetCapWMSLayer error : layerInfo is not defined");
      return;
    } // récupération de la projection de la carte


    var mapProjCode = this._getMapProjectionCode();

    var wmsSourceOptions = {}; // Récupération de l'url

    var getMapUrl = this._getWMSLayerGetMapUrl(); // on essaie de récupérer l'url du service dans le getCapbilities


    if (getMapUrl) {
      wmsSourceOptions.url = getMapUrl;
    } else {
      // sinon, on récupère l'url du getCapabilities, à laquelle on enlève éventuellement les paramètres
      var questionMarkIndex = this._getCapRequestUrl.indexOf("?");

      if (questionMarkIndex !== -1) {
        wmsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
      } else {
        wmsSourceOptions.url = this._getCapRequestUrl;
      }
    }

    wmsSourceOptions.params = {};

    if (layerInfo.Name) {
      wmsSourceOptions.params["LAYERS"] = layerInfo.Name;
    } else {
      logger.warn("[ol.control.LayerImport] unable to add wms layer : mandatory layer 'name' parameter cannot be found", layerInfo);
      return;
    }

    wmsSourceOptions.params["SERVICE"] = "WMS";

    if (this._getCapResponseWMS.version) {
      wmsSourceOptions.params["VERSION"] = this._getCapResponseWMS.version;
    } // on a déjà vérifié que la couche peut être reprojetée,
    // on vérifie que la couche ait une projection compatible avec celle de la carte
    // ou soit connue par proj4js


    var projection = layerInfo._projection;

    if (!projection) {
      logger.warn("[ol.control.LayerImport] wms layer cannot be added to map : unknown projection");
      return;
    } else if (projection !== mapProjCode) {
      // si la projection de la carte n'est pas disponible pour cette couche,
      // on spécifie une projection (qui doit avoir été définie dans proj4js) pour reprojection par Openlayers
      wmsSourceOptions.projection = projection;
    } // récupération du premier style disponible (pas d'info default?)


    var legend;

    if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
      var style = layerInfo.Style[0];
      wmsSourceOptions.params["STYLES"] = style.Name;

      if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
        legend = style.LegendURL[0].OnlineResource;
      }
    } // Création de la source (tester un try catch ?)


    var wmsSource = new ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15___default.a(wmsSourceOptions); // ajout des informations pour le layerSwitcher (titre, description, legendes, metadata) ou originators

    this._getWMSLayerInfoForLayerSwitcher(layerInfo, legend, wmsSource);

    var layerTileOptions = {};
    layerTileOptions["source"] = wmsSource; // récupération des résolutions min et max de la layer à partir des dénominateurs d'échelle

    this._getWMSLayerMinMaxResolution(layerInfo, mapProjCode, layerTileOptions); // récupération de l'étendue (bbox)


    this._getWMSLayerExtent(layerInfo, mapProjCode, layerTileOptions); // création de la couche à partir de la source


    var wmsLayer = new ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12___default.a(layerTileOptions); // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)

    wmsLayer.gpResultLayerId = "layerimport:WMS"; // on rajoute le champ gpGFIparams permettant d'identifier si la couche est queryable, et de transmettre les formats reconnus par GetFeatureInfo

    if (layerInfo.queryable) {
      wmsLayer.gpGFIparams = {
        queryable: true
      }; // récupération des différents formats reconnus par le GetFeatureInfo

      if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetFeatureInfo && this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format && Array.isArray(this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format)) {
        wmsLayer.gpGFIparams.formats = this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format;
      }
    }

    map.addLayer(wmsLayer);
  };
  /**
   * this method is called by this._addGetCapWMSLayer
   * and gets service getMap request url
   *
   * @return {String} getmapurl - service getMap request url
   * @private
   */


  LayerImport.prototype._getWMSLayerGetMapUrl = function () {
    var getmapurl;

    if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetMap) {
      var getmap = this._getCapResponseWMS.Capability.Request.GetMap;

      if (getmap.DCPType && Array.isArray(getmap.DCPType) && getmap.DCPType.length !== 0) {
        var url = getmap.DCPType[0];

        if (url && url.HTTP && url.HTTP.Get) {
          getmapurl = url.HTTP.Get.OnlineResource;
        }
      }
    }

    return getmapurl;
  };
  /**
   * this method is called by this._addGetCapWMSLayer
   * and gets a projection both available for a given layer and already defined in proj4js (ol.proj)
   * (openlayers raster reprojection will be then able to reproject layer in map projection)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
   * @return {String} projection - ol.proj projection alias (e.g. "EPSG:4326")
   * @private
   */


  LayerImport.prototype._getWMSLayerProjection = function (layerInfo, mapProjCode) {
    var projection;

    if (!layerInfo || _typeof(layerInfo) !== "object") {
      logger.warn("missing layer information (from getCapabilities)");
      return;
    } // on va parcourir la liste des CRS disponibles pour la couche
    // si on trouve la projection de la carte : c'est parfait
    // si on trouve une projection qui est connue par ol.proj : Openlayers gère la reprojection


    var CRSList = layerInfo.CRS;

    if (Array.isArray(CRSList)) {
      for (var i = 0; i < CRSList.length; i++) {
        var layerCRS = CRSList[i];

        if (layerCRS === mapProjCode) {
          projection = layerCRS;
          break;
        } else {
          if (layerCRS && typeof layerCRS === "string") {
            if (Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(layerCRS) || Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(layerCRS.toUpperCase())) {
              projection = layerCRS;
              break;
            }
          }
        }
      }
    }

    return projection;
  };
  /**
   * this method is called by this._addGetCapWMSLayer
   * and sets minResolution and maxResolution parameters for WMS layer (if available in getCapabilities response)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
   * @param {Object} layerTileOptions - options for ol.layer.Tile (to be filled)
   * @private
   */


  LayerImport.prototype._getWMSLayerMinMaxResolution = function (layerInfo, mapProjCode, layerTileOptions) {
    // récupération des résolutions min et max à partir des dénominateurs d'échelle
    var mapUnits = Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(mapProjCode).getUnits();

    if (mapUnits === "m") {
      // info : 1 pixel = 0.00028 m
      if (layerInfo.MinScaleDenominator) {
        layerTileOptions.minResolution = layerInfo.MinScaleDenominator * 0.00028;
      }

      if (layerInfo.MaxScaleDenominator) {
        layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * 0.00028;
      }
    } else if (mapUnits === "degrees") {
      // info : 6378137 * 2 * pi / 360 = rayon de la terre (ellipsoide WGS84)
      var cste = 0.00028 * 180 / (Math.PI * 6378137);

      if (layerInfo.MinScaleDenominator) {
        layerTileOptions.minResolution = layerInfo.MinScaleDenominator * cste;
      }

      if (layerInfo.MaxScaleDenominator) {
        layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * cste;
      }
    }
  };
  /**
   * this method is called by this._addGetCapWMSLayer
   * and sets extent for WMS layer in map projection (if available in getCapabilities response)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
   * @param {Object} layerTileOptions - options for ol.layer.Tile (to be filled)
   * @private
   */


  LayerImport.prototype._getWMSLayerExtent = function (layerInfo, mapProjCode, layerTileOptions) {
    if (!layerInfo) {
      logger.warn("[ol.control.LayerImport] _getWMSLayerExtent error : layerInfo is not defined");
      return;
    } // récupération des 2 propriétés qui peuvent spécifier l'étendue (bbox) selon les specs OGC WMS 1.3.0 :
    // 1. layerInfo.EX_GeographicBoundingBox est un tableau de type [westBoundLongitude, southBoundLatitude, eastBoundLongitude, northBoundLatitude] en WGS84


    var exGeographicBoundingBox = layerInfo["EX_GeographicBoundingBox"]; // 2. layerInfo.BoundingBox est un tableau dont chaque élément est un objet (balise bbox) avec les propriétés suivantes :
    // crs (String) et extent (tableau de type [minx, miny, maxx, maxy])

    var boundingBox = layerInfo.BoundingBox;

    if (exGeographicBoundingBox && Array.isArray(exGeographicBoundingBox)) {
      if (mapProjCode === "EPSG:4326") {
        // si la projection de la carte est la même que celle de l'extent (EPSG:4326), on la passe telle quelle
        layerTileOptions.extent = exGeographicBoundingBox;
      } else {
        layerTileOptions.extent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["transformExtent"])(exGeographicBoundingBox, "EPSG:4326", mapProjCode);
      } // si jamais EX_GeographicBoundingBox n'est pas ou est mal renseigné, on essaie de récupérer via le paramètre BoundingBox

    } else if (boundingBox && Array.isArray(boundingBox)) {
      var crs;
      var extent;

      for (var i = 0; i < boundingBox.length; i++) {
        // on peut avoir plusieurs BoundingBox
        crs = boundingBox[i].crs;
        extent = boundingBox[i].extent;

        if (crs) {
          if (crs === mapProjCode) {
            // si la bbox est dans la projection de la carte, on la passe telle quelle
            layerTileOptions.extent = extent;
            break;
          } else {
            if (typeof crs === "string") {
              var olProj = Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(crs) ? Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(crs) : Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(crs.toUpperCase()); // if ( olGetProj(crs) || olGetProj(crs.toUpperCase()) ) {

              if (olProj) {
                // si la bbox est dans une projection connue, on va la reprojeter
                // tout d'abord, on gère le cas des systèmes EPSG géographiques : inversion des axes x et y
                if (olProj.getUnits() === "degrees" && crs.toUpperCase().indexOf("EPSG") === 0) {
                  // le tableau extent est inversé, on a besoin de : [miny, minx, maxx, maxy]
                  var reversedExtent = [extent[1], extent[0], extent[3], extent[2]];
                  layerTileOptions.extent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["transformExtent"])(reversedExtent, olProj, mapProjCode);
                } else {
                  // reprojection dans la projection de la carte
                  layerTileOptions.extent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["transformExtent"])(extent, olProj, mapProjCode);
                }

                break;
              }
            }
          }
        }
      }
    }
  };
  /**
   * this method is called by this._addGetCapWMSLayer
   * and sets more information about layer (legends, title, description, metadata, originators) for layerSwitcher or attributions controls
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} legend - legend url
   * @param {Object} wmsSource - options for ol.source.TileWMS (to be filled)
   * @private
   */


  LayerImport.prototype._getWMSLayerInfoForLayerSwitcher = function (layerInfo, legend, wmsSource) {
    // ajout des informations pour le layerSwitcher (titre, description)
    if (layerInfo.Title) {
      wmsSource._title = layerInfo.Title;
      wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
    } else {
      wmsSource._title = layerInfo.Name;
      wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Name;
    } // ajout de légende si on en a trouvé


    if (legend) {
      wmsSource._legends = [{
        url: legend
      }];
    } // ajout d'éventuelles métadonnées


    if (layerInfo.MetadataURL && Array.isArray(layerInfo.MetadataURL)) {
      wmsSource._metadata = [];

      for (var i = 0; i < layerInfo.MetadataURL.length; i++) {
        var metadata = layerInfo.MetadataURL[i].OnlineResource;

        if (metadata) {
          wmsSource._metadata.push({
            url: metadata
          });
        }
      }
    } // ajout d'éventuelles attributions / originators


    if (layerInfo.Attribution) {
      var attribution = layerInfo.Attribution;
      wmsSource._originators = {};

      if (attribution.OnlineResource) {
        wmsSource._originators.url = attribution.OnlineResource;
      }

      if (attribution.Title) {
        wmsSource._originators.name = wmsSource._originators.attribution = attribution.Title;
      }

      if (attribution.LogoURL && attribution.LogoURL.OnlineResource) {
        wmsSource._originators.logo = attribution.LogoURL.OnlineResource;
      }
    }
  }; // ################################################################### //
  // ######### create WMTS layer from getCapabilities response ######### //
  // ################################################################### //

  /**
   * this method is called by this._onGetCapResponseLayerClick
   * and add WMTS layer to map using parameters from getCapabilities response
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @private
   */


  LayerImport.prototype._addGetCapWMTSLayer = function (layerInfo) {
    if (!layerInfo || !layerInfo.Identifier) {
      logger.warn("[ol.control.LayerImport] layer information not found in getCapabilities response for layer ");
      return;
    }

    var map = this.getMap();

    if (!map) {
      return;
    }

    var wmtsSourceOptions = {};
    wmtsSourceOptions.layer = layerInfo.Identifier; // service version

    if (this._getCapResponseWMTS.version) {
      wmtsSourceOptions.version = this._getCapResponseWMTS.version;
    } // Récupération de l'url


    var getMapUrl = this._getWMTSLayerGetTileUrl(); // on essaie de récupérer l'url du service dans le getCapbilities


    if (getMapUrl) {
      wmtsSourceOptions.url = getMapUrl;
    } else {
      // sinon, on récupère l'url du getCapabilities, à laquelle on enlève éventuellement les paramètres
      var questionMarkIndex = this._getCapRequestUrl.indexOf("?");

      if (questionMarkIndex !== -1) {
        wmtsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
      } else {
        wmtsSourceOptions.url = this._getCapRequestUrl;
      }
    } // Récupération des informations de la pyramide (tileGrid information) : matrixIds, resolutions, origin et projection


    var tmsOptions = this._getTMSParams(layerInfo);

    wmtsSourceOptions.matrixSet = tmsOptions.tms;
    wmtsSourceOptions.projection = tmsOptions.projCode;
    wmtsSourceOptions.tileGrid = new ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_4___default.a({
      resolutions: tmsOptions.resolutions,
      matrixIds: tmsOptions.matrixIds,
      origin: tmsOptions.origin
    }); // Récupération du style par défaut

    var defaultStyle;
    var legend;

    if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
      var style;

      for (var s = 0; s < layerInfo.Style.length; s++) {
        style = layerInfo.Style[s]; // on récupère le style

        defaultStyle = style.Identifier;

        if (style.isDefault) {
          // si c'est celui par défaut, on le garde (on ne boucle plus sur les autres styles)
          break;
        } // et une éventuelle légende


        if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
          legend = style.LegendURL[0].href;
        }
      }
    }

    if (defaultStyle == null) {
      logger.warn("[ol.control.LayerImport] style information not found in getCapabilities response for layer " + layerInfo.Identifier);
    }

    wmtsSourceOptions.style = defaultStyle; // Récupération du format (le premier trouvé)

    var format;

    if (layerInfo.Format && Array.isArray(layerInfo.Format)) {
      format = layerInfo.Format[0];
    }

    if (format == null) {
      logger.warn("[ol.control.LayerImport] format information not found in getCapabilities response for layer " + layerInfo.Identifier);
    }

    wmtsSourceOptions.format = format; // Création de la source (tester un try catch ?)

    var wmtsSource = new ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16___default.a(wmtsSourceOptions); // ajout des informations pour le layerSwitcher (titre, description)

    if (layerInfo.Title) {
      wmtsSource._title = layerInfo.Title;
      wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
    } else {
      wmtsSource._title = layerInfo.Identifier;
      wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Identifier;
    } // ajout d'une éventuelle légende


    if (legend) {
      wmtsSource._legends = [{
        url: legend
      }];
    }

    var layerTileOptions = {};
    layerTileOptions.source = wmtsSource; // récupération de l'étendue (bbox)

    layerTileOptions.extent = this._getWMTSLayerExtent(layerInfo);
    var wmtsLayer;

    try {
      wmtsLayer = new ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12___default.a(layerTileOptions);
    } catch (e) {
      logger.warn("[ol.control.LayerImport] an error occured while trying to create ol.layer.Tile from getCapabilities information. error : ", e);
      return;
    } // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)


    wmtsLayer.gpResultLayerId = "layerimport:WMTS";
    map.addLayer(wmtsLayer);
  };
  /**
   * this method is called by this._addGetCapWMTSLayer
   * and gets service getTile request url
   *
   * @return {String} gettileurl - service getTile request url
   * @private
   */


  LayerImport.prototype._getWMTSLayerGetTileUrl = function () {
    var gettileurl;

    if (this._getCapResponseWMTS && this._getCapResponseWMTS.OperationsMetadata && this._getCapResponseWMTS.OperationsMetadata.GetTile) {
      var gettile = this._getCapResponseWMTS.OperationsMetadata.GetTile;

      if (gettile.DCP && gettile.DCP.HTTP && gettile.DCP.HTTP.Get && Array.isArray(gettile.DCP.HTTP.Get) && gettile.DCP.HTTP.Get.length !== 0) {
        gettileurl = gettile.DCP.HTTP.Get[0].href;
      }
    }

    return gettileurl;
  };
  /**
   * this method is called by this._displayGetCapResponseLayers
   * and gets layer TileMatrixSet projection if defined in proj4js
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {Object} getCapResponseWMTS - whole getCapabilities response
   * @return {String} projection - ol.proj projection alias (e.g. "EPSG:4326")
   * @private
   */


  LayerImport.prototype._getWMTSLayerProjection = function (layerInfo, getCapResponseWMTS) {
    var projection;

    if (!layerInfo || _typeof(layerInfo) !== "object") {
      logger.warn("missing layer information (from getCapabilities)");
      return;
    }

    if (!getCapResponseWMTS || _typeof(getCapResponseWMTS) !== "object") {
      logger.warn("missing getCapabilities response");
      return;
    }

    if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
      var tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;
      var crs;

      if (getCapResponseWMTS.Contents && Array.isArray(getCapResponseWMTS.Contents.TileMatrixSet)) {
        var tileMatrixSets = getCapResponseWMTS.Contents.TileMatrixSet;

        for (var i = 0; i < tileMatrixSets.length; i++) {
          if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
            // on a trouvé le TMS correspondant
            var tileMatrixSet = tileMatrixSets[i];
            crs = tileMatrixSet.SupportedCRS;

            if (crs && typeof crs === "string") {
              if (Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(crs) || Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(crs.toUpperCase())) {
                projection = crs;
              }
            }

            break;
          }
        }
      }
    }

    ;
    return projection;
  };
  /**
   * this method is called by this._addGetCapWMTSLayer
   * and get ol.tileGrid.WMTS parameters using getCapabilities response
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @return {Object} tmsOptions - ol.tileGrid.WMTS options
   * @private
   */


  LayerImport.prototype._getTMSParams = function (layerInfo) {
    var tmsOptions = {};
    var matrixIds = [];
    var resolutions = [];
    var origin = [];
    var tms;
    var projCode;
    var projection; // TODO : recup TOUS les autres params d'un tileGrid ! (tileSize, width...)

    var map = this.getMap();

    if (!map) {
      return;
    } // Récupération des informations de la pyramide (tileGrid information) : matrixIds, resolutions, origin


    if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
      tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;

      if (this._getCapResponseWMTS.Contents && Array.isArray(this._getCapResponseWMTS.Contents.TileMatrixSet)) {
        var tileMatrixSets = this._getCapResponseWMTS.Contents.TileMatrixSet;

        for (var i = 0; i < tileMatrixSets.length; i++) {
          if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
            // on a trouvé le TMS correspondant
            var tileMatrixSet = tileMatrixSets[i];
            var tilematrix;
            var id;
            var scaledenominator;
            var resolution;
            var units;

            if (tileMatrixSet.SupportedCRS) {
              projCode = tileMatrixSet.SupportedCRS;
              projection = Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["get"])(projCode);
            }

            if (projection && projection.getUnits) {
              units = projection.getUnits();
            }

            if (Array.isArray(tileMatrixSet.TileMatrix)) {
              for (var j = 0; j < tileMatrixSet.TileMatrix.length; j++) {
                // construction du tableau des matrixIds
                tilematrix = tileMatrixSet.TileMatrix[j];

                if (tilematrix.Identifier != null) {
                  id = parseInt(tilematrix.Identifier, 10);
                  matrixIds.push(id);
                } // construction du tableau des résolutions, calculées à partir des dénominateurs d'échelle (scaledenominator)


                scaledenominator = tilematrix.ScaleDenominator; // calcul des résolutions selon la projection du TMS : selon si on a des coordonnées planes ou géographiques

                if (units === "degrees") {
                  // info : 6378137 * 2 * pi / 360 = rayon de la terre (ellipsoide WGS84)
                  resolution = scaledenominator * 0.00028 * 180 / (Math.PI * 6378137);
                } else {
                  // info : 1 pixel = 0.00028 m
                  resolution = scaledenominator * 0.00028;
                }

                resolutions.push(resolution);
                origin = tilematrix.TopLeftCorner;
              }
            } // tri des résolutions par ordre décroissant


            if (resolutions.sort !== undefined) {
              resolutions.sort(function (x, y) {
                return y - x;
              });
            } // tri des identifiants des niveaux de pyramide (matrixIds) par ordre croissant


            if (matrixIds.sort !== undefined) {
              matrixIds.sort(function (x, y) {
                return x - y;
              });
            }
          }
        }
      } else {
        logger.warn("[ol.control.LayerImport] TileMatrixSet data not found in getCapabilities response for layer " + layerInfo.Identifier);
      }
    } else {
      return;
    }

    tmsOptions.tms = tms;
    tmsOptions.projCode = projCode;
    tmsOptions.matrixIds = matrixIds;
    tmsOptions.resolutions = resolutions;
    tmsOptions.origin = origin;
    return tmsOptions;
  };
  /**
   * this method is called by this._addGetCapWMTSLayer
   * and sets extent for WMTS layer in map projection (if available in getCapabilities response)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @return {Array} extent - layer extent
   * @private
   */


  LayerImport.prototype._getWMTSLayerExtent = function (layerInfo) {
    var extent;

    var mapProjCode = this._getMapProjectionCode(); // récupération de l'étendue (bbox)


    if (layerInfo.WGS84BoundingBox && Array.isArray(layerInfo.WGS84BoundingBox)) {
      extent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_6__["transformExtent"])(layerInfo.WGS84BoundingBox, "EPSG:4326", mapProjCode);
    }

    return extent;
  }; // ################################################################### //
  // ################################ utils ############################ //
  // ################################################################### //

  /**
   * gets control map projection code
   *
   * @return {String} mapProjCode - control map projection code (e.g. "EPSG:3857")
   * @private
   */


  LayerImport.prototype._getMapProjectionCode = function () {
    var map = this.getMap();

    if (!map || !map.getView || !map.getView().getProjection) {
      logger.warn("unable to get layerimport's map");
      return;
    }

    var mapProjCode = map.getView().getProjection().getCode();
    return mapProjCode;
  }; // ################################################################### //
  // ################################ clean ############################ //
  // ################################################################### //

  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */


  LayerImport.prototype._displayWaitingContainer = function () {
    this._waitingContainer.className = "GPimportWaitingContainerVisible";
    this._waiting = true; // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)
    // si on est toujours en attente (si la requête est bloquée par exemple)

    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }

    var context = this;
    this._timer = setTimeout(function () {
      if (context._waiting === true) {
        context._hideWaitingContainer();
      } else {
        if (context._timer) {
          clearTimeout(context._timer);
        }
      }
    }, 16000);
  };
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */


  LayerImport.prototype._hideWaitingContainer = function () {
    if (this._waiting) {
      this._waitingContainer.className = "GPimportWaitingContainerHidden";
      this._waiting = false;
      clearTimeout(this._timer);
      this._timer = null;
    }
  };
  /**
   * this method empties getCap results list (DOM element)
   *
   * @private
   */


  LayerImport.prototype.cleanGetCapResultsList = function () {
    this._getCapRequestUrl = null;
    this._getCapResponseWMS = null;
    this._getCapResponseWMTS = null;
    this._getCapResponseWMSLayers = null;
    this._getCapResponseWMTSLayers = null;

    if (this._getCapResultsListContainer) {
      while (this._getCapResultsListContainer.firstChild) {
        this._getCapResultsListContainer.removeChild(this._getCapResultsListContainer.firstChild);
      }
    }
  };
  /**
   * this method empties MapBox results list (DOM element)
   *
   * @private
   */


  LayerImport.prototype.cleanMapBoxResultsList = function () {
    this.editor = null;
    this._mapBoxObj = null;

    if (this._mapBoxResultsListContainer) {
      while (this._mapBoxResultsListContainer.firstChild) {
        this._mapBoxResultsListContainer.removeChild(this._mapBoxResultsListContainer.firstChild);
      }
    }
  };

  return LayerImport;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (LayerImport); // Expose LayerImport as ol.control.LayerImport (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.LayerImport = LayerImport;
}

/***/ }),
/* 212 */
/***/ (function(module, exports) {

module.exports = ol.tilegrid;

/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = ol.format.MVT;

/***/ }),
/* 214 */
/***/ (function(module, exports) {

module.exports = ol.format.WMSCapabilities;

/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = ol.format.WMTSCapabilities;

/***/ }),
/* 216 */
/***/ (function(module, exports) {

module.exports = ol.layer.VectorTile;

/***/ }),
/* 217 */
/***/ (function(module, exports) {

module.exports = ol.source.TileJSON;

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyStyle", function() { return applyStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyBackground", function() { return applyBackground; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupVectorSource", function() { return setupVectorSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return olms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayer", function() { return getLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayers", function() { return getLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSource", function() { return getSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_finalizeLayer", function() { return finalizeLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getFonts", function() { return getFonts; });
/* harmony import */ var ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(157);
/* harmony import */ var ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_format_MVT_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(213);
/* harmony import */ var ol_format_MVT_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_format_MVT_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(219);
/* harmony import */ var ol_Map_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Map_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(220);
/* harmony import */ var ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(217);
/* harmony import */ var ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(167);
/* harmony import */ var ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(216);
/* harmony import */ var ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(43);
/* harmony import */ var ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_View_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(221);
/* harmony import */ var ol_View_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_View_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _stylefunction_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(222);
/* harmony import */ var webfont_matcher_lib_fonts_google_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(262);
/* harmony import */ var webfont_matcher_lib_fonts_google_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(webfont_matcher_lib_fonts_google_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(252);
/* harmony import */ var mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(253);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(258);
/* harmony import */ var ol_tilegrid_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(212);
/* harmony import */ var ol_tilegrid_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(ol_tilegrid_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var ol_proj_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(166);
/* harmony import */ var ol_proj_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(ol_proj_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var ol_Observable_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(171);
/* harmony import */ var ol_Observable_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(ol_Observable_js__WEBPACK_IMPORTED_MODULE_18__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*
ol-mapbox-style - Use Mapbox Style objects with OpenLayers
Copyright 2016-present ol-mapbox-style contributors
License: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE
*/



















/**
 * @typedef {import("ol/Map").default} PluggableMap
 * @typedef {import("ol/layer/Layer").default} Layer
 * @typedef {import("ol/source/Source").default} Source
 * @private
 */

var tilejsonCache = {};
var fontFamilyRegEx = /font-family: ?([^;]*);/;
var stripQuotesRegEx = /("|')/g;
var loadedFontFamilies;

function hasFontFamily(family) {
  if (!loadedFontFamilies) {
    loadedFontFamilies = {};
    var styleSheets = document.styleSheets;

    for (var i = 0, ii = styleSheets.length; i < ii; ++i) {
      var styleSheet =
      /** @type {CSSStyleSheet} */
      styleSheets[i];

      try {
        var cssRules = styleSheet.rules || styleSheet.cssRules;

        if (cssRules) {
          for (var j = 0, jj = cssRules.length; j < jj; ++j) {
            var cssRule = cssRules[j];

            if (cssRule.type == 5) {
              var match = cssRule.cssText.match(fontFamilyRegEx);
              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;
            }
          }
        }
      } catch (e) {// empty catch block
      }
    }
  }

  return family in loadedFontFamilies;
}

var processedFontFamilies = {};
var googleFamilies = webfont_matcher_lib_fonts_google_js__WEBPACK_IMPORTED_MODULE_12___default.a.getNames();
/**
 * @private
 * @param {Array} fonts Fonts.
 * @return {Array} Processed fonts.
 */

function getFonts(fonts) {
  var fontsKey = fonts.toString();

  if (fontsKey in processedFontFamilies) {
    return fonts;
  }

  var googleFontDescriptions = fonts.map(function (font) {
    var parts = mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_13___default()(font, 1).split(' ');
    return [parts.slice(3).join(' ').replace(/"/g, ''), parts[1] + parts[0]];
  });

  for (var i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {
    var googleFontDescription = googleFontDescriptions[i];
    var family = googleFontDescription[0];

    if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {
      var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1];

      if (!document.querySelector('link[href="' + fontUrl + '"]')) {
        var markup = document.createElement('link');
        markup.href = fontUrl;
        markup.rel = 'stylesheet';
        document.head.appendChild(markup);
      }
    }
  }

  processedFontFamilies[fontsKey] = true;
  return fonts;
}

var spriteRegEx = /^(.*)(\?.*)$/;

function withPath(url, path) {
  if (path && url.indexOf('.') === 0) {
    url = path + url;
  }

  return url;
}

function toSpriteUrl(url, path, extension) {
  url = withPath(url, path);
  var parts = url.match(spriteRegEx);
  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;
}
/**
 * ```js
 * import {applyStyle} from 'ol-mapbox-style';
 * ```
 *
 * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`
 * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function
 * will render all layers from the `glStyle` object that use the specified
 * `source`, or a subset of layers from the same source. The source needs to be
 * a `"type": "vector"` or `"type": "geojson"` source.
 *
 * Two additional properties will be set on the provided layer:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} source `source` key or an array of layer `id`s from the
 * Mapbox Style object. When a `source` key is provided, all layers for the
 * specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {string} [path=undefined] Path of the style file. Only required when
 * a relative path is used with the `"sprite"` property of the style.
 * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */


function applyStyle(layer, glStyle, source, path, resolutions) {
  return new Promise(function (resolve, reject) {
    // TODO: figure out where best place to check source type is
    // Note that the source arg is an array of gl layer ids and each must be
    // dereferenced to get source type to validate
    if (_typeof(glStyle) != 'object') {
      glStyle = JSON.parse(glStyle);
    }

    if (glStyle.version != 8) {
      return reject(new Error('glStyle version 8 required.'));
    }

    if (!(layer instanceof ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_6___default.a || layer instanceof ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_8___default.a)) {
      return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));
    }

    var spriteScale, spriteData, spriteImageUrl, style;

    function onChange() {
      if (!style && (!glStyle.sprite || spriteData)) {
        style = Object(_stylefunction_js__WEBPACK_IMPORTED_MODULE_11__["default"])(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);

        if (!layer.getStyle()) {
          reject(new Error("Nothing to show for source [".concat(source, "]")));
        } else {
          resolve();
        }
      } else if (style) {
        layer.setStyle(style);
        resolve();
      } else {
        reject(new Error('Something went wrong trying to apply style.'));
      }
    }

    if (glStyle.sprite) {
      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
      var sizeFactor_1 = spriteScale == 0.5 ? '@2x' : '';
      var spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.json');
      fetch(spriteUrl_1, {
        credentials: 'same-origin'
      }).then(function (response) {
        if (!response.ok && sizeFactor_1 !== '') {
          spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, '.json');
          return fetch(spriteUrl_1, {
            credentials: 'same-origin'
          });
        } else {
          return response;
        }
      }).then(function (response) {
        if (response.ok) {
          return response.json();
        } else {
          reject(new Error("Problem fetching sprite from ".concat(spriteUrl_1, ": ").concat(response.statusText)));
        }
      }).then(function (spritesJson) {
        if (spritesJson === undefined) {
          return reject(new Error('No sprites found.'));
        }

        spriteData = spritesJson;
        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.png');
        onChange();
      })["catch"](function (err) {
        reject(new Error("Sprites cannot be loaded: ".concat(spriteUrl_1, ": ").concat(err.message)));
      });
    } else {
      onChange();
    }
  });
}
var emptyObj = {};

function setBackground(mapOrLayer, layer) {
  var background = {
    id: layer.id,
    type: layer.type
  };
  var functionCache = {};

  function updateStyle(resolution) {
    var layout = layer.layout || {};
    var paint = layer.paint || {};
    background['paint'] = paint;
    var zoom = typeof mapOrLayer.getSource === 'function' ? mapOrLayer.getSource().getTileGrid().getZForResolution(resolution) : mapOrLayer.getView().getZoom();
    var element = typeof mapOrLayer.getTargetElement === 'function' ? mapOrLayer.getTargetElement() : undefined;
    var bg, opacity;

    if (paint['background-color'] !== undefined) {
      bg = Object(_stylefunction_js__WEBPACK_IMPORTED_MODULE_11__["getValue"])(background, 'paint', 'background-color', zoom, emptyObj, functionCache);

      if (element) {
        element.style.background = _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_14__["Color"].parse(bg).toString();
      }
    }

    if (paint['background-opacity'] !== undefined) {
      opacity = Object(_stylefunction_js__WEBPACK_IMPORTED_MODULE_11__["getValue"])(background, 'paint', 'background-opacity', zoom, emptyObj, functionCache);

      if (element) {
        element.style.opacity = opacity;
      }
    }

    if (layout.visibility == 'none') {
      if (element) {
        element.style.backgroundColor = '';
        element.style.opacity = '';
        return undefined;
      }
    }

    return Object(_stylefunction_js__WEBPACK_IMPORTED_MODULE_11__["_colorWithOpacity"])(bg, opacity);
  }

  if (typeof mapOrLayer.getTargetElement === 'function') {
    if (mapOrLayer.getTargetElement()) {
      updateStyle();
    }

    mapOrLayer.on(['change:resolution', 'change:target'], updateStyle);
  } else if (typeof mapOrLayer.setBackground === 'function') {
    mapOrLayer.setBackground(updateStyle);
  } else {
    throw new Error('Unable to apply background.');
  }
}
/**
 * ```js
 * import {applyBackground} from 'ol-mapbox-style';
 * ```
 * Applies properties of the Mapbox Style's first `background` layer to the
 * provided map or VectorTile layer.
 * @param {PluggableMap|VectorTileLayer} mapOrLayer OpenLayers Map or VectorTile layer.
 * @param {Object} glStyle Mapbox Style object.
 */


function applyBackground(mapOrLayer, glStyle) {
  glStyle.layers.some(function (l) {
    if (l.type == 'background') {
      setBackground(mapOrLayer, l);
      return true;
    }
  });
}

function getSourceIdByRef(layers, ref) {
  var sourceId;
  layers.some(function (layer) {
    if (layer.id == ref) {
      sourceId = layer.source;
      return true;
    }
  });
  return sourceId;
}

function extentFromTileJSON(tileJSON) {
  var bounds = tileJSON.bounds;

  if (bounds) {
    var ll = Object(ol_proj_js__WEBPACK_IMPORTED_MODULE_17__["fromLonLat"])([bounds[0], bounds[1]]);
    var tr = Object(ol_proj_js__WEBPACK_IMPORTED_MODULE_17__["fromLonLat"])([bounds[2], bounds[3]]);
    return [ll[0], ll[1], tr[0], tr[1]];
  }
}
/**
 * Creates an OpenLayers VectorTile source for a gl source entry.
 * @param {Object} glSource "source" entry from a Mapbox Style object.
 * @param {string|undefined} url URL to use for the source. This is expected to be the complete http(s) url,
 * with access key applied.When not provided, `glSource.tiles` has to be set.
 * @return {Promise<import("ol/source/VectorTile").default>} Promise resolving to a VectorTile source.
 * @private
 */


function setupVectorSource(glSource, url) {
  glSource = Object(_util_js__WEBPACK_IMPORTED_MODULE_15__["assign"])({}, glSource);
  var cacheKey = [url, JSON.stringify(glSource)].toString();
  var tilejson = tilejsonCache[cacheKey];

  if (!tilejson) {
    tilejson = new ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_4___default.a({
      url: glSource.tiles ? undefined : url,
      tileJSON: glSource.tiles ? glSource : undefined
    });
    tilejsonCache[cacheKey] = tilejson;
  }

  return new Promise(function (resolve) {
    var key = tilejson.on('change', function () {
      var state = tilejson.getState();

      if (state === 'ready') {
        var tileJSONDoc = tilejson.getTileJSON();
        var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];

        if (url) {
          for (var i = 0, ii = tiles.length; i < ii; ++i) {
            tiles[i] = decodeURI(new URL(tiles[i], url).href);
          }
        }

        var tileGrid = tilejson.getTileGrid();
        var extent = extentFromTileJSON(tileJSONDoc);
        var minZoom = tileJSONDoc.minzoom || 0;
        var maxZoom = tileJSONDoc.maxzoom || 22;
        var source = tilejson.get('ol-source');

        if (source === undefined) {
          source = new ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_9___default.a({
            attributions: tilejson.getAttributions(),
            format: new ol_format_MVT_js__WEBPACK_IMPORTED_MODULE_1___default.a(),
            tileGrid: new ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3___default.a({
              origin: tileGrid.getOrigin(0),
              extent: extent || tileGrid.getExtent(),
              minZoom: minZoom,
              resolutions: _util_js__WEBPACK_IMPORTED_MODULE_15__["defaultResolutions"].slice(0, maxZoom + 1),
              tileSize: 512
            }),
            urls: tiles
          });
          tilejson.set('ol-source', source);
        }

        Object(ol_Observable_js__WEBPACK_IMPORTED_MODULE_18__["unByKey"])(key);
        resolve(source);
      } else if (state === 'error') {
        tilejson.set('ol-source', null);
        Object(ol_Observable_js__WEBPACK_IMPORTED_MODULE_18__["unByKey"])(key);
        resolve(undefined);
      }
    });

    if (tilejson.getState() === 'ready') {
      tilejson.changed();
    }
  });
}

function setupVectorLayer(glSource, url) {
  var layer = new ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_8___default.a({
    declutter: true,
    visible: false
  });
  setupVectorSource(glSource, url).then(function (source) {
    layer.setSource(source);
  });
  return layer;
}

function setupRasterLayer(glSource, url) {
  var layer = new ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_5___default.a();
  var source = new ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_4___default.a({
    transition: 0,
    url: glSource.tiles ? undefined : url,
    tileJSON: glSource.tiles ? glSource : undefined,
    crossOrigin: 'anonymous'
  });
  var key = source.on('change', function () {
    var state = source.getState();

    if (state === 'ready') {
      Object(ol_Observable_js__WEBPACK_IMPORTED_MODULE_18__["unByKey"])(key);
      var tileJSONDoc =
      /** @type {Object} */
      source.getTileJSON();
      var extent = extentFromTileJSON(tileJSONDoc);
      var tileGrid = source.getTileGrid();
      var tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;
      var minZoom = tileJSONDoc.minzoom || 0;
      var maxZoom = tileJSONDoc.maxzoom || 22; // Only works when using ES modules
      //@ts-ignore

      source.tileGrid = new ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_3___default.a({
        origin: tileGrid.getOrigin(0),
        extent: extent || tileGrid.getExtent(),
        minZoom: minZoom,
        resolutions: Object(ol_tilegrid_js__WEBPACK_IMPORTED_MODULE_16__["createXYZ"])({
          maxZoom: maxZoom,
          tileSize: tileSize
        }).getResolutions(),
        tileSize: tileSize
      });
      layer.setSource(source);
    } else if (state === 'error') {
      Object(ol_Observable_js__WEBPACK_IMPORTED_MODULE_18__["unByKey"])(key);
      layer.setSource(undefined);
    }
  });
  source.setTileLoadFunction(function (tile, src) {
    if (src.indexOf('{bbox-epsg-3857}') != -1) {
      var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());
      src = src.replace('{bbox-epsg-3857}', bbox.toString());
    }

    var img =
    /** @type {import("ol/ImageTile").default} */
    tile.getImage();
    /** @type {HTMLImageElement} */

    img.src = src;
  });
  return layer;
}

var geoJsonFormat = new ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_0___default.a();

function setupGeoJSONLayer(glSource, path) {
  var data = glSource.data;
  var features, geoJsonUrl;

  if (typeof data == 'string') {
    geoJsonUrl = withPath(data, path);
  } else {
    features = geoJsonFormat.readFeatures(data, {
      featureProjection: 'EPSG:3857'
    });
  }

  return new ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_6___default.a({
    source: new ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_7___default.a({
      attributions: glSource.attribution,
      features: features,
      format: geoJsonFormat,
      url: geoJsonUrl
    }),
    visible: false
  });
}

function updateRasterLayerProperties(glLayer, layer, view, functionCache) {
  var zoom = view.getZoom();
  var opacity = Object(_stylefunction_js__WEBPACK_IMPORTED_MODULE_11__["getValue"])(glLayer, 'paint', 'raster-opacity', zoom, emptyObj, functionCache);
  layer.setOpacity(opacity);
}

function processStyle(glStyle, map, baseUrl, host, path, accessToken) {
  if (accessToken === void 0) {
    accessToken = '';
  }

  var promises = [];
  var view = map.getView();

  if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {
    view = new ol_View_js__WEBPACK_IMPORTED_MODULE_10___default.a({
      maxResolution: _util_js__WEBPACK_IMPORTED_MODULE_15__["defaultResolutions"][0]
    });
    map.setView(view);
  }

  if ('center' in glStyle && !view.getCenter()) {
    view.setCenter(Object(ol_proj_js__WEBPACK_IMPORTED_MODULE_17__["fromLonLat"])(glStyle.center));
  }

  if ('zoom' in glStyle && view.getZoom() === undefined) {
    view.setResolution(_util_js__WEBPACK_IMPORTED_MODULE_15__["defaultResolutions"][0] / Math.pow(2, glStyle.zoom));
  }

  if (!view.getCenter() || view.getZoom() === undefined) {
    view.fit(view.getProjection().getExtent(), {
      nearest: true,
      size: map.getSize()
    });
  }

  if (glStyle.sprite) {
    if (glStyle.sprite.indexOf('mapbox://') == 0) {
      glStyle.sprite = baseUrl + '/sprite' + accessToken;
    } else if (glStyle.sprite.indexOf('http') != 0) {
      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;
    }
  }

  var glLayers = glStyle.layers;
  var layerIds = [];
  var glLayer, glSource, glSourceId, id, layer, url;

  var _loop_1 = function _loop_1(i, ii) {
    glLayer = glLayers[i];
    var type = glLayer.type;

    if (type == 'heatmap' || type == 'hillshade') {//FIXME Unsupported layer type
    } else if (type == 'background') {
      setBackground(map, glLayer);
    } else {
      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref); // this technique assumes gl layers will be in a particular order

      if (id != glSourceId) {
        if (layerIds.length) {
          promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));
          layerIds = [];
        }

        glSource = glStyle.sources[id];
        url = glSource.url;

        if (url) {
          url = withPath(url, path);

          if (url.indexOf('mapbox://') == 0) {
            var mapid_1 = url.replace('mapbox://', '');
            glSource.tiles = ['a', 'b', 'c', 'd'].map(function (host) {
              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid_1 + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;
            });
          } else if (url.indexOf('/') === 0 && host.indexOf('http') === 0) {
            url = host + url;
          }
        }

        if (glSource.tiles) {
          glSource.tiles = glSource.tiles.map(function (url) {
            return withPath(url, path);
          });
        }

        if (glSource.type == 'vector') {
          layer = setupVectorLayer(glSource, url);
        } else if (glSource.type == 'raster') {
          layer = setupRasterLayer(glSource, url);
          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);
          var functionCache = {};
          view.on('change:resolution', updateRasterLayerProperties.bind(this_1, glLayer, layer, view, functionCache));
          updateRasterLayerProperties(glLayer, layer, view, functionCache);
        } else if (glSource.type == 'geojson') {
          layer = setupGeoJSONLayer(glSource, path);
        }

        glSourceId = id;

        if (layer) {
          layer.set('mapbox-source', glSourceId);
        }
      }

      layerIds.push(glLayer.id);
    }
  };

  var this_1 = this;

  for (var i = 0, ii = glLayers.length; i < ii; ++i) {
    _loop_1(i, ii);
  }

  promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));
  map.set('mapbox-style', glStyle);
  return Promise.all(promises);
}
/**
 * ```js
 * import olms from 'ol-mapbox-style';
 * ```
 *
 * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes
 * the map background, the layers, the center and the zoom.
 *
 * The center and zoom will only be set if present in the Mapbox Style document,
 * and if not already set on the OpenLayers map.
 *
 * Layers will be added to the OpenLayers map, without affecting any layers that
 * might already be set on the map.
 *
 * Layers added by `apply()` will have two additional properties:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * This function sets an additional `mapbox-style` property on the OpenLayers
 * map instance, which holds the Mapbox Style object.
 *
 * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url must contain an access
 * token and look like
 * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @return {Promise} A promise that resolves after all layers have been added to
 * the OpenLayers Map instance, their sources set, and their styles applied. the
 * `resolve` callback will be called with the OpenLayers Map instance as
 * argument.
 */


function olms(map, style) {
  var promise,
      accessToken = '',
      baseUrl = '',
      host = '',
      path = '';

  if (typeof map === 'string' || map instanceof HTMLElement) {
    map = new ol_Map_js__WEBPACK_IMPORTED_MODULE_2___default.a({
      target: map
    });
  }

  if (typeof style === 'string') {
    var parts = style.match(spriteRegEx);

    if (parts) {
      baseUrl = parts[1];
      accessToken = parts.length > 2 ? parts[2] : '';
    }

    promise = new Promise(function (resolve, reject) {
      fetch(style, {
        credentials: 'same-origin'
      }).then(function (response) {
        return response.json();
      }).then(function (glStyle) {
        var a =
        /** @type {HTMLAnchorElement} */
        document.createElement('A');
        a.href = style;
        var href = a.href;
        path = a.pathname.split('/').slice(0, -1).join('/') + '/';
        host = href.substr(0, href.indexOf(path));
        processStyle(glStyle, map, baseUrl, host, path, accessToken).then(function () {
          resolve(map);
        })["catch"](reject);
      })["catch"](function (err) {
        reject(new Error("Could not load ".concat(style, ": ").concat(err.message)));
      });
    });
  } else {
    promise = new Promise(function (resolve, reject) {
      processStyle(style, map).then(function () {
        resolve(map);
      })["catch"](reject);
    });
  }

  return promise;
}
/**
 * ```js
 * import {apply} from 'ol-mapbox-style';
 * ```
 * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.
 *
 * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url must contain an access
 * token and look like
 * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @return {PluggableMap} The OpenLayers Map instance that will be populated with the
 * contents described in the Mapbox Style object.
 */

function apply(map, style) {
  if (typeof map === 'string' || map instanceof HTMLElement) {
    map = new ol_Map_js__WEBPACK_IMPORTED_MODULE_2___default.a({
      target: map
    });
  }

  setTimeout(function () {
    olms(map, style);
  }, 0);
  return map;
}
/**
 * If layerIds is not empty, applies the style specified in glStyle to the layer,
 * and adds the layer to the map.
 *
 * The layer may not yet have a source when the function is called.  If so, the style
 * is applied to the layer via a once listener on the 'change:source' event.
 *
 * @param {Layer} layer An OpenLayers layer instance.
 * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.
 * @param {Object} glStyle Style as a JSON object.
 * @param {string|undefined} path The path part of the style URL. Only required
 * when a relative path is used with the `"sprite"` property of the style.
 * @param {PluggableMap} map OpenLayers Map.
 * @return {Promise} Returns a promise that resolves after the source has
 * been set on the specified layer, and the style has been applied.
 * @private
 */

function finalizeLayer(layer, layerIds, glStyle, path, map) {
  var minZoom = 24;
  var maxZoom = 0;
  var glLayers = glStyle.layers;

  for (var i = 0, ii = glLayers.length; i < ii; ++i) {
    var glLayer = glLayers[i];

    if (layerIds.indexOf(glLayer.id) !== -1) {
      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);
      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);
    }
  }

  return new Promise(function (resolve, reject) {
    var setStyle = function setStyle() {
      var source = layer.getSource();

      if (!source || source.getState() === 'error') {
        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));
        return;
      }

      if (typeof source.getTileGrid === 'function') {
        var tileGrid = source.getTileGrid();

        if (tileGrid) {
          var sourceMinZoom = tileGrid.getMinZoom();

          if (minZoom > 0 || sourceMinZoom > 0) {
            layer.setMaxResolution(Math.min(_util_js__WEBPACK_IMPORTED_MODULE_15__["defaultResolutions"][minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);
          }

          if (maxZoom < 24) {
            layer.setMinResolution(_util_js__WEBPACK_IMPORTED_MODULE_15__["defaultResolutions"][maxZoom] + 1e-9);
          }
        }
      }

      if (source instanceof ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_7___default.a || source instanceof ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_9___default.a) {
        applyStyle(
        /** @type {import("ol/layer/Vector").default|import("ol/layer/VectorTile").default} */
        layer, glStyle, layerIds, path).then(function () {
          layer.setVisible(true);
          resolve();
        }, function (e) {
          reject(e);
        });
      } else {
        resolve();
      }
    };

    layer.set('mapbox-layers', layerIds);

    if (map.getLayers().getArray().indexOf(layer) === -1) {
      map.addLayer(layer);
    }

    if (layer.getSource()) {
      setStyle();
    } else {
      layer.once('change:source', setStyle);
    }
  });
}
/**
 * ```js
 * import {getLayer} from 'ol-mapbox-style';
 * ```
 * Get the OpenLayers layer instance that contains the provided Mapbox Style
 * `layer`. Note that multiple Mapbox Style layers are combined in a single
 * OpenLayers layer instance when they use the same Mapbox Style `source`.
 * @param {PluggableMap} map OpenLayers Map.
 * @param {string} layerId Mapbox Style layer id.
 * @return {Layer} OpenLayers layer instance.
 */


function getLayer(map, layerId) {
  var layers = map.getLayers().getArray();

  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var mapboxLayers = layers[i].get('mapbox-layers');

    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {
      return (
        /** @type {Layer} */
        layers[i]
      );
    }
  }
}
/**
 * ```js
 * import {getLayers} from 'ol-mapbox-style';
 * ```
 * Get the OpenLayers layer instances for the provided Mapbox Style `source`.
 * @param {PluggableMap} map OpenLayers Map.
 * @param {string} sourceId Mapbox Style source id.
 * @return {Array<Layer>} OpenLayers layer instances.
 */

function getLayers(map, sourceId) {
  var result = [];
  var layers = map.getLayers().getArray();

  for (var i = 0, ii = layers.length; i < ii; ++i) {
    if (layers[i].get('mapbox-source') === sourceId) {
      result.push(
      /** @type {Layer} */
      layers[i]);
    }
  }

  return result;
}
/**
 * ```js
 * import {getSource} from 'ol-mapbox-style';
 * ```
 * Get the OpenLayers source instance for the provided Mapbox Style `source`.
 * @param {PluggableMap} map OpenLayers Map.
 * @param {string} sourceId Mapbox Style source id.
 * @return {Source} OpenLayers source instance.
 */

function getSource(map, sourceId) {
  var layers = map.getLayers().getArray();

  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var source =
    /** @type {Layer} */
    layers[i].getSource();

    if (layers[i].get('mapbox-source') === sourceId) {
      return source;
    }
  }
}


/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = ol.Map;

/***/ }),
/* 220 */
/***/ (function(module, exports) {

module.exports = ol.tilegrid.TileGrid;

/***/ }),
/* 221 */
/***/ (function(module, exports) {

module.exports = ol.View;

/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValue", function() { return getValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recordStyleLayer", function() { return recordStyleLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_colorWithOpacity", function() { return colorWithOpacity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_evaluateFilter", function() { return evaluateFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_fromTemplate", function() { return fromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getValue", function() { return getValue; });
/* harmony import */ var ol_style_Circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(151);
/* harmony import */ var ol_style_Circle_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_style_Circle_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(153);
/* harmony import */ var ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_style_Icon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(152);
/* harmony import */ var ol_style_Icon_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_style_Icon_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_render_Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(223);
/* harmony import */ var ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(154);
/* harmony import */ var ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(150);
/* harmony import */ var ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_style_Text_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(251);
/* harmony import */ var ol_style_Text_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_style_Text_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(252);
/* harmony import */ var mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(253);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(258);
/*
ol-mapbox-style - Use Mapbox Style objects with OpenLayers
Copyright 2016-present ol-mapbox-style contributors
License: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE
*/










/**
 * @typedef {import("ol/layer/Vector").default} VectorLayer
 * @typedef {import("ol/layer/VectorTile").default} VectorTileLayer
 * @typedef {import("ol/style/Style").StyleFunction} StyleFunction
 */

var isFunction = _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["function"].isFunction;
var convertFunction = _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["function"].convertFunction;
var isExpression = _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["expression"].isExpression;
var createPropertyExpression = _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["expression"].createPropertyExpression;
var types = {
  'Point': 1,
  'MultiPoint': 1,
  'LineString': 2,
  'MultiLineString': 2,
  'Polygon': 3,
  'MultiPolygon': 3
};
var anchor = {
  'center': [0.5, 0.5],
  'left': [0, 0.5],
  'right': [1, 0.5],
  'top': [0.5, 0],
  'bottom': [0.5, 1],
  'top-left': [0, 0],
  'top-right': [1, 0],
  'bottom-left': [0, 1],
  'bottom-right': [1, 1]
};

var expressionData = function expressionData(rawExpression, propertySpec) {
  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);

  if (compiledExpression.result === 'error') {
    throw new Error(compiledExpression.value.map(function (err) {
      return "".concat(err.key, ": ").concat(err.message);
    }).join(', '));
  }

  return compiledExpression.value;
};

var emptyObj = {};
var zoomObj = {
  zoom: 0
};
var renderFeatureCoordinates, renderFeature;
/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {string} layoutOrPaint 'layout' or 'paint'.
 * @param {string} property Feature property.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @param {Object} [functionCache] Function cache.
 * @return {?} Value.
 */

function getValue(layer, layoutOrPaint, property, zoom, feature, functionCache) {
  var layerId = layer.id;

  if (!functionCache) {
    functionCache = {};
    console.warn('No functionCache provided to getValue()'); //eslint-disable-line no-console
  }

  if (!functionCache[layerId]) {
    functionCache[layerId] = {};
  }

  var functions = functionCache[layerId];

  if (!functions[property]) {
    var value_1 = (layer[layoutOrPaint] || emptyObj)[property];
    var propertySpec = _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["latest"]["".concat(layoutOrPaint, "_").concat(layer.type)][property];

    if (value_1 === undefined) {
      value_1 = propertySpec["default"];
    }

    var isExpr = isExpression(value_1);

    if (!isExpr && isFunction(value_1)) {
      value_1 = convertFunction(value_1, propertySpec);
      isExpr = true;
    }

    if (isExpr) {
      var compiledExpression = expressionData(value_1, propertySpec);
      functions[property] = compiledExpression.evaluate.bind(compiledExpression);
    } else {
      if (propertySpec.type == 'color') {
        value_1 = _mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["Color"].parse(value_1);
      }

      functions[property] = function () {
        return value_1;
      };
    }
  }

  zoomObj.zoom = zoom;
  return functions[property](zoomObj, feature);
}
/**
 * @private
 * @param {string} layerId Layer id.
 * @param {?} filter Filter.
 * @param {Object} feature Feature.
 * @param {number} zoom Zoom.
 * @param {Object} [filterCache] Filter cache.
 * @return {boolean} Filter result.
 */

function evaluateFilter(layerId, filter, feature, zoom, filterCache) {
  if (!filterCache) {
    console.warn('No filterCache provided to evaluateFilter()'); //eslint-disable-line no-console
  }

  if (!(layerId in filterCache)) {
    filterCache[layerId] = Object(_mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["featureFilter"])(filter).filter;
  }

  zoomObj.zoom = zoom;
  return filterCache[layerId](zoomObj, feature);
}
/**
 * @private
 * @param {?} color Color.
 * @param {number} opacity Opacity.
 * @return {string} Color.
 */


function colorWithOpacity(color, opacity) {
  if (color) {
    if (color.a === 0 || opacity === 0) {
      return undefined;
    }

    var a = color.a;
    opacity = opacity === undefined ? 1 : opacity;
    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';
  }

  return color;
}

var templateRegEx = /^([^]*)\{(.*)\}([^]*)$/;
/**
 * @private
 * @param {string} text Text.
 * @param {Object} properties Properties.
 * @return {string} Text.
 */

function fromTemplate(text, properties) {
  var parts;

  do {
    parts = text.match(templateRegEx);

    if (parts) {
      var value = properties[parts[2]] || '';
      text = parts[1] + value + parts[3];
    }
  } while (parts);

  return text;
}

var recordLayer = false;
/**
 * ```js
 * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';
 * ```
 * Turns recording of the Mapbox Style's `layer` on and off. When turned on,
 * the layer that a rendered feature belongs to will be set as the feature's
 * `mapbox-layer` property.
 * @param {boolean} [record=false] Recording of the style layer is on.
 */

function recordStyleLayer(record) {
  recordLayer = record;
}
/**
 * ```js
 * import stylefunction from 'ol-mapbox-style/dist/stylefunction';
 * ```
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source and applies it to the specified OpenLayers layer.
 *
 * Two additional properties will be set on the provided layer:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * This function also works in a web worker. In worker mode, the main thread needs
 * to listen to messages from the worker and respond with another message to make
 * sure that sprite image loading works:
 *
 * ```js
 *  worker.addEventListener('message', event => {
 *   if (event.data.action === 'loadImage') {
 *     const image = new Image();
 *     image.crossOrigin = 'anonymous';
 *     image.addEventListener('load', function() {
 *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {
 *         worker.postMessage({
 *           action: 'imageLoaded',
 *           image: imageBitmap,
 *           src: event.data.src
 *         }, [imageBitmap]);
 *       });
 *     });
 *     image.src = event.data.src;
 *   }
 * });
 * ```
 *
 * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to
 * apply the style to. In addition to the style, the layer will get two
 * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used
 * for the layer, and `mapbox-layers` will be an array of the `id`s of the
 * `glStyle`'s layers.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} source `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]
 * Resolutions for mapping resolution to zoom level.
 * @param {Object} [spriteData=undefined] Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {string} [spriteImageUrl=undefined] Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that
 * receives a font stack as arguments, and returns a (modified) font stack that
 * is available. Font names are the names used in the Mapbox Style object. If
 * not provided, the font stack will be used as-is. This function can also be
 * used for loading web fonts.
 * @return {StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */

/* harmony default export */ __webpack_exports__["default"] = (function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {
  if (resolutions === void 0) {
    resolutions = _util_js__WEBPACK_IMPORTED_MODULE_9__["defaultResolutions"];
  }

  if (typeof glStyle == 'string') {
    glStyle = JSON.parse(glStyle);
  }

  if (glStyle.version != 8) {
    throw new Error('glStyle version 8 required.');
  }

  var spriteImage, spriteImgSize;

  if (spriteImageUrl) {
    if (typeof Image !== 'undefined') {
      var img_1 = new Image();
      img_1.crossOrigin = 'anonymous';

      img_1.onload = function () {
        spriteImage = img_1;
        spriteImgSize = [img_1.width, img_1.height];
        olLayer.changed();
        img_1.onload = null;
      };

      img_1.src = spriteImageUrl;
    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
      //eslint-disable-line
      var worker =
      /** @type {*} */
      self; // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'

      worker.postMessage({
        action: 'loadImage',
        src: spriteImageUrl
      });
      worker.addEventListener('message', function handler(event) {
        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {
          spriteImage = event.data.image;
          spriteImgSize = [spriteImage.width, spriteImage.height];
        }
      });
    }
  }

  var allLayers = Object(_mapbox_mapbox_gl_style_spec__WEBPACK_IMPORTED_MODULE_8__["derefLayers"])(glStyle.layers);
  var layersBySourceLayer = {};
  var mapboxLayers = [];
  var iconImageCache = {};
  var patternCache = {};
  var functionCache = {};
  var filterCache = {};
  var mapboxSource;

  for (var i = 0, ii = allLayers.length; i < ii; ++i) {
    var layer = allLayers[i];
    var layerId = layer.id;

    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {
      var sourceLayer = layer['source-layer'];

      if (!mapboxSource) {
        mapboxSource = layer.source;
        var source_1 = glStyle.sources[mapboxSource];

        if (!source_1) {
          throw new Error("Source \"".concat(mapboxSource, "\" is not defined"));
        }

        var type = source_1.type;

        if (type !== 'vector' && type !== 'geojson') {
          throw new Error("Source \"".concat(mapboxSource, "\" is not of type \"vector\" or \"geojson\", but \"").concat(type, "\""));
        }
      }

      var layers = layersBySourceLayer[sourceLayer];

      if (!layers) {
        layers = [];
        layersBySourceLayer[sourceLayer] = layers;
      }

      layers.push({
        layer: layer,
        index: i
      });
      mapboxLayers.push(layerId);
    }
  }

  var textHalo = new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_4___default.a();
  var textColor = new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1___default.a();
  var styles = [];

  var styleFunction = function styleFunction(feature, resolution) {
    var properties = feature.getProperties();
    var layers = layersBySourceLayer[properties.layer];

    if (!layers) {
      return;
    }

    var zoom = resolutions.indexOf(resolution);

    if (zoom == -1) {
      zoom = Object(_util_js__WEBPACK_IMPORTED_MODULE_9__["getZoomForResolution"])(resolution, resolutions);
    }

    var type = types[feature.getGeometry().getType()];
    var f = {
      properties: properties,
      type: type
    };
    var stylesLength = -1;
    var featureBelongsToLayer;

    var _loop_1 = function _loop_1(i, ii) {
      var layerData = layers[i];
      var layer = layerData.layer;
      var layerId = layer.id;
      var layout = layer.layout || emptyObj;
      var paint = layer.paint || emptyObj;

      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {
        return "continue";
      }

      var filter = layer.filter;

      if (!filter || evaluateFilter(layerId, filter, f, zoom, filterCache)) {
        featureBelongsToLayer = layer;
        var color = void 0,
            opacity = void 0,
            fill = void 0,
            stroke = void 0,
            strokeColor = void 0,
            style = void 0;
        var index = layerData.index;

        if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {
          opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f, functionCache);

          if (layer.type + '-pattern' in paint) {
            var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f, functionCache);

            if (fillIcon) {
              var icon_1 = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();

              if (spriteImage && spriteData && spriteData[icon_1]) {
                ++stylesLength;
                style = styles[stylesLength];

                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                  style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5___default.a({
                    fill: new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1___default.a()
                  });
                  styles[stylesLength] = style;
                }

                fill = style.getFill();
                style.setZIndex(index);
                var icon_cache_key = icon_1 + '.' + opacity;
                var pattern = patternCache[icon_cache_key];

                if (!pattern) {
                  var spriteImageData = spriteData[icon_1];
                  var canvas = Object(_util_js__WEBPACK_IMPORTED_MODULE_9__["createCanvas"])(spriteImageData.width, spriteImageData.height);
                  var ctx =
                  /** @type {CanvasRenderingContext2D} */
                  canvas.getContext('2d');
                  ctx.globalAlpha = opacity;
                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);
                  pattern = ctx.createPattern(canvas, 'repeat');
                  patternCache[icon_cache_key] = pattern;
                }

                fill.setColor(pattern);
              }
            }
          } else {
            color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f, functionCache), opacity);

            if (color) {
              if (layer.type + '-outline-color' in paint) {
                strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f, functionCache), opacity);
              }

              if (!strokeColor) {
                strokeColor = color;
              }

              ++stylesLength;
              style = styles[stylesLength];

              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {
                style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5___default.a({
                  fill: new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1___default.a(),
                  stroke: new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_4___default.a()
                });
                styles[stylesLength] = style;
              }

              fill = style.getFill();
              fill.setColor(color);
              stroke = style.getStroke();
              stroke.setColor(strokeColor);
              stroke.setWidth(1);
              style.setZIndex(index);
            }
          }
        }

        if (type != 1 && layer.type == 'line') {
          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f, functionCache), getValue(layer, 'paint', 'line-opacity', zoom, f, functionCache)) : undefined;
          var width_1 = getValue(layer, 'paint', 'line-width', zoom, f, functionCache);

          if (color && width_1 > 0) {
            ++stylesLength;
            style = styles[stylesLength];

            if (!style || !style.getStroke() || style.getFill() || style.getText()) {
              style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5___default.a({
                stroke: new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_4___default.a()
              });
              styles[stylesLength] = style;
            }

            stroke = style.getStroke();
            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f, functionCache));
            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f, functionCache));
            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f, functionCache));
            stroke.setColor(color);
            stroke.setWidth(width_1);
            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f, functionCache).map(function (x) {
              return x * width_1;
            }) : null);
            style.setZIndex(index);
          }
        }

        var hasImage = false;
        var text = null;
        var placementAngle = 0;
        var icon = void 0,
            iconImg = void 0,
            skipLabel = void 0;

        if ((type == 1 || type == 2) && 'icon-image' in layout) {
          var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f, functionCache);

          if (iconImage) {
            icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();
            var styleGeom = undefined;

            if (spriteImage && spriteData && spriteData[icon]) {
              var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f, functionCache);

              if (type == 2) {
                var geom = feature.getGeometry(); // ol package and ol-debug.js only

                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {
                  var extent = geom.getExtent();
                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));

                  if (size > 150) {
                    //FIXME Do not hard-code a size of 150
                    var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();

                    if (!renderFeature) {
                      renderFeatureCoordinates = [NaN, NaN];
                      renderFeature = new ol_render_Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Point', renderFeatureCoordinates, [], {}, null);
                    }

                    styleGeom = renderFeature;
                    renderFeatureCoordinates[0] = midpoint[0];
                    renderFeatureCoordinates[1] = midpoint[1];
                    var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache);

                    if (placement === 'line' && iconRotationAlignment === 'map') {
                      var stride = geom.getStride();
                      var coordinates = geom.getFlatCoordinates();

                      for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {
                        var x1 = coordinates[i_1];
                        var y1 = coordinates[i_1 + 1];
                        var x2 = coordinates[i_1 + stride];
                        var y2 = coordinates[i_1 + stride + 1];
                        var minX = Math.min(x1, x2);
                        var minY = Math.min(y1, y2);
                        var maxX = Math.max(x1, x2);
                        var maxY = Math.max(y1, y2);

                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {
                          placementAngle = Math.atan2(y1 - y2, x2 - x1);
                          break;
                        }
                      }
                    }
                  }
                }
              }

              if (type !== 2 || styleGeom) {
                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f, functionCache);
                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f, functionCache) : null;

                if (!iconColor || iconColor.a !== 0) {
                  var icon_cache_key = icon + '.' + iconSize;

                  if (iconColor !== null) {
                    icon_cache_key += '.' + iconColor;
                  }

                  iconImg = iconImageCache[icon_cache_key];

                  if (!iconImg) {
                    var spriteImageData = spriteData[icon];
                    iconImg = new ol_style_Icon_js__WEBPACK_IMPORTED_MODULE_2___default.a({
                      color: iconColor ? [iconColor.r * 255, iconColor.g * 255, iconColor.b * 255, iconColor.a] : undefined,
                      img: spriteImage,
                      imgSize: spriteImgSize,
                      size: [spriteImageData.width, spriteImageData.height],
                      offset: [spriteImageData.x, spriteImageData.y],
                      rotateWithView: iconRotationAlignment === 'map',
                      scale: iconSize / spriteImageData.pixelRatio
                    });
                    iconImageCache[icon_cache_key] = iconImg;
                  }
                }

                if (iconImg) {
                  ++stylesLength;
                  style = styles[stylesLength];

                  if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                    style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5___default.a();
                    styles[stylesLength] = style;
                  }

                  style.setGeometry(styleGeom);
                  iconImg.setRotation(placementAngle + Object(_util_js__WEBPACK_IMPORTED_MODULE_9__["deg2rad"])(getValue(layer, 'layout', 'icon-rotate', zoom, f, functionCache)));
                  iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f, functionCache));
                  iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f, functionCache)]);
                  style.setImage(iconImg);
                  text = style.getText();
                  style.setText(undefined);
                  style.setZIndex(index);
                  hasImage = true;
                  skipLabel = false;
                }
              } else {
                skipLabel = true;
              }
            }
          }
        }

        if (type == 1 && 'circle-radius' in paint) {
          ++stylesLength;
          style = styles[stylesLength];

          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
            style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5___default.a();
            styles[stylesLength] = style;
          }

          var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f, functionCache);
          var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f, functionCache), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f, functionCache));
          var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f, functionCache), getValue(layer, 'paint', 'circle-opacity', zoom, f, functionCache));
          var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f, functionCache);
          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;
          iconImg = iconImageCache[cache_key];

          if (!iconImg) {
            iconImg = new ol_style_Circle_js__WEBPACK_IMPORTED_MODULE_0___default.a({
              radius: circleRadius,
              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_4___default.a({
                width: circleStrokeWidth,
                color: circleStrokeColor
              }) : undefined,
              fill: circleColor ? new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1___default.a({
                color: circleColor
              }) : undefined
            });
            iconImageCache[cache_key] = iconImg;
          }

          style.setImage(iconImg);
          text = style.getText();
          style.setText(undefined);
          style.setGeometry(undefined);
          style.setZIndex(index);
          hasImage = true;
        }

        var label = void 0;

        if ('text-field' in layout) {
          var textField = getValue(layer, 'layout', 'text-field', zoom, f, functionCache).toString();
          label = fromTemplate(textField, properties).trim();
          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f, functionCache);
        }

        if (label && opacity && !skipLabel) {
          if (!hasImage) {
            ++stylesLength;
            style = styles[stylesLength];

            if (!style || !style.getText() || style.getFill() || style.getStroke()) {
              style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_5___default.a();
              styles[stylesLength] = style;
            }

            style.setImage(undefined);
            style.setGeometry(undefined);
          }

          if (!style.getText()) {
            style.setText(text || new ol_style_Text_js__WEBPACK_IMPORTED_MODULE_6___default.a({
              padding: [2, 2, 2, 2]
            }));
          }

          text = style.getText();
          var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f, functionCache));
          var fontArray = getValue(layer, 'layout', 'text-font', zoom, f, functionCache);
          var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f, functionCache);
          var font = mapbox_to_css_font__WEBPACK_IMPORTED_MODULE_7___default()(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);
          var textTransform = layout['text-transform'];

          if (textTransform == 'uppercase') {
            label = label.toUpperCase();
          } else if (textTransform == 'lowercase') {
            label = label.toLowerCase();
          }

          var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f, functionCache);
          var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f, functionCache);
          var wrappedLabel = type == 2 ? Object(_util_js__WEBPACK_IMPORTED_MODULE_9__["applyLetterSpacing"])(label, letterSpacing) : Object(_util_js__WEBPACK_IMPORTED_MODULE_9__["wrapText"])(label, font, maxTextWidth, letterSpacing);
          text.setText(wrappedLabel);
          text.setFont(font);
          text.setRotation(Object(_util_js__WEBPACK_IMPORTED_MODULE_9__["deg2rad"])(getValue(layer, 'layout', 'text-rotate', zoom, f, functionCache)));
          var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f, functionCache);
          var placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache);
          text.setPlacement(placement);
          var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f, functionCache);
          var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f, functionCache);
          var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f, functionCache); // Text offset has to take halo width and line height into account

          var vOffset = 0;
          var hOffset = 0;

          if (placement == 'point') {
            var textAlign = 'center';

            if (textAnchor.indexOf('left') !== -1) {
              textAlign = 'left';
              hOffset = textHaloWidth;
            } else if (textAnchor.indexOf('right') !== -1) {
              textAlign = 'right';
              hOffset = -textHaloWidth;
            }

            text.setTextAlign(textAlign);
            var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f, functionCache);
            text.setRotateWithView(textRotationAlignment == 'map');
          } else {
            text.setMaxAngle(Object(_util_js__WEBPACK_IMPORTED_MODULE_9__["deg2rad"])(getValue(layer, 'layout', 'text-max-angle', zoom, f, functionCache)) * label.length / wrappedLabel.length);
            text.setTextAlign();
            text.setRotateWithView(false);
          }

          var textBaseline = 'middle';

          if (textAnchor.indexOf('bottom') == 0) {
            textBaseline = 'bottom';
            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
          } else if (textAnchor.indexOf('top') == 0) {
            textBaseline = 'top';
            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
          }

          text.setTextBaseline(textBaseline);
          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);
          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);
          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f, functionCache), opacity));
          text.setFill(textColor);
          var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f, functionCache), opacity);

          if (haloColor) {
            textHalo.setColor(haloColor); // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width
            // Halo width must be doubled because it is applied around the center of the text outline

            textHaloWidth *= 2; // 1/4 of text size (spec) x 2

            var halfTextSize = 0.5 * textSize;
            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);
            text.setStroke(textHalo);
          } else {
            text.setStroke(undefined);
          }

          var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f, functionCache);
          var padding = text.getPadding();

          if (textPadding !== padding[0]) {
            padding[0] = textPadding;
            padding[1] = textPadding;
            padding[2] = textPadding;
            padding[3] = textPadding;
          }

          style.setZIndex(index);
        }
      }
    };

    for (var i = 0, ii = layers.length; i < ii; ++i) {
      _loop_1(i, ii);
    }

    if (stylesLength > -1) {
      styles.length = stylesLength + 1;

      if (recordLayer) {
        if (typeof feature.set === 'function') {
          // ol/Feature
          feature.set('mapbox-layer', featureBelongsToLayer);
        } else {
          // ol/render/Feature
          feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;
        }
      }

      return styles;
    }
  };

  olLayer.setStyle(styleFunction);
  olLayer.set('mapbox-source', mapboxSource);
  olLayer.set('mapbox-layers', mapboxLayers);
  return styleFunction;
});


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(224);
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(225);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(230);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(234);
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(236);
/* harmony import */ var _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(248);
/* harmony import */ var _geom_flat_center_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(249);
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(250);
/**
 * @module ol/render/Feature
 */









/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_1__["create"])();
/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */
var RenderFeature = /** @class */ (function () {
    /**
     * @param {import("../geom/GeometryType.js").default} type Geometry type.
     * @param {Array<number>} flatCoordinates Flat coordinates. These always need
     *     to be right-handed for polygons.
     * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.
     * @param {Object<string, *>} properties Properties.
     * @param {number|string|undefined} id Feature id.
     */
    function RenderFeature(type, flatCoordinates, ends, properties, id) {
        /**
         * @private
         * @type {import("../extent.js").Extent|undefined}
         */
        this.extent_;
        /**
         * @private
         * @type {number|string|undefined}
         */
        this.id_ = id;
        /**
         * @private
         * @type {import("../geom/GeometryType.js").default}
         */
        this.type_ = type;
        /**
         * @private
         * @type {Array<number>}
         */
        this.flatCoordinates_ = flatCoordinates;
        /**
         * @private
         * @type {Array<number>}
         */
        this.flatInteriorPoints_ = null;
        /**
         * @private
         * @type {Array<number>}
         */
        this.flatMidpoints_ = null;
        /**
         * @private
         * @type {Array<number>|Array<Array<number>>}
         */
        this.ends_ = ends;
        /**
         * @private
         * @type {Object<string, *>}
         */
        this.properties_ = properties;
    }
    /**
     * Get a feature property by its key.
     * @param {string} key Key
     * @return {*} Value for the requested key.
     * @api
     */
    RenderFeature.prototype.get = function (key) {
        return this.properties_[key];
    };
    /**
     * Get the extent of this feature's geometry.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    RenderFeature.prototype.getExtent = function () {
        if (!this.extent_) {
            this.extent_ =
                this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINT
                    ? Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdateFromCoordinate"])(this.flatCoordinates_)
                    : Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdateFromFlatCoordinates"])(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
        }
        return this.extent_;
    };
    /**
     * @return {Array<number>} Flat interior points.
     */
    RenderFeature.prototype.getFlatInteriorPoint = function () {
        if (!this.flatInteriorPoints_) {
            var flatCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCenter"])(this.getExtent());
            this.flatInteriorPoints_ = Object(_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_4__["getInteriorPointOfArray"])(this.flatCoordinates_, 0, 
            /** @type {Array<number>} */ (this.ends_), 2, flatCenter, 0);
        }
        return this.flatInteriorPoints_;
    };
    /**
     * @return {Array<number>} Flat interior points.
     */
    RenderFeature.prototype.getFlatInteriorPoints = function () {
        if (!this.flatInteriorPoints_) {
            var flatCenters = Object(_geom_flat_center_js__WEBPACK_IMPORTED_MODULE_7__["linearRingss"])(this.flatCoordinates_, 0, 
            /** @type {Array<Array<number>>} */ (this.ends_), 2);
            this.flatInteriorPoints_ = Object(_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_4__["getInteriorPointsOfMultiArray"])(this.flatCoordinates_, 0, 
            /** @type {Array<Array<number>>} */ (this.ends_), 2, flatCenters);
        }
        return this.flatInteriorPoints_;
    };
    /**
     * @return {Array<number>} Flat midpoint.
     */
    RenderFeature.prototype.getFlatMidpoint = function () {
        if (!this.flatMidpoints_) {
            this.flatMidpoints_ = Object(_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__["interpolatePoint"])(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
        }
        return this.flatMidpoints_;
    };
    /**
     * @return {Array<number>} Flat midpoints.
     */
    RenderFeature.prototype.getFlatMidpoints = function () {
        if (!this.flatMidpoints_) {
            this.flatMidpoints_ = [];
            var flatCoordinates = this.flatCoordinates_;
            var offset = 0;
            var ends = /** @type {Array<number>} */ (this.ends_);
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                var end = ends[i];
                var midpoint = Object(_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__["interpolatePoint"])(flatCoordinates, offset, end, 2, 0.5);
                Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["extend"])(this.flatMidpoints_, midpoint);
                offset = end;
            }
        }
        return this.flatMidpoints_;
    };
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is set when reading data from a remote source.
     * @return {number|string|undefined} Id.
     * @api
     */
    RenderFeature.prototype.getId = function () {
        return this.id_;
    };
    /**
     * @return {Array<number>} Flat coordinates.
     */
    RenderFeature.prototype.getOrientedFlatCoordinates = function () {
        return this.flatCoordinates_;
    };
    /**
     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
     * determining the geometry type in style function (see {@link #getType}).
     * @return {RenderFeature} Feature.
     * @api
     */
    RenderFeature.prototype.getGeometry = function () {
        return this;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {RenderFeature} Simplified geometry.
     */
    RenderFeature.prototype.getSimplifiedGeometry = function (squaredTolerance) {
        return this;
    };
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
     * @return {RenderFeature} Simplified geometry.
     */
    RenderFeature.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
        return this;
    };
    /**
     * Get the feature properties.
     * @return {Object<string, *>} Feature properties.
     * @api
     */
    RenderFeature.prototype.getProperties = function () {
        return this.properties_;
    };
    /**
     * @return {number} Stride.
     */
    RenderFeature.prototype.getStride = function () {
        return 2;
    };
    /**
     * @return {undefined}
     */
    RenderFeature.prototype.getStyleFunction = function () {
        return undefined;
    };
    /**
     * Get the type of this feature's geometry.
     * @return {import("../geom/GeometryType.js").default} Geometry type.
     * @api
     */
    RenderFeature.prototype.getType = function () {
        return this.type_;
    };
    /**
     * Transform geometry coordinates from tile pixel space to projected.
     *
     * @param {import("../proj.js").ProjectionLike} projection The data projection
     */
    RenderFeature.prototype.transform = function (projection) {
        projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])(projection);
        var pixelExtent = projection.getExtent();
        var projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
            var scale = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(projectedExtent) / Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(pixelExtent);
            Object(_transform_js__WEBPACK_IMPORTED_MODULE_1__["compose"])(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_8__["transform2D"])(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
        }
    };
    /**
     * @return {Array<number>|Array<Array<number>>} Ends or endss.
     */
    RenderFeature.prototype.getEnds = function () {
        return this.ends_;
    };
    return RenderFeature;
}());
RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
/**
 * @return {Array<number>} Flat coordinates.
 */
RenderFeature.prototype.getFlatCoordinates =
    RenderFeature.prototype.getOrientedFlatCoordinates;
/* harmony default export */ __webpack_exports__["default"] = (RenderFeature);
//# sourceMappingURL=Feature.js.map

/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryType
 */
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
    POINT: 'Point',
    LINE_STRING: 'LineString',
    LINEAR_RING: 'LinearRing',
    POLYGON: 'Polygon',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon',
    GEOMETRY_COLLECTION: 'GeometryCollection',
    CIRCLE: 'Circle',
});
//# sourceMappingURL=GeometryType.js.map

/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFromArray", function() { return setFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeScale", function() { return makeScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composeCssTransform", function() { return composeCssTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInverse", function() { return makeInverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(227);
/**
 * @module ol/transform
 */


/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */
/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */
/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
    return [1, 0, 0, 1, 0, 0];
}
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
}
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
    var a1 = transform1[0];
    var b1 = transform1[1];
    var c1 = transform1[2];
    var d1 = transform1[3];
    var e1 = transform1[4];
    var f1 = transform1[5];
    var a2 = transform2[0];
    var b2 = transform2[1];
    var c2 = transform2[2];
    var d2 = transform2[3];
    var e2 = transform2[4];
    var f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
}
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
}
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
}
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
    var x = coordinate[0];
    var y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
}
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */
function makeScale(target, x, y) {
    return set(target, x, 0, 0, y, 0, 0);
}
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    var sin = Math.sin(angle);
    var cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */
function invert(source) {
    return makeInverse(source, source);
}
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */
function makeInverse(target, source) {
    var det = determinant(source);
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(det !== 0, 32); // Transformation matrix cannot be inverted
    var a = source[0];
    var b = source[1];
    var c = source[2];
    var d = source[3];
    var e = source[4];
    var f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
}
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */
var transformStringDiv;
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */
function toString(mat) {
    var transformString = 'matrix(' + mat.join(', ') + ')';
    if (_has_js__WEBPACK_IMPORTED_MODULE_0__["WORKER_OFFSCREEN_CANVAS"]) {
        return transformString;
    }
    var node = transformStringDiv || (transformStringDiv = document.createElement('div'));
    node.style.transform = transformString;
    return node.style.transform;
}
//# sourceMappingURL=transform.js.map

/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIREFOX", function() { return FIREFOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAFARI", function() { return SAFARI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBKIT", function() { return WEBKIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAC", function() { return MAC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEVICE_PIXEL_RATIO", function() { return DEVICE_PIXEL_RATIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORKER_OFFSCREEN_CANVAS", function() { return WORKER_OFFSCREEN_CANVAS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGE_DECODE", function() { return IMAGE_DECODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PASSIVE_EVENT_LISTENERS", function() { return PASSIVE_EVENT_LISTENERS; });
/**
 * @module ol/has
 */
var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
    ? navigator.userAgent.toLowerCase()
    : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
var FIREFOX = ua.indexOf('firefox') !== -1;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
var MAC = ua.indexOf('macintosh') !== -1;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' &&
    typeof OffscreenCanvas !== 'undefined' &&
    self instanceof WorkerGlobalScope; //eslint-disable-line
/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */
var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
/**
 * @type {boolean}
 */
var PASSIVE_EVENT_LISTENERS = (function () {
    var passive = false;
    try {
        var options = Object.defineProperty({}, 'passive', {
            get: function () {
                passive = true;
            },
        });
        window.addEventListener('_', null, options);
        window.removeEventListener('_', null, options);
    }
    catch (error) {
        // passive not supported
    }
    return passive;
})();
//# sourceMappingURL=has.js.map

/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(228);
/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
    if (!assertion) {
        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](errorCode);
    }
}
//# sourceMappingURL=asserts.js.map

/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(229);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/AssertionError
 */

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError = /** @class */ (function (_super) {
    __extends(AssertionError, _super);
    /**
     * @param {number} code Error code.
     */
    function AssertionError(code) {
        var _this = this;
        var path = _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] === 'latest' ? _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] : 'v' + _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"].split('-')[0];
        var message = 'Assertion failed. See https://openlayers.org/en/' +
            path +
            '/doc/errors/#' +
            code +
            ' for details.';
        _this = _super.call(this, message) || this;
        /**
         * Error code. The meaning of the code can be found on
         * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
         * the version found in the OpenLayers script's header comment if a version
         * other than the latest is used).
         * @type {number}
         * @api
         */
        _this.code = code;
        /**
         * @type {string}
         */
        _this.name = 'AssertionError';
        // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
        _this.message = message;
        return _this;
    }
    return AssertionError;
}(Error));
/* harmony default export */ __webpack_exports__["default"] = (AssertionError);
//# sourceMappingURL=AssertionError.js.map

/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abstract", function() { return abstract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUid", function() { return getUid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/**
 * @module ol/util
 */
/**
 * @return {?} Any return.
 */
function abstract() {
    return /** @type {?} */ ((function () {
        throw new Error('Unimplemented abstract method.');
    })());
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */
function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
/**
 * OpenLayers version.
 * @type {string}
 */
var VERSION = '6.9.0';
//# sourceMappingURL=util.js.map

/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundingExtent", function() { return boundingExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSquaredDistanceXY", function() { return closestSquaredDistanceXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsCoordinate", function() { return containsCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsExtent", function() { return containsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsXY", function() { return containsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinateRelationship", function() { return coordinateRelationship; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmpty", function() { return createEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateEmpty", function() { return createOrUpdateEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinate", function() { return createOrUpdateFromCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinates", function() { return createOrUpdateFromCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromFlatCoordinates", function() { return createOrUpdateFromFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromRings", function() { return createOrUpdateFromRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "approximatelyEquals", function() { return approximatelyEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinate", function() { return extendCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinates", function() { return extendCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendFlatCoordinates", function() { return extendFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendRings", function() { return extendRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendXY", function() { return extendXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachCorner", function() { return forEachCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomLeft", function() { return getBottomLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomRight", function() { return getBottomRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenter", function() { return getCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCorner", function() { return getCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnlargedArea", function() { return getEnlargedArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForViewAndSize", function() { return getForViewAndSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeight", function() { return getHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersectionArea", function() { return getIntersectionArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersection", function() { return getIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMargin", function() { return getMargin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return getSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopLeft", function() { return getTopLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopRight", function() { return getTopRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWidth", function() { return getWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersects", function() { return intersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "returnOrUpdate", function() { return returnOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleFromCenter", function() { return scaleFromCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsSegment", function() { return intersectsSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyTransform", function() { return applyTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapX", function() { return wrapX; });
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(231);
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(227);
/**
 * @module ol/extent
 */



/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */
/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
    var extent = createEmpty();
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        extendCoordinate(extent, coordinates[i]);
    }
    return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [opt_extent] Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
    var minX = Math.min.apply(null, xs);
    var minY = Math.min.apply(null, ys);
    var maxX = Math.max.apply(null, xs);
    var maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0] - value;
        opt_extent[1] = extent[1] - value;
        opt_extent[2] = extent[2] + value;
        opt_extent[3] = extent[3] + value;
        return opt_extent;
    }
    else {
        return [
            extent[0] - value,
            extent[1] - value,
            extent[2] + value,
            extent[3] + value,
        ];
    }
}
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} The clone.
 */
function clone(extent, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
    }
    else {
        return extent.slice();
    }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
    var dx, dy;
    if (x < extent[0]) {
        dx = extent[0] - x;
    }
    else if (extent[2] < x) {
        dx = x - extent[2];
    }
    else {
        dx = 0;
    }
    if (y < extent[1]) {
        dy = extent[1] - y;
    }
    else if (extent[3] < y) {
        dy = y - extent[3];
    }
    else {
        dy = 0;
    }
    return dx * dx + dy * dy;
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
}
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
    return (extent1[0] <= extent2[0] &&
        extent2[2] <= extent1[2] &&
        extent1[1] <= extent2[1] &&
        extent2[3] <= extent1[3]);
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var x = coordinate[0];
    var y = coordinate[1];
    var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].UNKNOWN;
    if (x < minX) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].LEFT;
    }
    else if (x > maxX) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].RIGHT;
    }
    if (y < minY) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].BELOW;
    }
    else if (y > maxY) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABOVE;
    }
    if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].UNKNOWN) {
        relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERSECTING;
    }
    return relationship;
}
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
    return [Infinity, Infinity, -Infinity, -Infinity];
}
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = minX;
        opt_extent[1] = minY;
        opt_extent[2] = maxX;
        opt_extent[3] = maxY;
        return opt_extent;
    }
    else {
        return [minX, minY, maxX, maxY];
    }
}
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
    var x = coordinate[0];
    var y = coordinate[1];
    return createOrUpdate(x, y, x, y, opt_extent);
}
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendCoordinates(extent, coordinates);
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendRings(extent, rings);
}
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
    return (extent1[0] == extent2[0] &&
        extent1[2] == extent2[2] &&
        extent1[1] == extent2[1] &&
        extent1[3] == extent2[3]);
}
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */
function approximatelyEquals(extent1, extent2, tolerance) {
    return (Math.abs(extent1[0] - extent2[0]) < tolerance &&
        Math.abs(extent1[2] - extent2[2]) < tolerance &&
        Math.abs(extent1[1] - extent2[1]) < tolerance &&
        Math.abs(extent1[3] - extent2[3]) < tolerance);
}
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) {
        extent1[0] = extent2[0];
    }
    if (extent2[2] > extent1[2]) {
        extent1[2] = extent2[2];
    }
    if (extent2[1] < extent1[1]) {
        extent1[1] = extent2[1];
    }
    if (extent2[3] > extent1[3]) {
        extent1[3] = extent2[3];
    }
    return extent1;
}
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) {
        extent[0] = coordinate[0];
    }
    if (coordinate[0] > extent[2]) {
        extent[2] = coordinate[0];
    }
    if (coordinate[1] < extent[1]) {
        extent[1] = coordinate[1];
    }
    if (coordinate[1] > extent[3]) {
        extent[3] = coordinate[1];
    }
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        extendCoordinate(extent, coordinates[i]);
    }
    return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for (; offset < end; offset += stride) {
        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    }
    return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
    for (var i = 0, ii = rings.length; i < ii; ++i) {
        extendCoordinates(extent, rings[i]);
    }
    return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
}
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */
function forEachCorner(extent, callback) {
    var val;
    val = callback(getBottomLeft(extent));
    if (val) {
        return val;
    }
    val = callback(getBottomRight(extent));
    if (val) {
        return val;
    }
    val = callback(getTopRight(extent));
    if (val) {
        return val;
    }
    val = callback(getTopLeft(extent));
    if (val) {
        return val;
    }
    return false;
}
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
    var area = 0;
    if (!isEmpty(extent)) {
        area = getWidth(extent) * getHeight(extent);
    }
    return area;
}
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
    return [extent[0], extent[1]];
}
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
    return [extent[2], extent[1]];
}
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {import("./extent/Corner.js").default} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
    var coordinate;
    if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_LEFT) {
        coordinate = getBottomLeft(extent);
    }
    else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__["default"].BOTTOM_RIGHT) {
        coordinate = getBottomRight(extent);
    }
    else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_LEFT) {
        coordinate = getTopLeft(extent);
    }
    else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__["default"].TOP_RIGHT) {
        coordinate = getTopRight(extent);
    }
    else {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__["assert"])(false, 13); // Invalid corner
    }
    return coordinate;
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
    var minX = Math.min(extent1[0], extent2[0]);
    var minY = Math.min(extent1[1], extent2[1]);
    var maxX = Math.max(extent1[2], extent2[2]);
    var maxY = Math.max(extent1[3], extent2[3]);
    return (maxX - minX) * (maxY - minY);
}
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
    var dx = (resolution * size[0]) / 2;
    var dy = (resolution * size[1]) / 2;
    var cosRotation = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    var xCos = dx * cosRotation;
    var xSin = dx * sinRotation;
    var yCos = dy * cosRotation;
    var ySin = dy * sinRotation;
    var x = center[0];
    var y = center[1];
    var x0 = x - xCos + ySin;
    var x1 = x - xCos - ySin;
    var x2 = x + xCos - ySin;
    var x3 = x + xCos + ySin;
    var y0 = y - xSin - yCos;
    var y1 = y - xSin + yCos;
    var y2 = y + xSin + yCos;
    var y3 = y + xSin - yCos;
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
    return extent[3] - extent[1];
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
    var intersection = getIntersection(extent1, extent2);
    return getArea(intersection);
}
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [opt_extent] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
    var intersection = opt_extent ? opt_extent : createEmpty();
    if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) {
            intersection[0] = extent1[0];
        }
        else {
            intersection[0] = extent2[0];
        }
        if (extent1[1] > extent2[1]) {
            intersection[1] = extent1[1];
        }
        else {
            intersection[1] = extent2[1];
        }
        if (extent1[2] < extent2[2]) {
            intersection[2] = extent1[2];
        }
        else {
            intersection[2] = extent2[2];
        }
        if (extent1[3] < extent2[3]) {
            intersection[3] = extent1[3];
        }
        else {
            intersection[3] = extent2[3];
        }
    }
    else {
        createOrUpdateEmpty(intersection);
    }
    return intersection;
}
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
}
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
    return [extent[2] - extent[0], extent[3] - extent[1]];
}
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
    return [extent[0], extent[3]];
}
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
    return [extent[2], extent[3]];
}
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
    return extent[2] - extent[0];
}
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
    return (extent1[0] <= extent2[2] &&
        extent1[2] >= extent2[0] &&
        extent1[1] <= extent2[3] &&
        extent1[3] >= extent2[1]);
}
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
}
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
    }
    else {
        return extent;
    }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
    var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
    var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= deltaY;
    extent[3] += deltaY;
}
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
    var intersects = false;
    var startRel = coordinateRelationship(extent, start);
    var endRel = coordinateRelationship(extent, end);
    if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERSECTING ||
        endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERSECTING) {
        intersects = true;
    }
    else {
        var minX = extent[0];
        var minY = extent[1];
        var maxX = extent[2];
        var maxY = extent[3];
        var startX = start[0];
        var startY = start[1];
        var endX = end[0];
        var endY = end[1];
        var slope = (endY - startY) / (endX - startX);
        var x = void 0, y = void 0;
        if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABOVE)) {
            // potentially intersects top
            x = endX - (endY - maxY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects &&
            !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].RIGHT) &&
            !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].RIGHT)) {
            // potentially intersects right
            y = endY - (endX - maxX) * slope;
            intersects = y >= minY && y <= maxY;
        }
        if (!intersects &&
            !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].BELOW) &&
            !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].BELOW)) {
            // potentially intersects bottom
            x = endX - (endY - minY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects &&
            !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].LEFT) &&
            !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__["default"].LEFT)) {
            // potentially intersects left
            y = endY - (endX - minX) * slope;
            intersects = y >= minY && y <= maxY;
        }
    }
    return intersects;
}
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [opt_extent] Destination extent.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent, opt_stops) {
    var coordinates = [];
    if (opt_stops > 1) {
        var width = extent[2] - extent[0];
        var height = extent[3] - extent[1];
        for (var i = 0; i < opt_stops; ++i) {
            coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);
        }
    }
    else {
        coordinates = [
            extent[0],
            extent[1],
            extent[2],
            extent[1],
            extent[2],
            extent[3],
            extent[0],
            extent[3],
        ];
    }
    transformFn(coordinates, coordinates, 2);
    var xs = [];
    var ys = [];
    for (var i = 0, l = coordinates.length; i < l; i += 2) {
        xs.push(coordinates[i]);
        ys.push(coordinates[i + 1]);
    }
    return _boundingExtentXYs(xs, ys, opt_extent);
}
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */
function wrapX(extent, projection) {
    var projectionExtent = projection.getExtent();
    var center = getCenter(extent);
    if (projection.canWrapX() &&
        (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
        var worldWidth = getWidth(projectionExtent);
        var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
        var offset = worldsAway * worldWidth;
        extent[0] -= offset;
        extent[2] -= offset;
    }
    return extent;
}
//# sourceMappingURL=extent.js.map

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Corner
 */
/**
 * Extent corner.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_RIGHT: 'bottom-right',
    TOP_LEFT: 'top-left',
    TOP_RIGHT: 'top-right',
});
//# sourceMappingURL=Corner.js.map

/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Relationship
 */
/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16,
});
//# sourceMappingURL=Relationship.js.map

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearch", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberSafeCompareFunction", function() { return numberSafeCompareFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearFindNearest", function() { return linearFindNearest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverseSubArray", function() { return reverseSubArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stableSort", function() { return stableSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSorted", function() { return isSorted; });
/**
 * @module ol/array
 */
/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [opt_comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
    var mid, cmp;
    var comparator = opt_comparator || numberSafeCompareFunction;
    var low = 0;
    var high = haystack.length;
    var found = false;
    while (low < high) {
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
         * to double (which gives the wrong results). */
        mid = low + ((high - low) >> 1);
        cmp = +comparator(haystack[mid], needle);
        if (cmp < 0.0) {
            /* Too low. */
            low = mid + 1;
        }
        else {
            /* Key found or too high */
            high = mid;
            found = !cmp;
        }
    }
    /* Key not found. */
    return found ? low : ~low;
}
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
    return arr.indexOf(obj) >= 0;
}
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */
/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
    var n = arr.length;
    if (arr[0] <= target) {
        return 0;
    }
    else if (target <= arr[n - 1]) {
        return n - 1;
    }
    else {
        var i = void 0;
        if (direction > 0) {
            for (i = 1; i < n; ++i) {
                if (arr[i] < target) {
                    return i - 1;
                }
            }
        }
        else if (direction < 0) {
            for (i = 1; i < n; ++i) {
                if (arr[i] <= target) {
                    return i;
                }
            }
        }
        else {
            for (i = 1; i < n; ++i) {
                if (arr[i] == target) {
                    return i;
                }
                else if (arr[i] < target) {
                    if (typeof direction === 'function') {
                        if (direction(target, arr[i - 1], arr[i]) > 0) {
                            return i - 1;
                        }
                        else {
                            return i;
                        }
                    }
                    else if (arr[i - 1] - target < target - arr[i]) {
                        return i - 1;
                    }
                    else {
                        return i;
                    }
                }
            }
        }
        return n - 1;
    }
}
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
    while (begin < end) {
        var tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
    }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
    var extension = Array.isArray(data) ? data : [data];
    var length = extension.length;
    for (var i = 0; i < length; i++) {
        arr[arr.length] = extension[i];
    }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
    var i = arr.indexOf(obj);
    var found = i > -1;
    if (found) {
        arr.splice(i, 1);
    }
    return found;
}
/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
    var length = arr.length >>> 0;
    var value;
    for (var i = 0; i < length; i++) {
        value = arr[i];
        if (func(value, i, arr)) {
            return value;
        }
    }
    return null;
}
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
    var len1 = arr1.length;
    if (len1 !== arr2.length) {
        return false;
    }
    for (var i = 0; i < len1; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
    var length = arr.length;
    var tmp = Array(arr.length);
    var i;
    for (i = 0; i < length; i++) {
        tmp[i] = { index: i, value: arr[i] };
    }
    tmp.sort(function (a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
    });
    for (i = 0; i < arr.length; i++) {
        arr[i] = tmp[i].value;
    }
}
/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
    var index;
    var found = !arr.every(function (el, idx) {
        index = idx;
        return !func(el, idx, arr);
    });
    return found ? index : -1;
}
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [opt_func] Comparison function.
 * @param {boolean} [opt_strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
    var compare = opt_func || numberSafeCompareFunction;
    return arr.every(function (currentVal, index) {
        if (index === 0) {
            return true;
        }
        var res = compare(arr[index - 1], currentVal);
        return !(res > 0 || (opt_strict && res === 0));
    });
}
//# sourceMappingURL=array.js.map

/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointOfArray", function() { return getInteriorPointOfArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointsOfMultiArray", function() { return getInteriorPointsOfMultiArray; });
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(235);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(233);
/**
 * @module ol/geom/flat/interiorpoint
 */


/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
    var i, ii, x, x1, x2, y1, y2;
    var y = flatCenters[flatCentersOffset + 1];
    /** @type {Array<number>} */
    var intersections = [];
    // Calculate intersections with the horizontal line
    for (var r = 0, rr = ends.length; r < rr; ++r) {
        var end = ends[r];
        x1 = flatCoordinates[end - stride];
        y1 = flatCoordinates[end - stride + 1];
        for (i = offset; i < end; i += stride) {
            x2 = flatCoordinates[i];
            y2 = flatCoordinates[i + 1];
            if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
                x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
                intersections.push(x);
            }
            x1 = x2;
            y1 = y2;
        }
    }
    // Find the longest segment of the horizontal line that has its center point
    // inside the linear ring.
    var pointX = NaN;
    var maxSegmentLength = -Infinity;
    intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_1__["numberSafeCompareFunction"]);
    x1 = intersections[0];
    for (i = 1, ii = intersections.length; i < ii; ++i) {
        x2 = intersections[i];
        var segmentLength = Math.abs(x2 - x1);
        if (segmentLength > maxSegmentLength) {
            x = (x1 + x2) / 2;
            if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_0__["linearRingsContainsXY"])(flatCoordinates, offset, ends, stride, x, y)) {
                pointX = x;
                maxSegmentLength = segmentLength;
            }
        }
        x1 = x2;
    }
    if (isNaN(pointX)) {
        // There is no horizontal line that has its center point inside the linear
        // ring.  Use the center of the the linear ring's extent.
        pointX = flatCenters[flatCentersOffset];
    }
    if (opt_dest) {
        opt_dest.push(pointX, y, maxSegmentLength);
        return opt_dest;
    }
    else {
        return [pointX, y, maxSegmentLength];
    }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
    var interiorPoints = [];
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
        offset = ends[ends.length - 1];
    }
    return interiorPoints;
}
//# sourceMappingURL=interiorpoint.js.map

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsExtent", function() { return linearRingContainsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsXY", function() { return linearRingContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingsContainsXY", function() { return linearRingsContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingssContainsXY", function() { return linearRingssContainsXY; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(230);
/**
 * @module ol/geom/flat/contains
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
    var outside = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent, 
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function (coordinate) {
        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
    return !outside;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
    // https://geomalgorithms.com/a03-_inclusion.html
    // Copyright 2000 softSurfer, 2012 Dan Sunday
    // This code may be freely used and modified for any purpose
    // providing that this copyright notice is included with it.
    // SoftSurfer makes no warranty for this code, and cannot be held
    // liable for any real or imagined damage resulting from its use.
    // Users of this code must verify correctness for their application.
    var wn = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];
    for (; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        if (y1 <= y) {
            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                wn++;
            }
        }
        else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
            wn--;
        }
        x1 = x2;
        y1 = y2;
    }
    return wn !== 0;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
    if (ends.length === 0) {
        return false;
    }
    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
        return false;
    }
    for (var i = 1, ii = ends.length; i < ii; ++i) {
        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
            return false;
        }
    }
    return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
    if (endss.length === 0) {
        return false;
    }
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
            return true;
        }
        offset = ends[ends.length - 1];
    }
    return false;
}
//# sourceMappingURL=contains.js.map

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTransform", function() { return cloneTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identityTransform", function() { return identityTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjection", function() { return addProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjections", function() { return addProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointResolution", function() { return getPointResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentProjections", function() { return addEquivalentProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentTransforms", function() { return addEquivalentTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAllProjections", function() { return clearAllProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createProjection", function() { return createProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformFromCoordinateTransform", function() { return createTransformFromCoordinateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCoordinateTransforms", function() { return addCoordinateTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromLonLat", function() { return fromLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toLonLat", function() { return toLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equivalent", function() { return equivalent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformFromProjections", function() { return getTransformFromProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransform", function() { return getTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformExtent", function() { return transformExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformWithProjections", function() { return transformWithProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUserProjection", function() { return setUserProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearUserProjection", function() { return clearUserProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUserProjection", function() { return getUserProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useGeographic", function() { return useGeographic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUserCoordinate", function() { return toUserCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromUserCoordinate", function() { return fromUserCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUserExtent", function() { return toUserExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromUserExtent", function() { return fromUserExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUserResolution", function() { return toUserResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromUserResolution", function() { return fromUserResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSafeCoordinateTransform", function() { return createSafeCoordinateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommon", function() { return addCommon; });
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(237);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return _proj_Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(238);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["METERS_PER_UNIT"]; });

/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(241);
/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(242);
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(243);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(230);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(240);
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(245);
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(246);
/**
 * @module ol/proj
 */
/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */










/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */
/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */


/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
    var output;
    if (opt_output !== undefined) {
        for (var i = 0, ii = input.length; i < ii; ++i) {
            opt_output[i] = input[i];
        }
        output = opt_output;
    }
    else {
        output = input.slice();
    }
    return output;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
    if (opt_output !== undefined && input !== opt_output) {
        for (var i = 0, ii = input.length; i < ii; ++i) {
            opt_output[i] = input[i];
        }
        input = opt_output;
    }
    return input;
}
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
    Object(_proj_projections_js__WEBPACK_IMPORTED_MODULE_4__["add"])(projection.getCode(), projection);
    Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["add"])(projection, projection, cloneTransform);
}
/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
    projections.forEach(addProjection);
}
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
    return typeof projectionLike === 'string'
        ? Object(_proj_projections_js__WEBPACK_IMPORTED_MODULE_4__["get"])(/** @type {string} */ (projectionLike))
        : /** @type {Projection} */ (projectionLike) || null;
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").default} [opt_units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
    projection = get(projection);
    var pointResolution;
    var getter = projection.getPointResolutionFunc();
    if (getter) {
        pointResolution = getter(resolution, point);
        if (opt_units && opt_units !== projection.getUnits()) {
            var metersPerUnit = projection.getMetersPerUnit();
            if (metersPerUnit) {
                pointResolution =
                    (pointResolution * metersPerUnit) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["METERS_PER_UNIT"][opt_units];
            }
        }
    }
    else {
        var units = projection.getUnits();
        if ((units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES && !opt_units) || opt_units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES) {
            pointResolution = resolution;
        }
        else {
            // Estimate point resolution by transforming the center pixel to EPSG:4326,
            // measuring its width and height on the normal sphere, and taking the
            // average of the width and height.
            var toEPSG4326_1 = getTransformFromProjections(projection, get('EPSG:4326'));
            if (toEPSG4326_1 === identityTransform && units !== _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES) {
                // no transform is available
                pointResolution = resolution * projection.getMetersPerUnit();
            }
            else {
                var vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2,
                ];
                vertices = toEPSG4326_1(vertices, vertices, 2);
                var width = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_8__["getDistance"])(vertices.slice(0, 2), vertices.slice(2, 4));
                var height = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_8__["getDistance"])(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
            }
            var metersPerUnit = opt_units
                ? _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["METERS_PER_UNIT"][opt_units]
                : projection.getMetersPerUnit();
            if (metersPerUnit !== undefined) {
                pointResolution /= metersPerUnit;
            }
        }
    }
    return pointResolution;
}
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function (source) {
        projections.forEach(function (destination) {
            if (source !== destination) {
                Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["add"])(source, destination, cloneTransform);
            }
        });
    });
}
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function (projection1) {
        projections2.forEach(function (projection2) {
            Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["add"])(projection1, projection2, forwardTransform);
            Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["add"])(projection2, projection1, inverseTransform);
        });
    });
}
/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
    Object(_proj_projections_js__WEBPACK_IMPORTED_MODULE_4__["clear"])();
    Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["clear"])();
}
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
    if (!projection) {
        return get(defaultCode);
    }
    else if (typeof projection === 'string') {
        return get(projection);
    }
    else {
        return /** @type {Projection} */ (projection);
    }
}
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
    return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [opt_output] Output.
     * @param {number} [opt_dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
        var length = input.length;
        var dimension = opt_dimension !== undefined ? opt_dimension : 2;
        var output = opt_output !== undefined ? opt_output : new Array(length);
        for (var i = 0; i < length; i += dimension) {
            var point = coordTransform([input[i], input[i + 1]]);
            output[i] = point[0];
            output[i + 1] = point[1];
            for (var j = dimension - 1; j >= 2; --j) {
                output[i + j] = input[i + j];
            }
        }
        return output;
    });
}
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
    var sourceProj = get(source);
    var destProj = get(destination);
    Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["add"])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
    Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["add"])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [opt_projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
    return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [opt_projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
    var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
    var lon = lonLat[0];
    if (lon < -180 || lon > 180) {
        lonLat[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_7__["modulo"])(lon + 180, 360) - 180;
    }
    return lonLat;
}
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
    if (projection1 === projection2) {
        return true;
    }
    var equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) {
        return equalUnits;
    }
    else {
        var transformFunc = getTransformFromProjections(projection1, projection2);
        return transformFunc === cloneTransform && equalUnits;
    }
}
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
    var sourceCode = sourceProjection.getCode();
    var destinationCode = destinationProjection.getCode();
    var transformFunc = Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_5__["get"])(sourceCode, destinationCode);
    if (!transformFunc) {
        transformFunc = identityTransform;
    }
    return transformFunc;
}
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
    var sourceProjection = get(source);
    var destinationProjection = get(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
}
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
    var transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, undefined, coordinate.length);
}
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination, opt_stops) {
    var transformFunc = getTransform(source, destination);
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["applyTransform"])(extent, transformFunc, undefined, opt_stops);
}
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
    var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
    return transformFunc(point);
}
/**
 * @type {?Projection}
 */
var userProjection = null;
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @param {ProjectionLike} projection The user projection.
 */
function setUserProjection(projection) {
    userProjection = get(projection);
}
/**
 * Clear the user projection if set.  Note that this method is not yet a part of
 * the stable API.  Support for user projections is not yet complete and should
 * be considered experimental.
 */
function clearUserProjection() {
    userProjection = null;
}
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @return {?Projection} The user projection (or null if not set).
 */
function getUserProjection() {
    return userProjection;
}
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  Note that this
 * method is not yet a part of the stable API.  Support for user projections is
 * not yet complete and should be considered experimental.
 */
function useGeographic() {
    setUserProjection('EPSG:4326');
}
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */
function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) {
        return coordinate;
    }
    return transform(coordinate, sourceProjection, userProjection);
}
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */
function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) {
        return coordinate;
    }
    return transform(coordinate, userProjection, destProjection);
}
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */
function toUserExtent(extent, sourceProjection) {
    if (!userProjection) {
        return extent;
    }
    return transformExtent(extent, sourceProjection, userProjection);
}
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */
function fromUserExtent(extent, destProjection) {
    if (!userProjection) {
        return extent;
    }
    return transformExtent(extent, userProjection, destProjection);
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */
function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) {
        return resolution;
    }
    var sourceUnits = get(sourceProjection).getUnits();
    var userUnits = userProjection.getUnits();
    return sourceUnits && userUnits
        ? (resolution * _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["METERS_PER_UNIT"][sourceUnits]) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["METERS_PER_UNIT"][userUnits]
        : resolution;
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */
function fromUserResolution(resolution, destProjection) {
    if (!userProjection) {
        return resolution;
    }
    var sourceUnits = get(destProjection).getUnits();
    var userUnits = userProjection.getUnits();
    return sourceUnits && userUnits
        ? (resolution * _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["METERS_PER_UNIT"][userUnits]) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["METERS_PER_UNIT"][sourceUnits]
        : resolution;
}
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
 */
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
    return function (coord) {
        var sourceX = coord[0];
        var sourceY = coord[1];
        var transformed, worldsAway;
        if (sourceProj.canWrapX()) {
            var sourceExtent = sourceProj.getExtent();
            var sourceExtentWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["getWidth"])(sourceExtent);
            worldsAway = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["getWorldsAway"])(coord, sourceProj, sourceExtentWidth);
            if (worldsAway) {
                // Move x to the real world
                sourceX = sourceX - worldsAway * sourceExtentWidth;
            }
            sourceX = Object(_math_js__WEBPACK_IMPORTED_MODULE_7__["clamp"])(sourceX, sourceExtent[0], sourceExtent[2]);
            sourceY = Object(_math_js__WEBPACK_IMPORTED_MODULE_7__["clamp"])(sourceY, sourceExtent[1], sourceExtent[3]);
            transformed = transform([sourceX, sourceY]);
        }
        else {
            transformed = transform(coord);
        }
        if (worldsAway && destProj.canWrapX()) {
            // Move transformed coordinate back to the offset world
            transformed[0] += worldsAway * Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["getWidth"])(destProj.getExtent());
        }
        return transformed;
    };
}
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_2__["PROJECTIONS"]);
    addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"]);
    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.
    addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_2__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_2__["fromEPSG4326"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_2__["toEPSG4326"]);
}
addCommon();
//# sourceMappingURL=proj.js.map

/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(238);
/**
 * @module ol/proj/Projection
 */

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution getPointResolution()} function will be used.
 */
/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */
var Projection = /** @class */ (function () {
    /**
     * @param {Options} options Projection options.
     */
    function Projection(options) {
        /**
         * @private
         * @type {string}
         */
        this.code_ = options.code;
        /**
         * Units of projected coordinates. When set to `TILE_PIXELS`, a
         * `this.extent_` and `this.worldExtent_` must be configured properly for each
         * tile.
         * @private
         * @type {import("./Units.js").default}
         */
        this.units_ = /** @type {import("./Units.js").default} */ (options.units);
        /**
         * Validity extent of the projection in projected coordinates. For projections
         * with `TILE_PIXELS` units, this is the extent of the tile in
         * tile pixel space.
         * @private
         * @type {import("../extent.js").Extent}
         */
        this.extent_ = options.extent !== undefined ? options.extent : null;
        /**
         * Extent of the world in EPSG:4326. For projections with
         * `TILE_PIXELS` units, this is the extent of the tile in
         * projected coordinate space.
         * @private
         * @type {import("../extent.js").Extent}
         */
        this.worldExtent_ =
            options.worldExtent !== undefined ? options.worldExtent : null;
        /**
         * @private
         * @type {string}
         */
        this.axisOrientation_ =
            options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
        /**
         * @private
         * @type {boolean}
         */
        this.global_ = options.global !== undefined ? options.global : false;
        /**
         * @private
         * @type {boolean}
         */
        this.canWrapX_ = !!(this.global_ && this.extent_);
        /**
         * @private
         * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
         */
        this.getPointResolutionFunc_ = options.getPointResolution;
        /**
         * @private
         * @type {import("../tilegrid/TileGrid.js").default}
         */
        this.defaultTileGrid_ = null;
        /**
         * @private
         * @type {number|undefined}
         */
        this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    Projection.prototype.canWrapX = function () {
        return this.canWrapX_;
    };
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    Projection.prototype.getCode = function () {
        return this.code_;
    };
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    Projection.prototype.getExtent = function () {
        return this.extent_;
    };
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").default} Units.
     * @api
     */
    Projection.prototype.getUnits = function () {
        return this.units_;
    };
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    Projection.prototype.getMetersPerUnit = function () {
        return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__["METERS_PER_UNIT"][this.units_];
    };
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    Projection.prototype.getWorldExtent = function () {
        return this.worldExtent_;
    };
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    Projection.prototype.getAxisOrientation = function () {
        return this.axisOrientation_;
    };
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    Projection.prototype.isGlobal = function () {
        return this.global_;
    };
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    Projection.prototype.setGlobal = function (global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
    };
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
    Projection.prototype.getDefaultTileGrid = function () {
        return this.defaultTileGrid_;
    };
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
    Projection.prototype.setDefaultTileGrid = function (tileGrid) {
        this.defaultTileGrid_ = tileGrid;
    };
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    Projection.prototype.setExtent = function (extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
    };
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
    Projection.prototype.setWorldExtent = function (worldExtent) {
        this.worldExtent_ = worldExtent;
    };
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
    Projection.prototype.setGetPointResolution = function (func) {
        this.getPointResolutionFunc_ = func;
    };
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
    Projection.prototype.getPointResolutionFunc = function () {
        return this.getPointResolutionFunc_;
    };
    return Projection;
}());
/* harmony default export */ __webpack_exports__["default"] = (Projection);
//# sourceMappingURL=Projection.js.map

/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromCode", function() { return fromCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/**
 * @module ol/proj/Units
 */
/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
    /**
     * Radians
     * @api
     */
    RADIANS: 'radians',
    /**
     * Degrees
     * @api
     */
    DEGREES: 'degrees',
    /**
     * Feet
     * @api
     */
    FEET: 'ft',
    /**
     * Meters
     * @api
     */
    METERS: 'm',
    /**
     * Pixels
     * @api
     */
    PIXELS: 'pixels',
    /**
     * Tile Pixels
     * @api
     */
    TILE_PIXELS: 'tile-pixels',
    /**
     * US Feet
     * @api
     */
    USFEET: 'us-ft',
};
/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */
var unitByCode = {
    '9001': Units.METERS,
    '9002': Units.FEET,
    '9003': Units.USFEET,
    '9101': Units.RADIANS,
    '9102': Units.DEGREES,
};
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */
function fromCode(code) {
    return unitByCode[code];
}
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */
var METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.RADIANS] = 6370997 / (2 * Math.PI);
METERS_PER_UNIT[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
/* harmony default export */ __webpack_exports__["default"] = (Units);
//# sourceMappingURL=Units.js.map

/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_SIZE", function() { return HALF_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORLD_EXTENT", function() { return WORLD_EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_SAFE_Y", function() { return MAX_SAFE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEPSG4326", function() { return fromEPSG4326; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toEPSG4326", function() { return toEPSG4326; });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(237);
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(238);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(240);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/proj/epsg3857
 */



/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */
var HALF_SIZE = Math.PI * RADIUS;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
var EPSG3857Projection = /** @class */ (function (_super) {
    __extends(EPSG3857Projection, _super);
    /**
     * @param {string} code Code.
     */
    function EPSG3857Projection(code) {
        return _super.call(this, {
            code: code,
            units: _Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].METERS,
            extent: EXTENT,
            global: true,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function (resolution, point) {
                return resolution / Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cosh"])(point[1] / RADIUS);
            },
        }) || this;
    }
    return EPSG3857Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"]));
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
    new EPSG3857Projection('EPSG:3857'),
    new EPSG3857Projection('EPSG:102100'),
    new EPSG3857Projection('EPSG:102113'),
    new EPSG3857Projection('EPSG:900913'),
    new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
    new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var output = opt_output;
    if (output === undefined) {
        if (dimension > 2) {
            // preserve values beyond second dimension
            output = input.slice();
        }
        else {
            output = new Array(length);
        }
    }
    for (var i = 0; i < length; i += dimension) {
        output[i] = (HALF_SIZE * input[i]) / 180;
        var y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
        if (y > MAX_SAFE_Y) {
            y = MAX_SAFE_Y;
        }
        else if (y < -MAX_SAFE_Y) {
            y = -MAX_SAFE_Y;
        }
        output[i + 1] = y;
    }
    return output;
}
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var output = opt_output;
    if (output === undefined) {
        if (dimension > 2) {
            // preserve values beyond second dimension
            output = input.slice();
        }
        else {
            output = new Array(length);
        }
    }
    for (var i = 0; i < length; i += dimension) {
        output[i] = (180 * input[i]) / HALF_SIZE;
        output[i + 1] =
            (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
    }
    return output;
}
//# sourceMappingURL=epsg3857.js.map

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log2", function() { return log2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredSegmentDistance", function() { return squaredSegmentDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveLinearSystem", function() { return solveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return modulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/**
 * @module ol/math
 */
/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
var cosh = (function () {
    // Wrapped in a iife, to save the overhead of checking for the native
    // implementation on every invocation.
    var cosh;
    if ('cosh' in Math) {
        // The environment supports the native Math.cosh function, use it…
        cosh = Math.cosh;
    }
    else {
        // … else, use the reference implementation of MDN:
        cosh = function (x) {
            var y = /** @type {Math} */ (Math).exp(x);
            return (y + 1 / y) / 2;
        };
    }
    return cosh;
})();
/**
 * Return the base 2 logarithm of a given number. The method will use the
 * native `Math.log2` function if it is available, otherwise the base 2
 * logarithm will be calculated via the reference implementation of the
 * Mozilla developer network.
 *
 * @param {number} x X.
 * @return {number} Base 2 logarithm of x.
 */
var log2 = (function () {
    // Wrapped in a iife, to save the overhead of checking for the native
    // implementation on every invocation.
    var log2;
    if ('log2' in Math) {
        // The environment supports the native Math.log2 function, use it…
        log2 = Math.log2;
    }
    else {
        // … else, use the reference implementation of MDN:
        log2 = function (x) {
            return Math.log(x) * Math.LOG2E;
        };
    }
    return log2;
})();
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x1 = x2;
            y1 = y2;
        }
        else if (t > 0) {
            x1 += dx * t;
            y1 += dy * t;
        }
    }
    return squaredDistance(x, y, x1, y1);
}
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
}
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
    var n = mat.length;
    for (var i = 0; i < n; i++) {
        // Find max in the i-th column (ignoring i - 1 first rows)
        var maxRow = i;
        var maxEl = Math.abs(mat[i][i]);
        for (var r = i + 1; r < n; r++) {
            var absValue = Math.abs(mat[r][i]);
            if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
            }
        }
        if (maxEl === 0) {
            return null; // matrix is singular
        }
        // Swap max row with i-th (current) row
        var tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;
        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for (var j = i + 1; j < n; j++) {
            var coef = -mat[j][i] / mat[i][i];
            for (var k = i; k < n + 1; k++) {
                if (i == k) {
                    mat[j][k] = 0;
                }
                else {
                    mat[j][k] += coef * mat[i][k];
                }
            }
        }
    }
    // Solve Ax=b for upper triangular matrix A (mat)
    var x = new Array(n);
    for (var l = n - 1; l >= 0; l--) {
        x[l] = mat[l][n] / mat[l][l];
        for (var m = l - 1; m >= 0; m--) {
            mat[m][n] -= mat[m][l] * x[l];
        }
    }
    return x;
}
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
    return (angleInRadians * 180) / Math.PI;
}
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
    return (angleInDegrees * Math.PI) / 180;
}
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
    var r = a % b;
    return r * b < 0 ? r + b : r;
}
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
    return a + x * (b - a);
}
//# sourceMappingURL=math.js.map

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(237);
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(238);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/proj/epsg4326
 */


/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = (Math.PI * RADIUS) / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
var EPSG4326Projection = /** @class */ (function (_super) {
    __extends(EPSG4326Projection, _super);
    /**
     * @param {string} code Code.
     * @param {string} [opt_axisOrientation] Axis orientation.
     */
    function EPSG4326Projection(code, opt_axisOrientation) {
        return _super.call(this, {
            code: code,
            units: _Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES,
            extent: EXTENT,
            axisOrientation: opt_axisOrientation,
            global: true,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: EXTENT,
        }) || this;
    }
    return EPSG4326Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"]));
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
    new EPSG4326Projection('CRS:84'),
    new EPSG4326Projection('EPSG:4326', 'neu'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84', 'neu'),
    new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),
];
//# sourceMappingURL=epsg4326.js.map

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/**
 * @module ol/proj/projections
 */
/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};
/**
 * Clear the projections cache.
 */
function clear() {
    cache = {};
}
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
    return (cache[code] ||
        cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] ||
        null);
}
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
    cache[code] = projection;
}
//# sourceMappingURL=projections.js.map

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(244);
/**
 * @module ol/proj/transforms
 */

/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};
/**
 * Clear the transform cache.
 */
function clear() {
    transforms = {};
}
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
    var sourceCode = source.getCode();
    var destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) {
        transforms[sourceCode] = {};
    }
    transforms[sourceCode][destinationCode] = transformFn;
}
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
    var sourceCode = source.getCode();
    var destinationCode = destination.getCode();
    var transform = transforms[sourceCode][destinationCode];
    delete transforms[sourceCode][destinationCode];
    if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(transforms[sourceCode])) {
        delete transforms[sourceCode];
    }
    return transform;
}
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
    var transform;
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
        transform = transforms[sourceCode][destinationCode];
    }
    return transform;
}
//# sourceMappingURL=transforms.js.map

/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValues", function() { return getValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/**
 * @module ol/obj
 */
/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = typeof Object.assign === 'function'
    ? Object.assign
    : function (target, var_sources) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        for (var i = 1, ii = arguments.length; i < ii; ++i) {
            var source = arguments[i];
            if (source !== undefined && source !== null) {
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        output[key] = source[key];
                    }
                }
            }
        }
        return output;
    };
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
    for (var property in object) {
        delete object[property];
    }
}
/**
 * Polyfill for Object.values().  Get an array of property values from an object.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
 *
 * @param {!Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
var getValues = typeof Object.values === 'function'
    ? Object.values
    : function (object) {
        var values = [];
        for (var property in object) {
            values.push(object[property]);
        }
        return values;
    };
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
    var property;
    for (property in object) {
        return false;
    }
    return !property;
}
//# sourceMappingURL=obj.js.map

/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RADIUS", function() { return DEFAULT_RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistance", function() { return getDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLength", function() { return getLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return offset; });
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(224);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/**
 * @module ol/sphere
 */


/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */
/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
    var radius = opt_radius || DEFAULT_RADIUS;
    var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(c1[1]);
    var lat2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(c2[1]);
    var deltaLatBy2 = (lat2 - lat1) / 2;
    var deltaLonBy2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(c2[0] - c1[0]) / 2;
    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
        Math.sin(deltaLonBy2) *
            Math.sin(deltaLonBy2) *
            Math.cos(lat1) *
            Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
    var length = 0;
    for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
        length += getDistance(coordinates[i], coordinates[i + 1], radius);
    }
    return length;
}
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
    var options = opt_options || {};
    var radius = options.radius || DEFAULT_RADIUS;
    var projection = options.projection || 'EPSG:3857';
    var type = geometry.getType();
    if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].GEOMETRY_COLLECTION) {
        geometry = geometry.clone().transform(projection, 'EPSG:4326');
    }
    var length = 0;
    var coordinates, coords, i, ii, j, jj;
    switch (type) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].MULTI_POINT: {
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINEAR_RING: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            length = getLengthInternal(coordinates, radius);
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].MULTI_LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            for (i = 0, ii = coordinates.length; i < ii; ++i) {
                length += getLengthInternal(coordinates[i], radius);
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].MULTI_POLYGON: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            for (i = 0, ii = coordinates.length; i < ii; ++i) {
                coords = coordinates[i];
                for (j = 0, jj = coords.length; j < jj; ++j) {
                    length += getLengthInternal(coords[j], radius);
                }
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].GEOMETRY_COLLECTION: {
            var geometries = 
            /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
            for (i = 0, ii = geometries.length; i < ii; ++i) {
                length += getLength(geometries[i], opt_options);
            }
            break;
        }
        default: {
            throw new Error('Unsupported geometry type: ' + type);
        }
    }
    return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
    var area = 0;
    var len = coordinates.length;
    var x1 = coordinates[len - 1][0];
    var y1 = coordinates[len - 1][1];
    for (var i = 0; i < len; i++) {
        var x2 = coordinates[i][0];
        var y2 = coordinates[i][1];
        area +=
            Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(x2 - x1) *
                (2 + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(y1)) + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(y2)));
        x1 = x2;
        y1 = y2;
    }
    return (area * radius * radius) / 2.0;
}
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
    var options = opt_options || {};
    var radius = options.radius || DEFAULT_RADIUS;
    var projection = options.projection || 'EPSG:3857';
    var type = geometry.getType();
    if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].GEOMETRY_COLLECTION) {
        geometry = geometry.clone().transform(projection, 'EPSG:4326');
    }
    var area = 0;
    var coordinates, coords, i, ii, j, jj;
    switch (type) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].MULTI_POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].MULTI_LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINEAR_RING: {
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON: {
            coordinates = /** @type {import("./geom/Polygon.js").default} */ (geometry).getCoordinates();
            area = Math.abs(getAreaInternal(coordinates[0], radius));
            for (i = 1, ii = coordinates.length; i < ii; ++i) {
                area -= Math.abs(getAreaInternal(coordinates[i], radius));
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].MULTI_POLYGON: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            for (i = 0, ii = coordinates.length; i < ii; ++i) {
                coords = coordinates[i];
                area += Math.abs(getAreaInternal(coords[0], radius));
                for (j = 1, jj = coords.length; j < jj; ++j) {
                    area -= Math.abs(getAreaInternal(coords[j], radius));
                }
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__["default"].GEOMETRY_COLLECTION: {
            var geometries = 
            /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
            for (i = 0, ii = geometries.length; i < ii; ++i) {
                area += getArea(geometries[i], opt_options);
            }
            break;
        }
        default: {
            throw new Error('Unsupported geometry type: ' + type);
        }
    }
    return area;
}
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
    var radius = opt_radius || DEFAULT_RADIUS;
    var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(c1[1]);
    var lon1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toRadians"])(c1[0]);
    var dByR = distance / radius;
    var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) +
        Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
    var lon = lon1 +
        Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
    return [Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toDegrees"])(lon), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["toDegrees"])(lat)];
}
//# sourceMappingURL=sphere.js.map

/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnCircle", function() { return closestOnCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnSegment", function() { return closestOnSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStringXY", function() { return createStringXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToStringHDMS", function() { return degreesToStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistanceToSegment", function() { return squaredDistanceToSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringHDMS", function() { return toStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringXY", function() { return toStringXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapX", function() { return wrapX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWorldsAway", function() { return getWorldsAway; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(230);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(247);
/**
 * @module ol/coordinate
 */



/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */
/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */
/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
}
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
    var r = circle.getRadius();
    var center = circle.getCenter();
    var x0 = center[0];
    var y0 = center[1];
    var x1 = coordinate[0];
    var y1 = coordinate[1];
    var dx = x1 - x0;
    var dy = y1 - y0;
    if (dx === 0 && dy === 0) {
        dx = 1;
    }
    var d = Math.sqrt(dx * dx + dy * dy);
    var x = x0 + (r * dx) / d;
    var y = y0 + (r * dy) / d;
    return [x, y];
}
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
    var x0 = coordinate[0];
    var y0 = coordinate[1];
    var start = segment[0];
    var end = segment[1];
    var x1 = start[0];
    var y1 = start[1];
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = dx === 0 && dy === 0
        ? 0
        : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    var x, y;
    if (along <= 0) {
        x = x1;
        y = y1;
    }
    else if (along >= 1) {
        x = x2;
        y = y2;
    }
    else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return [x, y];
}
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(opt_fractionDigits) {
    return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
        return toStringXY(coordinate, opt_fractionDigits);
    });
}
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
    var normalizedDegrees = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(degrees + 180, 360) - 180;
    var x = Math.abs(3600 * normalizedDegrees);
    var dflPrecision = opt_fractionDigits || 0;
    var precision = Math.pow(10, dflPrecision);
    var deg = Math.floor(x / 3600);
    var min = Math.floor((x - deg * 3600) / 60);
    var sec = x - deg * 3600 - min * 60;
    sec = Math.ceil(sec * precision) / precision;
    if (sec >= 60) {
        sec = 0;
        min += 1;
    }
    if (min >= 60) {
        min = 0;
        deg += 1;
    }
    return (deg +
        '\u00b0 ' +
        Object(_string_js__WEBPACK_IMPORTED_MODULE_2__["padNumber"])(min, 2) +
        '\u2032 ' +
        Object(_string_js__WEBPACK_IMPORTED_MODULE_2__["padNumber"])(sec, 2, dflPrecision) +
        '\u2033' +
        (normalizedDegrees == 0
            ? ''
            : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0)));
}
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, opt_fractionDigits) {
    if (coordinate) {
        return template
            .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
            .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
    }
    else {
        return '';
    }
}
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
    var equals = true;
    for (var i = coordinate1.length - 1; i >= 0; --i) {
        if (coordinate1[i] != coordinate2[i]) {
            equals = false;
            break;
        }
    }
    return equals;
}
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
}
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
    var dx = coord1[0] - coord2[0];
    var dy = coord1[1] - coord2[1];
    return dx * dx + dy * dy;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
}
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, opt_fractionDigits) {
    if (coordinate) {
        return (degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) +
            ' ' +
            degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits));
    }
    else {
        return '';
    }
}
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, opt_fractionDigits) {
    return format(coordinate, '{x}, {y}', opt_fractionDigits);
}
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */
function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
        var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(projection.getExtent());
        var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
        if (worldsAway) {
            coordinate[0] -= worldsAway * worldWidth;
        }
    }
    return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [opt_sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */
function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
    var projectionExtent = projection.getExtent();
    var worldsAway = 0;
    if (projection.canWrapX() &&
        (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
        var sourceExtentWidth = opt_sourceExtentWidth || Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(projectionExtent);
        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }
    return worldsAway;
}
//# sourceMappingURL=coordinate.js.map

/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padNumber", function() { return padNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersions", function() { return compareVersions; });
/**
 * @module ol/string
 */
/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [opt_precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
    var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
    var decimal = numberString.indexOf('.');
    decimal = decimal === -1 ? numberString.length : decimal;
    return decimal > width
        ? numberString
        : new Array(1 + width - decimal).join('0') + numberString;
}
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */
function compareVersions(v1, v2) {
    var s1 = ('' + v1).split('.');
    var s2 = ('' + v2).split('.');
    for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
        var n1 = parseInt(s1[i] || '0', 10);
        var n2 = parseInt(s2[i] || '0', 10);
        if (n1 > n2) {
            return 1;
        }
        if (n2 > n1) {
            return -1;
        }
    }
    return 0;
}
//# sourceMappingURL=string.js.map

/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolatePoint", function() { return interpolatePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringCoordinateAtM", function() { return lineStringCoordinateAtM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringsCoordinateAtM", function() { return lineStringsCoordinateAtM; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/**
 * @module ol/geom/flat/interpolate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [opt_dest] Destination.
 * @param {number} [opt_dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
    var o, t;
    var n = (end - offset) / stride;
    if (n === 1) {
        o = offset;
    }
    else if (n === 2) {
        o = offset;
        t = fraction;
    }
    else if (n !== 0) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        var length_1 = 0;
        var cumulativeLengths = [0];
        for (var i = offset + stride; i < end; i += stride) {
            var x2 = flatCoordinates[i];
            var y2 = flatCoordinates[i + 1];
            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            cumulativeLengths.push(length_1);
            x1 = x2;
            y1 = y2;
        }
        var target = fraction * length_1;
        var index = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["binarySearch"])(cumulativeLengths, target);
        if (index < 0) {
            t =
                (target - cumulativeLengths[-index - 2]) /
                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
            o = offset + (-index - 2) * stride;
        }
        else {
            o = offset + index * stride;
        }
    }
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var dest = opt_dest ? opt_dest : new Array(dimension);
    for (var i = 0; i < dimension; ++i) {
        dest[i] =
            o === undefined
                ? NaN
                : t === undefined
                    ? flatCoordinates[o + i]
                    : Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
    }
    return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) {
        return null;
    }
    var coordinate;
    if (m < flatCoordinates[offset + stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(offset, offset + stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    else if (flatCoordinates[end - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(end - stride, end);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    // FIXME use O(1) search
    if (m == flatCoordinates[offset + stride - 1]) {
        return flatCoordinates.slice(offset, offset + stride);
    }
    var lo = offset / stride;
    var hi = end / stride;
    while (lo < hi) {
        var mid = (lo + hi) >> 1;
        if (m < flatCoordinates[(mid + 1) * stride - 1]) {
            hi = mid;
        }
        else {
            lo = mid + 1;
        }
    }
    var m0 = flatCoordinates[lo * stride - 1];
    if (m == m0) {
        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    }
    var m1 = flatCoordinates[(lo + 1) * stride - 1];
    var t = (m - m0) / (m1 - m0);
    coordinate = [];
    for (var i = 0; i < stride - 1; ++i) {
        coordinate.push(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
    }
    coordinate.push(m);
    return coordinate;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) {
        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    }
    var coordinate;
    if (m < flatCoordinates[stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(0, stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        if (offset == end) {
            continue;
        }
        if (m < flatCoordinates[offset + stride - 1]) {
            return null;
        }
        else if (m <= flatCoordinates[end - 1]) {
            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
        }
        offset = end;
    }
    return null;
}
//# sourceMappingURL=interpolate.js.map

/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingss", function() { return linearRingss; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(230);
/**
 * @module ol/geom/flat/center
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
    var flatCenters = [];
    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromFlatCoordinates"])(flatCoordinates, offset, ends[0], stride);
        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
        offset = ends[ends.length - 1];
    }
    return flatCenters;
}
//# sourceMappingURL=center.js.map

/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform2D", function() { return transform2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/**
 * @module ol/geom/flat/transform
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        var x = flatCoordinates[j];
        var y = flatCoordinates[j + 1];
        dest[i++] = transform[0] * x + transform[2] * y + transform[4];
        dest[i++] = transform[1] * x + transform[3] * y + transform[5];
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + deltaX * cos - deltaY * sin;
        dest[i++] = anchorY + deltaX * sin + deltaY * cos;
        for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
        }
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + sx * deltaX;
        dest[i++] = anchorY + sy * deltaY;
        for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
        }
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        dest[i++] = flatCoordinates[j] + deltaX;
        dest[i++] = flatCoordinates[j + 1] + deltaY;
        for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
        }
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
//# sourceMappingURL=transform.js.map

/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports = ol.style.Text;

/***/ }),
/* 252 */
/***/ (function(module, exports) {

var fontWeights = {
  thin: 100,
  hairline: 100,
  'ultra-light': 100,
  'extra-light': 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  'semi-bold': 600,
  'demi-bold': 600,
  bold: 700,
  heavy: 800,
  black: 800,
  'extra-bold': 800,
  'ultra-black': 900,
  'extra-black': 900,
  'ultra-bold': 900,
  'heavy-black': 900,
  fat: 900,
  poster: 900
};
var sp = ' ';
var italicRE = /(italic|oblique)$/i;

var fontCache = {};

module.exports = function(fonts, size, lineHeight) {
  var cssData = fontCache[fonts];
  if (!cssData) {
    if (!Array.isArray(fonts)) {
      fonts = [fonts];
    }
    var weight = 400;
    var style = 'normal';
    var fontFamilies = [];
    var haveWeight, haveStyle;
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      var parts = font.split(' ');
      var maybeWeight = parts[parts.length - 1].toLowerCase();
      if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {
        style = haveStyle ? style : maybeWeight;
        parts.pop();
        maybeWeight = parts[parts.length - 1].toLowerCase();
      } else if (italicRE.test(maybeWeight)) {
        maybeWeight = maybeWeight.replace(italicRE, '');
        style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, '');
      }
      for (var w in fontWeights) {
        var previousPart = parts.length > 1 ? parts[parts.length - 2].toLowerCase() : '';
        if (maybeWeight == w || maybeWeight == w.replace('-', '') || previousPart + '-' + maybeWeight == w) {
          weight = haveWeight ? weight : fontWeights[w];
          parts.pop();
          if (previousPart && w.startsWith(previousPart)) {
            parts.pop();
          }
          break;
        }
      }
      if (!haveWeight && typeof maybeWeight == 'number') {
        weight = maybeWeight;
      }
      var fontFamily = parts.join(sp)
        .replace('Klokantech Noto Sans', 'Noto Sans');
      if (fontFamily.indexOf(sp) !== -1) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies.push(fontFamily);
    }
    // CSS font property: font-style font-weight font-size/line-height font-family
    cssData = fontCache[fonts] = [style, weight, fontFamilies];
  }
  return cssData[0] + sp + cssData[1] + sp + size + 'px' + (lineHeight ? '/' + lineHeight : '') + sp + cssData[2];
};


/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParsingError", function() { return ParsingError$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ValidationError", function() { return ValidationError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composite", function() { return composite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertFilter", function() { return convertFilter$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "derefLayers", function() { return derefLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diff", function() { return diffStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expression", function() { return expression$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "featureFilter", function() { return createFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "function", function() { return styleFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "latest", function() { return v8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "migrate", function() { return migrate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v8", function() { return v8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validate", function() { return validateStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateMapboxApiSupported", function() { return validateMapboxApiSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visit", function() { return visit; });
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var $version = 8;
var $root = {
  version: {
    required: true,
    type: "enum",
    values: [8],
    doc: "Style specification version number. Must be 8.",
    example: 8
  },
  name: {
    type: "string",
    doc: "A human-readable name for the style.",
    example: "Bright"
  },
  metadata: {
    type: "*",
    doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
  },
  center: {
    type: "array",
    value: "number",
    doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    example: [-73.9749, 40.7736]
  },
  zoom: {
    type: "number",
    doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    example: 12.5
  },
  bearing: {
    type: "number",
    "default": 0,
    period: 360,
    units: "degrees",
    doc: "Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    example: 29
  },
  pitch: {
    type: "number",
    "default": 0,
    units: "degrees",
    doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    example: 50
  },
  light: {
    type: "light",
    doc: "The global light source.",
    example: {
      anchor: "viewport",
      color: "white",
      intensity: 0.4
    }
  },
  terrain: {
    type: "terrain",
    doc: "A global modifier that elevates layers and markers based on a DEM data source."
  },
  fog: {
    type: "fog",
    doc: "A global effect that fades layers and markers based on their distance to the camera. The fog can be used to approximate the effect of atmosphere on distant objects and enhance the depth perception of the map when used with terrain or 3D features."
  },
  sources: {
    required: true,
    type: "sources",
    doc: "Data source specifications.",
    example: {
      "mapbox-streets": {
        type: "vector",
        url: "mapbox://mapbox.mapbox-streets-v6"
      }
    }
  },
  sprite: {
    type: "string",
    doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
    example: "mapbox://sprites/mapbox/bright-v8"
  },
  glyphs: {
    type: "string",
    doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
    example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
  },
  transition: {
    type: "transition",
    doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
    example: {
      duration: 300,
      delay: 0
    }
  },
  layers: {
    required: true,
    type: "array",
    value: "layer",
    doc: "Layers will be drawn in the order of this array.",
    example: [{
      id: "water",
      source: "mapbox-streets",
      "source-layer": "water",
      type: "fill",
      paint: {
        "fill-color": "#00ffff"
      }
    }]
  }
};
var sources = {
  "*": {
    type: "source",
    doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
  }
};
var source = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var source_vector = {
  type: {
    required: true,
    type: "enum",
    values: {
      vector: {
        doc: "A vector tile source."
      }
    },
    doc: "The type of the source."
  },
  url: {
    type: "string",
    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
  },
  tiles: {
    type: "array",
    value: "string",
    doc: "An array of one or more tile source URLs, as in the TileJSON spec."
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    "default": [-180, -85.051129, 180, 85.051129],
    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {
        doc: "Slippy map tilenames scheme."
      },
      tms: {
        doc: "OSGeo spec scheme."
      }
    },
    "default": "xyz",
    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
  },
  minzoom: {
    type: "number",
    "default": 0,
    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
  },
  maxzoom: {
    type: "number",
    "default": 22,
    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  promoteId: {
    type: "promoteId",
    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."
  },
  "volatile": {
    type: "boolean",
    "default": false,
    doc: "A setting to determine whether a source's tiles are cached locally.",
    "sdk-support": {
      "basic functionality": {
        android: "9.3.0",
        ios: "5.10.0"
      }
    }
  },
  "*": {
    type: "*",
    doc: "Other keys to configure the data source."
  }
};
var source_raster = {
  type: {
    required: true,
    type: "enum",
    values: {
      raster: {
        doc: "A raster tile source."
      }
    },
    doc: "The type of the source."
  },
  url: {
    type: "string",
    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
  },
  tiles: {
    type: "array",
    value: "string",
    doc: "An array of one or more tile source URLs, as in the TileJSON spec."
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    "default": [-180, -85.051129, 180, 85.051129],
    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
  },
  minzoom: {
    type: "number",
    "default": 0,
    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
  },
  maxzoom: {
    type: "number",
    "default": 22,
    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
  },
  tileSize: {
    type: "number",
    "default": 512,
    units: "pixels",
    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {
        doc: "Slippy map tilenames scheme."
      },
      tms: {
        doc: "OSGeo spec scheme."
      }
    },
    "default": "xyz",
    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  "volatile": {
    type: "boolean",
    "default": false,
    doc: "A setting to determine whether a source's tiles are cached locally.",
    "sdk-support": {
      "basic functionality": {
        android: "9.3.0",
        ios: "5.10.0"
      }
    }
  },
  "*": {
    type: "*",
    doc: "Other keys to configure the data source."
  }
};
var source_raster_dem = {
  type: {
    required: true,
    type: "enum",
    values: {
      "raster-dem": {
        doc: "A RGB-encoded raster DEM source"
      }
    },
    doc: "The type of the source."
  },
  url: {
    type: "string",
    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
  },
  tiles: {
    type: "array",
    value: "string",
    doc: "An array of one or more tile source URLs, as in the TileJSON spec."
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    "default": [-180, -85.051129, 180, 85.051129],
    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
  },
  minzoom: {
    type: "number",
    "default": 0,
    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
  },
  maxzoom: {
    type: "number",
    "default": 22,
    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
  },
  tileSize: {
    type: "number",
    "default": 512,
    units: "pixels",
    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  encoding: {
    type: "enum",
    values: {
      terrarium: {
        doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
      },
      mapbox: {
        doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
      }
    },
    "default": "mapbox",
    doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
  },
  "volatile": {
    type: "boolean",
    "default": false,
    doc: "A setting to determine whether a source's tiles are cached locally.",
    "sdk-support": {
      "basic functionality": {
        android: "9.3.0",
        ios: "5.10.0"
      }
    }
  },
  "*": {
    type: "*",
    doc: "Other keys to configure the data source."
  }
};
var source_geojson = {
  type: {
    required: true,
    type: "enum",
    values: {
      geojson: {
        doc: "A GeoJSON data source."
      }
    },
    doc: "The data type of the GeoJSON source."
  },
  data: {
    type: "*",
    doc: "A URL to a GeoJSON file, or inline GeoJSON."
  },
  maxzoom: {
    type: "number",
    "default": 18,
    doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  buffer: {
    type: "number",
    "default": 128,
    maximum: 512,
    minimum: 0,
    doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
  },
  filter: {
    type: "*",
    doc: "An expression for filtering features prior to processing them for rendering."
  },
  tolerance: {
    type: "number",
    "default": 0.375,
    doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
  },
  cluster: {
    type: "boolean",
    "default": false,
    doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
  },
  clusterRadius: {
    type: "number",
    "default": 50,
    minimum: 0,
    doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
  },
  clusterMaxZoom: {
    type: "number",
    doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15."
  },
  clusterMinPoints: {
    type: "number",
    doc: "Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`."
  },
  clusterProperties: {
    type: "*",
    doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\"property_name\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\"+\"` or `\"max\"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{\"sum\": [\"+\", [\"get\", \"scalerank\"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\"accumulated\"]` value, e.g.:\n`{\"sum\": [[\"+\", [\"accumulated\"], [\"get\", \"sum\"]], [\"get\", \"scalerank\"]]}`"
  },
  lineMetrics: {
    type: "boolean",
    "default": false,
    doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
  },
  generateId: {
    type: "boolean",
    "default": false,
    doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
  },
  promoteId: {
    type: "promoteId",
    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
  }
};
var source_video = {
  type: {
    required: true,
    type: "enum",
    values: {
      video: {
        doc: "A video data source."
      }
    },
    doc: "The data type of the video source."
  },
  urls: {
    required: true,
    type: "array",
    value: "string",
    doc: "URLs to video content in order of preferred format."
  },
  coordinates: {
    required: true,
    doc: "Corners of video specified in longitude, latitude pairs.",
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number",
      doc: "A single longitude, latitude pair."
    }
  }
};
var source_image = {
  type: {
    required: true,
    type: "enum",
    values: {
      image: {
        doc: "An image data source."
      }
    },
    doc: "The data type of the image source."
  },
  url: {
    required: true,
    type: "string",
    doc: "URL that points to an image."
  },
  coordinates: {
    required: true,
    doc: "Corners of image specified in longitude, latitude pairs.",
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number",
      doc: "A single longitude, latitude pair."
    }
  }
};
var layer = {
  id: {
    type: "string",
    doc: "Unique layer name.",
    required: true
  },
  type: {
    type: "enum",
    values: {
      fill: {
        doc: "A filled polygon with an optional stroked border.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      line: {
        doc: "A stroked line.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      symbol: {
        doc: "An icon or a text label.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      circle: {
        doc: "A filled circle.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      heatmap: {
        doc: "A heatmap.",
        "sdk-support": {
          "basic functionality": {
            js: "0.41.0",
            android: "6.0.0",
            ios: "4.0.0",
            macos: "0.7.0"
          }
        }
      },
      "fill-extrusion": {
        doc: "An extruded (3D) polygon.",
        "sdk-support": {
          "basic functionality": {
            js: "0.27.0",
            android: "5.1.0",
            ios: "3.6.0",
            macos: "0.5.0"
          }
        }
      },
      raster: {
        doc: "Raster map textures such as satellite imagery.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      hillshade: {
        doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
        "sdk-support": {
          "basic functionality": {
            js: "0.43.0",
            android: "6.0.0",
            ios: "4.0.0",
            macos: "0.7.0"
          }
        }
      },
      background: {
        doc: "The background color or pattern of the map.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      sky: {
        doc: "A spherical dome around the map that is always rendered behind all other layers.",
        "sdk-support": {
          "basic functionality": {
            js: "2.0.0"
          }
        }
      }
    },
    doc: "Rendering type of this layer.",
    required: true
  },
  metadata: {
    type: "*",
    doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
  },
  source: {
    type: "string",
    doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
  },
  "source-layer": {
    type: "string",
    doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
  },
  minzoom: {
    type: "number",
    minimum: 0,
    maximum: 24,
    doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
  },
  maxzoom: {
    type: "number",
    minimum: 0,
    maximum: 24,
    doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
  },
  filter: {
    type: "filter",
    doc: "A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions."
  },
  layout: {
    type: "layout",
    doc: "Layout properties for the layer."
  },
  paint: {
    type: "paint",
    doc: "Default paint properties for this layer."
  }
};
var layout = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"];
var layout_background = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_sky = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_fill = {
  "fill-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      },
      "data-driven styling": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_circle = {
  "circle-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "1.2.0",
        android: "9.2.0",
        ios: "5.9.0",
        macos: "0.16.0"
      },
      "data-driven styling": {
        js: "1.2.0",
        android: "9.2.0",
        ios: "5.9.0",
        macos: "0.16.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_heatmap = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_line = {
  "line-cap": {
    type: "enum",
    values: {
      butt: {
        doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
      },
      round: {
        doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
      },
      square: {
        doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
      }
    },
    "default": "butt",
    doc: "The display of line endings.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "2.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "line-join": {
    type: "enum",
    values: {
      bevel: {
        doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
      },
      round: {
        doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
      },
      miter: {
        doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
      }
    },
    "default": "miter",
    doc: "The display of lines when joining.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "line-miter-limit": {
    type: "number",
    "default": 2,
    doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
    requires: [{
      "line-join": "miter"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "line-round-limit": {
    type: "number",
    "default": 1.05,
    doc: "Used to automatically convert round joins to miter joins for shallow angles.",
    requires: [{
      "line-join": "round"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "line-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      },
      "data-driven styling": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_symbol = {
  "symbol-placement": {
    type: "enum",
    values: {
      point: {
        doc: "The label is placed at the point where the geometry is located."
      },
      line: {
        doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
      },
      "line-center": {
        doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
      }
    },
    "default": "point",
    doc: "Label placement relative to its geometry.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "`line-center` value": {
        js: "0.47.0",
        android: "6.4.0",
        ios: "4.3.0",
        macos: "0.10.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "symbol-spacing": {
    type: "number",
    "default": 250,
    minimum: 1,
    units: "pixels",
    doc: "Distance between two symbol anchors.",
    requires: [{
      "symbol-placement": "line"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "symbol-avoid-edges": {
    type: "boolean",
    "default": false,
    doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "symbol-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "0.53.0",
        android: "7.4.0",
        ios: "4.11.0",
        macos: "0.14.0"
      },
      "data-driven styling": {
        js: "0.53.0",
        android: "7.4.0",
        ios: "4.11.0",
        macos: "0.14.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "symbol-z-order": {
    type: "enum",
    values: {
      auto: {
        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
      },
      "viewport-y": {
        doc: "Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
      },
      source: {
        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data."
      }
    },
    "default": "auto",
    doc: "Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.",
    "sdk-support": {
      "basic functionality": {
        js: "0.49.0",
        android: "6.6.0",
        ios: "4.5.0",
        macos: "0.12.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-allow-overlap": {
    type: "boolean",
    "default": false,
    doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-ignore-placement": {
    type: "boolean",
    "default": false,
    doc: "If true, other symbols can be visible even if they collide with the icon.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-optional": {
    type: "boolean",
    "default": false,
    doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
    requires: ["icon-image", "text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-rotation-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
      },
      viewport: {
        doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
      },
      auto: {
        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
      }
    },
    "default": "auto",
    doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "`auto` value": {
        js: "0.25.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-size": {
    type: "number",
    "default": 1,
    minimum: 0,
    units: "factor of the original icon size",
    doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "icon-text-fit": {
    type: "enum",
    values: {
      none: {
        doc: "The icon is displayed at its intrinsic aspect ratio."
      },
      width: {
        doc: "The icon is scaled in the x-dimension to fit the width of the text."
      },
      height: {
        doc: "The icon is scaled in the y-dimension to fit the height of the text."
      },
      both: {
        doc: "The icon is scaled in both x- and y-dimensions."
      }
    },
    "default": "none",
    doc: "Scales the icon to fit around the associated text.",
    requires: ["icon-image", "text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      },
      "stretchable icons": {
        js: "1.6.0",
        android: "9.2.0",
        ios: "5.8.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-text-fit-padding": {
    type: "array",
    value: "number",
    length: 4,
    "default": [0, 0, 0, 0],
    units: "pixels",
    doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
    requires: ["icon-image", "text-field", {
      "icon-text-fit": ["both", "width", "height"]
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-image": {
    type: "resolvedImage",
    doc: "Name of image in sprite to use for drawing an image background.",
    tokens: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "icon-rotate": {
    type: "number",
    "default": 0,
    period: 360,
    units: "degrees",
    doc: "Rotates the icon clockwise.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.21.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "icon-padding": {
    type: "number",
    "default": 2,
    minimum: 0,
    units: "pixels",
    doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-keep-upright": {
    type: "boolean",
    "default": false,
    doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
    requires: ["icon-image", {
      "icon-rotation-alignment": "map"
    }, {
      "symbol-placement": ["line", "line-center"]
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-offset": {
    type: "array",
    value: "number",
    length: 2,
    "default": [0, 0],
    doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "icon-anchor": {
    type: "enum",
    values: {
      center: {
        doc: "The center of the icon is placed closest to the anchor."
      },
      left: {
        doc: "The left side of the icon is placed closest to the anchor."
      },
      right: {
        doc: "The right side of the icon is placed closest to the anchor."
      },
      top: {
        doc: "The top of the icon is placed closest to the anchor."
      },
      bottom: {
        doc: "The bottom of the icon is placed closest to the anchor."
      },
      "top-left": {
        doc: "The top left corner of the icon is placed closest to the anchor."
      },
      "top-right": {
        doc: "The top right corner of the icon is placed closest to the anchor."
      },
      "bottom-left": {
        doc: "The bottom left corner of the icon is placed closest to the anchor."
      },
      "bottom-right": {
        doc: "The bottom right corner of the icon is placed closest to the anchor."
      }
    },
    "default": "center",
    doc: "Part of the icon placed closest to the anchor.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "icon-pitch-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "The icon is aligned to the plane of the map."
      },
      viewport: {
        doc: "The icon is aligned to the plane of the viewport."
      },
      auto: {
        doc: "Automatically matches the value of `icon-rotation-alignment`."
      }
    },
    "default": "auto",
    doc: "Orientation of icon when map is pitched.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-pitch-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "The text is aligned to the plane of the map."
      },
      viewport: {
        doc: "The text is aligned to the plane of the viewport."
      },
      auto: {
        doc: "Automatically matches the value of `text-rotation-alignment`."
      }
    },
    "default": "auto",
    doc: "Orientation of text when map is pitched.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      },
      "`auto` value": {
        js: "0.25.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-rotation-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
      },
      viewport: {
        doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
      },
      auto: {
        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
      }
    },
    "default": "auto",
    doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "`auto` value": {
        js: "0.25.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-field": {
    type: "formatted",
    "default": "",
    tokens: true,
    doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-font": {
    type: "array",
    value: "string",
    "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
    doc: "Font stack to use for displaying text.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-size": {
    type: "number",
    "default": 16,
    minimum: 0,
    units: "pixels",
    doc: "Font size.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-max-width": {
    type: "number",
    "default": 10,
    minimum: 0,
    units: "ems",
    doc: "The maximum line width for text wrapping.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-line-height": {
    type: "number",
    "default": 1.2,
    units: "ems",
    doc: "Text leading value for multi-line text.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "2.3.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-letter-spacing": {
    type: "number",
    "default": 0,
    units: "ems",
    doc: "Text tracking amount.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-justify": {
    type: "enum",
    values: {
      auto: {
        doc: "The text is aligned towards the anchor position."
      },
      left: {
        doc: "The text is aligned to the left."
      },
      center: {
        doc: "The text is centered."
      },
      right: {
        doc: "The text is aligned to the right."
      }
    },
    "default": "center",
    doc: "Text justification options.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      },
      auto: {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-radial-offset": {
    type: "number",
    units: "ems",
    "default": 0,
    doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
    "sdk-support": {
      "basic functionality": {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      },
      "data-driven styling": {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      }
    },
    requires: ["text-field"],
    "property-type": "data-driven",
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    }
  },
  "text-variable-anchor": {
    type: "array",
    value: "enum",
    values: {
      center: {
        doc: "The center of the text is placed closest to the anchor."
      },
      left: {
        doc: "The left side of the text is placed closest to the anchor."
      },
      right: {
        doc: "The right side of the text is placed closest to the anchor."
      },
      top: {
        doc: "The top of the text is placed closest to the anchor."
      },
      bottom: {
        doc: "The bottom of the text is placed closest to the anchor."
      },
      "top-left": {
        doc: "The top left corner of the text is placed closest to the anchor."
      },
      "top-right": {
        doc: "The top right corner of the text is placed closest to the anchor."
      },
      "bottom-left": {
        doc: "The bottom left corner of the text is placed closest to the anchor."
      },
      "bottom-right": {
        doc: "The bottom right corner of the text is placed closest to the anchor."
      }
    },
    requires: ["text-field", {
      "symbol-placement": ["point"]
    }],
    doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
    "sdk-support": {
      "basic functionality": {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-anchor": {
    type: "enum",
    values: {
      center: {
        doc: "The center of the text is placed closest to the anchor."
      },
      left: {
        doc: "The left side of the text is placed closest to the anchor."
      },
      right: {
        doc: "The right side of the text is placed closest to the anchor."
      },
      top: {
        doc: "The top of the text is placed closest to the anchor."
      },
      bottom: {
        doc: "The bottom of the text is placed closest to the anchor."
      },
      "top-left": {
        doc: "The top left corner of the text is placed closest to the anchor."
      },
      "top-right": {
        doc: "The top right corner of the text is placed closest to the anchor."
      },
      "bottom-left": {
        doc: "The bottom left corner of the text is placed closest to the anchor."
      },
      "bottom-right": {
        doc: "The bottom right corner of the text is placed closest to the anchor."
      }
    },
    "default": "center",
    doc: "Part of the text placed closest to the anchor.",
    requires: ["text-field", {
      "!": "text-variable-anchor"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-max-angle": {
    type: "number",
    "default": 45,
    units: "degrees",
    doc: "Maximum angle change between adjacent characters.",
    requires: ["text-field", {
      "symbol-placement": ["line", "line-center"]
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-writing-mode": {
    type: "array",
    value: "enum",
    values: {
      horizontal: {
        doc: "If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally."
      },
      vertical: {
        doc: "If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically."
      }
    },
    doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",
    requires: ["text-field", {
      "symbol-placement": ["point"]
    }],
    "sdk-support": {
      "basic functionality": {
        js: "1.3.0",
        android: "8.3.0",
        ios: "5.3.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-rotate": {
    type: "number",
    "default": 0,
    period: 360,
    units: "degrees",
    doc: "Rotates the text clockwise.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-padding": {
    type: "number",
    "default": 2,
    minimum: 0,
    units: "pixels",
    doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-keep-upright": {
    type: "boolean",
    "default": true,
    doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
    requires: ["text-field", {
      "text-rotation-alignment": "map"
    }, {
      "symbol-placement": ["line", "line-center"]
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-transform": {
    type: "enum",
    values: {
      none: {
        doc: "The text is not altered."
      },
      uppercase: {
        doc: "Forces all letters to be displayed in uppercase."
      },
      lowercase: {
        doc: "Forces all letters to be displayed in lowercase."
      }
    },
    "default": "none",
    doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-offset": {
    type: "array",
    doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
    value: "number",
    units: "ems",
    length: 2,
    "default": [0, 0],
    requires: ["text-field", {
      "!": "text-radial-offset"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature"]
    },
    "property-type": "data-driven"
  },
  "text-allow-overlap": {
    type: "boolean",
    "default": false,
    doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-ignore-placement": {
    type: "boolean",
    "default": false,
    doc: "If true, other symbols can be visible even if they collide with the text.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-optional": {
    type: "boolean",
    "default": false,
    doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
    requires: ["text-field", "icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_raster = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var layout_hillshade = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    "default": "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    "property-type": "constant"
  }
};
var filter = {
  type: "array",
  value: "*",
  doc: "A filter selects specific features from a layer."
};
var filter_operator = {
  type: "enum",
  values: {
    "==": {
      doc: "`[\"==\", key, value]` equality: `feature[key] = value`"
    },
    "!=": {
      doc: "`[\"!=\", key, value]` inequality: `feature[key] ≠ value`"
    },
    ">": {
      doc: "`[\">\", key, value]` greater than: `feature[key] > value`"
    },
    ">=": {
      doc: "`[\">=\", key, value]` greater than or equal: `feature[key] ≥ value`"
    },
    "<": {
      doc: "`[\"<\", key, value]` less than: `feature[key] < value`"
    },
    "<=": {
      doc: "`[\"<=\", key, value]` less than or equal: `feature[key] ≤ value`"
    },
    "in": {
      doc: "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`"
    },
    "!in": {
      doc: "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`"
    },
    all: {
      doc: "`[\"all\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`"
    },
    any: {
      doc: "`[\"any\", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`"
    },
    none: {
      doc: "`[\"none\", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`"
    },
    has: {
      doc: "`[\"has\", key]` `feature[key]` exists"
    },
    "!has": {
      doc: "`[\"!has\", key]` `feature[key]` does not exist"
    },
    within: {
      doc: "`[\"within\", object]` feature geometry is within object geometry"
    }
  },
  doc: "The filter operator."
};
var geometry_type = {
  type: "enum",
  values: {
    Point: {
      doc: "Filter to point geometries."
    },
    LineString: {
      doc: "Filter to line geometries."
    },
    Polygon: {
      doc: "Filter to polygon geometries."
    }
  },
  doc: "The geometry type for the filter to select."
};
var function_stop = {
  type: "array",
  minimum: 0,
  maximum: 24,
  value: ["number", "color"],
  length: 2,
  doc: "Zoom level and value pair."
};
var expression = {
  type: "array",
  value: "*",
  minimum: 1,
  doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
};
var expression_name = {
  doc: "",
  type: "enum",
  values: {
    "let": {
      doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
      group: "Variable binding",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "var": {
      doc: "References variable bound using \"let\".",
      group: "Variable binding",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    literal: {
      doc: "Provides a literal array or object value.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    array: {
      doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    at: {
      doc: "Retrieves an item from an array.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "in": {
      doc: "Determines whether an item exists in an array or a substring exists in a string.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "1.6.0",
          android: "9.1.0",
          ios: "5.8.0",
          macos: "0.15.0"
        }
      }
    },
    "index-of": {
      doc: "Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "1.10.0"
        }
      }
    },
    slice: {
      doc: "Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "1.10.0"
        }
      }
    },
    "case": {
      doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    match: {
      doc: "Selects the output for which the label value matches the input value, or the fallback value if no match is found. The input can be any expression (for example, `[\"get\", \"building_type\"]`). Each label must be unique, and must be either:\n - a single literal value; or\n - an array of literal values, the values of which must be all strings or all numbers (for example `[100, 101]` or `[\"c\", \"b\"]`).\n\nThe input matches if any of the values in the array matches using strict equality, similar to the `\"in\"` operator.\nIf the input type does not match the type of the labels, the result will be the fallback value.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    coalesce: {
      doc: "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    step: {
      doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.42.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    interpolate: {
      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `[\"linear\"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\n- `[\"exponential\", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.",
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.42.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "interpolate-hcl": {
      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.49.0"
        }
      }
    },
    "interpolate-lab": {
      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.49.0"
        }
      }
    },
    ln2: {
      doc: "Returns mathematical constant ln(2).",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    pi: {
      doc: "Returns the mathematical constant pi.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    e: {
      doc: "Returns the mathematical constant e.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "typeof": {
      doc: "Returns a string describing the type of the given value.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    string: {
      doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    number: {
      doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "boolean": {
      doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    object: {
      doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    collator: {
      doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    format: {
      doc: "Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`'image'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\n- `\"text-font\"`: Overrides the font stack specified by the root layout property.\n- `\"text-color\"`: Overrides the color specified by the root paint property.\n- `\"font-scale\"`: Applies a scaling factor on `text-size` as specified by the root layout property.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.48.0",
          android: "6.7.0",
          ios: "4.6.0",
          macos: "0.12.0"
        },
        "text-font": {
          js: "0.48.0",
          android: "6.7.0",
          ios: "4.6.0",
          macos: "0.12.0"
        },
        "font-scale": {
          js: "0.48.0",
          android: "6.7.0",
          ios: "4.6.0",
          macos: "0.12.0"
        },
        "text-color": {
          js: "1.3.0",
          android: "7.3.0",
          ios: "4.10.0",
          macos: "0.14.0"
        },
        image: {
          js: "1.6.0",
          android: "8.6.0",
          ios: "5.7.0",
          macos: "0.15.0"
        }
      }
    },
    image: {
      doc: "Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "1.4.0",
          android: "8.6.0",
          ios: "5.7.0",
          macos: "0.15.0"
        }
      }
    },
    "number-format": {
      doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.54.0"
        }
      }
    },
    "to-string": {
      doc: "Converts the input value to a string. If the input is `null`, the result is `\"\"`. If the input is a boolean, the result is `\"true\"` or `\"false\"`. If the input is a number, it is converted to a string as specified by the [\"NumberToString\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\"rgba(r,g,b,a)\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-number": {
      doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\"ToNumber Applied to the String Type\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-boolean": {
      doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-rgba": {
      doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
      group: "Color",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-color": {
      doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    rgb: {
      doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
      group: "Color",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    rgba: {
      doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
      group: "Color",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    get: {
      doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    has: {
      doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    length: {
      doc: "Gets the length of an array or string.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    properties: {
      doc: "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\"get\", \"property_name\"] directly.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "feature-state": {
      doc: "Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.46.0"
        }
      }
    },
    "geometry-type": {
      doc: "Gets the feature's geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    id: {
      doc: "Gets the feature's id, if it has one.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    zoom: {
      doc: "Gets the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level \"step\" or \"interpolate\" expression.",
      group: "Zoom",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "heatmap-density": {
      doc: "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
      group: "Heatmap",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "line-progress": {
      doc: "Gets the progress along a gradient line. Can only be used in the `line-gradient` property.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.6.0",
          macos: "0.12.0"
        }
      }
    },
    "sky-radial-progress": {
      doc: "Gets the distance of a point on the sky from the sun position. Returns 0 at sun position and 1 when the distance reaches `sky-gradient-radius`. Can only be used in the `sky-gradient` property.",
      group: "sky",
      "sdk-support": {
        "basic functionality": {
          js: "2.0.0"
        }
      }
    },
    accumulated: {
      doc: "Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.53.0"
        }
      }
    },
    "+": {
      doc: "Returns the sum of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "*": {
      doc: "Returns the product of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "-": {
      doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "/": {
      doc: "Returns the result of floating point division of the first input by the second.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "%": {
      doc: "Returns the remainder after integer division of the first input by the second.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "^": {
      doc: "Returns the result of raising the first input to the power specified by the second.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    sqrt: {
      doc: "Returns the square root of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.42.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    log10: {
      doc: "Returns the base-ten logarithm of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    ln: {
      doc: "Returns the natural logarithm of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    log2: {
      doc: "Returns the base-two logarithm of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    sin: {
      doc: "Returns the sine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    cos: {
      doc: "Returns the cosine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    tan: {
      doc: "Returns the tangent of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    asin: {
      doc: "Returns the arcsine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    acos: {
      doc: "Returns the arccosine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    atan: {
      doc: "Returns the arctangent of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    min: {
      doc: "Returns the minimum value of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    max: {
      doc: "Returns the maximum value of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    round: {
      doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\"round\", -1.5]` evaluates to -2.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    abs: {
      doc: "Returns the absolute value of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    ceil: {
      doc: "Returns the smallest integer that is greater than or equal to the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    floor: {
      doc: "Returns the largest integer that is less than or equal to the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    distance: {
      doc: "Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          android: "9.2.0",
          ios: "5.9.0",
          macos: "0.16.0"
        }
      }
    },
    "==": {
      doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    "!=": {
      doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    ">": {
      doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    "<": {
      doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    ">=": {
      doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    "<=": {
      doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    all: {
      doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    any: {
      doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "!": {
      doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    within: {
      doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line's endpoint is on the boundary.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "1.9.0",
          android: "9.1.0",
          ios: "5.8.0",
          macos: "0.15.0"
        }
      }
    },
    "is-supported-script": {
      doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.6.0"
        }
      }
    },
    upcase: {
      doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    downcase: {
      doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    concat: {
      doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "resolved-locale": {
      doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    }
  }
};
var fog = {
  range: {
    type: "array",
    "default": [0.5, 10],
    minimum: -20,
    maximum: 20,
    length: 2,
    value: "number",
    "property-type": "data-constant",
    transition: true,
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    doc: "The start and end distance range in which fog fades from fully transparent to fully opaque. The distance to the point at the center of the map is defined as zero, so that negative range values are closer to the camera, and positive values are farther away.",
    example: [0.5, 10],
    "sdk-support": {
      "basic functionality": {
        js: "2.3.0"
      }
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    "default": "#ffffff",
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    transition: true,
    doc: "The color of the fog. Using opacity is recommended only for smoothly transitioning fog on/off as anything less than 100% opacity results in more tiles loaded and drawn.",
    "sdk-support": {
      "basic functionality": {
        js: "2.3.0"
      }
    }
  },
  "horizon-blend": {
    type: "number",
    "property-type": "data-constant",
    "default": 0.1,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    transition: true,
    doc: "Horizon blend applies a smooth fade from the color of the fog to the color of the sky. A value of zero leaves a sharp transition from fog to sky. Increasing the value blends the color of fog into increasingly high angles of the sky.",
    "sdk-support": {
      "basic functionality": {
        js: "2.3.0"
      }
    }
  }
};
var light = {
  anchor: {
    type: "enum",
    "default": "viewport",
    values: {
      map: {
        doc: "The position of the light source is aligned to the rotation of the map."
      },
      viewport: {
        doc: "The position of the light source is aligned to the rotation of the viewport."
      }
    },
    "property-type": "data-constant",
    transition: false,
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    doc: "Whether extruded geometries are lit relative to the map or viewport.",
    example: "map",
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  },
  position: {
    type: "array",
    "default": [1.15, 210, 30],
    length: 3,
    value: "number",
    "property-type": "data-constant",
    transition: true,
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).",
    example: [1.5, 90, 80],
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    "default": "#ffffff",
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    transition: true,
    doc: "Color tint for lighting extruded geometries.",
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  },
  intensity: {
    type: "number",
    "property-type": "data-constant",
    "default": 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    transition: true,
    doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  }
};
var terrain = {
  source: {
    type: "string",
    doc: "Name of a source of `raster_dem` type to be used for terrain elevation.",
    required: true,
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    }
  },
  exaggeration: {
    type: "number",
    "property-type": "data-constant",
    "default": 1,
    minimum: 0,
    maximum: 1000,
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    transition: true,
    doc: "Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    }
  }
};
var paint = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"];
var paint_fill = {
  "fill-antialias": {
    type: "boolean",
    "default": true,
    doc: "Whether or not the fill should be antialiased.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "fill-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.21.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "fill-color": {
    type: "color",
    "default": "#000000",
    doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
    transition: true,
    requires: [{
      "!": "fill-pattern"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.19.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "fill-outline-color": {
    type: "color",
    doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
    transition: true,
    requires: [{
      "!": "fill-pattern"
    }, {
      "fill-antialias": true
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.19.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "fill-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [0, 0],
    transition: true,
    units: "pixels",
    doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "fill-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The fill is translated relative to the map."
      },
      viewport: {
        doc: "The fill is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `fill-translate`.",
    "default": "map",
    requires: ["fill-translate"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "fill-pattern": {
    type: "resolvedImage",
    transition: true,
    doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.49.0",
        android: "6.5.0",
        macos: "0.11.0",
        ios: "4.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "cross-faded-data-driven"
  }
};
var paint_line = {
  "line-opacity": {
    type: "number",
    doc: "The opacity at which the line will be drawn.",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "line-color": {
    type: "color",
    doc: "The color with which the line will be drawn.",
    "default": "#000000",
    transition: true,
    requires: [{
      "!": "line-pattern"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.23.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "line-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [0, 0],
    transition: true,
    units: "pixels",
    doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "line-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The line is translated relative to the map."
      },
      viewport: {
        doc: "The line is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `line-translate`.",
    "default": "map",
    requires: ["line-translate"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "line-width": {
    type: "number",
    "default": 1,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Stroke thickness.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "line-gap-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
    transition: true,
    units: "pixels",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "line-offset": {
    type: "number",
    "default": 0,
    doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
    transition: true,
    units: "pixels",
    "sdk-support": {
      "basic functionality": {
        js: "0.12.1",
        android: "3.0.0",
        ios: "3.1.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "line-blur": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Blur applied to the line, in pixels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "line-dasharray": {
    type: "array",
    value: "number",
    doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    minimum: 0,
    transition: true,
    units: "line widths",
    requires: [{
      "!": "line-pattern"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "2.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-pattern": {
    type: "resolvedImage",
    transition: true,
    doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.49.0",
        android: "6.5.0",
        macos: "0.11.0",
        ios: "4.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom", "feature"]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-gradient": {
    type: "color",
    doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\"lineMetrics\": true`.",
    transition: false,
    requires: [{
      "!": "line-dasharray"
    }, {
      "!": "line-pattern"
    }, {
      source: "geojson",
      has: {
        lineMetrics: true
      }
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.45.0",
        android: "6.5.0",
        ios: "4.4.0",
        macos: "0.11.0"
      },
      "data-driven styling": {}
    },
    expression: {
      interpolated: true,
      parameters: ["line-progress"]
    },
    "property-type": "color-ramp"
  }
};
var paint_circle = {
  "circle-radius": {
    type: "number",
    "default": 5,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Circle radius.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.18.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "circle-color": {
    type: "color",
    "default": "#000000",
    doc: "The fill color of the circle.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.18.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "circle-blur": {
    type: "number",
    "default": 0,
    doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.20.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "circle-opacity": {
    type: "number",
    doc: "The opacity at which the circle will be drawn.",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.20.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "circle-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [0, 0],
    transition: true,
    units: "pixels",
    doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "circle-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The circle is translated relative to the map."
      },
      viewport: {
        doc: "The circle is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `circle-translate`.",
    "default": "map",
    requires: ["circle-translate"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-scale": {
    type: "enum",
    values: {
      map: {
        doc: "Circles are scaled according to their apparent distance to the camera."
      },
      viewport: {
        doc: "Circles are not scaled."
      }
    },
    "default": "map",
    doc: "Controls the scaling behavior of the circle when the map is pitched.",
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "The circle is aligned to the plane of the map."
      },
      viewport: {
        doc: "The circle is aligned to the plane of the viewport."
      }
    },
    "default": "viewport",
    doc: "Orientation of circle when map is pitched.",
    "sdk-support": {
      "basic functionality": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "circle-stroke-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
    "sdk-support": {
      "basic functionality": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-color": {
    type: "color",
    "default": "#000000",
    doc: "The stroke color of the circle.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-opacity": {
    type: "number",
    doc: "The opacity of the circle's stroke.",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  }
};
var paint_heatmap = {
  "heatmap-radius": {
    type: "number",
    "default": 30,
    minimum: 1,
    transition: true,
    units: "pixels",
    doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      },
      "data-driven styling": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "heatmap-weight": {
    type: "number",
    "default": 1,
    minimum: 0,
    transition: false,
    doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      },
      "data-driven styling": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "heatmap-intensity": {
    type: "number",
    "default": 1,
    minimum: 0,
    transition: true,
    doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "heatmap-color": {
    type: "color",
    "default": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"],
    doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\"heatmap-density\"]` as input.",
    transition: false,
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      },
      "data-driven styling": {}
    },
    expression: {
      interpolated: true,
      parameters: ["heatmap-density"]
    },
    "property-type": "color-ramp"
  },
  "heatmap-opacity": {
    type: "number",
    doc: "The global opacity at which the heatmap layer will be drawn.",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  }
};
var paint_symbol = {
  "icon-opacity": {
    doc: "The opacity at which the icon will be drawn.",
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "icon-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    doc: "The color of the icon. This can only be used with sdf icons.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "icon-halo-color": {
    type: "color",
    "default": "rgba(0, 0, 0, 0)",
    transition: true,
    doc: "The color of the icon's halo. Icon halos can only be used with SDF icons.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "icon-halo-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Distance of halo to the icon outline.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "icon-halo-blur": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Fade out the halo towards the outside.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "icon-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [0, 0],
    transition: true,
    units: "pixels",
    doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
    requires: ["icon-image"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "icon-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "Icons are translated relative to the map."
      },
      viewport: {
        doc: "Icons are translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `icon-translate`.",
    "default": "map",
    requires: ["icon-image", "icon-translate"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-opacity": {
    type: "number",
    doc: "The opacity at which the text will be drawn.",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "text-color": {
    type: "color",
    doc: "The color with which the text will be drawn.",
    "default": "#000000",
    transition: true,
    overridable: true,
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "text-halo-color": {
    type: "color",
    "default": "rgba(0, 0, 0, 0)",
    transition: true,
    doc: "The color of the text's halo, which helps it stand out from backgrounds.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "text-halo-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "text-halo-blur": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "The halo's fadeout distance towards the outside.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom", "feature", "feature-state"]
    },
    "property-type": "data-driven"
  },
  "text-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [0, 0],
    transition: true,
    units: "pixels",
    doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
    requires: ["text-field"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "text-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The text is translated relative to the map."
      },
      viewport: {
        doc: "The text is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `text-translate`.",
    "default": "map",
    requires: ["text-field", "text-translate"],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  }
};
var paint_raster = {
  "raster-opacity": {
    type: "number",
    doc: "The opacity at which the image will be drawn.",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "raster-hue-rotate": {
    type: "number",
    "default": 0,
    period: 360,
    transition: true,
    units: "degrees",
    doc: "Rotates hues around the color wheel.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-min": {
    type: "number",
    doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
    "default": 0,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-max": {
    type: "number",
    doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "raster-saturation": {
    type: "number",
    doc: "Increase or reduce the saturation of the image.",
    "default": 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "raster-contrast": {
    type: "number",
    doc: "Increase or reduce the contrast of the image.",
    "default": 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "raster-resampling": {
    type: "enum",
    doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
    values: {
      linear: {
        doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
      },
      nearest: {
        doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
      }
    },
    "default": "linear",
    "sdk-support": {
      "basic functionality": {
        js: "0.47.0",
        android: "6.3.0",
        ios: "4.2.0",
        macos: "0.9.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "raster-fade-duration": {
    type: "number",
    "default": 300,
    minimum: 0,
    transition: false,
    units: "milliseconds",
    doc: "Fade duration when a new tile is added.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  }
};
var paint_hillshade = {
  "hillshade-illumination-direction": {
    type: "number",
    "default": 335,
    minimum: 0,
    maximum: 359,
    doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
    transition: false,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The hillshade illumination is relative to the north direction."
      },
      viewport: {
        doc: "The hillshade illumination is relative to the top of the viewport."
      }
    },
    "default": "viewport",
    doc: "Direction of light source when map is rotated.",
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "hillshade-exaggeration": {
    type: "number",
    doc: "Intensity of the hillshade",
    "default": 0.5,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "hillshade-shadow-color": {
    type: "color",
    "default": "#000000",
    doc: "The shading color of areas that face away from the light source.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "hillshade-highlight-color": {
    type: "color",
    "default": "#FFFFFF",
    doc: "The shading color of areas that faces towards the light source.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "hillshade-accent-color": {
    type: "color",
    "default": "#000000",
    doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  }
};
var paint_background = {
  "background-color": {
    type: "color",
    "default": "#000000",
    doc: "The color with which the background will be drawn.",
    transition: true,
    requires: [{
      "!": "background-pattern"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "background-pattern": {
    type: "resolvedImage",
    transition: true,
    doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {}
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "cross-faded"
  },
  "background-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    doc: "The opacity at which the background will be drawn.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  }
};
var paint_sky = {
  "sky-type": {
    type: "enum",
    values: {
      gradient: {
        doc: "Renders the sky with a gradient that can be configured with `sky-gradient-radius` and `sky-gradient`."
      },
      atmosphere: {
        doc: "Renders the sky with a simulated atmospheric scattering algorithm, the sun direction can be attached to the light position or explicitly set through `sky-atmosphere-sun`."
      }
    },
    "default": "atmosphere",
    doc: "The type of the sky",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "sky-atmosphere-sun": {
    type: "array",
    value: "number",
    length: 2,
    units: "degrees",
    minimum: [0, 0],
    maximum: [360, 180],
    transition: false,
    doc: "Position of the sun center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the sun relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the sun, where 0° is directly above, at zenith, and 90° at the horizon. When this property is ommitted, the sun center is directly inherited from the light position.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    requires: [{
      "sky-type": "atmosphere"
    }],
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "sky-atmosphere-sun-intensity": {
    type: "number",
    requires: [{
      "sky-type": "atmosphere"
    }],
    "default": 10,
    minimum: 0,
    maximum: 100,
    transition: false,
    doc: "Intensity of the sun as a light source in the atmosphere (on a scale from 0 to a 100). Setting higher values will brighten up the sky.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    "property-type": "data-constant"
  },
  "sky-gradient-center": {
    type: "array",
    requires: [{
      "sky-type": "gradient"
    }],
    value: "number",
    "default": [0, 0],
    length: 2,
    units: "degrees",
    minimum: [0, 0],
    maximum: [360, 180],
    transition: false,
    doc: "Position of the gradient center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the gradient center relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the gradient center, where 0° is directly above, at zenith, and 90° at the horizon.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "sky-gradient-radius": {
    type: "number",
    requires: [{
      "sky-type": "gradient"
    }],
    "default": 90,
    minimum: 0,
    maximum: 180,
    transition: false,
    doc: "The angular distance (measured in degrees) from `sky-gradient-center` up to which the gradient extends. A value of 180 causes the gradient to wrap around to the opposite direction from `sky-gradient-center`.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  },
  "sky-gradient": {
    type: "color",
    "default": ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"],
    doc: "Defines a radial color gradient with which to color the sky. The color values can be interpolated with an expression using `sky-radial-progress`. The range [0, 1] for the interpolant covers a radial distance (in degrees) of [0, `sky-gradient-radius`] centered at the position specified by `sky-gradient-center`.",
    transition: false,
    requires: [{
      "sky-type": "gradient"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      },
      "data-driven styling": {}
    },
    expression: {
      interpolated: true,
      parameters: ["sky-radial-progress"]
    },
    "property-type": "color-ramp"
  },
  "sky-atmosphere-halo-color": {
    type: "color",
    "default": "white",
    doc: "A color applied to the atmosphere sun halo. The alpha channel describes how strongly the sun halo is represented in an atmosphere sky layer.",
    transition: false,
    requires: [{
      "sky-type": "atmosphere"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    "property-type": "data-constant"
  },
  "sky-atmosphere-color": {
    type: "color",
    "default": "white",
    doc: "A color used to tweak the main atmospheric scattering coefficients. Using white applies the default coefficients giving the natural blue color to the atmosphere. This color affects how heavily the corresponding wavelength is represented during scattering. The alpha channel describes the density of the atmosphere, with 1 maximum density and 0 no density.",
    transition: false,
    requires: [{
      "sky-type": "atmosphere"
    }],
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    "property-type": "data-constant"
  },
  "sky-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    doc: "The opacity of the entire sky layer.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: ["zoom"]
    },
    "property-type": "data-constant"
  }
};
var transition = {
  duration: {
    type: "number",
    "default": 300,
    minimum: 0,
    units: "milliseconds",
    doc: "Time allotted for transitions to complete."
  },
  delay: {
    type: "number",
    "default": 0,
    minimum: 0,
    units: "milliseconds",
    doc: "Length of time before a transition begins."
  }
};
var promoteId = {
  "*": {
    type: "string",
    doc: "A name of a feature property to use as ID for feature state."
  }
};
var v8 = {
  $version: $version,
  $root: $root,
  sources: sources,
  source: source,
  source_vector: source_vector,
  source_raster: source_raster,
  source_raster_dem: source_raster_dem,
  source_geojson: source_geojson,
  source_video: source_video,
  source_image: source_image,
  layer: layer,
  layout: layout,
  layout_background: layout_background,
  layout_sky: layout_sky,
  layout_fill: layout_fill,
  layout_circle: layout_circle,
  layout_heatmap: layout_heatmap,
  "layout_fill-extrusion": {
    visibility: {
      type: "enum",
      values: {
        visible: {
          doc: "The layer is shown."
        },
        none: {
          doc: "The layer is not shown."
        }
      },
      "default": "visible",
      doc: "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      "property-type": "constant"
    }
  },
  layout_line: layout_line,
  layout_symbol: layout_symbol,
  layout_raster: layout_raster,
  layout_hillshade: layout_hillshade,
  filter: filter,
  filter_operator: filter_operator,
  geometry_type: geometry_type,
  "function": {
    expression: {
      type: "expression",
      doc: "An expression."
    },
    stops: {
      type: "array",
      doc: "An array of stops.",
      value: "function_stop"
    },
    base: {
      type: "number",
      "default": 1,
      minimum: 0,
      doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    },
    property: {
      type: "string",
      doc: "The name of a feature property to use as the function input.",
      "default": "$zoom"
    },
    type: {
      type: "enum",
      values: {
        identity: {
          doc: "Return the input value as the output value."
        },
        exponential: {
          doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
        },
        interval: {
          doc: "Return the output value of the stop just less than the function input."
        },
        categorical: {
          doc: "Return the output value of the stop equal to the function input."
        }
      },
      doc: "The interpolation strategy to use in function evaluation.",
      "default": "exponential"
    },
    colorSpace: {
      type: "enum",
      values: {
        rgb: {
          doc: "Use the RGB color space to interpolate color values"
        },
        lab: {
          doc: "Use the LAB color space to interpolate color values."
        },
        hcl: {
          doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
        }
      },
      doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
      "default": "rgb"
    },
    "default": {
      type: "*",
      required: false,
      doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
    }
  },
  function_stop: function_stop,
  expression: expression,
  expression_name: expression_name,
  fog: fog,
  light: light,
  terrain: terrain,
  paint: paint,
  paint_fill: paint_fill,
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      type: "number",
      "default": 1,
      minimum: 0,
      maximum: 1,
      doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
      transition: true,
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: ["zoom"]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-color": {
      type: "color",
      "default": "#000000",
      doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
      transition: true,
      requires: [{
        "!": "fill-extrusion-pattern"
      }],
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: ["zoom", "feature", "feature-state"]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-translate": {
      type: "array",
      value: "number",
      length: 2,
      "default": [0, 0],
      transition: true,
      units: "pixels",
      doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: ["zoom"]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-translate-anchor": {
      type: "enum",
      values: {
        map: {
          doc: "The fill extrusion is translated relative to the map."
        },
        viewport: {
          doc: "The fill extrusion is translated relative to the viewport."
        }
      },
      doc: "Controls the frame of reference for `fill-extrusion-translate`.",
      "default": "map",
      requires: ["fill-extrusion-translate"],
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: false,
        parameters: ["zoom"]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-pattern": {
      type: "resolvedImage",
      transition: true,
      doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.49.0",
          android: "6.5.0",
          macos: "0.11.0",
          ios: "4.4.0"
        }
      },
      expression: {
        interpolated: false,
        parameters: ["zoom", "feature"]
      },
      "property-type": "cross-faded-data-driven"
    },
    "fill-extrusion-height": {
      type: "number",
      "default": 0,
      minimum: 0,
      units: "meters",
      doc: "The height with which to extrude this layer.",
      transition: true,
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: ["zoom", "feature", "feature-state"]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-base": {
      type: "number",
      "default": 0,
      minimum: 0,
      units: "meters",
      doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
      transition: true,
      requires: ["fill-extrusion-height"],
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: ["zoom", "feature", "feature-state"]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-vertical-gradient": {
      type: "boolean",
      "default": true,
      doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
      transition: false,
      "sdk-support": {
        "basic functionality": {
          js: "0.50.0",
          ios: "4.7.0",
          macos: "0.13.0"
        }
      },
      expression: {
        interpolated: false,
        parameters: ["zoom"]
      },
      "property-type": "data-constant"
    }
  },
  paint_line: paint_line,
  paint_circle: paint_circle,
  paint_heatmap: paint_heatmap,
  paint_symbol: paint_symbol,
  paint_raster: paint_raster,
  paint_hillshade: paint_hillshade,
  paint_background: paint_background,
  paint_sky: paint_sky,
  transition: transition,
  "property-type": {
    "data-driven": {
      type: "property-type",
      doc: "Property is interpolable and can be represented using a property expression."
    },
    "cross-faded": {
      type: "property-type",
      doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."
    },
    "cross-faded-data-driven": {
      type: "property-type",
      doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."
    },
    "color-ramp": {
      type: "property-type",
      doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
    },
    "data-constant": {
      type: "property-type",
      doc: "Property is interpolable but cannot be represented using a property expression."
    },
    constant: {
      type: "property-type",
      doc: "Property is constant across all zoom levels and property values."
    }
  },
  promoteId: promoteId
}; // Note: This regex matches even invalid JSON strings, but since we’re
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we don’t care since the output would be invalid anyway).

var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;

var jsonStringifyPrettyCompact = function stringify(passedObj, options) {
  var indent, maxLength, replacer;
  options = options || {};
  indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);
  maxLength = indent === "" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;
  replacer = options.replacer;
  return function _stringify(obj, currentIndent, reserved) {
    // prettier-ignore
    var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;

    if (obj && typeof obj.toJSON === "function") {
      obj = obj.toJSON();
    }

    string = JSON.stringify(obj, replacer);

    if (string === undefined) {
      return string;
    }

    length = maxLength - currentIndent.length - reserved;

    if (string.length <= length) {
      prettified = string.replace(stringOrChar, function (match, stringLiteral) {
        return stringLiteral || match + " ";
      });

      if (prettified.length <= length) {
        return prettified;
      }
    }

    if (replacer != null) {
      obj = JSON.parse(string);
      replacer = undefined;
    }

    if (_typeof(obj) === "object" && obj !== null) {
      nextIndent = currentIndent + indent;
      items = [];
      index = 0;

      if (Array.isArray(obj)) {
        start = "[";
        end = "]";
        length = obj.length;

        for (; index < length; index++) {
          items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null");
        }
      } else {
        start = "{";
        end = "}";
        keys = Object.keys(obj);
        length = keys.length;

        for (; index < length; index++) {
          key = keys[index];
          keyPart = JSON.stringify(key) + ": ";
          value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));

          if (value !== undefined) {
            items.push(keyPart + value);
          }
        }
      }

      if (items.length > 0) {
        return [start, indent + items.join(",\n" + nextIndent), end].join("\n" + currentIndent);
      }
    }

    return string;
  }(passedObj, "", 0);
};

function sortKeysBy(obj, reference) {
  var result = {};

  for (var key in reference) {
    if (obj[key] !== undefined) {
      result[key] = obj[key];
    }
  }

  for (var _key in obj) {
    if (result[_key] === undefined) {
      result[_key] = obj[_key];
    }
  }

  return result;
}

function format(style) {
  var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  style = sortKeysBy(style, v8.$root);

  if (style.layers) {
    style.layers = style.layers.map(function (layer) {
      return sortKeysBy(layer, v8.layer);
    });
  }

  return jsonStringifyPrettyCompact(style, {
    indent: space
  });
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = {
    exports: {}
  };
  return fn(module, module.exports), module.exports;
}

function commonjsRequire(target) {
  throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
}
/*! https://mths.be/punycode v1.3.2 by @mathias */


var punycode = createCommonjsModule(function (module, exports) {
  (function (root) {
    /** Detect free variables */
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal;

    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    /**
     * The `punycode` object.
     * @name punycode
     * @type Object
     */


    var punycode,

    /** Highest positive signed 32-bit float value */
    maxInt = 2147483647,
        // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    base = 36,
        tMin = 1,
        tMax = 26,
        skew = 38,
        damp = 700,
        initialBias = 72,
        initialN = 128,
        // 0x80
    delimiter = '-',
        // '\x2D'

    /** Regular expressions */
    regexPunycode = /^xn--/,
        regexNonASCII = /[^\x20-\x7E]/,
        // unprintable ASCII chars + non-ASCII chars
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
        // RFC 3490 separators

    /** Error messages */
    errors = {
      'overflow': 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input'
    },

    /** Convenience shortcuts */
    baseMinusTMin = base - tMin,
        floor = Math.floor,
        stringFromCharCode = String.fromCharCode,

    /** Temporary variable */
    key;
    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */

    function error(type) {
      throw RangeError(errors[type]);
    }
    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */


    function map(array, fn) {
      var length = array.length;
      var result = [];

      while (length--) {
        result[length] = fn(array[length]);
      }

      return result;
    }
    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */


    function mapDomain(string, fn) {
      var parts = string.split('@');
      var result = '';

      if (parts.length > 1) {
        // In email addresses, only the domain name should be punycoded. Leave
        // the local part (i.e. everything up to `@`) intact.
        result = parts[0] + '@';
        string = parts[1];
      } // Avoid `split(regex)` for IE8 compatibility. See #17.


      string = string.replace(regexSeparators, '\x2E');
      var labels = string.split('.');
      var encoded = map(labels, fn).join('.');
      return result + encoded;
    }
    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */


    function ucs2decode(string) {
      var output = [],
          counter = 0,
          length = string.length,
          value,
          extra;

      while (counter < length) {
        value = string.charCodeAt(counter++);

        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
          // high surrogate, and there is a next character
          extra = string.charCodeAt(counter++);

          if ((extra & 0xFC00) == 0xDC00) {
            // low surrogate
            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
          } else {
            // unmatched surrogate; only append this code unit, in case the next
            // code unit is the high surrogate of a surrogate pair
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }

      return output;
    }
    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */


    function ucs2encode(array) {
      return map(array, function (value) {
        var output = '';

        if (value > 0xFFFF) {
          value -= 0x10000;
          output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
          value = 0xDC00 | value & 0x3FF;
        }

        output += stringFromCharCode(value);
        return output;
      }).join('');
    }
    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */


    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }

      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }

      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }

      return base;
    }
    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */


    function digitToBasic(digit, flag) {
      //  0..25 map to ASCII a..z or A..Z
      // 26..35 map to ASCII 0..9
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * http://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */


    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);

      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }

      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */


    function decode(input) {
      // Don't use UCS-2
      var output = [],
          inputLength = input.length,
          out,
          i = 0,
          n = initialN,
          bias = initialBias,
          basic,
          j,
          index,
          oldi,
          w,
          k,
          digit,
          t,

      /** Cached calculation results */
      baseMinusT; // Handle the basic code points: let `basic` be the number of input code
      // points before the last delimiter, or `0` if there is none, then copy
      // the first basic code points to the output.

      basic = input.lastIndexOf(delimiter);

      if (basic < 0) {
        basic = 0;
      }

      for (j = 0; j < basic; ++j) {
        // if it's not a basic code point
        if (input.charCodeAt(j) >= 0x80) {
          error('not-basic');
        }

        output.push(input.charCodeAt(j));
      } // Main decoding loop: start just after the last delimiter if any basic code
      // points were copied; start at the beginning otherwise.


      for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
        // `index` is the index of the next character to be consumed.
        // Decode a generalized variable-length integer into `delta`,
        // which gets added to `i`. The overflow checking is easier
        // if we increase `i` as we go, then subtract off its starting
        // value at the end to obtain `delta`.
        for (oldi = i, w = 1, k = base;; k += base) {
          if (index >= inputLength) {
            error('invalid-input');
          }

          digit = basicToDigit(input.charCodeAt(index++));

          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error('overflow');
          }

          i += digit * w;
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

          if (digit < t) {
            break;
          }

          baseMinusT = base - t;

          if (w > floor(maxInt / baseMinusT)) {
            error('overflow');
          }

          w *= baseMinusT;
        }

        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
        // incrementing `n` each time, so we'll fix that now:

        if (floor(i / out) > maxInt - n) {
          error('overflow');
        }

        n += floor(i / out);
        i %= out; // Insert `n` at position `i` of the output

        output.splice(i++, 0, n);
      }

      return ucs2encode(output);
    }
    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */


    function encode(input) {
      var n,
          delta,
          handledCPCount,
          basicLength,
          bias,
          j,
          m,
          q,
          k,
          t,
          currentValue,
          output = [],

      /** `inputLength` will hold the number of code points in `input`. */
      inputLength,

      /** Cached calculation results */
      handledCPCountPlusOne,
          baseMinusT,
          qMinusT; // Convert the input in UCS-2 to Unicode

      input = ucs2decode(input); // Cache the length

      inputLength = input.length; // Initialize the state

      n = initialN;
      delta = 0;
      bias = initialBias; // Handle the basic code points

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < 0x80) {
          output.push(stringFromCharCode(currentValue));
        }
      }

      handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
      // `basicLength` is the number of basic code points.
      // Finish the basic string - if it is not empty - with a delimiter

      if (basicLength) {
        output.push(delimiter);
      } // Main encoding loop:


      while (handledCPCount < inputLength) {
        // All non-basic code points < n have been handled already. Find the next
        // larger one:
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];

          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow


        handledCPCountPlusOne = handledCPCount + 1;

        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error('overflow');
        }

        delta += (m - n) * handledCPCountPlusOne;
        n = m;

        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];

          if (currentValue < n && ++delta > maxInt) {
            error('overflow');
          }

          if (currentValue == n) {
            // Represent delta as a generalized variable-length integer
            for (q = delta, k = base;; k += base) {
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (q < t) {
                break;
              }

              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }

        ++delta;
        ++n;
      }

      return output.join('');
    }
    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */


    function toUnicode(input) {
      return mapDomain(input, function (string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    }
    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */


    function toASCII(input) {
      return mapDomain(input, function (string) {
        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
      });
    }
    /*--------------------------------------------------------------------------*/

    /** Define the public API */


    punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      'version': '1.3.2',

      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      'ucs2': {
        'decode': ucs2decode,
        'encode': ucs2encode
      },
      'decode': decode,
      'encode': encode,
      'toASCII': toASCII,
      'toUnicode': toUnicode
    };
    /** Expose `punycode` */
    // Some AMD build optimizers, like r.js, check for specific condition patterns
    // like the following:

    if (freeExports && freeModule) {
      if (module.exports == freeExports) {
        // in Node.js or RingoJS v0.8.0+
        freeModule.exports = punycode;
      } else {
        // in Narwhal or RingoJS v0.7.0-
        for (key in punycode) {
          punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
        }
      }
    } else {
      // in Rhino or a web browser
      root.punycode = punycode;
    }
  })(commonjsGlobal);
});
var util = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return _typeof(arg) === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
}; // Copyright Joyent, Inc. and other Node contributors.
// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var decode = function decode(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
}; // Copyright Joyent, Inc. and other Node contributors.


var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

var encode = function encode(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (_typeof(obj) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var querystring = createCommonjsModule(function (module, exports) {
  exports.decode = exports.parse = decode;
  exports.encode = exports.stringify = encode;
});
var parse = urlParse;
var resolve = urlResolve;
var resolveObject = urlResolveObject;
var format$1 = urlFormat;
var Url_1 = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + _typeof(url));
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift())) {
        ;
      }

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

var url = {
  parse: parse,
  resolve: resolve,
  resolveObject: resolveObject,
  format: format$1,
  Url: Url_1
};

function getPropertyReference(propertyName) {
  for (var i = 0; i < v8.layout.length; i++) {
    for (var key in v8[v8.layout[i]]) {
      if (key === propertyName) return v8[v8.layout[i]][key];
    }
  }

  for (var _i = 0; _i < v8.paint.length; _i++) {
    for (var _key2 in v8[v8.paint[_i]]) {
      if (_key2 === propertyName) return v8[v8.paint[_i]][_key2];
    }
  }

  return null;
}

function eachSource(style, callback) {
  for (var k in style.sources) {
    callback(style.sources[k]);
  }
}

function eachLayer(style, callback) {
  var _iterator = _createForOfIteratorHelper(style.layers),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _layer = _step.value;
      callback(_layer);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function eachProperty(style, options, callback) {
  function inner(layer, propertyType) {
    var properties = layer[propertyType];
    if (!properties) return;
    Object.keys(properties).forEach(function (key) {
      callback({
        path: [layer.id, propertyType, key],
        key: key,
        value: properties[key],
        reference: getPropertyReference(key),
        set: function set(x) {
          properties[key] = x;
        }
      });
    });
  }

  eachLayer(style, function (layer) {
    if (options.paint) {
      inner(layer, 'paint');
    }

    if (options.layout) {
      inner(layer, 'layout');
    }
  });
}

function eachLayout(layer, callback) {
  for (var k in layer) {
    if (k.indexOf('layout') === 0) {
      callback(layer[k], k);
    }
  }
}

function eachPaint(layer, callback) {
  for (var k in layer) {
    if (k.indexOf('paint') === 0) {
      callback(layer[k], k);
    }
  }
}

function resolveConstant(style, value) {
  if (typeof value === 'string' && value[0] === '@') {
    return resolveConstant(style, style.constants[value]);
  } else {
    return value;
  }
}

function isFunction(value) {
  return Array.isArray(value.stops);
}

function renameProperty(obj, from, to) {
  obj[to] = obj[from];
  delete obj[from];
}

function migrateToV8(style) {
  style.version = 8;
  eachSource(style, function (source) {
    if (source.type === 'video' && source.url !== undefined) {
      renameProperty(source, 'url', 'urls');
    }

    if (source.type === 'video') {
      source.coordinates.forEach(function (coord) {
        return coord.reverse();
      });
    }
  });
  eachLayer(style, function (layer) {
    eachLayout(layer, function (layout) {
      if (layout['symbol-min-distance'] !== undefined) {
        renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');
      }
    });
    eachPaint(layer, function (paint) {
      if (paint['background-image'] !== undefined) {
        renameProperty(paint, 'background-image', 'background-pattern');
      }

      if (paint['line-image'] !== undefined) {
        renameProperty(paint, 'line-image', 'line-pattern');
      }

      if (paint['fill-image'] !== undefined) {
        renameProperty(paint, 'fill-image', 'fill-pattern');
      }
    });
  });
  eachProperty(style, {
    paint: true,
    layout: true
  }, function (property) {
    var value = resolveConstant(style, property.value);

    if (isFunction(value)) {
      value.stops.forEach(function (stop) {
        stop[1] = resolveConstant(style, stop[1]);
      });
    }

    property.set(value);
  });
  delete style.constants;
  eachLayer(style, function (layer) {
    eachLayout(layer, function (layout) {
      delete layout['text-max-size'];
      delete layout['icon-max-size'];
    });
    eachPaint(layer, function (paint) {
      if (paint['text-size']) {
        if (!layer.layout) layer.layout = {};
        layer.layout['text-size'] = paint['text-size'];
        delete paint['text-size'];
      }

      if (paint['icon-size']) {
        if (!layer.layout) layer.layout = {};
        layer.layout['icon-size'] = paint['icon-size'];
        delete paint['icon-size'];
      }
    });
  });

  function migrateFontstackURL(input) {
    var inputParsed = url.parse(input);
    var inputPathnameParts = inputParsed.pathname.split('/');

    if (inputParsed.protocol !== 'mapbox:') {
      return input;
    } else if (inputParsed.hostname === 'fontstack') {
      return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';
    } else if (inputParsed.hostname === 'fonts') {
      return "mapbox://fonts/".concat(inputPathnameParts[2], "/{fontstack}/{range}.pbf");
    } else ;
  }

  if (style.glyphs) {
    style.glyphs = migrateFontstackURL(style.glyphs);
  }

  function migrateFontStack(font) {
    function splitAndTrim(string) {
      return string.split(',').map(function (s) {
        return s.trim();
      });
    }

    if (Array.isArray(font)) {
      return font;
    } else if (typeof font === 'string') {
      return splitAndTrim(font);
    } else if (_typeof(font) === 'object') {
      font.stops.forEach(function (stop) {
        stop[1] = splitAndTrim(stop[1]);
      });
      return font;
    } else {
      throw new Error('unexpected font value');
    }
  }

  eachLayer(style, function (layer) {
    eachLayout(layer, function (layout) {
      if (layout['text-font']) {
        layout['text-font'] = migrateFontStack(layout['text-font']);
      }
    });
  });
  var firstSymbolLayer = 0;

  for (var i = style.layers.length - 1; i >= 0; i--) {
    var _layer2 = style.layers[i];

    if (_layer2.type !== 'symbol') {
      firstSymbolLayer = i + 1;
      break;
    }
  }

  var symbolLayers = style.layers.splice(firstSymbolLayer);
  symbolLayers.reverse();
  style.layers = style.layers.concat(symbolLayers);
  return style;
}

function extend(output) {
  for (var _len = arguments.length, inputs = new Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {
    inputs[_key3 - 1] = arguments[_key3];
  }

  for (var _i2 = 0, _inputs = inputs; _i2 < _inputs.length; _i2++) {
    var input = _inputs[_i2];

    for (var k in input) {
      output[k] = input[k];
    }
  }

  return output;
}

var ParsingError = /*#__PURE__*/function (_Error) {
  _inherits(ParsingError, _Error);

  var _super = _createSuper(ParsingError);

  function ParsingError(key, message) {
    var _this;

    _classCallCheck(this, ParsingError);

    _this = _super.call(this, message);
    _this.message = message;
    _this.key = key;
    return _this;
  }

  return _createClass(ParsingError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

var Scope = /*#__PURE__*/function () {
  function Scope(parent) {
    var bindings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, Scope);

    this.parent = parent;
    this.bindings = {};

    var _iterator2 = _createForOfIteratorHelper(bindings),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            name = _step2$value[0],
            _expression = _step2$value[1];

        this.bindings[name] = _expression;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  _createClass(Scope, [{
    key: "concat",
    value: function concat(bindings) {
      return new Scope(this, bindings);
    }
  }, {
    key: "get",
    value: function get(name) {
      if (this.bindings[name]) {
        return this.bindings[name];
      }

      if (this.parent) {
        return this.parent.get(name);
      }

      throw new Error("".concat(name, " not found in scope."));
    }
  }, {
    key: "has",
    value: function has(name) {
      if (this.bindings[name]) return true;
      return this.parent ? this.parent.has(name) : false;
    }
  }]);

  return Scope;
}();

var NullType = {
  kind: 'null'
};
var NumberType = {
  kind: 'number'
};
var StringType = {
  kind: 'string'
};
var BooleanType = {
  kind: 'boolean'
};
var ColorType = {
  kind: 'color'
};
var ObjectType = {
  kind: 'object'
};
var ValueType = {
  kind: 'value'
};
var ErrorType = {
  kind: 'error'
};
var CollatorType = {
  kind: 'collator'
};
var FormattedType = {
  kind: 'formatted'
};
var ResolvedImageType = {
  kind: 'resolvedImage'
};

function array(itemType, N) {
  return {
    kind: 'array',
    itemType: itemType,
    N: N
  };
}

function toString(type) {
  if (type.kind === 'array') {
    var itemType = toString(type.itemType);
    return typeof type.N === 'number' ? "array<".concat(itemType, ", ").concat(type.N, ">") : type.itemType.kind === 'value' ? 'array' : "array<".concat(itemType, ">");
  } else {
    return type.kind;
  }
}

var valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array(ValueType), ResolvedImageType];

function _checkSubtype(expected, t) {
  if (t.kind === 'error') {
    return null;
  } else if (expected.kind === 'array') {
    if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !_checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
      return null;
    }
  } else if (expected.kind === t.kind) {
    return null;
  } else if (expected.kind === 'value') {
    var _iterator3 = _createForOfIteratorHelper(valueMemberTypes),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var memberType = _step3.value;

        if (!_checkSubtype(memberType, t)) {
          return null;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }

  return "Expected ".concat(toString(expected), " but found ").concat(toString(t), " instead.");
}

function isValidType(provided, allowedTypes) {
  return allowedTypes.some(function (t) {
    return t.kind === provided.kind;
  });
}

function isValidNativeType(provided, allowedTypes) {
  return allowedTypes.some(function (t) {
    if (t === 'null') {
      return provided === null;
    } else if (t === 'array') {
      return Array.isArray(provided);
    } else if (t === 'object') {
      return provided && !Array.isArray(provided) && _typeof(provided) === 'object';
    } else {
      return t === _typeof(provided);
    }
  });
}

var csscolorparser = createCommonjsModule(function (module, exports) {
  // (c) Dean McNamee <dean@gmail.com>, 2012.
  //
  // https://github.com/deanm/css-color-parser-js
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to
  // deal in the Software without restriction, including without limitation the
  // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  // sell copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  // IN THE SOFTWARE.
  // http://www.w3.org/TR/css3-color/
  var kCSSColorTable = {
    "transparent": [0, 0, 0, 0],
    "aliceblue": [240, 248, 255, 1],
    "antiquewhite": [250, 235, 215, 1],
    "aqua": [0, 255, 255, 1],
    "aquamarine": [127, 255, 212, 1],
    "azure": [240, 255, 255, 1],
    "beige": [245, 245, 220, 1],
    "bisque": [255, 228, 196, 1],
    "black": [0, 0, 0, 1],
    "blanchedalmond": [255, 235, 205, 1],
    "blue": [0, 0, 255, 1],
    "blueviolet": [138, 43, 226, 1],
    "brown": [165, 42, 42, 1],
    "burlywood": [222, 184, 135, 1],
    "cadetblue": [95, 158, 160, 1],
    "chartreuse": [127, 255, 0, 1],
    "chocolate": [210, 105, 30, 1],
    "coral": [255, 127, 80, 1],
    "cornflowerblue": [100, 149, 237, 1],
    "cornsilk": [255, 248, 220, 1],
    "crimson": [220, 20, 60, 1],
    "cyan": [0, 255, 255, 1],
    "darkblue": [0, 0, 139, 1],
    "darkcyan": [0, 139, 139, 1],
    "darkgoldenrod": [184, 134, 11, 1],
    "darkgray": [169, 169, 169, 1],
    "darkgreen": [0, 100, 0, 1],
    "darkgrey": [169, 169, 169, 1],
    "darkkhaki": [189, 183, 107, 1],
    "darkmagenta": [139, 0, 139, 1],
    "darkolivegreen": [85, 107, 47, 1],
    "darkorange": [255, 140, 0, 1],
    "darkorchid": [153, 50, 204, 1],
    "darkred": [139, 0, 0, 1],
    "darksalmon": [233, 150, 122, 1],
    "darkseagreen": [143, 188, 143, 1],
    "darkslateblue": [72, 61, 139, 1],
    "darkslategray": [47, 79, 79, 1],
    "darkslategrey": [47, 79, 79, 1],
    "darkturquoise": [0, 206, 209, 1],
    "darkviolet": [148, 0, 211, 1],
    "deeppink": [255, 20, 147, 1],
    "deepskyblue": [0, 191, 255, 1],
    "dimgray": [105, 105, 105, 1],
    "dimgrey": [105, 105, 105, 1],
    "dodgerblue": [30, 144, 255, 1],
    "firebrick": [178, 34, 34, 1],
    "floralwhite": [255, 250, 240, 1],
    "forestgreen": [34, 139, 34, 1],
    "fuchsia": [255, 0, 255, 1],
    "gainsboro": [220, 220, 220, 1],
    "ghostwhite": [248, 248, 255, 1],
    "gold": [255, 215, 0, 1],
    "goldenrod": [218, 165, 32, 1],
    "gray": [128, 128, 128, 1],
    "green": [0, 128, 0, 1],
    "greenyellow": [173, 255, 47, 1],
    "grey": [128, 128, 128, 1],
    "honeydew": [240, 255, 240, 1],
    "hotpink": [255, 105, 180, 1],
    "indianred": [205, 92, 92, 1],
    "indigo": [75, 0, 130, 1],
    "ivory": [255, 255, 240, 1],
    "khaki": [240, 230, 140, 1],
    "lavender": [230, 230, 250, 1],
    "lavenderblush": [255, 240, 245, 1],
    "lawngreen": [124, 252, 0, 1],
    "lemonchiffon": [255, 250, 205, 1],
    "lightblue": [173, 216, 230, 1],
    "lightcoral": [240, 128, 128, 1],
    "lightcyan": [224, 255, 255, 1],
    "lightgoldenrodyellow": [250, 250, 210, 1],
    "lightgray": [211, 211, 211, 1],
    "lightgreen": [144, 238, 144, 1],
    "lightgrey": [211, 211, 211, 1],
    "lightpink": [255, 182, 193, 1],
    "lightsalmon": [255, 160, 122, 1],
    "lightseagreen": [32, 178, 170, 1],
    "lightskyblue": [135, 206, 250, 1],
    "lightslategray": [119, 136, 153, 1],
    "lightslategrey": [119, 136, 153, 1],
    "lightsteelblue": [176, 196, 222, 1],
    "lightyellow": [255, 255, 224, 1],
    "lime": [0, 255, 0, 1],
    "limegreen": [50, 205, 50, 1],
    "linen": [250, 240, 230, 1],
    "magenta": [255, 0, 255, 1],
    "maroon": [128, 0, 0, 1],
    "mediumaquamarine": [102, 205, 170, 1],
    "mediumblue": [0, 0, 205, 1],
    "mediumorchid": [186, 85, 211, 1],
    "mediumpurple": [147, 112, 219, 1],
    "mediumseagreen": [60, 179, 113, 1],
    "mediumslateblue": [123, 104, 238, 1],
    "mediumspringgreen": [0, 250, 154, 1],
    "mediumturquoise": [72, 209, 204, 1],
    "mediumvioletred": [199, 21, 133, 1],
    "midnightblue": [25, 25, 112, 1],
    "mintcream": [245, 255, 250, 1],
    "mistyrose": [255, 228, 225, 1],
    "moccasin": [255, 228, 181, 1],
    "navajowhite": [255, 222, 173, 1],
    "navy": [0, 0, 128, 1],
    "oldlace": [253, 245, 230, 1],
    "olive": [128, 128, 0, 1],
    "olivedrab": [107, 142, 35, 1],
    "orange": [255, 165, 0, 1],
    "orangered": [255, 69, 0, 1],
    "orchid": [218, 112, 214, 1],
    "palegoldenrod": [238, 232, 170, 1],
    "palegreen": [152, 251, 152, 1],
    "paleturquoise": [175, 238, 238, 1],
    "palevioletred": [219, 112, 147, 1],
    "papayawhip": [255, 239, 213, 1],
    "peachpuff": [255, 218, 185, 1],
    "peru": [205, 133, 63, 1],
    "pink": [255, 192, 203, 1],
    "plum": [221, 160, 221, 1],
    "powderblue": [176, 224, 230, 1],
    "purple": [128, 0, 128, 1],
    "rebeccapurple": [102, 51, 153, 1],
    "red": [255, 0, 0, 1],
    "rosybrown": [188, 143, 143, 1],
    "royalblue": [65, 105, 225, 1],
    "saddlebrown": [139, 69, 19, 1],
    "salmon": [250, 128, 114, 1],
    "sandybrown": [244, 164, 96, 1],
    "seagreen": [46, 139, 87, 1],
    "seashell": [255, 245, 238, 1],
    "sienna": [160, 82, 45, 1],
    "silver": [192, 192, 192, 1],
    "skyblue": [135, 206, 235, 1],
    "slateblue": [106, 90, 205, 1],
    "slategray": [112, 128, 144, 1],
    "slategrey": [112, 128, 144, 1],
    "snow": [255, 250, 250, 1],
    "springgreen": [0, 255, 127, 1],
    "steelblue": [70, 130, 180, 1],
    "tan": [210, 180, 140, 1],
    "teal": [0, 128, 128, 1],
    "thistle": [216, 191, 216, 1],
    "tomato": [255, 99, 71, 1],
    "turquoise": [64, 224, 208, 1],
    "violet": [238, 130, 238, 1],
    "wheat": [245, 222, 179, 1],
    "white": [255, 255, 255, 1],
    "whitesmoke": [245, 245, 245, 1],
    "yellow": [255, 255, 0, 1],
    "yellowgreen": [154, 205, 50, 1]
  };

  function clamp_css_byte(i) {
    // Clamp to integer 0 .. 255.
    i = Math.round(i); // Seems to be what Chrome does (vs truncation).

    return i < 0 ? 0 : i > 255 ? 255 : i;
  }

  function clamp_css_float(f) {
    // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }

  function parse_css_int(str) {
    // int or percentage.
    if (str[str.length - 1] === '%') return clamp_css_byte(parseFloat(str) / 100 * 255);
    return clamp_css_byte(parseInt(str));
  }

  function parse_css_float(str) {
    // float or percentage.
    if (str[str.length - 1] === '%') return clamp_css_float(parseFloat(str) / 100);
    return clamp_css_float(parseFloat(str));
  }

  function css_hue_to_rgb(m1, m2, h) {
    if (h < 0) h += 1;else if (h > 1) h -= 1;
    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    return m1;
  }

  function parseCSSColor(css_str) {
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = css_str.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

    if (str in kCSSColorTable) return kCSSColorTable[str].slice(); // dup.
    // #abc and #abc123 syntax.

    if (str[0] === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.

        return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.

        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
      }

      return null;
    }

    var op = str.indexOf('('),
        ep = str.indexOf(')');

    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(',');
      var alpha = 1; // To allow case fallthrough.

      switch (fname) {
        case 'rgba':
          if (params.length !== 4) return null;
          alpha = parse_css_float(params.pop());
        // Fall through.

        case 'rgb':
          if (params.length !== 3) return null;
          return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];

        case 'hsla':
          if (params.length !== 4) return null;
          alpha = parse_css_float(params.pop());
        // Fall through.

        case 'hsl':
          if (params.length !== 3) return null;
          var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
          // NOTE(deanm): According to the CSS spec s/l should only be
          // percentages, but we don't bother and let float or percentage.

          var s = parse_css_float(params[1]);
          var l = parse_css_float(params[2]);
          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var m1 = l * 2 - m2;
          return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];

        default:
          return null;
      }
    }

    return null;
  }

  try {
    exports.parseCSSColor = parseCSSColor;
  } catch (e) {}
});

var Color = /*#__PURE__*/function () {
  function Color(r, g, b) {
    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, Color);

    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  _createClass(Color, [{
    key: "toString",
    value: function toString() {
      var _this$toArray = this.toArray(),
          _this$toArray2 = _slicedToArray(_this$toArray, 4),
          r = _this$toArray2[0],
          g = _this$toArray2[1],
          b = _this$toArray2[2],
          a = _this$toArray2[3];

      return "rgba(".concat(Math.round(r), ",").concat(Math.round(g), ",").concat(Math.round(b), ",").concat(a, ")");
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var r = this.r,
          g = this.g,
          b = this.b,
          a = this.a;
      return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];
    }
  }], [{
    key: "parse",
    value: function parse(input) {
      if (!input) {
        return undefined;
      }

      if (input instanceof Color) {
        return input;
      }

      if (typeof input !== 'string') {
        return undefined;
      }

      var rgba = csscolorparser.parseCSSColor(input);

      if (!rgba) {
        return undefined;
      }

      return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
    }
  }]);

  return Color;
}();

Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);
Color.blue = new Color(0, 0, 1, 1);

var Collator = /*#__PURE__*/function () {
  function Collator(caseSensitive, diacriticSensitive, locale) {
    _classCallCheck(this, Collator);

    if (caseSensitive) this.sensitivity = diacriticSensitive ? 'variant' : 'case';else this.sensitivity = diacriticSensitive ? 'accent' : 'base';
    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
      sensitivity: this.sensitivity,
      usage: 'search'
    });
  }

  _createClass(Collator, [{
    key: "compare",
    value: function compare(lhs, rhs) {
      return this.collator.compare(lhs, rhs);
    }
  }, {
    key: "resolvedLocale",
    value: function resolvedLocale() {
      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
    }
  }]);

  return Collator;
}();

var FormattedSection = /*#__PURE__*/_createClass(function FormattedSection(text, image, scale, fontStack, textColor) {
  _classCallCheck(this, FormattedSection);

  this.text = text;
  this.image = image;
  this.scale = scale;
  this.fontStack = fontStack;
  this.textColor = textColor;
});

var Formatted = /*#__PURE__*/function () {
  function Formatted(sections) {
    _classCallCheck(this, Formatted);

    this.sections = sections;
  }

  _createClass(Formatted, [{
    key: "isEmpty",
    value: function isEmpty() {
      if (this.sections.length === 0) return true;
      return !this.sections.some(function (section) {
        return section.text.length !== 0 || section.image && section.image.name.length !== 0;
      });
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.sections.length === 0) return '';
      return this.sections.map(function (section) {
        return section.text;
      }).join('');
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serialized = ['format'];

      var _iterator4 = _createForOfIteratorHelper(this.sections),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var section = _step4.value;

          if (section.image) {
            serialized.push(['image', section.image.name]);
            continue;
          }

          serialized.push(section.text);
          var options = {};

          if (section.fontStack) {
            options['text-font'] = ['literal', section.fontStack.split(',')];
          }

          if (section.scale) {
            options['font-scale'] = section.scale;
          }

          if (section.textColor) {
            options['text-color'] = ['rgba'].concat(section.textColor.toArray());
          }

          serialized.push(options);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return serialized;
    }
  }], [{
    key: "fromString",
    value: function fromString(unformatted) {
      return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
    }
  }, {
    key: "factory",
    value: function factory(text) {
      if (text instanceof Formatted) {
        return text;
      } else {
        return Formatted.fromString(text);
      }
    }
  }]);

  return Formatted;
}();

var ResolvedImage = /*#__PURE__*/function () {
  function ResolvedImage(options) {
    _classCallCheck(this, ResolvedImage);

    this.name = options.name;
    this.available = options.available;
  }

  _createClass(ResolvedImage, [{
    key: "toString",
    value: function toString() {
      return this.name;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return ['image', this.name];
    }
  }], [{
    key: "fromString",
    value: function fromString(name) {
      if (!name) return null;
      return new ResolvedImage({
        name: name,
        available: false
      });
    }
  }]);

  return ResolvedImage;
}();

function validateRGBA(r, g, b, a) {
  if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
    var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
    return "Invalid rgba value [".concat(value.join(', '), "]: 'r', 'g', and 'b' must be between 0 and 255.");
  }

  if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
    return "Invalid rgba value [".concat([r, g, b, a].join(', '), "]: 'a' must be between 0 and 1.");
  }

  return null;
}

function isValue(mixed) {
  if (mixed === null) {
    return true;
  } else if (typeof mixed === 'string') {
    return true;
  } else if (typeof mixed === 'boolean') {
    return true;
  } else if (typeof mixed === 'number') {
    return true;
  } else if (mixed instanceof Color) {
    return true;
  } else if (mixed instanceof Collator) {
    return true;
  } else if (mixed instanceof Formatted) {
    return true;
  } else if (mixed instanceof ResolvedImage) {
    return true;
  } else if (Array.isArray(mixed)) {
    var _iterator5 = _createForOfIteratorHelper(mixed),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var item = _step5.value;

        if (!isValue(item)) {
          return false;
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    return true;
  } else if (_typeof(mixed) === 'object') {
    for (var key in mixed) {
      if (!isValue(mixed[key])) {
        return false;
      }
    }

    return true;
  } else {
    return false;
  }
}

function typeOf(value) {
  if (value === null) {
    return NullType;
  } else if (typeof value === 'string') {
    return StringType;
  } else if (typeof value === 'boolean') {
    return BooleanType;
  } else if (typeof value === 'number') {
    return NumberType;
  } else if (value instanceof Color) {
    return ColorType;
  } else if (value instanceof Collator) {
    return CollatorType;
  } else if (value instanceof Formatted) {
    return FormattedType;
  } else if (value instanceof ResolvedImage) {
    return ResolvedImageType;
  } else if (Array.isArray(value)) {
    var length = value.length;
    var itemType;

    var _iterator6 = _createForOfIteratorHelper(value),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var item = _step6.value;
        var t = typeOf(item);

        if (!itemType) {
          itemType = t;
        } else if (itemType === t) {
          continue;
        } else {
          itemType = ValueType;
          break;
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    return array(itemType || ValueType, length);
  } else {
    return ObjectType;
  }
}

function toString$1(value) {
  var type = _typeof(value);

  if (value === null) {
    return '';
  } else if (type === 'string' || type === 'number' || type === 'boolean') {
    return String(value);
  } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
    return value.toString();
  } else {
    return JSON.stringify(value);
  }
}

var Literal = /*#__PURE__*/function () {
  function Literal(type, value) {
    _classCallCheck(this, Literal);

    this.type = type;
    this.value = value;
  }

  _createClass(Literal, [{
    key: "evaluate",
    value: function evaluate() {
      return this.value;
    }
  }, {
    key: "eachChild",
    value: function eachChild() {}
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return true;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      if (this.type.kind === 'array' || this.type.kind === 'object') {
        return ['literal', this.value];
      } else if (this.value instanceof Color) {
        return ['rgba'].concat(this.value.toArray());
      } else if (this.value instanceof Formatted) {
        return this.value.serialize();
      } else {
        return this.value;
      }
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 2) return context.error("'literal' expression requires exactly one argument, but found ".concat(args.length - 1, " instead."));
      if (!isValue(args[1])) return context.error("invalid value");
      var value = args[1];
      var type = typeOf(value);
      var expected = context.expectedType;

      if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
        type = expected;
      }

      return new Literal(type, value);
    }
  }]);

  return Literal;
}();

var RuntimeError = /*#__PURE__*/function () {
  function RuntimeError(message) {
    _classCallCheck(this, RuntimeError);

    this.name = 'ExpressionEvaluationError';
    this.message = message;
  }

  _createClass(RuntimeError, [{
    key: "toJSON",
    value: function toJSON() {
      return this.message;
    }
  }]);

  return RuntimeError;
}();

var types = {
  string: StringType,
  number: NumberType,
  "boolean": BooleanType,
  object: ObjectType
};

var Assertion = /*#__PURE__*/function () {
  function Assertion(type, args) {
    _classCallCheck(this, Assertion);

    this.type = type;
    this.args = args;
  }

  _createClass(Assertion, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      for (var i = 0; i < this.args.length; i++) {
        var value = this.args[i].evaluate(ctx);

        var _error = _checkSubtype(this.type, typeOf(value));

        if (!_error) {
          return value;
        } else if (i === this.args.length - 1) {
          throw new RuntimeError("Expected value to be of type ".concat(toString(this.type), ", but found ").concat(toString(typeOf(value)), " instead."));
        }
      }

      return null;
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      this.args.forEach(fn);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.args.every(function (arg) {
        return arg.outputDefined();
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var type = this.type;
      var serialized = [type.kind];

      if (type.kind === 'array') {
        var itemType = type.itemType;

        if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
          serialized.push(itemType.kind);
          var N = type.N;

          if (typeof N === 'number' || this.args.length > 1) {
            serialized.push(N);
          }
        }
      }

      return serialized.concat(this.args.map(function (arg) {
        return arg.serialize();
      }));
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length < 2) return context.error("Expected at least one argument.");
      var i = 1;
      var type;
      var name = args[0];

      if (name === 'array') {
        var itemType;

        if (args.length > 2) {
          var _type = args[1];
          if (typeof _type !== 'string' || !(_type in types) || _type === 'object') return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
          itemType = types[_type];
          i++;
        } else {
          itemType = ValueType;
        }

        var N;

        if (args.length > 3) {
          if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
            return context.error('The length argument to "array" must be a positive integer literal', 2);
          }

          N = args[2];
          i++;
        }

        type = array(itemType, N);
      } else {
        type = types[name];
      }

      var parsed = [];

      for (; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) return null;
        parsed.push(input);
      }

      return new Assertion(type, parsed);
    }
  }]);

  return Assertion;
}();

var FormatExpression = /*#__PURE__*/function () {
  function FormatExpression(sections) {
    _classCallCheck(this, FormatExpression);

    this.type = FormattedType;
    this.sections = sections;
  }

  _createClass(FormatExpression, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var evaluateSection = function evaluateSection(section) {
        var evaluatedContent = section.content.evaluate(ctx);

        if (typeOf(evaluatedContent) === ResolvedImageType) {
          return new FormattedSection('', evaluatedContent, null, null, null);
        }

        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
      };

      return new Formatted(this.sections.map(evaluateSection));
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      var _iterator7 = _createForOfIteratorHelper(this.sections),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var section = _step7.value;
          fn(section.content);

          if (section.scale) {
            fn(section.scale);
          }

          if (section.font) {
            fn(section.font);
          }

          if (section.textColor) {
            fn(section.textColor);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serialized = ['format'];

      var _iterator8 = _createForOfIteratorHelper(this.sections),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var section = _step8.value;
          serialized.push(section.content.serialize());
          var options = {};

          if (section.scale) {
            options['font-scale'] = section.scale.serialize();
          }

          if (section.font) {
            options['text-font'] = section.font.serialize();
          }

          if (section.textColor) {
            options['text-color'] = section.textColor.serialize();
          }

          serialized.push(options);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length < 2) {
        return context.error("Expected at least one argument.");
      }

      var firstArg = args[1];

      if (!Array.isArray(firstArg) && _typeof(firstArg) === 'object') {
        return context.error("First argument must be an image or text section.");
      }

      var sections = [];
      var nextTokenMayBeObject = false;

      for (var i = 1; i <= args.length - 1; ++i) {
        var arg = args[i];

        if (nextTokenMayBeObject && _typeof(arg) === 'object' && !Array.isArray(arg)) {
          nextTokenMayBeObject = false;
          var scale = null;

          if (arg['font-scale']) {
            scale = context.parse(arg['font-scale'], 1, NumberType);
            if (!scale) return null;
          }

          var font = null;

          if (arg['text-font']) {
            font = context.parse(arg['text-font'], 1, array(StringType));
            if (!font) return null;
          }

          var textColor = null;

          if (arg['text-color']) {
            textColor = context.parse(arg['text-color'], 1, ColorType);
            if (!textColor) return null;
          }

          var lastExpression = sections[sections.length - 1];
          lastExpression.scale = scale;
          lastExpression.font = font;
          lastExpression.textColor = textColor;
        } else {
          var content = context.parse(args[i], 1, ValueType);
          if (!content) return null;
          var kind = content.type.kind;
          if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') return context.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
          nextTokenMayBeObject = true;
          sections.push({
            content: content,
            scale: null,
            font: null,
            textColor: null
          });
        }
      }

      return new FormatExpression(sections);
    }
  }]);

  return FormatExpression;
}();

var ImageExpression = /*#__PURE__*/function () {
  function ImageExpression(input) {
    _classCallCheck(this, ImageExpression);

    this.type = ResolvedImageType;
    this.input = input;
  }

  _createClass(ImageExpression, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var evaluatedImageName = this.input.evaluate(ctx);
      var value = ResolvedImage.fromString(evaluatedImageName);
      if (value && ctx.availableImages) value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
      return value;
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.input);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return ['image', this.input.serialize()];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 2) {
        return context.error("Expected two arguments.");
      }

      var name = context.parse(args[1], 1, StringType);
      if (!name) return context.error("No image name provided.");
      return new ImageExpression(name);
    }
  }]);

  return ImageExpression;
}();

var types$1 = {
  'to-boolean': BooleanType,
  'to-color': ColorType,
  'to-number': NumberType,
  'to-string': StringType
};

var Coercion = /*#__PURE__*/function () {
  function Coercion(type, args) {
    _classCallCheck(this, Coercion);

    this.type = type;
    this.args = args;
  }

  _createClass(Coercion, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      if (this.type.kind === 'boolean') {
        return Boolean(this.args[0].evaluate(ctx));
      } else if (this.type.kind === 'color') {
        var input;

        var _error2;

        var _iterator9 = _createForOfIteratorHelper(this.args),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var arg = _step9.value;
            input = arg.evaluate(ctx);
            _error2 = null;

            if (input instanceof Color) {
              return input;
            } else if (typeof input === 'string') {
              var c = ctx.parseColor(input);
              if (c) return c;
            } else if (Array.isArray(input)) {
              if (input.length < 3 || input.length > 4) {
                _error2 = "Invalid rbga value ".concat(JSON.stringify(input), ": expected an array containing either three or four numeric values.");
              } else {
                _error2 = validateRGBA(input[0], input[1], input[2], input[3]);
              }

              if (!_error2) {
                return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
              }
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        throw new RuntimeError(_error2 || "Could not parse color from value '".concat(typeof input === 'string' ? input : String(JSON.stringify(input)), "'"));
      } else if (this.type.kind === 'number') {
        var value = null;

        var _iterator10 = _createForOfIteratorHelper(this.args),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var _arg = _step10.value;
            value = _arg.evaluate(ctx);
            if (value === null) return 0;
            var num = Number(value);
            if (isNaN(num)) continue;
            return num;
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }

        throw new RuntimeError("Could not convert ".concat(JSON.stringify(value), " to number."));
      } else if (this.type.kind === 'formatted') {
        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));
      } else if (this.type.kind === 'resolvedImage') {
        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));
      } else {
        return toString$1(this.args[0].evaluate(ctx));
      }
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      this.args.forEach(fn);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.args.every(function (arg) {
        return arg.outputDefined();
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      if (this.type.kind === 'formatted') {
        return new FormatExpression([{
          content: this.args[0],
          scale: null,
          font: null,
          textColor: null
        }]).serialize();
      }

      if (this.type.kind === 'resolvedImage') {
        return new ImageExpression(this.args[0]).serialize();
      }

      var serialized = ["to-".concat(this.type.kind)];
      this.eachChild(function (child) {
        serialized.push(child.serialize());
      });
      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length < 2) return context.error("Expected at least one argument.");
      var name = args[0];
      if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) return context.error("Expected one argument.");
      var type = types$1[name];
      var parsed = [];

      for (var i = 1; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) return null;
        parsed.push(input);
      }

      return new Coercion(type, parsed);
    }
  }]);

  return Coercion;
}();

var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

var EvaluationContext = /*#__PURE__*/function () {
  function EvaluationContext() {
    _classCallCheck(this, EvaluationContext);

    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = {};
    this.availableImages = null;
    this.canonical = null;
  }

  _createClass(EvaluationContext, [{
    key: "id",
    value: function id() {
      return this.feature && 'id' in this.feature ? this.feature.id : null;
    }
  }, {
    key: "geometryType",
    value: function geometryType() {
      return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
    }
  }, {
    key: "geometry",
    value: function geometry() {
      return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
    }
  }, {
    key: "canonicalID",
    value: function canonicalID() {
      return this.canonical;
    }
  }, {
    key: "properties",
    value: function properties() {
      return this.feature && this.feature.properties || {};
    }
  }, {
    key: "parseColor",
    value: function parseColor(input) {
      var cached = this._parseColorCache[input];

      if (!cached) {
        cached = this._parseColorCache[input] = Color.parse(input);
      }

      return cached;
    }
  }]);

  return EvaluationContext;
}();

var CompoundExpression = /*#__PURE__*/function () {
  function CompoundExpression(name, type, evaluate, args) {
    _classCallCheck(this, CompoundExpression);

    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
  }

  _createClass(CompoundExpression, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      return this._evaluate(ctx, this.args);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      this.args.forEach(fn);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return [this.name].concat(this.args.map(function (arg) {
        return arg.serialize();
      }));
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      var op = args[0];
      var definition = CompoundExpression.definitions[op];

      if (!definition) {
        return context.error("Unknown expression \"".concat(op, "\". If you wanted a literal array, use [\"literal\", [...]]."), 0);
      }

      var type = Array.isArray(definition) ? definition[0] : definition.type;
      var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
      var overloads = availableOverloads.filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            signature = _ref2[0];

        return !Array.isArray(signature) || signature.length === args.length - 1;
      });
      var signatureContext = null;

      var _iterator11 = _createForOfIteratorHelper(overloads),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _step11$value = _slicedToArray(_step11.value, 2),
              params = _step11$value[0],
              evaluate = _step11$value[1];

          signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
          var parsedArgs = [];
          var argParseFailed = false;

          for (var _i3 = 1; _i3 < args.length; _i3++) {
            var arg = args[_i3];
            var expectedType = Array.isArray(params) ? params[_i3 - 1] : params.type;

            var _parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);

            if (!_parsed) {
              argParseFailed = true;
              break;
            }

            parsedArgs.push(_parsed);
          }

          if (argParseFailed) {
            continue;
          }

          if (Array.isArray(params)) {
            if (params.length !== parsedArgs.length) {
              signatureContext.error("Expected ".concat(params.length, " arguments, but found ").concat(parsedArgs.length, " instead."));
              continue;
            }
          }

          for (var _i4 = 0; _i4 < parsedArgs.length; _i4++) {
            var _expected = Array.isArray(params) ? params[_i4] : params.type;

            var _arg2 = parsedArgs[_i4];
            signatureContext.concat(_i4 + 1).checkSubtype(_expected, _arg2.type);
          }

          if (signatureContext.errors.length === 0) {
            return new CompoundExpression(op, type, evaluate, parsedArgs);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      if (overloads.length === 1) {
        var _context$errors;

        (_context$errors = context.errors).push.apply(_context$errors, _toConsumableArray(signatureContext.errors));
      } else {
        var expected = overloads.length ? overloads : availableOverloads;
        var signatures = expected.map(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              params = _ref4[0];

          return stringifySignature(params);
        }).join(' | ');
        var actualTypes = [];

        for (var i = 1; i < args.length; i++) {
          var parsed = context.parse(args[i], 1 + actualTypes.length);
          if (!parsed) return null;
          actualTypes.push(toString(parsed.type));
        }

        context.error("Expected arguments of type ".concat(signatures, ", but found (").concat(actualTypes.join(', '), ") instead."));
      }

      return null;
    }
  }, {
    key: "register",
    value: function register(registry, definitions) {
      CompoundExpression.definitions = definitions;

      for (var name in definitions) {
        registry[name] = CompoundExpression;
      }
    }
  }]);

  return CompoundExpression;
}();

function stringifySignature(signature) {
  if (Array.isArray(signature)) {
    return "(".concat(signature.map(toString).join(', '), ")");
  } else {
    return "(".concat(toString(signature.type), "...)");
  }
}

var CollatorExpression = /*#__PURE__*/function () {
  function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
    _classCallCheck(this, CollatorExpression);

    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
  }

  _createClass(CollatorExpression, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.caseSensitive);
      fn(this.diacriticSensitive);

      if (this.locale) {
        fn(this.locale);
      }
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var options = {};
      options['case-sensitive'] = this.caseSensitive.serialize();
      options['diacritic-sensitive'] = this.diacriticSensitive.serialize();

      if (this.locale) {
        options['locale'] = this.locale.serialize();
      }

      return ['collator', options];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 2) return context.error("Expected one argument.");
      var options = args[1];
      if (_typeof(options) !== 'object' || Array.isArray(options)) return context.error("Collator options argument must be an object.");
      var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
      if (!caseSensitive) return null;
      var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
      if (!diacriticSensitive) return null;
      var locale = null;

      if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) return null;
      }

      return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
    }
  }]);

  return CollatorExpression;
}();

var EXTENT = 8192;

function updateBBox(bbox, coord) {
  bbox[0] = Math.min(bbox[0], coord[0]);
  bbox[1] = Math.min(bbox[1], coord[1]);
  bbox[2] = Math.max(bbox[2], coord[0]);
  bbox[3] = Math.max(bbox[3], coord[1]);
}

function mercatorXfromLng(lng) {
  return (180 + lng) / 360;
}

function mercatorYfromLat(lat) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}

function boxWithinBox(bbox1, bbox2) {
  if (bbox1[0] <= bbox2[0]) return false;
  if (bbox1[2] >= bbox2[2]) return false;
  if (bbox1[1] <= bbox2[1]) return false;
  if (bbox1[3] >= bbox2[3]) return false;
  return true;
}

function getTileCoordinates(p, canonical) {
  var x = mercatorXfromLng(p[0]);
  var y = mercatorYfromLat(p[1]);
  var tilesAtZoom = Math.pow(2, canonical.z);
  return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];
}

function onBoundary(p, p1, p2) {
  var x1 = p[0] - p1[0];
  var y1 = p[1] - p1[1];
  var x2 = p[0] - p2[0];
  var y2 = p[1] - p2[1];
  return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}

function rayIntersect(p, p1, p2) {
  return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}

function pointWithinPolygon(point, rings) {
  var inside = false;

  for (var i = 0, len = rings.length; i < len; i++) {
    var ring = rings[i];

    for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
      if (onBoundary(point, ring[j], ring[j + 1])) return false;
      if (rayIntersect(point, ring[j], ring[j + 1])) inside = !inside;
    }
  }

  return inside;
}

function pointWithinPolygons(point, polygons) {
  for (var i = 0; i < polygons.length; i++) {
    if (pointWithinPolygon(point, polygons[i])) return true;
  }

  return false;
}

function perp(v1, v2) {
  return v1[0] * v2[1] - v1[1] * v2[0];
}

function twoSided(p1, p2, q1, q2) {
  var x1 = p1[0] - q1[0];
  var y1 = p1[1] - q1[1];
  var x2 = p2[0] - q1[0];
  var y2 = p2[1] - q1[1];
  var x3 = q2[0] - q1[0];
  var y3 = q2[1] - q1[1];
  var det1 = x1 * y3 - x3 * y1;
  var det2 = x2 * y3 - x3 * y2;
  if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) return true;
  return false;
}

function lineIntersectLine(a, b, c, d) {
  var vectorP = [b[0] - a[0], b[1] - a[1]];
  var vectorQ = [d[0] - c[0], d[1] - c[1]];
  if (perp(vectorQ, vectorP) === 0) return false;
  if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) return true;
  return false;
}

function lineIntersectPolygon(p1, p2, polygon) {
  var _iterator12 = _createForOfIteratorHelper(polygon),
      _step12;

  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var ring = _step12.value;

      for (var j = 0; j < ring.length - 1; ++j) {
        if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
          return true;
        }
      }
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }

  return false;
}

function lineStringWithinPolygon(line, polygon) {
  for (var i = 0; i < line.length; ++i) {
    if (!pointWithinPolygon(line[i], polygon)) {
      return false;
    }
  }

  for (var _i5 = 0; _i5 < line.length - 1; ++_i5) {
    if (lineIntersectPolygon(line[_i5], line[_i5 + 1], polygon)) {
      return false;
    }
  }

  return true;
}

function lineStringWithinPolygons(line, polygons) {
  for (var i = 0; i < polygons.length; i++) {
    if (lineStringWithinPolygon(line, polygons[i])) return true;
  }

  return false;
}

function getTilePolygon(coordinates, bbox, canonical) {
  var polygon = [];

  for (var i = 0; i < coordinates.length; i++) {
    var ring = [];

    for (var j = 0; j < coordinates[i].length; j++) {
      var coord = getTileCoordinates(coordinates[i][j], canonical);
      updateBBox(bbox, coord);
      ring.push(coord);
    }

    polygon.push(ring);
  }

  return polygon;
}

function getTilePolygons(coordinates, bbox, canonical) {
  var polygons = [];

  for (var i = 0; i < coordinates.length; i++) {
    var polygon = getTilePolygon(coordinates[i], bbox, canonical);
    polygons.push(polygon);
  }

  return polygons;
}

function updatePoint(p, bbox, polyBBox, worldSize) {
  if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
    var halfWorldSize = worldSize * 0.5;
    var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;

    if (shift === 0) {
      shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
    }

    p[0] += shift;
  }

  updateBBox(bbox, p);
}

function resetBBox(bbox) {
  bbox[0] = bbox[1] = Infinity;
  bbox[2] = bbox[3] = -Infinity;
}

function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
  var worldSize = Math.pow(2, canonical.z) * EXTENT;
  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
  var tilePoints = [];

  var _iterator13 = _createForOfIteratorHelper(geometry),
      _step13;

  try {
    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
      var points = _step13.value;

      var _iterator14 = _createForOfIteratorHelper(points),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var point = _step14.value;
          var p = [point.x + shifts[0], point.y + shifts[1]];
          updatePoint(p, pointBBox, polyBBox, worldSize);
          tilePoints.push(p);
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
  } catch (err) {
    _iterator13.e(err);
  } finally {
    _iterator13.f();
  }

  return tilePoints;
}

function getTileLines(geometry, lineBBox, polyBBox, canonical) {
  var worldSize = Math.pow(2, canonical.z) * EXTENT;
  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
  var tileLines = [];

  var _iterator15 = _createForOfIteratorHelper(geometry),
      _step15;

  try {
    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
      var _line = _step15.value;
      var tileLine = [];

      var _iterator18 = _createForOfIteratorHelper(_line),
          _step18;

      try {
        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
          var point = _step18.value;
          var _p = [point.x + shifts[0], point.y + shifts[1]];
          updateBBox(lineBBox, _p);
          tileLine.push(_p);
        }
      } catch (err) {
        _iterator18.e(err);
      } finally {
        _iterator18.f();
      }

      tileLines.push(tileLine);
    }
  } catch (err) {
    _iterator15.e(err);
  } finally {
    _iterator15.f();
  }

  if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
    resetBBox(lineBBox);

    var _iterator16 = _createForOfIteratorHelper(tileLines),
        _step16;

    try {
      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
        var line = _step16.value;

        var _iterator17 = _createForOfIteratorHelper(line),
            _step17;

        try {
          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
            var p = _step17.value;
            updatePoint(p, lineBBox, polyBBox, worldSize);
          }
        } catch (err) {
          _iterator17.e(err);
        } finally {
          _iterator17.f();
        }
      }
    } catch (err) {
      _iterator16.e(err);
    } finally {
      _iterator16.f();
    }
  }

  return tileLines;
}

function pointsWithinPolygons(ctx, polygonGeometry) {
  var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];
  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
  var canonical = ctx.canonicalID();

  if (polygonGeometry.type === 'Polygon') {
    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
    var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
    if (!boxWithinBox(pointBBox, polyBBox)) return false;

    var _iterator19 = _createForOfIteratorHelper(tilePoints),
        _step19;

    try {
      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
        var point = _step19.value;
        if (!pointWithinPolygon(point, tilePolygon)) return false;
      }
    } catch (err) {
      _iterator19.e(err);
    } finally {
      _iterator19.f();
    }
  }

  if (polygonGeometry.type === 'MultiPolygon') {
    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);

    var _tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);

    if (!boxWithinBox(pointBBox, polyBBox)) return false;

    var _iterator20 = _createForOfIteratorHelper(_tilePoints),
        _step20;

    try {
      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
        var _point = _step20.value;
        if (!pointWithinPolygons(_point, tilePolygons)) return false;
      }
    } catch (err) {
      _iterator20.e(err);
    } finally {
      _iterator20.f();
    }
  }

  return true;
}

function linesWithinPolygons(ctx, polygonGeometry) {
  var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];
  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
  var canonical = ctx.canonicalID();

  if (polygonGeometry.type === 'Polygon') {
    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
    var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
    if (!boxWithinBox(lineBBox, polyBBox)) return false;

    var _iterator21 = _createForOfIteratorHelper(tileLines),
        _step21;

    try {
      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
        var line = _step21.value;
        if (!lineStringWithinPolygon(line, tilePolygon)) return false;
      }
    } catch (err) {
      _iterator21.e(err);
    } finally {
      _iterator21.f();
    }
  }

  if (polygonGeometry.type === 'MultiPolygon') {
    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);

    var _tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);

    if (!boxWithinBox(lineBBox, polyBBox)) return false;

    var _iterator22 = _createForOfIteratorHelper(_tileLines),
        _step22;

    try {
      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
        var _line2 = _step22.value;
        if (!lineStringWithinPolygons(_line2, tilePolygons)) return false;
      }
    } catch (err) {
      _iterator22.e(err);
    } finally {
      _iterator22.f();
    }
  }

  return true;
}

var Within = /*#__PURE__*/function () {
  function Within(geojson, geometries) {
    _classCallCheck(this, Within);

    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
  }

  _createClass(Within, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      if (ctx.geometry() != null && ctx.canonicalID() != null) {
        if (ctx.geometryType() === 'Point') {
          return pointsWithinPolygons(ctx, this.geometries);
        } else if (ctx.geometryType() === 'LineString') {
          return linesWithinPolygons(ctx, this.geometries);
        }
      }

      return false;
    }
  }, {
    key: "eachChild",
    value: function eachChild() {}
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return true;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return ['within', this.geojson];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 2) return context.error("'within' expression requires exactly one argument, but found ".concat(args.length - 1, " instead."));

      if (isValue(args[1])) {
        var geojson = args[1];

        if (geojson.type === 'FeatureCollection') {
          for (var i = 0; i < geojson.features.length; ++i) {
            var type = geojson.features[i].geometry.type;

            if (type === 'Polygon' || type === 'MultiPolygon') {
              return new Within(geojson, geojson.features[i].geometry);
            }
          }
        } else if (geojson.type === 'Feature') {
          var _type2 = geojson.geometry.type;

          if (_type2 === 'Polygon' || _type2 === 'MultiPolygon') {
            return new Within(geojson, geojson.geometry);
          }
        } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
          return new Within(geojson, geojson);
        }
      }

      return context.error("'within' expression requires valid geojson object that contains polygon geometry type.");
    }
  }]);

  return Within;
}();

function isFeatureConstant(e) {
  if (e instanceof CompoundExpression) {
    if (e.name === 'get' && e.args.length === 1) {
      return false;
    } else if (e.name === 'feature-state') {
      return false;
    } else if (e.name === 'has' && e.args.length === 1) {
      return false;
    } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
      return false;
    } else if (/^filter-/.test(e.name)) {
      return false;
    }
  }

  if (e instanceof Within) {
    return false;
  }

  var result = true;
  e.eachChild(function (arg) {
    if (result && !isFeatureConstant(arg)) {
      result = false;
    }
  });
  return result;
}

function isStateConstant(e) {
  if (e instanceof CompoundExpression) {
    if (e.name === 'feature-state') {
      return false;
    }
  }

  var result = true;
  e.eachChild(function (arg) {
    if (result && !isStateConstant(arg)) {
      result = false;
    }
  });
  return result;
}

function isGlobalPropertyConstant(e, properties) {
  if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
    return false;
  }

  var result = true;
  e.eachChild(function (arg) {
    if (result && !isGlobalPropertyConstant(arg, properties)) {
      result = false;
    }
  });
  return result;
}

var Var = /*#__PURE__*/function () {
  function Var(name, boundExpression) {
    _classCallCheck(this, Var);

    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
  }

  _createClass(Var, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      return this.boundExpression.evaluate(ctx);
    }
  }, {
    key: "eachChild",
    value: function eachChild() {}
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return ['var', this.name];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 2 || typeof args[1] !== 'string') return context.error("'var' expression requires exactly one string literal argument.");
      var name = args[1];

      if (!context.scope.has(name)) {
        return context.error("Unknown variable \"".concat(name, "\". Make sure \"").concat(name, "\" has been bound in an enclosing \"let\" expression before using it."), 1);
      }

      return new Var(name, context.scope.get(name));
    }
  }]);

  return Var;
}();

var ParsingContext = /*#__PURE__*/function () {
  function ParsingContext(registry) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var expectedType = arguments.length > 2 ? arguments[2] : undefined;
    var scope = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Scope();
    var errors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

    _classCallCheck(this, ParsingContext);

    this.registry = registry;
    this.path = path;
    this.key = path.map(function (part) {
      return "[".concat(part, "]");
    }).join('');
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
  }

  _createClass(ParsingContext, [{
    key: "parse",
    value: function parse(expr, index, expectedType, bindings) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      if (index) {
        return this.concat(index, expectedType, bindings)._parse(expr, options);
      }

      return this._parse(expr, options);
    }
  }, {
    key: "_parse",
    value: function _parse(expr, options) {
      if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
        expr = ['literal', expr];
      }

      function annotate(parsed, type, typeAnnotation) {
        if (typeAnnotation === 'assert') {
          return new Assertion(type, [parsed]);
        } else if (typeAnnotation === 'coerce') {
          return new Coercion(type, [parsed]);
        } else {
          return parsed;
        }
      }

      if (Array.isArray(expr)) {
        if (expr.length === 0) {
          return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
        }

        var op = expr[0];

        if (typeof op !== 'string') {
          this.error("Expression name must be a string, but found ".concat(_typeof(op), " instead. If you wanted a literal array, use [\"literal\", [...]]."), 0);
          return null;
        }

        var Expr = this.registry[op];

        if (Expr) {
          var parsed = Expr.parse(expr, this);
          if (!parsed) return null;

          if (this.expectedType) {
            var expected = this.expectedType;
            var actual = parsed.type;

            if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
              parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
            } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
              parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
            } else if (this.checkSubtype(expected, actual)) {
              return null;
            }
          }

          if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
            var ec = new EvaluationContext();

            try {
              parsed = new Literal(parsed.type, parsed.evaluate(ec));
            } catch (e) {
              this.error(e.message);
              return null;
            }
          }

          return parsed;
        }

        return this.error("Unknown expression \"".concat(op, "\". If you wanted a literal array, use [\"literal\", [...]]."), 0);
      } else if (typeof expr === 'undefined') {
        return this.error("'undefined' value invalid. Use null instead.");
      } else if (_typeof(expr) === 'object') {
        return this.error("Bare objects invalid. Use [\"literal\", {...}] instead.");
      } else {
        return this.error("Expected an array, but found ".concat(_typeof(expr), " instead."));
      }
    }
  }, {
    key: "concat",
    value: function concat(index, expectedType, bindings) {
      var path = typeof index === 'number' ? this.path.concat(index) : this.path;
      var scope = bindings ? this.scope.concat(bindings) : this.scope;
      return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
    }
  }, {
    key: "error",
    value: function error(_error3) {
      for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key4 = 1; _key4 < _len2; _key4++) {
        keys[_key4 - 1] = arguments[_key4];
      }

      var key = "".concat(this.key).concat(keys.map(function (k) {
        return "[".concat(k, "]");
      }).join(''));
      this.errors.push(new ParsingError(key, _error3));
    }
  }, {
    key: "checkSubtype",
    value: function checkSubtype(expected, t) {
      var error = _checkSubtype(expected, t);

      if (error) this.error(error);
      return error;
    }
  }]);

  return ParsingContext;
}();

function isConstant(expression) {
  if (expression instanceof Var) {
    return isConstant(expression.boundExpression);
  } else if (expression instanceof CompoundExpression && expression.name === 'error') {
    return false;
  } else if (expression instanceof CollatorExpression) {
    return false;
  } else if (expression instanceof Within) {
    return false;
  }

  var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
  var childrenConstant = true;
  expression.eachChild(function (child) {
    if (isTypeAnnotation) {
      childrenConstant = childrenConstant && isConstant(child);
    } else {
      childrenConstant = childrenConstant && child instanceof Literal;
    }
  });

  if (!childrenConstant) {
    return false;
  }

  return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'sky-radial-progress', 'accumulated', 'is-supported-script']);
}

function findStopLessThanOrEqualTo(stops, input) {
  var lastIndex = stops.length - 1;
  var lowerIndex = 0;
  var upperIndex = lastIndex;
  var currentIndex = 0;
  var currentValue, nextValue;

  while (lowerIndex <= upperIndex) {
    currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
    currentValue = stops[currentIndex];
    nextValue = stops[currentIndex + 1];

    if (currentValue <= input) {
      if (currentIndex === lastIndex || input < nextValue) {
        return currentIndex;
      }

      lowerIndex = currentIndex + 1;
    } else if (currentValue > input) {
      upperIndex = currentIndex - 1;
    } else {
      throw new RuntimeError('Input is not a number.');
    }
  }

  return 0;
}

var Step = /*#__PURE__*/function () {
  function Step(type, input, stops) {
    _classCallCheck(this, Step);

    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];

    var _iterator23 = _createForOfIteratorHelper(stops),
        _step23;

    try {
      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
        var _step23$value = _slicedToArray(_step23.value, 2),
            label = _step23$value[0],
            _expression2 = _step23$value[1];

        this.labels.push(label);
        this.outputs.push(_expression2);
      }
    } catch (err) {
      _iterator23.e(err);
    } finally {
      _iterator23.f();
    }
  }

  _createClass(Step, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var labels = this.labels;
      var outputs = this.outputs;

      if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
      }

      var value = this.input.evaluate(ctx);

      if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
      }

      var stopCount = labels.length;

      if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
      }

      var index = findStopLessThanOrEqualTo(labels, value);
      return outputs[index].evaluate(ctx);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.input);

      var _iterator24 = _createForOfIteratorHelper(this.outputs),
          _step24;

      try {
        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
          var _expression3 = _step24.value;
          fn(_expression3);
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.outputs.every(function (out) {
        return out.outputDefined();
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serialized = ['step', this.input.serialize()];

      for (var i = 0; i < this.labels.length; i++) {
        if (i > 0) {
          serialized.push(this.labels[i]);
        }

        serialized.push(this.outputs[i].serialize());
      }

      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length - 1 < 4) {
        return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));
      }

      if ((args.length - 1) % 2 !== 0) {
        return context.error("Expected an even number of arguments.");
      }

      var input = context.parse(args[1], 1, NumberType);
      if (!input) return null;
      var stops = [];
      var outputType = null;

      if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
      }

      for (var i = 1; i < args.length; i += 2) {
        var label = i === 1 ? -Infinity : args[i];
        var value = args[i + 1];
        var labelKey = i;
        var valueKey = i + 1;

        if (typeof label !== 'number') {
          return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }

        if (stops.length && stops[stops.length - 1][0] >= label) {
          return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }

        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) return null;
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
      }

      return new Step(outputType, input, stops);
    }
  }]);

  return Step;
}();
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */


var unitbezier = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
  // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
  this.cx = 3.0 * p1x;
  this.bx = 3.0 * (p2x - p1x) - this.cx;
  this.ax = 1.0 - this.cx - this.bx;
  this.cy = 3.0 * p1y;
  this.by = 3.0 * (p2y - p1y) - this.cy;
  this.ay = 1.0 - this.cy - this.by;
  this.p1x = p1x;
  this.p1y = p2y;
  this.p2x = p2x;
  this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function (t) {
  // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
  return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function (t) {
  return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
  return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function (x, epsilon) {
  if (typeof epsilon === 'undefined') epsilon = 1e-6;
  var t0, t1, t2, x2, i; // First try a few iterations of Newton's method -- normally very fast.

  for (t2 = x, i = 0; i < 8; i++) {
    x2 = this.sampleCurveX(t2) - x;
    if (Math.abs(x2) < epsilon) return t2;
    var d2 = this.sampleCurveDerivativeX(t2);
    if (Math.abs(d2) < 1e-6) break;
    t2 = t2 - x2 / d2;
  } // Fall back to the bisection method for reliability.


  t0 = 0.0;
  t1 = 1.0;
  t2 = x;
  if (t2 < t0) return t0;
  if (t2 > t1) return t1;

  while (t0 < t1) {
    x2 = this.sampleCurveX(t2);
    if (Math.abs(x2 - x) < epsilon) return t2;

    if (x > x2) {
      t0 = t2;
    } else {
      t1 = t2;
    }

    t2 = (t1 - t0) * 0.5 + t0;
  } // Failure.


  return t2;
};

UnitBezier.prototype.solve = function (x, epsilon) {
  return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

function number(a, b, t) {
  return a * (1 - t) + b * t;
}

function color(from, to, t) {
  return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}

function array$1(from, to, t) {
  return from.map(function (d, i) {
    return number(d, to[i], t);
  });
}

var interpolate = /*#__PURE__*/Object.freeze({
  __proto__: null,
  number: number,
  color: color,
  array: array$1
});
var Xn = 0.95047,
    Yn = 1,
    Zn = 1.08883,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1,
    deg2rad = Math.PI / 180,
    rad2deg = 180 / Math.PI;

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  x /= 255;
  return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function rgbToLab(rgbColor) {
  var b = rgb2xyz(rgbColor.r),
      a = rgb2xyz(rgbColor.g),
      l = rgb2xyz(rgbColor.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
  return {
    l: 116 * y - 16,
    a: 500 * (x - y),
    b: 200 * (y - z),
    alpha: rgbColor.a
  };
}

function labToRgb(labColor) {
  var y = (labColor.l + 16) / 116,
      x = isNaN(labColor.a) ? y : y + labColor.a / 500,
      z = isNaN(labColor.b) ? y : y - labColor.b / 200;
  y = Yn * lab2xyz(y);
  x = Xn * lab2xyz(x);
  z = Zn * lab2xyz(z);
  return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}

function interpolateLab(from, to, t) {
  return {
    l: number(from.l, to.l, t),
    a: number(from.a, to.a, t),
    b: number(from.b, to.b, t),
    alpha: number(from.alpha, to.alpha, t)
  };
}

function rgbToHcl(rgbColor) {
  var _rgbToLab = rgbToLab(rgbColor),
      l = _rgbToLab.l,
      a = _rgbToLab.a,
      b = _rgbToLab.b;

  var h = Math.atan2(b, a) * rad2deg;
  return {
    h: h < 0 ? h + 360 : h,
    c: Math.sqrt(a * a + b * b),
    l: l,
    alpha: rgbColor.a
  };
}

function hclToRgb(hclColor) {
  var h = hclColor.h * deg2rad,
      c = hclColor.c,
      l = hclColor.l;
  return labToRgb({
    l: l,
    a: Math.cos(h) * c,
    b: Math.sin(h) * c,
    alpha: hclColor.alpha
  });
}

function interpolateHue(a, b, t) {
  var d = b - a;
  return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}

function interpolateHcl(from, to, t) {
  return {
    h: interpolateHue(from.h, to.h, t),
    c: number(from.c, to.c, t),
    l: number(from.l, to.l, t),
    alpha: number(from.alpha, to.alpha, t)
  };
}

var lab = {
  forward: rgbToLab,
  reverse: labToRgb,
  interpolate: interpolateLab
};
var hcl = {
  forward: rgbToHcl,
  reverse: hclToRgb,
  interpolate: interpolateHcl
};
var colorSpaces = /*#__PURE__*/Object.freeze({
  __proto__: null,
  lab: lab,
  hcl: hcl
});

var Interpolate = /*#__PURE__*/function () {
  function Interpolate(type, operator, interpolation, input, stops) {
    _classCallCheck(this, Interpolate);

    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];

    var _iterator25 = _createForOfIteratorHelper(stops),
        _step25;

    try {
      for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
        var _step25$value = _slicedToArray(_step25.value, 2),
            label = _step25$value[0],
            _expression4 = _step25$value[1];

        this.labels.push(label);
        this.outputs.push(_expression4);
      }
    } catch (err) {
      _iterator25.e(err);
    } finally {
      _iterator25.f();
    }
  }

  _createClass(Interpolate, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var labels = this.labels;
      var outputs = this.outputs;

      if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
      }

      var value = this.input.evaluate(ctx);

      if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
      }

      var stopCount = labels.length;

      if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
      }

      var index = findStopLessThanOrEqualTo(labels, value);
      var lower = labels[index];
      var upper = labels[index + 1];
      var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
      var outputLower = outputs[index].evaluate(ctx);
      var outputUpper = outputs[index + 1].evaluate(ctx);

      if (this.operator === 'interpolate') {
        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
      } else if (this.operator === 'interpolate-hcl') {
        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
      } else {
        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
      }
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.input);

      var _iterator26 = _createForOfIteratorHelper(this.outputs),
          _step26;

      try {
        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
          var _expression5 = _step26.value;
          fn(_expression5);
        }
      } catch (err) {
        _iterator26.e(err);
      } finally {
        _iterator26.f();
      }
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.outputs.every(function (out) {
        return out.outputDefined();
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var interpolation;

      if (this.interpolation.name === 'linear') {
        interpolation = ['linear'];
      } else if (this.interpolation.name === 'exponential') {
        if (this.interpolation.base === 1) {
          interpolation = ['linear'];
        } else {
          interpolation = ['exponential', this.interpolation.base];
        }
      } else {
        interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
      }

      var serialized = [this.operator, interpolation, this.input.serialize()];

      for (var i = 0; i < this.labels.length; i++) {
        serialized.push(this.labels[i], this.outputs[i].serialize());
      }

      return serialized;
    }
  }], [{
    key: "interpolationFactor",
    value: function interpolationFactor(interpolation, input, lower, upper) {
      var t = 0;

      if (interpolation.name === 'exponential') {
        t = exponentialInterpolation(input, interpolation.base, lower, upper);
      } else if (interpolation.name === 'linear') {
        t = exponentialInterpolation(input, 1, lower, upper);
      } else if (interpolation.name === 'cubic-bezier') {
        var c = interpolation.controlPoints;
        var ub = new unitbezier(c[0], c[1], c[2], c[3]);
        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
      }

      return t;
    }
  }, {
    key: "parse",
    value: function parse(args, context) {
      var _args = _toArray(args),
          operator = _args[0],
          interpolation = _args[1],
          input = _args[2],
          rest = _args.slice(3);

      if (!Array.isArray(interpolation) || interpolation.length === 0) {
        return context.error("Expected an interpolation type expression.", 1);
      }

      if (interpolation[0] === 'linear') {
        interpolation = {
          name: 'linear'
        };
      } else if (interpolation[0] === 'exponential') {
        var base = interpolation[1];
        if (typeof base !== 'number') return context.error("Exponential interpolation requires a numeric base.", 1, 1);
        interpolation = {
          name: 'exponential',
          base: base
        };
      } else if (interpolation[0] === 'cubic-bezier') {
        var controlPoints = interpolation.slice(1);

        if (controlPoints.length !== 4 || controlPoints.some(function (t) {
          return typeof t !== 'number' || t < 0 || t > 1;
        })) {
          return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
        }

        interpolation = {
          name: 'cubic-bezier',
          controlPoints: controlPoints
        };
      } else {
        return context.error("Unknown interpolation type ".concat(String(interpolation[0])), 1, 0);
      }

      if (args.length - 1 < 4) {
        return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));
      }

      if ((args.length - 1) % 2 !== 0) {
        return context.error("Expected an even number of arguments.");
      }

      input = context.parse(input, 2, NumberType);
      if (!input) return null;
      var stops = [];
      var outputType = null;

      if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
        outputType = ColorType;
      } else if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
      }

      for (var i = 0; i < rest.length; i += 2) {
        var label = rest[i];
        var value = rest[i + 1];
        var labelKey = i + 3;
        var valueKey = i + 4;

        if (typeof label !== 'number') {
          return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }

        if (stops.length && stops[stops.length - 1][0] >= label) {
          return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }

        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) return null;
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
      }

      if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
        return context.error("Type ".concat(toString(outputType), " is not interpolatable."));
      }

      return new Interpolate(outputType, operator, interpolation, input, stops);
    }
  }]);

  return Interpolate;
}();

function exponentialInterpolation(input, base, lowerValue, upperValue) {
  var difference = upperValue - lowerValue;
  var progress = input - lowerValue;

  if (difference === 0) {
    return 0;
  } else if (base === 1) {
    return progress / difference;
  } else {
    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
  }
}

var Coalesce = /*#__PURE__*/function () {
  function Coalesce(type, args) {
    _classCallCheck(this, Coalesce);

    this.type = type;
    this.args = args;
  }

  _createClass(Coalesce, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var result = null;
      var argCount = 0;
      var requestedImageName;

      var _iterator27 = _createForOfIteratorHelper(this.args),
          _step27;

      try {
        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
          var arg = _step27.value;
          argCount++;
          result = arg.evaluate(ctx);

          if (result && result instanceof ResolvedImage && !result.available) {
            if (!requestedImageName) {
              requestedImageName = result.name;
            }

            result = null;

            if (argCount === this.args.length) {
              result = requestedImageName;
            }
          }

          if (result !== null) break;
        }
      } catch (err) {
        _iterator27.e(err);
      } finally {
        _iterator27.f();
      }

      return result;
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      this.args.forEach(fn);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.args.every(function (arg) {
        return arg.outputDefined();
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serialized = ['coalesce'];
      this.eachChild(function (child) {
        serialized.push(child.serialize());
      });
      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length < 2) {
        return context.error('Expectected at least one argument.');
      }

      var outputType = null;
      var expectedType = context.expectedType;

      if (expectedType && expectedType.kind !== 'value') {
        outputType = expectedType;
      }

      var parsedArgs = [];

      var _iterator28 = _createForOfIteratorHelper(args.slice(1)),
          _step28;

      try {
        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
          var arg = _step28.value;
          var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, {
            typeAnnotation: 'omit'
          });
          if (!parsed) return null;
          outputType = outputType || parsed.type;
          parsedArgs.push(parsed);
        }
      } catch (err) {
        _iterator28.e(err);
      } finally {
        _iterator28.f();
      }

      var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
        return _checkSubtype(expectedType, arg.type);
      });
      return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
    }
  }]);

  return Coalesce;
}();

var Let = /*#__PURE__*/function () {
  function Let(bindings, result) {
    _classCallCheck(this, Let);

    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
  }

  _createClass(Let, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      return this.result.evaluate(ctx);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      var _iterator29 = _createForOfIteratorHelper(this.bindings),
          _step29;

      try {
        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
          var binding = _step29.value;
          fn(binding[1]);
        }
      } catch (err) {
        _iterator29.e(err);
      } finally {
        _iterator29.f();
      }

      fn(this.result);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.result.outputDefined();
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serialized = ['let'];

      var _iterator30 = _createForOfIteratorHelper(this.bindings),
          _step30;

      try {
        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
          var _step30$value = _slicedToArray(_step30.value, 2),
              name = _step30$value[0],
              expr = _step30$value[1];

          serialized.push(name, expr.serialize());
        }
      } catch (err) {
        _iterator30.e(err);
      } finally {
        _iterator30.f();
      }

      serialized.push(this.result.serialize());
      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length < 4) return context.error("Expected at least 3 arguments, but found ".concat(args.length - 1, " instead."));
      var bindings = [];

      for (var i = 1; i < args.length - 1; i += 2) {
        var name = args[i];

        if (typeof name !== 'string') {
          return context.error("Expected string, but found ".concat(_typeof(name), " instead."), i);
        }

        if (/[^a-zA-Z0-9_]/.test(name)) {
          return context.error("Variable names must contain only alphanumeric characters or '_'.", i);
        }

        var value = context.parse(args[i + 1], i + 1);
        if (!value) return null;
        bindings.push([name, value]);
      }

      var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
      if (!result) return null;
      return new Let(bindings, result);
    }
  }]);

  return Let;
}();

var At = /*#__PURE__*/function () {
  function At(type, index, input) {
    _classCallCheck(this, At);

    this.type = type;
    this.index = index;
    this.input = input;
  }

  _createClass(At, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var index = this.index.evaluate(ctx);
      var array = this.input.evaluate(ctx);

      if (index < 0) {
        throw new RuntimeError("Array index out of bounds: ".concat(index, " < 0."));
      }

      if (index >= array.length) {
        throw new RuntimeError("Array index out of bounds: ".concat(index, " > ").concat(array.length - 1, "."));
      }

      if (index !== Math.floor(index)) {
        throw new RuntimeError("Array index must be an integer, but found ".concat(index, " instead."));
      }

      return array[index];
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.index);
      fn(this.input);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return ['at', this.index.serialize(), this.input.serialize()];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 3) return context.error("Expected 2 arguments, but found ".concat(args.length - 1, " instead."));
      var index = context.parse(args[1], 1, NumberType);
      var input = context.parse(args[2], 2, array(context.expectedType || ValueType));
      if (!index || !input) return null;
      var t = input.type;
      return new At(t.itemType, index, input);
    }
  }]);

  return At;
}();

var In = /*#__PURE__*/function () {
  function In(needle, haystack) {
    _classCallCheck(this, In);

    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
  }

  _createClass(In, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var needle = this.needle.evaluate(ctx);
      var haystack = this.haystack.evaluate(ctx);
      if (!haystack) return false;

      if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(typeOf(needle)), " instead."));
      }

      if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError("Expected second argument to be of type array or string, but found ".concat(toString(typeOf(haystack)), " instead."));
      }

      return haystack.indexOf(needle) >= 0;
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.needle);
      fn(this.haystack);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return true;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return ['in', this.needle.serialize(), this.haystack.serialize()];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 3) {
        return context.error("Expected 2 arguments, but found ".concat(args.length - 1, " instead."));
      }

      var needle = context.parse(args[1], 1, ValueType);
      var haystack = context.parse(args[2], 2, ValueType);
      if (!needle || !haystack) return null;

      if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(needle.type), " instead"));
      }

      return new In(needle, haystack);
    }
  }]);

  return In;
}();

var IndexOf = /*#__PURE__*/function () {
  function IndexOf(needle, haystack, fromIndex) {
    _classCallCheck(this, IndexOf);

    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
  }

  _createClass(IndexOf, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var needle = this.needle.evaluate(ctx);
      var haystack = this.haystack.evaluate(ctx);

      if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(typeOf(needle)), " instead."));
      }

      if (!isValidNativeType(haystack, ['string', 'array'])) {
        throw new RuntimeError("Expected second argument to be of type array or string, but found ".concat(toString(typeOf(haystack)), " instead."));
      }

      if (this.fromIndex) {
        var fromIndex = this.fromIndex.evaluate(ctx);
        return haystack.indexOf(needle, fromIndex);
      }

      return haystack.indexOf(needle);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.needle);
      fn(this.haystack);

      if (this.fromIndex) {
        fn(this.fromIndex);
      }
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      if (this.fromIndex != null && this.fromIndex !== undefined) {
        var fromIndex = this.fromIndex.serialize();
        return ['index-of', this.needle.serialize(), this.haystack.serialize(), fromIndex];
      }

      return ['index-of', this.needle.serialize(), this.haystack.serialize()];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length <= 2 || args.length >= 5) {
        return context.error("Expected 3 or 4 arguments, but found ".concat(args.length - 1, " instead."));
      }

      var needle = context.parse(args[1], 1, ValueType);
      var haystack = context.parse(args[2], 2, ValueType);
      if (!needle || !haystack) return null;

      if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
        return context.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(needle.type), " instead"));
      }

      if (args.length === 4) {
        var fromIndex = context.parse(args[3], 3, NumberType);
        if (!fromIndex) return null;
        return new IndexOf(needle, haystack, fromIndex);
      } else {
        return new IndexOf(needle, haystack);
      }
    }
  }]);

  return IndexOf;
}();

var Match = /*#__PURE__*/function () {
  function Match(inputType, outputType, input, cases, outputs, otherwise) {
    _classCallCheck(this, Match);

    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
  }

  _createClass(Match, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var input = this.input.evaluate(ctx);
      var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
      return output.evaluate(ctx);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.input);
      this.outputs.forEach(fn);
      fn(this.otherwise);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.outputs.every(function (out) {
        return out.outputDefined();
      }) && this.otherwise.outputDefined();
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var _this2 = this;

      var serialized = ['match', this.input.serialize()];
      var sortedLabels = Object.keys(this.cases).sort();
      var groupedByOutput = [];
      var outputLookup = {};

      var _iterator31 = _createForOfIteratorHelper(sortedLabels),
          _step31;

      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
          var label = _step31.value;
          var _outputIndex = outputLookup[this.cases[label]];

          if (_outputIndex === undefined) {
            outputLookup[this.cases[label]] = groupedByOutput.length;
            groupedByOutput.push([this.cases[label], [label]]);
          } else {
            groupedByOutput[_outputIndex][1].push(label);
          }
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }

      var coerceLabel = function coerceLabel(label) {
        return _this2.inputType.kind === 'number' ? Number(label) : label;
      };

      for (var _i6 = 0, _groupedByOutput = groupedByOutput; _i6 < _groupedByOutput.length; _i6++) {
        var _groupedByOutput$_i = _slicedToArray(_groupedByOutput[_i6], 2),
            outputIndex = _groupedByOutput$_i[0],
            labels = _groupedByOutput$_i[1];

        if (labels.length === 1) {
          serialized.push(coerceLabel(labels[0]));
        } else {
          serialized.push(labels.map(coerceLabel));
        }

        serialized.push(this.outputs[outputIndex].serialize());
      }

      serialized.push(this.otherwise.serialize());
      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length < 5) return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));
      if (args.length % 2 !== 1) return context.error("Expected an even number of arguments.");
      var inputType;
      var outputType;

      if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
      }

      var cases = {};
      var outputs = [];

      for (var i = 2; i < args.length - 1; i += 2) {
        var labels = args[i];
        var value = args[i + 1];

        if (!Array.isArray(labels)) {
          labels = [labels];
        }

        var labelContext = context.concat(i);

        if (labels.length === 0) {
          return labelContext.error('Expected at least one branch label.');
        }

        var _iterator32 = _createForOfIteratorHelper(labels),
            _step32;

        try {
          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
            var label = _step32.value;

            if (typeof label !== 'number' && typeof label !== 'string') {
              return labelContext.error("Branch labels must be numbers or strings.");
            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
              return labelContext.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
            } else if (typeof label === 'number' && Math.floor(label) !== label) {
              return labelContext.error("Numeric branch labels must be integer values.");
            } else if (!inputType) {
              inputType = typeOf(label);
            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
              return null;
            }

            if (typeof cases[String(label)] !== 'undefined') {
              return labelContext.error('Branch labels must be unique.');
            }

            cases[String(label)] = outputs.length;
          }
        } catch (err) {
          _iterator32.e(err);
        } finally {
          _iterator32.f();
        }

        var result = context.parse(value, i, outputType);
        if (!result) return null;
        outputType = outputType || result.type;
        outputs.push(result);
      }

      var input = context.parse(args[1], 1, ValueType);
      if (!input) return null;
      var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
      if (!otherwise) return null;

      if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
        return null;
      }

      return new Match(inputType, outputType, input, cases, outputs, otherwise);
    }
  }]);

  return Match;
}();

var Case = /*#__PURE__*/function () {
  function Case(type, branches, otherwise) {
    _classCallCheck(this, Case);

    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
  }

  _createClass(Case, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var _iterator33 = _createForOfIteratorHelper(this.branches),
          _step33;

      try {
        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
          var _step33$value = _slicedToArray(_step33.value, 2),
              test = _step33$value[0],
              _expression6 = _step33$value[1];

          if (test.evaluate(ctx)) {
            return _expression6.evaluate(ctx);
          }
        }
      } catch (err) {
        _iterator33.e(err);
      } finally {
        _iterator33.f();
      }

      return this.otherwise.evaluate(ctx);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      var _iterator34 = _createForOfIteratorHelper(this.branches),
          _step34;

      try {
        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
          var _step34$value = _slicedToArray(_step34.value, 2),
              test = _step34$value[0],
              _expression7 = _step34$value[1];

          fn(test);
          fn(_expression7);
        }
      } catch (err) {
        _iterator34.e(err);
      } finally {
        _iterator34.f();
      }

      fn(this.otherwise);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return this.branches.every(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            _ = _ref6[0],
            out = _ref6[1];

        return out.outputDefined();
      }) && this.otherwise.outputDefined();
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serialized = ['case'];
      this.eachChild(function (child) {
        serialized.push(child.serialize());
      });
      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length < 4) return context.error("Expected at least 3 arguments, but found only ".concat(args.length - 1, "."));
      if (args.length % 2 !== 0) return context.error("Expected an odd number of arguments.");
      var outputType;

      if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
      }

      var branches = [];

      for (var i = 1; i < args.length - 1; i += 2) {
        var test = context.parse(args[i], i, BooleanType);
        if (!test) return null;
        var result = context.parse(args[i + 1], i + 1, outputType);
        if (!result) return null;
        branches.push([test, result]);
        outputType = outputType || result.type;
      }

      var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
      if (!otherwise) return null;
      return new Case(outputType, branches, otherwise);
    }
  }]);

  return Case;
}();

var Slice = /*#__PURE__*/function () {
  function Slice(type, input, beginIndex, endIndex) {
    _classCallCheck(this, Slice);

    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
  }

  _createClass(Slice, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var input = this.input.evaluate(ctx);
      var beginIndex = this.beginIndex.evaluate(ctx);

      if (!isValidNativeType(input, ['string', 'array'])) {
        throw new RuntimeError("Expected first argument to be of type array or string, but found ".concat(toString(typeOf(input)), " instead."));
      }

      if (this.endIndex) {
        var endIndex = this.endIndex.evaluate(ctx);
        return input.slice(beginIndex, endIndex);
      }

      return input.slice(beginIndex);
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.input);
      fn(this.beginIndex);

      if (this.endIndex) {
        fn(this.endIndex);
      }
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      if (this.endIndex != null && this.endIndex !== undefined) {
        var endIndex = this.endIndex.serialize();
        return ['slice', this.input.serialize(), this.beginIndex.serialize(), endIndex];
      }

      return ['slice', this.input.serialize(), this.beginIndex.serialize()];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length <= 2 || args.length >= 5) {
        return context.error("Expected 3 or 4 arguments, but found ".concat(args.length - 1, " instead."));
      }

      var input = context.parse(args[1], 1, ValueType);
      var beginIndex = context.parse(args[2], 2, NumberType);
      if (!input || !beginIndex) return null;

      if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {
        return context.error("Expected first argument to be of type array or string, but found ".concat(toString(input.type), " instead"));
      }

      if (args.length === 4) {
        var endIndex = context.parse(args[3], 3, NumberType);
        if (!endIndex) return null;
        return new Slice(input.type, input, beginIndex, endIndex);
      } else {
        return new Slice(input.type, input, beginIndex);
      }
    }
  }]);

  return Slice;
}();

function isComparableType(op, type) {
  if (op === '==' || op === '!=') {
    return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
  } else {
    return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
  }
}

function eq(ctx, a, b) {
  return a === b;
}

function neq(ctx, a, b) {
  return a !== b;
}

function lt(ctx, a, b) {
  return a < b;
}

function gt(ctx, a, b) {
  return a > b;
}

function lteq(ctx, a, b) {
  return a <= b;
}

function gteq(ctx, a, b) {
  return a >= b;
}

function eqCollate(ctx, a, b, c) {
  return c.compare(a, b) === 0;
}

function neqCollate(ctx, a, b, c) {
  return !eqCollate(ctx, a, b, c);
}

function ltCollate(ctx, a, b, c) {
  return c.compare(a, b) < 0;
}

function gtCollate(ctx, a, b, c) {
  return c.compare(a, b) > 0;
}

function lteqCollate(ctx, a, b, c) {
  return c.compare(a, b) <= 0;
}

function gteqCollate(ctx, a, b, c) {
  return c.compare(a, b) >= 0;
}

function makeComparison(op, compareBasic, compareWithCollator) {
  var isOrderComparison = op !== '==' && op !== '!=';
  return /*#__PURE__*/function () {
    function Comparison(lhs, rhs, collator) {
      _classCallCheck(this, Comparison);

      this.type = BooleanType;
      this.lhs = lhs;
      this.rhs = rhs;
      this.collator = collator;
      this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
    }

    _createClass(Comparison, [{
      key: "evaluate",
      value: function evaluate(ctx) {
        var lhs = this.lhs.evaluate(ctx);
        var rhs = this.rhs.evaluate(ctx);

        if (isOrderComparison && this.hasUntypedArgument) {
          var _lt = typeOf(lhs);

          var rt = typeOf(rhs);

          if (_lt.kind !== rt.kind || !(_lt.kind === 'string' || _lt.kind === 'number')) {
            throw new RuntimeError("Expected arguments for \"".concat(op, "\" to be (string, string) or (number, number), but found (").concat(_lt.kind, ", ").concat(rt.kind, ") instead."));
          }
        }

        if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
          var _lt2 = typeOf(lhs);

          var _rt = typeOf(rhs);

          if (_lt2.kind !== 'string' || _rt.kind !== 'string') {
            return compareBasic(ctx, lhs, rhs);
          }
        }

        return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
      }
    }, {
      key: "eachChild",
      value: function eachChild(fn) {
        fn(this.lhs);
        fn(this.rhs);

        if (this.collator) {
          fn(this.collator);
        }
      }
    }, {
      key: "outputDefined",
      value: function outputDefined() {
        return true;
      }
    }, {
      key: "serialize",
      value: function serialize() {
        var serialized = [op];
        this.eachChild(function (child) {
          serialized.push(child.serialize());
        });
        return serialized;
      }
    }], [{
      key: "parse",
      value: function parse(args, context) {
        if (args.length !== 3 && args.length !== 4) return context.error("Expected two or three arguments.");
        var op = args[0];
        var lhs = context.parse(args[1], 1, ValueType);
        if (!lhs) return null;

        if (!isComparableType(op, lhs.type)) {
          return context.concat(1).error("\"".concat(op, "\" comparisons are not supported for type '").concat(toString(lhs.type), "'."));
        }

        var rhs = context.parse(args[2], 2, ValueType);
        if (!rhs) return null;

        if (!isComparableType(op, rhs.type)) {
          return context.concat(2).error("\"".concat(op, "\" comparisons are not supported for type '").concat(toString(rhs.type), "'."));
        }

        if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
          return context.error("Cannot compare types '".concat(toString(lhs.type), "' and '").concat(toString(rhs.type), "'."));
        }

        if (isOrderComparison) {
          if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
            lhs = new Assertion(rhs.type, [lhs]);
          } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
            rhs = new Assertion(lhs.type, [rhs]);
          }
        }

        var collator = null;

        if (args.length === 4) {
          if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
            return context.error("Cannot use collator to compare non-string types.");
          }

          collator = context.parse(args[3], 3, CollatorType);
          if (!collator) return null;
        }

        return new Comparison(lhs, rhs, collator);
      }
    }]);

    return Comparison;
  }();
}

var Equals = makeComparison('==', eq, eqCollate);
var NotEquals = makeComparison('!=', neq, neqCollate);
var LessThan = makeComparison('<', lt, ltCollate);
var GreaterThan = makeComparison('>', gt, gtCollate);
var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

var NumberFormat = /*#__PURE__*/function () {
  function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
    _classCallCheck(this, NumberFormat);

    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
  }

  _createClass(NumberFormat, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
        style: this.currency ? 'currency' : 'decimal',
        currency: this.currency ? this.currency.evaluate(ctx) : undefined,
        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
      }).format(this.number.evaluate(ctx));
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.number);

      if (this.locale) {
        fn(this.locale);
      }

      if (this.currency) {
        fn(this.currency);
      }

      if (this.minFractionDigits) {
        fn(this.minFractionDigits);
      }

      if (this.maxFractionDigits) {
        fn(this.maxFractionDigits);
      }
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var options = {};

      if (this.locale) {
        options['locale'] = this.locale.serialize();
      }

      if (this.currency) {
        options['currency'] = this.currency.serialize();
      }

      if (this.minFractionDigits) {
        options['min-fraction-digits'] = this.minFractionDigits.serialize();
      }

      if (this.maxFractionDigits) {
        options['max-fraction-digits'] = this.maxFractionDigits.serialize();
      }

      return ['number-format', this.number.serialize(), options];
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 3) return context.error("Expected two arguments.");
      var number = context.parse(args[1], 1, NumberType);
      if (!number) return null;
      var options = args[2];
      if (_typeof(options) !== 'object' || Array.isArray(options)) return context.error("NumberFormat options argument must be an object.");
      var locale = null;

      if (options['locale']) {
        locale = context.parse(options['locale'], 1, StringType);
        if (!locale) return null;
      }

      var currency = null;

      if (options['currency']) {
        currency = context.parse(options['currency'], 1, StringType);
        if (!currency) return null;
      }

      var minFractionDigits = null;

      if (options['min-fraction-digits']) {
        minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
        if (!minFractionDigits) return null;
      }

      var maxFractionDigits = null;

      if (options['max-fraction-digits']) {
        maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
        if (!maxFractionDigits) return null;
      }

      return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
    }
  }]);

  return NumberFormat;
}();

var Length = /*#__PURE__*/function () {
  function Length(input) {
    _classCallCheck(this, Length);

    this.type = NumberType;
    this.input = input;
  }

  _createClass(Length, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var input = this.input.evaluate(ctx);

      if (typeof input === 'string') {
        return input.length;
      } else if (Array.isArray(input)) {
        return input.length;
      } else {
        throw new RuntimeError("Expected value to be of type string or array, but found ".concat(toString(typeOf(input)), " instead."));
      }
    }
  }, {
    key: "eachChild",
    value: function eachChild(fn) {
      fn(this.input);
    }
  }, {
    key: "outputDefined",
    value: function outputDefined() {
      return false;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serialized = ['length'];
      this.eachChild(function (child) {
        serialized.push(child.serialize());
      });
      return serialized;
    }
  }], [{
    key: "parse",
    value: function parse(args, context) {
      if (args.length !== 2) return context.error("Expected 1 argument, but found ".concat(args.length - 1, " instead."));
      var input = context.parse(args[1], 1);
      if (!input) return null;
      if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') return context.error("Expected argument of type string or array, but found ".concat(toString(input.type), " instead."));
      return new Length(input);
    }
  }]);

  return Length;
}();

var expressions = {
  '==': Equals,
  '!=': NotEquals,
  '>': GreaterThan,
  '<': LessThan,
  '>=': GreaterThanOrEqual,
  '<=': LessThanOrEqual,
  'array': Assertion,
  'at': At,
  'boolean': Assertion,
  'case': Case,
  'coalesce': Coalesce,
  'collator': CollatorExpression,
  'format': FormatExpression,
  'image': ImageExpression,
  'in': In,
  'index-of': IndexOf,
  'interpolate': Interpolate,
  'interpolate-hcl': Interpolate,
  'interpolate-lab': Interpolate,
  'length': Length,
  'let': Let,
  'literal': Literal,
  'match': Match,
  'number': Assertion,
  'number-format': NumberFormat,
  'object': Assertion,
  'slice': Slice,
  'step': Step,
  'string': Assertion,
  'to-boolean': Coercion,
  'to-color': Coercion,
  'to-number': Coercion,
  'to-string': Coercion,
  'var': Var,
  'within': Within
};

function rgba(ctx, _ref7) {
  var _ref8 = _slicedToArray(_ref7, 4),
      r = _ref8[0],
      g = _ref8[1],
      b = _ref8[2],
      a = _ref8[3];

  r = r.evaluate(ctx);
  g = g.evaluate(ctx);
  b = b.evaluate(ctx);
  var alpha = a ? a.evaluate(ctx) : 1;
  var error = validateRGBA(r, g, b, alpha);
  if (error) throw new RuntimeError(error);
  return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}

function has(key, obj) {
  return key in obj;
}

function get(key, obj) {
  var v = obj[key];
  return typeof v === 'undefined' ? null : v;
}

function binarySearch(v, a, i, j) {
  while (i <= j) {
    var m = i + j >> 1;
    if (a[m] === v) return true;
    if (a[m] > v) j = m - 1;else i = m + 1;
  }

  return false;
}

function varargs(type) {
  return {
    type: type
  };
}

CompoundExpression.register(expressions, {
  'error': [ErrorType, [StringType], function (ctx, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
        v = _ref10[0];

    throw new RuntimeError(v.evaluate(ctx));
  }],
  'typeof': [StringType, [ValueType], function (ctx, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
        v = _ref12[0];

    return toString(typeOf(v.evaluate(ctx)));
  }],
  'to-rgba': [array(NumberType, 4), [ColorType], function (ctx, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 1),
        v = _ref14[0];

    return v.evaluate(ctx).toArray();
  }],
  'rgb': [ColorType, [NumberType, NumberType, NumberType], rgba],
  'rgba': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],
  'has': {
    type: BooleanType,
    overloads: [[[StringType], function (ctx, _ref15) {
      var _ref16 = _slicedToArray(_ref15, 1),
          key = _ref16[0];

      return has(key.evaluate(ctx), ctx.properties());
    }], [[StringType, ObjectType], function (ctx, _ref17) {
      var _ref18 = _slicedToArray(_ref17, 2),
          key = _ref18[0],
          obj = _ref18[1];

      return has(key.evaluate(ctx), obj.evaluate(ctx));
    }]]
  },
  'get': {
    type: ValueType,
    overloads: [[[StringType], function (ctx, _ref19) {
      var _ref20 = _slicedToArray(_ref19, 1),
          key = _ref20[0];

      return get(key.evaluate(ctx), ctx.properties());
    }], [[StringType, ObjectType], function (ctx, _ref21) {
      var _ref22 = _slicedToArray(_ref21, 2),
          key = _ref22[0],
          obj = _ref22[1];

      return get(key.evaluate(ctx), obj.evaluate(ctx));
    }]]
  },
  'feature-state': [ValueType, [StringType], function (ctx, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 1),
        key = _ref24[0];

    return get(key.evaluate(ctx), ctx.featureState || {});
  }],
  'properties': [ObjectType, [], function (ctx) {
    return ctx.properties();
  }],
  'geometry-type': [StringType, [], function (ctx) {
    return ctx.geometryType();
  }],
  'id': [ValueType, [], function (ctx) {
    return ctx.id();
  }],
  'zoom': [NumberType, [], function (ctx) {
    return ctx.globals.zoom;
  }],
  'heatmap-density': [NumberType, [], function (ctx) {
    return ctx.globals.heatmapDensity || 0;
  }],
  'line-progress': [NumberType, [], function (ctx) {
    return ctx.globals.lineProgress || 0;
  }],
  'sky-radial-progress': [NumberType, [], function (ctx) {
    return ctx.globals.skyRadialProgress || 0;
  }],
  'accumulated': [ValueType, [], function (ctx) {
    return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
  }],
  '+': [NumberType, varargs(NumberType), function (ctx, args) {
    var result = 0;

    var _iterator35 = _createForOfIteratorHelper(args),
        _step35;

    try {
      for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
        var arg = _step35.value;
        result += arg.evaluate(ctx);
      }
    } catch (err) {
      _iterator35.e(err);
    } finally {
      _iterator35.f();
    }

    return result;
  }],
  '*': [NumberType, varargs(NumberType), function (ctx, args) {
    var result = 1;

    var _iterator36 = _createForOfIteratorHelper(args),
        _step36;

    try {
      for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
        var arg = _step36.value;
        result *= arg.evaluate(ctx);
      }
    } catch (err) {
      _iterator36.e(err);
    } finally {
      _iterator36.f();
    }

    return result;
  }],
  '-': {
    type: NumberType,
    overloads: [[[NumberType, NumberType], function (ctx, _ref25) {
      var _ref26 = _slicedToArray(_ref25, 2),
          a = _ref26[0],
          b = _ref26[1];

      return a.evaluate(ctx) - b.evaluate(ctx);
    }], [[NumberType], function (ctx, _ref27) {
      var _ref28 = _slicedToArray(_ref27, 1),
          a = _ref28[0];

      return -a.evaluate(ctx);
    }]]
  },
  '/': [NumberType, [NumberType, NumberType], function (ctx, _ref29) {
    var _ref30 = _slicedToArray(_ref29, 2),
        a = _ref30[0],
        b = _ref30[1];

    return a.evaluate(ctx) / b.evaluate(ctx);
  }],
  '%': [NumberType, [NumberType, NumberType], function (ctx, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 2),
        a = _ref32[0],
        b = _ref32[1];

    return a.evaluate(ctx) % b.evaluate(ctx);
  }],
  'ln2': [NumberType, [], function () {
    return Math.LN2;
  }],
  'pi': [NumberType, [], function () {
    return Math.PI;
  }],
  'e': [NumberType, [], function () {
    return Math.E;
  }],
  '^': [NumberType, [NumberType, NumberType], function (ctx, _ref33) {
    var _ref34 = _slicedToArray(_ref33, 2),
        b = _ref34[0],
        e = _ref34[1];

    return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
  }],
  'sqrt': [NumberType, [NumberType], function (ctx, _ref35) {
    var _ref36 = _slicedToArray(_ref35, 1),
        x = _ref36[0];

    return Math.sqrt(x.evaluate(ctx));
  }],
  'log10': [NumberType, [NumberType], function (ctx, _ref37) {
    var _ref38 = _slicedToArray(_ref37, 1),
        n = _ref38[0];

    return Math.log(n.evaluate(ctx)) / Math.LN10;
  }],
  'ln': [NumberType, [NumberType], function (ctx, _ref39) {
    var _ref40 = _slicedToArray(_ref39, 1),
        n = _ref40[0];

    return Math.log(n.evaluate(ctx));
  }],
  'log2': [NumberType, [NumberType], function (ctx, _ref41) {
    var _ref42 = _slicedToArray(_ref41, 1),
        n = _ref42[0];

    return Math.log(n.evaluate(ctx)) / Math.LN2;
  }],
  'sin': [NumberType, [NumberType], function (ctx, _ref43) {
    var _ref44 = _slicedToArray(_ref43, 1),
        n = _ref44[0];

    return Math.sin(n.evaluate(ctx));
  }],
  'cos': [NumberType, [NumberType], function (ctx, _ref45) {
    var _ref46 = _slicedToArray(_ref45, 1),
        n = _ref46[0];

    return Math.cos(n.evaluate(ctx));
  }],
  'tan': [NumberType, [NumberType], function (ctx, _ref47) {
    var _ref48 = _slicedToArray(_ref47, 1),
        n = _ref48[0];

    return Math.tan(n.evaluate(ctx));
  }],
  'asin': [NumberType, [NumberType], function (ctx, _ref49) {
    var _ref50 = _slicedToArray(_ref49, 1),
        n = _ref50[0];

    return Math.asin(n.evaluate(ctx));
  }],
  'acos': [NumberType, [NumberType], function (ctx, _ref51) {
    var _ref52 = _slicedToArray(_ref51, 1),
        n = _ref52[0];

    return Math.acos(n.evaluate(ctx));
  }],
  'atan': [NumberType, [NumberType], function (ctx, _ref53) {
    var _ref54 = _slicedToArray(_ref53, 1),
        n = _ref54[0];

    return Math.atan(n.evaluate(ctx));
  }],
  'min': [NumberType, varargs(NumberType), function (ctx, args) {
    return Math.min.apply(Math, _toConsumableArray(args.map(function (arg) {
      return arg.evaluate(ctx);
    })));
  }],
  'max': [NumberType, varargs(NumberType), function (ctx, args) {
    return Math.max.apply(Math, _toConsumableArray(args.map(function (arg) {
      return arg.evaluate(ctx);
    })));
  }],
  'abs': [NumberType, [NumberType], function (ctx, _ref55) {
    var _ref56 = _slicedToArray(_ref55, 1),
        n = _ref56[0];

    return Math.abs(n.evaluate(ctx));
  }],
  'round': [NumberType, [NumberType], function (ctx, _ref57) {
    var _ref58 = _slicedToArray(_ref57, 1),
        n = _ref58[0];

    var v = n.evaluate(ctx);
    return v < 0 ? -Math.round(-v) : Math.round(v);
  }],
  'floor': [NumberType, [NumberType], function (ctx, _ref59) {
    var _ref60 = _slicedToArray(_ref59, 1),
        n = _ref60[0];

    return Math.floor(n.evaluate(ctx));
  }],
  'ceil': [NumberType, [NumberType], function (ctx, _ref61) {
    var _ref62 = _slicedToArray(_ref61, 1),
        n = _ref62[0];

    return Math.ceil(n.evaluate(ctx));
  }],
  'filter-==': [BooleanType, [StringType, ValueType], function (ctx, _ref63) {
    var _ref64 = _slicedToArray(_ref63, 2),
        k = _ref64[0],
        v = _ref64[1];

    return ctx.properties()[k.value] === v.value;
  }],
  'filter-id-==': [BooleanType, [ValueType], function (ctx, _ref65) {
    var _ref66 = _slicedToArray(_ref65, 1),
        v = _ref66[0];

    return ctx.id() === v.value;
  }],
  'filter-type-==': [BooleanType, [StringType], function (ctx, _ref67) {
    var _ref68 = _slicedToArray(_ref67, 1),
        v = _ref68[0];

    return ctx.geometryType() === v.value;
  }],
  'filter-<': [BooleanType, [StringType, ValueType], function (ctx, _ref69) {
    var _ref70 = _slicedToArray(_ref69, 2),
        k = _ref70[0],
        v = _ref70[1];

    var a = ctx.properties()[k.value];
    var b = v.value;
    return _typeof(a) === _typeof(b) && a < b;
  }],
  'filter-id-<': [BooleanType, [ValueType], function (ctx, _ref71) {
    var _ref72 = _slicedToArray(_ref71, 1),
        v = _ref72[0];

    var a = ctx.id();
    var b = v.value;
    return _typeof(a) === _typeof(b) && a < b;
  }],
  'filter->': [BooleanType, [StringType, ValueType], function (ctx, _ref73) {
    var _ref74 = _slicedToArray(_ref73, 2),
        k = _ref74[0],
        v = _ref74[1];

    var a = ctx.properties()[k.value];
    var b = v.value;
    return _typeof(a) === _typeof(b) && a > b;
  }],
  'filter-id->': [BooleanType, [ValueType], function (ctx, _ref75) {
    var _ref76 = _slicedToArray(_ref75, 1),
        v = _ref76[0];

    var a = ctx.id();
    var b = v.value;
    return _typeof(a) === _typeof(b) && a > b;
  }],
  'filter-<=': [BooleanType, [StringType, ValueType], function (ctx, _ref77) {
    var _ref78 = _slicedToArray(_ref77, 2),
        k = _ref78[0],
        v = _ref78[1];

    var a = ctx.properties()[k.value];
    var b = v.value;
    return _typeof(a) === _typeof(b) && a <= b;
  }],
  'filter-id-<=': [BooleanType, [ValueType], function (ctx, _ref79) {
    var _ref80 = _slicedToArray(_ref79, 1),
        v = _ref80[0];

    var a = ctx.id();
    var b = v.value;
    return _typeof(a) === _typeof(b) && a <= b;
  }],
  'filter->=': [BooleanType, [StringType, ValueType], function (ctx, _ref81) {
    var _ref82 = _slicedToArray(_ref81, 2),
        k = _ref82[0],
        v = _ref82[1];

    var a = ctx.properties()[k.value];
    var b = v.value;
    return _typeof(a) === _typeof(b) && a >= b;
  }],
  'filter-id->=': [BooleanType, [ValueType], function (ctx, _ref83) {
    var _ref84 = _slicedToArray(_ref83, 1),
        v = _ref84[0];

    var a = ctx.id();
    var b = v.value;
    return _typeof(a) === _typeof(b) && a >= b;
  }],
  'filter-has': [BooleanType, [ValueType], function (ctx, _ref85) {
    var _ref86 = _slicedToArray(_ref85, 1),
        k = _ref86[0];

    return k.value in ctx.properties();
  }],
  'filter-has-id': [BooleanType, [], function (ctx) {
    return ctx.id() !== null && ctx.id() !== undefined;
  }],
  'filter-type-in': [BooleanType, [array(StringType)], function (ctx, _ref87) {
    var _ref88 = _slicedToArray(_ref87, 1),
        v = _ref88[0];

    return v.value.indexOf(ctx.geometryType()) >= 0;
  }],
  'filter-id-in': [BooleanType, [array(ValueType)], function (ctx, _ref89) {
    var _ref90 = _slicedToArray(_ref89, 1),
        v = _ref90[0];

    return v.value.indexOf(ctx.id()) >= 0;
  }],
  'filter-in-small': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref91) {
    var _ref92 = _slicedToArray(_ref91, 2),
        k = _ref92[0],
        v = _ref92[1];

    return v.value.indexOf(ctx.properties()[k.value]) >= 0;
  }],
  'filter-in-large': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref93) {
    var _ref94 = _slicedToArray(_ref93, 2),
        k = _ref94[0],
        v = _ref94[1];

    return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
  }],
  'all': {
    type: BooleanType,
    overloads: [[[BooleanType, BooleanType], function (ctx, _ref95) {
      var _ref96 = _slicedToArray(_ref95, 2),
          a = _ref96[0],
          b = _ref96[1];

      return a.evaluate(ctx) && b.evaluate(ctx);
    }], [varargs(BooleanType), function (ctx, args) {
      var _iterator37 = _createForOfIteratorHelper(args),
          _step37;

      try {
        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
          var arg = _step37.value;
          if (!arg.evaluate(ctx)) return false;
        }
      } catch (err) {
        _iterator37.e(err);
      } finally {
        _iterator37.f();
      }

      return true;
    }]]
  },
  'any': {
    type: BooleanType,
    overloads: [[[BooleanType, BooleanType], function (ctx, _ref97) {
      var _ref98 = _slicedToArray(_ref97, 2),
          a = _ref98[0],
          b = _ref98[1];

      return a.evaluate(ctx) || b.evaluate(ctx);
    }], [varargs(BooleanType), function (ctx, args) {
      var _iterator38 = _createForOfIteratorHelper(args),
          _step38;

      try {
        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
          var arg = _step38.value;
          if (arg.evaluate(ctx)) return true;
        }
      } catch (err) {
        _iterator38.e(err);
      } finally {
        _iterator38.f();
      }

      return false;
    }]]
  },
  '!': [BooleanType, [BooleanType], function (ctx, _ref99) {
    var _ref100 = _slicedToArray(_ref99, 1),
        b = _ref100[0];

    return !b.evaluate(ctx);
  }],
  'is-supported-script': [BooleanType, [StringType], function (ctx, _ref101) {
    var _ref102 = _slicedToArray(_ref101, 1),
        s = _ref102[0];

    var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;

    if (isSupportedScript) {
      return isSupportedScript(s.evaluate(ctx));
    }

    return true;
  }],
  'upcase': [StringType, [StringType], function (ctx, _ref103) {
    var _ref104 = _slicedToArray(_ref103, 1),
        s = _ref104[0];

    return s.evaluate(ctx).toUpperCase();
  }],
  'downcase': [StringType, [StringType], function (ctx, _ref105) {
    var _ref106 = _slicedToArray(_ref105, 1),
        s = _ref106[0];

    return s.evaluate(ctx).toLowerCase();
  }],
  'concat': [StringType, varargs(ValueType), function (ctx, args) {
    return args.map(function (arg) {
      return toString$1(arg.evaluate(ctx));
    }).join('');
  }],
  'resolved-locale': [StringType, [CollatorType], function (ctx, _ref107) {
    var _ref108 = _slicedToArray(_ref107, 1),
        collator = _ref108[0];

    return collator.evaluate(ctx).resolvedLocale();
  }]
});

function success(value) {
  return {
    result: 'success',
    value: value
  };
}

function error(value) {
  return {
    result: 'error',
    value: value
  };
}

function supportsPropertyExpression(spec) {
  return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
}

function supportsZoomExpression(spec) {
  return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
}

function supportsInterpolation(spec) {
  return !!spec.expression && spec.expression.interpolated;
}

function getType(val) {
  if (val instanceof Number) {
    return 'number';
  } else if (val instanceof String) {
    return 'string';
  } else if (val instanceof Boolean) {
    return 'boolean';
  } else if (Array.isArray(val)) {
    return 'array';
  } else if (val === null) {
    return 'null';
  } else {
    return _typeof(val);
  }
}

function isFunction$1(value) {
  return _typeof(value) === 'object' && value !== null && !Array.isArray(value);
}

function identityFunction(x) {
  return x;
}

function createFunction(parameters, propertySpec) {
  var isColor = propertySpec.type === 'color';
  var zoomAndFeatureDependent = parameters.stops && _typeof(parameters.stops[0][0]) === 'object';
  var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
  var zoomDependent = zoomAndFeatureDependent || !featureDependent;
  var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');

  if (isColor) {
    parameters = extend({}, parameters);

    if (parameters.stops) {
      parameters.stops = parameters.stops.map(function (stop) {
        return [stop[0], Color.parse(stop[1])];
      });
    }

    if (parameters["default"]) {
      parameters["default"] = Color.parse(parameters["default"]);
    } else {
      parameters["default"] = Color.parse(propertySpec["default"]);
    }
  }

  if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {
    throw new Error("Unknown color space: ".concat(parameters.colorSpace));
  }

  var innerFun;
  var hashedStops;
  var categoricalKeyType;

  if (type === 'exponential') {
    innerFun = evaluateExponentialFunction;
  } else if (type === 'interval') {
    innerFun = evaluateIntervalFunction;
  } else if (type === 'categorical') {
    innerFun = evaluateCategoricalFunction;
    hashedStops = Object.create(null);

    var _iterator39 = _createForOfIteratorHelper(parameters.stops),
        _step39;

    try {
      for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
        var stop = _step39.value;
        hashedStops[stop[0]] = stop[1];
      }
    } catch (err) {
      _iterator39.e(err);
    } finally {
      _iterator39.f();
    }

    categoricalKeyType = _typeof(parameters.stops[0][0]);
  } else if (type === 'identity') {
    innerFun = evaluateIdentityFunction;
  } else {
    throw new Error("Unknown function type \"".concat(type, "\""));
  }

  if (zoomAndFeatureDependent) {
    var featureFunctions = {};
    var zoomStops = [];

    for (var s = 0; s < parameters.stops.length; s++) {
      var _stop = parameters.stops[s];
      var zoom = _stop[0].zoom;

      if (featureFunctions[zoom] === undefined) {
        featureFunctions[zoom] = {
          zoom: zoom,
          type: parameters.type,
          property: parameters.property,
          "default": parameters["default"],
          stops: []
        };
        zoomStops.push(zoom);
      }

      featureFunctions[zoom].stops.push([_stop[0].value, _stop[1]]);
    }

    var featureFunctionStops = [];

    for (var _i7 = 0, _zoomStops = zoomStops; _i7 < _zoomStops.length; _i7++) {
      var z = _zoomStops[_i7];
      featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);
    }

    var interpolationType = {
      name: 'linear'
    };
    return {
      kind: 'composite',
      interpolationType: interpolationType,
      interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),
      zoomStops: featureFunctionStops.map(function (s) {
        return s[0];
      }),
      evaluate: function evaluate(_ref109, properties) {
        var zoom = _ref109.zoom;
        return evaluateExponentialFunction({
          stops: featureFunctionStops,
          base: parameters.base
        }, propertySpec, zoom).evaluate(zoom, properties);
      }
    };
  } else if (zoomDependent) {
    var _interpolationType = type === 'exponential' ? {
      name: 'exponential',
      base: parameters.base !== undefined ? parameters.base : 1
    } : null;

    return {
      kind: 'camera',
      interpolationType: _interpolationType,
      interpolationFactor: Interpolate.interpolationFactor.bind(undefined, _interpolationType),
      zoomStops: parameters.stops.map(function (s) {
        return s[0];
      }),
      evaluate: function evaluate(_ref110) {
        var zoom = _ref110.zoom;
        return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);
      }
    };
  } else {
    return {
      kind: 'source',
      evaluate: function evaluate(_, feature) {
        var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;

        if (value === undefined) {
          return coalesce(parameters["default"], propertySpec["default"]);
        }

        return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
      }
    };
  }
}

function coalesce(a, b, c) {
  if (a !== undefined) return a;
  if (b !== undefined) return b;
  if (c !== undefined) return c;
}

function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
  var evaluated = _typeof(input) === keyType ? hashedStops[input] : undefined;
  return coalesce(evaluated, parameters["default"], propertySpec["default"]);
}

function evaluateIntervalFunction(parameters, propertySpec, input) {
  if (getType(input) !== 'number') return coalesce(parameters["default"], propertySpec["default"]);
  var n = parameters.stops.length;
  if (n === 1) return parameters.stops[0][1];
  if (input <= parameters.stops[0][0]) return parameters.stops[0][1];
  if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];
  var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
    return stop[0];
  }), input);
  return parameters.stops[index][1];
}

function evaluateExponentialFunction(parameters, propertySpec, input) {
  var base = parameters.base !== undefined ? parameters.base : 1;
  if (getType(input) !== 'number') return coalesce(parameters["default"], propertySpec["default"]);
  var n = parameters.stops.length;
  if (n === 1) return parameters.stops[0][1];
  if (input <= parameters.stops[0][0]) return parameters.stops[0][1];
  if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];
  var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
    return stop[0];
  }), input);
  var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
  var outputLower = parameters.stops[index][1];
  var outputUpper = parameters.stops[index + 1][1];
  var interp = interpolate[propertySpec.type] || identityFunction;

  if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
    var colorspace = colorSpaces[parameters.colorSpace];

    interp = function interp(a, b) {
      return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
    };
  }

  if (typeof outputLower.evaluate === 'function') {
    return {
      evaluate: function evaluate() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {
          args[_key5] = arguments[_key5];
        }

        var evaluatedLower = outputLower.evaluate.apply(undefined, args);
        var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);

        if (evaluatedLower === undefined || evaluatedUpper === undefined) {
          return undefined;
        }

        return interp(evaluatedLower, evaluatedUpper, t);
      }
    };
  }

  return interp(outputLower, outputUpper, t);
}

function evaluateIdentityFunction(parameters, propertySpec, input) {
  if (propertySpec.type === 'color') {
    input = Color.parse(input);
  } else if (propertySpec.type === 'formatted') {
    input = Formatted.fromString(input.toString());
  } else if (propertySpec.type === 'resolvedImage') {
    input = ResolvedImage.fromString(input.toString());
  } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
    input = undefined;
  }

  return coalesce(input, parameters["default"], propertySpec["default"]);
}

function interpolationFactor(input, base, lowerValue, upperValue) {
  var difference = upperValue - lowerValue;
  var progress = input - lowerValue;

  if (difference === 0) {
    return 0;
  } else if (base === 1) {
    return progress / difference;
  } else {
    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
  }
}

var StyleExpression = /*#__PURE__*/function () {
  function StyleExpression(expression, propertySpec) {
    _classCallCheck(this, StyleExpression);

    this.expression = expression;
    this._warningHistory = {};
    this._evaluator = new EvaluationContext();
    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
    this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
  }

  _createClass(StyleExpression, [{
    key: "evaluateWithoutErrorHandling",
    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
      this._evaluator.globals = globals;
      this._evaluator.feature = feature;
      this._evaluator.featureState = featureState;
      this._evaluator.canonical = canonical;
      this._evaluator.availableImages = availableImages || null;
      this._evaluator.formattedSection = formattedSection;
      return this.expression.evaluate(this._evaluator);
    }
  }, {
    key: "evaluate",
    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
      this._evaluator.globals = globals;
      this._evaluator.feature = feature || null;
      this._evaluator.featureState = featureState || null;
      this._evaluator.canonical = canonical;
      this._evaluator.availableImages = availableImages || null;
      this._evaluator.formattedSection = formattedSection || null;

      try {
        var val = this.expression.evaluate(this._evaluator);

        if (val === null || val === undefined || typeof val === 'number' && val !== val) {
          return this._defaultValue;
        }

        if (this._enumValues && !(val in this._enumValues)) {
          throw new RuntimeError("Expected value to be one of ".concat(Object.keys(this._enumValues).map(function (v) {
            return JSON.stringify(v);
          }).join(', '), ", but found ").concat(JSON.stringify(val), " instead."));
        }

        return val;
      } catch (e) {
        if (!this._warningHistory[e.message]) {
          this._warningHistory[e.message] = true;

          if (typeof console !== 'undefined') {
            console.warn(e.message);
          }
        }

        return this._defaultValue;
      }
    }
  }]);

  return StyleExpression;
}();

function isExpression(expression) {
  return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;
}

function createExpression(expression, propertySpec) {
  var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
  var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? {
    typeAnnotation: 'coerce'
  } : undefined);

  if (!parsed) {
    return error(parser.errors);
  }

  return success(new StyleExpression(parsed, propertySpec));
}

var ZoomConstantExpression = /*#__PURE__*/function () {
  function ZoomConstantExpression(kind, expression) {
    _classCallCheck(this, ZoomConstantExpression);

    this.kind = kind;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
  }

  _createClass(ZoomConstantExpression, [{
    key: "evaluateWithoutErrorHandling",
    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
      return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
  }, {
    key: "evaluate",
    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
      return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
  }]);

  return ZoomConstantExpression;
}();

var ZoomDependentExpression = /*#__PURE__*/function () {
  function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
    _classCallCheck(this, ZoomDependentExpression);

    this.kind = kind;
    this.zoomStops = zoomStops;
    this._styleExpression = expression;
    this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
    this.interpolationType = interpolationType;
  }

  _createClass(ZoomDependentExpression, [{
    key: "evaluateWithoutErrorHandling",
    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
      return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
  }, {
    key: "evaluate",
    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
      return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
  }, {
    key: "interpolationFactor",
    value: function interpolationFactor(input, lower, upper) {
      if (this.interpolationType) {
        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
      } else {
        return 0;
      }
    }
  }]);

  return ZoomDependentExpression;
}();

function createPropertyExpression(expression, propertySpec) {
  expression = createExpression(expression, propertySpec);

  if (expression.result === 'error') {
    return expression;
  }

  var parsed = expression.value.expression;
  var isFeatureConstant$1 = isFeatureConstant(parsed);

  if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
    return error([new ParsingError('', 'data expressions not supported')]);
  }

  var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);

  if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
    return error([new ParsingError('', 'zoom expressions not supported')]);
  }

  var zoomCurve = findZoomCurve(parsed);

  if (!zoomCurve && !isZoomConstant) {
    return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  } else if (zoomCurve instanceof ParsingError) {
    return error([zoomCurve]);
  } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
    return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
  }

  if (!zoomCurve) {
    return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
  }

  var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;
  return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
}

var StylePropertyFunction = /*#__PURE__*/function () {
  function StylePropertyFunction(parameters, specification) {
    _classCallCheck(this, StylePropertyFunction);

    this._parameters = parameters;
    this._specification = specification;
    extend(this, createFunction(this._parameters, this._specification));
  }

  _createClass(StylePropertyFunction, null, [{
    key: "deserialize",
    value: function deserialize(serialized) {
      return new StylePropertyFunction(serialized._parameters, serialized._specification);
    }
  }, {
    key: "serialize",
    value: function serialize(input) {
      return {
        _parameters: input._parameters,
        _specification: input._specification
      };
    }
  }]);

  return StylePropertyFunction;
}();

function normalizePropertyExpression(value, specification) {
  if (isFunction$1(value)) {
    return new StylePropertyFunction(value, specification);
  } else if (isExpression(value)) {
    var _expression8 = createPropertyExpression(value, specification);

    if (_expression8.result === 'error') {
      throw new Error(_expression8.value.map(function (err) {
        return "".concat(err.key, ": ").concat(err.message);
      }).join(', '));
    }

    return _expression8.value;
  } else {
    var constant = value;

    if (typeof value === 'string' && specification.type === 'color') {
      constant = Color.parse(value);
    }

    return {
      kind: 'constant',
      evaluate: function evaluate() {
        return constant;
      }
    };
  }
}

function findZoomCurve(expression) {
  var result = null;

  if (expression instanceof Let) {
    result = findZoomCurve(expression.result);
  } else if (expression instanceof Coalesce) {
    var _iterator40 = _createForOfIteratorHelper(expression.args),
        _step40;

    try {
      for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
        var arg = _step40.value;
        result = findZoomCurve(arg);

        if (result) {
          break;
        }
      }
    } catch (err) {
      _iterator40.e(err);
    } finally {
      _iterator40.f();
    }
  } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {
    result = expression;
  }

  if (result instanceof ParsingError) {
    return result;
  }

  expression.eachChild(function (child) {
    var childResult = findZoomCurve(child);

    if (childResult instanceof ParsingError) {
      result = childResult;
    } else if (!result && childResult) {
      result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
    } else if (result && childResult && result !== childResult) {
      result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
    }
  });
  return result;
}

function getExpectedType(spec) {
  var types = {
    color: ColorType,
    string: StringType,
    number: NumberType,
    "enum": StringType,
    "boolean": BooleanType,
    formatted: FormattedType,
    resolvedImage: ResolvedImageType
  };

  if (spec.type === 'array') {
    return array(types[spec.value] || ValueType, spec.length);
  }

  return types[spec.type];
}

function getDefaultValue(spec) {
  if (spec.type === 'color' && isFunction$1(spec["default"])) {
    return new Color(0, 0, 0, 0);
  } else if (spec.type === 'color') {
    return Color.parse(spec["default"]) || null;
  } else if (spec["default"] === undefined) {
    return null;
  } else {
    return spec["default"];
  }
}

function convertLiteral(value) {
  return _typeof(value) === 'object' ? ['literal', value] : value;
}

function convertFunction(parameters, propertySpec) {
  var stops = parameters.stops;

  if (!stops) {
    return convertIdentityFunction(parameters, propertySpec);
  }

  var zoomAndFeatureDependent = stops && _typeof(stops[0][0]) === 'object';
  var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
  var zoomDependent = zoomAndFeatureDependent || !featureDependent;
  stops = stops.map(function (stop) {
    if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {
      return [stop[0], convertTokenString(stop[1])];
    }

    return [stop[0], convertLiteral(stop[1])];
  });

  if (zoomAndFeatureDependent) {
    return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
  } else if (zoomDependent) {
    return convertZoomFunction(parameters, propertySpec, stops);
  } else {
    return convertPropertyFunction(parameters, propertySpec, stops);
  }
}

function convertIdentityFunction(parameters, propertySpec) {
  var get = ['get', parameters.property];

  if (parameters["default"] === undefined) {
    return propertySpec.type === 'string' ? ['string', get] : get;
  } else if (propertySpec.type === 'enum') {
    return ['match', get, Object.keys(propertySpec.values), get, parameters["default"]];
  } else {
    var _expression9 = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters["default"])];

    if (propertySpec.type === 'array') {
      _expression9.splice(1, 0, propertySpec.value, propertySpec.length || null);
    }

    return _expression9;
  }
}

function getInterpolateOperator(parameters) {
  switch (parameters.colorSpace) {
    case 'hcl':
      return 'interpolate-hcl';

    case 'lab':
      return 'interpolate-lab';

    default:
      return 'interpolate';
  }
}

function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
  var featureFunctionParameters = {};
  var featureFunctionStops = {};
  var zoomStops = [];

  for (var s = 0; s < stops.length; s++) {
    var stop = stops[s];
    var zoom = stop[0].zoom;

    if (featureFunctionParameters[zoom] === undefined) {
      featureFunctionParameters[zoom] = {
        zoom: zoom,
        type: parameters.type,
        property: parameters.property,
        "default": parameters["default"]
      };
      featureFunctionStops[zoom] = [];
      zoomStops.push(zoom);
    }

    featureFunctionStops[zoom].push([stop[0].value, stop[1]]);
  }

  var functionType = getFunctionType({}, propertySpec);

  if (functionType === 'exponential') {
    var _expression10 = [getInterpolateOperator(parameters), ['linear'], ['zoom']];

    var _iterator41 = _createForOfIteratorHelper(zoomStops),
        _step41;

    try {
      for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
        var z = _step41.value;
        var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
        appendStopPair(_expression10, z, output, false);
      }
    } catch (err) {
      _iterator41.e(err);
    } finally {
      _iterator41.f();
    }

    return _expression10;
  } else {
    var _expression11 = ['step', ['zoom']];

    var _iterator42 = _createForOfIteratorHelper(zoomStops),
        _step42;

    try {
      for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
        var _z = _step42.value;

        var _output = convertPropertyFunction(featureFunctionParameters[_z], propertySpec, featureFunctionStops[_z]);

        appendStopPair(_expression11, _z, _output, true);
      }
    } catch (err) {
      _iterator42.e(err);
    } finally {
      _iterator42.f();
    }

    fixupDegenerateStepCurve(_expression11);
    return _expression11;
  }
}

function coalesce$1(a, b) {
  if (a !== undefined) return a;
  if (b !== undefined) return b;
}

function getFallback(parameters, propertySpec) {
  var defaultValue = convertLiteral(coalesce$1(parameters["default"], propertySpec["default"]));

  if (defaultValue === undefined && propertySpec.type === 'resolvedImage') {
    return '';
  }

  return defaultValue;
}

function convertPropertyFunction(parameters, propertySpec, stops) {
  var type = getFunctionType(parameters, propertySpec);
  var get = ['get', parameters.property];

  if (type === 'categorical' && typeof stops[0][0] === 'boolean') {
    var _expression12 = ['case'];

    var _iterator43 = _createForOfIteratorHelper(stops),
        _step43;

    try {
      for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
        var stop = _step43.value;

        _expression12.push(['==', get, stop[0]], stop[1]);
      }
    } catch (err) {
      _iterator43.e(err);
    } finally {
      _iterator43.f();
    }

    _expression12.push(getFallback(parameters, propertySpec));

    return _expression12;
  } else if (type === 'categorical') {
    var _expression13 = ['match', get];

    var _iterator44 = _createForOfIteratorHelper(stops),
        _step44;

    try {
      for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
        var _stop2 = _step44.value;
        appendStopPair(_expression13, _stop2[0], _stop2[1], false);
      }
    } catch (err) {
      _iterator44.e(err);
    } finally {
      _iterator44.f();
    }

    _expression13.push(getFallback(parameters, propertySpec));

    return _expression13;
  } else if (type === 'interval') {
    var _expression14 = ['step', ['number', get]];

    var _iterator45 = _createForOfIteratorHelper(stops),
        _step45;

    try {
      for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
        var _stop3 = _step45.value;
        appendStopPair(_expression14, _stop3[0], _stop3[1], true);
      }
    } catch (err) {
      _iterator45.e(err);
    } finally {
      _iterator45.f();
    }

    fixupDegenerateStepCurve(_expression14);
    return parameters["default"] === undefined ? _expression14 : ['case', ['==', ['typeof', get], 'number'], _expression14, convertLiteral(parameters["default"])];
  } else if (type === 'exponential') {
    var base = parameters.base !== undefined ? parameters.base : 1;
    var _expression15 = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], ['number', get]];

    var _iterator46 = _createForOfIteratorHelper(stops),
        _step46;

    try {
      for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
        var _stop4 = _step46.value;
        appendStopPair(_expression15, _stop4[0], _stop4[1], false);
      }
    } catch (err) {
      _iterator46.e(err);
    } finally {
      _iterator46.f();
    }

    return parameters["default"] === undefined ? _expression15 : ['case', ['==', ['typeof', get], 'number'], _expression15, convertLiteral(parameters["default"])];
  } else {
    throw new Error("Unknown property function type ".concat(type));
  }
}

function convertZoomFunction(parameters, propertySpec, stops) {
  var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['zoom'];
  var type = getFunctionType(parameters, propertySpec);
  var expression;
  var isStep = false;

  if (type === 'interval') {
    expression = ['step', input];
    isStep = true;
  } else if (type === 'exponential') {
    var base = parameters.base !== undefined ? parameters.base : 1;
    expression = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], input];
  } else {
    throw new Error("Unknown zoom function type \"".concat(type, "\""));
  }

  var _iterator47 = _createForOfIteratorHelper(stops),
      _step47;

  try {
    for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
      var stop = _step47.value;
      appendStopPair(expression, stop[0], stop[1], isStep);
    }
  } catch (err) {
    _iterator47.e(err);
  } finally {
    _iterator47.f();
  }

  fixupDegenerateStepCurve(expression);
  return expression;
}

function fixupDegenerateStepCurve(expression) {
  if (expression[0] === 'step' && expression.length === 3) {
    expression.push(0);
    expression.push(expression[3]);
  }
}

function appendStopPair(curve, input, output, isStep) {
  if (curve.length > 3 && input === curve[curve.length - 2]) {
    return;
  }

  if (!(isStep && curve.length === 2)) {
    curve.push(input);
  }

  curve.push(output);
}

function getFunctionType(parameters, propertySpec) {
  if (parameters.type) {
    return parameters.type;
  } else {
    return propertySpec.expression.interpolated ? 'exponential' : 'interval';
  }
}

function convertTokenString(s) {
  var result = ['concat'];
  var re = /{([^{}]+)}/g;
  var pos = 0;

  for (var match = re.exec(s); match !== null; match = re.exec(s)) {
    var literal = s.slice(pos, re.lastIndex - match[0].length);
    pos = re.lastIndex;
    if (literal.length > 0) result.push(literal);
    result.push(['get', match[1]]);
  }

  if (result.length === 1) {
    return s;
  }

  if (pos < s.length) {
    result.push(s.slice(pos));
  } else if (result.length === 2) {
    return ['to-string', result[1]];
  }

  return result;
}

function isExpressionFilter(filter) {
  if (filter === true || filter === false) {
    return true;
  }

  if (!Array.isArray(filter) || filter.length === 0) {
    return false;
  }

  switch (filter[0]) {
    case 'has':
      return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';

    case 'in':
      return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));

    case '!in':
    case '!has':
    case 'none':
      return false;

    case '==':
    case '!=':
    case '>':
    case '>=':
    case '<':
    case '<=':
      return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);

    case 'any':
    case 'all':
      var _iterator48 = _createForOfIteratorHelper(filter.slice(1)),
          _step48;

      try {
        for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
          var f = _step48.value;

          if (!isExpressionFilter(f) && typeof f !== 'boolean') {
            return false;
          }
        }
      } catch (err) {
        _iterator48.e(err);
      } finally {
        _iterator48.f();
      }

      return true;

    default:
      return true;
  }
}

var filterSpec = {
  'type': 'boolean',
  'default': false,
  'transition': false,
  'property-type': 'data-driven',
  'expression': {
    'interpolated': false,
    'parameters': ['zoom', 'feature']
  }
};

function createFilter(filter) {
  if (filter === null || filter === undefined) {
    return {
      filter: function filter() {
        return true;
      },
      needGeometry: false
    };
  }

  if (!isExpressionFilter(filter)) {
    filter = convertFilter(filter);
  }

  var compiled = createExpression(filter, filterSpec);

  if (compiled.result === 'error') {
    throw new Error(compiled.value.map(function (err) {
      return "".concat(err.key, ": ").concat(err.message);
    }).join(', '));
  } else {
    var needGeometry = geometryNeeded(filter);
    return {
      filter: function filter(globalProperties, feature, canonical) {
        return compiled.value.evaluate(globalProperties, feature, {}, canonical);
      },
      needGeometry: needGeometry
    };
  }
}

function compare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

function geometryNeeded(filter) {
  if (!Array.isArray(filter)) return false;
  if (filter[0] === 'within') return true;

  for (var index = 1; index < filter.length; index++) {
    if (geometryNeeded(filter[index])) return true;
  }

  return false;
}

function convertFilter(filter) {
  if (!filter) return true;
  var op = filter[0];
  if (filter.length <= 1) return op !== 'any';
  var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : op === 'within' ? filter : true;
  return converted;
}

function convertComparisonOp(property, value, op) {
  switch (property) {
    case '$type':
      return ["filter-type-".concat(op), value];

    case '$id':
      return ["filter-id-".concat(op), value];

    default:
      return ["filter-".concat(op), property, value];
  }
}

function convertDisjunctionOp(filters) {
  return ['any'].concat(filters.map(convertFilter));
}

function convertInOp(property, values) {
  if (values.length === 0) {
    return false;
  }

  switch (property) {
    case '$type':
      return ["filter-type-in", ['literal', values]];

    case '$id':
      return ["filter-id-in", ['literal', values]];

    default:
      if (values.length > 200 && !values.some(function (v) {
        return _typeof(v) !== _typeof(values[0]);
      })) {
        return ['filter-in-large', property, ['literal', values.sort(compare)]];
      } else {
        return ['filter-in-small', property, ['literal', values]];
      }

  }
}

function convertHasOp(property) {
  switch (property) {
    case '$type':
      return true;

    case '$id':
      return ["filter-has-id"];

    default:
      return ["filter-has", property];
  }
}

function convertNegation(filter) {
  return ['!', filter];
}

function convertFilter$1(filter) {
  return _convertFilter(filter, {});
}

function _convertFilter(filter, expectedTypes) {
  if (isExpressionFilter(filter)) {
    return filter;
  }

  if (!filter) return true;
  var op = filter[0];
  if (filter.length <= 1) return op !== 'any';
  var converted;

  if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
    var _filter = _slicedToArray(filter, 3),
        property = _filter[1],
        value = _filter[2];

    converted = convertComparisonOp$1(property, value, op, expectedTypes);
  } else if (op === 'any') {
    var children = filter.slice(1).map(function (f) {
      var types = {};

      var child = _convertFilter(f, types);

      var typechecks = runtimeTypeChecks(types);
      return typechecks === true ? child : ['case', typechecks, child, false];
    });
    return ['any'].concat(children);
  } else if (op === 'all') {
    var _ref111;

    var _children = filter.slice(1).map(function (f) {
      return _convertFilter(f, expectedTypes);
    });

    return _children.length > 1 ? ['all'].concat(_children) : (_ref111 = []).concat.apply(_ref111, _toConsumableArray(_children));
  } else if (op === 'none') {
    return ['!', _convertFilter(['any'].concat(filter.slice(1)), {})];
  } else if (op === 'in') {
    converted = convertInOp$1(filter[1], filter.slice(2));
  } else if (op === '!in') {
    converted = convertInOp$1(filter[1], filter.slice(2), true);
  } else if (op === 'has') {
    converted = convertHasOp$1(filter[1]);
  } else if (op === '!has') {
    converted = ['!', convertHasOp$1(filter[1])];
  } else {
    converted = true;
  }

  return converted;
}

function runtimeTypeChecks(expectedTypes) {
  var conditions = [];

  for (var property in expectedTypes) {
    var _get = property === '$id' ? ['id'] : ['get', property];

    conditions.push(['==', ['typeof', _get], expectedTypes[property]]);
  }

  if (conditions.length === 0) return true;
  if (conditions.length === 1) return conditions[0];
  return ['all'].concat(conditions);
}

function convertComparisonOp$1(property, value, op, expectedTypes) {
  var get;

  if (property === '$type') {
    return [op, ['geometry-type'], value];
  } else if (property === '$id') {
    get = ['id'];
  } else {
    get = ['get', property];
  }

  if (expectedTypes && value !== null) {
    var type = _typeof(value);

    expectedTypes[property] = type;
  }

  if (op === '==' && property !== '$id' && value === null) {
    return ['all', ['has', property], ['==', get, null]];
  } else if (op === '!=' && property !== '$id' && value === null) {
    return ['any', ['!', ['has', property]], ['!=', get, null]];
  }

  return [op, get, value];
}

function convertInOp$1(property, values) {
  var negate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (values.length === 0) return negate;
  var get;

  if (property === '$type') {
    get = ['geometry-type'];
  } else if (property === '$id') {
    get = ['id'];
  } else {
    get = ['get', property];
  }

  var uniformTypes = true;

  var type = _typeof(values[0]);

  var _iterator49 = _createForOfIteratorHelper(values),
      _step49;

  try {
    for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
      var value = _step49.value;

      if (_typeof(value) !== type) {
        uniformTypes = false;
        break;
      }
    }
  } catch (err) {
    _iterator49.e(err);
  } finally {
    _iterator49.f();
  }

  if (uniformTypes && (type === 'string' || type === 'number')) {
    var uniqueValues = values.sort().filter(function (v, i) {
      return i === 0 || values[i - 1] !== v;
    });
    return ['match', get, uniqueValues, !negate, negate];
  }

  return [negate ? 'all' : 'any'].concat(values.map(function (v) {
    return [negate ? '!=' : '==', get, v];
  }));
}

function convertHasOp$1(property) {
  if (property === '$type') {
    return true;
  } else if (property === '$id') {
    return ['!=', ['id'], null];
  } else {
    return ['has', property];
  }
}

function migrateToExpressions(style) {
  var converted = [];
  eachLayer(style, function (layer) {
    if (layer.filter) {
      layer.filter = convertFilter$1(layer.filter);
    }
  });
  eachProperty(style, {
    paint: true,
    layout: true
  }, function (_ref112) {
    var path = _ref112.path,
        value = _ref112.value,
        reference = _ref112.reference,
        set = _ref112.set;
    if (isExpression(value)) return;

    if (_typeof(value) === 'object' && !Array.isArray(value)) {
      set(convertFunction(value, reference));
      converted.push(path.join('.'));
    } else if (reference.tokens && typeof value === 'string') {
      set(convertTokenString(value));
    }
  });
  return style;
}

function migrate(style) {
  var migrated = false;

  if (style.version === 7) {
    style = migrateToV8(style);
    migrated = true;
  }

  if (style.version === 8) {
    migrated = migrateToExpressions(style);
    migrated = true;
  }

  if (!migrated) {
    throw new Error('cannot migrate from', style.version);
  }

  return style;
}

function composite(style) {
  var styleIDs = [];
  var sourceIDs = [];
  var compositedSourceLayers = [];

  for (var id in style.sources) {
    var _source = style.sources[id];
    if (_source.type !== 'vector') continue;
    var match = /^mapbox:\/\/(.*)/.exec(_source.url);
    if (!match) continue;
    styleIDs.push(id);
    sourceIDs.push(match[1]);
  }

  if (styleIDs.length < 2) return style;
  styleIDs.forEach(function (id) {
    delete style.sources[id];
  });
  var compositeID = sourceIDs.join(',');
  style.sources[compositeID] = {
    'type': 'vector',
    'url': "mapbox://".concat(compositeID)
  };
  style.layers.forEach(function (layer) {
    if (styleIDs.indexOf(layer.source) >= 0) {
      layer.source = compositeID;

      if ('source-layer' in layer) {
        if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {
          throw new Error('Conflicting source layer names');
        } else {
          compositedSourceLayers.push(layer['source-layer']);
        }
      }
    }
  });
  return style;
}

var refProperties = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];

function deref(layer, parent) {
  var result = {};

  for (var k in layer) {
    if (k !== 'ref') {
      result[k] = layer[k];
    }
  }

  refProperties.forEach(function (k) {
    if (k in parent) {
      result[k] = parent[k];
    }
  });
  return result;
}

function derefLayers(layers) {
  layers = layers.slice();
  var map = Object.create(null);

  for (var i = 0; i < layers.length; i++) {
    map[layers[i].id] = layers[i];
  }

  for (var _i8 = 0; _i8 < layers.length; _i8++) {
    if ('ref' in layers[_i8]) {
      layers[_i8] = deref(layers[_i8], map[layers[_i8].ref]);
    }
  }

  return layers;
}

function deepEqual(a, b) {
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }

    return true;
  }

  if (_typeof(a) === 'object' && a !== null && b !== null) {
    if (!(_typeof(b) === 'object')) return false;
    var keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length) return false;

    for (var key in a) {
      if (!deepEqual(a[key], b[key])) return false;
    }

    return true;
  }

  return a === b;
}

var operations = {
  setStyle: 'setStyle',
  addLayer: 'addLayer',
  removeLayer: 'removeLayer',
  setPaintProperty: 'setPaintProperty',
  setLayoutProperty: 'setLayoutProperty',
  setFilter: 'setFilter',
  addSource: 'addSource',
  removeSource: 'removeSource',
  setGeoJSONSourceData: 'setGeoJSONSourceData',
  setLayerZoomRange: 'setLayerZoomRange',
  setLayerProperty: 'setLayerProperty',
  setCenter: 'setCenter',
  setZoom: 'setZoom',
  setBearing: 'setBearing',
  setPitch: 'setPitch',
  setSprite: 'setSprite',
  setGlyphs: 'setGlyphs',
  setTransition: 'setTransition',
  setLight: 'setLight',
  setTerrain: 'setTerrain',
  setFog: 'setFog'
};

function addSource(sourceId, after, commands) {
  commands.push({
    command: operations.addSource,
    args: [sourceId, after[sourceId]]
  });
}

function removeSource(sourceId, commands, sourcesRemoved) {
  commands.push({
    command: operations.removeSource,
    args: [sourceId]
  });
  sourcesRemoved[sourceId] = true;
}

function updateSource(sourceId, after, commands, sourcesRemoved) {
  removeSource(sourceId, commands, sourcesRemoved);
  addSource(sourceId, after, commands);
}

function canUpdateGeoJSON(before, after, sourceId) {
  var prop;

  for (prop in before[sourceId]) {
    if (!before[sourceId].hasOwnProperty(prop)) continue;

    if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
      return false;
    }
  }

  for (prop in after[sourceId]) {
    if (!after[sourceId].hasOwnProperty(prop)) continue;

    if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
      return false;
    }
  }

  return true;
}

function diffSources(before, after, commands, sourcesRemoved) {
  before = before || {};
  after = after || {};
  var sourceId;

  for (sourceId in before) {
    if (!before.hasOwnProperty(sourceId)) continue;

    if (!after.hasOwnProperty(sourceId)) {
      removeSource(sourceId, commands, sourcesRemoved);
    }
  }

  for (sourceId in after) {
    if (!after.hasOwnProperty(sourceId)) continue;

    if (!before.hasOwnProperty(sourceId)) {
      addSource(sourceId, after, commands);
    } else if (!deepEqual(before[sourceId], after[sourceId])) {
      if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {
        commands.push({
          command: operations.setGeoJSONSourceData,
          args: [sourceId, after[sourceId].data]
        });
      } else {
        updateSource(sourceId, after, commands, sourcesRemoved);
      }
    }
  }
}

function diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {
  before = before || {};
  after = after || {};
  var prop;

  for (prop in before) {
    if (!before.hasOwnProperty(prop)) continue;

    if (!deepEqual(before[prop], after[prop])) {
      commands.push({
        command: command,
        args: [layerId, prop, after[prop], klass]
      });
    }
  }

  for (prop in after) {
    if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) continue;

    if (!deepEqual(before[prop], after[prop])) {
      commands.push({
        command: command,
        args: [layerId, prop, after[prop], klass]
      });
    }
  }
}

function pluckId(layer) {
  return layer.id;
}

function indexById(group, layer) {
  group[layer.id] = layer;
  return group;
}

function diffLayers(before, after, commands) {
  before = before || [];
  after = after || [];
  var beforeOrder = before.map(pluckId);
  var afterOrder = after.map(pluckId);
  var beforeIndex = before.reduce(indexById, {});
  var afterIndex = after.reduce(indexById, {});
  var tracker = beforeOrder.slice();
  var clean = Object.create(null);
  var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;

  for (i = 0, d = 0; i < beforeOrder.length; i++) {
    layerId = beforeOrder[i];

    if (!afterIndex.hasOwnProperty(layerId)) {
      commands.push({
        command: operations.removeLayer,
        args: [layerId]
      });
      tracker.splice(tracker.indexOf(layerId, d), 1);
    } else {
      d++;
    }
  }

  for (i = 0, d = 0; i < afterOrder.length; i++) {
    layerId = afterOrder[afterOrder.length - 1 - i];
    if (tracker[tracker.length - 1 - i] === layerId) continue;

    if (beforeIndex.hasOwnProperty(layerId)) {
      commands.push({
        command: operations.removeLayer,
        args: [layerId]
      });
      tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);
    } else {
      d++;
    }

    insertBeforeLayerId = tracker[tracker.length - i];
    commands.push({
      command: operations.addLayer,
      args: [afterIndex[layerId], insertBeforeLayerId]
    });
    tracker.splice(tracker.length - i, 0, layerId);
    clean[layerId] = true;
  }

  for (i = 0; i < afterOrder.length; i++) {
    layerId = afterOrder[i];
    beforeLayer = beforeIndex[layerId];
    afterLayer = afterIndex[layerId];
    if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) continue;

    if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !deepEqual(beforeLayer.type, afterLayer.type)) {
      commands.push({
        command: operations.removeLayer,
        args: [layerId]
      });
      insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];
      commands.push({
        command: operations.addLayer,
        args: [afterLayer, insertBeforeLayerId]
      });
      continue;
    }

    diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);
    diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);

    if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {
      commands.push({
        command: operations.setFilter,
        args: [layerId, afterLayer.filter]
      });
    }

    if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {
      commands.push({
        command: operations.setLayerZoomRange,
        args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]
      });
    }

    for (prop in beforeLayer) {
      if (!beforeLayer.hasOwnProperty(prop)) continue;
      if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;

      if (prop.indexOf('paint.') === 0) {
        diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
      } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
        commands.push({
          command: operations.setLayerProperty,
          args: [layerId, prop, afterLayer[prop]]
        });
      }
    }

    for (prop in afterLayer) {
      if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) continue;
      if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;

      if (prop.indexOf('paint.') === 0) {
        diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
      } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
        commands.push({
          command: operations.setLayerProperty,
          args: [layerId, prop, afterLayer[prop]]
        });
      }
    }
  }
}

function diffStyles(before, after) {
  if (!before) return [{
    command: operations.setStyle,
    args: [after]
  }];
  var commands = [];

  try {
    if (!deepEqual(before.version, after.version)) {
      return [{
        command: operations.setStyle,
        args: [after]
      }];
    }

    if (!deepEqual(before.center, after.center)) {
      commands.push({
        command: operations.setCenter,
        args: [after.center]
      });
    }

    if (!deepEqual(before.zoom, after.zoom)) {
      commands.push({
        command: operations.setZoom,
        args: [after.zoom]
      });
    }

    if (!deepEqual(before.bearing, after.bearing)) {
      commands.push({
        command: operations.setBearing,
        args: [after.bearing]
      });
    }

    if (!deepEqual(before.pitch, after.pitch)) {
      commands.push({
        command: operations.setPitch,
        args: [after.pitch]
      });
    }

    if (!deepEqual(before.sprite, after.sprite)) {
      commands.push({
        command: operations.setSprite,
        args: [after.sprite]
      });
    }

    if (!deepEqual(before.glyphs, after.glyphs)) {
      commands.push({
        command: operations.setGlyphs,
        args: [after.glyphs]
      });
    }

    if (!deepEqual(before.transition, after.transition)) {
      commands.push({
        command: operations.setTransition,
        args: [after.transition]
      });
    }

    if (!deepEqual(before.light, after.light)) {
      commands.push({
        command: operations.setLight,
        args: [after.light]
      });
    }

    if (!deepEqual(before.fog, after.fog)) {
      commands.push({
        command: operations.setFog,
        args: [after.fog]
      });
    }

    var sourcesRemoved = {};
    var removeOrAddSourceCommands = [];
    diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);
    var beforeLayers = [];

    if (before.layers) {
      before.layers.forEach(function (layer) {
        if (sourcesRemoved[layer.source]) {
          commands.push({
            command: operations.removeLayer,
            args: [layer.id]
          });
        } else {
          beforeLayers.push(layer);
        }
      });
    }

    var beforeTerrain = before.terrain;

    if (beforeTerrain) {
      if (sourcesRemoved[beforeTerrain.source]) {
        commands.push({
          command: operations.setTerrain,
          args: [undefined]
        });
        beforeTerrain = undefined;
      }
    }

    commands = commands.concat(removeOrAddSourceCommands);

    if (!deepEqual(beforeTerrain, after.terrain)) {
      commands.push({
        command: operations.setTerrain,
        args: [after.terrain]
      });
    }

    diffLayers(beforeLayers, after.layers, commands);
  } catch (e) {
    console.warn('Unable to compute style diff:', e);
    commands = [{
      command: operations.setStyle,
      args: [after]
    }];
  }

  return commands;
}

var ValidationError = /*#__PURE__*/_createClass(function ValidationError(key, value, message, identifier) {
  _classCallCheck(this, ValidationError);

  this.message = (key ? "".concat(key, ": ") : '') + message;
  if (identifier) this.identifier = identifier;

  if (value !== null && value !== undefined && value.__line__) {
    this.line = value.__line__;
  }
});

var ParsingError$1 = /*#__PURE__*/_createClass(function ParsingError$1(error) {
  _classCallCheck(this, ParsingError$1);

  this.error = error;
  this.message = error.message;
  var match = error.message.match(/line (\d+)/);
  this.line = match ? parseInt(match[1], 10) : 0;
});

function validateConstants(options) {
  var key = options.key;
  var constants = options.value;

  if (constants) {
    return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
  } else {
    return [];
  }
}

function unbundle(value) {
  if (value instanceof Number || value instanceof String || value instanceof Boolean) {
    return value.valueOf();
  } else {
    return value;
  }
}

function deepUnbundle(value) {
  if (Array.isArray(value)) {
    return value.map(deepUnbundle);
  } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
    var unbundledValue = {};

    for (var key in value) {
      unbundledValue[key] = deepUnbundle(value[key]);
    }

    return unbundledValue;
  }

  return unbundle(value);
}

function validateObject(options) {
  var key = options.key;
  var object = options.value;
  var elementSpecs = options.valueSpec || {};
  var elementValidators = options.objectElementValidators || {};
  var style = options.style;
  var styleSpec = options.styleSpec;
  var errors = [];
  var type = getType(object);

  if (type !== 'object') {
    return [new ValidationError(key, object, "object expected, ".concat(type, " found"))];
  }

  for (var objectKey in object) {
    var elementSpecKey = objectKey.split('.')[0];
    var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];
    var validateElement = void 0;

    if (elementValidators[elementSpecKey]) {
      validateElement = elementValidators[elementSpecKey];
    } else if (elementSpecs[elementSpecKey]) {
      validateElement = validate;
    } else if (elementValidators['*']) {
      validateElement = elementValidators['*'];
    } else if (elementSpecs['*']) {
      validateElement = validate;
    } else {
      errors.push(new ValidationError(key, object[objectKey], "unknown property \"".concat(objectKey, "\"")));
      continue;
    }

    errors = errors.concat(validateElement({
      key: (key ? "".concat(key, ".") : key) + objectKey,
      value: object[objectKey],
      valueSpec: elementSpec,
      style: style,
      styleSpec: styleSpec,
      object: object,
      objectKey: objectKey
    }, object));
  }

  for (var _elementSpecKey in elementSpecs) {
    if (elementValidators[_elementSpecKey]) {
      continue;
    }

    if (elementSpecs[_elementSpecKey].required && elementSpecs[_elementSpecKey]['default'] === undefined && object[_elementSpecKey] === undefined) {
      errors.push(new ValidationError(key, object, "missing required property \"".concat(_elementSpecKey, "\"")));
    }
  }

  return errors;
}

function validateArray(options) {
  var array = options.value;
  var arraySpec = options.valueSpec;
  var style = options.style;
  var styleSpec = options.styleSpec;
  var key = options.key;
  var validateArrayElement = options.arrayElementValidator || validate;

  if (getType(array) !== 'array') {
    return [new ValidationError(key, array, "array expected, ".concat(getType(array), " found"))];
  }

  if (arraySpec.length && array.length !== arraySpec.length) {
    return [new ValidationError(key, array, "array length ".concat(arraySpec.length, " expected, length ").concat(array.length, " found"))];
  }

  if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
    return [new ValidationError(key, array, "array length at least ".concat(arraySpec['min-length'], " expected, length ").concat(array.length, " found"))];
  }

  var arrayElementSpec = {
    'type': arraySpec.value,
    'values': arraySpec.values,
    'minimum': arraySpec.minimum,
    'maximum': arraySpec.maximum
  };

  if (styleSpec.$version < 7) {
    arrayElementSpec["function"] = arraySpec["function"];
  }

  if (getType(arraySpec.value) === 'object') {
    arrayElementSpec = arraySpec.value;
  }

  var errors = [];

  for (var i = 0; i < array.length; i++) {
    errors = errors.concat(validateArrayElement({
      array: array,
      arrayIndex: i,
      value: array[i],
      valueSpec: arrayElementSpec,
      style: style,
      styleSpec: styleSpec,
      key: "".concat(key, "[").concat(i, "]")
    }));
  }

  return errors;
}

function validateNumber(options) {
  var key = options.key;
  var value = options.value;
  var valueSpec = options.valueSpec;
  var type = getType(value);

  if (type === 'number' && value !== value) {
    type = 'NaN';
  }

  if (type !== 'number') {
    return [new ValidationError(key, value, "number expected, ".concat(type, " found"))];
  }

  if ('minimum' in valueSpec) {
    var specMin = valueSpec.minimum;

    if (getType(valueSpec.minimum) === 'array') {
      var i = options.arrayIndex;
      specMin = valueSpec.minimum[i];
    }

    if (value < specMin) {
      return [new ValidationError(key, value, "".concat(value, " is less than the minimum value ").concat(specMin))];
    }
  }

  if ('maximum' in valueSpec) {
    var specMax = valueSpec.maximum;

    if (getType(valueSpec.maximum) === 'array') {
      var _i9 = options.arrayIndex;
      specMax = valueSpec.maximum[_i9];
    }

    if (value > specMax) {
      return [new ValidationError(key, value, "".concat(value, " is greater than the maximum value ").concat(specMax))];
    }
  }

  return [];
}

function validateFunction(options) {
  var functionValueSpec = options.valueSpec;
  var functionType = unbundle(options.value.type);
  var stopKeyType;
  var stopDomainValues = {};
  var previousStopDomainValue;
  var previousStopDomainZoom;
  var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
  var isPropertyFunction = !isZoomFunction;
  var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';
  var errors = validateObject({
    key: options.key,
    value: options.value,
    valueSpec: options.styleSpec["function"],
    style: options.style,
    styleSpec: options.styleSpec,
    objectElementValidators: {
      stops: validateFunctionStops,
      "default": validateFunctionDefault
    }
  });

  if (functionType === 'identity' && isZoomFunction) {
    errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
  }

  if (functionType !== 'identity' && !options.value.stops) {
    errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
  }

  if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
    errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
  }

  if (options.styleSpec.$version >= 8) {
    if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
      errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
    } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
      errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
    }
  }

  if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
    errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
  }

  return errors;

  function validateFunctionStops(options) {
    if (functionType === 'identity') {
      return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
    }

    var errors = [];
    var value = options.value;
    errors = errors.concat(validateArray({
      key: options.key,
      value: value,
      valueSpec: options.valueSpec,
      style: options.style,
      styleSpec: options.styleSpec,
      arrayElementValidator: validateFunctionStop
    }));

    if (getType(value) === 'array' && value.length === 0) {
      errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
    }

    return errors;
  }

  function validateFunctionStop(options) {
    var errors = [];
    var value = options.value;
    var key = options.key;

    if (getType(value) !== 'array') {
      return [new ValidationError(key, value, "array expected, ".concat(getType(value), " found"))];
    }

    if (value.length !== 2) {
      return [new ValidationError(key, value, "array length 2 expected, length ".concat(value.length, " found"))];
    }

    if (isZoomAndPropertyFunction) {
      if (getType(value[0]) !== 'object') {
        return [new ValidationError(key, value, "object expected, ".concat(getType(value[0]), " found"))];
      }

      if (value[0].zoom === undefined) {
        return [new ValidationError(key, value, 'object stop key must have zoom')];
      }

      if (value[0].value === undefined) {
        return [new ValidationError(key, value, 'object stop key must have value')];
      }

      if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
        return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
      }

      if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
        previousStopDomainZoom = unbundle(value[0].zoom);
        previousStopDomainValue = undefined;
        stopDomainValues = {};
      }

      errors = errors.concat(validateObject({
        key: "".concat(key, "[0]"),
        value: value[0],
        valueSpec: {
          zoom: {}
        },
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
          zoom: validateNumber,
          value: validateStopDomainValue
        }
      }));
    } else {
      errors = errors.concat(validateStopDomainValue({
        key: "".concat(key, "[0]"),
        value: value[0],
        valueSpec: {},
        style: options.style,
        styleSpec: options.styleSpec
      }, value));
    }

    if (isExpression(deepUnbundle(value[1]))) {
      return errors.concat([new ValidationError("".concat(key, "[1]"), value[1], 'expressions are not allowed in function stops.')]);
    }

    return errors.concat(validate({
      key: "".concat(key, "[1]"),
      value: value[1],
      valueSpec: functionValueSpec,
      style: options.style,
      styleSpec: options.styleSpec
    }));
  }

  function validateStopDomainValue(options, stop) {
    var type = getType(options.value);
    var value = unbundle(options.value);
    var reportValue = options.value !== null ? options.value : stop;

    if (!stopKeyType) {
      stopKeyType = type;
    } else if (type !== stopKeyType) {
      return [new ValidationError(options.key, reportValue, "".concat(type, " stop domain type must match previous stop domain type ").concat(stopKeyType))];
    }

    if (type !== 'number' && type !== 'string' && type !== 'boolean') {
      return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
    }

    if (type !== 'number' && functionType !== 'categorical') {
      var message = "number expected, ".concat(type, " found");

      if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {
        message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
      }

      return [new ValidationError(options.key, reportValue, message)];
    }

    if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
      return [new ValidationError(options.key, reportValue, "integer expected, found ".concat(value))];
    }

    if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
      return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
    } else {
      previousStopDomainValue = value;
    }

    if (functionType === 'categorical' && value in stopDomainValues) {
      return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
    } else {
      stopDomainValues[value] = true;
    }

    return [];
  }

  function validateFunctionDefault(options) {
    return validate({
      key: options.key,
      value: options.value,
      valueSpec: functionValueSpec,
      style: options.style,
      styleSpec: options.styleSpec
    });
  }
}

function validateExpression(options) {
  var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);

  if (expression.result === 'error') {
    return expression.value.map(function (error) {
      return new ValidationError("".concat(options.key).concat(error.key), options.value, error.message);
    });
  }

  var expressionObj = expression.value.expression || expression.value._styleExpression.expression;

  if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && !expressionObj.outputDefined()) {
    return [new ValidationError(options.key, options.value, "Invalid data expression for \"".concat(options.propertyKey, "\". Output values must be contained as literals within the expression."))];
  }

  if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {
    return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
  }

  if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {
    return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with filters.')];
  }

  if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {
    if (!isGlobalPropertyConstant(expressionObj, ['zoom', 'feature-state'])) {
      return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    }

    if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {
      return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
    }
  }

  return [];
}

function validateBoolean(options) {
  var value = options.value;
  var key = options.key;
  var type = getType(value);

  if (type !== 'boolean') {
    return [new ValidationError(key, value, "boolean expected, ".concat(type, " found"))];
  }

  return [];
}

function validateColor(options) {
  var key = options.key;
  var value = options.value;
  var type = getType(value);

  if (type !== 'string') {
    return [new ValidationError(key, value, "color expected, ".concat(type, " found"))];
  }

  if (csscolorparser.parseCSSColor(value) === null) {
    return [new ValidationError(key, value, "color expected, \"".concat(value, "\" found"))];
  }

  return [];
}

function validateEnum(options) {
  var key = options.key;
  var value = options.value;
  var valueSpec = options.valueSpec;
  var errors = [];

  if (Array.isArray(valueSpec.values)) {
    if (valueSpec.values.indexOf(unbundle(value)) === -1) {
      errors.push(new ValidationError(key, value, "expected one of [".concat(valueSpec.values.join(', '), "], ").concat(JSON.stringify(value), " found")));
    }
  } else {
    if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
      errors.push(new ValidationError(key, value, "expected one of [".concat(Object.keys(valueSpec.values).join(', '), "], ").concat(JSON.stringify(value), " found")));
    }
  }

  return errors;
}

function validateFilter(options) {
  if (isExpressionFilter(deepUnbundle(options.value))) {
    return validateExpression(extend({}, options, {
      expressionContext: 'filter',
      valueSpec: {
        value: 'boolean'
      }
    }));
  } else {
    return validateNonExpressionFilter(options);
  }
}

function validateNonExpressionFilter(options) {
  var value = options.value;
  var key = options.key;

  if (getType(value) !== 'array') {
    return [new ValidationError(key, value, "array expected, ".concat(getType(value), " found"))];
  }

  var styleSpec = options.styleSpec;
  var type;
  var errors = [];

  if (value.length < 1) {
    return [new ValidationError(key, value, 'filter array must have at least 1 element')];
  }

  errors = errors.concat(validateEnum({
    key: "".concat(key, "[0]"),
    value: value[0],
    valueSpec: styleSpec.filter_operator,
    style: options.style,
    styleSpec: options.styleSpec
  }));

  switch (unbundle(value[0])) {
    case '<':
    case '<=':
    case '>':
    case '>=':
      if (value.length >= 2 && unbundle(value[1]) === '$type') {
        errors.push(new ValidationError(key, value, "\"$type\" cannot be use with operator \"".concat(value[0], "\"")));
      }

    case '==':
    case '!=':
      if (value.length !== 3) {
        errors.push(new ValidationError(key, value, "filter array for operator \"".concat(value[0], "\" must have 3 elements")));
      }

    case 'in':
    case '!in':
      if (value.length >= 2) {
        type = getType(value[1]);

        if (type !== 'string') {
          errors.push(new ValidationError("".concat(key, "[1]"), value[1], "string expected, ".concat(type, " found")));
        }
      }

      for (var i = 2; i < value.length; i++) {
        type = getType(value[i]);

        if (unbundle(value[1]) === '$type') {
          errors = errors.concat(validateEnum({
            key: "".concat(key, "[").concat(i, "]"),
            value: value[i],
            valueSpec: styleSpec.geometry_type,
            style: options.style,
            styleSpec: options.styleSpec
          }));
        } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
          errors.push(new ValidationError("".concat(key, "[").concat(i, "]"), value[i], "string, number, or boolean expected, ".concat(type, " found")));
        }
      }

      break;

    case 'any':
    case 'all':
    case 'none':
      for (var _i10 = 1; _i10 < value.length; _i10++) {
        errors = errors.concat(validateNonExpressionFilter({
          key: "".concat(key, "[").concat(_i10, "]"),
          value: value[_i10],
          style: options.style,
          styleSpec: options.styleSpec
        }));
      }

      break;

    case 'has':
    case '!has':
      type = getType(value[1]);

      if (value.length !== 2) {
        errors.push(new ValidationError(key, value, "filter array for \"".concat(value[0], "\" operator must have 2 elements")));
      } else if (type !== 'string') {
        errors.push(new ValidationError("".concat(key, "[1]"), value[1], "string expected, ".concat(type, " found")));
      }

      break;

    case 'within':
      type = getType(value[1]);

      if (value.length !== 2) {
        errors.push(new ValidationError(key, value, "filter array for \"".concat(value[0], "\" operator must have 2 elements")));
      } else if (type !== 'object') {
        errors.push(new ValidationError("".concat(key, "[1]"), value[1], "object expected, ".concat(type, " found")));
      }

      break;
  }

  return errors;
}

function validateProperty(options, propertyType) {
  var key = options.key;
  var style = options.style;
  var styleSpec = options.styleSpec;
  var value = options.value;
  var propertyKey = options.objectKey;
  var layerSpec = styleSpec["".concat(propertyType, "_").concat(options.layerType)];
  if (!layerSpec) return [];
  var transitionMatch = propertyKey.match(/^(.*)-transition$/);

  if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
    return validate({
      key: key,
      value: value,
      valueSpec: styleSpec.transition,
      style: style,
      styleSpec: styleSpec
    });
  }

  var valueSpec = options.valueSpec || layerSpec[propertyKey];

  if (!valueSpec) {
    return [new ValidationError(key, value, "unknown property \"".concat(propertyKey, "\""))];
  }

  var tokenMatch;

  if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
    return [new ValidationError(key, value, "\"".concat(propertyKey, "\" does not support interpolation syntax\n") + "Use an identity property function instead: `{ \"type\": \"identity\", \"property\": ".concat(JSON.stringify(tokenMatch[1]), " }`."))];
  }

  var errors = [];

  if (options.layerType === 'symbol') {
    if (propertyKey === 'text-field' && style && !style.glyphs) {
      errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
    }

    if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {
      errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
    }
  }

  return errors.concat(validate({
    key: options.key,
    value: value,
    valueSpec: valueSpec,
    style: style,
    styleSpec: styleSpec,
    expressionContext: 'property',
    propertyType: propertyType,
    propertyKey: propertyKey
  }));
}

function validatePaintProperty(options) {
  return validateProperty(options, 'paint');
}

function validateLayoutProperty(options) {
  return validateProperty(options, 'layout');
}

function validateLayer(options) {
  var errors = [];
  var layer = options.value;
  var key = options.key;
  var style = options.style;
  var styleSpec = options.styleSpec;

  if (!layer.type && !layer.ref) {
    errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
  }

  var type = unbundle(layer.type);
  var ref = unbundle(layer.ref);

  if (layer.id) {
    var layerId = unbundle(layer.id);

    for (var i = 0; i < options.arrayIndex; i++) {
      var otherLayer = style.layers[i];

      if (unbundle(otherLayer.id) === layerId) {
        errors.push(new ValidationError(key, layer.id, "duplicate layer id \"".concat(layer.id, "\", previously used at line ").concat(otherLayer.id.__line__)));
      }
    }
  }

  if ('ref' in layer) {
    ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
      if (p in layer) {
        errors.push(new ValidationError(key, layer[p], "\"".concat(p, "\" is prohibited for ref layers")));
      }
    });
    var parent;
    style.layers.forEach(function (layer) {
      if (unbundle(layer.id) === ref) parent = layer;
    });

    if (!parent) {
      errors.push(new ValidationError(key, layer.ref, "ref layer \"".concat(ref, "\" not found")));
    } else if (parent.ref) {
      errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
    } else {
      type = unbundle(parent.type);
    }
  } else if (!(type === 'background' || type === 'sky')) {
    if (!layer.source) {
      errors.push(new ValidationError(key, layer, 'missing required property "source"'));
    } else {
      var _source2 = style.sources && style.sources[layer.source];

      var sourceType = _source2 && unbundle(_source2.type);

      if (!_source2) {
        errors.push(new ValidationError(key, layer.source, "source \"".concat(layer.source, "\" not found")));
      } else if (sourceType === 'vector' && type === 'raster') {
        errors.push(new ValidationError(key, layer.source, "layer \"".concat(layer.id, "\" requires a raster source")));
      } else if (sourceType === 'raster' && type !== 'raster') {
        errors.push(new ValidationError(key, layer.source, "layer \"".concat(layer.id, "\" requires a vector source")));
      } else if (sourceType === 'vector' && !layer['source-layer']) {
        errors.push(new ValidationError(key, layer, "layer \"".concat(layer.id, "\" must specify a \"source-layer\"")));
      } else if (sourceType === 'raster-dem' && type !== 'hillshade') {
        errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \'hillshade\'.'));
      } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !_source2.lineMetrics)) {
        errors.push(new ValidationError(key, layer, "layer \"".concat(layer.id, "\" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.")));
      }
    }
  }

  errors = errors.concat(validateObject({
    key: key,
    value: layer,
    valueSpec: styleSpec.layer,
    style: options.style,
    styleSpec: options.styleSpec,
    objectElementValidators: {
      '*': function _() {
        return [];
      },
      type: function type() {
        return validate({
          key: "".concat(key, ".type"),
          value: layer.type,
          valueSpec: styleSpec.layer.type,
          style: options.style,
          styleSpec: options.styleSpec,
          object: layer,
          objectKey: 'type'
        });
      },
      filter: validateFilter,
      layout: function layout(options) {
        return validateObject({
          layer: layer,
          key: options.key,
          value: options.value,
          style: options.style,
          styleSpec: options.styleSpec,
          objectElementValidators: {
            '*': function _(options) {
              return validateLayoutProperty(extend({
                layerType: type
              }, options));
            }
          }
        });
      },
      paint: function paint(options) {
        return validateObject({
          layer: layer,
          key: options.key,
          value: options.value,
          style: options.style,
          styleSpec: options.styleSpec,
          objectElementValidators: {
            '*': function _(options) {
              return validatePaintProperty(extend({
                layerType: type
              }, options));
            }
          }
        });
      }
    }
  }));
  return errors;
}

function validateString(options) {
  var value = options.value;
  var key = options.key;
  var type = getType(value);

  if (type !== 'string') {
    return [new ValidationError(key, value, "string expected, ".concat(type, " found"))];
  }

  return [];
}

var objectElementValidators = {
  promoteId: validatePromoteId
};

function validateSource(options) {
  var value = options.value;
  var key = options.key;
  var styleSpec = options.styleSpec;
  var style = options.style;

  if (!value.type) {
    return [new ValidationError(key, value, '"type" is required')];
  }

  var type = unbundle(value.type);
  var errors;

  switch (type) {
    case 'vector':
    case 'raster':
    case 'raster-dem':
      errors = validateObject({
        key: key,
        value: value,
        valueSpec: styleSpec["source_".concat(type.replace('-', '_'))],
        style: options.style,
        styleSpec: styleSpec,
        objectElementValidators: objectElementValidators
      });
      return errors;

    case 'geojson':
      errors = validateObject({
        key: key,
        value: value,
        valueSpec: styleSpec.source_geojson,
        style: style,
        styleSpec: styleSpec,
        objectElementValidators: objectElementValidators
      });

      if (value.cluster) {
        for (var prop in value.clusterProperties) {
          var _errors, _errors2;

          var _value$clusterPropert = _slicedToArray(value.clusterProperties[prop], 2),
              operator = _value$clusterPropert[0],
              mapExpr = _value$clusterPropert[1];

          var reduceExpr = typeof operator === 'string' ? [operator, ['accumulated'], ['get', prop]] : operator;

          (_errors = errors).push.apply(_errors, _toConsumableArray(validateExpression({
            key: "".concat(key, ".").concat(prop, ".map"),
            value: mapExpr,
            expressionContext: 'cluster-map'
          })));

          (_errors2 = errors).push.apply(_errors2, _toConsumableArray(validateExpression({
            key: "".concat(key, ".").concat(prop, ".reduce"),
            value: reduceExpr,
            expressionContext: 'cluster-reduce'
          })));
        }
      }

      return errors;

    case 'video':
      return validateObject({
        key: key,
        value: value,
        valueSpec: styleSpec.source_video,
        style: style,
        styleSpec: styleSpec
      });

    case 'image':
      return validateObject({
        key: key,
        value: value,
        valueSpec: styleSpec.source_image,
        style: style,
        styleSpec: styleSpec
      });

    case 'canvas':
      return [new ValidationError(key, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", 'source.canvas')];

    default:
      return validateEnum({
        key: "".concat(key, ".type"),
        value: value.type,
        valueSpec: {
          values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image']
        },
        style: style,
        styleSpec: styleSpec
      });
  }
}

function validatePromoteId(_ref113) {
  var key = _ref113.key,
      value = _ref113.value;

  if (getType(value) === 'string') {
    return validateString({
      key: key,
      value: value
    });
  } else {
    var errors = [];

    for (var prop in value) {
      errors.push.apply(errors, _toConsumableArray(validateString({
        key: "".concat(key, ".").concat(prop),
        value: value[prop]
      })));
    }

    return errors;
  }
}

function validateLight(options) {
  var light = options.value;
  var styleSpec = options.styleSpec;
  var lightSpec = styleSpec.light;
  var style = options.style;
  var errors = [];
  var rootType = getType(light);

  if (light === undefined) {
    return errors;
  } else if (rootType !== 'object') {
    errors = errors.concat([new ValidationError('light', light, "object expected, ".concat(rootType, " found"))]);
    return errors;
  }

  for (var key in light) {
    var transitionMatch = key.match(/^(.*)-transition$/);

    if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
      errors = errors.concat(validate({
        key: key,
        value: light[key],
        valueSpec: styleSpec.transition,
        style: style,
        styleSpec: styleSpec
      }));
    } else if (lightSpec[key]) {
      errors = errors.concat(validate({
        key: key,
        value: light[key],
        valueSpec: lightSpec[key],
        style: style,
        styleSpec: styleSpec
      }));
    } else {
      errors = errors.concat([new ValidationError(key, light[key], "unknown property \"".concat(key, "\""))]);
    }
  }

  return errors;
}

function validateTerrain(options) {
  var terrain = options.value;
  var key = options.key;
  var style = options.style;
  var styleSpec = options.styleSpec;
  var terrainSpec = styleSpec.terrain;
  var errors = [];
  var rootType = getType(terrain);

  if (terrain === undefined) {
    return errors;
  } else if (rootType !== 'object') {
    errors = errors.concat([new ValidationError('terrain', terrain, "object expected, ".concat(rootType, " found"))]);
    return errors;
  }

  for (var _key6 in terrain) {
    var transitionMatch = _key6.match(/^(.*)-transition$/);

    if (transitionMatch && terrainSpec[transitionMatch[1]] && terrainSpec[transitionMatch[1]].transition) {
      errors = errors.concat(validate({
        key: _key6,
        value: terrain[_key6],
        valueSpec: styleSpec.transition,
        style: style,
        styleSpec: styleSpec
      }));
    } else if (terrainSpec[_key6]) {
      errors = errors.concat(validate({
        key: _key6,
        value: terrain[_key6],
        valueSpec: terrainSpec[_key6],
        style: style,
        styleSpec: styleSpec
      }));
    } else {
      errors = errors.concat([new ValidationError(_key6, terrain[_key6], "unknown property \"".concat(_key6, "\""))]);
    }
  }

  if (!terrain.source) {
    errors.push(new ValidationError(key, terrain, "terrain is missing required property \"source\""));
  } else {
    var _source3 = style.sources && style.sources[terrain.source];

    var sourceType = _source3 && unbundle(_source3.type);

    if (!_source3) {
      errors.push(new ValidationError(key, terrain.source, "source \"".concat(terrain.source, "\" not found")));
    } else if (sourceType !== 'raster-dem') {
      errors.push(new ValidationError(key, terrain.source, "terrain cannot be used with a source of type ".concat(sourceType, ", it only be used with a \"raster-dem\" source type")));
    }
  }

  return errors;
}

function validateFog(options) {
  var fog = options.value;
  var style = options.style;
  var styleSpec = options.styleSpec;
  var fogSpec = styleSpec.fog;
  var errors = [];
  var rootType = getType(fog);

  if (fog === undefined) {
    return errors;
  } else if (rootType !== 'object') {
    errors = errors.concat([new ValidationError('fog', fog, "object expected, ".concat(rootType, " found"))]);
    return errors;
  }

  for (var key in fog) {
    var transitionMatch = key.match(/^(.*)-transition$/);

    if (transitionMatch && fogSpec[transitionMatch[1]] && fogSpec[transitionMatch[1]].transition) {
      errors = errors.concat(validate({
        key: key,
        value: fog[key],
        valueSpec: styleSpec.transition,
        style: style,
        styleSpec: styleSpec
      }));
    } else if (fogSpec[key]) {
      errors = errors.concat(validate({
        key: key,
        value: fog[key],
        valueSpec: fogSpec[key],
        style: style,
        styleSpec: styleSpec
      }));
    } else {
      errors = errors.concat([new ValidationError(key, fog[key], "unknown property \"".concat(key, "\""))]);
    }
  }

  return errors;
}

function validateFormatted(options) {
  if (validateString(options).length === 0) {
    return [];
  }

  return validateExpression(options);
}

function validateImage(options) {
  if (validateString(options).length === 0) {
    return [];
  }

  return validateExpression(options);
}

var VALIDATORS = {
  '*': function _() {
    return [];
  },
  'array': validateArray,
  'boolean': validateBoolean,
  'number': validateNumber,
  'color': validateColor,
  'constants': validateConstants,
  'enum': validateEnum,
  'filter': validateFilter,
  'function': validateFunction,
  'layer': validateLayer,
  'object': validateObject,
  'source': validateSource,
  'light': validateLight,
  'terrain': validateTerrain,
  'fog': validateFog,
  'string': validateString,
  'formatted': validateFormatted,
  'resolvedImage': validateImage
};

function validate(options) {
  var value = options.value;
  var valueSpec = options.valueSpec;
  var styleSpec = options.styleSpec;

  if (valueSpec.expression && isFunction$1(unbundle(value))) {
    return validateFunction(options);
  } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
    return validateExpression(options);
  } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
    return VALIDATORS[valueSpec.type](options);
  } else {
    var valid = validateObject(extend({}, options, {
      valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec
    }));
    return valid;
  }
}

function validateGlyphsURL(options) {
  var value = options.value;
  var key = options.key;
  var errors = validateString(options);
  if (errors.length) return errors;

  if (value.indexOf('{fontstack}') === -1) {
    errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
  }

  if (value.indexOf('{range}') === -1) {
    errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
  }

  return errors;
}

function validateStyleMin(style) {
  var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;
  var errors = [];
  errors = errors.concat(validate({
    key: '',
    value: style,
    valueSpec: styleSpec.$root,
    styleSpec: styleSpec,
    style: style,
    objectElementValidators: {
      glyphs: validateGlyphsURL,
      '*': function _() {
        return [];
      }
    }
  }));

  if (style.constants) {
    errors = errors.concat(validateConstants({
      key: 'constants',
      value: style.constants,
      style: style,
      styleSpec: styleSpec
    }));
  }

  return sortErrors(errors);
}

validateStyleMin.source = wrapCleanErrors(validateSource);
validateStyleMin.light = wrapCleanErrors(validateLight);
validateStyleMin.terrain = wrapCleanErrors(validateTerrain);
validateStyleMin.fog = wrapCleanErrors(validateFog);
validateStyleMin.layer = wrapCleanErrors(validateLayer);
validateStyleMin.filter = wrapCleanErrors(validateFilter);
validateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);
validateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);

function sortErrors(errors) {
  return [].concat(errors).sort(function (a, b) {
    return a.line - b.line;
  });
}

function wrapCleanErrors(inner) {
  return function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key7 = 0; _key7 < _len4; _key7++) {
      args[_key7] = arguments[_key7];
    }

    return sortErrors(inner.apply(this, args));
  };
}
/* parser generated by jison 0.4.15 */


var jsonlint = createCommonjsModule(function (module, exports) {
  /*
    Returns a Parser object of the following structure:
  
    Parser: {
      yy: {}
    }
  
    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),
  
      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),
  
          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },
  
          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }
  
  
    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }
  
  
    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var parser = function () {
    var o = function o(k, v, _o, l) {
      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
        ;
      }

      return _o;
    },
        $V0 = [1, 12],
        $V1 = [1, 13],
        $V2 = [1, 9],
        $V3 = [1, 10],
        $V4 = [1, 11],
        $V5 = [1, 14],
        $V6 = [1, 15],
        $V7 = [14, 18, 22, 24],
        $V8 = [18, 22],
        $V9 = [22, 24];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "JSONString": 3,
        "STRING": 4,
        "JSONNumber": 5,
        "NUMBER": 6,
        "JSONNullLiteral": 7,
        "NULL": 8,
        "JSONBooleanLiteral": 9,
        "TRUE": 10,
        "FALSE": 11,
        "JSONText": 12,
        "JSONValue": 13,
        "EOF": 14,
        "JSONObject": 15,
        "JSONArray": 16,
        "{": 17,
        "}": 18,
        "JSONMemberList": 19,
        "JSONMember": 20,
        ":": 21,
        ",": 22,
        "[": 23,
        "]": 24,
        "JSONElementList": 25,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        4: "STRING",
        6: "NUMBER",
        8: "NULL",
        10: "TRUE",
        11: "FALSE",
        14: "EOF",
        17: "{",
        18: "}",
        21: ":",
        22: ",",
        23: "[",
        24: "]"
      },
      productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
      /* action[1] */
      , $$
      /* vstack */
      , _$
      /* lstack */
      ) {
        /* this == yyval */
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
            // replace escaped characters with actual character
            this.$ = new String(yytext.replace(/\\(\\|")/g, "$" + "1").replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\v/g, '\v').replace(/\\f/g, '\f').replace(/\\b/g, '\b'));
            this.$.__line__ = this._$.first_line;
            break;

          case 2:
            this.$ = new Number(yytext);
            this.$.__line__ = this._$.first_line;
            break;

          case 3:
            this.$ = null;
            break;

          case 4:
            this.$ = new Boolean(true);
            this.$.__line__ = this._$.first_line;
            break;

          case 5:
            this.$ = new Boolean(false);
            this.$.__line__ = this._$.first_line;
            break;

          case 6:
            return this.$ = $$[$0 - 1];

          case 13:
            this.$ = {};
            Object.defineProperty(this.$, '__line__', {
              value: this._$.first_line,
              enumerable: false
            });
            break;

          case 14:
          case 19:
            this.$ = $$[$0 - 1];
            Object.defineProperty(this.$, '__line__', {
              value: this._$.first_line,
              enumerable: false
            });
            break;

          case 15:
            this.$ = [$$[$0 - 2], $$[$0]];
            break;

          case 16:
            this.$ = {};
            this.$[$$[$0][0]] = $$[$0][1];
            break;

          case 17:
            this.$ = $$[$0 - 2];
            $$[$0 - 2][$$[$0][0]] = $$[$0][1];
            break;

          case 18:
            this.$ = [];
            Object.defineProperty(this.$, '__line__', {
              value: this._$.first_line,
              enumerable: false
            });
            break;

          case 20:
            this.$ = [$$[$0]];
            break;

          case 21:
            this.$ = $$[$0 - 2];
            $$[$0 - 2].push($$[$0]);
            break;
        }
      },
      table: [{
        3: 5,
        4: $V0,
        5: 6,
        6: $V1,
        7: 3,
        8: $V2,
        9: 4,
        10: $V3,
        11: $V4,
        12: 1,
        13: 2,
        15: 7,
        16: 8,
        17: $V5,
        23: $V6
      }, {
        1: [3]
      }, {
        14: [1, 16]
      }, o($V7, [2, 7]), o($V7, [2, 8]), o($V7, [2, 9]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), o($V7, [2, 3]), o($V7, [2, 4]), o($V7, [2, 5]), o([14, 18, 21, 22, 24], [2, 1]), o($V7, [2, 2]), {
        3: 20,
        4: $V0,
        18: [1, 17],
        19: 18,
        20: 19
      }, {
        3: 5,
        4: $V0,
        5: 6,
        6: $V1,
        7: 3,
        8: $V2,
        9: 4,
        10: $V3,
        11: $V4,
        13: 23,
        15: 7,
        16: 8,
        17: $V5,
        23: $V6,
        24: [1, 21],
        25: 22
      }, {
        1: [2, 6]
      }, o($V7, [2, 13]), {
        18: [1, 24],
        22: [1, 25]
      }, o($V8, [2, 16]), {
        21: [1, 26]
      }, o($V7, [2, 18]), {
        22: [1, 28],
        24: [1, 27]
      }, o($V9, [2, 20]), o($V7, [2, 14]), {
        3: 20,
        4: $V0,
        20: 29
      }, {
        3: 5,
        4: $V0,
        5: 6,
        6: $V1,
        7: 3,
        8: $V2,
        9: 4,
        10: $V3,
        11: $V4,
        13: 30,
        15: 7,
        16: 8,
        17: $V5,
        23: $V6
      }, o($V7, [2, 19]), {
        3: 5,
        4: $V0,
        5: 6,
        6: $V1,
        7: 3,
        8: $V2,
        9: 4,
        10: $V3,
        11: $V4,
        13: 31,
        15: 7,
        16: 8,
        17: $V5,
        23: $V6
      }, o($V8, [2, 17]), o($V8, [2, 15]), o($V9, [2, 21])],
      defaultActions: {
        16: [2, 6]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          throw new Error(str);
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        function lex() {
          var token;
          token = lexer.lex() || EOF;

          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }

          return token;
        }

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push('\'' + this.terminals_[p] + '\'');
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }
              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* generated by jison-lex 0.3.4 */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        // resets the lexer, sets new input
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        // consumes and returns one char from the input
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        // unshifts one char (or a string) into the input
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function more() {
          this._more = true;
          return this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        // retain first n characters of the match
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false; // rule action called reject() implying the next rule should be tested instead.
          }

          return false;
        },
        // return next match in input
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


            return false;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        // return next match that has a token
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              /* skip whitespace */
              break;

            case 1:
              return 6;

            case 2:
              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
              return 4;

            case 3:
              return 17;

            case 4:
              return 18;

            case 5:
              return 23;

            case 6:
              return 24;

            case 7:
              return 22;

            case 8:
              return 21;

            case 9:
              return 10;

            case 10:
              return 11;

            case 11:
              return 8;

            case 12:
              return 14;

            case 13:
              return 'INVALID';
          }
        },
        rules: [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/],
        conditions: {
          "INITIAL": {
            "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
            "inclusive": true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
    exports.parser = parser;
    exports.Parser = parser.Parser;

    exports.parse = function () {
      return parser.parse.apply(parser, arguments);
    };
  }
});

function readStyle(style) {
  if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {
    try {
      return jsonlint.parse(style.toString());
    } catch (e) {
      throw new ParsingError$1(e);
    }
  }

  return style;
}

function validateStyle(style) {
  var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;
  var s = style;

  try {
    s = readStyle(s);
  } catch (e) {
    return [e];
  }

  return validateStyleMin(s, styleSpec);
}

var SUPPORTED_SPEC_VERSION = 8;
var MAX_SOURCES_IN_STYLE = 15;

function isValid(value, regex) {
  if (!value || getType(value) !== 'string') return true;
  return !!value.match(regex);
}

function getSourceCount(source) {
  if (source.url) {
    return source.url.split(',').length;
  } else {
    return 0;
  }
}

function getAllowedKeyErrors(obj, keys, path) {
  var allowed = new Set(keys);
  var errors = [];
  Object.keys(obj).forEach(function (k) {
    if (!allowed.has(k)) {
      var prop = path ? "".concat(path, ".").concat(k) : null;
      errors.push(new ValidationError(prop, obj[k], "Unsupported property \"".concat(k, "\"")));
    }
  });
  return errors;
}

var acceptedSourceTypes = new Set(['vector', 'raster', 'raster-dem']);

function getSourceErrors(source, i) {
  var errors = [];
  var sourceKeys = ['type', 'url', 'tileSize'];
  errors.push.apply(errors, _toConsumableArray(getAllowedKeyErrors(source, sourceKeys, 'source')));

  if (!acceptedSourceTypes.has(String(source.type))) {
    errors.push(new ValidationError("sources[".concat(i, "].type"), source.type, "Expected one of [".concat(Array.from(acceptedSourceTypes).join(', '), "]")));
  }

  var sourceUrlPattern = /^mapbox:\/\/([^/]*)$/;

  if (!source.url || !isValid(source.url, sourceUrlPattern)) {
    errors.push(new ValidationError("sources[".concat(i, "].url"), source.url, 'Expected a valid Mapbox tileset url'));
  }

  return errors;
}

function getSourcesErrors(sources) {
  var errors = [];
  var count = 0;
  Object.keys(sources).forEach(function (s, i) {
    var sourceErrors = getSourceErrors(sources[s], i);

    if (!sourceErrors.length) {
      count = count + getSourceCount(sources[s]);
    }

    errors.push.apply(errors, _toConsumableArray(sourceErrors));
  });

  if (count > MAX_SOURCES_IN_STYLE) {
    errors.push(new ValidationError('sources', null, "Styles must contain ".concat(MAX_SOURCES_IN_STYLE, " or fewer sources")));
  }

  return errors;
}

function getRootErrors(style, specKeys) {
  var errors = [];
  var optionalRootProperties = ['owner', 'id', 'cacheControl', 'draft', 'created', 'modified', 'visibility'];
  var allowedKeyErrors = getAllowedKeyErrors(style, [].concat(_toConsumableArray(specKeys), optionalRootProperties));
  errors.push.apply(errors, _toConsumableArray(allowedKeyErrors));

  if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {
    errors.push(new ValidationError('version', style.version, "Style version must be ".concat(SUPPORTED_SPEC_VERSION)));
  }

  var glyphUrlPattern = /^mapbox:\/\/fonts\/([^/]*)\/{fontstack}\/{range}.pbf$/;

  if (!isValid(style.glyphs, glyphUrlPattern)) {
    errors.push(new ValidationError('glyphs', style.glyphs, 'Styles must reference glyphs hosted by Mapbox'));
  }

  var spriteUrlPattern = /^mapbox:\/\/sprites\/([^/]*)\/([^/]*)\/?([^/]*)?$/;

  if (!isValid(style.sprite, spriteUrlPattern)) {
    errors.push(new ValidationError('sprite', style.sprite, 'Styles must reference sprites hosted by Mapbox'));
  }

  var visibilityPattern = /^(public|private)$/;

  if (!isValid(style.visibility, visibilityPattern)) {
    errors.push(new ValidationError('visibility', style.visibility, 'Style visibility must be public or private'));
  }

  return errors;
}

function validateMapboxApiSupported(style) {
  var s = style;

  try {
    s = readStyle(s);
  } catch (e) {
    return [e];
  }

  var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));

  if (s.sources) {
    errors = errors.concat(getSourcesErrors(s.sources));
  }

  return errors;
}

var expression$1 = {
  StyleExpression: StyleExpression,
  isExpression: isExpression,
  isExpressionFilter: isExpressionFilter,
  createExpression: createExpression,
  createPropertyExpression: createPropertyExpression,
  normalizePropertyExpression: normalizePropertyExpression,
  ZoomConstantExpression: ZoomConstantExpression,
  ZoomDependentExpression: ZoomDependentExpression,
  StylePropertyFunction: StylePropertyFunction
};
var styleFunction = {
  convertFunction: convertFunction,
  createFunction: createFunction,
  isFunction: isFunction$1
};
var visit = {
  eachSource: eachSource,
  eachLayer: eachLayer,
  eachProperty: eachProperty
};
validateStyle.parsed = validateStyle;
validateStyle.latest = validateStyle;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(62), __webpack_require__(254).Buffer))

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(255)
var ieee754 = __webpack_require__(256)
var isArray = __webpack_require__(257)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(62)))

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 256 */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 257 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultResolutions", function() { return defaultResolutions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return createCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getZoomForResolution", function() { return getZoomForResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyLetterSpacing", function() { return applyLetterSpacing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapText", function() { return wrapText; });
/* harmony import */ var ol_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/* harmony import */ var ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/* harmony import */ var ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(261);



/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */

var assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);

  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];

    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }

  return output;
};
function deg2rad(degrees) {
  return degrees * Math.PI / 180;
}
var defaultResolutions = function () {
  var resolutions = [];

  for (var res = 78271.51696402048; resolutions.length <= 24; res /= 2) {
    resolutions.push(res);
  }

  return resolutions;
}();
/**
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @return {HTMLCanvasElement} Canvas.
 */

function createCanvas(width, height) {
  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && typeof OffscreenCanvas !== 'undefined') {
    // eslint-disable-line
    return (
      /** @type {?} */
      new OffscreenCanvas(width, height)
    );
  } else {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
}
function getZoomForResolution(resolution, resolutions) {
  var i = 0;
  var ii = resolutions.length;

  for (; i < ii; ++i) {
    var candidate = resolutions[i];

    if (candidate < resolution && i + 1 < ii) {
      var zoomFactor = resolutions[i] / resolutions[i + 1];
      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
    }
  }

  return ii - 1;
}
var hairSpacePool = Array(256).join("\u200A");
function applyLetterSpacing(text, letterSpacing) {
  if (letterSpacing >= 0.05) {
    var textWithLetterSpacing = '';
    var lines = text.split('\n');
    var joinSpaceString = hairSpacePool.slice(0, Math.round(letterSpacing / 0.1));

    for (var l = 0, ll = lines.length; l < ll; ++l) {
      if (l > 0) {
        textWithLetterSpacing += '\n';
      }

      textWithLetterSpacing += lines[l].split('').join(joinSpaceString);
    }

    return textWithLetterSpacing;
  }

  return text;
}
var measureContext;

function getMeasureContext() {
  if (!measureContext) {
    measureContext = createCanvas(1, 1).getContext('2d');
  }

  return measureContext;
}

function measureText(text, letterSpacing) {
  return getMeasureContext().measureText(text).width + (text.length - 1) * letterSpacing;
}

var measureCache = {};

if (ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_1__["labelCache"]) {
  // Only available when using ES modules
  //@ts-ignore
  Object(ol_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_1__["labelCache"], ol_events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLEAR, function () {
    measureCache = {};
  });
}

function wrapText(text, font, em, letterSpacing) {
  if (text.indexOf('\n') !== -1) {
    var hardLines = text.split('\n');
    var lines = [];

    for (var i = 0, ii = hardLines.length; i < ii; ++i) {
      lines.push(wrapText(hardLines[i], font, em, letterSpacing));
    }

    return lines.join('\n');
  }

  var key = em + ',' + font + ',' + text + ',' + letterSpacing;
  var wrappedText = measureCache[key];

  if (!wrappedText) {
    var words = text.split(' ');

    if (words.length > 1) {
      var ctx = getMeasureContext();
      ctx.font = font;
      var oneEm = ctx.measureText('M').width;
      var maxWidth = oneEm * em;
      var line = '';
      var lines = []; // Pass 1 - wrap lines to not exceed maxWidth

      for (var i = 0, ii = words.length; i < ii; ++i) {
        var word = words[i];
        var testLine = line + (line ? ' ' : '') + word;

        if (measureText(testLine, letterSpacing) <= maxWidth) {
          line = testLine;
        } else {
          if (line) {
            lines.push(line);
          }

          line = word;
        }
      }

      if (line) {
        lines.push(line);
      } // Pass 2 - add lines with a width of less than 30% of maxWidth to the previous or next line


      for (var i = 0, ii = lines.length; i < ii && ii > 1; ++i) {
        var line_1 = lines[i];

        if (measureText(line_1, letterSpacing) < maxWidth * 0.35) {
          var prevWidth = i > 0 ? measureText(lines[i - 1], letterSpacing) : Infinity;
          var nextWidth = i < ii - 1 ? measureText(lines[i + 1], letterSpacing) : Infinity;
          lines.splice(i, 1);
          ii -= 1;

          if (prevWidth < nextWidth) {
            lines[i - 1] += ' ' + line_1;
            i -= 1;
          } else {
            lines[i] = line_1 + ' ' + lines[i];
          }
        }
      } // Pass 3 - try to fill 80% of maxWidth for each line


      for (var i = 0, ii = lines.length - 1; i < ii; ++i) {
        var line_2 = lines[i];
        var next = lines[i + 1];

        if (measureText(line_2, letterSpacing) > maxWidth * 0.7 && measureText(next, letterSpacing) < maxWidth * 0.6) {
          var lineWords = line_2.split(' ');
          var lastWord = lineWords.pop();

          if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {
            lines[i] = lineWords.join(' ');
            lines[i + 1] = lastWord + ' ' + next;
          }

          ii -= 1;
        }
      }

      wrappedText = lines.join('\n');
    } else {
      wrappedText = text;
    }

    wrappedText = applyLetterSpacing(wrappedText, letterSpacing);
    measureCache[key] = wrappedText;
  }

  return wrappedText;
}

/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/EventType
 */
/**
 * @enum {string}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */
    CHANGE: 'change',
    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */
    ERROR: 'error',
    BLUR: 'blur',
    CLEAR: 'clear',
    CONTEXTMENU: 'contextmenu',
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DRAGENTER: 'dragenter',
    DRAGOVER: 'dragover',
    DROP: 'drop',
    FOCUS: 'focus',
    KEYDOWN: 'keydown',
    KEYPRESS: 'keypress',
    LOAD: 'load',
    RESIZE: 'resize',
    TOUCHMOVE: 'touchmove',
    WHEEL: 'wheel',
});
//# sourceMappingURL=EventType.js.map

/***/ }),
/* 260 */
/***/ (function(module, exports) {

module.exports = ol.render.canvas;

/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listen", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenOnce", function() { return listenOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenByKey", function() { return unlistenByKey; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(244);
/**
 * @module ol/events
 */

/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */
/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */
/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */
/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */
/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [opt_once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
    if (opt_this && opt_this !== target) {
        listener = listener.bind(opt_this);
    }
    if (opt_once) {
        var originalListener_1 = listener;
        listener = function () {
            target.removeEventListener(type, listener);
            originalListener_1.apply(this, arguments);
        };
    }
    var eventsKey = {
        target: target,
        type: type,
        listener: listener,
    };
    target.addEventListener(type, listener);
    return eventsKey;
}
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
    return listen(target, type, listener, opt_this, true);
}
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
    if (key && key.target) {
        key.target.removeEventListener(key.type, key.listener);
        Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(key);
    }
}
//# sourceMappingURL=events.js.map

/***/ }),
/* 262 */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.10.0
(function() {
  var families;

  module.exports = {
    icon: 'icons/google.svg',
    name: 'google',
    title: 'Google Fonts',
    link: 'google.com/fonts',
    getNames: function() {
      return families;
    },
    getLink: function(name) {
      return "https://fonts.google.com/specimen/" + (name.replace(/( )/g, '+'));
    },
    normalizeName: function(name) {
      return name;
    }
  };

  families = ["ABeeZee", "Abel", "Abril Fatface", "Aclonica", "Acme", "Actor", "Adamina", "Advent Pro", "Aguafina Script", "Akronim", "Aladin", "Aldrich", "Alef", "Alegreya", "Alegreya SC", "Alegreya Sans", "Alegreya Sans SC", "Alex Brush", "Alfa Slab One", "Alice", "Alike", "Alike Angular", "Allan", "Allerta", "Allerta Stencil", "Allura", "Almendra", "Almendra Display", "Almendra SC", "Amarante", "Amaranth", "Amatic SC", "Amethysta", "Amiri", "Amita", "Anaheim", "Andada", "Andika", "Angkor", "Annie Use Your Telescope", "Anonymous Pro", "Antic", "Antic Didone", "Antic Slab", "Anton", "Arapey", "Arbutus", "Arbutus Slab", "Architects Daughter", "Archivo Black", "Archivo Narrow", "Arimo", "Arizonia", "Armata", "Artifika", "Arvo", "Arya", "Asap", "Asar", "Asset", "Astloch", "Asul", "Atomic Age", "Aubrey", "Audiowide", "Autour One", "Average", "Average Sans", "Averia Gruesa Libre", "Averia Libre", "Averia Sans Libre", "Averia Serif Libre", "Bad Script", "Balthazar", "Bangers", "Basic", "Battambang", "Baumans", "Bayon", "Belgrano", "Belleza", "BenchNine", "Bentham", "Berkshire Swash", "Bevan", "Bigelow Rules", "Bigshot One", "Bilbo", "Bilbo Swash Caps", "Biryani", "Bitter", "Black Ops One", "Bokor", "Bonbon", "Boogaloo", "Bowlby One", "Bowlby One SC", "Brawler", "Bree Serif", "Bubblegum Sans", "Bubbler One", "Buda", "Buenard", "Butcherman", "Butterfly Kids", "Cabin", "Cabin Condensed", "Cabin Sketch", "Caesar Dressing", "Cagliostro", "Calligraffitti", "Cambay", "Cambo", "Candal", "Cantarell", "Cantata One", "Cantora One", "Capriola", "Cardo", "Carme", "Carrois Gothic", "Carrois Gothic SC", "Carter One", "Catamaran", "Caudex", "Caveat", "Caveat Brush", "Cedarville Cursive", "Ceviche One", "Changa One", "Chango", "Chau Philomene One", "Chela One", "Chelsea Market", "Chenla", "Cherry Cream Soda", "Cherry Swash", "Chewy", "Chicle", "Chivo", "Chonburi", "Cinzel", "Cinzel Decorative", "Clicker Script", "Coda", "Coda Caption", "Codystar", "Combo", "Comfortaa", "Coming Soon", "Concert One", "Condiment", "Content", "Contrail One", "Convergence", "Cookie", "Copse", "Corben", "Courgette", "Cousine", "Coustard", "Covered By Your Grace", "Crafty Girls", "Creepster", "Crete Round", "Crimson Text", "Croissant One", "Crushed", "Cuprum", "Cutive", "Cutive Mono", "Damion", "Dancing Script", "Dangrek", "Dawning of a New Day", "Days One", "Dekko", "Delius", "Delius Swash Caps", "Delius Unicase", "Della Respira", "Denk One", "Devonshire", "Dhurjati", "Didact Gothic", "Diplomata", "Diplomata SC", "Domine", "Donegal One", "Doppio One", "Dorsa", "Dosis", "Dr Sugiyama", "Droid Sans", "Droid Sans Mono", "Droid Serif", "Duru Sans", "Dynalight", "EB Garamond", "Eagle Lake", "Eater", "Economica", "Eczar", "Ek Mukta", "Electrolize", "Elsie", "Elsie Swash Caps", "Emblema One", "Emilys Candy", "Engagement", "Englebert", "Enriqueta", "Erica One", "Esteban", "Euphoria Script", "Ewert", "Exo", "Exo 2", "Expletus Sans", "Fanwood Text", "Fascinate", "Fascinate Inline", "Faster One", "Fasthand", "Fauna One", "Federant", "Federo", "Felipa", "Fenix", "Finger Paint", "Fira Mono", "Fira Sans", "Fjalla One", "Fjord One", "Flamenco", "Flavors", "Fondamento", "Fontdiner Swanky", "Forum", "Francois One", "Freckle Face", "Fredericka the Great", "Fredoka One", "Freehand", "Fresca", "Frijole", "Fruktur", "Fugaz One", "GFS Didot", "GFS Neohellenic", "Gabriela", "Gafata", "Galdeano", "Galindo", "Gentium Basic", "Gentium Book Basic", "Geo", "Geostar", "Geostar Fill", "Germania One", "Gidugu", "Gilda Display", "Give You Glory", "Glass Antiqua", "Glegoo", "Gloria Hallelujah", "Goblin One", "Gochi Hand", "Gorditas", "Goudy Bookletter 1911", "Graduate", "Grand Hotel", "Gravitas One", "Great Vibes", "Griffy", "Gruppo", "Gudea", "Gurajada", "Habibi", "Halant", "Hammersmith One", "Hanalei", "Hanalei Fill", "Handlee", "Hanuman", "Happy Monkey", "Headland One", "Henny Penny", "Herr Von Muellerhoff", "Hind", "Hind Siliguri", "Hind Vadodara", "Holtwood One SC", "Homemade Apple", "Homenaje", "IM Fell DW Pica", "IM Fell DW Pica SC", "IM Fell Double Pica", "IM Fell Double Pica SC", "IM Fell English", "IM Fell English SC", "IM Fell French Canon", "IM Fell French Canon SC", "IM Fell Great Primer", "IM Fell Great Primer SC", "Iceberg", "Iceland", "Imprima", "Inconsolata", "Inder", "Indie Flower", "Inika", "Inknut Antiqua", "Irish Grover", "Istok Web", "Italiana", "Italianno", "Itim", "Jacques Francois", "Jacques Francois Shadow", "Jaldi", "Jim Nightshade", "Jockey One", "Jolly Lodger", "Josefin Sans", "Josefin Slab", "Joti One", "Judson", "Julee", "Julius Sans One", "Junge", "Jura", "Just Another Hand", "Just Me Again Down Here", "Kadwa", "Kalam", "Kameron", "Kantumruy", "Karla", "Karma", "Kaushan Script", "Kavoon", "Kdam Thmor", "Keania One", "Kelly Slab", "Kenia", "Khand", "Khmer", "Khula", "Kite One", "Knewave", "Kotta One", "Koulen", "Kranky", "Kreon", "Kristi", "Krona One", "Kurale", "La Belle Aurore", "Laila", "Lakki Reddy", "Lancelot", "Lateef", "Lato", "League Script", "Leckerli One", "Ledger", "Lekton", "Lemon", "Libre Baskerville", "Life Savers", "Lilita One", "Lily Script One", "Limelight", "Linden Hill", "Lobster", "Lobster Two", "Londrina Outline", "Londrina Shadow", "Londrina Sketch", "Londrina Solid", "Lora", "Love Ya Like A Sister", "Loved by the King", "Lovers Quarrel", "Luckiest Guy", "Lusitana", "Lustria", "Macondo", "Macondo Swash Caps", "Magra", "Maiden Orange", "Mako", "Mallanna", "Mandali", "Marcellus", "Marcellus SC", "Marck Script", "Margarine", "Marko One", "Marmelad", "Martel", "Martel Sans", "Marvel", "Mate", "Mate SC", "Maven Pro", "McLaren", "Meddon", "MedievalSharp", "Medula One", "Megrim", "Meie Script", "Merienda", "Merienda One", "Merriweather", "Merriweather Sans", "Metal", "Metal Mania", "Metamorphous", "Metrophobic", "Michroma", "Milonga", "Miltonian", "Miltonian Tattoo", "Miniver", "Miss Fajardose", "Modak", "Modern Antiqua", "Molengo", "Molle", "Monda", "Monofett", "Monoton", "Monsieur La Doulaise", "Montaga", "Montez", "Montserrat", "Montserrat Alternates", "Montserrat Subrayada", "Moul", "Moulpali", "Mountains of Christmas", "Mouse Memoirs", "Mr Bedfort", "Mr Dafoe", "Mr De Haviland", "Mrs Saint Delafield", "Mrs Sheppards", "Muli", "Mystery Quest", "NTR", "Neucha", "Neuton", "New Rocker", "News Cycle", "Niconne", "Nixie One", "Nobile", "Nokora", "Norican", "Nosifer", "Nothing You Could Do", "Noticia Text", "Noto Sans", "Noto Serif", "Nova Cut", "Nova Flat", "Nova Mono", "Nova Oval", "Nova Round", "Nova Script", "Nova Slim", "Nova Square", "Numans", "Nunito", "Odor Mean Chey", "Offside", "Old Standard TT", "Oldenburg", "Oleo Script", "Oleo Script Swash Caps", "Open Sans", "Open Sans Condensed", "Oranienbaum", "Orbitron", "Oregano", "Orienta", "Original Surfer", "Oswald", "Over the Rainbow", "Overlock", "Overlock SC", "Ovo", "Oxygen", "Oxygen Mono", "PT Mono", "PT Sans", "PT Sans Caption", "PT Sans Narrow", "PT Serif", "PT Serif Caption", "Pacifico", "Palanquin", "Palanquin Dark", "Paprika", "Parisienne", "Passero One", "Passion One", "Pathway Gothic One", "Patrick Hand", "Patrick Hand SC", "Patua One", "Paytone One", "Peddana", "Peralta", "Permanent Marker", "Petit Formal Script", "Petrona", "Philosopher", "Piedra", "Pinyon Script", "Pirata One", "Plaster", "Play", "Playball", "Playfair Display", "Playfair Display SC", "Podkova", "Poiret One", "Poller One", "Poly", "Pompiere", "Pontano Sans", "Poppins", "Port Lligat Sans", "Port Lligat Slab", "Pragati Narrow", "Prata", "Preahvihear", "Press Start 2P", "Princess Sofia", "Prociono", "Prosto One", "Puritan", "Purple Purse", "Quando", "Quantico", "Quattrocento", "Quattrocento Sans", "Questrial", "Quicksand", "Quintessential", "Qwigley", "Racing Sans One", "Radley", "Rajdhani", "Raleway", "Raleway Dots", "Ramabhadra", "Ramaraja", "Rambla", "Rammetto One", "Ranchers", "Rancho", "Ranga", "Rationale", "Ravi Prakash", "Redressed", "Reenie Beanie", "Revalia", "Rhodium Libre", "Ribeye", "Ribeye Marrow", "Righteous", "Risque", "Roboto", "Roboto Condensed", "Roboto Mono", "Roboto Slab", "Rochester", "Rock Salt", "Rokkitt", "Romanesco", "Ropa Sans", "Rosario", "Rosarivo", "Rouge Script", "Rozha One", "Rubik", "Rubik Mono One", "Rubik One", "Ruda", "Rufina", "Ruge Boogie", "Ruluko", "Rum Raisin", "Ruslan Display", "Russo One", "Ruthie", "Rye", "Sacramento", "Sahitya", "Sail", "Salsa", "Sanchez", "Sancreek", "Sansita One", "Sarala", "Sarina", "Sarpanch", "Satisfy", "Scada", "Scheherazade", "Schoolbell", "Seaweed Script", "Sevillana", "Seymour One", "Shadows Into Light", "Shadows Into Light Two", "Shanti", "Share", "Share Tech", "Share Tech Mono", "Shojumaru", "Short Stack", "Siemreap", "Sigmar One", "Signika", "Signika Negative", "Simonetta", "Sintony", "Sirin Stencil", "Six Caps", "Skranji", "Slabo 13px", "Slabo 27px", "Slackey", "Smokum", "Smythe", "Sniglet", "Snippet", "Snowburst One", "Sofadi One", "Sofia", "Sonsie One", "Sorts Mill Goudy", "Source Code Pro", "Source Sans Pro", "Source Serif Pro", "Special Elite", "Spicy Rice", "Spinnaker", "Spirax", "Squada One", "Sree Krushnadevaraya", "Stalemate", "Stalinist One", "Stardos Stencil", "Stint Ultra Condensed", "Stint Ultra Expanded", "Stoke", "Strait", "Sue Ellen Francisco", "Sumana", "Sunshiney", "Supermercado One", "Sura", "Suranna", "Suravaram", "Suwannaphum", "Swanky and Moo Moo", "Syncopate", "Tangerine", "Taprom", "Tauri", "Teko", "Telex", "Tenali Ramakrishna", "Tenor Sans", "Text Me One", "The Girl Next Door", "Tienne", "Tillana", "Timmana", "Tinos", "Titan One", "Titillium Web", "Trade Winds", "Trocchi", "Trochut", "Trykker", "Tulpen One", "Ubuntu", "Ubuntu Condensed", "Ubuntu Mono", "Ultra", "Uncial Antiqua", "Underdog", "Unica One", "UnifrakturCook", "UnifrakturMaguntia", "Unkempt", "Unlock", "Unna", "VT323", "Vampiro One", "Varela", "Varela Round", "Vast Shadow", "Vesper Libre", "Vibur", "Vidaloka", "Viga", "Voces", "Volkhov", "Vollkorn", "Voltaire", "Waiting for the Sunrise", "Wallpoet", "Walter Turncoat", "Warnes", "Wellfleet", "Wendy One", "Wire One", "Work Sans", "Yanone Kaffeesatz", "Yantramanav", "Yellowtail", "Yeseva One", "Yesteryear", "Zeyada"];

}).call(this);


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Editor_GPeditorOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _CSS_Controls_Editor_GPeditorOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Editor_GPeditorOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(264);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);
/* harmony import */ var _Editor_Style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(266);
/* harmony import */ var _Editor_Themes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(268);
/* harmony import */ var _Editor_Filter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(269);
/* harmony import */ var _Editor_Legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(270);
/* harmony import */ var _Editor_Layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(271);
/* harmony import */ var _Editor_Group__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(272);
/* harmony import */ var _Editor_Event__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(267);
/* harmony import */ var _Common_Controls_Editor_EditorDOM__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(273);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// import CSS
 // import library

 // import local










 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("editor");
/**
 * @classdesc
 *
 * Editor Styles MapBox...
 *
 * @constructor
 * @alias ol.style.Editor
 * @param {Object} options - options for function call.
 * @fires editor:layer:onclickvisibility
 * @fires editor:layer:onclickclone
 * @fires editor:layer:onclickremove
 * @fires editor:style:oneditjson
 * @fires editor:style:scale:onchangemin
 * @fires editor:style:scale:onchangemax
 * @fires editor:legend:onclickedition
 * @fires editor:legend:onchangevalue
 * @fires editor:filter:oneditjson
 * @fires editor:themes:onclickimage
 * @fires editor:themes:onclicktitle
 * @fires editor:group:oncollapse
 * @fires editor:onloaded
 * @example
 *   var editor = new Editor ({
 *      target : "",
 *      style : "data/styles/layer.json",
 *      themes: {
 *          themesSummary : "",
 *          themes : [{
 *             "thumbnail": "data/images/layer0.png",
 *             "name": "standard0",
 *             "url": "data/styles/layer0.json",
 *             "description": "",
 *             "selected" : true
 *          },{
 *             "thumbnail": "data/images/layer1.png",
 *             "name": "standard1",
 *             "url": "data/styles/layer1.json",
 *             "description": ""
 *          }]
 *      },
 *      scope : this,
 *      events : {
 *          "editor:layer:onclickvisibility" : ...,
 *          "editor:layer:onclickclone" : ...,
 *          "editor:layer:onclickremove" : ...,
 *          "editor:style:oneditjson" : ...,
 *          "editor:style:scale:onchangemin" : ...,
 *          "editor:style:scale:onchangemax" : ...,
 *          "editor:filter:oneditjson" : ...,
 *          "editor:themes:onclickimage" : this._onClickEventImageTheme(),
 *          "editor:themes:onclicktitle" : function(e) {...}
 *      },
 *      tools : {
 *          // afficher/cacher les themes (par defaut) ou utiliser les options
 *          themes : true | false | {
 *              target : "...",
 *              tools : {
 *                  "thumbnails": true,
 *                  "button": { visible : true, type : "checkbox" }
 *              },
 *          },
 *          layers : true | false,     // afficher les couches (layers)
 *          style : true | false,      // afficher les styles (sous menu layers)
 *          filter : true | false,     // afficher les filtres (sous menu layers)
 *          legend : true | false,     // afficher les legendes (layers)
 *          group : true | false,      // grouper les couches (layers)
 *          sort : true | false,       // trier les couches (layers)
 *          title : true | false       // afficher les titres des rubriques,
 *          type : true | false,       // afficher le type de geometrie (layers)
 *          pin : true | false,        // afficher la puce pour chaque couche (layers)
 *          visibility : true | false, // afficher l'icone de visibilité (layers),
 *          icon : {                   // afficher l'icone "oeil" ou "checkbox" (layers),
 *              "image" : true,
 *              "anchor" : "start" // afficher l'icone au debut ou à la fin de la ligne
 *          },
 *          editable : true | false    // active l'edition de la legende (legendes)
 *      }
 *   });
 *   // create DOM
 *   editor.createElement()
 *     .then(() => {
 *       console.warn(editor.getID());
 *     })
 *     .catch(error => {});
 *   // possibility to add listeners with globale variable : eventbus
 *   eventbus.addEventListener("editor:style:scale:onchangemin", function (e) {...});
 */

function Editor(options) {
  logger.trace("[constructor] Editor", options); // options

  this.options = options || {// TODO default...
  };

  if (!(this instanceof Editor)) {
    throw new TypeError("ERROR CLASS_CONSTRUCTOR");
  }

  this._initialize();
}

; // on récupère les méthodes de la classe DOM

_Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].assign(Editor.prototype, _Common_Controls_Editor_EditorDOM__WEBPACK_IMPORTED_MODULE_12__["default"]);
/**
 * Constructor (alias)
 *
 * @private
 */

Editor.prototype.constructor = Editor;
/**
 * Initialize component
 * (called by constructor)
 *
 * @private
 */

Editor.prototype._initialize = function () {
  // gestion des options
  if (!this.options.target) {
    logger.info("La 'target' n'est pas renseignée (options.target).");
  }

  if (!this.options.style) {
    logger.error("Le 'style' MapBox n'est pas renseigné (options.style) !");
    return;
  }

  if (this.options.events) {
    this._initEvents();
  } else {
    logger.warn("Les 'handlers' ne sont pas renseignés (options.events) !");
  }

  if (!this.options.themes) {
    logger.info("Les 'themes' MapBox ne sont pas renseignés (options.themes).");
  } // options par defaut


  var _toolsDefault = {
    themes: false,
    layers: true,
    style: false,
    filter: false,
    legend: false,
    group: false,
    sort: true,
    title: true,
    type: true,
    pin: true,
    visibility: true,
    icon: {
      image: true,
      anchor: "end"
    },
    editable: true
  };

  if (!this.options.tools) {
    logger.trace("Utilisation des outils MapBox par défaut (options.tools).");
    this.options.tools = _toolsDefault;
  }

  _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false); // id unique

  this.id = this.options.id || _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate(); // property layers

  this.layers = []; // property container

  this.container = null; // property name

  this.name = {
    target: "GPEditorMapBoxTarget",
    container: "GPEditorMapBoxContainer",
    containerID: "GPEditorMapBoxContainer_ID_",
    containerLayers: "GPEditorMapBoxLayersContainer",
    titleLayers: "GPEditorMapBoxLayersTitle",
    titleLayersID: "GPEditorMapBoxLayersTitle_ID_",
    titleThemes: "GPEditorMapBoxThemesTitle",
    titleThemesID: "GPEditorMapBoxThemesTitle_ID_",
    sep: "GPEditorMapBoxSep"
  }; // property mapbox

  this.mapbox = {}; // property sprites :
  // {
  //     url : null,
  //     size : {
  //         h : null,
  //         w : null
  //     },
  //     json : {}
  // }

  this.sprites = {};
};
/**
* Initialize events with handlers
* (called by constructor)
*
* List Events :
*          "editor:layer:visibility"
*          "editor:layer:clone"
*          "editor:layer:remove"
*          "editor:style:edit"
*          "editor:style:minScale"
*          "editor:style:maxScale"
*          "editor:filter:edit"
*          "editor:themes:image",
*          "editor:themes:title"
* @private
*/


Editor.prototype._initEvents = function () {
  var ctx = this.options.scope || this;
  var events = this.options.events;

  if (events) {
    for (var event in events) {
      if (events.hasOwnProperty(event)) {
        var handler = events[event]; // test sur les events disponibles !

        if (handler) {
          if (!eventbusjs__WEBPACK_IMPORTED_MODULE_1___default.a.hasEventListener(event, handler, ctx)) {
            eventbusjs__WEBPACK_IMPORTED_MODULE_1___default.a.addEventListener(event, handler, ctx);
          }
        }
      }
    }
  }
};
/**
 * Graphical rendering of the component
 * (called by constructor)
 *
 * @example
 *  <div class="GPEditorMapBoxContainer" id="GPEditorMapBoxContainer_ID_0">
 *    <div id="GPEditorMapBoxThemesTitle" class="GPEditorMapBoxThemesTitle">Liste des 'thèmes'</div>
 *    <div class="GPEditorMapBoxThemesContainer">
 *      ...
 *    </div>
 *    <div id="GPEditorMapBoxLayersTitle" class="GPEditorMapBoxLayersTitle">Liste des 'couches'</div>
 *    <div class="GPEditorMapBoxLayersContainer">
 *      <div class="GPEditorMapBoxLayerContainer">
 *          <div id="GPEditorMapBoxLayerTitleContainer-0_1" class="GPEditorMapBoxLayerTitleContainer">
 *              <label class="GPEditorMapBoxLayerImageLabel"></label>
 *              <input id="GPEditorMapBoxLayerTitleInput-0_1" class="GPEditorMapBoxLayerTitleInput" type="checkbox">
 *              <label class="GPEditorMapBoxLayerTitleLabel" for="GPEditorMapBoxLayerTitleInput-0_1" title="states">population_lt_2m</label>
 *          </div>
 *      </div>
 *      <div class="GPEditorMapBoxLayerContainer">...</div>
 *      <div class="GPEditorMapBoxLayerContainer">...</div>
 *    </div>
 *  </div>
 * @private
 */


Editor.prototype._initContainer = function () {
  logger.trace(this.mapbox); // existance d'un autre container (editeur) ?
  // var _idx = 0;
  // var elements = document.querySelectorAll("div[id^=" + this.name.containerID + "]");
  // for (var j = 0; j < elements.length; j++) {
  //     var element = elements[j];
  //     var num = parseInt(element.id.substring(element.id.lastIndexOf("_") + 1), 10);
  //     if (num > _idx) {
  //         _idx = num;
  //     }
  // }
  // if (elements.length) {
  //     _idx += 1;
  // }
  // container principal de l'editeur

  var div = document.createElement("div");
  div.id = this.name.containerID + this.id;
  div.className = this.name.container; // Themes

  var _toolsThemes = this.options.tools.themes;

  if (_toolsThemes && this.options.themes) {
    // title
    if (this.options.tools.title) {
      var titleThemes = document.createElement("div");
      titleThemes.id = this.name.titleThemesID + this.id;
      titleThemes.className = this.name.titleThemes;
      titleThemes.innerHTML = "Liste des 'thèmes'";
      div.appendChild(titleThemes);
    } // lien vers les styles


    var themes = new _Editor_Themes__WEBPACK_IMPORTED_MODULE_6__["default"]({
      id: this.id,
      target: div,
      tools: _typeof(_toolsThemes) === "object" ? _toolsThemes : {},
      obj: this.options.themes
    });
    themes.add();
  }

  for (var source in this.mapbox.sources) {
    if (this.mapbox.sources.hasOwnProperty(source)) {
      if (this.options.tools.layers) {
        // multisources ? Si oui, on renseigne un titre...
        var multisources = Object.keys(this.mapbox.sources).length > 1 ? 1 : 0;

        if (multisources) {
          var hr = document.createElement("hr");
          hr.className = this.name.sep;
          div.appendChild(hr);
        } // title


        if (this.options.tools.title) {
          var titleLayers = document.createElement("div");
          titleLayers.id = this.name.titleLayersID + this.id;
          titleLayers.className = this.name.titleLayers;
          titleLayers.innerHTML = multisources ? "Liste des 'couches' (" + source + ")" : "Liste des 'couches'";
          div.appendChild(titleLayers);
        }
      } // clone


      var _layers = this.mapbox.layers.slice(); // gestion de l'ordre avant tri avec la metadata 'order'
      // une fois les layers triés, la metadata:geoportail:order permet
      // de savoir l'emplacement du layers dans le fichier de style.


      _layers.forEach(function (layer, order) {
        // on écarte les layers sans source: ex. "background"
        // if (!layer.source) {
        //     return;
        // }
        // ajout de la metadata d'ordre
        var _metadata = layer["metadata"];

        if (_metadata) {
          _metadata["geoportail:order"] = order;
        } else {
          layer["metadata"] = {
            "geoportail:order": order
          };
        }
      }); // tri des layers


      if (this.options.tools.sort) {
        _layers.sort(function (a, b) {
          // FIXME si on utilise les groupements utilisateurs, ils doivent
          // tous renseignés sinon...
          var cmpA = null;
          var cmpB = null;

          if (a["metadata"] && a["metadata"]["geoportail:group"] && b["metadata"] && b["metadata"]["geoportail:group"]) {
            cmpA = a["metadata"]["geoportail:group"];
            cmpB = b["metadata"]["geoportail:group"];
          } else {
            cmpA = a.id;
            cmpB = b.id;
          }

          if (cmpA < cmpB) {
            return -1;
          }

          if (cmpA > cmpB) {
            return 1;
          }

          return 0;
        });
      }

      logger.trace("Layers : ", _layers); // gestion des groupes avec la metadata de groupe

      var _groups = {}; // liste et comptage des layers dans les groupes

      _layers.forEach(function (layer) {
        // on écarte les layers sans source: ex. "background"
        // if (!layer.source) {
        //     return;
        // }
        // balise metadata
        var _metadata = layer["metadata"]; // s'il existe déjà une meta de groupe, on l'utilise...
        // sinon, on la met en place.

        if (_metadata && _metadata["geoportail:group"]) {
          var _groupName = _metadata["geoportail:group"];
          _groups[_groupName] = _groups[_groupName] ? _groups[_groupName] + 1 : 1;
        } else {
          var _title = layer.id; // separateur

          var _regex = /_|-|:|=/; // TODO à definir via une option !
          // index
          // y'a t il un separateur ?

          var _idx = _title.search(_regex);

          var _newGroupName = _idx !== -1 ? _title.substring(0, _idx).trim() : _title; // on compte le nombre d'entrée dans un groupe


          _groups[_newGroupName] = _groups[_newGroupName] ? _groups[_newGroupName] + 1 : 1; // ajout de la metadata de groupe

          if (_metadata) {
            _metadata["geoportail:group"] = _newGroupName;
          } else {
            layer["metadata"] = {
              "geoportail:group": _newGroupName
            };
          }
        }
      });

      logger.trace("Groups : ", _groups); // container principal des couches

      var divLayers = document.createElement("div");
      divLayers.className = this.name.containerLayers;
      div.appendChild(divLayers); // container courant (cf. groupe) pour l'ajout des elements

      var target = divLayers; // Ex. Layers, Styles, Groups et Filtres
      //  "id": "ocs - vegetation",
      //  "type": "fill",
      //  "source": "pyramide_proto",
      //  "source-layer": "ocs_vegetation_surf",
      //  "metadata" : {
      //      "geoportail:group": "ocs"
      //  },
      //  "layout": {
      //    "visibility": "visible"
      //  },
      //  "filter": ["in","symbo",
      //      "SURFACE_D_EAU",
      //      "BASSIN",
      //      "ZONE_MARINE"
      //  ],
      //  "paint": {
      //    "fill-color": "#2BB3E1"
      //  }

      var index = -1;

      for (var ii = 0; ii < _layers.length; ii++) {
        var data = _layers[ii];
        index++; // traitement dans l'ordre des sources

        if (data.source === source) {
          // FIXME la gestion des groupes est à revoir...
          // Groups
          if (this.options.tools.group) {
            var mtd = data.metadata; // creation du container de groupe
            // si le tag metadata existe

            if (mtd) {
              var grp = data.metadata["geoportail:group"];

              if (grp) {
                // le groupe doit contenir plus d'un element
                if (_groups[grp] > 1) {
                  // le groupe est déjà créé, on en veut plus par la suite...
                  _groups[grp] = -1; // creation du groupe

                  var oGroup = new _Editor_Group__WEBPACK_IMPORTED_MODULE_10__["default"]({
                    id: this.id,
                    target: divLayers,
                    title: grp,
                    collapse: true
                  });
                  oGroup.add(); // le nouveau container pour les elements suivants

                  target = oGroup.getContainer();
                } else if (_groups[grp] === 1) {
                  // l'element est seul, donc pas d'ajout dans le
                  // groupe en cours
                  target = divLayers;
                } else {// on ajoute l'element dans le groupe courant...
                }
              } else {
                target = divLayers;
              }
            } else {
              target = divLayers;
            }
          } // Layers


          if (this.options.tools.layers) {
            var oLayer = new _Editor_Layer__WEBPACK_IMPORTED_MODULE_9__["default"]({
              id: this.id,
              target: target,
              position: index + "_" + this.id,
              // unique !
              tools: {
                visibility: this.options.tools.visibility,
                icon: this.options.tools.icon,
                type: this.options.tools.type,
                pin: this.options.tools.pin
              },
              obj: {
                id: data.id,
                type: data.type,
                source: data.source,
                "source-layer": data["source-layer"]
              }
            });
            oLayer.add(); // update visibility layer

            if (data.layout && data.layout.visibility && data.layout.visibility === "none") {
              oLayer.visibility(false);
            } // sauvegarde des layers


            this.layers.push(oLayer);
          } // Legende


          if (this.options.tools.legend) {
            // gestion de l'edition de la legende :
            // l'option "editable" est prioritaire sur le tag "editable" du fichier de style !
            var isEditable = this.options.tools.editable;

            if (typeof isEditable === "undefined") {
              isEditable = data.editable;
            }

            var oLegend = new _Editor_Legend__WEBPACK_IMPORTED_MODULE_8__["default"]({
              id: this.id,
              target: target,
              sprites: this.sprites,
              obj: {
                id: data.id,
                source: data.source,
                title: data.id,
                editable: typeof isEditable !== "undefined" ? isEditable : false,
                paint: data.paint,
                layout: data.layout
              }
            });
            oLegend.add();
            oLegend.display(false);

            if (oLayer) {
              oLayer.addLegend(oLegend);
              oLayer.slotLegend(); // integration de la legende dans le container du layers !
            }
          } // Style


          if (this.options.tools.style) {
            var oStyle = new _Editor_Style__WEBPACK_IMPORTED_MODULE_5__["default"]({
              id: this.id,
              target: target,
              position: index + "_" + this.id,
              // unique !,
              obj: {
                id: data.id,
                source: data.source,
                layout: data.layout,
                paint: data.paint
              }
            });
            oStyle.add();
            oStyle.display(false);

            if (oLayer) {
              oLayer.addStyle(oStyle);
            } // update visibility layer


            if (data.layout && data.layout.visibility && data.layout.visibility === "none") {
              oLayer.visibility(false);
            }
          } // Filter


          if (this.options.tools.filter) {
            var oFilter = new _Editor_Filter__WEBPACK_IMPORTED_MODULE_7__["default"]({
              id: this.id,
              target: target,
              position: index + "_" + this.id,
              // unique !,
              obj: {
                id: data.id,
                source: data.source,
                filter: data.Filter
              }
            });
            oFilter.add();
            oFilter.display(false);

            if (oLayer) {
              oLayer.addFilter(oFilter);
            }
          }
        } else {
          // on ecarte un layer car il n'est pas reconnu dans la source
          // on decremente la position du layer
          if (index >= 0) {
            index--;
          }
        }
      }
    }
  } // sauvegarde


  this.container = div; // container principal

  if (!this.options.target) {
    if (!document.getElementById(this.name.target)) {
      var _target = document.createElement("div");

      _target.id = this.name.target;
      var node = document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0] || document.documentElement;
      node.appendChild(_target);
    }

    this.options.target = document.getElementById(this.name.target);
  }

  if (this.container) {
    this.options.target.appendChild(this.container);
  } // dispatch event


  eventbusjs__WEBPACK_IMPORTED_MODULE_1___default.a.dispatch(_Editor_Event__WEBPACK_IMPORTED_MODULE_11__["default"].onloaded, this);
};
/**
 * Getting Sprites informations
 * (called by _initialize)
 *
 * @param {String} sprites - url des sprites
 * @returns {Promise} - promise
 * @private
 */


Editor.prototype._getSprites = function (sprites) {
  var self = this; // on ne doit pas mettre de promise en échec...
  // car on souhaite continuer le traitement même si on n'a pas de sprites !
  // si le protocole est mapbox://

  if (sprites && sprites.startsWith("mapbox://")) {
    return new Promise(function (resolve, reject) {
      // eslint-disable-line no-unused-vars
      logger.info("Protocole mapbox:// non géré !");
      resolve(self);
    });
  } // si pas de sprites


  if (!sprites) {
    return new Promise(function (resolve, reject) {
      // eslint-disable-line no-unused-vars
      logger.info("Auncun sprites disponibles !");
      resolve(self);
    });
  }

  var fetchSpritesImage = function fetchSpritesImage() {
    var spritesImage = sprites + ".png";
    return fetch(spritesImage, {
      credentials: "same-origin"
    }).then(function (response) {
      if (response.ok) {
        return response.blob().then(function (blob) {
          self.sprites.url = spritesImage; // decode de l'image

          var theImage = new Image();
          theImage.src = spritesImage;
          return theImage.decode().then(function () {
            self.sprites.size = {};
            self.sprites.size.h = theImage.height;
            self.sprites.size.w = theImage.width;
          });
        })["catch"](function (error) {
          logger.warn("fetch image sprites exception :", error);
        });
      }
    })["catch"](function (error) {
      logger.warn("fetch sprites exception :", error);
    });
  };

  var fetchSpritesJson = function fetchSpritesJson() {
    var spritesJson = sprites + ".json";
    return fetch(spritesJson, {
      credentials: "same-origin"
    }).then(function (response) {
      if (response.ok) {
        return response.json().then(function (json) {
          self.sprites.json = json;
        })["catch"](function (error) {
          logger.warn("fetch json sprites exception :", error);
        });
      }
    })["catch"](function (error) {
      logger.warn("fetch sprites exception :", error);
    });
  }; // promise


  return Promise.all([fetchSpritesImage(), fetchSpritesJson()]);
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Create Editor
 *
 * @returns {Promise} - promise
 */


Editor.prototype.createElement = function () {
  var self = this; // objet json

  if (_typeof(this.options.style) === "object") {
    this.mapbox = this.options.style; // les sprites sont utiles que si on veut une legende !

    if (this.options.tools.legend) {
      return this._getSprites(this.mapbox.sprite).then(function () {
        // init du DOM
        self._initContainer();

        return self;
      })["catch"](function (error) {
        logger.warn("fetch sprites exception :", error);
      });
    } else {
      return new Promise(function (resolve, reject) {
        // eslint-disable-line no-unused-vars
        self._initContainer();

        resolve(self);
      });
    }
  } // url


  if (typeof this.options.style === "string") {
    return fetch(this.options.style, {
      credentials: "same-origin"
    }).then(function (response) {
      // sauvegarde du json
      return response.json().then(function (style) {
        self.mapbox = style;
      }).then(function () {
        // les sprites sont utiles que si on veut une legende !
        if (self.options.tools.legend) {
          return self._getSprites(self.mapbox.sprite).then(function () {
            // init du DOM
            self._initContainer();

            return self;
          })["catch"](function (error) {
            logger.warn("fetch sprites exception :", error);
          });
        } else {
          return new Promise(function (resolve, reject) {
            // eslint-disable-line no-unused-vars
            self._initContainer();

            resolve(self);
          });
        }
      })["catch"](function (error) {
        logger.error("json exception :", error);
      });
    })["catch"](function (error) {
      logger.error("fetch exception :", error);
    });
  }
};
/**
 * Set display container (DOM)
 *
 * @param {Boolean} display - show/hidden container
 */


Editor.prototype.display = function (display) {
  this.container.style.display = display ? "block" : "none";
};
/**
 * Get id editor
 * @returns {Number} id
 */


Editor.prototype.getID = function () {
  return this.id;
};
/**
 * Get container (DOM)
 * @returns {DOMElement} DOM element
 */


Editor.prototype.getContainer = function () {
  return this.container;
};
/**
 * Get Style (json)
 * @returns {Object} Style MapBox
 */


Editor.prototype.getStyle = function () {
  return this.mapbox;
};
/**
 * Get layer style (json)
 * @param {Number} i - index
 * @returns {Object} Style MapBox of a layers
 */


Editor.prototype.getStyleLayer = function (i) {
  var layer = null;
  var o = this.getLayer(i);
  var id = o.options.obj.id;

  for (var k = 0; k < this.mapbox.layers.length; k++) {
    var l = this.mapbox.layers[k];

    if (l.id === id) {
      layer = l;
      break;
    }
  }

  return layer;
};
/**
 * Get layer object from json style
 * @param {Number} i - index into style json
 * @returns {Object} Style MapBox of a layers
 */


Editor.prototype.getLayerFromStyle = function (i) {
  var layer = null;
  var l = this.mapbox.layers[i];

  for (var k = 0; k < this.getLayers().length; k++) {
    var o = this.getLayer(k);

    if (l.id === o.options.obj.id) {
      layer = o;
      break;
    }
  }

  return layer;
};
/**
 * Get a list of layer object sorted or not (see options.tools.sort)
 * @returns {Array} - List of layer object
 * @see {ol.style.editor.Layer}
 */


Editor.prototype.getLayers = function () {
  return this.layers;
};
/**
 * Get the layer object from a list sorted or not (see options.tools.sort)
 * @param {Number} i - index
 * @returns {Object} - layer object
 * @see {ol.style.editor.Layer}
 */


Editor.prototype.getLayer = function (i) {
  return this.layers[i];
}; // ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //


/* harmony default export */ __webpack_exports__["default"] = (Editor); // Expose Editor as ol.editor.View (for a build bundle)

if (window.ol && window.ol.style) {
  window.ol.style.Editor = Editor;
}

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["eventbus"] = __webpack_require__(265);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(62)))

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

(function(root,factory){if(true)module.exports=factory();else {}})(this,function(){var EventBusClass={};EventBusClass=function(){this.listeners={}};EventBusClass.prototype={addEventListener:function(type,callback,scope){var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>3?args.splice(3,args.length-1):[];if(typeof this.listeners[type]!="undefined"){this.listeners[type].push({scope:scope,callback:callback,args:args})}else{this.listeners[type]=[{scope:scope,callback:callback,args:args}]}},removeEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;var newArray=[];for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener.scope==scope&&listener.callback==callback){}else{newArray.push(listener)}}this.listeners[type]=newArray}},hasEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;if(callback===undefined&&scope===undefined){return numOfCallbacks>0}for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if((scope?listener.scope==scope:true)&&listener.callback==callback){return true}}}return false},dispatch:function(type,target){var event={type:type,target:target};var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>2?args.splice(2,args.length-1):[];args=[event].concat(args);if(typeof this.listeners[type]!="undefined"){var listeners=this.listeners[type].slice();var numOfCallbacks=listeners.length;for(var i=0;i<numOfCallbacks;i++){var listener=listeners[i];if(listener&&listener.callback){var concatArgs=args.concat(listener.args);listener.callback.apply(listener.scope,concatArgs)}}}},getEvents:function(){var str="";for(var type in this.listeners){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];str+=listener.scope&&listener.scope.className?listener.scope.className:"anonymous";str+=" listen for '"+type+"'\n"}}return str}};var EventBus=new EventBusClass;return EventBus});

/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(141);




var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("editor-style");
/**
 * @classdesc
 *
 * MapBox styles management
 *
 * @constructor
 * @alias ol.style.editor.Style
 * @param {Object} options - options for function call.
 * @example
 *   var style = new Style ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      tools : {
 *          edition : false,
 *          scale : true
 *      },
 *      title : "Styles (JSON)",
 *      obj : {
 *          paint : {},
 *          layout : {}
 *      }
 *   });
 *  style.add();
 *  style.display(true);
 *  style.getContainer();
 */

function Style(options) {
  logger.trace("[constructor] Style", options); // options

  this.options = options || {
    // default...
    target: null,
    position: 0,
    tools: null,
    title: null,
    obj: null
  };

  if (!(this instanceof Style)) {
    throw new TypeError("ERROR CLASS_CONSTRUCTOR");
  }

  this._initialize();

  this._initContainer();
}

;
/**
 * Constructor (alias)
 *
 * @private
 */

Style.prototype.constructor = Style;
/**
 * Initialize component
 * (called by constructor)
 *
 * @private
 */

Style.prototype._initialize = function () {
  // unique editor id (optional!)
  this.id = this.options.id || null;

  if (!this.options.target) {// cf. add()
  }

  if (!this.options.position) {
    this.options.position = 0;
  }

  var _toolsDefault = {
    scale: true,
    edition: false
  };

  if (!this.options.tools) {
    this.options.tools = _toolsDefault;
  }

  _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);

  if (!this.options.obj) {
    // choix d'avoir un objet vide pour une edition futur...
    this.options.obj = {
      paint: {},
      layout: {}
    };
  }

  if (!this.options.title) {
    this.options.title = "JSON Styles :";
  }

  this.container = null; // DOM : className or id

  this.name = {
    target: "GPEditorMapBoxStyleTarget",
    container: "GPEditorMapBoxStyleContainer",
    containerjson: "GPEditorMapBoxStyleJsonContainer",
    jsonlabel: "GPEditorMapBoxStyleJsonTitle",
    jsondisplay: "GPEditorMapBoxStyleJsonDisplay",
    containertoolsscale: "GPEditorMapBoxStyleToolsScaleContainer",
    scaletitle: "GPEditorMapBoxStyleScaleTitle",
    containertoolsminscale: "GPEditorMapBoxStyleToolsScaleMinContainer",
    scalelabelmin: "GPEditorMapBoxStyleScaleLabelMin",
    scaleinputmin: "GPEditorMapBoxStyleScaleInputMin",
    containertoolsmaxscale: "GPEditorMapBoxStyleToolsScaleMaxContainer",
    scalelabelmax: "GPEditorMapBoxStyleScaleLabelMax",
    scaleinputmax: "GPEditorMapBoxStyleScaleInputMax",
    containertoolsedit: "GPEditorMapBoxStyleToolsEditionContainer"
  };
};
/**
 * Graphical rendering of the component
 * ie. this.container
 * (called by constructor)
 *
 * @private
 * @example
 * <div class="GPEditorMapBoxStyleContainer">
 *   <div class ="GPEditorMapBoxStyleJsonContainer">
 *      <label class="GPEditorMapBoxStyleJsonTitle">JSON Styles :</label>
 *      <pre class="GPEditorMapBoxStyleJsonDisplay">...</pre>
 *   </div>
 *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
 *   <div class ="GPEditorMapBoxStyleToolsEditionContainer"></div>
 * </div>
 */


Style.prototype._initContainer = function () {
  // contexte
  var self = this;
  var _found = false;

  var _obj = JSON.parse(JSON.stringify(this.options.obj)); // on manipule une copie  !


  var _style = {}; // styles into tag 'paint' ?

  if (_obj.paint) {
    _found = true;
    _style.paint = _obj.paint;

    if (Object.keys(_obj.paint).length === 0) {
      logger.info("tag 'paint' is empty !");
    }
  } // if not, search into tag 'layout' !


  if (_obj.layout) {
    _found = true;
    _style.layout = _obj.layout; // FIXME delete visibility from display ?

    if (_obj.layout.visibility) {
      delete _style.visibility;
    }

    if (Object.keys(_obj.layout).length === 0) {
      logger.info("tag 'layout' is empty !");
    }
  }

  var div = document.createElement("div");
  div.className = this.name.container;
  var json = null;

  if (_found) {
    var strJson = JSON.stringify(_style, null, 4);
    json = this._syntaxHighlight(strJson);
  }

  var divJson = document.createElement("div");
  divJson.className = this.name.containerjson;
  var label = document.createElement("label");
  label.className = this.name.jsonlabel;
  label.innerHTML = this.options.title;
  divJson.appendChild(label);
  var pre = document.createElement("pre");
  pre.className = this.name.jsondisplay;
  pre.innerHTML = json;

  if (pre.addEventListener) {
    pre.addEventListener("click", function (e) {
      if (self.options.tools.edition) {
        self.onEditJsonStyleMapBox(e);
      }
    });
  } else if (pre.attachEvent) {
    pre.attachEvent("onclick", function (e) {
      if (self.options.tools.edition) {
        self.onEditJsonStyleMapBox(e);
      }
    });
  }

  divJson.appendChild(pre);
  div.appendChild(divJson); // scale

  if (this.options.tools.scale) {
    div.appendChild(this._createElementToolsScale({
      min: _style.layout ? _style.layout.minzoom : 0,
      max: _style.layout ? _style.layout.maxzoom : 21
    }));
  } // TODO menu d'edition


  if (this.options.tools.edition) {
    div.appendChild(this._createElementToolsEdition());
  } // main container


  this.container = div;
};
/**
 * Graphical rendering of the scale tools
 *
 * @param {Object} scale - {min,max} or 0|21
 * @returns {DOMElement} DOM element
 *
 * @private
 * @example
 *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
 */


Style.prototype._createElementToolsScale = function (scale) {
  logger.trace("_createElementToolsScale");
  var self = this;
  var obj = this.options.obj;
  var divToolsScale = document.createElement("div");
  divToolsScale.className = this.name.containertoolsscale; // FIXME Titre ?
  // var label = document.createElement("label");
  // label.className = this.name.scaletitle;
  // label.innerHTML = "Scale :";
  // divToolsScale.appendChild(label);

  var divMin = document.createElement("div");
  divMin.className = this.name.containertoolsminscale;
  var labelMin = document.createElement("label");
  labelMin.className = this.name.scalelabelmin;
  labelMin.innerHTML = "min :";
  divMin.appendChild(labelMin);
  var inputMin = document.createElement("input");
  inputMin.className = this.name.scaleinputmin;
  inputMin.type = "range";
  inputMin.value = scale.min || 0;
  inputMin.title = scale.min || 0;
  inputMin.disabled = false;
  inputMin.min = 0;
  inputMin.max = 21;
  inputMin.data = obj; // on lie le DOM et la couche, utile lors d'evenement !

  if (inputMin.addEventListener) {
    inputMin.addEventListener("change", function (e) {
      self.onChangeStyleScaleMinMapBox(e);
    });
  } else if (inputMin.appendChild) {
    inputMin.appendChild("onchange", function (e) {
      self.onChangeStyleScaleMinMapBox(e);
    });
  }

  divMin.appendChild(inputMin);
  divToolsScale.appendChild(divMin);
  var divMax = document.createElement("div");
  divMax.className = this.name.containertoolsmaxscale;
  var labelMax = document.createElement("label");
  labelMax.className = this.name.scalelabelmax;
  labelMax.innerHTML = "max :";
  divMax.appendChild(labelMax);
  var inputMax = document.createElement("input");
  inputMax.className = this.name.scaleinputmin;
  inputMax.type = "range";
  inputMax.value = scale.max || 21;
  inputMax.title = scale.max || 21;
  inputMax.disabled = false;
  inputMax.min = 0;
  inputMax.max = 21;
  inputMax.data = obj; // on lie le DOM et la couche, utile lors d'evenement !

  if (inputMax.addEventListener) {
    inputMax.addEventListener("change", function (e) {
      self.onChangeStyleScaleMaxMapBox(e);
    });
  } else if (inputMax.appendChild) {
    inputMax.appendChild("onchange", function (e) {
      self.onChangeStyleScaleMaxMapBox(e);
    });
  }

  divMax.appendChild(inputMax);
  divToolsScale.appendChild(divMax);
  return divToolsScale;
};
/**
 * Graphical rendering of the edition tools
 *
 * @returns {DOMElement} DOM element
 *
 * @private
 * @example
 *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
 */


Style.prototype._createElementToolsEdition = function () {
  logger.warn("_createElementToolsEdition, it's not yet implemented !");
  var divToolsEdit = document.createElement("div");
  divToolsEdit.className = this.name.containertoolsedit;
  return divToolsEdit;
}; // ################################################################### //
// ##################### private methods ############################# //
// ################################################################### //

/**
 * Transform a JSON into a DOM with a syntax in color
 *
 * @private
 * @param {Object} json - json.
 * @returns {DOMElement} dom element
 */


Style.prototype._syntaxHighlight = function (json) {
  json = json.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function (match) {
    var cls = "gp-json-number";

    if (/^"/.test(match)) {
      if (/:$/.test(match)) {
        cls = "gp-json-key";
      } else {
        cls = "gp-json-string";
      }
    } else if (/true|false/.test(match)) {
      cls = "gp-json-boolean";
    } else if (/null/.test(match)) {
      cls = "gp-json-null";
    }

    return "<span class='" + cls + "'>" + match + "</span>";
  });
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Add element into target DOM
 * @returns {Object} - Legend instance
 */


Style.prototype.add = function () {
  if (!this.options.target) {
    if (!document.getElementById(this.name.target)) {
      var div = document.createElement("div");
      div.id = this.name.target;
      var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
      node.appendChild(div);
    }

    this.options.target = document.getElementById(this.name.target);
  }

  if (this.container) {
    this.options.target.appendChild(this.container);
  }

  return this;
};
/**
 * Set display container or get
 *
 * @param {Boolean} display - show/hidden container or get status
 * @returns {Boolean} - true/false
 */


Style.prototype.display = function (display) {
  logger.trace("display()", display);

  if (typeof display !== "undefined") {
    this.container.style.display = display ? "flex" : "none";
  }

  return this.container.style.display === "flex";
};
/**
 * Get container (DOM)
 *
 * @returns {DOMElement} DOM element
 */


Style.prototype.getContainer = function () {
  return this.container;
}; // ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //

/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Style#editor:style:oneditjson
 */


Style.prototype.onEditJsonStyleMapBox = function (e) {
  logger.trace("onEditJsonStyleMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].style.oneditjson, e);
};
/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Style#editor:style:scale:onchangemin
 */


Style.prototype.onChangeStyleScaleMinMapBox = function (e) {
  logger.trace("onChangeStyleScaleMinMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].style.scale.onchangemin, e);
};
/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Style#editor:style:scale:onchangemax
 */


Style.prototype.onChangeStyleScaleMaxMapBox = function (e) {
  logger.trace("onChangeStyleScaleMaxMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].style.scale.onchangemax, e);
};

/* harmony default export */ __webpack_exports__["default"] = (Style);

/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
* managing events
*
* See {@link http://krasimirtsonev.com/blog/article/javascript-managing-events-dispatch-listen}
* See {@link https://github.com/krasimir/EventBus}
*
* @property {Event} "editor:layer:onclickvisibility" - event ...
* @property {Event} "editor:layer:onclickclone" - event ...
* @property {Event} "editor:layer:onclickremove" - event ...
* @property {Event} "editor:style:oneditjson" - event ...
* @property {Event} "editor:style:scale:onchangemin" - event ...
* @property {Event} "editor:style:scale:onchangemax" - event ...
* @property {Event} "editor:legend:onclickedition" - event ...
* @property {Event} "editor:legend:onchangevalue" - event ...
* @property {Event} "editor:filter:oneditjson" - event ...
* @property {Event} "editor:themes:onclickimage" - event ...
* @property {Event} "editor:themes:onclicktitle" - event ...
* @property {Event} "editor:group:oncollapse" - event ...
* @property {Event} "editor:onloaded" - event ...
*
* @mixin
*
* @example
* // dispatch event
* EventBus.dispatch(EventEditor.layer.visibility, e);
* // listener
* EventBus.addEventListener(EventEditor.layer.visibility, function (e) {...}, this);
*/
var EventEditor = {
  /** evenement sur la fin de chargement de l'editeur */
  onloaded: "editor:onloaded",
  layer: {
    /** evenement sur la visibilité : clic sur le bouton 'oeil' */
    onclickvisibility: "editor:layer:onclickvisibility",

    /** evenement sur la duplication : clic sur le bouton
    (not yet implemented !) */
    onclickclone: "editor:layer:onclickclone",

    /** evenement sur la suppression : clic sur le bouton
    (not yet implemented !) */
    onclickremove: "editor:layer:onclickremove"
  },
  legend: {
    /** evenement sur l'affichage du mode edition */
    onclickedition: "editor:legend:onclickedition",

    /** evenement sur la modification d'une valeur */
    onchangevalue: "editor:legend:onchangevalue"
  },
  group: {
    /**  evenement pour deplier/plier le groupe
    (not yet implemented !) */
    oncollapse: "editor:group:oncollapse"
  },
  style: {
    /** evenement sur l'édition du style
    (not yet implemented !) */
    oneditjson: "editor:style:oneditjson",

    /** evenement sur la modification de l'echelle d'affichage */
    scale: {
      onchangemin: "editor:style:scale:onchangemin",
      onchangemax: "editor:style:scale:onchangemax"
    }
  },
  filter: {
    /** evenement sur l'édition du filtre
    (not yet implemented !) */
    oneditjson: "editor:filter:oneditjson"
  },
  themes: {
    /** evenement sur le clic de l'image */
    onclickimage: "editor:themes:onclickimage",

    /** evenement sur le clic du titre */
    onclicktitle: "editor:themes:onclicktitle"
  }
};
/* harmony default export */ __webpack_exports__["default"] = (EventEditor);

/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(172);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);





var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("editor-themes");
/**
 * @classdesc
 *
 * Mapbox Themes management
 *
 * @constructor
 * @alias ol.style.editor.Theme
 * @param {Object} options - options for function call.
 * @example
 *   var theme = new Themes ({
 *        "target": "",
 *        "tools": {
 *          "thumbnails": true,
 *          "button" : {
 *              "visible" : true,
 *              "type" : "radio" (par defaut) | "checkbox"
 *          }
 *        },
 *        "obj": {
 *          "themesSummary": "", // Titre du composant (non graphique !)
 *          "themes": [{
 *             "thumbnail": "data/images/layer0.png",
 *             "name": "standard0",
 *             "url": "data/styles/layer0.json",
 *             "description": "",
 *             "selected" : true
 *          },{
 *             "thumbnail": "data/images/layer1.png",
 *             "name": "standard1",
 *             "url": "data/styles/layer1.json",
 *             "description": ""
 *          }]
 *        }
 *   });
 *  theme.add();
 *  theme.display(true);
 *  theme.getContainer();
 */

function Themes(options) {
  logger.trace("[constructor] Themes", options); // options

  this.options = options || {// TODO default...
  };

  if (!(this instanceof Themes)) {
    throw new TypeError("ERROR CLASS_CONSTRUCTOR");
  }

  this._initialize();

  this._initContainer();
}

;
/**
 * Constructor (alias)
 *
 * @private
 */

Themes.prototype.constructor = Themes;
/**
 * Initialize component
 * (called by constructor)
 *
 * @private
 */

Themes.prototype._initialize = function () {
  // unique editor id (optional!)
  this.id = this.options.id || null;

  if (!this.options.target) {// cf. add()
  }

  var _toolsDefault = {
    thumbnails: true,
    button: {
      visible: true,
      type: "radio"
    }
  };

  if (!this.options.tools || Object.keys(this.options.tools).length === 0) {
    this.options.tools = _toolsDefault;
  }

  _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);

  if (typeof this.options.obj === "undefined" || this.options.obj === null || !this.options.obj) {
    // vide par defaut ?
    this.options.obj = {
      themesSummary: "",
      themes: []
    };
  }

  this.container = null; // DOM : className or id

  this.name = {
    target: "GPEditorMapBoxThemeTarget",
    container: "GPEditorMapBoxThemesContainer",
    containertheme: "GPEditorMapBoxThemeContainer",
    containerthemeID: "GPEditorMapBoxThemeContainer_ID_",
    input: "GPEditorMapBoxThemeInput",
    inputID: "GPEditorMapBoxThemeInput_ID_",
    label: "GPEditorMapBoxThemeTitle",
    labelID: "GPEditorMapBoxThemeTitle_ID_",
    image: "GPEditorMapBoxThemeImage",
    imageID: "GPEditorMapBoxThemeImage_ID_",
    message: "GPEditorMapBoxThemeMessage"
  };
};
/**
 * Graphical rendering of the component
 * (called by constructor)
 *
 * @private
 * @example
 *  <div class="GPEditorMapBoxThemesContainer">
 *      <div id="GPEditorMapBoxThemeContainer-1" class="GPEditorMapBoxThemeContainer">
 *          <input type="radio" id="GPEditorMapBoxThemeInput-1" class="GPEditorMapBoxThemeInput" name="1552920176933">
 *          <img class="GPEditorMapBoxThemeImage" src="http://image1.png" alt="Description1"></img>
 *          <label for="GPEditorMapBoxThemeInput-1" class="GPEditorMapBoxThemeTitle">Titre1</label>
 *      </div>
 *      <div id="GPEditorMapBoxThemeContainer-2" class="GPEditorMapBoxThemeContainer">
 *          <input type="radio" id="GPEditorMapBoxThemeInput-2" class="GPEditorMapBoxThemeInput" name="1552920176934">
 *          <img class="GPEditorMapBoxThemeImage" src="http://image2.png" alt="Description2"></img>
 *          <label for="GPEditorMapBoxThemeInput-2" class="GPEditorMapBoxThemeTitle">Titre2</label>
 *      </div>
 * </div>
 */


Themes.prototype._initContainer = function () {
  // contexte
  var self = this;
  var obj = this.options.obj;
  var id = this.id || _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate(); // div principale

  var div = document.createElement("div");
  div.className = this.name.container;
  div.title = obj.themesSummary || "";
  var _lstThemes = obj.themes;

  if (_lstThemes) {
    for (var i = 0; i < _lstThemes.length; i++) {
      var _theme = _lstThemes[i]; // div pour chaque theme

      var divTheme = document.createElement("div");
      divTheme.id = this.name.containerthemeID + i + "_" + id;
      divTheme.className = this.name.containertheme;
      divTheme.tabIndex = i; // url du style est obligatoire !

      var _url = _theme.url; // style selectionné par defaut (uniquement en mode radio-button !?)

      var _selected = _theme.selected || false;

      if (_url) {
        // bouton
        var button = this.options.tools.button;

        if (button.visible) {
          var _type = button.type === "checkbox" ? "checkbox" : "radio";

          var _button = document.createElement("input");

          _button.type = _type;
          _button.id = this.name.inputID + i + "_" + id;
          _button.className = this.name.input;
          _button.name = id;
          _button.checked = _selected;
          _button.data = _url; // on lie le DOM et la couche, utile lors d'evenement !

          if (_button.addEventListener) {
            _button.addEventListener("click", function (e) {
              self.onClickThemeTitleMapBox(e);
            });
          } else if (_button.attachEvent) {
            _button.attachEvent("onclick", function (e) {
              self.onClickThemeTitleMapBox(e);
            });
          }

          divTheme.appendChild(_button);
        } // vignette


        if (this.options.tools.thumbnails) {
          if (_theme.thumbnail) {
            var _img = document.createElement("img");

            _img.id = this.name.imageID + i + "_" + id;
            _img.className = this.name.image;
            _img.src = _theme.thumbnail;
            _img.alt = _theme.thumbnail;
            _img.title = _theme.description || ""; // une description au survol de l'image ou titre...

            _img.data = _url; // on lie le DOM et la couche, utile lors d'evenement !

            if (_img.addEventListener) {
              _img.addEventListener("click", function (e) {
                self.onClickThemeImageMapBox(e); // maj du radio button

                var nodes = e.target.parentElement.childNodes;

                if (nodes) {
                  var node = nodes[0];

                  if (node.tagName.toLowerCase() === "input") {
                    node.checked = !node.checked;
                  }
                }
              });
            } else if (_img.attachEvent) {
              _img.attachEvent("onclick", function (e) {
                self.onClickThemeImageMapBox(e);
                var nodes = e.target.parentElement.childNodes;

                if (nodes) {
                  var node = nodes[0];

                  if (node.tagName.toLowerCase() === "input") {
                    node.checked = !node.checked;
                  }
                }
              });
            }

            divTheme.appendChild(_img);
          }
        } // label


        if (_theme.name) {
          var _label = document.createElement("label");

          _label.id = this.name.labelID + i + "_" + id;

          if (this.options.tools.button.visible) {
            _label.htmlFor = _button.id;
          }

          _label.className = this.name.label;
          _label.innerHTML = _theme.name;
          _label.title = _theme.description || ""; // une description au survol de l'image ou titre...

          _label.data = _url; // on lie le DOM et la couche, utile lors d'evenement !

          if (!this.options.tools.button.visible) {
            if (_label.addEventListener) {
              _label.addEventListener("click", function (e) {
                self.onClickThemeTitleMapBox(e);
              });
            } else if (_label.attachEvent) {
              _label.attachEvent("onclick", function (e) {
                self.onClickThemeTitleMapBox(e);
              });
            }
          }

          divTheme.appendChild(_label);
        }
      } else {
        var _msg = document.createElement("label");

        _msg.className = this.name.message;
        _msg.innerHTML = "Thème non disponible...";
        divTheme.appendChild(_msg);
      }

      div.appendChild(divTheme);
    }
  }

  this.container = div;
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Add element into target DOM
 * @returns {Object} - Legend instance
 */


Themes.prototype.add = function () {
  if (!this.options.target) {
    if (!document.getElementById(this.name.target)) {
      var div = document.createElement("div");
      div.id = this.name.target;
      var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
      node.appendChild(div);
    }

    this.options.target = document.getElementById(this.name.target);
  }

  if (this.container) {
    this.options.target.appendChild(this.container);
  }

  return this;
};
/**
 * Set display container or get
 *
 * @param {Boolean} display - show/hidden container or get status
 * @returns {Boolean} - true/false
 */


Themes.prototype.display = function (display) {
  logger.trace("display()", display);

  if (typeof display !== "undefined") {
    this.container.style.display = display ? "flex" : "none";
  }

  return this.container.style.display === "flex";
};
/**
 * Get container (DOM)
 *
 * @returns {DOMElement} DOM element
 */


Themes.prototype.getContainer = function () {
  return this.container;
}; // ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //

/**
 * this method is called by event '' on '' tag form
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Themes#editor:themes:image
 */


Themes.prototype.onClickThemeImageMapBox = function (e) {
  logger.trace("onClickThemeImageMapBox", e);
  e.editorID = this.id;
  e.data = this.options;

  if (this.options.tools.button.type === "checkbox") {
    // GPEditorMapBoxThemeInput_ID_0_1571317605868
    var targetIDX = e.target.previousSibling.id.substring(e.target.previousSibling.id.lastIndexOf("_") + 1);

    var _inputs = document.getElementsByClassName(this.name.input);

    for (var i = 0; i < _inputs.length; i++) {
      var el = _inputs[i];

      if (el.id === e.target.previousSibling.id) {
        continue;
      }

      var elIDX = el.id.substring(el.id.lastIndexOf("_") + 1);

      if (elIDX !== targetIDX) {
        continue;
      }

      el.checked = false;
    }
  }

  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].themes.onclickimage, e);
};
/**
 * this method is called by event '' on '' tag form
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Themes#editor:themes:title
 */


Themes.prototype.onClickThemeTitleMapBox = function (e) {
  logger.trace("onClickThemeTitleMapBox", e);
  e.editorID = this.id;
  e.data = this.options;

  if (this.options.tools.button.type === "checkbox") {
    // GPEditorMapBoxThemeInput_ID_0_1571317605868
    var targetIDX = e.target.id.substring(e.target.id.lastIndexOf("_") + 1);

    var _inputs = document.getElementsByClassName(this.name.input);

    for (var i = 0; i < _inputs.length; i++) {
      var el = _inputs[i];

      if (el.id === e.target.id) {
        continue;
      }

      var elIDX = el.id.substring(el.id.lastIndexOf("_") + 1);

      if (elIDX !== targetIDX) {
        continue;
      }

      el.checked = false;
    }
  }

  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].themes.onclicktitle, e);
};

/* harmony default export */ __webpack_exports__["default"] = (Themes);

/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(141);




var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("editor-filter");
/**
 * @classdesc
 *
 * MapBox filter management
 *
 * @constructor
 * @alias ol.style.editor.Filter
 * @param {Object} options - options for function call.
 * @example
 *   var filter = new Filter ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      tools : {
 *          edition : false
 *      },
 *      title : "Filtres (JSON)",
 *      obj : {
 *          filter : []
 *      }
 *   });
 *  filter.add();
 *  filter.display(true);
 *  filter.getContainer();
 */

function Filter(options) {
  logger.trace("[constructor] Filter", options); // options

  this.options = options || {
    // default...
    target: null,
    position: 0,
    tools: null,
    title: null,
    obj: null
  };

  if (!(this instanceof Filter)) {
    throw new TypeError("ERROR CLASS_CONSTRUCTOR");
  }

  this._initialize();

  this._initContainer();
}

;
/**
 * Constructor (alias)
 *
 * @private
 */

Filter.prototype.constructor = Filter;
/**
 * Initialize component
 * (called by constructor)
 *
 * @private
 */

Filter.prototype._initialize = function () {
  // unique editor id (optional!)
  this.id = this.options.id || null;

  if (!this.options.target) {// cf. add()
  }

  if (!this.options.position) {
    this.options.position = 0;
  }

  var _toolsDefault = {
    edition: false
  };

  if (!this.options.tools) {
    this.options.tools = _toolsDefault;
  }

  _Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);

  if (!this.options.obj) {
    // choix d'avoir un objet vide pour une edition futur...
    this.options.obj = {
      filter: []
    };
  }

  if (!this.options.title) {
    this.options.title = "JSON Filtres :";
  }

  this.container = null; // DOM : className or id

  this.name = {
    target: "GPEditorMapBoxFilterTarget",
    container: "GPEditorMapBoxFilterContainer",
    containerjson: "GPEditorMapBoxFilterJsonContainer",
    jsonlabel: "GPEditorMapBoxFilterTitleJson",
    jsondisplay: "GPEditorMapBoxFilterDisplayJson",
    containertoolsedit: "GPEditorMapBoxFilterToolsEditionContainer"
  };
};
/**
 * Graphical rendering of the component
 * (called by constructor)
 *
 * @private
 * @example
 * <div class="GPEditorMapBoxFilterContainer">
 *  <div class ="GPEditorMapBoxFilterJsonontainer">
 *     <label class="GPEditorMapBoxFilterTitleJson">JSON Filtres :</label>
 *     <pre class="GPEditorMapBoxFilterDisplayJson">...</pre>
 *  </div>
 *  <div class ="GPEditorMapBoxStyleToolsEditionContainer"></div>
 * </div>
 */


Filter.prototype._initContainer = function () {
  // contexte
  var self = this;
  var _found = false;

  var _filter = JSON.parse(JSON.stringify(this.options.obj)); // on manipule une copie  !
  // FIXME tag filter est obselete !
  // on doit utiliser les expressions dans "paint" ou "layout" !


  if (_filter.filter) {
    _found = true;

    if (_filter.filter.length === 0) {
      logger.info("tag 'filter' is empty !");
    }
  }

  var div = document.createElement("div");
  div.className = this.name.container;
  var json = null;

  if (_found) {
    json = JSON.stringify(_filter.filter, null, 4);
  }

  var divJson = document.createElement("div");
  divJson.className = this.name.containerjson;
  var labelJson = document.createElement("label");
  labelJson.className = this.name.jsonlabel;
  labelJson.innerHTML = this.options.title;
  divJson.appendChild(labelJson);
  var preJson = document.createElement("pre");
  preJson.className = this.name.jsondisplay;
  preJson.innerHTML = json;

  if (preJson.addEventListener) {
    preJson.addEventListener("click", function (e) {
      if (self.options.tools.edition) {
        self.onEditJsonFilterMapBox(e);
      }
    });
  } else if (preJson.attachEvent) {
    preJson.attachEvent("onclick", function (e) {
      if (self.options.tools.edition) {
        self.onEditJsonFilterMapBox(e);
      }
    });
  }

  divJson.appendChild(preJson);
  div.appendChild(divJson);

  if (this.options.tools.edition) {
    var divEdit = document.createElement("div");
    divEdit.className = this.name.containertoolsedit;
    div.appendChild(divEdit);
  } // main container


  this.container = div;
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Add element into target DOM
 * @returns {Object} - Legend instance
 */


Filter.prototype.add = function () {
  if (!this.options.target) {
    if (!document.getElementById(this.name.target)) {
      var div = document.createElement("div");
      div.id = this.name.target;
      var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
      node.appendChild(div);
    }

    this.options.target = document.getElementById(this.name.target);
  }

  if (this.container) {
    this.options.target.appendChild(this.container);
  }

  return this;
};
/**
 * Set display container or get
 *
 * @param {Boolean} display - show/hidden container or get status
 * @returns {Boolean} - true/false
 */


Filter.prototype.display = function (display) {
  logger.trace("display()", display);

  if (typeof display !== "undefined") {
    this.container.style.display = display ? "flex" : "none";
  }

  return this.container.style.display === "flex";
};
/**
 * Get container (DOM)
 *
 * @returns {DOMElement} DOM element
 */


Filter.prototype.getContainer = function () {
  return this.container;
}; // ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //

/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Filter#editor:style:oneditjson
 */


Filter.prototype.onEditJsonFilterMapBox = function (e) {
  logger.trace("onEditJsonFilterMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].filter.oneditjson, e);
};

/* harmony default export */ __webpack_exports__["default"] = (Filter);

/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(155);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }





var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("editor-legend");
/**
 * @classdesc
 *
 * MapBox Legend management
 *
 * @constructor
 * @alias ol.style.editor.Legend
 * @param {Object} options - options for function call.
 * @param {Object} [options.target = null] - ...
 * @param {Number} [options.position = 0] -  ...
 * @param {Number} [options.id = null] - (internal) ...
 * @param {Object} [options.sprites = null] - ...
 * @param {String} [options.sprites.url] - ...
 * @param {Object} [options.sprites.size] - {h:, w:} ...
 * @param {Object} [options.sprites.json] - ...
 * @param {Object} options.obj - ...
 * @param {String} [options.obj.title] - ...
 * @param {Boolean} [options.obj.editable = true] - ...
 * @param {Object} options.obj.paint - ...
 * @param {Object} options.obj.layout - ...
 * @example
 *   var legend = new Legend ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      sprites : {
 *          url : "http://localhost/sprites.png",
 *          size : { w : 450, h : 550 },
 *          json : {
 *              icon-1 : {x:,y:,height:,width:,pixelRatio:},
 *              icon-2 : {x:,y:,height:,width:,pixelRatio:}
 *          }
 *      },
 *      obj : {
 *          title : "",
 *          editable : true, // tag non standard issue du style json dédié à l'edition
 *          paint : {"fill-color": "#2BB3E1"},
 *          layout : {visibility:"none"}
 *      }
 *   });
 *  legend.add();
 *  legend.display(true);
 *  legend.isEditable();
 *  legend.getRenderContainer();
 *  legend.getToolsContainer();
 *  legend.getContainer();
 */

function Legend(options) {
  logger.trace("[constructor] Legend", options); // options

  this.options = options || {
    // default...
    target: null,
    position: 0,
    sprites: null,
    obj: null
  };

  if (!(this instanceof Legend)) {
    throw new TypeError("ERROR CLASS_CONSTRUCTOR");
  }

  this._initialize();

  this._initContainer();
}

;
/**
 * Constructor (alias)
 *
 * @private
 */

Legend.prototype.constructor = Legend;
/**
 * Initialize component
 * (called by constructor)
 *
 * @private
 */

Legend.prototype._initialize = function () {
  // unique editor id (optional!)
  this.id = this.options.id || null;

  if (!this.options.target) {// cf. add()
  } // permet d'avoir un identifiant de position dans la liste des layers


  if (!this.options.position) {
    this.options.position = 0;
  }

  if (!this.options.obj) {
    // choix d'avoir un objet vide pour une edition...
    this.options.obj = {
      title: "vide...",
      editable: true,
      paint: {
        "fill-color": "#FFFFFF"
      }
    };
  } // la legende est elle editable ?
  // le tag 'editable' est à placer dans le fichier de style (dans le layer)...


  var _editable = this.options.obj.editable;
  this.editable = typeof _editable !== "undefined" ? _editable : false; // liste des caractéristiques de la legende

  this.legendRender = {
    type: "fill",
    values: {
      width: 1,
      stroke: "#FFFFFF",
      color: "#000000",
      opacity: 1,
      icon: null
    }
  }; // DOM : pointer

  this.container = null;
  this.rendercontainer = null;
  this.toolscontainer = null; // DOM : className or id

  this.name = {
    target: "GPEditorMapBoxLegendTarget",
    container: "GPEditorMapBoxLegendContainer",
    containerlegendrender: "GPEditorMapBoxLegendRenderContainer",
    legendrender: "GPEditorMapBoxLegendRender",
    legendeditable: "GPEditorMapBoxLegendEditable",
    legendtitle: "GPEditorMapBoxLegendTitle",
    containerlegendtools: "GPEditorMapBoxLegendToolsContainer"
  }; // DOM : Label menu Edition

  this.labels = {
    "line-color": "Couleur du trait",
    "line-width": "Epaisseur du trait",
    "line-opacity": "Opacité du trait",
    "fill-color": "Couleur de remplissage",
    "fill-opacity": "Opacité du remplissage"
  };
};
/**
 * Graphical rendering of the component
 * (called by constructor)
 *
 * @private
 * @example
 * <div class="GPEditorMapBoxLegendContainer">
 *  <div class="GPEditorMapBoxLegendRenderContainer">
 *      <div class="GPEditorMapBoxLegendRender GPEditorMapBoxLegendEditable legend-circle" style="..."></div>
 *      <span class="GPEditorMapBoxLegendTitle">test circle editable...</span>
 *  </div>
 *  <div class="GPEditorMapBoxLegendToolsContainer">...</div>
 * </div>
 */


Legend.prototype._initContainer = function () {
  var _obj = this.options.obj;
  var div = document.createElement("div");
  div.className = this.name.container; // on recherche les informations dans le tag 'paint' en priorité, mais pour
  // les icones ou textes, les informations peuvent se trouver aussi dans le tag 'layout'...

  var _bfoundStyle = false;
  var _style = {};

  if (_obj.paint && _obj.layout) {
    _bfoundStyle = true;
    Object.assign(_style, _obj.paint, _obj.layout);
  } else if (_obj.paint) {
    _bfoundStyle = true;
    Object.assign(_style, _obj.paint);
  } else if (_obj.layout) {
    _bfoundStyle = true;
    Object.assign(_style, _obj.layout);
  } else {
    _bfoundStyle = false;
  }

  if (_bfoundStyle) {
    var keys = Object.keys(_style);

    if (keys.length === 0) {
      logger.info("tag 'paint' or 'layout' is empty !");
    } // FIXME
    // - gestion de type plus complexe : texte avec/sans symbole ou symbole !
    // - pour les textes ou icones, les info peuvent être aussi dans le tag 'layout' !


    var params = {};
    var bFound = false;

    for (var i = 0; i < keys.length; i++) {
      var _key = keys[i];

      if (/fill-/.test(_key) || /line-/.test(_key) || /circle-/.test(_key) || /background-/.test(_key) || /text-/.test(_key) || // FIXME not yet implemented...
      /icon-/.test(_key) // FIXME not yet implemented...
      ) {
        // style geré & trouvé
        bFound = true;

        var _title = _obj.title || ""; // le type texte ou icone est difficile à trouver, on le gère en
        // symbole...


        var _type = _key.split("-")[0];

        if (_type === "text" || _type === "icon") {
          _type = "symbol";
        }

        if (this._getValues(_type, _style)) {
          params = {
            edit: this.editable,
            title: _title,
            type: this.legendRender.type,
            values: this.legendRender.values
          };
          div.appendChild(this._createElementIconLegend(params));
        } // on stoppe la recherche


        break;
      }
    }
  } // legende avec un style indeterminé ou non géré !?


  if (!bFound) {
    if (this._getValues("fill", _style)) {
      params = {
        edit: this.editable,
        title: _obj.title || "",
        type: this.legendRender.type,
        values: this.legendRender.values
      };
      div.appendChild(this._createElementIconLegend(params));
    }
  } // ajout mode edition graphique de la legende


  this.toolscontainer = this._createElementEditionLegend(params);
  div.appendChild(this.toolscontainer); // main container

  this.container = div;
};
/**
* ...
*
* @param {Object} type - fill, line, circle, text, icon...
* @param {Object} value - see example
* @returns {Boolean} - see this.legendRender
*
* @private
* @example
* // type simple for fill, line or circle type:
* // "paint": {
* //     "fill-color": "#2BB3E1"
* // }
*
* // TODO type complexe : not yet implemented !
* // "paint": {
* //     "fill-color": [
* //          "match",
* //          ["get","symbo"],
* //          "ZONE_BOISEE","#A7DA81",
* //          "ZONE_MANGROVE","#7E8AB5",
* //          "#A7DA81"
* //      ]
* // }
*
* // TODO other type complexe : not yet implemented !
* // "paint": {
* //     "fill-color": {
* //        "base": 1,
* //        "stops": [
* //        [
* //          15.5,
* //         "#f2eae2"
* //        ],
* //        [
* //          16,
* //          "#dfdbd7"
* //        ]
* //        ]
* //     }
* // }
*
* // TODO symbol with text (1) / symbol without text (2) / text (3)
* // "layout":{
* //      "icon-image":"{maki}-11",          <!--- IT'S A SYMBOL (1) (2)-->
* //      "text-font":[
* //           "Open Sans Semibold",
* //           "Arial Unicode MS Bold"
* //       ],
* //       "text-field":"{name_en}",         <!--- IT'S A TEXT (1) (3)-->
* //       "text-max-width":9,
* //       "text-padding":2,
* //       "text-offset":[
* //            0,
* //            0.6
* //       ],
* //       "text-anchor":"top",
* //       "text-size":12
* // },
* // "paint":{
* //     "text-color":"#666",
* //     "text-halo-color":"#ffffff",
* //     "text-halo-width":1,
* //     "text-halo-blur":0.5
* // },
*
*/


Legend.prototype._getValues = function (type, value) {
  logger.trace("_getValues():", type, value); // objets

  var pColor = null;
  var pStroke = null;
  var pWidth = null;
  var pOpacity = null; // par defaut...

  var _color = this.legendRender.values.color; // couleur remplissage

  var _stroke = this.legendRender.values.stroke; // couleur trait

  var _width = this.legendRender.values.width; // epaisseur

  var _opacity = this.legendRender.values.opacity; // opacité

  var _icon = null; // cas particulier : determiner pour un symbole complexe

  if (type === "symbol") {
    // il existe 2 type de symbole :
    // - texte
    // - icone avec ou sans texte
    var _textValue = value["text-field"];
    var _iconValue = value["icon-image"];
    type = _textValue && _iconValue ? "icon" : _textValue ? "text" : _iconValue ? "icon" : "unknow";

    if (type === "unknow") {
      logger.warn("_getValues() - Type inconnu :", type, value); // on force le type texte !?

      type = "text";
    }
  }

  switch (type) {
    case "line":
      pColor = value["line-color"];

      if (Array.isArray(pColor) || _typeof(pColor) === "object") {
        _color = null;
        break;
      }

      _color = pColor || _color;
      pWidth = value["line-width"];
      _width = Array.isArray(pWidth) || _typeof(pWidth) === "object" ? _width : pWidth || _width;
      pOpacity = value["line-opacity"];
      _opacity = Array.isArray(pOpacity) || _typeof(pOpacity) === "object" ? _opacity : pOpacity || _opacity;
      break;

    case "text":
      pColor = value["text-color"];

      if (Array.isArray(pColor) || _typeof(pColor) === "object") {
        _color = null;
        break;
      } // FIXME c'est plus complexe !?


      _color = pColor || _color;
      break;

    case "icon":
      var bfound = false;

      if (value["icon-image"] && this.options.sprites && Object.keys(this.options.sprites).length) {
        if (this.options.sprites.json && this.options.sprites.json[value["icon-image"]]) {
          bfound = true;
        }
      }

      if (bfound) {
        _icon = value["icon-image"];
      } else {
        pColor = value["icon-color"];

        if (Array.isArray(pColor) || _typeof(pColor) === "object") {
          _color = null;
          break;
        } // FIXME  c'est plus complexe !?


        _color = pColor || _color;
      }

      break;

    case "circle":
      pColor = value["circle-color"];

      if (Array.isArray(pColor) || _typeof(pColor) === "object") {
        _color = null;
        break;
      }

      _color = pColor || _color;
      pStroke = value["circle-stroke-color"];
      _stroke = Array.isArray(pStroke) || _typeof(pStroke) === "object" ? _stroke : pStroke || _stroke;
      pOpacity = value["circle-opacity"];
      _opacity = Array.isArray(pOpacity) || _typeof(pOpacity) === "object" ? _opacity : pOpacity || _opacity;
      pWidth = value["circle-stroke-width"];
      _width = Array.isArray(pWidth) || _typeof(pWidth) === "object" ? _width : pWidth || _width;
      break;

    case "background":
      pColor = value["background-color"];

      if (Array.isArray(pColor) || _typeof(pColor) === "object") {
        _color = null;
        break;
      }

      _color = pColor || _color;
      break;

    case "fill":
      pColor = value["fill-color"];

      if (Array.isArray(pColor) || _typeof(pColor) === "object") {
        _color = null;
        break;
      }

      _color = pColor || _color;
      pOpacity = value["fill-opacity"];
      _opacity = Array.isArray(pOpacity) || _typeof(pOpacity) === "object" ? _opacity : pOpacity || _opacity;
      break;

    default: // return false;

  } // save


  this.legendRender = {
    type: type,
    values: {
      color: _color,
      stroke: _stroke,
      width: _width,
      opacity: _opacity,
      icon: _icon
    }
  };
  return true;
};
/**
* ...
*
* @param {Object} type - fill, line, circle, text, ...
* @param {Object} values - {"color":..., "width":..., "stroke":...., "opacity":...}
* @returns {Boolean} true/false
*
* @private
* @example
* (...)
*/


Legend.prototype._setValues = function (type, values) {
  // div de rendu de la legende
  var div = this.rendercontainer;

  if (!div) {
    return false;
  } // les valeurs


  var _color = values.color || this.legendRender.values.color; // couleur remplissage


  var _stroke = values.stroke || this.legendRender.values.stroke; // couleur trait


  var _width = values.width || this.legendRender.values.width; // epaisseur


  var _opacity = values.opacity || this.legendRender.values.opacity; // opacité


  var _icon = values.icon || this.legendRender.values.icon; // nom de l'icone


  var _style = ""; // SVG

  var svg = null; // facteur grossissement (x10) pour le trait

  var factor = 10; // en fonction du type, on y ajoute le style

  switch (type) {
    case "text":
      _style = "font-size: 5em;font-weight: bold;";
      svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><text x='50' y='50' fill='%color%' fill-opacity='%opacity%'  text-anchor='middle' alignment-baseline='central' style='%style%'> T </text></svg>\")";
      div.style["background"] = svg.replace("%color%", _color.indexOf("rgb") === 0 ? _color : _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(_color, 1)).replace("%opacity%", _opacity).replace("%style%", _style);
      break;

    case "icon":
      if (_icon) {
        // FIXME on reste dans le paradigme d'utilisation du SVG...,
        // mais probleme de ratio de l'image !?
        var template = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' width='27px' height='27px' x='0' y='0' viewBox='%x% %y% %w% %h%'><image width='%W%px' height='%H%px' href='%URL%'/></svg>";
        svg = template.replace("%x%", this.options.sprites.json[_icon].x).replace("%y%", this.options.sprites.json[_icon].y).replace(/%w%/g, this.options.sprites.json[_icon].width).replace(/%h%/g, this.options.sprites.json[_icon].height).replace("%W%", this.options.sprites.size.w).replace("%H%", this.options.sprites.size.h).replace("%URL%", this.options.sprites.url);
        div.innerHTML = svg;
      } else {
        _style = "fill: transparent;stroke-width: 10;";
        svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><path d='M 50,20 80,82.5 20,82.5 z' stroke='%color%' style='%style%'/></svg>\")";
        div.style["background"] = svg.replace("%color%", _color.indexOf("rgb") === 0 ? _color : _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(_color, 1)).replace("%style%", _style);
      }

      break;

    case "background":
      div.style["background-color"] = _color;
      break;

    case "line":
      svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><path d='M0 99 L99 0 L100 1 L1 100' stroke='%color%' stroke-width='%width%' stroke-opacity='%opacity%' /></svg>\")";
      div.style["background"] = svg.replace("%color%", _color.indexOf("rgb") === 0 ? _color : _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(_color, 1)).replace("%opacity%", _opacity).replace("%width%", _width * factor);
      break;

    case "circle":
      svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' stroke='%stroke%' stroke-width='%width%' stroke-opacity='%opacity%' fill='%color%' fill-opacity='%opacity%' /></svg>\")";
      div.style["background"] = svg.replace("%color%", _color.indexOf("rgb") === 0 ? _color : _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(_color, 1)).replace("%opacity%", _opacity).replace("%stroke%", _stroke.indexOf("rgb") === 0 ? _stroke : _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(_stroke, 1)).replace("%width%", _width * factor);
      break;

    case "fill":
      svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><rect x='0' y='0' width='100' height='100' rx='5' ry='5' fill='%color%' fill-opacity='%opacity%' /></svg>\")";
      div.style["background"] = svg.replace("%color%", _color.indexOf("rgb") === 0 ? _color : _Common_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(_color, 1)).replace("%opacity%", _opacity);
      break;

    default:
      return false;
  } // save


  this.legendRender = {
    type: type,
    values: {
      color: _color,
      stroke: _stroke,
      width: _width,
      opacity: _opacity,
      icon: _icon
    }
  };
  return true;
};
/**
* Create a Graphical Legend Icon
*
* @param {Object} params - param
* @param {String} params.title - title
* @param {String} params.type - fill, line, circle, text, icon, ...
* @param {String} params.values - {"color": "#2BB3E1", "width": 10, "opacity": 0.5, "stroke": "#2BB3E1"}
* @param {Boolean} params.edit - editable with a colorPicker for only line, fill and circle legend !
* @returns {DOMElement} DOM element
*
* @private
* @example
*   <div class="GPEditorMapBoxLegendRenderContainer">
*       <div class="GPEditorMapBoxLegendRender GPEditorMapBoxLegendEditable legend-fill"
*           style="background: url(&quot;data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><rect x='0' y='0' width='100' height='100' rx='5' ry='5' fill='rgba(255, 255, 255, 1)' fill-opacity='1' /></svg>&quot;);">
*       </div>
*       <span class="GPEditorMapBoxLegendTitle">vide...</span>
</div>
*/


Legend.prototype._createElementIconLegend = function (params) {
  // contexte
  var self = this;
  var container = document.createElement("div");
  container.className = this.name.containerlegendrender;
  var div = this.rendercontainer = document.createElement("div");
  div.className = this.name.legendrender;

  if (params.edit) {
    div.className += " ";
    div.className += this.name.legendeditable;

    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        self.onEditionLegendMapBox(e);
      });
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function (e) {
        self.onEditionLegendMapBox(e);
      });
    }
  } // couleur remplissage


  var _color = params.values.color; // couleur trait

  var _stroke = params.values.stroke; // epaisseur

  var _width = params.values.width; // opacité

  var _opacity = params.values.opacity; // type de legende

  var _type = params.type; // si la couleur n'est pas definie, c'est que le type de syntaxe
  // est non implementé ou non reconnu pour le moment...

  if (!_color) {
    // className
    div.className += " legend-not-implemented";
  } else {
    // ajout du style qur la div de rendu
    if (this._setValues(_type, {
      color: _color,
      stroke: _stroke,
      width: _width,
      opacity: _opacity
    })) {
      // className possibles :
      // " legend-text"
      // " legend-icon"
      // " legend-background"
      // " legend-line"
      // " legend-line-not-editable"
      // " legend-circle"
      // " legend-circle-not-editable"
      // " legend-fill"
      // " legend-fill-not-editable"
      div.className += params.edit ? " legend-" + _type : " legend-" + _type + "-not-editable";
    } else {
      div.className += " legend-unknow";
    }
  }

  container.appendChild(div);
  var span = document.createElement("span");
  span.className = this.name.legendtitle;
  span.innerHTML = params.title || "";
  container.appendChild(span);
  return container;
};
/**
* Create a Graphical Legend Edition
*
* @param {Object} params - param
* @param {String} params.type - fill, line, (TODO : circle, icon or text)
* @param {String} params.values - {"fill-color": "#2BB3E1"}
* @param {Boolean} params.edit - editable with a colorPicker for only line and fill legend !
* @returns {DOMElement} DOM element
*
* @private
* @example
*   <div class="GPEditorMapBoxLegendToolsContainer">
*       <div class="legend-styling-div">
*           <label for="stroke-color">Couleur du trait</label>
*           <input class="legend-styling" id="stroke-color" title="" type="color">
*       </div>
*       <div class="legend-styling-div">
*           <label for="stroke-width">Epaisseur du trait</label>
*           <input class="legend-styling" id="stroke-width" title="" type="range" min="0" max="10" step="1" value="1">
*       </div>
*       <div class="legend-styling-div">
*           <label for="stroke-opacity">Opacité du trait</label>
*           <input class="legend-styling" id="stroke-opacity" title="" type="range" min="0" max="1" step="0.1" value="1">
*       </div>
*       <div class="legend-styling-div">
*           <label for="fill-color">Couleur de remplissage</label>
*        <input class="legend-styling" id="fill-color" title="" type="color">
*       </div>
*       <div class="legend-styling-div">
*           <label for="fill-opacity">Opacité du remplissage</label>
*           <input class="legend-styling" id="fill-opacity" title="" type="range" min="0" max="1" step="0.1" value="1">
*       </div>
*   </div>
*/


Legend.prototype._createElementEditionLegend = function (params) {
  // contexte
  var self = this;
  var container = document.createElement("div");
  container.className = this.name.containerlegendtools; // uniquement les elements editables !

  if (!params.edit) {
    return container;
  } // on ne traite que l'edition du mode 'traits' ou 'surfaciques'
  // mode 'line'


  if (params.type === "line") {
    // couleur du trait
    var linecolor = document.createElement("div");
    linecolor.className = "legend-styling-div";
    var lLineColor = document.createElement("label");
    lLineColor.htmlFor = "line-color";
    lLineColor.innerHTML = this.labels["line-color"];
    var inputLineColor = document.createElement("input");
    inputLineColor.className = "legend-styling";
    inputLineColor.id = "line-color";
    inputLineColor.title = "Selectionner une couleur de trait";
    inputLineColor.type = "color";
    inputLineColor.value = params.values.color;

    if (inputLineColor.addEventListener) {
      inputLineColor.addEventListener("change", function (e) {
        self._setValues(params.type, {
          color: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    } else if (inputLineColor.attachEvent) {
      inputLineColor.attachEvent("onchange", function (e) {
        self._setValues(params.type, {
          color: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    }

    linecolor.appendChild(lLineColor);
    linecolor.appendChild(inputLineColor);
    container.appendChild(linecolor); // epaisseur du trait

    var linewidth = document.createElement("div");
    linewidth.className = "legend-styling-div";
    var lLineWidth = document.createElement("label");
    lLineWidth.htmlFor = "line-width";
    lLineWidth.innerHTML = this.labels["line-width"];
    var inputLineWidth = document.createElement("input");
    inputLineWidth.className = "legend-styling";
    inputLineWidth.id = "line-width";
    inputLineWidth.title = params.values.width;
    inputLineWidth.type = "range";
    inputLineWidth.min = "0";
    inputLineWidth.max = "10";
    inputLineWidth.step = "1";
    inputLineWidth.defaultValue = params.values.width;

    if (inputLineWidth.addEventListener) {
      inputLineWidth.addEventListener("change", function (e) {
        logger.trace(e);
        e.target.title = e.target.value;

        self._setValues(params.type, {
          width: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    } else if (inputLineWidth.attachEvent) {
      inputLineWidth.attachEvent("onchange", function (e) {
        logger.trace(e);
        e.target.title = e.target.value;

        self._setValues(params.type, {
          width: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    }

    linewidth.appendChild(lLineWidth);
    linewidth.appendChild(inputLineWidth);
    container.appendChild(linewidth); // opacité du trait

    var lineopacity = document.createElement("div");
    lineopacity.className = "legend-styling-div";
    var lLineOpacity = document.createElement("label");
    lLineOpacity.htmlFor = "line-opacity";
    lLineOpacity.innerHTML = this.labels["line-opacity"];
    var inputLineOpacity = document.createElement("input");
    inputLineOpacity.className = "legend-styling";
    inputLineOpacity.id = "line-opacity";
    inputLineOpacity.title = params.values.opacity;
    inputLineOpacity.type = "range";
    inputLineOpacity.min = "0";
    inputLineOpacity.max = "1";
    inputLineOpacity.step = "0.1";
    inputLineOpacity.defaultValue = params.values.opacity;

    if (inputLineOpacity.addEventListener) {
      inputLineOpacity.addEventListener("change", function (e) {
        logger.trace(e);
        e.target.title = e.target.value;

        self._setValues(params.type, {
          opacity: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    } else if (inputLineOpacity.attachEvent) {
      inputLineOpacity.attachEvent("onchange", function (e) {
        logger.trace(e);
        e.target.title = e.target.value;

        self._setValues(params.type, {
          opacity: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    }

    lineopacity.appendChild(lLineOpacity);
    lineopacity.appendChild(inputLineOpacity);
    container.appendChild(lineopacity);
  } // mode 'fill'


  if (params.type === "fill") {
    // couleur de remplissage
    var fillcolor = document.createElement("div");
    fillcolor.className = "legend-styling-div";
    var lFillColor = document.createElement("label");
    lFillColor.htmlFor = "fill-color";
    lFillColor.innerHTML = this.labels["fill-color"];
    var inputFillColor = document.createElement("input");
    inputFillColor.className = "legend-styling";
    inputFillColor.id = "fill-color";
    inputFillColor.title = "Selectionner une couleur de remplissage";
    inputFillColor.type = "color";
    inputFillColor.value = params.values.color;

    if (inputFillColor.addEventListener) {
      inputFillColor.addEventListener("change", function (e) {
        self._setValues(params.type, {
          color: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    } else if (inputFillColor.attachEvent) {
      inputFillColor.attachEvent("onchange", function (e) {
        self._setValues(params.type, {
          color: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    }

    fillcolor.appendChild(lFillColor);
    fillcolor.appendChild(inputFillColor);
    container.appendChild(fillcolor); // opacité du remplissage

    var fillopacity = document.createElement("div");
    fillopacity.className = "legend-styling-div";
    var lFillOpacity = document.createElement("label");
    lFillOpacity.htmlFor = "fill-opacity";
    lFillOpacity.innerHTML = this.labels["fill-opacity"];
    var inputFillOpacity = document.createElement("input");
    inputFillOpacity.className = "legend-styling";
    inputFillOpacity.id = "fill-opacity";
    inputFillOpacity.title = params.values.opacity;
    inputFillOpacity.type = "range";
    inputFillOpacity.min = "0";
    inputFillOpacity.max = "1";
    inputFillOpacity.step = "0.1";
    inputFillOpacity.defaultValue = params.values.opacity;

    if (inputFillOpacity.addEventListener) {
      inputFillOpacity.addEventListener("change", function (e) {
        e.target.title = e.target.value;

        self._setValues(params.type, {
          opacity: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    } else if (inputFillOpacity.attachEvent) {
      inputFillOpacity.attachEvent("onchange", function (e) {
        e.target.title = e.target.value;

        self._setValues(params.type, {
          opacity: e.target.value
        });

        self.onChangeValueLegendMapBox(e);
      });
    }

    fillopacity.appendChild(lFillOpacity);
    fillopacity.appendChild(inputFillOpacity);
    container.appendChild(fillopacity);
  }

  return container;
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Add element into target DOM
 * @returns {Object} - Legend instance
 */


Legend.prototype.add = function () {
  if (!this.options.target) {
    if (!document.getElementById(this.name.target)) {
      var div = document.createElement("div");
      div.id = this.name.target;
      var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
      node.appendChild(div);
    }

    this.options.target = document.getElementById(this.name.target);
  }

  if (this.container) {
    this.options.target.appendChild(this.container);
  }

  return this;
};
/**
 * Set display container or get
 *
 * @param {Boolean} display - show/hidden container or get status
 * @returns {Boolean} - true/false
 */


Legend.prototype.display = function (display) {
  logger.trace("display()", display);

  if (typeof display !== "undefined") {
    this.container.style.display = display ? "flex" : "none";
  }

  return this.container.style.display === "flex";
};
/**
 * Is editable
 *
 * @returns {Boolean} - true/false
 */


Legend.prototype.isEditable = function () {
  return this.editable;
};
/**
 * Get container Legend Render (DOM)
 *
 * @returns {DOMElement} DOM element
 * @see Layer.prototype.slotLegend()
 * @example
 *  <div class="GPEditorMapBoxLegendRender legend-(line|fill|background|text|icon|circle|unknow)" style="..."></div>
 */


Legend.prototype.getRenderContainer = function () {
  return this.rendercontainer;
};
/**
 * Get container Legend Tools (DOM)
 *
 * @returns {DOMElement} DOM element
 * @see Layer.prototype.slotLegend()
 * @example
 *  <div class="GPEditorMapBoxLegendToolsContainer">...</div>
 */


Legend.prototype.getToolsContainer = function () {
  return this.toolscontainer;
};
/**
 * Get container (DOM)
 *
 * @returns {DOMElement} DOM element
 */


Legend.prototype.getContainer = function () {
  return this.container;
}; // ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //

/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Legend#editor:legend:onclickedition
 */


Legend.prototype.onEditionLegendMapBox = function (e) {
  logger.trace("onEditionLegendMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].legend.onclickedition, e);
};
/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Legend#editor:legend:onchangevalue
 */


Legend.prototype.onChangeValueLegendMapBox = function (e) {
  logger.trace("onChangeValueLegendMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].legend.onchangevalue, e);
};

/* harmony default export */ __webpack_exports__["default"] = (Legend);

/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _Style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(266);
/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(270);
/* harmony import */ var _Filter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(269);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(141);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }








var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__["default"].getLogger("editor-layer");
/**
 * @classdesc
 *
 * MapBox filter management
 *
 * @constructor
 * @alias ol.style.editor.Layer
 * @param {Object} options - options for function call.
 * @example
 *   var layers = new Layer ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      tools : {
 *          "visibility" : true, // afficher l'icone de visibilité
 *          "icon" : {
 *              "image" : true, // afficher l'icone "oeil" (defaut) ou une checkbox
 *              "anchor" : "start" | "end"  // afficher l'icone au debut ou à la fin (defaut)
 *          },
 *          "type" : true,       // afficher l'icone du type de geometrie
 *          "pin" : true,        // afficher l'icone de puce
 *          "remove" : false,    // TODO afficher l'icone de suppression
 *          "clone" : false      // TODO afficher l'icone de duplication
 *      },
 *      obj : {
 *          "id": "ocs - vegetation", // MANDATORY
 *          "type": "fill", // OPTIONAL
 *          "source": "pyramide_proto", // OPTIONAL
 *          "source-layer": "ocs_vegetation_surf" // OPTIONAL
 *      }
 *   });
 *  layers.addLegend(oLegend);
 *  layers.slotLegend();
 *  layers.addStyle(oStyle);
 *  layers.addFilter(oFilter);
 *  layers.add();
 *  layers.active(false);
 *  layers.visibility(false);
 *  layers.display(false);
 *  layers.collapse();
 *  EventBus.addEventListener("editor:layer:onclickvisibility", function (e) {
 *     // e.target.data : options !
 *     // e.target.editorID : id or null
 *   }, this);
 */

function Layer(options) {
  logger.trace("[constructor] Layer", options); // options

  this.options = options || {};

  if (!(this instanceof Layer)) {
    throw new TypeError("ERROR CLASS_CONSTRUCTOR");
  }

  this._initialize();

  this._initContainer();
}

;
/**
 * Constructor (alias)
 *
 * @private
 */

Layer.prototype.constructor = Layer; // ################################################################### //
// ##################### private methods ############################# //
// ################################################################### //

/**
 * Initialize component
 * (called by constructor)
 *
 * @private
 */

Layer.prototype._initialize = function () {
  // unique editor id (optional!)
  this.id = this.options.id || null; // null si le layer n'appartient pas à un editeur !

  if (!this.options.target) {// cf. add()
  }

  if (!this.options.position) {
    this.options.position = 0;
  }

  var _toolsDefault = {
    visibility: true,
    icon: {
      image: true,
      anchor: "end"
    },
    type: true,
    pin: true,
    remove: false,
    // TODO
    clone: false // TODO

  };

  if (!this.options.tools) {
    this.options.tools = _toolsDefault;
  }

  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].mergeParams(this.options.tools, _toolsDefault, false);
  var _objDefault = {
    id: "",
    type: "",
    // icone sur le type de geometrie
    source: "",
    "source-layer": ""
  };

  if (!this.options.obj) {
    this.options.obj = _objDefault;
  }

  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].mergeParams(this.options.obj, _objDefault, false); // legende intégrée

  this.bSlotLegend = false; // obj

  this.oFilter = null;
  this.oStyle = null;
  this.oLegend = null; // dom

  this.container = null;
  this.DomVisibility = null;
  this.DomToggle = null; // DOM : className or id

  this.name = {
    target: "GPEditorMapBoxLayerTarget",
    container: "GPEditorMapBoxLayerContainer",
    containerlegend: "GPEditorMapBoxLayerLegendContainer",
    containertitle: "GPEditorMapBoxLayerTitleContainer",
    imagelabelinput: "GPEditorMapBoxLayerImageInput",
    imagelabel: "GPEditorMapBoxLayerImageLabel",
    typeimg: "GPEditorMapBoxLayerTypeImage",
    titleinput: "GPEditorMapBoxLayerTitleInput",
    titlelabel: "GPEditorMapBoxLayerTitleLabel",
    containertools: "GPEditorMapBoxToolsContainer",
    visibilityinput: "GPEditorMapBoxToolsVisibilityInput",
    visibilitylabel: "GPEditorMapBoxToolsVisibilityLabel",
    visibilityinputdisable: "GPEditorMapBoxToolsVisibilityInputDisable",
    visibilitylabeldisable: "GPEditorMapBoxToolsVisibilityLabelDisable"
  };
};
/**
 * Graphical rendering of the component
 * (called by constructor)
 *
 * @private
 * @example
 * // >> Titre 1          |OOO| <- menu tools : visibility, clone, remove
 * // >> Titre 2          |OXX| <- affichage configurable (cf. options.tools)
 * // Event : clic sur le titre -> ex. affiche le menu des styles / filtres
 * //       : clic visibility, clone, remove
 * // DOM :
 *      <div class="GPEditorMapBoxLayerContainer">
 *          <div id="GPEditorMapBoxLayerTitleContainer-45" class="GPEditorMapBoxLayerTitleContainer">
 *              <input id="GPEditorMapBoxLayerImageInput-45" class="GPEditorMapBoxLayerImageInput" type="checkbox">
 *              <label class="GPEditorMapBoxLayerImageLabel" for="GPEditorMapBoxLayerImageInput-45"></label>
 *              <input id="GPEditorMapBoxLayerTitleInput-45" class="GPEditorMapBoxLayerTitleInput" type="checkbox">
 *              <label class="GPEditorMapBoxLayerTitleLabel" for="GPEditorMapBoxLayerTitleInput-45" title="...">...</label>
 *          </div>
 *          <div id="GPEditorMapBoxToolsContainer-45" class="GPEditorMapBoxToolsContainer">
 *              <input id="GPEditorMapBoxToolsVisibilityInput-45" type="checkbox" class="GPEditorMapBoxToolsVisibilityInput">
 *              <label for="GPEditorMapBoxToolsVisibilityInput-45" id="GPEditorMapBoxToolsVisibilityLabel-45" class="GPEditorMapBoxToolsVisibilityLabel" title="Afficher/masquer la couche"></label>
 *          </div>
 *      </div>
 */


Layer.prototype._initContainer = function () {
  // contexte
  var self = this;
  var obj = this.options.obj;
  var div = document.createElement("div");
  div.className = this.name.container; // title

  var divTitle = document.createElement("div");
  divTitle.id = this.name.containertitle + "-" + this.options.position;
  divTitle.className = this.name.containertitle; // puce

  if (this.options.tools.pin) {
    // Optionnel !
    // input
    var inputImage = document.createElement("input");
    inputImage.id = this.name.imagelabelinput + "-" + this.options.position;
    inputImage.className = this.name.imagelabelinput;
    inputImage.type = "checkbox";
    divTitle.appendChild(inputImage); // puce

    var labelImage = document.createElement("label");
    labelImage.className = this.name.imagelabel;
    labelImage.htmlFor = inputImage.id;

    if (labelImage.addEventListener) {
      labelImage.addEventListener("click", function (e) {
        self.onClickLayerMapBox(e);
      });
    } else if (labelImage.attachEvent) {
      labelImage.attachEvent("onclick", function (e) {
        self.onClickLayerMapBox(e);
      });
    }

    divTitle.appendChild(labelImage);
  } // tools :
  // visibility, (remove, clone)


  var _addTools = function _addTools() {
    var divTools = document.createElement("div");
    divTools.id = this.name.containertools + "-" + this.options.position;
    divTools.className = this.name.containertools; // visibility

    if (this.options.tools.visibility) {
      var inputTools = document.createElement("input");
      inputTools.id = this.name.visibilityinput + "-" + this.options.position;
      inputTools.className = this.options.tools.icon.image ? this.name.visibilityinput : this.name.visibilityinputdisable;
      inputTools.type = "checkbox";
      inputTools.checked = "checked"; // par défaut, à modifier via visibility(true|false) !
      // event for visibility change

      if (inputTools.addEventListener) {
        inputTools.addEventListener("click", function (e) {
          self.onVisibilityLayerMapBox(e);
        });
      } else if (inputTools.attachEvent) {
        // internet explorer
        inputTools.attachEvent("onclick", function (e) {
          self.onVisibilityLayerMapBox(e);
        });
      }

      divTools.appendChild(inputTools); // enregistrement utile pour la méthode : visibility()

      this.DomVisibility = inputTools;
      var labelTools = document.createElement("label");
      labelTools.htmlFor = this.name.visibilityinput + "-" + this.options.position;
      labelTools.id = this.name.visibilitylabel + "-" + this.options.position;
      labelTools.className = this.options.tools.icon.image ? this.name.visibilitylabel : this.name.visibilitylabeldisable;
      labelTools.title = "Afficher/masquer la couche";
      divTools.appendChild(labelTools);
      div.appendChild(divTools);
    } // clone


    if (this.options.tools.clone) {
      // TODO...
      logger.warn("Dom for tools clone, it's not yet implemented !");
    } // remove


    if (this.options.tools.remove) {
      // TODO...
      logger.warn("Dom for tools remove, it's not yet implemented !");
    }
  }; // ajout des outils au debut du composant


  if (this.options.tools.icon.anchor === "start") {
    _addTools.apply(this);
  } // type


  if (this.options.tools.type && obj.type) {
    // Optionnel !
    var imgType = document.createElement("img");
    imgType.className = this.name.typeimg; // FIXME il faudrait faire la difference entre :
    // - icone uniquement : SYMBOL-ICON
    // - texte uniquement : SYMBOL-TEXT
    // - les 2 : SYMBOL
    // Mais il nous faut les styles complets (paint & layout)
    // pour determiner les 3 types !

    switch (obj.type.toUpperCase()) {
      case "SYMBOL-ICON":
        // not used !
        imgType.style["background-position"] = "0px 0";
        break;

      case "SYMBOL-TEXT":
        // not used !
        imgType.style["background-position"] = "-194px 0";
        break;

      case "SYMBOL":
        imgType.style["background-position"] = "-84px 0";
        break;

      case "LINE":
        imgType.style["background-position"] = "-28px 0";
        break;

      case "FILL":
        imgType.style["background-position"] = "-56px 0";
        break;

      case "BACKGROUND":
        imgType.style["background-position"] = "-140px 0";
        break;

      case "CIRCLE":
        imgType.style["background-position"] = "-168px 0";
        break;

      default:
        // type inconnu ou non pris en charge ou par defaut
        imgType.style["background-position"] = "-112px 0";
    }

    divTitle.appendChild(imgType);
  } // container legend (empty)


  var divLegend = document.createElement("div");
  divLegend.id = this.name.containerlegend + "-" + this.options.position;
  divLegend.className = this.name.containerlegend;
  divTitle.appendChild(divLegend); // input

  var inputTitle = document.createElement("input");
  inputTitle.id = this.name.titleinput + "-" + this.options.position;
  inputTitle.className = this.name.titleinput;
  inputTitle.type = "checkbox";
  divTitle.appendChild(inputTitle); // label for

  var labelTitle = document.createElement("label");
  labelTitle.className = this.name.titlelabel;
  labelTitle.htmlFor = inputTitle.id;
  labelTitle.innerHTML = obj["id"] || obj["source-layer"] || obj["source"];
  labelTitle.title = obj["source-layer"] || obj["source"] || obj["id"];

  if (labelTitle.addEventListener) {
    labelTitle.addEventListener("click", function (e) {
      self.onClickLayerMapBox(e);
    });
  } else if (labelTitle.attachEvent) {
    labelTitle.attachEvent("onclick", function (e) {
      self.onClickLayerMapBox(e);
    });
  }

  divTitle.appendChild(labelTitle); // enregistrement utile pour la méthode : collapse()

  this.DomToggle = labelTitle;
  div.appendChild(divTitle); // ajout des outils au fin du composant

  if (this.options.tools.icon.anchor === "end") {
    _addTools.apply(this);
  } // main container


  this.container = div;
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Add element into target DOM
 * @returns {Object} - Layer instance
 */


Layer.prototype.add = function () {
  logger.trace("add()");

  if (!this.options.target) {
    if (!document.getElementById(this.name.target)) {
      var div = document.createElement("div");
      div.id = this.name.target;
      var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
      node.appendChild(div);
    }

    this.options.target = document.getElementById(this.name.target);
  }

  if (this.container) {
    this.options.target.appendChild(this.container);
  }

  return this;
};
/**
 * Add style in the submenu
 *
 * @param {Object} style - style object
 */


Layer.prototype.addStyle = function (style) {
  logger.trace("addStyle()", style);

  if (style && _typeof(style) === "object" && style instanceof _Style__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    this.oStyle = style;
    this.oStyle.display(false); // par defaut !
  }
};
/**
 * Add filter in the submenu
 *
 * @param {Object} filter - filter object
 */


Layer.prototype.addFilter = function (filter) {
  logger.trace("addFilter()", filter);

  if (filter && _typeof(filter) === "object" && filter instanceof _Filter__WEBPACK_IMPORTED_MODULE_4__["default"]) {
    this.oFilter = filter;
    this.oFilter.display(false); // par defaut !
  }
};
/**
 * Add Legend in the submenu
 *
 * @param {Object} legend - legend object
 */


Layer.prototype.addLegend = function (legend) {
  logger.trace("addLegend()", legend);

  if (legend && _typeof(legend) === "object" && legend instanceof _Legend__WEBPACK_IMPORTED_MODULE_3__["default"]) {
    this.oLegend = legend;
    this.oLegend.display(false); // par defaut !
  }
};
/**
 * Integrate Legend to the layer container
 */


Layer.prototype.slotLegend = function () {
  // cas particulier :
  // on souhaite intégrer une partie de la legende dans le container du layer.
  var legend = this.oLegend;

  if (legend) {
    // FIXME c'est pourri...
    var node = null;
    var nodesLvl1 = this.container.childNodes;

    if (nodesLvl1.length) {
      // selon où se situe l'icone de visibilité : au debut ou à la fin...
      var idx = this.options.tools.icon.anchor === "start" ? 1 : 0;
      var nodesLvl2 = nodesLvl1[idx].childNodes; // on recherche le container de la legende

      for (var i = 0; i < nodesLvl2.length; i++) {
        var curnode = nodesLvl2[i];

        if (curnode.id.indexOf(this.name.containerlegend) !== -1) {
          node = curnode;
        }
      }
    }

    if (node) {
      var render = legend.getRenderContainer();

      if (render) {
        node.appendChild(render); // legende intégrée

        this.bSlotLegend = true;
      }
    }
  }
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Set visibility or get
 *
 * @param {Boolean} display - set visibility or undefined to get status
 * @returns {Boolean} - true/false
 */


Layer.prototype.visibility = function (display) {
  logger.trace("visibility()", display);

  if (!this.options.tools.visibility) {
    return;
  }

  if (typeof display !== "undefined") {
    this.DomVisibility.checked = display ? "checked" : "";
  }

  return this.DomVisibility.checked;
};
/**
* Collapse a layer panel (event)
*/


Layer.prototype.collapse = function () {
  logger.trace("collapse()");
  this.DomToggle.click();
};
/**
* Click on visibility icon (event)
*/


Layer.prototype.visible = function () {
  logger.trace("visible()");

  if (!this.options.tools.visibility) {
    return;
  }

  this.DomVisibility.click();
};
/**
 * Set collapse or get
 *
 * @param {Boolean} display - show/hidden container or get status
 * @returns {Boolean} - true/false
 */


Layer.prototype.display = function (display) {
  logger.trace("display()", display);
  var checked = document.getElementById(this.DomToggle.htmlFor).checked;

  if (typeof display !== "undefined") {
    this.container.style.display = display ? "inline-flex" : "none";

    if (this.oStyle) {
      this.oStyle.display(display && checked);
    }

    if (this.oFilter) {
      this.oFilter.display(display && checked);
    }

    if (this.oLegend) {
      this.oLegend.display(display && checked);
    }
  }

  return checked;
};
/**
 * Set disabled/enabled status or get
 *
 * @param {Boolean} active - disable/enable layer interaction or get status
 * @returns {Boolean} - true/false
 */


Layer.prototype.active = function (active) {
  logger.trace("active()", active);

  if (typeof active !== "undefined") {
    this.container.className = active ? this.name.container : this.name.container + " disabled";
  }

  return this.container.className === this.name.container;
};
/**
 * Get container (DOM)
 *
 * @returns {DOMElement} DOM element
 */


Layer.prototype.getContainer = function () {
  return this.container;
}; // ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //

/**
 * this method is called by event '' on '' tag form
 *
 * @param {Object} e - HTMLElement
 * @private
 */


Layer.prototype.onClickLayerMapBox = function (e) {
  logger.trace("onClickLayerMapBox", e);
  var id = e.target.htmlFor.substring(e.target.htmlFor.indexOf("-"));
  var checked = document.getElementById(e.target.htmlFor).checked; // gestion des inputs

  if (e.target.htmlFor === this.name.imagelabelinput + id) {
    document.getElementById(this.name.titleinput + id).checked = !checked;
  }

  if (e.target.htmlFor === this.name.titleinput + id) {
    // si options.pin:false, ce DOM n'existe pas !
    if (document.getElementById(this.name.imagelabelinput + id)) {
      document.getElementById(this.name.imagelabelinput + id).checked = !checked;
    }
  } // ouverture du panneau des styles / filtres


  if (this.oStyle) {
    this.oStyle.display(!checked);
  }

  if (this.oFilter) {
    this.oFilter.display(!checked);
  } // attention,
  // si la legende est non editable, elle ne se trouve pas dans le sous menu !


  if (this.oLegend && this.oLegend.isEditable()) {
    this.oLegend.display(!checked);
  }
};
/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Layer#editor:layer:onclickvisibility
 */


Layer.prototype.onVisibilityLayerMapBox = function (e) {
  logger.trace("onVisibilityLayerMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].layer.onclickvisibility, e);
};
/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Layer#editor:layer:onclickclone
 */


Layer.prototype.onCloneLayerMapBox = function (e) {
  logger.trace("onCloneLayerMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].layer.onclickclone, e);
};
/**
 * this method is called by event '' on '' tag form...
 *
 * 'e' contains the option object into 'e.target.data' !
 * 'e' contains the id editor into 'e.target.editorID' !
 *
 * @param {Object} e - HTMLElement
 * @private
 * @fires Layer#editor:layer:onclickremove
 */


Layer.prototype.onRemoveLayerMapBox = function (e) {
  logger.trace("onRemoveLayerMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].layer.onclickremove, e);
};

/* harmony default export */ __webpack_exports__["default"] = (Layer);

/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(264);
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(141);



var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("editor-group");
/**
 * @classdesc
 *
 * MapBox group management
 *
 * @constructor
 * @alias ol.style.editor.Group
 * @param {Object} options - options for function call.
 * @example
 *   var group = new Group ({
 *      title : "MyGroup",
 *      collapse : true, // plier/deplier
 *      target : ...
 *   });
 *   group.add();
 *   group.add();
 */

function Group(options) {
  logger.trace("[constructor] Group", options); // options

  this.options = options || {// default...
  };

  if (!(this instanceof Group)) {
    throw new TypeError("ERROR CLASS_CONSTRUCTOR");
  }

  this._initialize();

  this._initContainer();
}

;
/**
 * Constructor (alias)
 *
 * @private
 */

Group.prototype.constructor = Group;
/**
 * Initialize component
 * (called by constructor)
 *
 * @private
 */

Group.prototype._initialize = function () {
  // unique editor id (optional!)
  this.id = this.options.id || null;

  if (!this.options.target) {// cf. add()
  }

  if (!this.options.title) {
    // cf. summary
    this.options.title = "Détails du groupe...";
  } // plier par defaut


  if (typeof this.options.collapse === "undefined") {
    this.options.collapse = true;
  }

  this.container = null; // DOM : className or id

  this.name = {
    target: "GPEditorMapBoxGroupTarget",
    container: "GPEditorMapBoxGroupContainer",
    details: "GPEditorMapBoxGroupDetails",
    summary: "GPEditorMapBoxGroupSummary"
  };
};
/**
 * Graphical rendering of the component
 * (called by constructor)
 *
 * @private
 * @example
 * <div class="GPEditorMapBoxGroupContainer">...</div>
 */


Group.prototype._initContainer = function () {
  var div = document.createElement("div");
  div.className = this.name.container; // FIXME pas compatible IE !
  // https://caniuse.com/#search=details
  // cf. https://css-tricks.com/quick-reminder-that-details-summary-is-the-easiest-way-ever-to-make-an-accordion/

  var details = document.createElement("details");
  details.className = this.name.details;
  details.open = !this.options.collapse;
  div.appendChild(details);
  var summary = document.createElement("summary");
  summary.className = this.name.summary;
  summary.innerHTML = this.options.title;
  details.appendChild(summary); // main container

  this.container = div;
}; // ################################################################### //
// ##################### public methods ############################## //
// ################################################################### //

/**
 * Add element into target DOM
 */


Group.prototype.add = function () {
  if (!this.options.target) {
    if (!document.getElementById(this.name.target)) {
      var div = document.createElement("div");
      div.id = this.name.target;
      var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
      node.appendChild(div);
    }

    this.options.target = document.getElementById(this.name.target);
  }

  if (this.container) {
    this.options.target.appendChild(this.container);
  }
};
/**
 * Set display container (DOM)
 *
 * @param {Boolean} display - show/hidden container
 */


Group.prototype.display = function (display) {
  this.container.style.display = display ? "flex" : "none";
};
/**
 * Get container (DOM)
 *
 * @returns {DOMElement} DOM element
 */


Group.prototype.getContainer = function () {
  var nodes = this.container.childNodes;

  if (nodes.length) {
    // retourne le noeud "details" !
    return nodes[0];
  } // sinon le container principal


  return this.container;
}; // ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //

/**
 * this method is called by event '' on '' tag form
 *
 * NOT USED !
 * @param {Object} e - HTMLElement
 * @private
 * @fires Group#editor:group:oncollapse
 */


Group.prototype.onCollapseGroupMapBox = function (e) {
  logger.trace("onCollapseGroupMapBox", e);
  e.editorID = this.id;
  e.data = this.options;
  eventbusjs__WEBPACK_IMPORTED_MODULE_0___default.a.dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].group.oncollapse, e);
};

/* harmony default export */ __webpack_exports__["default"] = (Group);

/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var EditorDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (EditorDOM);

/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);

var LayerImportDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Map loading
   *
   * @returns {DOMElement} container
   */
  _createLoadingElement: function _createLoadingElement() {
    var div = document.createElement("div");
    div.id = "GPmapLoading";
    div.className = "";
    return div;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPimport");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ######################### show widget ############################# //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowImportElement: function _createShowImportElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowImport");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show Import
   *
   * @returns {DOMElement} DOM element
   */
  _createShowImportPictoElement: function _createShowImportPictoElement() {
    // contexte d'execution
    var self = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowImportPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowImport");
    label.title = "Ouvrir l'import de couches"; // Close all results and panels when minimizing the widget

    if (label.addEventListener) {
      label.addEventListener("click", function () {
        self._onShowImportClick();
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function () {
        self._onShowImportClick();
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowImportOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },
  // ################################################################### //
  // ######################### Header panel ############################ //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelElement: function _createImportPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportPanel");
    div.className = "GPpanel";
    return div;
  },

  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelHeaderElement: function _createImportPanelHeaderElement() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader"; // panel title

    var panelTitle = this._createImportPanelTitleElement();

    container.appendChild(panelTitle); // close picto

    var closeDiv = this._createImportPanelCloseElement();

    container.appendChild(closeDiv);
    return container;
  },

  /**
   * Create Header Title Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelTitleElement: function _createImportPanelTitleElement() {
    var div = document.createElement("div");
    div.className = "GPpanelTitle";
    div.innerHTML = "Import de données";
    return div;
  },

  /**
   * Create Header close div
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelCloseElement: function _createImportPanelCloseElement() {
    // contexte
    var self = this;
    var divClose = document.createElement("div");
    divClose.id = this._addUID("GPimportPanelClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer le panneau"; // Link panel close / visibility checkbox

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowImportPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowImportPicto")).click();
      });
    }

    return divClose;
  },
  // ################################################################### //
  // ########################### Form panel ############################ //
  // ################################################################### //

  /**
   * Create Form
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelFormElement: function _createImportPanelFormElement() {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPimportForm");
    form.className = "map-tool-box"; // TODO ?

    if (form.addEventListener) {
      form.addEventListener("submit", function (e) {
        e.preventDefault();

        self._onImportSubmit();
      });
    } else if (form.attachEvent) {
      form.attachEvent("onsubmit", function (e) {
        e.preventDefault();

        self._onImportSubmit();
      });
    }

    return form;
  },

  /**
   * Create Container for import type choice
   *
   * @param {Array} importTypes - import types to be displayed (and used)
   * @returns {DOMElement} DOM element
   */
  _createImportTypeLineElement: function _createImportTypeLineElement(importTypes) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPimportTypeLine");
    div.className = "GPimportInputLine";
    var label = document.createElement("label");
    label.htmlFor = this._addUID("GPimportType");
    label.className = "GPimportLabel";
    label.innerHTML = "Type de donnée";
    label.title = "Type de donnée";
    div.appendChild(label);
    var select = document.createElement("select");
    select.className = "GPimportSelect"; // gestionnaire d'evenement : on stocke la valeur du type d'import

    if (select.addEventListener) {
      select.addEventListener("change", function (e) {
        if (this.value === "KML" || this.value === "GPX" || this.value === "GeoJSON" || this.value === "MAPBOX") {
          // static import
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPimportVisibleParams";
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPimportHiddenParams";
        } else if (this.value === "WMS" || this.value === "WMTS" || this.value === "WFS") {
          // service import
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPimportVisibleParams";
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPimportHiddenParams";
        }

        context._onImportTypeChange(e);
      });
    } else if (select.attachEvent) {
      select.attachEvent("onchange", function () {
        if (this.value === "KML" || this.value === "GPX" || this.value === "GeoJSON" || this.value === "MAPBOX") {
          // static import
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPimportVisibleParams";
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPimportHiddenParams";
        } else if (this.value === "WMS" || this.value === "WMTS" || this.value === "WFS") {
          // service import
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPimportVisibleParams";
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPimportHiddenParams";
        }

        context._onImportTypeChange();
      });
    }

    select.id = this._addUID("GPimportType"); // on prend soit les valeurs passées par l'utilisateur, soit des valeurs par défaut

    if (!importTypes || !Array.isArray(importTypes)) {
      importTypes = ["KML", "GPX", "GeoJSON", "MAPBOX", "WMS", "WMTS", "WFS"];
    }

    var option;

    for (var i = 0; i < importTypes.length; i++) {
      option = document.createElement("option");
      option.value = importTypes[i];
      option.text = importTypes[i] === "MAPBOX" ? "Tuiles vectorielles" : importTypes[i];
      select.appendChild(option);
    }

    div.appendChild(select);
    return div;
  },

  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportWaitingElement: function _createImportWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportWaitingContainer");
    div.className = "GPimportWaitingContainerHidden";
    var p = document.createElement("p");
    p.className = "GPimportWaiting";
    p.innerHTML = "Recherche en cours...";
    div.appendChild(p);
    return div;
  },
  // ################################################################### //
  // ##### Params for static import (KML / GPX / GeoJSON) ############## //
  // ################################################################### //

  /**
   * Create container for KML/GPX/GeoJSON parameters
   * @param {String} currentType - GeoJSON, GPX or KML value
   * @returns {DOMElement} DOM element
   */
  _createImportStaticParamsContainer: function _createImportStaticParamsContainer(currentType) {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportStaticParams");

    if (currentType === "KML" || currentType === "GPX" || currentType === "GeoJSON" || currentType === "MAPBOX") {
      div.className = "GPimportVisibleParams";
    } else {
      div.className = "GPimportHiddenParams";
    }

    return div;
  },

  /**
   * Create name label for KML/GPX/GeoJSON parameters
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticNameLabel: function _createStaticNameLabel() {
    var div = document.createElement("div");
    div.className = "GPimportInputLine";
    var label = document.createElement("label");
    label.className = "GPimportLabel";
    label.htmlFor = this._addUID("GPimportName");
    label.innerHTML = "Nom";
    label.title = "Nom";
    div.appendChild(label);
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportName");
    input.className = "GPimportInput";
    div.appendChild(input);
    return div;
  },

  /**
   * Create import choice for KML/GPX/GeoJSON parameters (local or url)
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticModeChoiceDiv: function _createStaticModeChoiceDiv() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportChoice");
    return div;
  },

  /**
   * Create local import choice for KML/GPX/GeoJSON parameters
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalChoiceDiv: function _createStaticLocalChoiceDiv() {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPimportChoiceAlt";
    var input = document.createElement("input");
    input.type = "radio";

    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportValueHidden";

        context._onStaticImportTypeChange(e);
      });
    } else if (input.appendChild) {
      input.appendChild("onchange", function () {
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportValueHidden";

        context._onStaticImportTypeChange();
      });
    }

    input.name = "GPimportChoiceMode";
    input.value = "local";
    input.checked = true;
    input.id = this._addUID("GPimportChoiceAltLocal");
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPimportChoiceAltTxt";
    label.htmlFor = this._addUID("GPimportChoiceAltLocal");
    label.innerHTML = "par fichier local";
    label.title = "par fichier local";
    div.appendChild(label);
    return div;
  },

  /**
   * Create url import choice for KML/GPX/GeoJSON parameters
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlChoiceDiv: function _createStaticUrlChoiceDiv() {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPimportChoiceAlt";
    var input = document.createElement("input");
    input.type = "radio";

    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportValueHidden";

        context._onStaticImportTypeChange(e);
      });
    } else if (input.appendChild) {
      input.appendChild("onchange", function () {
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportValueHidden";

        context._onStaticImportTypeChange();
      });
    }

    input.id = this._addUID("GPimportChoiceAltUrl");
    input.name = "GPimportChoiceMode";
    input.value = "url";
    input.checked = false;
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPimportChoiceAltTxt";
    label.htmlFor = this._addUID("GPimportChoiceAltUrl");
    label.innerHTML = "par URL";
    label.title = "par URL";
    div.appendChild(label);
    return div;
  },

  /**
   * Create input div for KML/GPX/GeoJSON parameters local import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalInputDiv: function _createStaticLocalInputDiv() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportValueLocal");
    div.className = "GPimportInputLine";
    return div;
  },

  /**
   * Create input label for KML/GPX/GeoJSON parameters local import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalInputLabel: function _createStaticLocalInputLabel() {
    var label = document.createElement("label");
    label.className = "GPimportLabel";
    label.htmlFor = this._addUID("GPimportFile");
    label.innerHTML = "Fichier local";
    label.title = "Fichier local";
    return label;
  },

  /**
   * Create file input for KML/GPX/GeoJSON parameters local import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalInput: function _createStaticLocalInput() {
    var input = document.createElement("input");
    input.type = "file";
    input.id = this._addUID("GPimportFile");
    input.className = "GPimportInputFile";
    return input;
  },

  /**
   * Create input div for KML/GPX/GeoJSON parameters url import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlInputDiv: function _createStaticUrlInputDiv() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportValueUrl");
    div.className = "GPimportValueHidden";
    return div;
  },

  /**
   * Create input label for KML/GPX/GeoJSON parameters url import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlInputLabel: function _createStaticUrlInputLabel() {
    var label = document.createElement("label");
    label.className = "GPimportLabel";
    label.htmlFor = this._addUID("GPimportUrl");
    label.innerHTML = "URL";
    label.title = "URL";
    return label;
  },

  /**
   * Create url input for KML/GPX/GeoJSON parameters url import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlInput: function _createStaticUrlInput() {
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportUrl");
    input.className = "GPimportInput";
    return input;
  },
  // ################################################################### //
  // ######## Params for service params import (WMS//WMTS/WFS) ######### //
  // ################################################################### //

  /**
   * Create container for WMS/WMTS/WFS parameters
   * @param {String} currentType - WMS, WMTS or WFS value
   * @returns {DOMElement} DOM element
   */
  _createServiceParamsContainer: function _createServiceParamsContainer(currentType) {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportServiceParams");

    if (currentType === "WMS" || currentType === "WMTS" || currentType === "WFS") {
      div.className = "GPimportVisibleParams";
    } else {
      div.className = "GPimportHiddenParams";
    }

    return div;
  },

  /**
   * Create div for WMS/WMTS/WFS url
   *
   * @returns {DOMElement} DOM element
   */
  _createServiceUrlDiv: function _createServiceUrlDiv() {
    var div = document.createElement("div");
    div.className = "GPimportInputLine";
    return div;
  },

  /**
   * Create input label for WMS/WMTS/WFS url
   *
   * @returns {DOMElement} DOM element
   */
  _createServiceUrlInputLabel: function _createServiceUrlInputLabel() {
    var label = document.createElement("label");
    label.className = "GPimportLabel";
    label.htmlFor = this._addUID("GPimportServiceUrl");
    label.innerHTML = "URL du service";
    label.title = "URL du service";
    return label;
  },

  /**
   * Create input for WMS/WMTS/WFS parameters url
   *
   * @returns {DOMElement} DOM element
   */
  _createServiceUrlInput: function _createServiceUrlInput() {
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportServiceUrl");
    input.className = "GPimportInput";
    return input;
  },
  // ################################################################### //
  // ########################### Submit Form ########################### //
  // ################################################################### //

  /**
   * Create Submit Form Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportSubmitFormElement: function _createImportSubmitFormElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPimportSubmit");
    input.className = "GPinputSubmit tool-form-submit";
    input.type = "submit";
    input.value = "Importer";
    return input;
  },
  // ################################################################### //
  // ########################### GetCap Panel ########################## //
  // ################################################################### //

  /**
   * Create GetCap Panel Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportGetCapPanelElement: function _createImportGetCapPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportGetCapPanel");
    div.className = "GPpanel";
    return div;
  },

  /**
   * Create GetCap Panel Header Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportGetCapPanelHeaderElement: function _createImportGetCapPanelHeaderElement() {
    // contexte
    var context = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader"; // panel title

    var panelTitle = document.createElement("div");
    panelTitle.className = "GPpanelTitle";
    panelTitle.innerHTML = "Couches accessibles";
    panelTitle.title = "Couches accessibles";
    container.appendChild(panelTitle); // close picto

    var closeDiv = document.createElement("div");

    if (closeDiv.addEventListener) {
      closeDiv.addEventListener("click", function () {
        document.getElementById(context._addUID("GPimportGetCapPanel")).style.display = "none";
        document.getElementById(context._addUID("GPimportPanel")).style.display = "";

        context._onGetCapPanelClose();
      });
    } else if (closeDiv.attachEvent) {
      closeDiv.attachEvent("click", function () {
        document.getElementById(context._addUID("GPimportGetCapPanel")).style.display = "none";
        document.getElementById(context._addUID("GPimportPanel")).style.display = "";

        context._onGetCapPanelClose();
      });
    }

    closeDiv.className = "GPpanelClose";
    closeDiv.title = "Fermer le panneau";
    closeDiv.id = this._addUID("GPimportGetCapPanelClose");
    container.appendChild(closeDiv);
    return container;
  },

  /**
   * Create GetCap Results List Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportGetCapResultsContainer: function _createImportGetCapResultsContainer() {
    var container = document.createElement("div");
    container.className = "GPimportGetCapRoot";
    container.id = this._addUID("GPimportGetCapResults");
    return container;
  },
  _addImportGetCapResultListRubrique: function _addImportGetCapResultListRubrique(title, container) {
    var ul = document.createElement("ul");
    ul.className = "GPimportGetCapListRubrique";
    ul.title = title;
    container.appendChild(ul);
    return container;
  },
  _addImportGetCapResultRubrique: function _addImportGetCapResultRubrique(title, container) {
    var li = document.createElement("li");
    li.className = "GPimportGetCapRubrique"; // input

    var input = document.createElement("input");
    input.id = "GPimportGetCapRubrique-" + _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].generate();
    input.className = "GPimportGetCapRubrique";
    input.type = "checkbox";
    li.appendChild(input); // label for

    var label = document.createElement("label");
    label.className = "GPimportGetCapRubriqueTitle";
    label.htmlFor = input.id;
    label.innerHTML = title;
    label.title = title;
    li.appendChild(label);
    container.appendChild(li);
    return container;
  },
  _addImportGetCapResultListLayer: function _addImportGetCapResultListLayer(container) {
    var ul = document.createElement("ul");
    ul.className = "GPimportGetCapListLayer";
    container.appendChild(ul);
    return container;
  },
  _addImportGetCapResultLayer: function _addImportGetCapResultLayer(description, id, container) {
    var li = document.createElement("li");
    li.className = "GPimportGetCapProposal";
    li.innerHTML = description.content;
    li.title = description.title;
    li.id = "GPimportGetCapProposal_" + id;
    var context = this;

    if (li.addEventListener) {
      li.addEventListener("click", function (e) {
        context._onGetCapResponseLayerClick(e);
      });
    } else if (li.attachEvent) {
      li.attachEvent("onclick", function () {
        context._onGetCapResponseLayerClick();
      });
    }

    container.appendChild(li);
    return container;
  },
  // ################################################################### //
  // ########################### MapBox Panel ########################## //
  // ################################################################### //

  /**
   * Create MapBox Panel Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportMapBoxPanelElement: function _createImportMapBoxPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportMapBoxPanel");
    div.className = "GPpanel";
    return div;
  },

  /**
   * Create MapBox Panel Header Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportMapBoxPanelHeaderElement: function _createImportMapBoxPanelHeaderElement() {
    // contexte
    var context = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader"; // return picto

    var returnDiv = document.createElement("div");
    returnDiv.id = this._addUID("GPimportMapBoxPanelReturnPicto");
    returnDiv.title = "Masquer le panneau";
    returnDiv.className = "";

    if (returnDiv.addEventListener) {
      returnDiv.addEventListener("click", function (e) {
        // document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        // document.getElementById(context._addUID("GPimportPanel")).style.display = "none";
        context._onMapBoxReturnPictoClick(e);
      });
    } else if (returnDiv.attachEvent) {
      returnDiv.attachEvent("onclick", function (e) {
        // document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        // document.getElementById(context._addUID("GPimportPanel")).style.display = "none";
        context._onMapBoxReturnPictoClick(e);
      });
    }

    container.appendChild(returnDiv); // panel title

    var panelTitle = document.createElement("div");
    panelTitle.className = "GPpanelTitle";
    panelTitle.innerHTML = "Edition des styles";
    panelTitle.title = "Edition des styles";
    container.appendChild(panelTitle); // close picto

    var closeDiv = document.createElement("div");

    if (closeDiv.addEventListener) {
      closeDiv.addEventListener("click", function () {
        document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        document.getElementById(context._addUID("GPimportPanel")).style.display = "";

        context._onMapBoxPanelClose();
      });
    } else if (closeDiv.attachEvent) {
      closeDiv.attachEvent("click", function () {
        document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        document.getElementById(context._addUID("GPimportPanel")).style.display = "";

        context._onMapBoxPanelClose();
      });
    }

    closeDiv.className = "GPpanelClose";
    closeDiv.title = "Fermer le panneau";
    closeDiv.id = this._addUID("GPimportMapBoxPanelClose");
    container.appendChild(closeDiv);
    return container;
  },

  /**
   * Create MapBox Results List Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportMapBoxResultsContainer: function _createImportMapBoxResultsContainer() {
    var container = document.createElement("div");
    container.className = "GPimportMapBoxpRoot";
    container.id = this._addUID("GPimportMapBoxResults");
    return container;
  } // _addImportMapBoxResultListSource : function (id, source, container) {
  //     var ul = document.createElement("ul");
  //     ul.className = "GPimportMapBoxListSource";
  //     ul.title = id;
  //
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxListSourceTitle";
  //     label.innerHTML = "Listes des couches pour la source '" + id + "' :";
  //     label.title = source.attribution || id;
  //     ul.appendChild(label);
  //
  //     container.appendChild(ul);
  //     return container;
  // },
  //
  // _addImportMapBoxResultSource : function (layer, container) {
  //     var li = document.createElement("li");
  //     li.className = "GPimportMapBoxSource";
  //
  //     // input
  //     var input = document.createElement("input");
  //     input.id = "GPimportMapBoxSource-" + SelectorID.generate();
  //     input.className = "GPimportMapBoxSource";
  //     input.type = "checkbox";
  //     li.appendChild(input);
  //
  //     // label for
  //     var name = layer["source-layer"] || layer.id || layer.source;
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxSourceTitle";
  //     label.htmlFor = input.id;
  //     label.innerHTML = name;
  //     label.title = JSON.stringify(layer.metadata) || name;
  //     li.appendChild(label);
  //
  //     container.appendChild(li);
  //     return container;
  // },
  //
  // _addImportMapBoxStyleSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _style = false;
  //     var _obj = {};
  //     var _layer = JSON.parse(JSON.stringify(layer)); // on utilise une copie  !
  //     if (_layer.paint && Object.keys(_layer.paint).length) {
  //         _style = true;
  //         _obj.paint = _layer.paint;
  //     }
  //
  //     // pas de style dans paint, on teste dans layout !
  //     if (_layer.layout && Object.keys(_layer.layout).length) {
  //         _style = true;
  //         _obj.layout = _layer.layout;
  //         // on supprime visibility à l'affichage uniquement
  //         // cf. _addImportMapBoxVisibilitySource !
  //         if (_layer.layout.visibility) {
  //             delete _obj.visibility;
  //         }
  //     }
  //
  //     function syntaxHighlight (json) {
  //         json = json.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  //         return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function (match) {
  //             var cls = "gp-json-number";
  //             if (/^"/.test(match)) {
  //                 if (/:$/.test(match)) {
  //                     cls = "gp-json-key";
  //                 } else {
  //                     cls = "gp-json-string";
  //                 }
  //             } else if (/true|false/.test(match)) {
  //                 cls = "gp-json-boolean";
  //             } else if (/null/.test(match)) {
  //                 cls = "gp-json-null";
  //             }
  //             return "<span class='" + cls + "'>" + match + "</span>";
  //         });
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceStyle";
  //
  //     if (_style) {
  //         var strJson = JSON.stringify(_obj, null, 4);
  //
  //         var label = document.createElement("label");
  //         label.innerHTML = "JSON Styles :";
  //         div.appendChild(label);
  //         var pre = document.createElement("pre");
  //         pre.className = "GPimportMapBoxJsonEdit";
  //         pre.innerHTML = syntaxHighlight(strJson);
  //         if (pre.addEventListener) {
  //             pre.addEventListener("click", function (e) {
  //                 self._onSwitchStyleEditSourceMapBox(e);
  //             });
  //         } else if (pre.appendChild) {
  //             pre.appendChild("onclick", function (e) {
  //                 self._onSwitchStyleEditSourceMapBox(e);
  //             });
  //         }
  //         div.appendChild(pre);
  //     }
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxFilterSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _filter = false;
  //     // FIXME tag filter est obselete !
  //     // on doit utiliser les expressions dans "paint" ou "layout" !
  //     if (layer.filter && layer.filter.length) {
  //         _filter = true;
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceFilter";
  //
  //     if (_filter) {
  //         var label = document.createElement("label");
  //         label.innerHTML = "JSON Filtres :";
  //         div.appendChild(label);
  //         var pre = document.createElement("pre");
  //         pre.className = "GPimportMapBoxJsonEdit";
  //         pre.innerHTML = JSON.stringify(layer.filter, null, 4);
  //         if (pre.addEventListener) {
  //             pre.addEventListener("click", function (e) {
  //                 self._onSwitchFilterEditSourceMapBox(e);
  //             });
  //         } else if (pre.appendChild) {
  //             pre.appendChild("onclick", function (e) {
  //                 self._onSwitchFilterEditSourceMapBox(e);
  //             });
  //         }
  //         div.appendChild(pre);
  //     }
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxScaleSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _scaleMin = layer.minzoom || 0;
  //     var _scaleMax = layer.maxzoom || 21;
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceScale";
  //
  //     var labelMin = document.createElement("label");
  //     labelMin.className = "GPimportMapBoxSourceScaleLabel";
  //     labelMin.innerHTML = "minZoom :";
  //     div.appendChild(labelMin);
  //
  //     var inputMin = document.createElement("input");
  //     inputMin.className = "GPimportMapBoxSourceScaleInput";
  //     inputMin.type = "range";
  //     inputMin.value = _scaleMin;
  //     inputMin.title = _scaleMin;
  //     inputMin.disabled = false;
  //     inputMin.min = 0;
  //     inputMin.max = 21;
  //     if (inputMin.addEventListener) {
  //         inputMin.addEventListener("change", function (e) {
  //             self._onChangeScaleMinSourceMapBox(e, layer);
  //         });
  //     } else if (inputMin.appendChild) {
  //         inputMin.appendChild("onchange", function (e) {
  //             self._onChangeScaleMinSourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(inputMin);
  //
  //     div.appendChild(document.createElement("br"));
  //
  //     var labelMax = document.createElement("label");
  //     labelMax.className = "GPimportMapBoxSourceScaleLabel";
  //     labelMax.innerHTML = "maxZoom :";
  //     div.appendChild(labelMax);
  //
  //     var inputMax = document.createElement("input");
  //     inputMax.className = "GPimportMapBoxSourceScaleInput";
  //     inputMax.type = "range";
  //     inputMax.value = _scaleMax;
  //     inputMax.title = _scaleMax;
  //     inputMax.disabled = false;
  //     inputMax.min = 0;
  //     inputMax.max = 21;
  //     if (inputMax.addEventListener) {
  //         inputMax.addEventListener("change", function (e) {
  //             self._onChangeScaleMaxSourceMapBox(e, layer);
  //         });
  //     } else if (inputMax.appendChild) {
  //         inputMax.appendChild("onchange", function (e) {
  //             self._onChangeScaleMaxSourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(inputMax);
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxVisibilitySource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _visibility = true;
  //     if (layer.layout && layer.layout.visibility && layer.layout.visibility === "none") {
  //         _visibility = false;
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceVisibility";
  //
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxSourceVisibilityLabel";
  //     label.innerHTML = "Visibilité :";
  //     div.appendChild(label);
  //
  //     var input = document.createElement("input");
  //     input.className = "GPimportMapBoxSourceVisibilityInput";
  //     input.type = "checkbox";
  //     input.checked = _visibility;
  //     input.disabled = false;
  //     if (input.addEventListener) {
  //         input.addEventListener("change", function (e) {
  //             self._onChangeVisibilitySourceMapBox(e, layer);
  //         });
  //     } else if (input.appendChild) {
  //         input.appendChild("onchange", function (e) {
  //             self._onChangeVisibilitySourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(input);
  //
  //     container.appendChild(div);
  //     return container;
  // }

};
/* harmony default export */ __webpack_exports__["default"] = (LayerImportDOM);

/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Attribution_GPattributionOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _CSS_Controls_Attribution_GPattributionOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Attribution_GPattributionOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Attribution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(276);
/* harmony import */ var ol_control_Attribution__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Attribution__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Common_Utils_LayerUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(163);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);
// import CSS
 // import OpenLayers


 // import local



var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("geoportalattribution");
/**
 * @classdesc
 * OpenLayers Control to manage Originators for layer resources
 *
 * @constructor
 * @extends {ol.control.Attribution}
 * @alias ol.control.GeoportalAttribution
 * @param {Object} options - ol.control.Attribution options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Attribution.html ol.Control.Attribution})
 * @fires attributions:update
 * @example
 * var attribution = new ol.control.GeoportalAttribution({
 *   collapsed : false
 * });
 * map.addControl(attribution);
 * // listeners for attributions update :
 * attribution.on("attributions:update", function (e) {});
 */

var GeoportalAttribution = function (Attribution) {
  function GeoportalAttribution(options) {
    options = options || {};

    if (!(this instanceof GeoportalAttribution)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // Attributions are not collapsible for ol/source/OSM except if ...


    options.collapsible = true; // call ol.control.Attribution constructor

    Attribution.call(this, options);
  } // Inherits from ol.control.Attribution


  if (Attribution) GeoportalAttribution.__proto__ = Attribution; // Object.setPrototypeOf(GeoportalAttribution, Attribution)

  /*
   * @lends module:GeoportalAttribution
   */

  GeoportalAttribution.prototype = Object.create(Attribution && Attribution.prototype, {});
  /**
   * Constructor (alias)
   */

  GeoportalAttribution.prototype.constructor = GeoportalAttribution;
  /**
   * Overload setMap function, that enables to catch map events, such as movend events.
   *
   * @param {ol.Map} map - Map.
   */

  GeoportalAttribution.prototype.setMap = function (map) {
    var _this = this;

    if (map != null) {
      // Remove default ol.control.Attribution
      var ctrls = map.getControls();
      ctrls.forEach(function (ctrl) {
        if (ctrl instanceof GeoportalAttribution) {
          return;
        }

        if (ctrl) {
          var classList = ctrl.element.classList;

          for (var i = 0; i < classList.length; i++) {
            if (classList[i] === "ol-attribution") {
              ctrls.remove(ctrl);
              break;
            }
          }
        }
      }); // on récupère les attributions des couches déjà ajoutées à la carte.

      this._updateAttributions(map); // At every map movement, layers attributions have to be updated,
      // according to map and originators zoom and extent.


      map.on("moveend", function () {
        _this._updateAttributions(map);
      });
      map.getLayers().on("add", function () {
        _this._updateAttributions(map);
      });
      map.getLayers().on("remove", function () {
        _this._updateAttributions(map);
      });
    }

    Attribution.prototype.setMap.call(this, map);
  };
  /**
   * Update map layers attributions
   *
   * @param {ol.Map} map - Map.
   * @private
   */


  GeoportalAttribution.prototype._updateAttributions = function (map) {
    var _this2 = this;

    // get map parameters
    var mapAttributions = {};
    var view = map.getView(); // extent, then convert to geographical coordinates

    var extent = view.calculateExtent(map.getSize());
    var mapProjection = view.getProjection().getCode();
    var geoExtent = Object(ol_proj__WEBPACK_IMPORTED_MODULE_2__["transformExtent"])(extent, mapProjection, "EPSG:4326"); // transform extent from [minx, miny, maxx, maxy] to [maxy, minx, miny, maxx]

    var standardExtent = [geoExtent[3], geoExtent[0], geoExtent[1], geoExtent[2]]; // zoom

    var zoom = view.getZoom(); // layers

    var layers = map.getLayers().getArray(); // info : This option suppresses warnings about functions inside of loops.

    /* jshint loopfunc: true */
    // loop on layers to get their originators, if there is at least one originator, and if layer is visible.

    for (var i = 0; i < layers.length; i++) {
      // distinguish case of ol.layer.Group (which is made up of layers with their own source)
      // and other ol.layer (with their own source)
      if (layers[i].getSource) {
        // single ol.layer
        this._updateLayerAttributions(layers[i], mapAttributions, standardExtent, mapProjection, zoom);
      } else if (layers[i].getLayers) {
        // ol.layer.Group
        var lyrs = layers[i].getLayers();
        lyrs.forEach(function (lyr) {
          if (lyr.getSource) {
            _this2._updateLayerAttributions(lyr, mapAttributions, standardExtent, mapProjection, zoom);
          } else {
            logger.log("cannot find layer source in layergroup ", layers[i]);
          }
        });
      }
    }
  };
  /**
   * Update a layer attributions
   *
   * @param {ol.layer} layer - layer
   * @param {Object} mapAttributions - object recensing attributions already added, to prevent displaying twice the same producer
   * @param {Array} mapExtent - map current extent
   * @param {String} mapCrs - map current crs
   * @param {Number} mapZoom - map current zoom
   * @private
   */


  GeoportalAttribution.prototype._updateLayerAttributions = function (layer, mapAttributions, mapExtent, mapCrs, mapZoom) {
    if (!layer) {
      logger.trace("layer is null !?");
      return;
    }

    var src = layer.getSource();

    if (!src) {
      logger.trace("source is not yet loaded !");
      return;
    }

    if (!mapAttributions) {
      mapAttributions = {};
    }

    var attributions = [];
    var visibility = layer.getVisible();
    var originators = src._originators; // info : clean previous attributions ONLY for Geoportal Layers (when src._originators is defined)

    if (typeof originators !== "undefined") {
      src.setAttributions(); // clean
    }

    if (originators && visibility) {
      // get layer's attributions array
      var layerAttributions = _Common_Utils_LayerUtils__WEBPACK_IMPORTED_MODULE_3__["default"].getAttributions({
        extent: mapExtent,
        crs: mapCrs,
        zoom: mapZoom,
        visibility: visibility,
        originators: originators
      });

      for (var j = 0; j < layerAttributions.length; j++) {
        var attributionj = layerAttributions[j]; // check that this attribution hasn't been added yet for another layer

        if (!mapAttributions.hasOwnProperty(attributionj)) {
          // add attribution html
          attributions.push(attributionj); // add attribution to mapAttributions, to manage all layers attributions

          mapAttributions[attributionj] = true;
        }
      }

      ; // update source attribution

      if (attributions.length !== 0) {
        src.setAttributions(attributions);
        /**
        * event triggered when the attributions are updated
        *
        * @event attributions:update
        * @type Object
        * @property {Array} attributions - list of attributions
        */

        this.dispatchEvent({
          type: "attributions:update",
          attributions: attributions
        });
      }
    }
  };

  return GeoportalAttribution;
}(ol_control_Attribution__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (GeoportalAttribution); // Expose GeoportalAttribution as ol.control.GeoportalAttribution (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.GeoportalAttribution = GeoportalAttribution;
}

/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = ol.control.Attribution;

/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_ElevationPath_GPelevationPathOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _CSS_Controls_ElevationPath_GPelevationPathOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ElevationPath_GPelevationPathOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(197);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_geom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(48);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(200);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_sphere__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(209);
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_Feature__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(49);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(180);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(172);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(179);
/* harmony import */ var _MeasureToolBox__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(278);
/* harmony import */ var _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(280);
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(169);
/* harmony import */ var _Common_Controls_ElevationPathDOM__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(281);
/* harmony import */ var _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(282);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* globals AmCharts, d3 */
// import CSS
 // import OpenLayers









 // import geoportal library access

 // import local




 // import local with ol dependencies




 // DOM



var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_12__["default"].getLogger("elevationpath");
/**
 * @classdesc
 *
 * Elevation Path Control. Allows users to draw a path on a Openlayers map see the elevation profile computed with geoportal elevation path web service along that path.
 *
 * @constructor
 * @alias ol.control.ElevationPath
 * @extends ol.control.Control
 * @param {Object} options - options for function call.
 * @param {String} [options.apiKey] - API key for services call (isocurve and autocomplete services), mandatory if autoconf service has not been charged in advance
 * @param {Boolean} [options.active = false] - specify if control should be actived at startup. Default is false.
 * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Object} [options.elevationPathOptions = {}] - elevation path service options. See {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~getAltitude Gp.Services.getAltitude()} for available options
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Profil altimétrique"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Mon profil altimétrique"] - Layer description to be displayed in LayerSwitcher
 * @param {Object} [options.stylesOptions] - styles management
 * @param {Object} [options.stylesOptions.marker = {}] - styles management of marker displayed on map when the user follows the elevation path. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object
 * @param {Object} [options.stylesOptions.draw = {}] - styles used when drawing. Specified with following properties.
 * @param {Object} [options.stylesOptions.draw.pointer = {}] - Style for mouse pointer when drawing the line. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
 * @param {Object} [options.stylesOptions.draw.start = {}] - Line Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Stroke-Stroke.html ol.style.Stroke} object.
 * @param {Object} [options.stylesOptions.draw.finish = {}] - Line Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Stroke-Stroke.html ol.style.Stroke} object.
 * @param {Object} [options.displayProfileOptions = {}] - profile options.
 * @param {Boolean} [options.displayProfileOptions.totalDistance = true] - display the total distance of the path
 * @param {Boolean} [options.displayProfileOptions.greaterSlope = true] - display the greater slope into the graph
 * @param {Boolean} [options.displayProfileOptions.meanSlope = true] -  display the mean slope into the graph
 * @param {Boolean} [options.displayProfileOptions.ascendingElevation = true] -  display the ascending elevation into the graph
 * @param {Boolean} [options.displayProfileOptions.descendingElevation = true] -  display the descending elevation into the graph
 * @param {Boolean} [options.displayProfileOptions.currentSlope = true] -  display current slope value on profile mouseover
 * @param {Function} [options.displayProfileOptions.apply] - function to display profile if you want to cutomise it. By default, ([DISPLAY_PROFILE_BY_DEFAULT()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_BY_DEFAULT)) is used. Helper functions to use with D3 ([DISPLAY_PROFILE_LIB_D3()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_LIB_D3)) or AmCharts ([DISPLAY_PROFILE_LIB_AMCHARTS()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_LIB_AMCHARTS)) frameworks are also provided. You may also provide your own function.
 * @param {Object} [options.displayProfileOptions.target] - DOM container to use to display the profile.
 * @fires elevationpath:drawstart
 * @fires elevationpath:drawend
 * @fires elevationpath:compute
 * @example
 *
 * var measure = new ol.control.ElevationPath({
 *    stylesOptions : {
 *     draw : {
 *       finish : new ol.style.Stroke({
 *            color : "rgba(0, 0, 0, 0.5)",
 *            width : 2
 *       })
 *     },
 *    }
 *    displayProfileOptions : {
 *       apply : ol.control.ElevationPath.DISPLAY_PROFILE_RAW,
 *    }
 * });
 *
 * Exemples :
 * - displayProfileOptions.apply : null
 * - displayProfileOptions.apply : function (elevations, container, context) {  // do some stuff... }
 * - displayProfileOptions.apply : ol.control.ElevationPath.DISPLAY_PROFILE_{LIB_AMCHARTS | LIB_D3 | RAW}
 *
 */

var ElevationPath = function (Control) {
  function ElevationPath(options) {
    logger.trace("ElevationPath()");
    /**
     * options
     * @private
     */

    options = options || {};

    if (!(this instanceof ElevationPath)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    /**
     * Nom de la classe (heritage)
     * @private
     */


    this.CLASSNAME = "ElevationPath"; // uuid

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_14__["default"].generate(); // container : HTMLElement

    this._showContainer = null;
    this._pictoContainer = null;
    this._panelContainer = null;
    this._profileContainer = null;
    this._waitingContainer = null;
    this._infoContainer = null; // timer sur la fenetre d'informations des données

    this._timerHdlr = null; // objet de type "ol.style"

    this._drawStyleStart = null;
    this._drawStyleFinish = null;
    this._markerStyle = null; // graph

    this._profile = null; // data elevations

    this._data = {};
    /* objet de type
        "ol.source.Vector",
        "ol.layer.Vector",
        "ol.interaction.Draw"
    */

    this._measureSource = null;
    this._measureVector = null;
    this._measureDraw = null; // objet de type ol.feature, saisie en cours

    this._lastSketch = null;
    this._currentSketch = null; // objet de type ol.feature, marker

    this._marker = null; // gestion des droits sur le service

    this._noRightManagement = false; // initialisation du composant

    this._initialize(options); // gestion des droits


    this._checkRightsManagement(); // creation du DOM container


    this._container = options.element ? options.element : this._initializeContainer(); // heritage

    Control.call(this, {
      element: this._container,
      target: options.target,
      render: options.render
    });
  } // heritage avec ol.control.Control


  if (Control) ElevationPath.__proto__ = Control;
  /**
   * @lends module:ElevationPath
   */

  ElevationPath.prototype = Object.create(Control.prototype, {}); // on récupère les mixins de la classe "ElevationPathDOM"

  _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].assign(ElevationPath.prototype, _Common_Controls_ElevationPathDOM__WEBPACK_IMPORTED_MODULE_19__["default"]);
  /**
   * suppression du marker
   *
   * @param {Object} context - context
   *
   * @private
   */

  ElevationPath.__removeProfileMarker = function (context) {
    var self = context; // suppression de l'ancien marker

    if (self._marker) {
      self._measureSource.removeFeature(self._marker);

      self._marker = null;
    }
  };
  /**
   * suppression du marker
   *
   * @param {Object} context - context
   * @param {Object} d - d
   *
   * @private
   */


  ElevationPath.__createProfileMarker = function (context, d) {
    var self = context; // suppression de l'ancien marker

    if (self._marker) {
      self._measureSource.removeFeature(self._marker);

      self._marker = null;
    }

    var map = self.getMap();
    var proj = map.getView().getProjection();

    var _coordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])([d.lon, d.lat], "EPSG:4326", proj);

    var _coordinateProj = self._measureSource.getFeatures()[0].getGeometry().getClosestPoint(_coordinate);

    var _geometry = new ol_geom__WEBPACK_IMPORTED_MODULE_3__["Point"](_coordinateProj);

    self._marker = new ol_Feature__WEBPACK_IMPORTED_MODULE_7___default.a({
      geometry: _geometry
    });
    logger.trace(_geometry); // style

    self._marker.setStyle(self._markerStyle); // ajout du marker sur la map


    self._measureSource.addFeature(self._marker);
  };
  /**
   * mise à jour du marker
   *
   * @param {Object} context - context
   * @param {Object} d - data
   *
   * @private
   */


  ElevationPath.__updateProfileMarker = function (context, d) {
    var self = context;

    ElevationPath.__removeProfileMarker(self);

    ElevationPath.__createProfileMarker(self, d);
  };
  /**
   * TODO : customisation possible d'une opération sur le profil
   *
   * @param {Object} context - context
   * @param {Object} d - data
   *
   * @private
   */


  ElevationPath.__customRawProfileOperation = function (context, d) {
    logger.log("__customRawProfileOperation");
    var self = context;
    var _pts = d.points;

    var _proj = self.getMap().getView().getProjection();

    for (var i = 0; i < _pts.length; i++) {
      var obj = _pts[i];

      var _coordinate = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])([obj.lon, obj.lat], "EPSG:4326", _proj);

      var _geometry = new ol_geom__WEBPACK_IMPORTED_MODULE_3__["Point"](_coordinate);

      self._marker = new ol_Feature__WEBPACK_IMPORTED_MODULE_7___default.a({
        geometry: _geometry
      });
      logger.trace(_geometry); // TODO style en options ?

      var styles = ElevationPath.DEFAULT_STYLES.RESULTS;

      var _image = new ol_style__WEBPACK_IMPORTED_MODULE_2__["Circle"]({
        radius: styles.imageRadius,
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Stroke"]({
          color: styles.imageStrokeColor,
          width: styles.imageStrokeWidth
        }),
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Fill"]({
          color: styles.imageFillColor
        })
      });

      self._marker.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"]({
        image: _image
      })); // ajout du marker sur la map


      self._measureSource.addFeature(self._marker);
    }
  };
  /**
   * TODO : customisation possible d'une opération sur le profil
   * Ex. Methode appélée dans le DOM : ProfileElevationPathDOM
   *
   * @param {Object} context - context
   * @param {Object} e - event
   * @private
   */


  ElevationPath.__customRawProfileMouseOverEvent = function (context, e) {
    logger.log("__customRawProfileMouseOverEvent", context, e);
  };
  /**
   * display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.
   *
   * @param {Object} data - collection elevations
   * @param {HTMLElement} container - container
   * @param {Object} context - this control object
   */


  ElevationPath.DISPLAY_PROFILE_LIB_AMCHARTS = function (data, container, context) {
    logger.trace("ElevationPath.DISPLAY_PROFILE_LIB_AMCHARTS"); // Calcul du profile

    if (typeof AmCharts === "undefined") {
      logger.log("Lib. AmCharts is not loaded !");
      return;
    }

    var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_20__["default"].displayProfileLibAmCharts(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet

    if (profile) {
      this._profile = profile;
    }
  };
  /**
   * display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.
   *
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   */


  ElevationPath.DISPLAY_PROFILE_LIB_D3 = function (data, container, context) {
    logger.trace("ElevationPath.DISPLAY_PROFILE_LIB_D3"); // Calcul du profile

    if (typeof d3 === "undefined") {
      logger.log("Lib. D3 is not loaded !");
      return;
    }

    var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_20__["default"].displayProfileLibD3(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet

    if (profile) {
      this._profile = profile;
    }
  };
  /**
   * display Profile without graphical rendering (raw service response)
   *
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   */


  ElevationPath.DISPLAY_PROFILE_RAW = function (data, container, context) {
    logger.trace("ElevationPath.DISPLAY_PROFILE_RAW");
    var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_20__["default"].displayProfileRaw(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet

    if (profile) {
      this._profile = profile;
    }
  };
  /**
   * Display Profile function used by default : no additonal framework needed.
   *
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   */


  ElevationPath.DISPLAY_PROFILE_BY_DEFAULT = function (data, container, context) {
    logger.trace("ElevationPath.DISPLAY_PROFILE_BY_DEFAULT");
    var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_20__["default"].displayProfileByDefault(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet

    if (profile) {
      this._profile = profile;
    }
  };
  /**
   * Styles applied by default if stylesOptions property is not set.
   */


  ElevationPath.DEFAULT_STYLES = {
    // styling drawing by default
    // see => Measures.DEFAULTS_STYLES
    // stying marker to the profile by default
    MARKER: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Icon"]({
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAsCAYAAAAATWqyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABTtJREFUeNq8WGtsFUUU/rb3gtdCAykFG9AUDTQUKimhxUewEusrJYoBo4FfEgoqotHERH6oP9TGmJhIrIlWAf9hjAaEiME2pgFfVVpFii8sWqIQLLSx3EJLW7p+Z2Z2b2l7d/b23vZLTmZ2duacb2fmnDk7DlKA67rXs1hJKacsohRQppjXFygnKT9TDlH2O47zFzIFGnco91EOuqnjoBnr2Ow4FhIlLN6m3DykFTh3BGj/Doj/CfSe082xPCDnBmDWTUBeyXDVjZTHOUNHUiZCEs+weI0ySTV0/w0c2wa07gIungn+vOx8YN46oPhpYOp1Xms/5TmSeSMUERKImFnYqBoGuPRNL5LEW8BgX2rrmjWZZLYApS8BUW8r4T0zO5eTEjFr+S6lSjV0HgPqVwNdf6S30abNB+7aDeQWey3bKZtIxvU5DxvyrE/izJfAvuXpkxCIDtElOjWqjK2RM8LZWMbiG0oEnUc5kB7a14WMYvI04H56du5ieZKluZWz8r0/IyQh5TuKRH8cqFuTeRIC0Sm6xYbYok1j21+ahyhLVO3wC8D5VowbRLfY0FhibOulIavDLEoRZyD8sJDeMWBXKG5ZsIobsdDsg+OMq3u1m1u9KQo8zP45EqjRxOUpk6i50IRl4FuGjpZtwUoiMYa314GFj/EzIsN8n8v+C1e4kfvwcm+wnhsZY27xQ8oiWZpKrWRQB6tAElfxpKnjsCdGklDzG9HvpI/0DYLYEpsalVnmAAM6fgR62oMHl70C5N9mn3rpI32DILbEpkZ5ljlFgbPNFtebzij5VPhNKX1lTBASNtXSzPZ3cxCuvVOH7FTCu4yxeZDGbCES0z5+PniQ3uGpwTYmYTOWCPGTpgYP6u9OnYhtzBCbQkSH0NiM4EEdP6VOxDYmYbNLiJxQ1elFwYPaG3XQCn3QHddjgpCweUKI6K2bvzw4YROf//rJob6fZl/H2FRoFiINfqo3qyzYwD8MVIeYLw32J+8j76SP9A2C2BKbGg1CZL+EF/W4YKP9a3/fCeyhkrY9DOOXEu1SlzZ5J31sSNjqURm/OfQkY9qgvkYOvXhbuH0g505Oga7HT9rPF9+t5+pDL0ulwzt46FV5ROax+JUSRRtP0LoHMK64+xNg7iqVEVOKSKRVxRGpsKhRnaRD4SPjR0J0axKCGmP7ilQxm4X8d8xXmfvHJZlPkCR3WfODl9FLMlxCIhevSJ5Nwzo1XdKxYpe3hpmB6BKdmoS43VqPxIgsni+aWOg8biZ3f+nLmSMiuvKWek/P01az7QdLyNVT7lC/l59WAKcb0iMxhzpW1nvmvpDtSiKD1l9OkpnDgv8UyMWFU9wvTP8vdY6NhJwnD1JVtso2OiiLSeL0iJUbNfg6zikVVwRTyOn2HWOfjfLtHgnBhtFIJCViyNDZUatdmnGlaFPqJIoe1WM1aqlz71ivJbLNobgAA9zgu7nZ/vstHAk5WVdzaPRqmGC5lER6kjpV4OWJdq+1kkshSk4VH9izcy/bV66qSPQZV+0J9G7rTY6+XNmqHmYwyJVV24kse1X31dhKHdasygkzy+a64oC4nWr47F4e858nSbLv4V/KAe9JKpVDrx/SImLIXMOiRUKdujESl+49O8xVZxpXzVc/C/I/RxL/hgq8YYkYhev9q6kVO4d9B+sr3vdICNaHJTHWW8Ya/87wqy2uWwstUk/gTYw3aCRGOarMDfS67kfFWqSuIe9imAjQEC272nJHixYNaSvGRIIGN49ywbsZEw1zI11N6TZSHeaGORn+F2AAJtRIMx4t+hUAAAAASUVORK5CYII=",
      anchor: [0.5, 1],
      snapToPixel: true
    }),
    // styling service results points by default
    RESULTS: {
      // INFO orienté maintenance !
      imageRadius: 5,
      imageFillColor: "rgba(128, 128, 128, 0.2)",
      imageStrokeColor: "rgba(0, 0, 0, 0.7)",
      imageStrokeWidth: 2
    } // FIXME ???
    // PROFILE : {
    //     type : "serial",
    //     pathToImages : "http://cdn.amcharts.com/lib/3/images/",
    //     categoryField : "dist",
    //     autoMarginOffset : 0,
    //     marginRight : 10,
    //     marginTop : 10,
    //     startDuration : 0,
    //     color : "#5E5E5E",
    //     fontSize : 10,
    //     theme : "light",
    //     thousandsSeparator : "",
    //     categoryAxis : {
    //         color : "#5E5E5E",
    //         gridPosition : "start",
    //         minHorizontalGap : 40,
    //         tickPosition : "start",
    //         title : "Distance (km)",
    //         titleColor : "#5E5E5E",
    //         startOnAxis : true
    //     },
    //     chartCursor : {
    //         animationDuration : 0,
    //         bulletsEnabled : true,
    //         bulletSize : 10,
    //         categoryBalloonEnabled : false,
    //         cursorColor : "#F90",
    //         graphBulletAlpha : 1,
    //         graphBulletSize : 1,
    //         zoomable : false
    //     },
    //     trendLines : [],
    //     graphs : [
    //         {
    //             balloonColor : "#CCCCCC",
    //             balloonText : "<span class='altiPathValue'>[[title]] : [[value]]m</span><br/><span class='altiPathCoords'>(lat: [[lat]] / lon:[[lon]])</span>",
    //             bullet : "round",
    //             bulletAlpha : 0,
    //             bulletBorderColor : "#FFF",
    //             bulletBorderThickness : 2,currentSlope
    //             bulletColor : "#F90",
    //             bulletSize : 6,
    //             hidden : false,
    //             id : "AmGraph-1",
    //             fillAlphas : 0.4,
    //             fillColors : "#C77A04",
    //             lineAlpha : 1,
    //             lineColor : "#C77A04",
    //             lineThickness : 1,
    //             title : "Altitude",
    //             valueField : "z"
    //         }
    //     ],
    //     guides : [],
    //     valueAxes : [
    //         {
    //             id : "ValueAxis-1",
    //             minVerticalGap : 20,
    //             title : "Altitude (m)"
    //         }
    //     ],
    //     allLabels : [],
    //     balloon : {
    //         borderColor : "#CCCCCC",
    //         borderThickness : 1,
    //         fillColor : "#FFFFFF",
    //         showBullet : true
    //     },
    //     titles : []
    // }

  };
  /**
   * Constructor (alias)
   * @private
   */

  ElevationPath.prototype.constructor = ElevationPath; // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Attach control to map. Overloaded ol.control.Control.setMap() method.
   *
   * @param {ol.Map} map - Map.
   */

  ElevationPath.prototype.setMap = function (map) {
    logger.trace("ElevationPath::setMap");

    if (map) {
      // activation des interactions de dessin selon la valeur de
      // l'option active
      if (this.options.active) {
        // on n'affiche pas la fenetre de profile s'il n'existe pas...
        if (this._profile === null) {
          this._panelContainer.style.display = "none"; // this._panelContainer.style.visibility = "hidden";
        }

        this._initMeasureInteraction(map);

        this._addMeasureInteraction(map);
      } // ajout du composant dans une toolbox


      if (!this.options.target) {
        _MeasureToolBox__WEBPACK_IMPORTED_MODULE_16__["default"].add(map, this);
      }
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Returns true if widget is actived (drawing),
   * false otherwise
   *
   * @returns {Boolean} active - true or false
   */


  ElevationPath.prototype.getActive = function () {
    logger.trace("ElevationPath::getActive");
    return this.options.active;
  };
  /**
   * Actived widget drawing or not
   *
   * @param {Boolean} active - true / false
   */


  ElevationPath.prototype.setActive = function (active) {
    logger.trace("ElevationPath::setActive");
    this.options.active = active;
  };
  /**
   * Get elevation data
   *
   * @returns {Object} data - elevations
   * @example
   * {
   *        greaterSlope // pente max
   *        meanSlope  // pente moyenne
   *        distancePlus // distance cumulée positive
   *        distanceMinus // distance cumulée négative
   *        ascendingElevation // dénivelé cumulée positive
   *        descendingElevation // dénivelé cumulée négative
   *        altMin // altitude min
   *        altMax // altitude max
   *        distance // distance totale
   *        unit : // unité des mesures de distance
   *        points : // elevations
   *   }
   */


  ElevationPath.prototype.getData = function () {
    return this._data;
  };
  /**
   * clean
   */


  ElevationPath.prototype.clean = function () {
    logger.trace("ElevationPath::clean");
    var map = this.getMap(); // fenetre du profil

    this._panelContainer.style.display = "none"; // this._panelContainer.style.visibility = "hidden";
    // picto

    this._showContainer.checked = false;

    this._removeProfile();

    this._removeMeasure();

    this._removeMeasureInteraction(map);
  };
  /**
   * Remove measure
   * @private
   */


  ElevationPath.prototype._removeMeasure = function () {
    // sketch
    this._lastSketch = null;
    this._currentSketch = null;

    if (this._measureSource) {
      // marker
      if (this._marker) {
        this._measureSource.removeFeature(this._marker);

        this._marker = null;
      } // all other features


      var _features = this._measureSource.getFeatures();

      for (var i = 0; i < _features.length; i++) {
        this._measureSource.removeFeature(_features[i]);
      }
    }
  };
  /**
   * Remove profile
   * @private
   */


  ElevationPath.prototype._removeProfile = function () {
    // graph
    this._profile = null; // on vide le container

    if (this._profileContainer) {
      while (this._profileContainer.firstChild) {
        this._profileContainer.removeChild(this._profileContainer.firstChild);
      }
    }
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */


  ElevationPath.prototype._initialize = function (options) {
    logger.trace("ElevationPath::_initialize : ", options); // liste des options

    this.options = {
      target: null,
      render: null,
      active: false,
      apiKey: null,
      elevationOptions: {},
      layerDescription: {
        title: "Profil altimétrique",
        description: "Mon profil altimétrique"
      },
      displayProfileOptions: {
        totalDistance: true,
        greaterSlope: true,
        meanSlope: true,
        ascendingElevation: true,
        descendingElevation: true,
        currentSlope: true,
        apply: null,
        target: null
      },
      stylesOptions: {
        profile: null,
        draw: null,
        marker: null
      }
    }; // merge with user options

    _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(this.options, options);
    this.options.target = options.target || null; // this.options.render = options.render || null;
    // cle API sur le service

    this.options.apiKey = options.apiKey; // gestion de l'affichage du profil

    var _profile = options.displayProfileOptions || {}; // gestion de la fonction du profil


    var displayFunction = _profile.apply;
    this.options.displayProfileOptions.apply = typeof displayFunction === "function" ? displayFunction : ElevationPath.DISPLAY_PROFILE_BY_DEFAULT; // gestion du container du profil

    var displayContainer = _profile.target;
    this.options.displayProfileOptions.target = typeof displayContainer !== "undefined" ? displayContainer : null; // gestion des styles

    var _styles = options.stylesOptions || {}; // FIXME ???
    // gestion du style du profil
    // var profileStyle = _styles.profile;
    // this.options.stylesOptions.profile = ( typeof profileStyle === "undefined" || Object.keys(profileStyle).length === 0 ) ?
    //     ElevationPath.DEFAULT_STYLES.PROFILE : profileStyle;
    // this._createStylingProfile();
    // gestion des styles du tracé


    this.options.stylesOptions.draw = _styles.draw || {};

    this._createStylingDraw(); // gestion des styles du marker


    this.options.stylesOptions.marker = _styles.marker || {};

    this._createStylingMarker();
  };
  /**
   * initialize component container (DOM)
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  ElevationPath.prototype._initializeContainer = function () {
    logger.trace("ElevationPath::_initializeContainer : ", this._uid); // create main container

    var container = this._createMainContainerElement();

    var inputShow = this._showContainer = this._createShowElevationPathElement();

    container.appendChild(inputShow);

    var picto = this._pictoContainer = this._createShowElevationPathPictoElement();

    container.appendChild(picto); // mode "active"

    if (this.options.active) {
      this._showContainer.checked = true;
    } // panneau


    var panel = this._panelContainer = this._createElevationPathPanelElement(); // header


    var header = this._createElevationPathPanelHeaderElement();

    panel.appendChild(header); // profile

    var profile = this._profileContainer = this._createElevationPathPanelProfilElement();

    panel.appendChild(profile); // waiting

    var waiting = this._waitingContainer = this._createElevationPathWaitingElement();

    panel.appendChild(waiting); // info

    var info = this._infoContainer = this._createElevationPathInformationsElement();

    panel.appendChild(info);

    if (this.options.displayProfileOptions.target === null) {
      container.appendChild(panel);
    }

    return container;
  };
  /**
   * this method is called by constructor (into method _initialize())
   * and check the rights to resources
   *
   * @private
   */


  ElevationPath.prototype._checkRightsManagement = function () {
    logger.trace("ElevationPath::_checkRightsManagement");
    var rightManagement = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_13__["default"].check({
      key: this.options.apiKey,
      resources: ["SERVICE_CALCUL_ALTIMETRIQUE_RSC"],
      services: ["Elevation"]
    });

    if (!rightManagement) {
      this._noRightManagement = true;
      return;
    } // on recupère les informations utiles
    // sur ce controle, on ne s'occupe pas de la ressource car elle est unique...
    // Ex. la clef API issue de l'autoconfiguration si elle n'a pas
    // été renseignée.


    if (!this.options.apiKey) {
      this.options.apiKey = rightManagement.key;
    }
  }; // ################################################################### //
  // ###################### init styles ################################ //
  // ################################################################### //

  /**
   * create style marker object : "ol.style"
   *
   * @private
   */


  ElevationPath.prototype._createStylingMarker = function () {
    logger.trace("ElevationPath::_createStylingMarker ");
    var marker = ElevationPath.DEFAULT_STYLES.MARKER;
    logger.trace("style marker", marker); // si marker n'est pas un objet ol.style.Image, on applique le
    // style par défaut.

    if (this.options.stylesOptions.marker instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__["Image"]) {
      marker = this.options.stylesOptions.marker;
    }

    this._markerStyle = new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"]({
      image: marker
    });
  };
  /**
   * create style draw object : "ol.style"
   *
   * @private
   */


  ElevationPath.prototype._createStylingDraw = function () {
    logger.trace("ElevationPath::_createStylingDraw"); // on interprete les params pour y creer un objet ol.Style

    var styles = this.options.stylesOptions.draw; // style de depart

    logger.trace("style start", styles.start); // Creation à partir des styles par défaut

    var startStyleOpts = {
      image: _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__["default"].DEFAULT_POINTER_STYLE,
      stroke: _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__["default"].DEFAULT_DRAW_START_STYLE.getStroke()
    }; // ecrasement à partir des propriétés renseignées

    if (styles.hasOwnProperty("pointer") && styles.pointer instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__["Image"]) {
      startStyleOpts.image = styles.pointer;
    }

    if (styles.hasOwnProperty("start") && styles.start instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__["Stroke"]) {
      startStyleOpts.stroke = styles.start;
    }

    this._drawStyleStart = new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"](startStyleOpts); // style de fin

    logger.trace("style finish", styles.finish);
    var finishStyleOpts = {
      stroke: _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__["default"].DEFAULT_DRAW_FINISH_STYLE.getStroke()
    }; // ecrasement à partir des propriétés renseignées

    if (styles.hasOwnProperty("finish") && styles.finish instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__["Stroke"]) {
      finishStyleOpts.stroke = styles.finish;
    }

    this._drawStyleFinish = new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"](finishStyleOpts);
  };
  /**
   * create style graph
   * FIXME : à revoir car ne sert que pour AmCharts !?
   *
   * @private
   */


  ElevationPath.prototype._createStylingProfile = function () {
    logger.trace("ElevationPath::_createStylingProfile");
    var userStyles = this.options.stylesOptions.profile;
    logger.trace("style profile", userStyles);
    var defaultStyle = ElevationPath.DEFAULT_STYLES.PROFILE;
    Object.keys(defaultStyle).forEach(function (key) {
      if (!userStyles.hasOwnProperty(key)) {
        // si le style user n'existe pas, on ajoute celui par defaut
        userStyles[key] = defaultStyle[key];
      } else {
        var _defaultStyle = defaultStyle[key];

        if (_typeof(_defaultStyle) === "object") {
          // on merge avec un objet,
          // les styles user ecrasent ceux par defaut...
          _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(_defaultStyle, userStyles[key]);
          userStyles[key] = _defaultStyle;
        }
      }
    });
  }; // ################################################################### //
  // ################### Map interactions management ################### //
  // ################################################################### //

  /**
   * this method is called by this.onShowElevationPathClick,
   * and initialize a vector layer, if widget is active.
   *
   * @param {ol.Map} map - Map
   * @private
   */


  ElevationPath.prototype._initMeasureInteraction = function (map) {
    var _this = this;

    logger.trace("ElevationPath::_initMeasureInteraction()"); // var map = this.getMap();

    if (!map) {
      return;
    }

    this._measureSource = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_9___default.a();
    this._measureVector = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8___default.a({
      source: this._measureSource,
      style: this._drawStyleFinish
    }); // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant.

    this._measureVector.gpResultLayerId = "measure";
    map.addLayer(this._measureVector); // Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche

    map.getControls().forEach(function (control) {
      if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_18__["default"]) {
        // un layer switcher est présent dans la carte
        var layerId = _this._measureVector.gpLayerId; // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)

        if (control._layers[layerId].title === layerId) {
          control.addLayer(_this._measureVector, {
            title: _this.options.layerDescription.title,
            description: _this.options.layerDescription.description
          });
        }
      }
    });
  };
  /**
   * this method is called by this.onShowElevationPathClick,
   * and add draw interaction to map, if widget is not active.
   *
   * @param {ol.Map} map - Map
   * @private
   */


  ElevationPath.prototype._addMeasureInteraction = function (map) {
    var _this2 = this;

    logger.trace("ElevationPath::_addMeasureInteraction()"); // var map = this.getMap();

    if (!map) {
      return;
    } // Creates and adds the interaction


    this._measureDraw = new ol_interaction__WEBPACK_IMPORTED_MODULE_4__["Draw"]({
      source: this._measureSource,
      type: "LineString",
      style: this._drawStyleStart,
      stopClick: true
    });

    this._measureDraw.setProperties({
      name: "ElevationPath",
      source: this
    });

    map.addInteraction(this._measureDraw); // Event start

    this._measureDraw.on("drawstart", function (evt) {
      logger.trace("drawstart", evt); // delete marker current

      if (_this2._marker !== null) {
        _this2._measureSource.removeFeature(_this2._marker);

        _this2._marker = null;
      } // set new feature and remove last feature


      if (_this2._lastSketch !== null) {
        _this2._measureSource.removeFeature(_this2._lastSketch);

        _this2._lastSketch = null;
      }

      _this2._currentSketch = evt.feature; // and, all features

      var _features = _this2._measureSource.getFeatures();

      for (var i = 0; i < _features.length; i++) {
        _this2._measureSource.removeFeature(_features[i]);
      }
      /**
      * event triggered at the start of drawing input
      * @event elevationpath:drawstart
      */


      _this2.dispatchEvent("elevationpath:drawstart");
    }); // Event end


    this._measureDraw.on("drawend", function (evt) {
      logger.trace("drawend", evt);
      /**
      * event triggered at the end of drawing input
      * @event elevationpath:drawend
      */

      _this2.dispatchEvent("elevationpath:drawend"); // set feature


      _this2._lastSketch = _this2._currentSketch; // Si il n'y a pas de surcharge utilisateur de la fonction de recuperation des
      // resultats, on realise l'affichage du panneau

      if (typeof _this2.options.elevationOptions.onSuccess === "undefined" && _this2.options.displayProfileOptions.target === null) {
        _this2._panelContainer.style.display = "block"; // self._panelContainer.style.visibility = "visible";
      } // set an alti request and display results


      _this2._measureDraw.setActive(false);

      _this2._requestService();
    });
  };
  /**
   * this method is called by this.onShowElevationPathClick,
   * and removes draw interaction from map (if exists)
   * And removes layer too...
   *
   * @param {ol.Map} map - Map
   * @private
   */


  ElevationPath.prototype._removeMeasureInteraction = function (map) {
    logger.trace("ElevationPath::_removeMeasureInteraction()"); // var map = this.getMap();

    if (!map) {
      return;
    }

    if (this._measureVector) {
      map.removeLayer(this._measureVector);
      this._measureVector = null;
    }

    if (this._measureDraw) {
      map.removeInteraction(this._measureDraw);
      this._measureDraw = null;
    }
  }; // ################################################################### //
  // ############################ Alti request ######################### //
  // ################################################################### //

  /**
   * transforme geometry feature to position coordinate (service)
   *
   * @returns {Object[]} geometry
   *
   * @private
   */


  ElevationPath.prototype._getGeometry = function () {
    // INFO
    // on transmet toujours des coordonnées au service en EPSG:4326
    if (this._currentSketch === null) {
      logger.warn("Current Feature undefined !?");
      return;
    }

    var geometry = [];
    var map = this.getMap();
    var projSrc = map.getView().getProjection();
    var projDest = "EPSG:4326";

    var coordinates = this._currentSketch.getGeometry().getCoordinates();

    for (var i = 0; i < coordinates.length; i++) {
      var xy = coordinates[i];
      var ll = xy; // on transmet au service des coordonnées en EPSG:4326

      if (projSrc !== projDest) {
        ll = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])(xy, projSrc, projDest);
      }

      geometry.push({
        lon: Math.round(ll[0] * 1e8) / 1e8,
        lat: Math.round(ll[1] * 1e8) / 1e8
      });
    }

    return geometry;
  };
  /**
   * get geometry feature length
   *
   * @returns {Integer} length
   *
   * @private
   */


  ElevationPath.prototype._getLength = function () {
    if (this._currentSketch === null) {
      logger.warn("Current Feature undefined !?");
      return;
    }

    var length = 0;
    var map = this.getMap();
    var projSrc = map.getView().getProjection();
    var projDest = "EPSG:4326";

    var coordinates = this._currentSketch.getGeometry().getCoordinates();

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var c1 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])(coordinates[i], projSrc, projDest);
      var c2 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])(coordinates[i + 1], projSrc, projDest);
      c1[0] = Math.round(c1[0] * 1e8) / 1e8;
      c1[1] = Math.round(c1[1] * 1e8) / 1e8;
      c2[0] = Math.round(c2[0] * 1e8) / 1e8;
      c2[1] = Math.round(c2[1] * 1e8) / 1e8;
      length += Object(ol_sphere__WEBPACK_IMPORTED_MODULE_6__["getDistance"])(c1, c2);
    }

    return length;
  };
  /**
   * get geometry feature point coords in EPSG:4326 [lon, lat]
   *
   * @returns {Array} point coords in EPSG:4326 [lon, lat]
   *
   * @private
   */


  ElevationPath.prototype._getSketchCoords = function () {
    if (this._currentSketch === null) {
      logger.warn("Current Feature undefined !?");
      return;
    }

    var map = this.getMap();
    var projSrc = map.getView().getProjection();
    var projDest = "EPSG:4326";
    var pointCoords = [];

    var coordinates = this._currentSketch.getGeometry().getCoordinates();

    for (var i = 0; i < coordinates.length; i++) {
      var c1 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_5__["transform"])(coordinates[i], projSrc, projDest);
      c1[0] = Math.round(c1[0] * 1e8) / 1e8;
      c1[1] = Math.round(c1[1] * 1e8) / 1e8;
      pointCoords.push(c1);
    }

    return pointCoords;
  };
  /**
   * this method is called at the end of the path,
   * it generates and sends alti request, then displays results
   *
   * @private
   */


  ElevationPath.prototype._requestService = function () {
    logger.trace("ElevationPath::_requestService"); // les coordonnées sont obligatoires

    var geometry = this._getGeometry();

    logger.trace("geometry", geometry);

    if (!geometry) {
      logger.warn("missing geometry !?");
      return;
    } // oups, aucun droits !


    if (this._noRightManagement) {
      logger.warn("no rights to this service !");
      return;
    } // on construit les options pour la requête


    var options = {}; // on surcharge avec les options de l'utilisateur

    _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, this.options.elevationOptions); // au cas où ...

    _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
      apiKey: options.apiKey || this.options.apiKey
    }); // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
    // true par défaut (https)

    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }

    _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
      ssl: options.ssl
    }); // les callbacks

    var self = this; // gestion des callback

    var bOnFailure = !!(this.options.elevationOptions.onFailure !== null && typeof this.options.elevationOptions.onFailure === "function"); // cast variable to boolean

    var bOnSuccess = !!(this.options.elevationOptions.onSuccess !== null && typeof this.options.elevationOptions.onSuccess === "function"); // callback _requestServiceOnSuccess

    var _requestServiceOnSuccess = function _requestServiceOnSuccess(result) {
      logger.trace(result);

      if (result) {
        self._panelContainer.style.display = "block"; // self._panelContainer.style.visibility = "visible";

        self._displayProfile(result.elevations);

        self._waitingContainer.className = "GPelevationPathCalcWaitingContainerHidden";
        self._waiting = false;

        self._measureDraw.setActive(true);
      }

      if (bOnSuccess) {
        self.options.elevationOptions.onSuccess.call(self, self.getData());
      }
    }; // callback _requestServiceOnFailure


    var _requestServiceOnFailure = function _requestServiceOnFailure(error) {
      // on ferme le panneau en cas d'erreur !
      self._panelContainer.style.display = "none"; // self._panelContainer.style.visibility = "hidden";

      logger.error(error.message);
      self._waitingContainer.className = "GPelevationPathCalcWaitingContainerHidden";
      self._waiting = false;

      self._measureDraw.setActive(true);

      if (bOnFailure) {
        self.options.elevationOptions.onFailure.call(self, error);
      }
    };

    _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
      onSuccess: _requestServiceOnSuccess,
      onFailure: _requestServiceOnFailure
    }); // le sampling est soit defini par l'utilisateur (opts),
    // ou soit calculé dynamiquement...

    var sampling = options.sampling;

    if (!sampling) {
      // computing sampling
      var _sampling;

      var _length = this._getLength();

      logger.trace("length", _length);
      var p = Math.max(50, Math.floor(_length) / 5); // en mètre sur un pas moyen de 5m !

      if (p > 200) {
        _sampling = 200;
      } else {
        _sampling = Math.floor(p);
      }

      var pointNumber = this._getSketchCoords().length;

      if (pointNumber > 100) {
        _sampling = 0;
      }
    }

    if (_sampling > 0) {
      _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
        sampling: _sampling
      });
    } // et enfin, la geometrie


    _Common_Utils__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
      positions: geometry
    });
    logger.trace("options du service", options); // mise en place de la patience

    this._waitingContainer.className = "GPelevationPathCalcWaitingContainerVisible"; // Request altitude service

    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_10__["default"].Services.getAltitude(options);
  }; // ################################################################### //
  // ########################## Profil display ######################### //
  // ################################################################### //

  /**
   * this method computes results elevations (Z and distance)
   *
   * @param {Array} elevations - array of elevation
   * @return {Array} elevations
   * @private
   */


  ElevationPath.prototype._computeElevationMeasure = function (elevations) {
    logger.trace("ElevationPath::_computeElevationMeasure", elevations);
    var _data = elevations;
    var _unit = "m";

    var _sketchPoints = this._getSketchCoords(); // section actuelle du sketch sur laquelle on est


    var _currentSection = 0; // longueur cumulée des sections précédentes

    var _previousSectionsLength = 0;
    var _nextSectionBegining = _sketchPoints[1]; // Calcul de la distance au départ pour chaque point + arrondi des lat/lon

    _data[0].dist = 0;
    _data[0].slope = 0;
    _data[0].lat = Math.round(_data[0].lat * 10000) / 10000;
    _data[0].lon = Math.round(_data[0].lon * 10000) / 10000;
    var _distanceMinus = 0;
    var _distancePlus = 0;
    var _ascendingElevation = 0;
    var _descendingElevation = 0;
    var _distance = 0;
    var _slopes = 0;
    var distances = [];

    for (var i = 1; i < _data.length; i++) {
      var a = [_data[i].lon, _data[i].lat];

      var distanceToStart = _previousSectionsLength + Object(ol_sphere__WEBPACK_IMPORTED_MODULE_6__["getDistance"])(a, _sketchPoints[_currentSection]);

      var dist = distanceToStart - _distance; // Changement de section

      if (a[0] === _nextSectionBegining[0] && a[1] === _nextSectionBegining[1]) {
        _currentSection++;
        _previousSectionsLength = distanceToStart; // Pas de next section si on est sur le dernier point

        if (i !== _data.length - 1) {
          _nextSectionBegining = _sketchPoints[_currentSection + 1];
        }
      }

      var za = _data[i].z;
      var zb = _data[i - 1].z;

      if (za < 0) {
        za = 0;
      }

      if (zb < 0) {
        zb = 0;
      }

      var slope = za - zb;

      if (slope < 0) {
        _distanceMinus += dist;
        _descendingElevation += slope;
      } else if (slope > 0) {
        _distancePlus += dist;
        _ascendingElevation += slope;
      }

      _distance = distanceToStart;
      _data[i].dist = distanceToStart;
      distances.push(distanceToStart);
      _slopes += slope ? Math.abs(Math.round(slope / dist * 100)) : 0;
      _data[i].slope = slope ? Math.abs(Math.round(slope / dist * 100)) : 0; // EVOL ?
      // cf. gradiant
      // http://www.color-hex.com/color/00b798

      var value = _data[i].slope;

      if (value > 15 && value < 30) {
        _data[i].color = "#005b4c";
      } else if (value > 30 && value < 45) {
        _data[i].color = "#00362d";
      } else if (value > 45) {
        _data[i].color = "#00120f";
      } else {
        _data[i].color = "#00B798";
      }

      _data[i].lat = Math.round(_data[i].lat * 10000) / 10000;
      _data[i].lon = Math.round(_data[i].lon * 10000) / 10000;
    } // check distance totale


    logger.trace("List Distances", distances); // Correction des altitudes aberrantes + arrondi des calculs de distance + ...

    var _altMin = _data[0].z;
    var _altMax = _data[0].z;
    var _greaterSlope = _data[0].slope;

    for (var ji = 0; ji < _data.length; ji++) {
      var d = _data[ji];

      if (d.z < -100) {
        d.z = 0;
      }

      if (d.z > _altMax) {
        _altMax = d.z;
      }

      if (d.z < _altMin) {
        _altMin = d.z;
      }

      if (d.slope > _greaterSlope) {
        _greaterSlope = d.slope;
      }
    }

    return {
      greaterSlope: _greaterSlope,
      // pente max
      meanSlope: Math.round(_slopes / _data.length),
      // pente moyenne
      distancePlus: _distancePlus,
      // distance cumulée positive
      distanceMinus: _distanceMinus,
      // distance cumulée négative
      ascendingElevation: _ascendingElevation,
      // dénivelé cumulée positive
      descendingElevation: _descendingElevation,
      // dénivelé cumulée négative
      altMin: _altMin.toLocaleString(),
      // altitude min TODO: inutile ?
      altMax: _altMax.toLocaleString(),
      // altitude max TODO: inutile ?
      distance: this._getLength(),
      // distance totale
      unit: _unit,
      // unité des mesures de distance
      points: _data
    };
  };
  /**
   * this method is called after service request (in case of success)
   * and display results
   *
   * @param {Array} elevations - array of elevation
   * @private
   */


  ElevationPath.prototype._displayProfile = function (elevations) {
    logger.trace("ElevationPath::_displayProfile", elevations); // data

    if (this._data) {
      this._data = {};
    } // sauvegarde des données


    var data = this._data = this._computeElevationMeasure(elevations);

    this._updateInfoContainer(); // container


    var container = this.options.displayProfileOptions.target;

    if (container) {
      container.appendChild(this._panelContainer);
    }

    container = this._profileContainer; // TODO contexte ?

    var context = this; // fonction

    var displayFunction = this.options.displayProfileOptions.apply; // execution...

    displayFunction.call(this, data, container, context);
    var opts = this.options.displayProfileOptions;
    var element = document.getElementById("GPelevationPathPanelInfo-" + this._uid);

    if (element) {
      if (opts.totalDistance || opts.greaterSlope || opts.meanSlope || opts.ascendingElevation || opts.descendingElevation) {
        // on affiche les informations
        element.style.display = "block";
      }
    }
    /**
     * event triggered when the compute is finished
     *
     * @event elevationpath:compute
     * @typedef {Object}
     * @property {Object} type - event
     * @property {Object} target - instance ElevationPath
     * @example
     * ElevationPath.on("elevationpath:compute", function (e) {
     *   console.log(e.target.getData());
     * })
     */


    this.dispatchEvent({
      type: "elevationpath:compute"
    });
  };
  /**
   * update info container
   *
   * @private
   */


  ElevationPath.prototype._updateInfoContainer = function () {
    logger.trace("ElevationPath::_updateInfoContainer"); // options d'affichage

    var totalDistance = this.options.displayProfileOptions.totalDistance;
    var meanSlope = this.options.displayProfileOptions.meanSlope;
    var greaterSlope = this.options.displayProfileOptions.greaterSlope;
    var ascendingElevation = this.options.displayProfileOptions.ascendingElevation;
    var descendingElevation = this.options.displayProfileOptions.descendingElevation; // clean

    var div = this._infoContainer;

    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    } // creation des infomations


    if (totalDistance) {
      this._addElevationPathInformationsItem("Distance totale : " + Math.round(this._data.distance).toLocaleString() + " m");
    }

    if (ascendingElevation) {
      this._addElevationPathInformationsItem("Dénivelé positif : " + this._data.ascendingElevation.toLocaleString() + " m");
    }

    if (descendingElevation) {
      this._addElevationPathInformationsItem("Dénivelé négatif : " + this._data.descendingElevation.toLocaleString() + " m");
    }

    if (meanSlope) {
      this._addElevationPathInformationsItem("Pente moyenne : " + this._data.meanSlope.toLocaleString() + " %");
    }

    if (greaterSlope) {
      this._addElevationPathInformationsItem("Plus forte pente : " + this._data.greaterSlope.toLocaleString() + " %");
    }
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on '' picto
   * and enable or disable the entry of the path
   *
   * @private
   */


  ElevationPath.prototype.onShowElevationPathClick = function () {
    var map = this.getMap();
    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_15__["default"].unset(map, {
      current: "ElevationPath"
    }); // Activation/Desactivation des interactions de dessins

    if (!this._showContainer.checked) {
      // on n'affiche pas la fenetre de profile s'il n'existe pas...
      if (this._profile === null) {
        this._panelContainer.style.display = "none"; // this._panelContainer.style.visibility = "hidden";
      }

      this._initMeasureInteraction(map);

      this._addMeasureInteraction(map);
    } else {
      this._panelContainer.style.display = "none"; // this._panelContainer.style.visibility = "hidden";

      this._removeMeasure();

      this._removeProfile();

      this._removeMeasureInteraction(map);
    }
  };
  /**
   * this method is called by event 'click' on '' picto
   * (cf. this.),
   * and display the panel info
   *
   * @private
   */


  ElevationPath.prototype.onOpenElevationPathInfoClick = function () {
    var div = this._infoContainer; // show des informations !

    if (div.className === "GPelevationPathInformationsContainerVisible") {
      clearTimeout(this._timerHdlr);
      div.className = "GPelevationPathInformationsContainerHidden";
    } else {
      div.className = "GPelevationPathInformationsContainerVisible";
    } // hidden des informations !


    this._timerHdlr = setTimeout(function () {
      div.className = "GPelevationPathInformationsContainerHidden";
    }, 4000);
  };

  return ElevationPath;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (ElevationPath); // Expose ElevationPath as ol.control.ElevationPath (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.ElevationPath = ElevationPath;
}

/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_ToolBoxMeasure_GPtoolBoxMeasureOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _CSS_Controls_ToolBoxMeasure_GPtoolBoxMeasureOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ToolBoxMeasure_GPtoolBoxMeasureOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(172);
/* harmony import */ var _Common_Controls_MeasureToolBoxDOM__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(279);
// import CSS
 // import local



 // DOM


var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("toolbox");
/*
* MeasureToolBox - Boite à outils (ToolBox) pour les outils de mesures.
* - distance
* - aire
* - azimut
*/

var MeasureToolBox = {
  /**
   * liste des uid/map (pour chaque toolbox)
   * { map : uid }
   * Ex. { "map1" : 465456456486845 }
   */
  _toolbox: {},

  /**
   * Ajout d'un controle dans la ToolBox.
   * Creation de la toolbox si besoin...
   *
   * @param {ol.Map} map - map
   * @param {ol.control.Control} ctrl - objet à ajouter
   */
  add: function add(map, ctrl) {
    logger.trace("ToolBox.add()", ctrl);

    if (!map) {
      logger.trace("map doesn't exist !?");
      return;
    } // contexte d'execution


    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;

    if (context) {
      // Pour info
      // l'objet ToolBox devrait être partagé avec les outils de mesures...,
      // mais, ce n'est pas le cas pour le mode modules cad un module par extension.
      // c'est pourquoi, on l'enregistre dans le contexte, qui lui est partagé (ex. window)
      this._toolbox = context.gpShareMeasureToolBox || {};
    }

    var mapContainer = map.getTargetElement();
    var mapDocument = mapContainer.ownerDocument;
    var mapId = mapContainer.id;

    if (!this._toolbox || Object.keys(this._toolbox).length === 0) {
      this._toolbox = {};
      this._toolbox[mapId] = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate();
    } else {
      if (!this._toolbox[mapId]) {
        this._toolbox[mapId] = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate();
      }
    }

    var uid = this._toolbox[mapId];

    if (!mapDocument.getElementById(this.getToolBoxID(uid))) {
      logger.trace("create toolbox !"); // creation et ajout de la toolbox sur la map

      var toolboxContainer = this._createToolBoxContainerElement(uid);

      toolboxContainer.style.pointerEvents = "auto"; // ajout pour ol6

      var overlaysContainer = mapContainer.getElementsByClassName("ol-overlaycontainer-stopevent");
      overlaysContainer[0].appendChild(toolboxContainer); // mapContainer.appendChild(toolboxContainer);
    } // ajout du widget dans la toolbox


    var widgetContainer = mapDocument.getElementById(this.getWidgetID(uid));
    ctrl.setTarget(widgetContainer);

    if (context) {
      // Pour info
      // on partage (enregistre) l'objet ToolBox dans le contexte d'execution !
      context.gpShareMeasureToolBox = this._toolbox;
    }

    logger.trace("add control to toolbox !");
  }
};
_Common_Utils__WEBPACK_IMPORTED_MODULE_2__["default"].assign(MeasureToolBox, _Common_Controls_MeasureToolBoxDOM__WEBPACK_IMPORTED_MODULE_4__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (MeasureToolBox);

/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var MeasureToolBoxDOM = {
  _toolboxId: "GPtoolbox-measure-main",
  _buttonId: "GPtoolbox-measure-button",
  _widgetId: "GPtoolbox-measure-widget",

  /**
  * get toolBox ID
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getToolBoxID: function getToolBoxID(uid) {
    return uid ? this._toolboxId + "-" + uid : this._toolboxId;
  },

  /**
  * get button ID
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getButtonID: function getButtonID(uid) {
    return uid ? this._buttonId + "-" + uid : this._buttonId;
  },

  /**
  * get toolBox Container for widget
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getWidgetID: function getWidgetID(uid) {
    return uid ? this._widgetId + "-" + uid : this._widgetId;
  },

  /**
   * Main container (DOM)
   * @param {Number} uid - uid
   * @returns {DOMElement} DOM element
   */
  _createToolBoxContainerElement: function _createToolBoxContainerElement(uid) {
    // <div id="GPtoolbox-measure-main">
    //   <button id="GPtoolbox-measure-button">&#9776;</button>
    //   <div id="GPtoolbox-measure-widget">
    //     <!-- HERE : widgets tools measures -->
    //   </div>
    // </div>
    var container = document.createElement("div");
    container.id = this.getToolBoxID(uid);
    container.className = "GPshowAdvancedToolPicto";
    var button = document.createElement("button");
    button.id = this.getButtonID(uid);
    var self = this;
    button.addEventListener("click", function () {
      this.blur(); // permet de perdre le focus !

      var widget = document.getElementById(self.getWidgetID(uid));

      if (widget.style.display === "block") {
        widget.style.display = "none";
      } else {
        widget.style.display = "block";
      }
    });
    container.appendChild(button);
    var widget = document.createElement("div");
    widget.id = this.getWidgetID(uid);
    widget.addEventListener("click", function () {
      /*
          e.preventDefault();
           // FIXME desactiver tous les outils sur
          // l'ouverture/fermeture de la toolbox ?
           var current = e.target.parentNode.getAttribute("for");
          var widgets = this.querySelectorAll("div > input");
          for (var i = 0; i < widgets.length; i++) {
              var id = widgets[i].id;
               if (document.getElementById(id) &&
                  document.getElementById(id).checked &&
                  document.querySelector("#" + id + " + label")) {
                      document.querySelector("#" + id + " + label").click();
                      // document.getElementById(id).checked = true;
              }
               if (current === id && widgets[i].checked) {
                  widgets[i].checked = false;
              } else if (current === id && !widgets[i].checked) {
                  widgets[i].checked = true;
              }
          }
      */
    }, false);
    container.appendChild(widget);
    return container;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (MeasureToolBoxDOM);

/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(145);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(196);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(141);
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(179);
/* harmony import */ var _LayerSwitcher__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(169);
// import OpenLayers




 // import local


 // import local with ol dependencies

 // Derived from OpenLayers measure example
// http://openlayers.org/en/latest/examples/measure.html

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__["default"].getLogger("measures");
/**
 * @private
 * @description
 * Measures Tools :
 * - length
 * - aera
 * - azimut
 */

var Measures = {
  // ****************************************************************** //
  // > Default Styles
  // ****************************************************************** //

  /*
   * Pointer
   */
  DEFAULT_POINTER_STYLE: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Circle"]({
    radius: 5,
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Stroke"]({
      color: "#002A50",
      width: 2
    }),
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Fill"]({
      color: "rgba(255, 155, 0, 0.7)"
    })
  }),

  /*
   * Measures style line
   */
  DEFAULT_DRAW_START_STYLE: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"]({
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Fill"]({
      color: "rgba(0, 183, 152, 0.2)"
    }),
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Stroke"]({
      color: "#002A50",
      lineDash: [10, 10],
      width: 2
    })
  }),

  /*
   * Measures final style line
   */
  DEFAULT_DRAW_FINISH_STYLE: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"]({
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Fill"]({
      color: "rgba(0, 183, 152, 0.3)"
    }),
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__["Stroke"]({
      color: "#002A50",
      width: 3
    })
  }),
  // ****************************************************************** //
  // > ToolBox : these tools work together
  // ****************************************************************** //
  // sample :
  // tools[name_control][0].(active|instance|map)
  // tools : {
  //      MeasureLength : [
  //          { active : true, instance : [Object MeasureLength], map : "map1" },
  //          { active : true, instance : [Object MeasureLength], map : "map2" }
  //      ],
  //      MeasureArea : [],
  //      MeasureAzimuth : []
  // }
  tools: {
    MeasureLength: [],
    MeasureArea: [],
    MeasureAzimuth: []
  },
  // ****************************************************************** //
  // > Variables
  // ****************************************************************** //

  /**
   * Global measure draw interaction
   * @type {ol.interaction.Draw}
   */
  measureDraw: null,

  /**
   * Global vector source for measure
   * @type {ol.source.Vector}
   */
  measureSource: null,

  /**
   * Global vector layer for measure
   * @type {ol.layer.Vector}
   */
  measureVector: null,

  /**
   * Currently drawn feature.
   * @type {ol.Feature}
   */
  sketch: null,

  /**
   * The measure tooltip element.
   * @type {Element}
   */
  measureTooltipElement: null,

  /**
   * Overlay to show the measurement.
   * @type {ol.Overlay}
   */
  measureTooltip: null,

  /**
   * TODO The help tooltip element.
   * @type {Element}
   */
  helpTooltipElement: null,

  /**
   * TODO Overlay to show the help.
   * @type {ol.Overlay}
   */
  helpTooltip: null,
  // ****************************************************************** //
  // > Methods Public
  // ****************************************************************** //

  /** Desactived Tool Measure */
  clean: function clean() {
    var _class = this.CLASSNAME;
    logger.trace("[" + _class + "] deactived tool !"); // sur la desactivation de l'outil de mesure
    // on fait un nettoyage des ressources
    // ainsi que le DOM

    this.clearMeasure();
    this.clearMeasureToolTip();
    this.removeMeasureEvents();
    this._showContainer.checked = false;
  },
  // ****************************************************************** //
  // > Methods Events
  // ****************************************************************** //

  /**
   * Handle pointer move.
   *
   * @param {ol.MapBrowserEvent} e - The event.
   */
  onPointerMoveHandler: function onPointerMoveHandler(e) {
    if (e.dragging) {
      return;
    }
    /** @type {ol.Coordinate|undefined} */


    var tooltipCoord = e.coordinate;

    if (this.sketch) {
      var output;
      var geom = this.sketch.getGeometry();
      output = this.format(geom);

      if (geom.getType() === "LineString") {
        tooltipCoord = geom.getLastCoordinate();
      } else if (geom.getType() === "Polygon") {
        tooltipCoord = geom.getInteriorPoint().getCoordinates();
      } else {
        return;
      }

      this.measureTooltipElement.innerHTML = output;
      this.measureTooltip.setPosition(tooltipCoord);
    }
  },

  /**
   * Main program !
   * This method is called by event 'click' on control picto
   *
   * @param {Object} e - HTMLElement
   * @param {String} type - LineString or Polygon
   * @private
   */
  onShowMeasureClick: function onShowMeasureClick(e, type) {
    var map = this.getMap();
    var currentMapId = map.getTargetElement().id; // contexte d'execution

    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;

    if (context) {
      // Pour info
      // les objets de mesures ont du code partagé
      // (afin de gerer les interactions entre eux).
      // Dans un mode "modules", on partage cet objet (this.tools) via le contexte
      // d'execution (ex. avec window)
      this.tools = context.gpShareMeasures || {};
    } // desactivation des controles de mesures sur la carte courrante


    var mySelf = this.CLASSNAME; // this.constructor.name : pas possible en mode minifié/manglifié !

    for (var className in this.tools) {
      if (this.tools.hasOwnProperty(className)) {
        var measures = this.tools[className];

        for (var i = 0; i < measures.length; i++) {
          var o = measures[i];

          if (o && o.active && className !== mySelf && o.map === currentMapId) {
            o.active = false;

            if (o.instance !== null) {
              // au cas où le controle a été supprimé !
              o.instance.clean();
            }
          }
        }
      }
    } // desactivation des autres interactions parasites


    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_6__["default"].unset(map, {
      current: "Measures"
    });

    if (!this._showContainer.checked) {
      this.addMeasureEvents();
      this.initMeasureInteraction();
      this.addMeasureInteraction(type);

      for (var j = 0; j < this.tools[mySelf].length; j++) {
        if (this.tools[mySelf][j].map === currentMapId) {
          this.tools[mySelf][j].active = true;
        }
      }
    } else {
      this.clearMeasure();
      this.clearMeasureToolTip();
      this.removeMeasureEvents();

      for (var k = 0; k < this.tools[mySelf].length; k++) {
        if (this.tools[mySelf][k].map === currentMapId) {
          this.tools[mySelf][k].active = false;
        }
      }
    }
  },
  // ****************************************************************** //
  // > Methods not Public
  // ****************************************************************** //

  /**
   * Clear all dom tooltip of length, area or azimut object.
   */
  clearMeasureToolTip: function clearMeasureToolTip() {
    var map = this.getMap();

    if (!map) {
      return;
    }

    var mapContainer = map.getTargetElement(); // au cas où il y'aurait plusieurs container de carte !

    var overlays = mapContainer.getElementsByClassName("ol-overlaycontainer-stopevent");

    for (var k = 0; k < overlays.length; k++) {
      var nodes = overlays[k];
      var len = nodes.children.length;
      var nodesToRemove = [];

      for (var i = 0; i < len; i++) {
        var node = nodes.children[i];

        if (node.children.length !== 0) {
          var child = node.children[0];

          if (child.className === "GPmeasureTooltip GPmeasureTooltip-static" || child.className === "GPmeasureTooltip GPmeasureTooltip-measure") {
            nodesToRemove.push(node);
          }
        }
      }

      for (var j = 0; j < nodesToRemove.length; j++) {
        nodes.removeChild(nodesToRemove[j]);
      }
    }
  },

  /**
   * Clear all length, area or azimut object.
   */
  clearMeasure: function clearMeasure() {
    var map = this.getMap(); // FIXME !?
    // if (this.measureTooltip) {
    //     map.removeOverlay(this.measureTooltip);
    //     this.measureTooltip = null;
    // }

    if (this.measureVector) {
      map.removeLayer(this.measureVector);
      this.measureVector = null;
    }

    if (this.measureDraw) {
      map.removeInteraction(this.measureDraw);
      this.measureDraw = null;
    }
  },

  /**
   * Creates a new measure tooltip
   * FIXME bug d'affichage de la tooltip de saisie en cours si on ne termine pas
   * la saisie  !?
   *
   * @param {ol.Map} map - The Map.
   */
  createMeasureTooltip: function createMeasureTooltip(map) {
    if (this.measureTooltipElement) {
      this.measureTooltipElement.parentNode.removeChild(this.measureTooltipElement);
    }

    this.measureTooltipElement = document.createElement("div");
    this.measureTooltipElement.className = "GPmeasureTooltip GPmeasureTooltip-measure";
    this.measureTooltip = new ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default.a({
      element: this.measureTooltipElement,
      offset: [0, -15],
      positioning: "bottom-center"
    });
    map.addOverlay(this.measureTooltip);
  },

  /**
   * TODO evolution
   * Creates a new help tooltip
   *
   * @param {ol.Map} map - The Map.
   */
  createHelpTooltip: function createHelpTooltip(map) {
    if (this.helpTooltipElement) {
      this.helpTooltipElement.parentNode.removeChild(this.helpTooltipElement);
    }

    this.helpTooltipElement = document.createElement("div");
    this.helpTooltipElement.className = "tooltip hidden";
    this.helpTooltip = new ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default.a({
      element: this.helpTooltipElement,
      offset: [15, 0],
      positioning: "center-left"
    });
    map.addOverlay(this.helpTooltip);
  },

  /**
   * Creates a style for drawing
   *
   * @param {Object} styles - styles.
   */
  createStylingMeasureInteraction: function createStylingMeasureInteraction(styles) {
    this.options.styles = styles || {}; // style de depart

    logger.trace("style start", this.options.styles.start); // Creation à partir des styles par défaut

    var startStyleOpts = {
      image: Measures.DEFAULT_POINTER_STYLE,
      fill: Measures.DEFAULT_DRAW_START_STYLE.getFill(),
      stroke: Measures.DEFAULT_DRAW_START_STYLE.getStroke()
    }; // ecrasement à partir des propriétés renseignées

    if (this.options.styles.hasOwnProperty("pointer") && this.options.styles.pointer instanceof Image) {
      startStyleOpts.image = this.options.styles.pointer;
    }

    if (this.options.styles.hasOwnProperty("start") && this.options.styles.start instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"]) {
      if (this.options.styles.start.getFill() != null) {
        startStyleOpts.fill = this.options.styles.start.getFill();
      }

      if (this.options.styles.start.getStroke() != null) {
        startStyleOpts.stroke = this.options.styles.start.getStroke();
      }
    }

    this.options.styles.start = new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"](startStyleOpts); // style de fin

    logger.trace("style finish", this.options.styles.finish);
    var finishStyleOpts = {
      fill: Measures.DEFAULT_DRAW_FINISH_STYLE.getFill(),
      stroke: Measures.DEFAULT_DRAW_FINISH_STYLE.getStroke()
    }; // ecrasement à partir des propriétés renseignées

    if (this.options.styles.hasOwnProperty("finish") && this.options.styles.finish instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"]) {
      if (this.options.styles.finish.getFill() != null) {
        finishStyleOpts.fill = this.options.styles.finish.getFill();
      }

      if (this.options.styles.finish.getStroke() != null) {
        finishStyleOpts.stroke = this.options.styles.finish.getStroke();
      }
    }

    this.options.styles.finish = new ol_style__WEBPACK_IMPORTED_MODULE_2__["Style"](finishStyleOpts);
  },

  /**
   * Add the measure interaction
   *
   * @param {String} type - LineString or Polygon.
   */
  addMeasureInteraction: function addMeasureInteraction(type) {
    var map = this.getMap(); // Creates and adds the interaction

    var self = this;
    this.measureDraw = new ol_interaction__WEBPACK_IMPORTED_MODULE_1__["Draw"]({
      source: this.measureSource,
      // condition : permet de gerer la suppression des derniers points saisis
      condition: function condition(event) {
        if (event.originalEvent.ctrlKey) {
          if (self.sketch) {
            this.removeLastPoint();
          }

          return false;
        }

        return true;
      },
      type: type,
      style: this.options.styles.start || Measures.DEFAULT_DRAW_START_STYLE
    });
    this.measureDraw.setProperties({
      name: "Measures",
      source: this
    });
    map.addInteraction(this.measureDraw); // Create tooltips

    this.createMeasureTooltip(map); // Event start measuring

    this.measureDraw.on("drawstart", function (evt) {
      // set sketch
      self.sketch = evt.feature;
    }); // Event end measuring

    this.measureDraw.on("drawend", function () {
      // FIXME MaJ de la tooltip en mode mobile !
      if (self.sketch) {
        var output;
        var tooltipCoord;
        var geom = self.sketch.getGeometry();
        output = self.format(geom);

        if (geom.getType() === "LineString") {
          tooltipCoord = geom.getLastCoordinate();
        } else if (geom.getType() === "Polygon") {
          tooltipCoord = geom.getInteriorPoint().getCoordinates();
        } else {
          return;
        }

        self.measureTooltipElement.innerHTML = output;
        self.measureTooltip.setPosition(tooltipCoord);
      }

      self.measureTooltipElement.className = "GPmeasureTooltip GPmeasureTooltip-static";
      self.measureTooltip.setOffset([0, -7]); // unset sketch

      self.sketch = null; // unset tooltip so that a new one can be created

      self.measureTooltipElement = null;
      self.createMeasureTooltip(map);
    });
  },

  /**
   * Init the measure interaction
   */
  initMeasureInteraction: function initMeasureInteraction() {
    var _this = this;

    var map = this.getMap();
    this.measureSource = new ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default.a();
    this.measureVector = new ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default.a({
      source: this.measureSource,
      style: this.options.styles.finish || Measures.DEFAULT_DRAW_FINISH_STYLE
    }); // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant.

    this.measureVector.gpResultLayerId = "measure";
    map.addLayer(this.measureVector); // Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche

    map.getControls().forEach(function (control) {
      if (control instanceof _LayerSwitcher__WEBPACK_IMPORTED_MODULE_7__["default"]) {
        // un layer switcher est présent dans la carte
        var layerId = _this.measureVector.gpLayerId; // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)

        if (control._layers[layerId].title === layerId) {
          control.addLayer(_this.measureVector, {
            title: _this.options.layerDescription.title,
            description: _this.options.layerDescription.description
          });
        }
      }
    });
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Measures);

/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var ElevationPathDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPelevationPath");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing panel
   *
   * @returns {DOMElement} DOM element
   */
  _createShowElevationPathElement: function _createShowElevationPathElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowElevationPath");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowElevationPathPictoElement: function _createShowElevationPathPictoElement() {
    // contexte d'execution
    var context = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowElevationPathPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowElevationPath");
    label.title = "Calculer un profil"; // gestionnaire d'evenement :
    // on ouvre le menu de saisie de saisie
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        context.onShowElevationPathClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        context.onShowElevationPathClick(e);
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowElevationPathOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  },
  // ################################################################### //
  // ######################### Methods to Panel ######################## //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createElevationPathPanelHeaderElement
   * don't call this._createElevationPathPanelProfilElement
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathPanelElement: function _createElevationPathPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPelevationPathPanel");
    div.className = "GPpanel"; // div.appendChild(this._createElevationPathPanelHeaderElement());
    // div.appendChild(this._createElevationPathPanelProfilElement());

    return div;
  },

  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathPanelHeaderElement: function _createElevationPathPanelHeaderElement() {
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader";
    var divInfo = document.createElement("div");
    divInfo.id = this._addUID("GPelevationPathPanelInfo");
    divInfo.className = "GPpanelInfo";
    divInfo.title = "Informations"; // add event on click

    if (divInfo.addEventListener) {
      divInfo.addEventListener("click", function () {
        self.onOpenElevationPathInfoClick();
      });
    } else if (divInfo.attachEvent) {
      // internet explorer
      divInfo.attachEvent("onclick", function () {
        self.onOpenElevationPathInfoClick();
      });
    }

    container.appendChild(divInfo);
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle";
    divTitle.innerHTML = "Profil Altimétrique";
    container.appendChild(divTitle);
    var divReduce = document.createElement("div");
    divReduce.id = this._addUID("GPelevationPathPanelReduce");
    divReduce.className = "GPpanelReduce";
    divReduce.title = "Masquer le panneau";

    if (divReduce.addEventListener) {
      divReduce.addEventListener("click", function () {
        if (typeof self.onReduceElevationPathPanelClick === "function") {
          document.getElementById(self._addUID("GPshowElevationPath")).checked = false;
          self.onReduceElevationPathPanelClick();
        }
      }, false);
    } else if (divReduce.attachEvent) {
      divReduce.attachEvent("onclick", function () {
        if (typeof self.onReduceElevationPathPanelClick === "function") {
          document.getElementById(self._addUID("GPshowElevationPath")).checked = false;
          self.onReduceElevationPathPanelClick();
        }
      });
    }

    container.appendChild(divReduce);
    var divClose = document.createElement("div");
    divClose.id = this._addUID("GPelevationPathPanelClose");
    divClose.className = "GPpanelClose";
    divClose.title = "Fermer le panneau"; // Link panel close / visibility checkbox

    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowElevationPathPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowElevationPathPicto")).click();
      });
    }

    container.appendChild(divClose);
    return container;
  },

  /**
   * Create Form
   * see evenement !
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathPanelProfilElement: function _createElevationPathPanelProfilElement() {
    var div = document.createElement("div");
    div.id = "GPelevationPathProfil";
    return div;
  },

  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathWaitingElement: function _createElevationPathWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPelevationPathCalcWaitingContainer");
    div.className = "GPelevationPathCalcWaitingContainerHidden";
    var p = document.createElement("p");
    p.className = "GPelevationPathCalcWaiting";
    p.innerHTML = "Calcul en cours...";
    div.appendChild(p);
    return div;
  },

  /**
   * Create information Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathInformationsElement: function _createElevationPathInformationsElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPelevationPathInformationsContainer");
    div.className = "GPelevationPathInformationsContainerHidden";
    var p = document.createElement("p");
    p.className = "GPelevationPathInformations";
    p.innerHTML = "Aucune information...";
    div.appendChild(p);
    return div;
  },

  /**
   * Add a information into Panel
   *
   * @param {String} value - value of item
   * @returns {DOMElement} DOM element
   */
  _addElevationPathInformationsItem: function _addElevationPathInformationsItem(value) {
    var div = document.getElementById(this._addUID("GPelevationPathInformationsContainer"));

    if (div) {
      var p = document.createElement("p");
      p.className = "GPelevationPathInformations";
      p.innerHTML = value;
      div.appendChild(p);
    }

    return div;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (ElevationPathDOM);

/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* globals AmCharts, d3 */
var ProfileElevationPathDOM = {
  /**
   * Gets a css property from an element
   *
   * @param {String} element The element to get the property from
   * @param {String} property The css property
   * @returns {String} The value of the property
   *
   * @see https://stackoverflow.com/questions/7444451/how-to-get-the-actual-rendered-font-when-its-not-defined-in-css
   */
  _getCssProperty: function _getCssProperty(element, property) {
    return window.getComputedStyle(element, null).getPropertyValue(property);
  },

  /**
   * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
   *
   * @param {String} text The text to be rendered.
   * @param {String} container The container of the text
   * @param {String} font The font of the container if known, format: 'weight size familiy'
   * @returns {Number} The width of the text
   *
   * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
   */
  _getTextWidth: function _getTextWidth(text, container) {
    var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    // re-use canvas object for better performance
    var canvas = this.canvas || (this.canvas = document.createElement("canvas"));
    var context = canvas.getContext("2d");

    if (font === null) {
      context.font = "".concat(this._getCssProperty(container, "font-weight"), " ").concat(this._getCssProperty(container, "font-size"), " ").concat(this._getCssProperty(container, "font-family"));
    } else {
      context.font = font;
    }

    var metrics = context.measureText(text);
    return metrics.width;
  },

  /**
   * Converts a data point z to svg y coord
   *
   * @param {Object} z The z to convert.
   * @param {Number} pathHeight The height of the path in the svg container in px
   * @param {Number} minGraphZ Min z of the graph
   * @param {Number} pxPerMZ Number of pixels per meter for the z (y) axis
   * @returns {Number} The y svg coordinate of the point
   *
   */
  _dataZToSvgY: function _dataZToSvgY(z, pathHeight, minGraphZ, pxPerMZ) {
    return pathHeight - (z - minGraphZ) * pxPerMZ - 0.5;
  },

  /**
   * Converts a data point dist value to svg x coord
   *
   * @param {Number} dist The dist to convert
   * @param {Number} svgWidth The witdth of the svg container in px
   * @param {Number} pathWidth The witdth of the path in the svg container in px
   * @param {Number} pxPerMX Number of pixels per meter for the x axis
   * @returns {Array} The x svg coordinate of the point
   *
   */
  _dataDistToSvgX: function _dataDistToSvgX(dist, svgWidth, pathWidth, pxPerMX) {
    return svgWidth - pathWidth + dist * pxPerMX;
  },

  /**
   * Converts a svg x coord to dist value
   *
   * @param {Number} svgX The dist to convert
   * @param {Number} svgWidth The witdth of the svg container in px
   * @param {Number} pathWidth The witdth of the path in the svg container in px
   * @param {Number} pxPerMX Number of pixels per meter for the x axis
   * @returns {Array} The dist value
   *
   */
  _svgXToDataDist: function _svgXToDataDist(svgX, svgWidth, pathWidth, pxPerMX) {
    return (svgX + pathWidth - svgWidth) / pxPerMX;
  },

  /**
   * Returns the index of value if it were inserted in sorted (by dist) array of data points.
   *
   * @param {Array} array Sorted array of data points (with dist property)
   * @param {Number} value Value to test the index of.
   * @returns {Number} The index the value would have.
   *
   */
  _arrayBisect: function _arrayBisect(array, value) {
    var idx;

    if (array.length === 0) {
      return 0;
    }

    for (idx = 0; idx < array.length; idx++) {
      if (value < array[idx].dist) {
        return idx;
      }
    }

    return idx - 1;
  },

  /**
   * Display Profile function used by default : no additonal framework needed.
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileByDefault: function displayProfileByDefault(data, container, context, className) {
    var self = context;

    if (!container) {
      return;
    }

    if (!data) {
      return;
    } // on nettoie toujours...


    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }

    var margin = {
      top: 25,
      right: 15,
      bottom: 10,
      left: 10
    };
    var _displayProfileOptions = self.options.displayProfileOptions;
    var _points = data.points;
    var sortedElev = JSON.parse(JSON.stringify(_points));
    sortedElev.sort(function (e1, e2) {
      return e1.z - e2.z;
    });
    var minZ = sortedElev[0].z;
    var maxZ = sortedElev[sortedElev.length - 1].z;
    var dist = data.distance;
    var distUnit = "m";
    var widgetDiv = document.createElement("div");
    widgetDiv.id = "profileElevationByDefault";
    container.appendChild(widgetDiv); // Détermination des tailles en pixels des éléments du widget

    var widgetHeigth = container.clientHeight - margin.top - margin.bottom;
    var widgetWidth = container.clientWidth - margin.left - margin.right;
    var zLabelWidth = 17;

    var zGradWidth = this._getTextWidth(Math.round(maxZ).toLocaleString() + ",88", container, "400 10 Verdana");

    var xLabelHeight = 17;
    var xGradHeight = 15;
    var minZguideHeigth = 15;

    var minXguideWidth = this._getTextWidth(Math.round(dist).toLocaleString() + ",5", container);

    var minNumXGuides = 1;
    var pathHeight = widgetHeigth - xLabelHeight - xGradHeight;
    var pathWidth = widgetWidth - zLabelWidth - zGradWidth;
    var elevationSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    elevationSvg.id = "profileElevationByDefaultSvg";
    elevationSvg.setAttribute("style", "display: block; margin: auto; overflow: visible; position: absolute; left: 10px;");
    elevationSvg.setAttribute("viewBox", "0 0 ".concat(container.clientWidth, " ").concat(container.clientHeight));
    elevationSvg.setAttribute("width", "100%");
    elevationSvg.setAttribute("height", "100%"); // Détermination des guides en ordonnée :

    var maxNumZguides = Math.floor(pathHeight / minZguideHeigth);
    var gradZ; // Traitement du cas altitude max = altitude min

    if (maxZ === minZ) {
      gradZ = 0.1;
    } else {
      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10))) / 2;
    }

    var minGraphZ = Math.floor(minZ / gradZ) * gradZ;
    var maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ; // cas où le path atteint pile les graduations extremes : ajout d'une gradiation

    if (maxGraphZ === maxZ) {
      maxGraphZ += gradZ;
    } // cas où gradZ < 1 : nombres flottants capricieux...


    minGraphZ = Math.round(minGraphZ * 100) / 100;
    maxGraphZ = Math.round(maxGraphZ * 100) / 100;
    var numZguides = Math.round((maxGraphZ - minGraphZ) / gradZ); // Si plus de guides que le max, on passe à une graduation de 10**x en 10**x (et non 10**x / 2)

    if (numZguides + 1 > maxNumZguides) {
      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10)));
      minGraphZ = Math.floor(minZ / gradZ) * gradZ;
      maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ; // cas où le path atteint pile les graduations extremes : ajout d'une gradiation

      if (maxGraphZ === maxZ) {
        maxGraphZ += gradZ;
      } // cas où gradZ < 1 : nombres flottants capricieux...


      minGraphZ = Math.round(minGraphZ * 100) / 100;
      maxGraphZ = Math.round(maxGraphZ * 100) / 100;
      numZguides = Math.floor((maxGraphZ - minGraphZ) / gradZ);
    }

    numZguides = Math.max(Math.round(numZguides), 1);
    var axisZ = document.createElementNS("http://www.w3.org/2000/svg", "g");
    axisZ.setAttribute("class", "profile-z-vertical");
    var guidesZ = document.createElementNS("http://www.w3.org/2000/svg", "g");
    var gradZyOffsetPx = pathHeight / numZguides;
    var pxPerMZ = pathHeight / (maxGraphZ - minGraphZ); // Traitement du cas altitude max = altitude min

    if (maxZ === minZ) {
      pxPerMZ = pathHeight / 0.2;
    } else {
      pxPerMZ = pathHeight / (maxGraphZ - minGraphZ);
    }

    var gradZtext;
    var yTextTranslation;
    var yStrokeTranslation;
    var gradZstroke;
    var gradZpath;
    var gradZgrad; // Ajout des graduations au graphique

    for (var i = 0; i <= numZguides; i++) {
      gradZtext = document.createElementNS("http://www.w3.org/2000/svg", "text");
      gradZtext.setAttribute("class", "profile-z-graduation");
      gradZtext.setAttribute("font-family", "Verdana");
      gradZtext.setAttribute("font-size", "10px");
      gradZtext.setAttribute("fill", "#5E5E5E"); // Cas où gradZ < 1 : nombres flottants capricieux...
      // Le Math.round est pour éviter des ennuis du genre 3 * 0.1 = 0.300000000000004

      gradZtext.textContent = (Math.round(100 * (minGraphZ + i * gradZ)) / 100).toLocaleString();
      yTextTranslation = pathHeight - i * gradZyOffsetPx;
      gradZtext.setAttribute("transform", "translate(".concat(zLabelWidth + zGradWidth - 8, ", ").concat(yTextTranslation + 5, ")"));
      gradZtext.setAttribute("text-anchor", "end");
      axisZ.appendChild(gradZtext);
      yStrokeTranslation = Math.round(yTextTranslation) - 0.5;
      gradZstroke = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gradZpath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradZpath.setAttribute("cs", "100,100");
      gradZpath.setAttribute("stroke-width", "1");

      if (i !== 0) {
        gradZpath.setAttribute("stroke-opacity", "0.2");
      } else {
        gradZpath.setAttribute("stroke-opacity", "1");
      }

      gradZpath.setAttribute("stroke", "#000000");
      gradZpath.setAttribute("fill", "none");
      gradZpath.setAttribute("d", "M".concat(zLabelWidth + zGradWidth, ",").concat(yStrokeTranslation, " L").concat(pathWidth + zLabelWidth + zGradWidth, ",").concat(yStrokeTranslation));
      gradZgrad = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradZgrad.setAttribute("cs", "100,100");
      gradZgrad.setAttribute("stroke-width", "1");
      gradZgrad.setAttribute("stroke-opacity", "1");
      gradZgrad.setAttribute("stroke", "#000000");
      gradZgrad.setAttribute("fill", "none");
      gradZgrad.setAttribute("d", "M".concat(zLabelWidth + zGradWidth, ",").concat(yStrokeTranslation, " L").concat(zLabelWidth + zGradWidth + 5, ",").concat(yStrokeTranslation));
      gradZgrad.setAttribute("transform", "translate(-5, 0)");
      gradZstroke.appendChild(gradZgrad);
      gradZstroke.appendChild(gradZpath);
      guidesZ.appendChild(gradZstroke);
    }

    var axisZLegend = document.createElementNS("http://www.w3.org/2000/svg", "text");
    axisZLegend.setAttribute("class", "profile-z-legend");
    axisZLegend.setAttribute("font-family", "Verdana");
    axisZLegend.setAttribute("font-size", "11px");
    axisZLegend.setAttribute("fill", "#5E5E5E");
    axisZLegend.textContent = "Altitude (m)";
    axisZLegend.setAttribute("transform", "translate(".concat(zLabelWidth - 8, ", ").concat(Math.round(pathHeight / 2), ") rotate(-90)"));
    axisZLegend.setAttribute("text-anchor", "middle");
    axisZ.appendChild(axisZLegend);
    elevationSvg.appendChild(axisZ);
    elevationSvg.appendChild(guidesZ); // Détermination des guides en abscisse :
    // Passage éventuel en km

    if (dist > 2000) {
      dist /= 1000;
      distUnit = "km";
    }

    var maxNumXguides = Math.floor(pathWidth / minXguideWidth);
    var gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10))) / 2;
    var maxGraphX = dist; // Si plus de guides que le max, on passe à une graduation de 10**x en 10**x (et non 10**x / 2)

    var numXguides = Math.floor(maxGraphX / gradX);

    if (numXguides > maxNumXguides) {
      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)));
      numXguides = Math.floor(maxGraphX / gradX);
    } else if (numXguides < minNumXGuides) {
      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)) - 1);
      numXguides = Math.floor(maxGraphX / gradX);
    }

    numXguides = Math.max(numXguides, 1);
    var lastGradX = gradX * numXguides;
    var axisX = document.createElementNS("http://www.w3.org/2000/svg", "g");
    axisX.setAttribute("class", "profile-x-vertical");
    var guidesX = document.createElementNS("http://www.w3.org/2000/svg", "g"); // Décalage des graduations pour que la dernière corresponde à la distance max

    var pxPerMX = pathWidth / maxGraphX;
    var xOffset = (maxGraphX - lastGradX) * pxPerMX;
    var gradXxOffsetPx = Math.round((pathWidth - xOffset) / numXguides);
    var gradXtext;
    var xTextTranslation;
    var xStrokeTranslation;
    var gradXstroke;
    var gradXpath;
    var gradXgrad; // Ajout des graduations au graphique

    for (var _i = 0; _i <= numXguides + 1; _i++) {
      gradXtext = document.createElementNS("http://www.w3.org/2000/svg", "text");
      gradXtext.setAttribute("class", "profile-x-graduation");
      gradXtext.setAttribute("font-family", "Verdana");
      gradXtext.setAttribute("font-size", "10px");
      gradXtext.setAttribute("fill", "#5E5E5E"); // Exclusion du cas de la dernière graduation : correspond à la distance max : pas de texte

      if (_i !== numXguides + 1) {
        // Cas où gradX < 1 : nombres flottants capricieux...
        gradXtext.textContent = (Math.round(100 * _i * gradX) / 100).toLocaleString();
      }

      xTextTranslation = zLabelWidth + zGradWidth + _i * gradXxOffsetPx; // Cas de la dernière graduation : correspond à la distance max

      if (_i === numXguides + 1) {
        xTextTranslation = zLabelWidth + zGradWidth + pathWidth;
      }

      gradXtext.setAttribute("transform", "translate(".concat(xTextTranslation, ", ").concat(pathHeight + xGradHeight + 5, ")"));
      gradXtext.setAttribute("text-anchor", "middle");
      axisX.appendChild(gradXtext);
      xStrokeTranslation = xTextTranslation - 0.5;
      gradXstroke = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gradXpath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradXpath.setAttribute("cs", "100,100");
      gradXpath.setAttribute("stroke-width", "1");

      if (_i !== 0) {
        gradXpath.setAttribute("stroke-opacity", "0.2");
      } else {
        gradXpath.setAttribute("stroke-opacity", "1");
      }

      gradXpath.setAttribute("stroke", "#000000");
      gradXpath.setAttribute("fill", "none");
      gradXpath.setAttribute("d", "M".concat(xStrokeTranslation, ",").concat(pathHeight, " L").concat(xStrokeTranslation, ",0"));
      gradXgrad = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradXgrad.setAttribute("cs", "100,100");
      gradXgrad.setAttribute("stroke-width", "1");
      gradXgrad.setAttribute("stroke-opacity", "1");
      gradXgrad.setAttribute("stroke", "#000000");
      gradXgrad.setAttribute("fill", "none");
      gradXgrad.setAttribute("d", "M".concat(xStrokeTranslation, ",").concat(pathHeight, " L").concat(xStrokeTranslation, ",").concat(pathHeight - 5));
      gradXgrad.setAttribute("transform", "translate(0, 5)");
      gradXstroke.appendChild(gradXgrad);
      gradXstroke.appendChild(gradXpath);
      guidesX.appendChild(gradXstroke);
    }

    var axisXLegend = document.createElementNS("http://www.w3.org/2000/svg", "text");
    axisXLegend.setAttribute("class", "profile-x-legend");
    axisXLegend.setAttribute("font-family", "Verdana");
    axisXLegend.setAttribute("font-size", "11px");
    axisXLegend.setAttribute("fill", "#5E5E5E");
    axisXLegend.textContent = "Distance (".concat(distUnit, ")");
    axisXLegend.setAttribute("transform", "translate(".concat(zLabelWidth + zGradWidth + pathWidth / 2, ", ").concat(pathHeight + xGradHeight + xLabelHeight + 3, ")"));
    axisXLegend.setAttribute("text-anchor", "middle");
    axisX.appendChild(axisXLegend);
    elevationSvg.appendChild(axisX);
    elevationSvg.appendChild(guidesX);
    var elevationPathG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    var factor = 1;

    if (distUnit === "km") {
      factor = 1000;
    }

    var pointX = this._dataDistToSvgX(_points[0].dist / factor, widgetWidth, pathWidth, pxPerMX);

    var pointY = this._dataZToSvgY(_points[0].z, pathHeight, minGraphZ, pxPerMZ);

    var pathD = "M".concat(pointX, ",").concat(pointY);

    for (var _i2 = 1; _i2 < _points.length; _i2++) {
      pointX = this._dataDistToSvgX(_points[_i2].dist / factor, widgetWidth, pathWidth, pxPerMX);
      pointY = this._dataZToSvgY(_points[_i2].z, pathHeight, minGraphZ, pxPerMZ);
      pathD += " L".concat(pointX, ",").concat(pointY);
    }

    var pathPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathPath.setAttribute("cs", "100,100");
    pathPath.setAttribute("stroke-width", "1");
    pathPath.setAttribute("stroke-opacity", "1");
    pathPath.setAttribute("stroke", "#0B6BA7");
    pathPath.setAttribute("fill", "none");
    pathPath.setAttribute("d", pathD); // Fermeture du path pour le fill

    pathD += " L".concat(pointX, ",").concat(pathHeight);
    pathD += " L".concat(widgetWidth - pathWidth, ",").concat(pathHeight);
    var pathFill = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathFill.setAttribute("cs", "100,100");
    pathFill.setAttribute("stroke-width", "1");
    pathFill.setAttribute("stroke-opacity", "0");
    pathFill.setAttribute("stroke", "#000000");
    pathFill.setAttribute("fill", "#00B798");
    pathFill.setAttribute("fill-opacity", "0.4");
    pathFill.setAttribute("d", pathD);
    elevationPathG.appendChild(pathPath);
    elevationPathG.appendChild(pathFill);
    elevationSvg.appendChild(elevationPathG); // Mise en place de l'écouteur d'évènement : pour l'affichage dynamique

    var dynamicsG = document.createElementNS("http://www.w3.org/2000/svg", "g"); // Pour écouter la position de la souris

    var pathRectangle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    pathRectangle.setAttribute("width", pathWidth);
    pathRectangle.setAttribute("height", pathHeight);
    pathRectangle.setAttribute("transform", "translate(".concat(widgetWidth - pathWidth, ",0)"));
    pathRectangle.setAttribute("visibility", "hidden");
    pathRectangle.setAttribute("pointer-events", "all");
    var sortedDist = JSON.parse(JSON.stringify(_points));
    sortedDist.sort(function (e1, e2) {
      return e1.dist - e2.dist;
    });
    var focusLineX = document.createElementNS("http://www.w3.org/2000/svg", "line");
    focusLineX.setAttribute("id", "focusLineX");
    focusLineX.setAttribute("class", "focusLine-default");
    focusLineX.setAttribute("fill", "none");
    focusLineX.setAttribute("stroke", "#F90");
    focusLineX.setAttribute("stroke-width", "0.5px");
    focusLineX.setAttribute("visibility", "hidden");
    var focusLineY = document.createElementNS("http://www.w3.org/2000/svg", "line");
    focusLineY.setAttribute("id", "focusLineY");
    focusLineY.setAttribute("class", "focusLine-default");
    focusLineY.setAttribute("fill", "none");
    focusLineY.setAttribute("stroke", "#F90");
    focusLineY.setAttribute("stroke-width", "0.5px");
    focusLineY.setAttribute("visibility", "hidden");
    var focusCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    focusCircle.setAttribute("id", "focusCircle");
    focusCircle.setAttribute("r", 4);
    focusCircle.setAttribute("class", "circle-default focusCircle-default");
    focusCircle.setAttribute("fill", "#F90");
    focusCircle.setAttribute("visibility", "hidden");
    dynamicsG.appendChild(focusCircle);
    dynamicsG.appendChild(focusLineX);
    dynamicsG.appendChild(focusLineY); // Tooltip

    var tooltipDiv = document.createElementNS("http://www.w3.org/2000/svg", "text");
    var altiSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    var slopeSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    var coordsSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    tooltipDiv.setAttribute("style", "text-align:center; max-width:220px; font-size:10px; color:#000000; font-family:Verdana; z-index:50;");
    tooltipDiv.style.pointerEvents = "none";
    tooltipDiv.style.position = "fixed"; // tooltipDiv.classList.add("tooltipInit");
    // IE...

    tooltipDiv.setAttribute("class", "tooltipInit");
    tooltipDiv.setAttribute("text-anchor", "middle");
    widgetDiv.appendChild(tooltipDiv);
    altiSpan.setAttribute("class", "altiPathValue");
    altiSpan.setAttribute("x", "0");
    altiSpan.setAttribute("dy", "-.7em");
    slopeSpan.setAttribute("class", "altiPathValue");
    slopeSpan.setAttribute("x", "0");
    slopeSpan.setAttribute("dy", "1em");
    coordsSpan.setAttribute("class", "altiPathCoords");
    coordsSpan.setAttribute("x", "0");
    coordsSpan.setAttribute("dy", "1em");
    tooltipDiv.appendChild(altiSpan);

    if (_displayProfileOptions.currentSlope) {
      tooltipDiv.appendChild(slopeSpan);
    }

    tooltipDiv.appendChild(coordsSpan);
    var tooltipG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    dynamicsG.appendChild(tooltipG);
    var tooltipBubble = document.createElementNS("http://www.w3.org/2000/svg", "path");
    tooltipBubble.setAttribute("cs", "100,100");
    tooltipBubble.setAttribute("fill", "#FFFFFF");
    tooltipBubble.setAttribute("stroke", "#CCCCCC");
    tooltipBubble.setAttribute("fill-opacity", "0.8");
    tooltipBubble.setAttribute("stroke-width", "1");
    tooltipBubble.setAttribute("stroke-opacity", "1");
    var tooltipBubbleShadow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    tooltipBubbleShadow.setAttribute("cs", "100,100");
    tooltipBubbleShadow.setAttribute("fill", "#FFFFFF");
    tooltipBubbleShadow.setAttribute("stroke", "#000000");
    tooltipBubbleShadow.setAttribute("fill-opacity", "0");
    tooltipBubbleShadow.setAttribute("stroke-width", "1");
    tooltipBubbleShadow.setAttribute("stroke-opacity", "0.4");
    tooltipBubbleShadow.setAttribute("transform", "translate(1,1)");
    tooltipG.appendChild(tooltipBubbleShadow);
    tooltipG.appendChild(tooltipBubble);
    tooltipG.appendChild(tooltipDiv); // tooltipG.classList.add("tooltipInit");
    // IE... deprecated

    tooltipG.setAttribute("class", "tooltipInit");
    tooltipG.style.pointerEvents = "none";
    pathRectangle.addEventListener("mouseover", function () {
      focusLineX.setAttribute("visibility", "visible");
      focusLineY.setAttribute("visibility", "visible");
      focusCircle.setAttribute("visibility", "visible");

      className.__createProfileMarker(self, _points[0]); // tooltips
      // tooltipDiv.classList.remove("tooltipInit");
      // tooltipG.classList.remove("tooltipInit");
      // tooltipDiv.classList.remove("tooltipFadeOut");
      // tooltipG.classList.remove("tooltipFadeOut");
      // tooltipDiv.classList.add("tooltipFadeIn");
      // tooltipG.classList.add("tooltipFadeIn");
      // IE... deprecated


      tooltipDiv.setAttribute("class", "tooltipFadeIn");
      tooltipG.setAttribute("class", "tooltipFadeIn");
    });
    pathRectangle.addEventListener("mouseout", function () {
      focusLineX.setAttribute("visibility", "hidden");
      focusLineY.setAttribute("visibility", "hidden");
      focusCircle.setAttribute("visibility", "hidden");

      className.__removeProfileMarker(self); // tooltips
      // tooltipDiv.classList.remove("tooltipFadeIn");
      // tooltipG.classList.remove("tooltipFadeIn");
      // tooltipDiv.classList.add("tooltipFadeOut");
      // tooltipG.classList.add("tooltipFadeOut");
      // IE... deprecated


      tooltipDiv.setAttribute("class", "tooltipFadeOut");
      tooltipG.setAttribute("class", "tooltipFadeOut");
    });
    pathRectangle.addEventListener("mousemove", function (e) {
      var mousePoint = elevationSvg.createSVGPoint();
      mousePoint.x = e.clientX;
      mousePoint.y = e.clientY;
      var svgMousePoint = mousePoint.matrixTransform(elevationSvg.getScreenCTM().inverse());
      var mouseDist = this._svgXToDataDist(svgMousePoint.x, widgetWidth, pathWidth, pxPerMX) * factor; // Math.max pour éviter de sortir de l'array

      var distIndex = Math.max(1, this._arrayBisect(sortedDist, mouseDist));
      var d0 = _points[distIndex - 1];
      var d1 = _points[distIndex];
      var d = d0;

      if (mouseDist - d0.dist > d1.dist - mouseDist) {
        d = d1;
      }

      var focusX = this._dataDistToSvgX(d.dist / factor, widgetWidth, pathWidth, pxPerMX);

      var focusY = this._dataZToSvgY(d.z, pathHeight, minGraphZ, pxPerMZ); // Mise à jour des éléments graphiques


      focusCircle.setAttribute("cx", focusX);
      focusCircle.setAttribute("cy", focusY);
      focusLineX.setAttribute("x1", focusX);
      focusLineX.setAttribute("y1", pathHeight);
      focusLineX.setAttribute("x2", focusX);
      focusLineX.setAttribute("y2", 0);
      focusLineY.setAttribute("x1", zLabelWidth + zGradWidth);
      focusLineY.setAttribute("y1", focusY);
      focusLineY.setAttribute("x2", pathWidth + zLabelWidth + zGradWidth);
      focusLineY.setAttribute("y2", focusY);

      className.__updateProfileMarker(self, d); // Mise à jour du tooltip


      var altiSpanTxt = "Altitude : ".concat(d.z.toLocaleString(), " m");
      var slopeSpanTxt = "Pente : ".concat(d.slope, " %");
      var coordsSpanTxt = "(lat : ".concat(d.lat.toLocaleString(), " / lon : ").concat(d.lon.toLocaleString(), ")");
      altiSpan.innerHTML = altiSpanTxt;
      slopeSpan.innerHTML = slopeSpanTxt;
      coordsSpan.innerHTML = coordsSpanTxt;
      var tooltipTextWidth = Math.max(this._getTextWidth(coordsSpanTxt, coordsSpan), this._getTextWidth(altiSpanTxt, altiSpan));
      var toolTipBubbleD;

      if (d.dist > dist * factor / 2) {
        toolTipBubbleD = "M -0.5 -0.5 l -6 6 l 0 16 l -".concat(tooltipTextWidth + 10, " 0 l 0 -44 l ").concat(tooltipTextWidth + 10, " 0 l 0 16 l 6 6");
        tooltipDiv.setAttribute("transform", "translate(".concat(-(tooltipTextWidth / 2 + 12), ",0)")); // IE11 !
      } else if (d.dist <= dist * factor / 2) {
        toolTipBubbleD = "M -0.5 -0.5 l 6 6 l 0 16 l ".concat(tooltipTextWidth + 10, " 0 l 0 -44 l -").concat(tooltipTextWidth + 10, " 0 l 0 16 l -6 6"); // Largeur de la fleche de la bulle du tooltip

        tooltipDiv.setAttribute("transform", "translate(".concat(tooltipTextWidth / 2 + 12, ",0)")); // IE11 !
      }

      tooltipBubble.setAttribute("d", toolTipBubbleD);
      tooltipBubbleShadow.setAttribute("d", toolTipBubbleD);
      tooltipG.setAttribute("transform", "translate(".concat(focusX, ",").concat(focusY, ")")); // IE11 !

      tooltipG.style.transform = "translate(".concat(focusX, "px,").concat(focusY, "px)");
    }.bind(this));
    dynamicsG.appendChild(pathRectangle);
    elevationSvg.appendChild(dynamicsG);
    widgetDiv.appendChild(elevationSvg);
    return container;
  },

  /**
   * Display Profile without graphical rendering (raw service response)
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileRaw: function displayProfileRaw(data, container, context, className) {
    if (!container) {
      return;
    } // on nettoie toujours...


    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }

    var _points = data && data.points ? data.points : {};

    var div = document.createElement("textarea");
    div.id = "profilElevationResults";
    div.rows = 10;
    div.cols = 50;
    div.style.width = "100%";
    div.innerHTML = JSON.stringify(_points, undefined, 4);
    div.addEventListener("mouseover", function (e) {
      className.__customRawProfileMouseOverEvent(context, e);
    }); // TODO
    // for (var i = 0; i < _points.length; i++) {
    //     var point = _points[i];
    //     var divC  = document.createElement("code");
    //     divC.id = "point_" + i;
    //     divC.innerHTML = JSON.stringify(point, undefined, 4);
    //     div.appendChild(divC);
    //     divC.addEventListener("mouseover", function (e) {
    //          className.__customRawProfileMouseOverEvent(context, e);
    //     });
    // }

    container.appendChild(div);
    return container;
  },

  /**
   * Display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileLibD3: function displayProfileLibD3(data, container, context, className) {
    var self = context;

    if (!container) {
      return;
    }

    if (!data) {
      return;
    } // on nettoie toujours...


    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }

    var _points = data.points;

    if (data.distance > 2000) {
      data.unit = "km";

      for (var i = 0; i < _points.length; i++) {
        _points[i].dist /= 1000;
      }
    }

    var _displayProfileOptions = self.options.displayProfileOptions;
    var margin = {
      top: 20,
      right: 20,
      bottom: 30,
      left: 40
    };
    var width = container.clientWidth - margin.left - margin.right;
    var height = container.clientHeight - margin.top - margin.bottom;
    var x = d3.scale.linear().range([0, width]);
    var y = d3.scale.linear().range([height, 0]);
    var xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(5);
    var yAxis = d3.svg.axis().scale(y).orient("left").ticks(5);
    var line = d3.svg.line().interpolate("basis").x(function (d) {
      return x(d.dist);
    }).y(function (d) {
      return y(d.z);
    });
    var area = d3.svg.area().interpolate("basis").x(function (d) {
      return x(d.dist);
    }).y0(height).y1(function (d) {
      return y(d.z);
    });
    var svg = d3.select(container).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var xDomain = d3.extent(_points, function (d) {
      return d.dist;
    });
    x.domain(xDomain);
    var yDomain = [0, d3.max(_points, function (d) {
      return d.z;
    })];
    y.domain(yDomain);
    svg.append("path").datum(_points).attr("class", "area-d3").attr("d", area);
    svg.append("g").attr("class", "x axis-d3").attr("transform", "translate(0," + height + ")").call(xAxis).append("text").attr("y", -15).attr("dy", ".71em").attr("x", width).text("Distance (" + data.unit + ")");
    svg.append("g").attr("class", "y axis-d3").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").text("Altitude (m)");
    svg.append("g").attr("class", "grid-d3 vertical").attr("transform", "translate(0," + height + ")").call(xAxis.orient("bottom").tickSize(-height, 0, 0).tickFormat(""));
    svg.append("g").attr("class", "grid-d3 horizontal").call(yAxis.orient("left").tickSize(-width, 0, 0).tickFormat(""));
    svg.append("path").datum(_points).attr("class", "line-d3").attr("d", line);
    svg.selectAll("circle").data(_points).enter().append("circle").attr("cx", function (d) {
      return x(d.dist);
    }).attr("cy", function (d) {
      return y(d.z);
    }).attr("r", 0).attr("class", "circle-d3");
    var focus = svg.append("g").style("display", "none");
    focus.append("line").attr("id", "focusLineX").attr("class", "focusLine-d3");
    focus.append("line").attr("id", "focusLineY").attr("class", "focusLine-d3");
    focus.append("circle").attr("id", "focusCircle").attr("r", 4).attr("class", "circle-d3 focusCircle-d3");
    var div = d3.select(container).append("div").attr("class", "tooltip-d3").style("opacity", 0);
    var bisectDist = d3.bisector(function (d) {
      return d.dist;
    }).left;
    svg.append("rect").attr("class", "overlay-d3").attr("width", width).attr("height", height).on("mouseover", function () {
      focus.style("display", null);

      className.__createProfileMarker(self, _points[0]);
    }).on("mouseout", function () {
      focus.style("display", "none");

      className.__removeProfileMarker(self); // tooltips


      div.transition().duration(500).style("opacity", 0);
    }).on("mousemove", function () {
      var m = d3.mouse(this);
      var distance = x.invert(m[0]); // Math.max pour éviter de sortir de l'array

      var i = Math.max(1, bisectDist(_points, distance));
      var d0 = _points[i - 1];
      var d1 = _points[i];
      var d = distance - d0[0] > d1[0] - distance ? d1 : d0;
      var xc = x(d.dist);
      var yc = y(d.z);
      focus.select("#focusCircle").attr("cx", xc).attr("cy", yc);
      focus.select("#focusLineX").attr("x1", xc).attr("y1", y(yDomain[0])).attr("x2", xc).attr("y2", y(yDomain[1]));
      focus.select("#focusLineY").attr("x1", x(xDomain[0])).attr("y1", yc).attr("x2", x(xDomain[1])).attr("y2", yc);

      className.__updateProfileMarker(self, d); // tooltips


      div.transition().duration(200).style("opacity", 0.9);
      var _message = "";
      _message += " Altitude : " + d.z + " m";

      if (_displayProfileOptions.currentSlope) {
        _message += "<br/> Pente : " + d.slope + " %";
      }

      _message += "<br/> (Lat : " + d.lat + "/ Lon : " + d.lon + ")";
      div.html(_message).style("left", d3.event.pageX + "px").style("top", d3.event.pageY - 28 + "px");
    }); // return d3.selectAll("rect.overlay")[0][0];

    return svg;
  },

  /**
   * Display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileLibAmCharts: function displayProfileLibAmCharts(data, container, context, className) {
    var self = context;

    if (!container) {
      return;
    }

    if (!data) {
      return;
    }

    var _points = data.points;
    var ballonText = "<span class='altiPathValue'>[[title]] : [[value]]m</span><br/>";
    var currentSlope = self.options.displayProfileOptions.currentSlope;

    if (currentSlope) {
      ballonText += "<span class='altiPathValue'>Pente : [[slope]] %</span><br/>";
    }

    ballonText += "<span class='altiPathCoords'>(Lat: [[lat]] / Lon:[[lon]])</span>";
    AmCharts.addInitHandler(function () {});

    if (data.distance > 2000) {
      data.unit = "km";

      for (var i = 0; i < _points.length; i++) {
        _points[i].dist /= 1000;
      }
    }

    for (var _i3 = 0; _i3 < _points.length; _i3++) {
      var dist = _points[_i3].dist;
      var coeffArrond = 100;

      if (dist > 100) {
        coeffArrond = 1;
      } else if (dist > 10) {
        coeffArrond = 10;
      } // Correction arrondi distance totale


      dist = Math.round(dist * coeffArrond) / coeffArrond;
      _points[_i3].dist = dist;
    }

    var settings = {
      type: "serial",
      pathToImages: "http://cdn.amcharts.com/lib/3/images/",
      categoryField: "dist",
      autoMarginOffset: 0,
      marginRight: 10,
      marginTop: 10,
      startDuration: 0,
      color: "#5E5E5E",
      fontSize: 8,
      theme: "light",
      thousandsSeparator: "",
      numberFormatter: {
        precision: -1,
        decimalSeparator: ",",
        thousandsSeparator: " "
      },
      categoryAxis: {
        color: "#5E5E5E",
        gridPosition: "start",
        minHorizontalGap: 40,
        tickPosition: "start",
        title: "Distance (" + data.unit + ")",
        titleColor: "#5E5E5E",
        labelOffset: 0,
        startOnAxis: true
      },
      chartCursor: {
        animationDuration: 0,
        bulletsEnabled: true,
        bulletSize: 10,
        categoryBalloonEnabled: false,
        cursorColor: "#F90",
        graphBulletAlpha: 1,
        graphBulletSize: 1,
        zoomable: false
      },
      trendLines: [],
      graphs: [{
        balloonColor: "#CCCCCC",
        balloonText: ballonText,
        bullet: "round",
        bulletAlpha: 0,
        bulletBorderColor: "#FFF",
        bulletBorderThickness: 2,
        bulletColor: "#F90",
        bulletSize: 6,
        hidden: false,
        id: "AmGraph-1",
        fillAlphas: 0.4,
        fillColors: "#C77A04",
        lineAlpha: 1,
        lineColor: "#C77A04",
        lineThickness: 1,
        title: "Altitude",
        valueField: "z"
      }],
      guides: [],
      valueAxes: [{
        id: "ValueAxis-1",
        minVerticalGap: 20,
        title: "Altitude (m)"
      }],
      balloon: {
        borderColor: "#CCCCCC",
        borderThickness: 1,
        fillColor: "#FFFFFF",
        showBullet: true
      },
      titles: [],
      allLabels: [],
      dataProvider: _points
    };

    var _containerProfile = AmCharts.makeChart(container, settings);

    _containerProfile.addListener("changed", function (e) {
      var obj = e.chart.dataProvider[e.index];

      className.__updateProfileMarker(self, obj);
    });

    return _containerProfile;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (ProfileElevationPathDOM);

/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureLengthOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureLengthOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Measures_GPmeasureLengthOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(200);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_sphere__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(172);
/* harmony import */ var _Common_Controls_MeasureLengthDOM__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(284);
/* harmony import */ var _MeasureToolBox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(278);
/* harmony import */ var _Measures__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(280);
// import CSS
 // import OpenLayers



 // import local



 // DOM

 // import local with ol dependencies


 // Derived from OpenLayers measure example
// http://openlayers.org/en/latest/examples/measure.html

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("measurelength");
/**
 * @classdesc
 *
 * Length measurement Control. Allows users to draw a path on Openlayers map and have its length computed and displayed.
 *
 * @constructor
 * @alias ol.control.MeasureLength
 * @extends {ol.control.Control}
 * @param {Object} options - options for function call.
 * @param {Boolean} [options.geodesic = true] - If true, length will be computed on the global sphere using the {@link https://openlayers.org/en/latest/apidoc/module-ol_sphere.html#haversineDistance ol.Sphere.haversineDistance()} function. Otherwise, length will be computed on the projected plane.
 * @param {Object} [options.styles = {}] - styles used when drawing. Specified with following properties.
 * @param {Object} [options.styles.pointer = {}] - Style for mouse pointer when drawing the path. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
 * @param {Object} [options.styles.start = {}] - Line Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
 * @param {Object} [options.styles.finish = {}] - Line Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
 * <!-- @param {Object} [options.tooltip = {}] - NOT YET IMPLEMENTED ! -->
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Mesures de distance"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Mes mesures"] - Layer description to be displayed in LayerSwitcher
 * @example
 * var measureLength = new ol.control.MeasureLength({
 *    geodesic : false
 * });
 */

var MeasureLength = function (Control) {
  function MeasureLength(options) {
    // options
    options = options || {};

    if (!(this instanceof MeasureLength)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    } // Nom de la classe (heritage)


    this.CLASSNAME = "MeasureLength"; // uuid

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_6__["default"].generate(); // container d'activation du controle

    this._showContainer = null;
    this._pictoContainer = null; // initialisation du composant

    this._initialize(options); // creation du DOM container


    var container = options.element ? options.element : this._initializeContainer(); // heritage

    Control.call(this, {
      element: container,
      target: options.target,
      render: options.render
    });
  } // heritage avec ol.control.Control


  if (Control) MeasureLength.__proto__ = Control;
  /**
   * @lends module:MeasureLength
   */

  MeasureLength.prototype = Object.create(Control.prototype, {}); // on récupère les mixins de la classe "MeasureLengthDOM" ainsi que celles
  // de "Measures".

  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].assign(MeasureLength.prototype, _Measures__WEBPACK_IMPORTED_MODULE_9__["default"]);
  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].assign(MeasureLength.prototype, _Common_Controls_MeasureLengthDOM__WEBPACK_IMPORTED_MODULE_7__["default"]);
  /**
   * Constructor (alias)
   * @private
   */

  MeasureLength.prototype.constructor = MeasureLength; // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */

  MeasureLength.prototype.setMap = function (map) {
    logger.trace("setMap()");
    var className = this.CLASSNAME; // on fait le choix de ne pas activer les events sur la map à l'init de l'outil,
    // mais uniquement à son utilisation !

    if (map) {
      // var self = this;
      // map.on("click", function (e) {
      //     logger.trace("event on map with click!");
      //     self.onPointerMoveHandler(e);
      // });
      //
      // map.on("singleclick", function (e) {
      //     logger.trace("event on map with singleclick!");
      //     self.onPointerMoveHandler(e);
      // });
      //
      // map.on("pointermove", function (e) {
      //     logger.trace("event on map with pointermove!");
      //     self.onPointerMoveHandler(e);
      // });
      if (!this.options.target) {
        _MeasureToolBox__WEBPACK_IMPORTED_MODULE_8__["default"].add(map, this);
      }
    } else {
      this.clean();
    } // sauvegarde de l'état de l'outil


    this.tools[className].push({
      instance: map ? this : null,
      active: false,
      map: map ? map.getTargetElement().id : null
    }); // contexte d'execution

    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;

    if (context) {
      // Pour info
      // les objets de mesures ont du code partagé
      // (afin de gerer les interactions entre eux).
      // Dans un mode "modules", on partage cet objet (this.tools) via le contexte
      // d'execution (ex. avec window)
      if (!context.gpShareMeasures) {
        context.gpShareMeasures = {};
      }

      context.gpShareMeasures[className] = this.tools[className];
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize measure control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */


  MeasureLength.prototype._initialize = function (options) {
    logger.trace("call MeasureLength::_initialize() : ", options); // liste des options

    this.options = {};
    this.options.geodesic = typeof options.geodesic !== "undefined" ? options.geodesic : true;
    this.options.target = typeof options.target !== "undefined" ? options.target : null;
    this.options.render = typeof options.render !== "undefined" ? options.render : null;
    this.options.layerDescription = typeof options.layerDescription !== "undefined" ? options.layerDescription : {
      title: "Mesures de distance",
      description: "Mes mesures"
    }; // gestion des styles !

    this.createStylingMeasureInteraction(options.styles);
  };
  /**
   * initialize component container (DOM)
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  MeasureLength.prototype._initializeContainer = function () {
    logger.trace("call MeasureLength::_initializeContainer() : ", this._uid);

    var container = this._createMainContainerElement();

    var show = this._showContainer = this._createShowMeasureLengthElement();

    container.appendChild(show); // par defaut, pas d'interaction à l'initialisation...

    this._showContainer.checked = false;

    var picto = this._pictoContainer = this._createShowMeasureLengthPictoElement();

    container.appendChild(picto);
    return container;
  }; // ################################################################### //
  // ########################## methods ################################ //
  // ################################################################### //

  /**
   * Add all events on map
   *
   * @private
   */


  MeasureLength.prototype.addMeasureEvents = function () {
    var _this = this;

    logger.trace("call MeasureLength::addMeasureEvents()");
    var map = this.getMap();
    map.on("singleclick", function (e) {
      return _this.onPointerMoveHandler(e);
    });
    map.on("pointermove", function (e) {
      return _this.onPointerMoveHandler(e);
    });
  };
  /**
   * Remove all events on map
   *
   * @private
   */


  MeasureLength.prototype.removeMeasureEvents = function () {
    var _this2 = this;

    logger.trace("call MeasureLength::removeMeasureEvents()");
    var map = this.getMap();
    map.un("singleclick", function (e) {
      return _this2.onPointerMoveHandle(e);
    });
    map.un("pointermove", function (e) {
      return _this2.onPointerMoveHandler(e);
    });
  };
  /**
   * Format length output.
   *
   * @param {ol.geom.Line} line - geometry line.
   * @return {String} The formatted output.
   * @private
   */


  MeasureLength.prototype.format = function (line) {
    logger.trace("call MeasureLength::format()");
    var map = this.getMap();
    var measure;

    if (this.options.geodesic) {
      var coordinates = line.getCoordinates();
      measure = 0;
      var sourceProj = map.getView().getProjection();

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var c1 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(coordinates[i], sourceProj, "EPSG:4326");
        var c2 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(coordinates[i + 1], sourceProj, "EPSG:4326");
        measure += Object(ol_sphere__WEBPACK_IMPORTED_MODULE_2__["getDistance"])(c1, c2);
      }
    } else {
      measure = Math.round(line.getLength() * 100) / 100;
    }

    var output;

    if (measure > 1000) {
      output = Math.round(measure / 1000 * 100) / 100 + " " + "km";
    } else {
      output = Math.round(measure * 100) / 100 + " " + "m";
    }

    return output;
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on picto
   *
   * @param {Object} e - HTMLElement
   *
   * @private
   */


  MeasureLength.prototype.onShowMeasureLengthClick = function (e) {
    logger.trace("call MeasureLength::onShowMeasureLengthClick()", e); // appel de la methode commune

    this.onShowMeasureClick(e, "LineString");
  };

  return MeasureLength;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (MeasureLength); // Expose MeasureLength as ol.control.MeasureLength (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.MeasureLength = MeasureLength;
}

/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var MeasureLengthDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmeasureLength");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMeasureLengthElement: function _createShowMeasureLengthElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowMeasureLength");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMeasureLengthPictoElement: function _createShowMeasureLengthPictoElement() {
    // contexte d'execution
    var context = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowMeasureLengthPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowMeasureLength");
    label.title = "Mesurer une distance"; // gestionnaire d'evenement :
    // on ouvre le menu de saisie...
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        context.onShowMeasureLengthClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        context.onShowMeasureLengthClick(e);
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowMeasureLengthOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (MeasureLengthDOM);

/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAreaOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAreaOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Measures_GPmeasureAreaOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(200);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_sphere__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(197);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_geom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(172);
/* harmony import */ var _Common_Controls_MeasureAreaDOM__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(286);
/* harmony import */ var _Measures__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(280);
/* harmony import */ var _MeasureToolBox__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(278);
// import CSS
 // import OpenLayers



 // import local



 // DOM

 // import local with ol dependencies


 // Derived from OpenLayers measure example
// http://openlayers.org/en/latest/examples/measure.html

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("measurearea");
/**
 * @classdesc
 *
 * Tool Measure Area Control. Allows users to measure the length of a path drawn on the map.
 *
 * @constructor
 * @alias ol.control.MeasureArea
 * @extends {ol.control.Control}
 * @param {Object} options - options for function call.
 * @param {Boolean} [options.geodesic = true] - If true, area will be computed on the global sphere using the {@link https://openlayers.org/en/latest/apidoc/module-ol_sphere.html#geodesicArea ol.Sphere.geodesicArea()} function. Otherwise, area will be computed on the projected plane.
 * @param {Object} [options.styles = {}] - styles used when drawing. Specified with following properties.
 * @param {Object} [options.styles.pointer = {}] - Style for mouse pointer when drawing the polygon to measure. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
 * @param {Object} [options.styles.start = {}] - Polygon Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
 * @param {Object} [options.styles.finish = {}] - Polygon Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
 * <!-- @param {Object} [options.tooltip = {}] - NOT YET IMPLEMENTED ! -->
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Mesures de surface"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Mes mesures"] - Layer description to be displayed in LayerSwitcher
 * @example
 * var measureArea = new ol.control.MeasureArea({
 *    geodesic : false
 * });
 */

var MeasureArea = function (Control) {
  function MeasureArea(options) {
    /**
     * options
     * @private
     */
    options = options || {};

    if (!(this instanceof MeasureArea)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    /**
     * Nom de la classe (heritage)
     * @private
     */


    this.CLASSNAME = "MeasureArea"; // uuid

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_6__["default"].generate(); // container d'activation du controle

    this._showContainer = null;
    this._pictoContainer = null; // initialisation du composant

    this._initialize(options); // creation du DOM container


    var container = options.element ? options.element : this._initializeContainer(); // heritage

    Control.call(this, {
      element: container,
      target: options.target,
      render: options.render
    });
  } // heritage avec ol.control.Control


  if (Control) MeasureArea.__proto__ = Control;
  /**
   * @lends module:MeasureArea
   */

  MeasureArea.prototype = Object.create(Control.prototype, {}); // on récupère les mixins de la classe "MeasureAreaDOM" ainsi que celles
  // de "Measures".

  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].assign(MeasureArea.prototype, _Measures__WEBPACK_IMPORTED_MODULE_8__["default"]);
  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].assign(MeasureArea.prototype, _Common_Controls_MeasureAreaDOM__WEBPACK_IMPORTED_MODULE_7__["default"]);
  /**
   * Constructor (alias)
   * @private
   */

  MeasureArea.prototype.constructor = MeasureArea; // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */

  MeasureArea.prototype.setMap = function (map) {
    logger.trace("setMap()");
    var className = this.CLASSNAME; // on fait le choix de ne pas activer les events sur la map à l'init de l'outil,
    // mais uniquement à son utilisation !

    if (map) {
      // var self = this;
      // map.on("click", function (e) {
      //     logger.trace("event on map with click!");
      //     self.onPointerMoveHandler(e);
      // });
      //
      // map.on("singleclick", function (e) {
      //     logger.trace("event on map with singleclick!");
      //     self.onPointerMoveHandler(e);
      // });
      //
      // map.on("pointermove", function (e) {
      //     logger.trace("event on map with pointermove!");
      //     self.onPointerMoveHandler(e);
      // });
      if (!this.options.target) {
        _MeasureToolBox__WEBPACK_IMPORTED_MODULE_9__["default"].add(map, this);
      }
    } else {
      this.clean();
    } // sauvegarde de l'état de l'outil


    this.tools[className].push({
      instance: map ? this : null,
      active: false,
      map: map ? map.getTargetElement().id : null
    }); // contexte d'execution

    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;

    if (context) {
      // Pour info
      // les objets de mesures ont du code partagé
      // (afin de gerer les interactions entre eux).
      // Dans un mode "modules", on partage cet objet (this.tools) via le contexte
      // d'execution (ex. avec window)
      if (!context.gpShareMeasures) {
        context.gpShareMeasures = {};
      }

      context.gpShareMeasures[className] = this.tools[className];
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize measure control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */


  MeasureArea.prototype._initialize = function (options) {
    logger.trace("call MeasureArea::_initialize() : ", options); // liste des options

    this.options = {};
    this.options.geodesic = typeof options.geodesic !== "undefined" ? options.geodesic : true;
    this.options.target = typeof options.target !== "undefined" ? options.target : null;
    this.options.render = typeof options.render !== "undefined" ? options.render : null;
    this.options.layerDescription = typeof options.layerDescription !== "undefined" ? options.layerDescription : {
      title: "Mesures de surface",
      description: "Mes mesures"
    }; // gestion des styles !

    this.createStylingMeasureInteraction(options.styles);
  };
  /**
   * initialize component container (DOM)
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  MeasureArea.prototype._initializeContainer = function () {
    logger.trace("call MeasureArea::_initializeContainer() : ", this._uid);

    var container = this._createMainContainerElement();

    ;

    var show = this._showContainer = this._createShowMeasureAreaElement();

    container.appendChild(show); // par defaut, pas d'interaction à l'initialisation...

    this._showContainer.checked = false;

    var picto = this._pictoContainer = this._createShowMeasureAreaPictoElement();

    container.appendChild(picto);
    return container;
  }; // ################################################################### //
  // ##################### overridden methods ########################## //
  // ################################################################### //

  /**
   * Add all events on map
   *
   * @private
   */


  MeasureArea.prototype.addMeasureEvents = function () {
    var _this = this;

    logger.trace("call MeasureArea::addMeasureEvents()");
    var map = this.getMap();
    map.on("singleclick", function (e) {
      return _this.onPointerMoveHandler(e);
    });
    map.on("pointermove", function (e) {
      return _this.onPointerMoveHandler(e);
    });
  };
  /**
   * Remove all events on map
   *
   * @private
   */


  MeasureArea.prototype.removeMeasureEvents = function () {
    var _this2 = this;

    logger.trace("call MeasureArea::removeMeasureEvents()");
    var map = this.getMap();
    map.un("singleclick", function (e) {
      return _this2.onPointerMoveHandler(e);
    });
    map.un("pointermove", function (e) {
      return _this2.onPointerMoveHandler(e);
    });
  };
  /**
   * Format length output.
   *
   * @param {ol.geom.Polygon} polygon - geometry polygon.
   * @return {String} The formatted output.
   * @private
   */


  MeasureArea.prototype.format = function (polygon) {
    logger.trace("call MeasureArea::format()");
    var measure;

    if (this.options.geodesic) {
      var geom = polygon.clone();
      var coordinates = geom.getLinearRing(0).getCoordinates();
      measure = Math.abs(Object(ol_sphere__WEBPACK_IMPORTED_MODULE_2__["getArea"])(new ol_geom__WEBPACK_IMPORTED_MODULE_3__["Polygon"]([coordinates])));
    } else {
      measure = polygon.getArea();
    }

    var output;

    if (measure > 1000000) {
      output = Math.round(measure / 1000000 * 100) / 100 + " " + "km<sup>2</sup>";
    } else if (measure > 100000) {
      output = Math.round(measure / 1000000 * 1000) / 1000 + " " + "km<sup>2</sup>";
    } else if (measure > 1000) {
      output = Math.round(measure / 10) * 10 + " " + "m<sup>2</sup>";
    } else {
      output = Math.round(measure * 100) / 100 + " " + "m<sup>2</sup>";
    }

    return output;
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on picto
   *
   * @param {Object} e - HTMLElement
   *
   * @private
   */


  MeasureArea.prototype.onShowMeasureAreaClick = function (e) {
    logger.trace("call MeasureArea::onShowMeasureAreaClick()", e); // appel de la methode commune

    this.onShowMeasureClick(e, "Polygon");
  };

  return MeasureArea;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (MeasureArea); // Expose MeasureArea as ol.control.MeasureArea (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.MeasureArea = MeasureArea;
}

/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var MeasureAreaDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmeasureArea");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMeasureAreaElement: function _createShowMeasureAreaElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowMeasureArea");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMeasureAreaPictoElement: function _createShowMeasureAreaPictoElement() {
    // contexte d'execution
    var context = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowMeasureAreaPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowMeasureArea");
    label.title = "Mesurer une surface"; // gestionnaire d'evenement :
    // on ouvre le menu de saisie...
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        context.onShowMeasureAreaClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        context.onShowMeasureAreaClick(e);
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowMeasureAreaOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (MeasureAreaDOM);

/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAzimuthOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _CSS_Controls_Measures_GPmeasureAzimuthOpenLayers_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_Measures_GPmeasureAzimuthOpenLayers_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(200);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_sphere__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(166);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(141);
/* harmony import */ var _Common_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(147);
/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(172);
/* harmony import */ var _Common_Controls_MeasureAzimuthDOM__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(288);
/* harmony import */ var _MeasureToolBox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(278);
/* harmony import */ var _Measures__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(280);
// import CSS
 // import OpenLayers



 // import local



 // DOM

 // import local with ol dependencies


 // Derived from OpenLayers measure example
// http://openlayers.org/en/latest/examples/measure.html

var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("measureazimut");
/**
 * @classdesc
 *
 * Azimuth measurement Control. Allows users to draw a line on an Openlayers map and have its angle in decimal degrees clockwise from the geographical north.
 *
 * @constructor
 * @alias ol.control.MeasureAzimuth
 * @extends {ol.control.Control}
 * @param {Object} options - options for function call.
 * @param {Boolean} [options.geodesic = false] - If true, azimuth will be computed on the global sphere. Otherwise, it will be computed on the projected plane.
 * @param {Object} [options.styles = {}] - styles used when drawing. Specified with following properties.
 * @param {Object} [options.styles.pointer = {}] - Style for mouse pointer when drawing the line. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
 * @param {Object} [options.styles.start = {}] - Line Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
 * @param {Object} [options.styles.finish = {}] - Line Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
 * <!-- @param {Object} [options.tooltip = {}] - NOT YET IMPLEMENTED ! -->
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Mesures d'azimuth"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Mes mesures"] - Layer description to be displayed in LayerSwitcher
 * @example
 * var measure = new ol.control.MeasureAzimuth({
 *   geodesic : true
 * });
 */

var MeasureAzimuth = function (Control) {
  function MeasureAzimuth(options) {
    /**
     * options
     * @private
     */
    options = options || {};

    if (!(this instanceof MeasureAzimuth)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    /**
     * Nom de la classe (heritage)
     * @private
     */


    this.CLASSNAME = "MeasureAzimuth"; // uuid

    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_6__["default"].generate(); // container d'activation du controle

    this._showContainer = null;
    this._pictoContainer = null; // initialisation du composant

    this._initialize(options); // creation du DOM container


    var container = options.element ? options.element : this._initializeContainer(); // heritage

    Control.call(this, {
      element: container,
      target: options.target,
      render: options.render
    });
  } // heritage avec ol.control.Control


  if (Control) MeasureAzimuth.__proto__ = Control;
  /**
   * @lends module:MeasureAzimuth
   */

  MeasureAzimuth.prototype = Object.create(Control.prototype, {}); // on récupère les mixins de la classe "MeasureAzimuthDOM" ainsi que celles
  // de "Measures".

  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].assign(MeasureAzimuth.prototype, _Measures__WEBPACK_IMPORTED_MODULE_9__["default"]);
  _Common_Utils__WEBPACK_IMPORTED_MODULE_5__["default"].assign(MeasureAzimuth.prototype, _Common_Controls_MeasureAzimuthDOM__WEBPACK_IMPORTED_MODULE_7__["default"]);
  /**
   * Constructor (alias)
   * @private
   */

  MeasureAzimuth.prototype.constructor = MeasureAzimuth; // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */

  MeasureAzimuth.prototype.setMap = function (map) {
    logger.trace("setMap()");
    var className = this.CLASSNAME; // on fait le choix de ne pas activer les events sur la map à l'init de l'outil,
    // mais uniquement à son utilisation !

    if (map) {
      // var self = this;
      // map.on("click", function (e) {
      //     logger.trace("event on map with click!");
      //     self.onPointerMoveAzimutHandler(e);
      // });
      //
      // map.on("singleclick", function (e) {
      //     logger.trace("event on map with singleclick!");
      //     self.onPointerMoveAzimutHandler(e);
      // });
      //
      // map.on("pointermove", function (e) {
      //     logger.trace("event on map with pointermove!");
      //     self.onPointerMoveAzimutHandler(e);
      // });
      if (!this.options.target) {
        _MeasureToolBox__WEBPACK_IMPORTED_MODULE_8__["default"].add(map, this);
      }
    } else {
      this.clean();
    } // sauvegarde de l'état de l'outil


    this.tools[className].push({
      instance: map ? this : null,
      active: false,
      map: map ? map.getTargetElement().id : null
    }); // contexte d'execution

    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;

    if (context) {
      // Pour info
      // les objets de mesures ont du code partagé
      // (afin de gerer les interactions entre eux).
      // Dans un mode "modules", on partage cet objet (this.tools) via le contexte
      // d'execution (ex. avec window)
      if (!context.gpShareMeasures) {
        context.gpShareMeasures = {};
      }

      context.gpShareMeasures[className] = this.tools[className];
    } // on appelle la méthode setMap originale d'OpenLayers


    Control.prototype.setMap.call(this, map);
  };
  /**
   * Setter for option Geodesic
   *
   * @param {Boolean} value - geodesic value
   */


  MeasureAzimuth.prototype.setGeodesic = function (value) {
    this.options.geodesic = typeof value !== "undefined" ? value : false;
  };
  /**
   * Getter for option Geodesic
   *
   * @return {Boolean} geodesic value
   */


  MeasureAzimuth.prototype.isGeodesic = function () {
    return this.options.geodesic;
  }; // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //

  /**
   * Initialize measure control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */


  MeasureAzimuth.prototype._initialize = function (options) {
    logger.trace("call MeasureAzimuth::_initialize() : ", options); // liste des options

    this.options = {};
    this.options.geodesic = typeof options.geodesic !== "undefined" ? options.geodesic : false;
    this.options.target = typeof options.target !== "undefined" ? options.target : null;
    this.options.render = typeof options.render !== "undefined" ? options.render : null;
    this.options.layerDescription = typeof options.layerDescription !== "undefined" ? options.layerDescription : {
      title: "Mesures d'azimuth",
      description: "Mes mesures"
    }; // gestion des styles !

    this.createStylingMeasureInteraction(options.styles);
  };
  /**
   * initialize component container (DOM)
   *
   * @returns {DOMElement} DOM element
   *
   * @private
   */


  MeasureAzimuth.prototype._initializeContainer = function () {
    logger.trace("call MeasureAzimuth::_initializeContainer() : ", this._uid);

    var container = this._createMainContainerElement();

    ;

    var show = this._showContainer = this._createShowMeasureAzimuthElement();

    container.appendChild(show); // par defaut, pas d'interaction à l'initialisation...

    this._showContainer.checked = false;

    var picto = this._pictoContainer = this._createShowMeasureAzimuthPictoElement();

    container.appendChild(picto);
    return container;
  }; // ################################################################### //
  // ##################### overridden methods ########################## //
  // ################################################################### //

  /**
   * Add all events on map
   *
   * @private
   */


  MeasureAzimuth.prototype.addMeasureEvents = function () {
    var _this = this;

    logger.trace("call MeasureAzimuth::addMeasureEvents()");
    var map = this.getMap();
    map.on("singleclick", function (e) {
      return _this.onPointerMoveAzimutHandler(e);
    });
    map.on("pointermove", function (e) {
      return _this.onPointerMoveAzimutHandler(e);
    });
  };
  /**
   * Remove all events on map
   *
   * @private
   */


  MeasureAzimuth.prototype.removeMeasureEvents = function () {
    var _this2 = this;

    logger.trace("call MeasureAzimuth::removeMeasureEvents()");
    var map = this.getMap();
    map.un("singleclick", function (e) {
      return _this2.onPointerMoveAzimutHandler(e);
    });
    map.un("pointermove", function (e) {
      return _this2.onPointerMoveAzimutHandler(e);
    });
  };
  /**
   * Format length output.
   *
   * @param {ol.geom.LineString} line - geometry line.
   * @return {String} The formatted output.
   * @private
   */


  MeasureAzimuth.prototype.format = function (line) {
    logger.trace("call MeasureAzimuth::format()");
    var map = this.getMap();
    var sourceProj = map.getView().getProjection();
    var c1 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(line.getFirstCoordinate(), sourceProj, "EPSG:4326");
    var c2 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(line.getLastCoordinate(), sourceProj, "EPSG:4326");

    if (!this.options.geodesic) {
      // TODO calcul sur une petite distance (>500m) afin de simuler un cap !
      var lengthGeodesic = Object(ol_sphere__WEBPACK_IMPORTED_MODULE_2__["getDistance"])(c1, c2);
      logger.trace("measure between 2 points with geodesic method", lengthGeodesic);

      if (lengthGeodesic > 500) {
        var fraction = 500.0 / lengthGeodesic;
        logger.trace("%", fraction);
        c2 = Object(ol_proj__WEBPACK_IMPORTED_MODULE_3__["transform"])(line.getCoordinateAt(fraction), sourceProj, "EPSG:4326");
      }
    }

    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var lon1 = degrees2radians * c1[0];
    var lon2 = degrees2radians * c2[0];
    var lat1 = degrees2radians * c1[1];
    var lat2 = degrees2radians * c2[1];
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    var atan = Math.atan2(a, b);
    var azimut = radians2degrees * atan;
    logger.trace("azimut", azimut);

    if (azimut < 0) {
      azimut += 360;
    }

    var output = Math.round(azimut * 100) / 100 + " °";
    return output;
  }; // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //

  /**
   * this method is called by event 'click' on picto
   *
   * @param {Object} e - HTMLElement
   * @private
   */


  MeasureAzimuth.prototype.onShowMeasureAzimuthClick = function (e) {
    logger.trace("call MeasureAzimuth::onShowMeasureAzimuthClick()", e); // appel de la methode commune

    this.onShowMeasureClick(e, "LineString");
  };
  /**
   * Handle pointer click.
   *
   * @param {ol.MapBrowserEvent} e - The event.
   * @private
   */


  MeasureAzimuth.prototype.onPointerMoveAzimutHandler = function (e) {
    this.onPointerMoveHandler(e);

    if (this.sketch) {
      var geom =
      /** @type {ol.geom.LineString} */
      this.sketch.getGeometry();

      if (geom.getCoordinates().length > 2) {
        this.measureDraw.finishDrawing();
      }
    }
  };

  return MeasureAzimuth;
}(ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default.a);

/* harmony default export */ __webpack_exports__["default"] = (MeasureAzimuth); // Expose MeasureAzimuth as ol.control.MeasureAzimuth (for a build bundle)

if (window.ol && window.ol.control) {
  window.ol.control.MeasureAzimuth = MeasureAzimuth;
}

/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var MeasureAzimuthDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },

  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmeasureAzimuth");
    container.className = "GPwidget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //

  /**
   * Hidden checkbox for minimizing/maximizing
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMeasureAzimuthElement: function _createShowMeasureAzimuthElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowMeasureAzimuth");
    input.type = "checkbox";
    return input;
  },

  /**
   * Show control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowMeasureAzimuthPictoElement: function _createShowMeasureAzimuthPictoElement() {
    // contexte d'execution
    var context = this;
    var label = document.createElement("label");
    label.id = this._addUID("GPshowMeasureAzimuthPicto");
    label.className = "GPshowAdvancedToolPicto";
    label.htmlFor = this._addUID("GPshowMeasureAzimuth");
    label.title = "Mesurer un azimut"; // gestionnaire d'evenement :
    // on ouvre le menu de saisie...
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)

    if (label.addEventListener) {
      label.addEventListener("click", function (e) {
        context.onShowMeasureAzimuthClick(e);
      });
    } else if (label.attachEvent) {
      label.attachEvent("onclick", function (e) {
        context.onShowMeasureAzimuthClick(e);
      });
    }

    var spanOpen = document.createElement("span");
    spanOpen.id = this._addUID("GPshowMeasureAzimuthOpen");
    spanOpen.className = "GPshowAdvancedToolOpen";
    label.appendChild(spanOpen);
    return label;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (MeasureAzimuthDOM);

/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);


(function () {
  var scripts = document.getElementsByTagName("script");
  var key = scripts[scripts.length - 1].getAttribute("data-key"); // in case of several keys

  if (key) {
    var splitKeys = key.split(/;|,|\|/);

    if (splitKeys.length > 1) {
      var keys = [];

      for (var i = 0; i < splitKeys.length; i++) {
        keys.push(splitKeys[i]);
      }

      key = keys;
    }
  }

  var url = scripts[scripts.length - 1].getAttribute("data-url");
  var timeout = scripts[scripts.length - 1].getAttribute("data-timeout"); // callback

  var success = function success() {// Pas de messages en mode prod
    // console.log("GetConfig success!");
  }; // callback


  var error = function error(e) {
    throw new Error("Configuration load failed : " + e.message);
  };

  if (!key && !url) {
    // pas de message d'information !
    // console.log("WARNING : parameters missing 'data-key' and 'data-url', the loading of configuration can not be done !");
    return;
  }

  var options = {
    apiKey: key,
    onSuccess: success,
    onFailure: error
  };

  if (url) {
    options.serverUrl = url;
    options.callbackSuffix = "";
  }

  if (timeout) {
    options.timeOut = timeout;
  } // test d'existance de la varibale globale Gp.Config


  if (!geoportal_access_lib__WEBPACK_IMPORTED_MODULE_0__["default"].Config) {
    // appel du service
    geoportal_access_lib__WEBPACK_IMPORTED_MODULE_0__["default"].Services.getConfig(options);
  }
})();

/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CRS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);

/**
 * Autoload function that loads defs into proj4
 * and adds proj4 defs into ol.
 */

(function () {
  // if you want to load all defs into proj4
  // you can call :
  //   inside code, CRS.load()
  // or
  //   outside code, Gp.olExtended.includeProjections()
  // but you can call only once...
  // load default defs into proj4
  _CRS__WEBPACK_IMPORTED_MODULE_0__["default"].loadByDefault(); // and register defs into openlayers

  _CRS__WEBPACK_IMPORTED_MODULE_0__["default"].overload();
})();

/***/ })
/******/ ]);