(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("itowns", [], factory);
	else if(typeof exports === 'object')
		exports["itowns"] = factory();
	else
		root["itowns"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp_name_"];
/******/ 	window["webpackJsonp_name_"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		1:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + "." + ({"0":"debug"}[chunkId]||chunkId) + ".js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(316);
	__webpack_require__(319);
	__webpack_require__(320);
	module.exports = __webpack_require__(321);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(2);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _chart = __webpack_require__(59);
	
	var _chart2 = _interopRequireDefault(_chart);
	
	var _Coordinates = __webpack_require__(217);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	var _OBBHelper = __webpack_require__(230);
	
	var _OBBHelper2 = _interopRequireDefault(_OBBHelper);
	
	var _View = __webpack_require__(235);
	
	var _View2 = _interopRequireDefault(_View);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Create a debug instance attached to an itowns instance
	 *
	 * @Constructor
	 * @param {Scene} scene the itowns Scene
	 * @return {Debug} a debug instance
	 */
	// disabling eslint errors as it is the exported constructor
	/* global menuGlobe */
	function Debug(view, viewerDiv) {
	    // CHARTS
	    // create charts div
	    var chartDiv = document.createElement('div');
	    chartDiv.id = 'chart-div';
	    chartDiv.style = 'position: absolute; bottom: 0; left: 0; width: 100vw; height: 20rem; background-color: white; display: none';
	
	    viewerDiv.appendChild(chartDiv);
	
	    var leftChart = document.createElement('div');
	    leftChart.id = 'chart-div-left';
	    leftChart.style = 'position: absolute; bottom: 0; left: 0; width: 50vw; height: 20rem; background-color: white; display: flex';
	    chartDiv.appendChild(leftChart);
	    var rightChart = document.createElement('div');
	    rightChart.id = 'chart-div-right';
	    rightChart.style = 'position: absolute; bottom: 0; left: 50vw; width: 50vw; height: 20rem; background-color: white; display: flex';
	    chartDiv.appendChild(rightChart);
	
	    // line graph for nb elements
	    var viewChartCanvas = document.createElement('canvas');
	    viewChartCanvas.heigth = '20rem';
	    viewChartCanvas.width = '50vw';
	    viewChartCanvas.id = 'nb-objects';
	    leftChart.appendChild(viewChartCanvas);
	
	    // bar graph for nb visible elements
	    var nbVisibleCanvas = document.createElement('canvas');
	    nbVisibleCanvas.heigth = '20rem';
	    nbVisibleCanvas.width = '50vw';
	    nbVisibleCanvas.id = 'nb-visible';
	    rightChart.appendChild(nbVisibleCanvas);
	
	    var timestamp = Date.now();
	    var viewLevelStartDataset = { label: 'Update 1st level', data: [{ x: 0, y: 0 }] };
	    var viewUpdateDurationDataset = { label: 'Update duration (ms)', data: [{ x: 0, y: 0 }], borderColor: 'rgba(75,192,192,1)' };
	    var viewInfoChartLabel = ['0s'];
	    var nbObjectsChart = new _chart2.default('nb-objects', {
	        type: 'line',
	        data: {
	            labels: viewInfoChartLabel,
	            datasets: [viewLevelStartDataset, viewUpdateDurationDataset]
	        },
	        options: {
	            animation: { duration: 10 },
	            scales: {
	                yAxes: [{
	                    display: true,
	                    ticks: {
	                        suggestedMin: 0 }
	                }]
	            }
	        }
	    });
	    var nbVisibleLabels = [];
	    var nbVisibleData = [];
	    var nbDisplayedData = [];
	    var nbVisibleChart = new _chart2.default('nb-visible', {
	        type: 'bar',
	        data: {
	            labels: nbVisibleLabels,
	            datasets: [{
	                label: 'Visible node per level',
	                data: nbVisibleData,
	                backgroundColor: 'rgba(75, 192, 192, 1)'
	            }, {
	                label: 'Diplayed node per level',
	                data: nbDisplayedData,
	                backgroundColor: 'rgba(153, 102, 255, 1)'
	            }]
	        },
	        options: {
	            scales: {
	                yAxes: [{
	                    display: true,
	                    ticks: {
	                        suggestedMin: 0 }
	                }]
	            }
	        }
	    });
	
	    function debugChartUpdate(updateStartLevel, updateDuration) {
	        function countVisible(node, stats) {
	            if (!node || !node.visible) {
	                return;
	            }
	            if (node.level) {
	                if (stats[node.level]) {
	                    stats[node.level][0] += 1;
	                } else {
	                    stats[node.level] = [1, 0];
	                }
	                if (node.material.visible) {
	                    stats[node.level][1] += 1;
	                }
	            }
	            if (node.children) {
	                var _iteratorNormalCompletion = true;
	                var _didIteratorError = false;
	                var _iteratorError = undefined;
	
	                try {
	                    for (var _iterator = (0, _getIterator3.default)(node.children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                        var child = _step.value;
	
	                        countVisible(child, stats);
	                    }
	                } catch (err) {
	                    _didIteratorError = true;
	                    _iteratorError = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion && _iterator.return) {
	                            _iterator.return();
	                        }
	                    } finally {
	                        if (_didIteratorError) {
	                            throw _iteratorError;
	                        }
	                    }
	                }
	            }
	        }
	
	        // update bar graph
	        var stats = {};
	        countVisible(view.scene, stats);
	        nbVisibleLabels.length = 0;
	        nbVisibleData.length = 0;
	        for (var level in stats) {
	            if ({}.hasOwnProperty.call(stats, level)) {
	                nbVisibleLabels[level - 1] = '' + level;
	                nbVisibleData[level - 1] = stats[level][0];
	                nbDisplayedData[level - 1] = stats[level][1];
	            }
	        }
	
	        // update line graph
	        // update time
	        var limit = 60;
	        var timeInS = Math.floor((Date.now() - timestamp) / 1000);
	        var lbl = timeInS + 's';
	        var identical = viewInfoChartLabel.lastValidCompareIndex > 0 && viewInfoChartLabel[viewInfoChartLabel.lastValidCompareIndex] == lbl;
	        if (identical) {
	            viewInfoChartLabel.push('');
	        } else {
	            viewInfoChartLabel.push(lbl);
	            viewInfoChartLabel.lastValidCompareIndex = viewInfoChartLabel.length - 1;
	        }
	
	        if (viewInfoChartLabel.length > limit) {
	            viewInfoChartLabel.shift();
	            viewInfoChartLabel.lastValidCompareIndex--;
	        }
	
	        viewLevelStartDataset.data.push({ x: timeInS, y: updateStartLevel });
	        viewUpdateDurationDataset.data.push({ x: timeInS, y: updateDuration });
	        if (viewLevelStartDataset.data.length > limit) {
	            viewLevelStartDataset.data.shift();
	            viewUpdateDurationDataset.data.shift();
	        }
	
	        if (chartDiv.style.display != 'none') {
	            nbObjectsChart.update();
	            nbVisibleChart.update();
	        }
	    }
	
	    // DEBUG CONTROLS
	    var gui = menuGlobe.gui.addFolder('Debug Tools');
	
	    var state = {
	        showOutline: false,
	        wireframe: false,
	        displayCharts: false,
	        eventsDebug: false
	    };
	
	    // charts
	    gui.add(state, 'displayCharts').name('Display charts').onChange(function (newValue) {
	        if (newValue) {
	            chartDiv.style.display = 'flex';
	        } else {
	            chartDiv.style.display = 'none';
	        }
	    });
	
	    function applyToNodeFirstMaterial(cb) {
	        view.scene.traverse(function (object) {
	            if (object.materials) {
	                cb(object.materials[0]);
	            }
	        });
	        view.notifyChange();
	    }
	
	    // tiles outline
	    gui.add(state, 'showOutline').name('Show tiles outline').onChange(function (newValue) {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	            for (var _iterator2 = (0, _getIterator3.default)(view._layers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                var geometryLayer = _step2.value;
	
	                geometryLayer.showOutline = newValue;
	            }
	        } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                    _iterator2.return();
	                }
	            } finally {
	                if (_didIteratorError2) {
	                    throw _iteratorError2;
	                }
	            }
	        }
	
	        applyToNodeFirstMaterial(function (material) {
	            material.uniforms.showOutline = { value: newValue };
	            material.needsUpdate = true;
	        });
	        view.notifyChange(0, true);
	    });
	
	    // tiles wireframe
	    gui.add(state, 'wireframe').name('Wireframe').onChange(function (newValue) {
	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;
	
	        try {
	            for (var _iterator3 = (0, _getIterator3.default)(view._layers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                var geometryLayer = _step3.value;
	
	                geometryLayer.wireframe = newValue;
	            }
	        } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                    _iterator3.return();
	                }
	            } finally {
	                if (_didIteratorError3) {
	                    throw _iteratorError3;
	                }
	            }
	        }
	
	        applyToNodeFirstMaterial(function (material) {
	            material.wireframe = newValue;
	        });
	        view.notifyChange(0, true);
	    });
	
	    gui.add(state, 'eventsDebug').name('Debug event').onChange(function () {
	        var eventFolder = void 0;
	        return function (newValue) {
	            var controls = view.controls;
	            var listeners = [];
	            if (newValue) {
	                (function () {
	                    eventFolder = gui.addFolder('Events');
	
	                    // camera-target-updated event
	                    var initialPosition = new _Coordinates2.default(view.referenceCrs, controls.getCameraTargetPosition()).as('EPSG:4326');
	                    var roundedLat = Math.round(initialPosition.latitude() * 10000) / 10000;
	                    var roundedLon = Math.round(initialPosition.longitude() * 10000) / 10000;
	                    state.cameraTargetUpdated = 'lat: ' + roundedLat + ' lon: ' + roundedLon;
	                    var cameraTargetUpdatedController = eventFolder.add(state, 'cameraTargetUpdated').name('camera-target-changed');
	                    var cameraTargetListener = function cameraTargetListener(ev) {
	                        var positionGeo = ev.new.cameraTarget.as('EPSG:4326');
	                        var roundedLat = Math.round(positionGeo.latitude() * 10000) / 10000;
	                        var roundedLon = Math.round(positionGeo.longitude() * 10000) / 10000;
	                        state.cameraTargetUpdated = 'lat: ' + roundedLat + ' lon: ' + roundedLon;
	                        cameraTargetUpdatedController.updateDisplay();
	                    };
	                    controls.addEventListener('camera-target-changed', cameraTargetListener);
	                    listeners.push({ type: 'camera-target-changed', stateName: 'cameraTargetUpdated', fn: cameraTargetListener });
	                })();
	            } else {
	                var _iteratorNormalCompletion4 = true;
	                var _didIteratorError4 = false;
	                var _iteratorError4 = undefined;
	
	                try {
	                    for (var _iterator4 = (0, _getIterator3.default)(listeners), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                        var listener = _step4.value;
	
	                        controls.removeEventListener(listener.type, listener.fn);
	                        delete state[listener.stateName];
	                    }
	                } catch (err) {
	                    _didIteratorError4 = true;
	                    _iteratorError4 = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                            _iterator4.return();
	                        }
	                    } finally {
	                        if (_didIteratorError4) {
	                            throw _iteratorError4;
	                        }
	                    }
	                }
	
	                gui.removeFolder('Events');
	            }
	        };
	    }());
	
	    // hook that to scene.update
	    var ml = view.mainLoop;
	    var oldUpdate = (0, _getPrototypeOf2.default)(ml)._update.bind(ml);
	    ml._update = function debugUpdate(view) {
	        // regular itowns update
	        var before = Date.now();
	
	        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	        }
	
	        oldUpdate.apply(undefined, [view].concat(args));
	        var duration = Date.now() - before;
	        // debug graphs update
	        debugChartUpdate(view._latestUpdateStartingLevel, duration);
	
	        // obb layer update
	        var _iteratorNormalCompletion5 = true;
	        var _didIteratorError5 = false;
	        var _iteratorError5 = undefined;
	
	        try {
	            var _loop = function _loop() {
	                var gLayer = _step5.value;
	
	                var obbLayerAlreadyAdded = view.getLayers(function (a, l) {
	                    return l && l.id == gLayer.id && a.id.indexOf('_obb_debug') >= 0;
	                }).length > 0;
	
	                // missing obb layer -> add it
	                if (!obbLayerAlreadyAdded) {
	                    addGeometryLayerDebugFeatures(gLayer, view, gui, state);
	                }
	            };
	
	            for (var _iterator5 = (0, _getIterator3.default)(view._layers), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	                _loop();
	            }
	        } catch (err) {
	            _didIteratorError5 = true;
	            _iteratorError5 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                    _iterator5.return();
	                }
	            } finally {
	                if (_didIteratorError5) {
	                    throw _iteratorError5;
	                }
	            }
	        }
	    };
	}
	
	function addGeometryLayerDebugFeatures(layer, view, gui, state) {
	    var obb_layer_id = layer.id + '_obb_debug';
	
	    // itowns layer definition
	    var debugIdUpdate = function debugIdUpdate(context, layer, node) {
	        var enabled = view.camera.camera3D.layers.test({ mask: 1 << layer.threejsLayer });
	
	        if (!enabled) {
	            return;
	        }
	        var n = node.children.filter(function (n) {
	            return n.layer == obb_layer_id;
	        });
	
	        if (node.material.visible) {
	            if (n.length == 0) {
	                var l = context.view.getLayers(function (l) {
	                    return l.id === obb_layer_id;
	                })[0];
	                var helper = new _OBBHelper2.default(node.OBB(), 'id:' + node.id);
	                helper.layer = obb_layer_id;
	                var l3js = l.threejsLayer;
	                helper.layers.set(l3js);
	                helper.children[0].layers.set(l3js);
	                node.add(helper);
	                helper.updateMatrixWorld(true);
	
	                n = helper;
	            } else {
	                n = n[0];
	            }
	
	            n.setMaterialVisibility(true);
	            n.update(node.OBB());
	        } else if (n.length > 0) {
	            n[0].setMaterialVisibility(false);
	        }
	    };
	    var debugLayer = {
	        id: obb_layer_id,
	        type: 'debug',
	        update: debugIdUpdate,
	        visible: false
	    };
	
	    debugLayer = _View2.default.prototype.addLayer.call(view, debugLayer, layer);
	
	    // add to debug gui
	    var folder = gui.addFolder('Geometry Layer: ' + layer.id);
	
	    var enabled = view.camera.camera3D.layers.test({ mask: 1 << layer.threejsLayer });
	    state[layer.id] = enabled;
	
	    folder.add(state, layer.id).name('Visible').onChange(function (newValue) {
	        layer.visible = newValue;
	        view.notifyChange(0, true);
	    });
	
	    state[debugLayer.id] = false;
	    folder.add(state, debugLayer.id).name('OBB visible').onChange(function (newValue) {
	        debugLayer.visible = newValue;
	        view.notifyChange(0, true);
	    });
	
	    var consistencyCheck = { click: function click() {
	            var imageryLayers = view.getLayers(function (a) {
	                return a.type == 'color';
	            });
	            var _iteratorNormalCompletion6 = true;
	            var _didIteratorError6 = false;
	            var _iteratorError6 = undefined;
	
	            try {
	                for (var _iterator6 = (0, _getIterator3.default)(layer.level0Nodes), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	                    var node = _step6.value;
	
	                    node.traverse(function (n) {
	                        if (n.materials && n.materials[0].visible) {
	                            n.materials[0].checkLayersConsistency(n, imageryLayers);
	                        }
	                    });
	                }
	            } catch (err) {
	                _didIteratorError6 = true;
	                _iteratorError6 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                        _iterator6.return();
	                    }
	                } finally {
	                    if (_didIteratorError6) {
	                        throw _iteratorError6;
	                    }
	                }
	            }
	        } };
	    folder.add(consistencyCheck, 'click').name('Check textures');
	}
	
	exports.default = Debug;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(3), __esModule: true };

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	module.exports = __webpack_require__(15).Object.getPrototypeOf;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(5)
	  , $getPrototypeOf = __webpack_require__(7);
	
	__webpack_require__(13)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(6);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(8)
	  , toObject    = __webpack_require__(5)
	  , IE_PROTO    = __webpack_require__(9)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 8 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(10)('keys')
	  , uid    = __webpack_require__(12);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 11 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 12 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(14)
	  , core    = __webpack_require__(15)
	  , fails   = __webpack_require__(24);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(11)
	  , core      = __webpack_require__(15)
	  , ctx       = __webpack_require__(16)
	  , hide      = __webpack_require__(18)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 15 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(17);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(19)
	  , createDesc = __webpack_require__(27);
	module.exports = __webpack_require__(23) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(20)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , toPrimitive    = __webpack_require__(26)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(23) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(23) && !__webpack_require__(24)(function(){
	  return Object.defineProperty(__webpack_require__(25)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(24)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21)
	  , document = __webpack_require__(11).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(21);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(29), __esModule: true };

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(30);
	__webpack_require__(54);
	module.exports = __webpack_require__(56);

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(31);
	var global        = __webpack_require__(11)
	  , hide          = __webpack_require__(18)
	  , Iterators     = __webpack_require__(34)
	  , TO_STRING_TAG = __webpack_require__(53)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(32)
	  , step             = __webpack_require__(33)
	  , Iterators        = __webpack_require__(34)
	  , toIObject        = __webpack_require__(35);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(38)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(36)
	  , defined = __webpack_require__(6);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(37);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(39)
	  , $export        = __webpack_require__(14)
	  , redefine       = __webpack_require__(40)
	  , hide           = __webpack_require__(18)
	  , has            = __webpack_require__(8)
	  , Iterators      = __webpack_require__(34)
	  , $iterCreate    = __webpack_require__(41)
	  , setToStringTag = __webpack_require__(52)
	  , getPrototypeOf = __webpack_require__(7)
	  , ITERATOR       = __webpack_require__(53)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(18);

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(42)
	  , descriptor     = __webpack_require__(27)
	  , setToStringTag = __webpack_require__(52)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(18)(IteratorPrototype, __webpack_require__(53)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(20)
	  , dPs         = __webpack_require__(43)
	  , enumBugKeys = __webpack_require__(50)
	  , IE_PROTO    = __webpack_require__(9)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(25)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(51).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(19)
	  , anObject = __webpack_require__(20)
	  , getKeys  = __webpack_require__(44);
	
	module.exports = __webpack_require__(23) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(45)
	  , enumBugKeys = __webpack_require__(50);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(8)
	  , toIObject    = __webpack_require__(35)
	  , arrayIndexOf = __webpack_require__(46)(false)
	  , IE_PROTO     = __webpack_require__(9)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(35)
	  , toLength  = __webpack_require__(47)
	  , toIndex   = __webpack_require__(49);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(48)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 48 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(48)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 50 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11).document && document.documentElement;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(19).f
	  , has = __webpack_require__(8)
	  , TAG = __webpack_require__(53)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(10)('wks')
	  , uid        = __webpack_require__(12)
	  , Symbol     = __webpack_require__(11).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(55)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(38)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(48)
	  , defined   = __webpack_require__(6);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(20)
	  , get      = __webpack_require__(57);
	module.exports = __webpack_require__(15).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(58)
	  , ITERATOR  = __webpack_require__(53)('iterator')
	  , Iterators = __webpack_require__(34);
	module.exports = __webpack_require__(15).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(37)
	  , TAG = __webpack_require__(53)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @namespace Chart
	 */
	var Chart = __webpack_require__(60)();
	
	__webpack_require__(61)(Chart);
	__webpack_require__(67)(Chart);
	__webpack_require__(69)(Chart);
	__webpack_require__(70)(Chart);
	__webpack_require__(71)(Chart);
	__webpack_require__(72)(Chart);
	__webpack_require__(73)(Chart);
	__webpack_require__(74)(Chart);
	__webpack_require__(75)(Chart);
	__webpack_require__(76)(Chart);
	__webpack_require__(77)(Chart);
	__webpack_require__(78)(Chart);
	__webpack_require__(79)(Chart);
	__webpack_require__(80)(Chart);
	__webpack_require__(81)(Chart);
	__webpack_require__(82)(Chart);
	
	__webpack_require__(83)(Chart);
	__webpack_require__(84)(Chart);
	__webpack_require__(85)(Chart);
	__webpack_require__(86)(Chart);
	
	__webpack_require__(87)(Chart);
	__webpack_require__(88)(Chart);
	__webpack_require__(89)(Chart);
	__webpack_require__(90)(Chart);
	__webpack_require__(91)(Chart);
	__webpack_require__(92)(Chart);
	
	// Controllers must be loaded after elements
	// See Chart.core.datasetController.dataElementType
	__webpack_require__(204)(Chart);
	__webpack_require__(205)(Chart);
	__webpack_require__(206)(Chart);
	__webpack_require__(207)(Chart);
	__webpack_require__(208)(Chart);
	__webpack_require__(209)(Chart);
	
	__webpack_require__(210)(Chart);
	__webpack_require__(211)(Chart);
	__webpack_require__(212)(Chart);
	__webpack_require__(213)(Chart);
	__webpack_require__(214)(Chart);
	__webpack_require__(215)(Chart);
	__webpack_require__(216)(Chart);
	
	window.Chart = module.exports = Chart;


/***/ },
/* 60 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function() {
	
		// Occupy the global variable of Chart, and create a simple base class
		var Chart = function(item, config) {
			this.controller = new Chart.Controller(item, config, this);
			return this.controller;
		};
	
		// Globally expose the defaults to allow for user updating/changing
		Chart.defaults = {
			global: {
				responsive: true,
				responsiveAnimationDuration: 0,
				maintainAspectRatio: true,
				events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
				hover: {
					onHover: null,
					mode: 'nearest',
					intersect: true,
					animationDuration: 400
				},
				onClick: null,
				defaultColor: 'rgba(0,0,0,0.1)',
				defaultFontColor: '#666',
				defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
				defaultFontSize: 12,
				defaultFontStyle: 'normal',
				showLines: true,
	
				// Element defaults defined in element extensions
				elements: {},
	
				// Legend callback string
				legendCallback: function(chart) {
					var text = [];
					text.push('<ul class="' + chart.id + '-legend">');
					for (var i = 0; i < chart.data.datasets.length; i++) {
						text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
						if (chart.data.datasets[i].label) {
							text.push(chart.data.datasets[i].label);
						}
						text.push('</li>');
					}
					text.push('</ul>');
	
					return text.join('');
				}
			}
		};
	
		Chart.Chart = Chart;
	
		return Chart;
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* global window: false */
	/* global document: false */
	'use strict';
	
	var color = __webpack_require__(62);
	
	module.exports = function(Chart) {
		// Global Chart helpers object for utility methods and classes
		var helpers = Chart.helpers = {};
	
		// -- Basic js utility methods
		helpers.each = function(loopable, callback, self, reverse) {
			// Check to see if null or undefined firstly.
			var i, len;
			if (helpers.isArray(loopable)) {
				len = loopable.length;
				if (reverse) {
					for (i = len - 1; i >= 0; i--) {
						callback.call(self, loopable[i], i);
					}
				} else {
					for (i = 0; i < len; i++) {
						callback.call(self, loopable[i], i);
					}
				}
			} else if (typeof loopable === 'object') {
				var keys = Object.keys(loopable);
				len = keys.length;
				for (i = 0; i < len; i++) {
					callback.call(self, loopable[keys[i]], keys[i]);
				}
			}
		};
		helpers.clone = function(obj) {
			var objClone = {};
			helpers.each(obj, function(value, key) {
				if (helpers.isArray(value)) {
					objClone[key] = value.slice(0);
				} else if (typeof value === 'object' && value !== null) {
					objClone[key] = helpers.clone(value);
				} else {
					objClone[key] = value;
				}
			});
			return objClone;
		};
		helpers.extend = function(base) {
			var setFn = function(value, key) {
				base[key] = value;
			};
			for (var i = 1, ilen = arguments.length; i < ilen; i++) {
				helpers.each(arguments[i], setFn);
			}
			return base;
		};
		// Need a special merge function to chart configs since they are now grouped
		helpers.configMerge = function(_base) {
			var base = helpers.clone(_base);
			helpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {
				helpers.each(extension, function(value, key) {
					var baseHasProperty = base.hasOwnProperty(key);
					var baseVal = baseHasProperty ? base[key] : {};
	
					if (key === 'scales') {
						// Scale config merging is complex. Add our own function here for that
						base[key] = helpers.scaleMerge(baseVal, value);
					} else if (key === 'scale') {
						// Used in polar area & radar charts since there is only one scale
						base[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);
					} else if (baseHasProperty
							&& typeof baseVal === 'object'
							&& !helpers.isArray(baseVal)
							&& baseVal !== null
							&& typeof value === 'object'
							&& !helpers.isArray(value)) {
						// If we are overwriting an object with an object, do a merge of the properties.
						base[key] = helpers.configMerge(baseVal, value);
					} else {
						// can just overwrite the value in this case
						base[key] = value;
					}
				});
			});
	
			return base;
		};
		helpers.scaleMerge = function(_base, extension) {
			var base = helpers.clone(_base);
	
			helpers.each(extension, function(value, key) {
				if (key === 'xAxes' || key === 'yAxes') {
					// These properties are arrays of items
					if (base.hasOwnProperty(key)) {
						helpers.each(value, function(valueObj, index) {
							var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
							var axisDefaults = Chart.scaleService.getScaleDefaults(axisType);
							if (index >= base[key].length || !base[key][index].type) {
								base[key].push(helpers.configMerge(axisDefaults, valueObj));
							} else if (valueObj.type && valueObj.type !== base[key][index].type) {
								// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults
								base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);
							} else {
								// Type is the same
								base[key][index] = helpers.configMerge(base[key][index], valueObj);
							}
						});
					} else {
						base[key] = [];
						helpers.each(value, function(valueObj) {
							var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
							base[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));
						});
					}
				} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {
					// If we are overwriting an object with an object, do a merge of the properties.
					base[key] = helpers.configMerge(base[key], value);
	
				} else {
					// can just overwrite the value in this case
					base[key] = value;
				}
			});
	
			return base;
		};
		helpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {
			if (value === undefined || value === null) {
				return defaultValue;
			}
	
			if (helpers.isArray(value)) {
				return index < value.length ? value[index] : defaultValue;
			}
	
			return value;
		};
		helpers.getValueOrDefault = function(value, defaultValue) {
			return value === undefined ? defaultValue : value;
		};
		helpers.indexOf = Array.prototype.indexOf?
			function(array, item) {
				return array.indexOf(item);
			}:
			function(array, item) {
				for (var i = 0, ilen = array.length; i < ilen; ++i) {
					if (array[i] === item) {
						return i;
					}
				}
				return -1;
			};
		helpers.where = function(collection, filterCallback) {
			if (helpers.isArray(collection) && Array.prototype.filter) {
				return collection.filter(filterCallback);
			}
			var filtered = [];
	
			helpers.each(collection, function(item) {
				if (filterCallback(item)) {
					filtered.push(item);
				}
			});
	
			return filtered;
		};
		helpers.findIndex = Array.prototype.findIndex?
			function(array, callback, scope) {
				return array.findIndex(callback, scope);
			} :
			function(array, callback, scope) {
				scope = scope === undefined? array : scope;
				for (var i = 0, ilen = array.length; i < ilen; ++i) {
					if (callback.call(scope, array[i], i, array)) {
						return i;
					}
				}
				return -1;
			};
		helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
			// Default to start of the array
			if (startIndex === undefined || startIndex === null) {
				startIndex = -1;
			}
			for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};
		helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
			// Default to end of the array
			if (startIndex === undefined || startIndex === null) {
				startIndex = arrayToSearch.length;
			}
			for (var i = startIndex - 1; i >= 0; i--) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};
		helpers.inherits = function(extensions) {
			// Basic javascript inheritance based on the model created in Backbone.js
			var me = this;
			var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
				return me.apply(this, arguments);
			};
	
			var Surrogate = function() {
				this.constructor = ChartElement;
			};
			Surrogate.prototype = me.prototype;
			ChartElement.prototype = new Surrogate();
	
			ChartElement.extend = helpers.inherits;
	
			if (extensions) {
				helpers.extend(ChartElement.prototype, extensions);
			}
	
			ChartElement.__super__ = me.prototype;
	
			return ChartElement;
		};
		helpers.noop = function() {};
		helpers.uid = (function() {
			var id = 0;
			return function() {
				return id++;
			};
		}());
		// -- Math methods
		helpers.isNumber = function(n) {
			return !isNaN(parseFloat(n)) && isFinite(n);
		};
		helpers.almostEquals = function(x, y, epsilon) {
			return Math.abs(x - y) < epsilon;
		};
		helpers.almostWhole = function(x, epsilon) {
			var rounded = Math.round(x);
			return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
		};
		helpers.max = function(array) {
			return array.reduce(function(max, value) {
				if (!isNaN(value)) {
					return Math.max(max, value);
				}
				return max;
			}, Number.NEGATIVE_INFINITY);
		};
		helpers.min = function(array) {
			return array.reduce(function(min, value) {
				if (!isNaN(value)) {
					return Math.min(min, value);
				}
				return min;
			}, Number.POSITIVE_INFINITY);
		};
		helpers.sign = Math.sign?
			function(x) {
				return Math.sign(x);
			} :
			function(x) {
				x = +x; // convert to a number
				if (x === 0 || isNaN(x)) {
					return x;
				}
				return x > 0 ? 1 : -1;
			};
		helpers.log10 = Math.log10?
			function(x) {
				return Math.log10(x);
			} :
			function(x) {
				return Math.log(x) / Math.LN10;
			};
		helpers.toRadians = function(degrees) {
			return degrees * (Math.PI / 180);
		};
		helpers.toDegrees = function(radians) {
			return radians * (180 / Math.PI);
		};
		// Gets the angle from vertical upright to the point about a centre.
		helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
			var distanceFromXCenter = anglePoint.x - centrePoint.x,
				distanceFromYCenter = anglePoint.y - centrePoint.y,
				radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
	
			var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
	
			if (angle < (-0.5 * Math.PI)) {
				angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
			}
	
			return {
				angle: angle,
				distance: radialDistanceFromCenter
			};
		};
		helpers.distanceBetweenPoints = function(pt1, pt2) {
			return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
		};
		helpers.aliasPixel = function(pixelWidth) {
			return (pixelWidth % 2 === 0) ? 0 : 0.5;
		};
		helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
			// Props to Rob Spencer at scaled innovation for his post on splining between points
			// http://scaledinnovation.com/analytics/splines/aboutSplines.html
	
			// This function must also respect "skipped" points
	
			var previous = firstPoint.skip ? middlePoint : firstPoint,
				current = middlePoint,
				next = afterPoint.skip ? middlePoint : afterPoint;
	
			var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
			var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
	
			var s01 = d01 / (d01 + d12);
			var s12 = d12 / (d01 + d12);
	
			// If all points are the same, s01 & s02 will be inf
			s01 = isNaN(s01) ? 0 : s01;
			s12 = isNaN(s12) ? 0 : s12;
	
			var fa = t * s01; // scaling factor for triangle Ta
			var fb = t * s12;
	
			return {
				previous: {
					x: current.x - fa * (next.x - previous.x),
					y: current.y - fa * (next.y - previous.y)
				},
				next: {
					x: current.x + fb * (next.x - previous.x),
					y: current.y + fb * (next.y - previous.y)
				}
			};
		};
		helpers.EPSILON = Number.EPSILON || 1e-14;
		helpers.splineCurveMonotone = function(points) {
			// This function calculates Bzier control points in a similar way than |splineCurve|,
			// but preserves monotonicity of the provided data and ensures no local extremums are added
			// between the dataset discrete points due to the interpolation.
			// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
	
			var pointsWithTangents = (points || []).map(function(point) {
				return {
					model: point._model,
					deltaK: 0,
					mK: 0
				};
			});
	
			// Calculate slopes (deltaK) and initialize tangents (mK)
			var pointsLen = pointsWithTangents.length;
			var i, pointBefore, pointCurrent, pointAfter;
			for (i = 0; i < pointsLen; ++i) {
				pointCurrent = pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}
	
				pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
				pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointAfter && !pointAfter.model.skip) {
					var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);
	
					// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
					pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
				}
	
				if (!pointBefore || pointBefore.model.skip) {
					pointCurrent.mK = pointCurrent.deltaK;
				} else if (!pointAfter || pointAfter.model.skip) {
					pointCurrent.mK = pointBefore.deltaK;
				} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
					pointCurrent.mK = 0;
				} else {
					pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
				}
			}
	
			// Adjust tangents to ensure monotonic properties
			var alphaK, betaK, tauK, squaredMagnitude;
			for (i = 0; i < pointsLen - 1; ++i) {
				pointCurrent = pointsWithTangents[i];
				pointAfter = pointsWithTangents[i + 1];
				if (pointCurrent.model.skip || pointAfter.model.skip) {
					continue;
				}
	
				if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
					pointCurrent.mK = pointAfter.mK = 0;
					continue;
				}
	
				alphaK = pointCurrent.mK / pointCurrent.deltaK;
				betaK = pointAfter.mK / pointCurrent.deltaK;
				squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
				if (squaredMagnitude <= 9) {
					continue;
				}
	
				tauK = 3 / Math.sqrt(squaredMagnitude);
				pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
				pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
			}
	
			// Compute control points
			var deltaX;
			for (i = 0; i < pointsLen; ++i) {
				pointCurrent = pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}
	
				pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
				pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointBefore && !pointBefore.model.skip) {
					deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
					pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
					pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
				}
				if (pointAfter && !pointAfter.model.skip) {
					deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
					pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
					pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
				}
			}
		};
		helpers.nextItem = function(collection, index, loop) {
			if (loop) {
				return index >= collection.length - 1 ? collection[0] : collection[index + 1];
			}
			return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
		};
		helpers.previousItem = function(collection, index, loop) {
			if (loop) {
				return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
			}
			return index <= 0 ? collection[0] : collection[index - 1];
		};
		// Implementation of the nice number algorithm used in determining where axis labels will go
		helpers.niceNum = function(range, round) {
			var exponent = Math.floor(helpers.log10(range));
			var fraction = range / Math.pow(10, exponent);
			var niceFraction;
	
			if (round) {
				if (fraction < 1.5) {
					niceFraction = 1;
				} else if (fraction < 3) {
					niceFraction = 2;
				} else if (fraction < 7) {
					niceFraction = 5;
				} else {
					niceFraction = 10;
				}
			} else if (fraction <= 1.0) {
				niceFraction = 1;
			} else if (fraction <= 2) {
				niceFraction = 2;
			} else if (fraction <= 5) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}
	
			return niceFraction * Math.pow(10, exponent);
		};
		// Easing functions adapted from Robert Penner's easing equations
		// http://www.robertpenner.com/easing/
		var easingEffects = helpers.easingEffects = {
			linear: function(t) {
				return t;
			},
			easeInQuad: function(t) {
				return t * t;
			},
			easeOutQuad: function(t) {
				return -1 * t * (t - 2);
			},
			easeInOutQuad: function(t) {
				if ((t /= 1 / 2) < 1) {
					return 1 / 2 * t * t;
				}
				return -1 / 2 * ((--t) * (t - 2) - 1);
			},
			easeInCubic: function(t) {
				return t * t * t;
			},
			easeOutCubic: function(t) {
				return 1 * ((t = t / 1 - 1) * t * t + 1);
			},
			easeInOutCubic: function(t) {
				if ((t /= 1 / 2) < 1) {
					return 1 / 2 * t * t * t;
				}
				return 1 / 2 * ((t -= 2) * t * t + 2);
			},
			easeInQuart: function(t) {
				return t * t * t * t;
			},
			easeOutQuart: function(t) {
				return -1 * ((t = t / 1 - 1) * t * t * t - 1);
			},
			easeInOutQuart: function(t) {
				if ((t /= 1 / 2) < 1) {
					return 1 / 2 * t * t * t * t;
				}
				return -1 / 2 * ((t -= 2) * t * t * t - 2);
			},
			easeInQuint: function(t) {
				return 1 * (t /= 1) * t * t * t * t;
			},
			easeOutQuint: function(t) {
				return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
			},
			easeInOutQuint: function(t) {
				if ((t /= 1 / 2) < 1) {
					return 1 / 2 * t * t * t * t * t;
				}
				return 1 / 2 * ((t -= 2) * t * t * t * t + 2);
			},
			easeInSine: function(t) {
				return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
			},
			easeOutSine: function(t) {
				return 1 * Math.sin(t / 1 * (Math.PI / 2));
			},
			easeInOutSine: function(t) {
				return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);
			},
			easeInExpo: function(t) {
				return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
			},
			easeOutExpo: function(t) {
				return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);
			},
			easeInOutExpo: function(t) {
				if (t === 0) {
					return 0;
				}
				if (t === 1) {
					return 1;
				}
				if ((t /= 1 / 2) < 1) {
					return 1 / 2 * Math.pow(2, 10 * (t - 1));
				}
				return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
			},
			easeInCirc: function(t) {
				if (t >= 1) {
					return t;
				}
				return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
			},
			easeOutCirc: function(t) {
				return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
			},
			easeInOutCirc: function(t) {
				if ((t /= 1 / 2) < 1) {
					return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
				}
				return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
			},
			easeInElastic: function(t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if (t === 0) {
					return 0;
				}
				if ((t /= 1) === 1) {
					return 1;
				}
				if (!p) {
					p = 1 * 0.3;
				}
				if (a < Math.abs(1)) {
					a = 1;
					s = p / 4;
				} else {
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
			},
			easeOutElastic: function(t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if (t === 0) {
					return 0;
				}
				if ((t /= 1) === 1) {
					return 1;
				}
				if (!p) {
					p = 1 * 0.3;
				}
				if (a < Math.abs(1)) {
					a = 1;
					s = p / 4;
				} else {
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;
			},
			easeInOutElastic: function(t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if (t === 0) {
					return 0;
				}
				if ((t /= 1 / 2) === 2) {
					return 1;
				}
				if (!p) {
					p = 1 * (0.3 * 1.5);
				}
				if (a < Math.abs(1)) {
					a = 1;
					s = p / 4;
				} else {
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				if (t < 1) {
					return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
				}
				return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
			},
			easeInBack: function(t) {
				var s = 1.70158;
				return 1 * (t /= 1) * t * ((s + 1) * t - s);
			},
			easeOutBack: function(t) {
				var s = 1.70158;
				return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
			},
			easeInOutBack: function(t) {
				var s = 1.70158;
				if ((t /= 1 / 2) < 1) {
					return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
				}
				return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
			},
			easeInBounce: function(t) {
				return 1 - easingEffects.easeOutBounce(1 - t);
			},
			easeOutBounce: function(t) {
				if ((t /= 1) < (1 / 2.75)) {
					return 1 * (7.5625 * t * t);
				} else if (t < (2 / 2.75)) {
					return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);
				} else if (t < (2.5 / 2.75)) {
					return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);
				}
				return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);
			},
			easeInOutBounce: function(t) {
				if (t < 1 / 2) {
					return easingEffects.easeInBounce(t * 2) * 0.5;
				}
				return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;
			}
		};
		// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		helpers.requestAnimFrame = (function() {
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					return window.setTimeout(callback, 1000 / 60);
				};
		}());
		// -- DOM methods
		helpers.getRelativePosition = function(evt, chart) {
			var mouseX, mouseY;
			var e = evt.originalEvent || evt,
				canvas = evt.currentTarget || evt.srcElement,
				boundingRect = canvas.getBoundingClientRect();
	
			var touches = e.touches;
			if (touches && touches.length > 0) {
				mouseX = touches[0].clientX;
				mouseY = touches[0].clientY;
	
			} else {
				mouseX = e.clientX;
				mouseY = e.clientY;
			}
	
			// Scale mouse coordinates into canvas coordinates
			// by following the pattern laid out by 'jerryj' in the comments of
			// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
			var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
			var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
			var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
			var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
			var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
			var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
	
			// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
			// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
			mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
			mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);
	
			return {
				x: mouseX,
				y: mouseY
			};
	
		};
		helpers.addEvent = function(node, eventType, method) {
			if (node.addEventListener) {
				node.addEventListener(eventType, method);
			} else if (node.attachEvent) {
				node.attachEvent('on' + eventType, method);
			} else {
				node['on' + eventType] = method;
			}
		};
		helpers.removeEvent = function(node, eventType, handler) {
			if (node.removeEventListener) {
				node.removeEventListener(eventType, handler, false);
			} else if (node.detachEvent) {
				node.detachEvent('on' + eventType, handler);
			} else {
				node['on' + eventType] = helpers.noop;
			}
		};
	
		// Private helper function to convert max-width/max-height values that may be percentages into a number
		function parseMaxStyle(styleValue, node, parentProperty) {
			var valueInPixels;
			if (typeof(styleValue) === 'string') {
				valueInPixels = parseInt(styleValue, 10);
	
				if (styleValue.indexOf('%') !== -1) {
					// percentage * size in dimension
					valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
				}
			} else {
				valueInPixels = styleValue;
			}
	
			return valueInPixels;
		}
	
		/**
		 * Returns if the given value contains an effective constraint.
		 * @private
		 */
		function isConstrainedValue(value) {
			return value !== undefined && value !== null && value !== 'none';
		}
	
		// Private helper to get a constraint dimension
		// @param domNode : the node to check the constraint on
		// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
		// @param percentageProperty : property of parent to use when calculating width as a percentage
		// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
		function getConstraintDimension(domNode, maxStyle, percentageProperty) {
			var view = document.defaultView;
			var parentNode = domNode.parentNode;
			var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
			var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
			var hasCNode = isConstrainedValue(constrainedNode);
			var hasCContainer = isConstrainedValue(constrainedContainer);
			var infinity = Number.POSITIVE_INFINITY;
	
			if (hasCNode || hasCContainer) {
				return Math.min(
					hasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
					hasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
			}
	
			return 'none';
		}
		// returns Number or undefined if no constraint
		helpers.getConstraintWidth = function(domNode) {
			return getConstraintDimension(domNode, 'max-width', 'clientWidth');
		};
		// returns Number or undefined if no constraint
		helpers.getConstraintHeight = function(domNode) {
			return getConstraintDimension(domNode, 'max-height', 'clientHeight');
		};
		helpers.getMaximumWidth = function(domNode) {
			var container = domNode.parentNode;
			var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
			var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
			var w = container.clientWidth - paddingLeft - paddingRight;
			var cw = helpers.getConstraintWidth(domNode);
			return isNaN(cw)? w : Math.min(w, cw);
		};
		helpers.getMaximumHeight = function(domNode) {
			var container = domNode.parentNode;
			var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
			var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
			var h = container.clientHeight - paddingTop - paddingBottom;
			var ch = helpers.getConstraintHeight(domNode);
			return isNaN(ch)? h : Math.min(h, ch);
		};
		helpers.getStyle = function(el, property) {
			return el.currentStyle ?
				el.currentStyle[property] :
				document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
		};
		helpers.retinaScale = function(chart) {
			var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;
			if (pixelRatio === 1) {
				return;
			}
	
			var canvas = chart.canvas;
			var height = chart.height;
			var width = chart.width;
	
			canvas.height = height * pixelRatio;
			canvas.width = width * pixelRatio;
			chart.ctx.scale(pixelRatio, pixelRatio);
	
			// If no style has been set on the canvas, the render size is used as display size,
			// making the chart visually bigger, so let's enforce it to the "correct" values.
			// See https://github.com/chartjs/Chart.js/issues/3575
			canvas.style.height = height + 'px';
			canvas.style.width = width + 'px';
		};
		// -- Canvas methods
		helpers.clear = function(chart) {
			chart.ctx.clearRect(0, 0, chart.width, chart.height);
		};
		helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
			return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
		};
		helpers.longestText = function(ctx, font, arrayOfThings, cache) {
			cache = cache || {};
			var data = cache.data = cache.data || {};
			var gc = cache.garbageCollect = cache.garbageCollect || [];
	
			if (cache.font !== font) {
				data = cache.data = {};
				gc = cache.garbageCollect = [];
				cache.font = font;
			}
	
			ctx.font = font;
			var longest = 0;
			helpers.each(arrayOfThings, function(thing) {
				// Undefined strings and arrays should not be measured
				if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
					longest = helpers.measureText(ctx, data, gc, longest, thing);
				} else if (helpers.isArray(thing)) {
					// if it is an array lets measure each element
					// to do maybe simplify this function a bit so we can do this more recursively?
					helpers.each(thing, function(nestedThing) {
						// Undefined strings and arrays should not be measured
						if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
							longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
						}
					});
				}
			});
	
			var gcLen = gc.length / 2;
			if (gcLen > arrayOfThings.length) {
				for (var i = 0; i < gcLen; i++) {
					delete data[gc[i]];
				}
				gc.splice(0, gcLen);
			}
			return longest;
		};
		helpers.measureText = function(ctx, data, gc, longest, string) {
			var textWidth = data[string];
			if (!textWidth) {
				textWidth = data[string] = ctx.measureText(string).width;
				gc.push(string);
			}
			if (textWidth > longest) {
				longest = textWidth;
			}
			return longest;
		};
		helpers.numberOfLabelLines = function(arrayOfThings) {
			var numberOfLines = 1;
			helpers.each(arrayOfThings, function(thing) {
				if (helpers.isArray(thing)) {
					if (thing.length > numberOfLines) {
						numberOfLines = thing.length;
					}
				}
			});
			return numberOfLines;
		};
		helpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {
			ctx.beginPath();
			ctx.moveTo(x + radius, y);
			ctx.lineTo(x + width - radius, y);
			ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
			ctx.lineTo(x + width, y + height - radius);
			ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
			ctx.lineTo(x + radius, y + height);
			ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
			ctx.lineTo(x, y + radius);
			ctx.quadraticCurveTo(x, y, x + radius, y);
			ctx.closePath();
		};
		helpers.color = function(c) {
			if (!color) {
				console.error('Color.js not found!');
				return c;
			}
	
			/* global CanvasGradient */
			if (c instanceof CanvasGradient) {
				return color(Chart.defaults.global.defaultColor);
			}
	
			return color(c);
		};
		helpers.isArray = Array.isArray?
			function(obj) {
				return Array.isArray(obj);
			} :
			function(obj) {
				return Object.prototype.toString.call(obj) === '[object Array]';
			};
		// ! @see http://stackoverflow.com/a/14853974
		helpers.arrayEquals = function(a0, a1) {
			var i, ilen, v0, v1;
	
			if (!a0 || !a1 || a0.length !== a1.length) {
				return false;
			}
	
			for (i = 0, ilen=a0.length; i < ilen; ++i) {
				v0 = a0[i];
				v1 = a1[i];
	
				if (v0 instanceof Array && v1 instanceof Array) {
					if (!helpers.arrayEquals(v0, v1)) {
						return false;
					}
				} else if (v0 !== v1) {
					// NOTE: two different object instances will never be equal: {x:20} != {x:20}
					return false;
				}
			}
	
			return true;
		};
		helpers.callCallback = function(fn, args, _tArg) {
			if (fn && typeof fn.call === 'function') {
				fn.apply(_tArg, args);
			}
		};
		helpers.getHoverColor = function(colorValue) {
			/* global CanvasPattern */
			return (colorValue instanceof CanvasPattern) ?
				colorValue :
				helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
		};
	};


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* MIT license */
	var convert = __webpack_require__(63);
	var string = __webpack_require__(65);
	
	var Color = function (obj) {
		if (obj instanceof Color) {
			return obj;
		}
		if (!(this instanceof Color)) {
			return new Color(obj);
		}
	
		this.valid = false;
		this.values = {
			rgb: [0, 0, 0],
			hsl: [0, 0, 0],
			hsv: [0, 0, 0],
			hwb: [0, 0, 0],
			cmyk: [0, 0, 0, 0],
			alpha: 1
		};
	
		// parse Color() argument
		var vals;
		if (typeof obj === 'string') {
			vals = string.getRgba(obj);
			if (vals) {
				this.setValues('rgb', vals);
			} else if (vals = string.getHsla(obj)) {
				this.setValues('hsl', vals);
			} else if (vals = string.getHwb(obj)) {
				this.setValues('hwb', vals);
			}
		} else if (typeof obj === 'object') {
			vals = obj;
			if (vals.r !== undefined || vals.red !== undefined) {
				this.setValues('rgb', vals);
			} else if (vals.l !== undefined || vals.lightness !== undefined) {
				this.setValues('hsl', vals);
			} else if (vals.v !== undefined || vals.value !== undefined) {
				this.setValues('hsv', vals);
			} else if (vals.w !== undefined || vals.whiteness !== undefined) {
				this.setValues('hwb', vals);
			} else if (vals.c !== undefined || vals.cyan !== undefined) {
				this.setValues('cmyk', vals);
			}
		}
	};
	
	Color.prototype = {
		isValid: function () {
			return this.valid;
		},
		rgb: function () {
			return this.setSpace('rgb', arguments);
		},
		hsl: function () {
			return this.setSpace('hsl', arguments);
		},
		hsv: function () {
			return this.setSpace('hsv', arguments);
		},
		hwb: function () {
			return this.setSpace('hwb', arguments);
		},
		cmyk: function () {
			return this.setSpace('cmyk', arguments);
		},
	
		rgbArray: function () {
			return this.values.rgb;
		},
		hslArray: function () {
			return this.values.hsl;
		},
		hsvArray: function () {
			return this.values.hsv;
		},
		hwbArray: function () {
			var values = this.values;
			if (values.alpha !== 1) {
				return values.hwb.concat([values.alpha]);
			}
			return values.hwb;
		},
		cmykArray: function () {
			return this.values.cmyk;
		},
		rgbaArray: function () {
			var values = this.values;
			return values.rgb.concat([values.alpha]);
		},
		hslaArray: function () {
			var values = this.values;
			return values.hsl.concat([values.alpha]);
		},
		alpha: function (val) {
			if (val === undefined) {
				return this.values.alpha;
			}
			this.setValues('alpha', val);
			return this;
		},
	
		red: function (val) {
			return this.setChannel('rgb', 0, val);
		},
		green: function (val) {
			return this.setChannel('rgb', 1, val);
		},
		blue: function (val) {
			return this.setChannel('rgb', 2, val);
		},
		hue: function (val) {
			if (val) {
				val %= 360;
				val = val < 0 ? 360 + val : val;
			}
			return this.setChannel('hsl', 0, val);
		},
		saturation: function (val) {
			return this.setChannel('hsl', 1, val);
		},
		lightness: function (val) {
			return this.setChannel('hsl', 2, val);
		},
		saturationv: function (val) {
			return this.setChannel('hsv', 1, val);
		},
		whiteness: function (val) {
			return this.setChannel('hwb', 1, val);
		},
		blackness: function (val) {
			return this.setChannel('hwb', 2, val);
		},
		value: function (val) {
			return this.setChannel('hsv', 2, val);
		},
		cyan: function (val) {
			return this.setChannel('cmyk', 0, val);
		},
		magenta: function (val) {
			return this.setChannel('cmyk', 1, val);
		},
		yellow: function (val) {
			return this.setChannel('cmyk', 2, val);
		},
		black: function (val) {
			return this.setChannel('cmyk', 3, val);
		},
	
		hexString: function () {
			return string.hexString(this.values.rgb);
		},
		rgbString: function () {
			return string.rgbString(this.values.rgb, this.values.alpha);
		},
		rgbaString: function () {
			return string.rgbaString(this.values.rgb, this.values.alpha);
		},
		percentString: function () {
			return string.percentString(this.values.rgb, this.values.alpha);
		},
		hslString: function () {
			return string.hslString(this.values.hsl, this.values.alpha);
		},
		hslaString: function () {
			return string.hslaString(this.values.hsl, this.values.alpha);
		},
		hwbString: function () {
			return string.hwbString(this.values.hwb, this.values.alpha);
		},
		keyword: function () {
			return string.keyword(this.values.rgb, this.values.alpha);
		},
	
		rgbNumber: function () {
			var rgb = this.values.rgb;
			return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
		},
	
		luminosity: function () {
			// http://www.w3.org/TR/WCAG20/#relativeluminancedef
			var rgb = this.values.rgb;
			var lum = [];
			for (var i = 0; i < rgb.length; i++) {
				var chan = rgb[i] / 255;
				lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
			}
			return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
		},
	
		contrast: function (color2) {
			// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
			var lum1 = this.luminosity();
			var lum2 = color2.luminosity();
			if (lum1 > lum2) {
				return (lum1 + 0.05) / (lum2 + 0.05);
			}
			return (lum2 + 0.05) / (lum1 + 0.05);
		},
	
		level: function (color2) {
			var contrastRatio = this.contrast(color2);
			if (contrastRatio >= 7.1) {
				return 'AAA';
			}
	
			return (contrastRatio >= 4.5) ? 'AA' : '';
		},
	
		dark: function () {
			// YIQ equation from http://24ways.org/2010/calculating-color-contrast
			var rgb = this.values.rgb;
			var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
			return yiq < 128;
		},
	
		light: function () {
			return !this.dark();
		},
	
		negate: function () {
			var rgb = [];
			for (var i = 0; i < 3; i++) {
				rgb[i] = 255 - this.values.rgb[i];
			}
			this.setValues('rgb', rgb);
			return this;
		},
	
		lighten: function (ratio) {
			var hsl = this.values.hsl;
			hsl[2] += hsl[2] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},
	
		darken: function (ratio) {
			var hsl = this.values.hsl;
			hsl[2] -= hsl[2] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},
	
		saturate: function (ratio) {
			var hsl = this.values.hsl;
			hsl[1] += hsl[1] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},
	
		desaturate: function (ratio) {
			var hsl = this.values.hsl;
			hsl[1] -= hsl[1] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},
	
		whiten: function (ratio) {
			var hwb = this.values.hwb;
			hwb[1] += hwb[1] * ratio;
			this.setValues('hwb', hwb);
			return this;
		},
	
		blacken: function (ratio) {
			var hwb = this.values.hwb;
			hwb[2] += hwb[2] * ratio;
			this.setValues('hwb', hwb);
			return this;
		},
	
		greyscale: function () {
			var rgb = this.values.rgb;
			// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
			var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
			this.setValues('rgb', [val, val, val]);
			return this;
		},
	
		clearer: function (ratio) {
			var alpha = this.values.alpha;
			this.setValues('alpha', alpha - (alpha * ratio));
			return this;
		},
	
		opaquer: function (ratio) {
			var alpha = this.values.alpha;
			this.setValues('alpha', alpha + (alpha * ratio));
			return this;
		},
	
		rotate: function (degrees) {
			var hsl = this.values.hsl;
			var hue = (hsl[0] + degrees) % 360;
			hsl[0] = hue < 0 ? 360 + hue : hue;
			this.setValues('hsl', hsl);
			return this;
		},
	
		/**
		 * Ported from sass implementation in C
		 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		 */
		mix: function (mixinColor, weight) {
			var color1 = this;
			var color2 = mixinColor;
			var p = weight === undefined ? 0.5 : weight;
	
			var w = 2 * p - 1;
			var a = color1.alpha() - color2.alpha();
	
			var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			var w2 = 1 - w1;
	
			return this
				.rgb(
					w1 * color1.red() + w2 * color2.red(),
					w1 * color1.green() + w2 * color2.green(),
					w1 * color1.blue() + w2 * color2.blue()
				)
				.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
		},
	
		toJSON: function () {
			return this.rgb();
		},
	
		clone: function () {
			// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
			// making the final build way to big to embed in Chart.js. So let's do it manually,
			// assuming that values to clone are 1 dimension arrays containing only numbers,
			// except 'alpha' which is a number.
			var result = new Color();
			var source = this.values;
			var target = result.values;
			var value, type;
	
			for (var prop in source) {
				if (source.hasOwnProperty(prop)) {
					value = source[prop];
					type = ({}).toString.call(value);
					if (type === '[object Array]') {
						target[prop] = value.slice(0);
					} else if (type === '[object Number]') {
						target[prop] = value;
					} else {
						console.error('unexpected color value:', value);
					}
				}
			}
	
			return result;
		}
	};
	
	Color.prototype.spaces = {
		rgb: ['red', 'green', 'blue'],
		hsl: ['hue', 'saturation', 'lightness'],
		hsv: ['hue', 'saturation', 'value'],
		hwb: ['hue', 'whiteness', 'blackness'],
		cmyk: ['cyan', 'magenta', 'yellow', 'black']
	};
	
	Color.prototype.maxes = {
		rgb: [255, 255, 255],
		hsl: [360, 100, 100],
		hsv: [360, 100, 100],
		hwb: [360, 100, 100],
		cmyk: [100, 100, 100, 100]
	};
	
	Color.prototype.getValues = function (space) {
		var values = this.values;
		var vals = {};
	
		for (var i = 0; i < space.length; i++) {
			vals[space.charAt(i)] = values[space][i];
		}
	
		if (values.alpha !== 1) {
			vals.a = values.alpha;
		}
	
		// {r: 255, g: 255, b: 255, a: 0.4}
		return vals;
	};
	
	Color.prototype.setValues = function (space, vals) {
		var values = this.values;
		var spaces = this.spaces;
		var maxes = this.maxes;
		var alpha = 1;
		var i;
	
		this.valid = true;
	
		if (space === 'alpha') {
			alpha = vals;
		} else if (vals.length) {
			// [10, 10, 10]
			values[space] = vals.slice(0, space.length);
			alpha = vals[space.length];
		} else if (vals[space.charAt(0)] !== undefined) {
			// {r: 10, g: 10, b: 10}
			for (i = 0; i < space.length; i++) {
				values[space][i] = vals[space.charAt(i)];
			}
	
			alpha = vals.a;
		} else if (vals[spaces[space][0]] !== undefined) {
			// {red: 10, green: 10, blue: 10}
			var chans = spaces[space];
	
			for (i = 0; i < space.length; i++) {
				values[space][i] = vals[chans[i]];
			}
	
			alpha = vals.alpha;
		}
	
		values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));
	
		if (space === 'alpha') {
			return false;
		}
	
		var capped;
	
		// cap values of the space prior converting all values
		for (i = 0; i < space.length; i++) {
			capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
			values[space][i] = Math.round(capped);
		}
	
		// convert to all the other color spaces
		for (var sname in spaces) {
			if (sname !== space) {
				values[sname] = convert[space][sname](values[space]);
			}
		}
	
		return true;
	};
	
	Color.prototype.setSpace = function (space, args) {
		var vals = args[0];
	
		if (vals === undefined) {
			// color.rgb()
			return this.getValues(space);
		}
	
		// color.rgb(10, 10, 10)
		if (typeof vals === 'number') {
			vals = Array.prototype.slice.call(args);
		}
	
		this.setValues(space, vals);
		return this;
	};
	
	Color.prototype.setChannel = function (space, index, val) {
		var svalues = this.values[space];
		if (val === undefined) {
			// color.red()
			return svalues[index];
		} else if (val === svalues[index]) {
			// color.red(color.red())
			return this;
		}
	
		// color.red(100)
		svalues[index] = val;
		this.setValues(space, svalues);
	
		return this;
	};
	
	if (typeof window !== 'undefined') {
		window.Color = Color;
	}
	
	module.exports = Color;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var conversions = __webpack_require__(64);
	
	var convert = function() {
	   return new Converter();
	}
	
	for (var func in conversions) {
	  // export Raw versions
	  convert[func + "Raw"] =  (function(func) {
	    // accept array or plain args
	    return function(arg) {
	      if (typeof arg == "number")
	        arg = Array.prototype.slice.call(arguments);
	      return conversions[func](arg);
	    }
	  })(func);
	
	  var pair = /(\w+)2(\w+)/.exec(func),
	      from = pair[1],
	      to = pair[2];
	
	  // export rgb2hsl and ["rgb"]["hsl"]
	  convert[from] = convert[from] || {};
	
	  convert[from][to] = convert[func] = (function(func) { 
	    return function(arg) {
	      if (typeof arg == "number")
	        arg = Array.prototype.slice.call(arguments);
	      
	      var val = conversions[func](arg);
	      if (typeof val == "string" || val === undefined)
	        return val; // keyword
	
	      for (var i = 0; i < val.length; i++)
	        val[i] = Math.round(val[i]);
	      return val;
	    }
	  })(func);
	}
	
	
	/* Converter does lazy conversion and caching */
	var Converter = function() {
	   this.convs = {};
	};
	
	/* Either get the values for a space or
	  set the values for a space, depending on args */
	Converter.prototype.routeSpace = function(space, args) {
	   var values = args[0];
	   if (values === undefined) {
	      // color.rgb()
	      return this.getValues(space);
	   }
	   // color.rgb(10, 10, 10)
	   if (typeof values == "number") {
	      values = Array.prototype.slice.call(args);        
	   }
	
	   return this.setValues(space, values);
	};
	  
	/* Set the values for a space, invalidating cache */
	Converter.prototype.setValues = function(space, values) {
	   this.space = space;
	   this.convs = {};
	   this.convs[space] = values;
	   return this;
	};
	
	/* Get the values for a space. If there's already
	  a conversion for the space, fetch it, otherwise
	  compute it */
	Converter.prototype.getValues = function(space) {
	   var vals = this.convs[space];
	   if (!vals) {
	      var fspace = this.space,
	          from = this.convs[fspace];
	      vals = convert[fspace][space](from);
	
	      this.convs[space] = vals;
	   }
	  return vals;
	};
	
	["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
	   Converter.prototype[space] = function(vals) {
	      return this.routeSpace(space, arguments);
	   }
	});
	
	module.exports = convert;

/***/ },
/* 64 */
/***/ function(module, exports) {

	/* MIT license */
	
	module.exports = {
	  rgb2hsl: rgb2hsl,
	  rgb2hsv: rgb2hsv,
	  rgb2hwb: rgb2hwb,
	  rgb2cmyk: rgb2cmyk,
	  rgb2keyword: rgb2keyword,
	  rgb2xyz: rgb2xyz,
	  rgb2lab: rgb2lab,
	  rgb2lch: rgb2lch,
	
	  hsl2rgb: hsl2rgb,
	  hsl2hsv: hsl2hsv,
	  hsl2hwb: hsl2hwb,
	  hsl2cmyk: hsl2cmyk,
	  hsl2keyword: hsl2keyword,
	
	  hsv2rgb: hsv2rgb,
	  hsv2hsl: hsv2hsl,
	  hsv2hwb: hsv2hwb,
	  hsv2cmyk: hsv2cmyk,
	  hsv2keyword: hsv2keyword,
	
	  hwb2rgb: hwb2rgb,
	  hwb2hsl: hwb2hsl,
	  hwb2hsv: hwb2hsv,
	  hwb2cmyk: hwb2cmyk,
	  hwb2keyword: hwb2keyword,
	
	  cmyk2rgb: cmyk2rgb,
	  cmyk2hsl: cmyk2hsl,
	  cmyk2hsv: cmyk2hsv,
	  cmyk2hwb: cmyk2hwb,
	  cmyk2keyword: cmyk2keyword,
	
	  keyword2rgb: keyword2rgb,
	  keyword2hsl: keyword2hsl,
	  keyword2hsv: keyword2hsv,
	  keyword2hwb: keyword2hwb,
	  keyword2cmyk: keyword2cmyk,
	  keyword2lab: keyword2lab,
	  keyword2xyz: keyword2xyz,
	
	  xyz2rgb: xyz2rgb,
	  xyz2lab: xyz2lab,
	  xyz2lch: xyz2lch,
	
	  lab2xyz: lab2xyz,
	  lab2rgb: lab2rgb,
	  lab2lch: lab2lch,
	
	  lch2lab: lch2lab,
	  lch2xyz: lch2xyz,
	  lch2rgb: lch2rgb
	}
	
	
	function rgb2hsl(rgb) {
	  var r = rgb[0]/255,
	      g = rgb[1]/255,
	      b = rgb[2]/255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, l;
	
	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g)/ delta;
	
	  h = Math.min(h * 60, 360);
	
	  if (h < 0)
	    h += 360;
	
	  l = (min + max) / 2;
	
	  if (max == min)
	    s = 0;
	  else if (l <= 0.5)
	    s = delta / (max + min);
	  else
	    s = delta / (2 - max - min);
	
	  return [h, s * 100, l * 100];
	}
	
	function rgb2hsv(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, v;
	
	  if (max == 0)
	    s = 0;
	  else
	    s = (delta/max * 1000)/10;
	
	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g) / delta;
	
	  h = Math.min(h * 60, 360);
	
	  if (h < 0)
	    h += 360;
	
	  v = ((max / 255) * 1000) / 10;
	
	  return [h, s, v];
	}
	
	function rgb2hwb(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      h = rgb2hsl(rgb)[0],
	      w = 1/255 * Math.min(r, Math.min(g, b)),
	      b = 1 - 1/255 * Math.max(r, Math.max(g, b));
	
	  return [h, w * 100, b * 100];
	}
	
	function rgb2cmyk(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255,
	      c, m, y, k;
	
	  k = Math.min(1 - r, 1 - g, 1 - b);
	  c = (1 - r - k) / (1 - k) || 0;
	  m = (1 - g - k) / (1 - k) || 0;
	  y = (1 - b - k) / (1 - k) || 0;
	  return [c * 100, m * 100, y * 100, k * 100];
	}
	
	function rgb2keyword(rgb) {
	  return reverseKeywords[JSON.stringify(rgb)];
	}
	
	function rgb2xyz(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255;
	
	  // assume sRGB
	  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
	
	  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
	
	  return [x * 100, y *100, z * 100];
	}
	
	function rgb2lab(rgb) {
	  var xyz = rgb2xyz(rgb),
	        x = xyz[0],
	        y = xyz[1],
	        z = xyz[2],
	        l, a, b;
	
	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;
	
	  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
	
	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);
	
	  return [l, a, b];
	}
	
	function rgb2lch(args) {
	  return lab2lch(rgb2lab(args));
	}
	
	function hsl2rgb(hsl) {
	  var h = hsl[0] / 360,
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      t1, t2, t3, rgb, val;
	
	  if (s == 0) {
	    val = l * 255;
	    return [val, val, val];
	  }
	
	  if (l < 0.5)
	    t2 = l * (1 + s);
	  else
	    t2 = l + s - l * s;
	  t1 = 2 * l - t2;
	
	  rgb = [0, 0, 0];
	  for (var i = 0; i < 3; i++) {
	    t3 = h + 1 / 3 * - (i - 1);
	    t3 < 0 && t3++;
	    t3 > 1 && t3--;
	
	    if (6 * t3 < 1)
	      val = t1 + (t2 - t1) * 6 * t3;
	    else if (2 * t3 < 1)
	      val = t2;
	    else if (3 * t3 < 2)
	      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	    else
	      val = t1;
	
	    rgb[i] = val * 255;
	  }
	
	  return rgb;
	}
	
	function hsl2hsv(hsl) {
	  var h = hsl[0],
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      sv, v;
	
	  if(l === 0) {
	      // no need to do calc on black
	      // also avoids divide by 0 error
	      return [0, 0, 0];
	  }
	
	  l *= 2;
	  s *= (l <= 1) ? l : 2 - l;
	  v = (l + s) / 2;
	  sv = (2 * s) / (l + s);
	  return [h, sv * 100, v * 100];
	}
	
	function hsl2hwb(args) {
	  return rgb2hwb(hsl2rgb(args));
	}
	
	function hsl2cmyk(args) {
	  return rgb2cmyk(hsl2rgb(args));
	}
	
	function hsl2keyword(args) {
	  return rgb2keyword(hsl2rgb(args));
	}
	
	
	function hsv2rgb(hsv) {
	  var h = hsv[0] / 60,
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      hi = Math.floor(h) % 6;
	
	  var f = h - Math.floor(h),
	      p = 255 * v * (1 - s),
	      q = 255 * v * (1 - (s * f)),
	      t = 255 * v * (1 - (s * (1 - f))),
	      v = 255 * v;
	
	  switch(hi) {
	    case 0:
	      return [v, t, p];
	    case 1:
	      return [q, v, p];
	    case 2:
	      return [p, v, t];
	    case 3:
	      return [p, q, v];
	    case 4:
	      return [t, p, v];
	    case 5:
	      return [v, p, q];
	  }
	}
	
	function hsv2hsl(hsv) {
	  var h = hsv[0],
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      sl, l;
	
	  l = (2 - s) * v;
	  sl = s * v;
	  sl /= (l <= 1) ? l : 2 - l;
	  sl = sl || 0;
	  l /= 2;
	  return [h, sl * 100, l * 100];
	}
	
	function hsv2hwb(args) {
	  return rgb2hwb(hsv2rgb(args))
	}
	
	function hsv2cmyk(args) {
	  return rgb2cmyk(hsv2rgb(args));
	}
	
	function hsv2keyword(args) {
	  return rgb2keyword(hsv2rgb(args));
	}
	
	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	function hwb2rgb(hwb) {
	  var h = hwb[0] / 360,
	      wh = hwb[1] / 100,
	      bl = hwb[2] / 100,
	      ratio = wh + bl,
	      i, v, f, n;
	
	  // wh + bl cant be > 1
	  if (ratio > 1) {
	    wh /= ratio;
	    bl /= ratio;
	  }
	
	  i = Math.floor(6 * h);
	  v = 1 - bl;
	  f = 6 * h - i;
	  if ((i & 0x01) != 0) {
	    f = 1 - f;
	  }
	  n = wh + f * (v - wh);  // linear interpolation
	
	  switch (i) {
	    default:
	    case 6:
	    case 0: r = v; g = n; b = wh; break;
	    case 1: r = n; g = v; b = wh; break;
	    case 2: r = wh; g = v; b = n; break;
	    case 3: r = wh; g = n; b = v; break;
	    case 4: r = n; g = wh; b = v; break;
	    case 5: r = v; g = wh; b = n; break;
	  }
	
	  return [r * 255, g * 255, b * 255];
	}
	
	function hwb2hsl(args) {
	  return rgb2hsl(hwb2rgb(args));
	}
	
	function hwb2hsv(args) {
	  return rgb2hsv(hwb2rgb(args));
	}
	
	function hwb2cmyk(args) {
	  return rgb2cmyk(hwb2rgb(args));
	}
	
	function hwb2keyword(args) {
	  return rgb2keyword(hwb2rgb(args));
	}
	
	function cmyk2rgb(cmyk) {
	  var c = cmyk[0] / 100,
	      m = cmyk[1] / 100,
	      y = cmyk[2] / 100,
	      k = cmyk[3] / 100,
	      r, g, b;
	
	  r = 1 - Math.min(1, c * (1 - k) + k);
	  g = 1 - Math.min(1, m * (1 - k) + k);
	  b = 1 - Math.min(1, y * (1 - k) + k);
	  return [r * 255, g * 255, b * 255];
	}
	
	function cmyk2hsl(args) {
	  return rgb2hsl(cmyk2rgb(args));
	}
	
	function cmyk2hsv(args) {
	  return rgb2hsv(cmyk2rgb(args));
	}
	
	function cmyk2hwb(args) {
	  return rgb2hwb(cmyk2rgb(args));
	}
	
	function cmyk2keyword(args) {
	  return rgb2keyword(cmyk2rgb(args));
	}
	
	
	function xyz2rgb(xyz) {
	  var x = xyz[0] / 100,
	      y = xyz[1] / 100,
	      z = xyz[2] / 100,
	      r, g, b;
	
	  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
	
	  // assume sRGB
	  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
	    : r = (r * 12.92);
	
	  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
	    : g = (g * 12.92);
	
	  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
	    : b = (b * 12.92);
	
	  r = Math.min(Math.max(0, r), 1);
	  g = Math.min(Math.max(0, g), 1);
	  b = Math.min(Math.max(0, b), 1);
	
	  return [r * 255, g * 255, b * 255];
	}
	
	function xyz2lab(xyz) {
	  var x = xyz[0],
	      y = xyz[1],
	      z = xyz[2],
	      l, a, b;
	
	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;
	
	  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
	
	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);
	
	  return [l, a, b];
	}
	
	function xyz2lch(args) {
	  return lab2lch(xyz2lab(args));
	}
	
	function lab2xyz(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      x, y, z, y2;
	
	  if (l <= 8) {
	    y = (l * 100) / 903.3;
	    y2 = (7.787 * (y / 100)) + (16 / 116);
	  } else {
	    y = 100 * Math.pow((l + 16) / 116, 3);
	    y2 = Math.pow(y / 100, 1/3);
	  }
	
	  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);
	
	  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);
	
	  return [x, y, z];
	}
	
	function lab2lch(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      hr, h, c;
	
	  hr = Math.atan2(b, a);
	  h = hr * 360 / 2 / Math.PI;
	  if (h < 0) {
	    h += 360;
	  }
	  c = Math.sqrt(a * a + b * b);
	  return [l, c, h];
	}
	
	function lab2rgb(args) {
	  return xyz2rgb(lab2xyz(args));
	}
	
	function lch2lab(lch) {
	  var l = lch[0],
	      c = lch[1],
	      h = lch[2],
	      a, b, hr;
	
	  hr = h / 360 * 2 * Math.PI;
	  a = c * Math.cos(hr);
	  b = c * Math.sin(hr);
	  return [l, a, b];
	}
	
	function lch2xyz(args) {
	  return lab2xyz(lch2lab(args));
	}
	
	function lch2rgb(args) {
	  return lab2rgb(lch2lab(args));
	}
	
	function keyword2rgb(keyword) {
	  return cssKeywords[keyword];
	}
	
	function keyword2hsl(args) {
	  return rgb2hsl(keyword2rgb(args));
	}
	
	function keyword2hsv(args) {
	  return rgb2hsv(keyword2rgb(args));
	}
	
	function keyword2hwb(args) {
	  return rgb2hwb(keyword2rgb(args));
	}
	
	function keyword2cmyk(args) {
	  return rgb2cmyk(keyword2rgb(args));
	}
	
	function keyword2lab(args) {
	  return rgb2lab(keyword2rgb(args));
	}
	
	function keyword2xyz(args) {
	  return rgb2xyz(keyword2rgb(args));
	}
	
	var cssKeywords = {
	  aliceblue:  [240,248,255],
	  antiquewhite: [250,235,215],
	  aqua: [0,255,255],
	  aquamarine: [127,255,212],
	  azure:  [240,255,255],
	  beige:  [245,245,220],
	  bisque: [255,228,196],
	  black:  [0,0,0],
	  blanchedalmond: [255,235,205],
	  blue: [0,0,255],
	  blueviolet: [138,43,226],
	  brown:  [165,42,42],
	  burlywood:  [222,184,135],
	  cadetblue:  [95,158,160],
	  chartreuse: [127,255,0],
	  chocolate:  [210,105,30],
	  coral:  [255,127,80],
	  cornflowerblue: [100,149,237],
	  cornsilk: [255,248,220],
	  crimson:  [220,20,60],
	  cyan: [0,255,255],
	  darkblue: [0,0,139],
	  darkcyan: [0,139,139],
	  darkgoldenrod:  [184,134,11],
	  darkgray: [169,169,169],
	  darkgreen:  [0,100,0],
	  darkgrey: [169,169,169],
	  darkkhaki:  [189,183,107],
	  darkmagenta:  [139,0,139],
	  darkolivegreen: [85,107,47],
	  darkorange: [255,140,0],
	  darkorchid: [153,50,204],
	  darkred:  [139,0,0],
	  darksalmon: [233,150,122],
	  darkseagreen: [143,188,143],
	  darkslateblue:  [72,61,139],
	  darkslategray:  [47,79,79],
	  darkslategrey:  [47,79,79],
	  darkturquoise:  [0,206,209],
	  darkviolet: [148,0,211],
	  deeppink: [255,20,147],
	  deepskyblue:  [0,191,255],
	  dimgray:  [105,105,105],
	  dimgrey:  [105,105,105],
	  dodgerblue: [30,144,255],
	  firebrick:  [178,34,34],
	  floralwhite:  [255,250,240],
	  forestgreen:  [34,139,34],
	  fuchsia:  [255,0,255],
	  gainsboro:  [220,220,220],
	  ghostwhite: [248,248,255],
	  gold: [255,215,0],
	  goldenrod:  [218,165,32],
	  gray: [128,128,128],
	  green:  [0,128,0],
	  greenyellow:  [173,255,47],
	  grey: [128,128,128],
	  honeydew: [240,255,240],
	  hotpink:  [255,105,180],
	  indianred:  [205,92,92],
	  indigo: [75,0,130],
	  ivory:  [255,255,240],
	  khaki:  [240,230,140],
	  lavender: [230,230,250],
	  lavenderblush:  [255,240,245],
	  lawngreen:  [124,252,0],
	  lemonchiffon: [255,250,205],
	  lightblue:  [173,216,230],
	  lightcoral: [240,128,128],
	  lightcyan:  [224,255,255],
	  lightgoldenrodyellow: [250,250,210],
	  lightgray:  [211,211,211],
	  lightgreen: [144,238,144],
	  lightgrey:  [211,211,211],
	  lightpink:  [255,182,193],
	  lightsalmon:  [255,160,122],
	  lightseagreen:  [32,178,170],
	  lightskyblue: [135,206,250],
	  lightslategray: [119,136,153],
	  lightslategrey: [119,136,153],
	  lightsteelblue: [176,196,222],
	  lightyellow:  [255,255,224],
	  lime: [0,255,0],
	  limegreen:  [50,205,50],
	  linen:  [250,240,230],
	  magenta:  [255,0,255],
	  maroon: [128,0,0],
	  mediumaquamarine: [102,205,170],
	  mediumblue: [0,0,205],
	  mediumorchid: [186,85,211],
	  mediumpurple: [147,112,219],
	  mediumseagreen: [60,179,113],
	  mediumslateblue:  [123,104,238],
	  mediumspringgreen:  [0,250,154],
	  mediumturquoise:  [72,209,204],
	  mediumvioletred:  [199,21,133],
	  midnightblue: [25,25,112],
	  mintcream:  [245,255,250],
	  mistyrose:  [255,228,225],
	  moccasin: [255,228,181],
	  navajowhite:  [255,222,173],
	  navy: [0,0,128],
	  oldlace:  [253,245,230],
	  olive:  [128,128,0],
	  olivedrab:  [107,142,35],
	  orange: [255,165,0],
	  orangered:  [255,69,0],
	  orchid: [218,112,214],
	  palegoldenrod:  [238,232,170],
	  palegreen:  [152,251,152],
	  paleturquoise:  [175,238,238],
	  palevioletred:  [219,112,147],
	  papayawhip: [255,239,213],
	  peachpuff:  [255,218,185],
	  peru: [205,133,63],
	  pink: [255,192,203],
	  plum: [221,160,221],
	  powderblue: [176,224,230],
	  purple: [128,0,128],
	  rebeccapurple: [102, 51, 153],
	  red:  [255,0,0],
	  rosybrown:  [188,143,143],
	  royalblue:  [65,105,225],
	  saddlebrown:  [139,69,19],
	  salmon: [250,128,114],
	  sandybrown: [244,164,96],
	  seagreen: [46,139,87],
	  seashell: [255,245,238],
	  sienna: [160,82,45],
	  silver: [192,192,192],
	  skyblue:  [135,206,235],
	  slateblue:  [106,90,205],
	  slategray:  [112,128,144],
	  slategrey:  [112,128,144],
	  snow: [255,250,250],
	  springgreen:  [0,255,127],
	  steelblue:  [70,130,180],
	  tan:  [210,180,140],
	  teal: [0,128,128],
	  thistle:  [216,191,216],
	  tomato: [255,99,71],
	  turquoise:  [64,224,208],
	  violet: [238,130,238],
	  wheat:  [245,222,179],
	  white:  [255,255,255],
	  whitesmoke: [245,245,245],
	  yellow: [255,255,0],
	  yellowgreen:  [154,205,50]
	};
	
	var reverseKeywords = {};
	for (var key in cssKeywords) {
	  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
	}


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* MIT license */
	var colorNames = __webpack_require__(66);
	
	module.exports = {
	   getRgba: getRgba,
	   getHsla: getHsla,
	   getRgb: getRgb,
	   getHsl: getHsl,
	   getHwb: getHwb,
	   getAlpha: getAlpha,
	
	   hexString: hexString,
	   rgbString: rgbString,
	   rgbaString: rgbaString,
	   percentString: percentString,
	   percentaString: percentaString,
	   hslString: hslString,
	   hslaString: hslaString,
	   hwbString: hwbString,
	   keyword: keyword
	}
	
	function getRgba(string) {
	   if (!string) {
	      return;
	   }
	   var abbr =  /^#([a-fA-F0-9]{3})$/,
	       hex =  /^#([a-fA-F0-9]{6})$/,
	       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
	       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
	       keyword = /(\w+)/;
	
	   var rgb = [0, 0, 0],
	       a = 1,
	       match = string.match(abbr);
	   if (match) {
	      match = match[1];
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match[i] + match[i], 16);
	      }
	   }
	   else if (match = string.match(hex)) {
	      match = match[1];
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
	      }
	   }
	   else if (match = string.match(rgba)) {
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match[i + 1]);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(per)) {
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(keyword)) {
	      if (match[1] == "transparent") {
	         return [0, 0, 0, 0];
	      }
	      rgb = colorNames[match[1]];
	      if (!rgb) {
	         return;
	      }
	   }
	
	   for (var i = 0; i < rgb.length; i++) {
	      rgb[i] = scale(rgb[i], 0, 255);
	   }
	   if (!a && a != 0) {
	      a = 1;
	   }
	   else {
	      a = scale(a, 0, 1);
	   }
	   rgb[3] = a;
	   return rgb;
	}
	
	function getHsla(string) {
	   if (!string) {
	      return;
	   }
	   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hsl);
	   if (match) {
	      var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          s = scale(parseFloat(match[2]), 0, 100),
	          l = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, s, l, a];
	   }
	}
	
	function getHwb(string) {
	   if (!string) {
	      return;
	   }
	   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hwb);
	   if (match) {
	    var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          w = scale(parseFloat(match[2]), 0, 100),
	          b = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, w, b, a];
	   }
	}
	
	function getRgb(string) {
	   var rgba = getRgba(string);
	   return rgba && rgba.slice(0, 3);
	}
	
	function getHsl(string) {
	  var hsla = getHsla(string);
	  return hsla && hsla.slice(0, 3);
	}
	
	function getAlpha(string) {
	   var vals = getRgba(string);
	   if (vals) {
	      return vals[3];
	   }
	   else if (vals = getHsla(string)) {
	      return vals[3];
	   }
	   else if (vals = getHwb(string)) {
	      return vals[3];
	   }
	}
	
	// generators
	function hexString(rgb) {
	   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
	              + hexDouble(rgb[2]);
	}
	
	function rgbString(rgba, alpha) {
	   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
	      return rgbaString(rgba, alpha);
	   }
	   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
	}
	
	function rgbaString(rgba, alpha) {
	   if (alpha === undefined) {
	      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
	   }
	   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
	           + ", " + alpha + ")";
	}
	
	function percentString(rgba, alpha) {
	   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
	      return percentaString(rgba, alpha);
	   }
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);
	
	   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
	}
	
	function percentaString(rgba, alpha) {
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);
	   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
	}
	
	function hslString(hsla, alpha) {
	   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
	      return hslaString(hsla, alpha);
	   }
	   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
	}
	
	function hslaString(hsla, alpha) {
	   if (alpha === undefined) {
	      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
	   }
	   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
	           + alpha + ")";
	}
	
	// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
	// (hwb have alpha optional & 1 is default value)
	function hwbString(hwb, alpha) {
	   if (alpha === undefined) {
	      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
	   }
	   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
	           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
	}
	
	function keyword(rgb) {
	  return reverseNames[rgb.slice(0, 3)];
	}
	
	// helpers
	function scale(num, min, max) {
	   return Math.min(Math.max(min, num), max);
	}
	
	function hexDouble(num) {
	  var str = num.toString(16).toUpperCase();
	  return (str.length < 2) ? "0" + str : str;
	}
	
	
	//create a list of reverse color names
	var reverseNames = {};
	for (var name in colorNames) {
	   reverseNames[colorNames[name]] = name;
	}


/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = {
		"aliceblue": [240, 248, 255],
		"antiquewhite": [250, 235, 215],
		"aqua": [0, 255, 255],
		"aquamarine": [127, 255, 212],
		"azure": [240, 255, 255],
		"beige": [245, 245, 220],
		"bisque": [255, 228, 196],
		"black": [0, 0, 0],
		"blanchedalmond": [255, 235, 205],
		"blue": [0, 0, 255],
		"blueviolet": [138, 43, 226],
		"brown": [165, 42, 42],
		"burlywood": [222, 184, 135],
		"cadetblue": [95, 158, 160],
		"chartreuse": [127, 255, 0],
		"chocolate": [210, 105, 30],
		"coral": [255, 127, 80],
		"cornflowerblue": [100, 149, 237],
		"cornsilk": [255, 248, 220],
		"crimson": [220, 20, 60],
		"cyan": [0, 255, 255],
		"darkblue": [0, 0, 139],
		"darkcyan": [0, 139, 139],
		"darkgoldenrod": [184, 134, 11],
		"darkgray": [169, 169, 169],
		"darkgreen": [0, 100, 0],
		"darkgrey": [169, 169, 169],
		"darkkhaki": [189, 183, 107],
		"darkmagenta": [139, 0, 139],
		"darkolivegreen": [85, 107, 47],
		"darkorange": [255, 140, 0],
		"darkorchid": [153, 50, 204],
		"darkred": [139, 0, 0],
		"darksalmon": [233, 150, 122],
		"darkseagreen": [143, 188, 143],
		"darkslateblue": [72, 61, 139],
		"darkslategray": [47, 79, 79],
		"darkslategrey": [47, 79, 79],
		"darkturquoise": [0, 206, 209],
		"darkviolet": [148, 0, 211],
		"deeppink": [255, 20, 147],
		"deepskyblue": [0, 191, 255],
		"dimgray": [105, 105, 105],
		"dimgrey": [105, 105, 105],
		"dodgerblue": [30, 144, 255],
		"firebrick": [178, 34, 34],
		"floralwhite": [255, 250, 240],
		"forestgreen": [34, 139, 34],
		"fuchsia": [255, 0, 255],
		"gainsboro": [220, 220, 220],
		"ghostwhite": [248, 248, 255],
		"gold": [255, 215, 0],
		"goldenrod": [218, 165, 32],
		"gray": [128, 128, 128],
		"green": [0, 128, 0],
		"greenyellow": [173, 255, 47],
		"grey": [128, 128, 128],
		"honeydew": [240, 255, 240],
		"hotpink": [255, 105, 180],
		"indianred": [205, 92, 92],
		"indigo": [75, 0, 130],
		"ivory": [255, 255, 240],
		"khaki": [240, 230, 140],
		"lavender": [230, 230, 250],
		"lavenderblush": [255, 240, 245],
		"lawngreen": [124, 252, 0],
		"lemonchiffon": [255, 250, 205],
		"lightblue": [173, 216, 230],
		"lightcoral": [240, 128, 128],
		"lightcyan": [224, 255, 255],
		"lightgoldenrodyellow": [250, 250, 210],
		"lightgray": [211, 211, 211],
		"lightgreen": [144, 238, 144],
		"lightgrey": [211, 211, 211],
		"lightpink": [255, 182, 193],
		"lightsalmon": [255, 160, 122],
		"lightseagreen": [32, 178, 170],
		"lightskyblue": [135, 206, 250],
		"lightslategray": [119, 136, 153],
		"lightslategrey": [119, 136, 153],
		"lightsteelblue": [176, 196, 222],
		"lightyellow": [255, 255, 224],
		"lime": [0, 255, 0],
		"limegreen": [50, 205, 50],
		"linen": [250, 240, 230],
		"magenta": [255, 0, 255],
		"maroon": [128, 0, 0],
		"mediumaquamarine": [102, 205, 170],
		"mediumblue": [0, 0, 205],
		"mediumorchid": [186, 85, 211],
		"mediumpurple": [147, 112, 219],
		"mediumseagreen": [60, 179, 113],
		"mediumslateblue": [123, 104, 238],
		"mediumspringgreen": [0, 250, 154],
		"mediumturquoise": [72, 209, 204],
		"mediumvioletred": [199, 21, 133],
		"midnightblue": [25, 25, 112],
		"mintcream": [245, 255, 250],
		"mistyrose": [255, 228, 225],
		"moccasin": [255, 228, 181],
		"navajowhite": [255, 222, 173],
		"navy": [0, 0, 128],
		"oldlace": [253, 245, 230],
		"olive": [128, 128, 0],
		"olivedrab": [107, 142, 35],
		"orange": [255, 165, 0],
		"orangered": [255, 69, 0],
		"orchid": [218, 112, 214],
		"palegoldenrod": [238, 232, 170],
		"palegreen": [152, 251, 152],
		"paleturquoise": [175, 238, 238],
		"palevioletred": [219, 112, 147],
		"papayawhip": [255, 239, 213],
		"peachpuff": [255, 218, 185],
		"peru": [205, 133, 63],
		"pink": [255, 192, 203],
		"plum": [221, 160, 221],
		"powderblue": [176, 224, 230],
		"purple": [128, 0, 128],
		"rebeccapurple": [102, 51, 153],
		"red": [255, 0, 0],
		"rosybrown": [188, 143, 143],
		"royalblue": [65, 105, 225],
		"saddlebrown": [139, 69, 19],
		"salmon": [250, 128, 114],
		"sandybrown": [244, 164, 96],
		"seagreen": [46, 139, 87],
		"seashell": [255, 245, 238],
		"sienna": [160, 82, 45],
		"silver": [192, 192, 192],
		"skyblue": [135, 206, 235],
		"slateblue": [106, 90, 205],
		"slategray": [112, 128, 144],
		"slategrey": [112, 128, 144],
		"snow": [255, 250, 250],
		"springgreen": [0, 255, 127],
		"steelblue": [70, 130, 180],
		"tan": [210, 180, 140],
		"teal": [0, 128, 128],
		"thistle": [216, 191, 216],
		"tomato": [255, 99, 71],
		"turquoise": [64, 224, 208],
		"violet": [238, 130, 238],
		"wheat": [245, 222, 179],
		"white": [255, 255, 255],
		"whitesmoke": [245, 245, 245],
		"yellow": [255, 255, 0],
		"yellowgreen": [154, 205, 50]
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// By default, select the browser (DOM) platform.
	// @TODO Make possible to select another platform at build time.
	var implementation = __webpack_require__(68);
	
	module.exports = function(Chart) {
		/**
		 * @namespace Chart.platform
		 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
		 * @since 2.4.0
		 */
		Chart.platform = {
			/**
			 * Called at chart construction time, returns a context2d instance implementing
			 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
			 * @param {*} item - The native item from which to acquire context (platform specific)
			 * @param {Object} options - The chart options
			 * @returns {CanvasRenderingContext2D} context2d instance
			 */
			acquireContext: function() {},
	
			/**
			 * Called at chart destruction time, releases any resources associated to the context
			 * previously returned by the acquireContext() method.
			 * @param {CanvasRenderingContext2D} context - The context2d instance
			 * @returns {Boolean} true if the method succeeded, else false
			 */
			releaseContext: function() {},
	
			/**
			 * Registers the specified listener on the given chart.
			 * @param {Chart} chart - Chart from which to listen for event
			 * @param {String} type - The ({@link IEvent}) type to listen for
			 * @param {Function} listener - Receives a notification (an object that implements
			 * the {@link IEvent} interface) when an event of the specified type occurs.
			 */
			addEventListener: function() {},
	
			/**
			 * Removes the specified listener previously registered with addEventListener.
			 * @param {Chart} chart -Chart from which to remove the listener
			 * @param {String} type - The ({@link IEvent}) type to remove
			 * @param {Function} listener - The listener function to remove from the event target.
			 */
			removeEventListener: function() {}
		};
	
		/**
		 * @interface IPlatform
		 * Allows abstracting platform dependencies away from the chart
		 * @borrows Chart.platform.acquireContext as acquireContext
		 * @borrows Chart.platform.releaseContext as releaseContext
		 * @borrows Chart.platform.addEventListener as addEventListener
		 * @borrows Chart.platform.removeEventListener as removeEventListener
		 */
	
		/**
		 * @interface IEvent
		 * @prop {String} type - The event type name, possible values are:
		 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
		 * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
		 * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
		 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
		 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
		 */
	
		Chart.helpers.extend(Chart.platform, implementation(Chart));
	};


/***/ },
/* 68 */
/***/ function(module, exports) {

	'use strict';
	
	// Chart.Platform implementation for targeting a web browser
	module.exports = function(Chart) {
		var helpers = Chart.helpers;
	
		// DOM event types -> Chart.js event types.
		// Note: only events with different types are mapped.
		// https://developer.mozilla.org/en-US/docs/Web/Events
		var eventTypeMap = {
			// Touch events
			touchstart: 'mousedown',
			touchmove: 'mousemove',
			touchend: 'mouseup',
	
			// Pointer events
			pointerenter: 'mouseenter',
			pointerdown: 'mousedown',
			pointermove: 'mousemove',
			pointerup: 'mouseup',
			pointerleave: 'mouseout',
			pointerout: 'mouseout'
		};
	
		/**
		 * The "used" size is the final value of a dimension property after all calculations have
		 * been performed. This method uses the computed style of `element` but returns undefined
		 * if the computed style is not expressed in pixels. That can happen in some cases where
		 * `element` has a size relative to its parent and this last one is not yet displayed,
		 * for example because of `display: none` on a parent node.
		 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
		 * @returns {Number} Size in pixels or undefined if unknown.
		 */
		function readUsedSize(element, property) {
			var value = helpers.getStyle(element, property);
			var matches = value && value.match(/(\d+)px/);
			return matches? Number(matches[1]) : undefined;
		}
	
		/**
		 * Initializes the canvas style and render size without modifying the canvas display size,
		 * since responsiveness is handled by the controller.resize() method. The config is used
		 * to determine the aspect ratio to apply in case no explicit height has been specified.
		 */
		function initCanvas(canvas, config) {
			var style = canvas.style;
	
			// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
			// returns null or '' if no explicit value has been set to the canvas attribute.
			var renderHeight = canvas.getAttribute('height');
			var renderWidth = canvas.getAttribute('width');
	
			// Chart.js modifies some canvas values that we want to restore on destroy
			canvas._chartjs = {
				initial: {
					height: renderHeight,
					width: renderWidth,
					style: {
						display: style.display,
						height: style.height,
						width: style.width
					}
				}
			};
	
			// Force canvas to display as block to avoid extra space caused by inline
			// elements, which would interfere with the responsive resize process.
			// https://github.com/chartjs/Chart.js/issues/2538
			style.display = style.display || 'block';
	
			if (renderWidth === null || renderWidth === '') {
				var displayWidth = readUsedSize(canvas, 'width');
				if (displayWidth !== undefined) {
					canvas.width = displayWidth;
				}
			}
	
			if (renderHeight === null || renderHeight === '') {
				if (canvas.style.height === '') {
					// If no explicit render height and style height, let's apply the aspect ratio,
					// which one can be specified by the user but also by charts as default option
					// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
					canvas.height = canvas.width / (config.options.aspectRatio || 2);
				} else {
					var displayHeight = readUsedSize(canvas, 'height');
					if (displayWidth !== undefined) {
						canvas.height = displayHeight;
					}
				}
			}
	
			return canvas;
		}
	
		function createEvent(type, chart, x, y, native) {
			return {
				type: type,
				chart: chart,
				native: native || null,
				x: x !== undefined? x : null,
				y: y !== undefined? y : null,
			};
		}
	
		function fromNativeEvent(event, chart) {
			var type = eventTypeMap[event.type] || event.type;
			var pos = helpers.getRelativePosition(event, chart);
			return createEvent(type, chart, pos.x, pos.y, event);
		}
	
		function createResizer(handler) {
			var iframe = document.createElement('iframe');
			iframe.className = 'chartjs-hidden-iframe';
			iframe.style.cssText =
				'display:block;'+
				'overflow:hidden;'+
				'border:0;'+
				'margin:0;'+
				'top:0;'+
				'left:0;'+
				'bottom:0;'+
				'right:0;'+
				'height:100%;'+
				'width:100%;'+
				'position:absolute;'+
				'pointer-events:none;'+
				'z-index:-1;';
	
			// Prevent the iframe to gain focus on tab.
			// https://github.com/chartjs/Chart.js/issues/3090
			iframe.tabIndex = -1;
	
			// If the iframe is re-attached to the DOM, the resize listener is removed because the
			// content is reloaded, so make sure to install the handler after the iframe is loaded.
			// https://github.com/chartjs/Chart.js/issues/3521
			helpers.addEvent(iframe, 'load', function() {
				helpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);
	
				// The iframe size might have changed while loading, which can also
				// happen if the size has been changed while detached from the DOM.
				handler();
			});
	
			return iframe;
		}
	
		function addResizeListener(node, listener, chart) {
			var stub = node._chartjs = {
				ticking: false
			};
	
			// Throttle the callback notification until the next animation frame.
			var notify = function() {
				if (!stub.ticking) {
					stub.ticking = true;
					helpers.requestAnimFrame.call(window, function() {
						if (stub.resizer) {
							stub.ticking = false;
							return listener(createEvent('resize', chart));
						}
					});
				}
			};
	
			// Let's keep track of this added iframe and thus avoid DOM query when removing it.
			stub.resizer = createResizer(notify);
	
			node.insertBefore(stub.resizer, node.firstChild);
		}
	
		function removeResizeListener(node) {
			if (!node || !node._chartjs) {
				return;
			}
	
			var resizer = node._chartjs.resizer;
			if (resizer) {
				resizer.parentNode.removeChild(resizer);
				node._chartjs.resizer = null;
			}
	
			delete node._chartjs;
		}
	
		return {
			acquireContext: function(item, config) {
				if (typeof item === 'string') {
					item = document.getElementById(item);
				} else if (item.length) {
					// Support for array based queries (such as jQuery)
					item = item[0];
				}
	
				if (item && item.canvas) {
					// Support for any object associated to a canvas (including a context2d)
					item = item.canvas;
				}
	
				if (item instanceof HTMLCanvasElement) {
					// To prevent canvas fingerprinting, some add-ons undefine the getContext
					// method, for example: https://github.com/kkapsner/CanvasBlocker
					// https://github.com/chartjs/Chart.js/issues/2807
					var context = item.getContext && item.getContext('2d');
					if (context instanceof CanvasRenderingContext2D) {
						initCanvas(item, config);
						return context;
					}
				}
	
				return null;
			},
	
			releaseContext: function(context) {
				var canvas = context.canvas;
				if (!canvas._chartjs) {
					return;
				}
	
				var initial = canvas._chartjs.initial;
				['height', 'width'].forEach(function(prop) {
					var value = initial[prop];
					if (value === undefined || value === null) {
						canvas.removeAttribute(prop);
					} else {
						canvas.setAttribute(prop, value);
					}
				});
	
				helpers.each(initial.style || {}, function(value, key) {
					canvas.style[key] = value;
				});
	
				// The canvas render size might have been changed (and thus the state stack discarded),
				// we can't use save() and restore() to restore the initial state. So make sure that at
				// least the canvas context is reset to the default state by setting the canvas width.
				// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
				canvas.width = canvas.width;
	
				delete canvas._chartjs;
			},
	
			addEventListener: function(chart, type, listener) {
				var canvas = chart.chart.canvas;
				if (type === 'resize') {
					// Note: the resize event is not supported on all browsers.
					addResizeListener(canvas.parentNode, listener, chart.chart);
					return;
				}
	
				var stub = listener._chartjs || (listener._chartjs = {});
				var proxies = stub.proxies || (stub.proxies = {});
				var proxy = proxies[chart.id + '_' + type] = function(event) {
					listener(fromNativeEvent(event, chart.chart));
				};
	
				helpers.addEvent(canvas, type, proxy);
			},
	
			removeEventListener: function(chart, type, listener) {
				var canvas = chart.chart.canvas;
				if (type === 'resize') {
					// Note: the resize event is not supported on all browsers.
					removeResizeListener(canvas.parentNode, listener);
					return;
				}
	
				var stub = listener._chartjs || {};
				var proxies = stub.proxies || {};
				var proxy = proxies[chart.id + '_' + type];
				if (!proxy) {
					return;
				}
	
				helpers.removeEvent(canvas, type, proxy);
			}
		};
	};


/***/ },
/* 69 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
		// Global Chart canvas helpers object for drawing items to canvas
		var helpers = Chart.canvasHelpers = {};
	
		helpers.drawPoint = function(ctx, pointStyle, radius, x, y) {
			var type, edgeLength, xOffset, yOffset, height, size;
	
			if (typeof pointStyle === 'object') {
				type = pointStyle.toString();
				if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
					ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);
					return;
				}
			}
	
			if (isNaN(radius) || radius <= 0) {
				return;
			}
	
			switch (pointStyle) {
			// Default includes circle
			default:
				ctx.beginPath();
				ctx.arc(x, y, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.fill();
				break;
			case 'triangle':
				ctx.beginPath();
				edgeLength = 3 * radius / Math.sqrt(3);
				height = edgeLength * Math.sqrt(3) / 2;
				ctx.moveTo(x - edgeLength / 2, y + height / 3);
				ctx.lineTo(x + edgeLength / 2, y + height / 3);
				ctx.lineTo(x, y - 2 * height / 3);
				ctx.closePath();
				ctx.fill();
				break;
			case 'rect':
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
				ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
				break;
			case 'rectRounded':
				var offset = radius / Math.SQRT2;
				var leftX = x - offset;
				var topY = y - offset;
				var sideSize = Math.SQRT2 * radius;
				Chart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);
				ctx.fill();
				break;
			case 'rectRot':
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.moveTo(x - size, y);
				ctx.lineTo(x, y + size);
				ctx.lineTo(x + size, y);
				ctx.lineTo(x, y - size);
				ctx.closePath();
				ctx.fill();
				break;
			case 'cross':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'crossRot':
				ctx.beginPath();
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'star':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'line':
				ctx.beginPath();
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'dash':
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			}
	
			ctx.stroke();
		};
	
		helpers.clipArea = function(ctx, clipArea) {
			ctx.save();
			ctx.beginPath();
			ctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);
			ctx.clip();
		};
	
		helpers.unclipArea = function(ctx) {
			ctx.restore();
		};
	
	};


/***/ },
/* 70 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.global.plugins = {};
	
		/**
		 * The plugin service singleton
		 * @namespace Chart.plugins
		 * @since 2.1.0
		 */
		Chart.plugins = {
			/**
			 * Globally registered plugins.
			 * @private
			 */
			_plugins: [],
	
			/**
			 * This identifier is used to invalidate the descriptors cache attached to each chart
			 * when a global plugin is registered or unregistered. In this case, the cache ID is
			 * incremented and descriptors are regenerated during following API calls.
			 * @private
			 */
			_cacheId: 0,
	
			/**
			 * Registers the given plugin(s) if not already registered.
			 * @param {Array|Object} plugins plugin instance(s).
			 */
			register: function(plugins) {
				var p = this._plugins;
				([]).concat(plugins).forEach(function(plugin) {
					if (p.indexOf(plugin) === -1) {
						p.push(plugin);
					}
				});
	
				this._cacheId++;
			},
	
			/**
			 * Unregisters the given plugin(s) only if registered.
			 * @param {Array|Object} plugins plugin instance(s).
			 */
			unregister: function(plugins) {
				var p = this._plugins;
				([]).concat(plugins).forEach(function(plugin) {
					var idx = p.indexOf(plugin);
					if (idx !== -1) {
						p.splice(idx, 1);
					}
				});
	
				this._cacheId++;
			},
	
			/**
			 * Remove all registered plugins.
			 * @since 2.1.5
			 */
			clear: function() {
				this._plugins = [];
				this._cacheId++;
			},
	
			/**
			 * Returns the number of registered plugins?
			 * @returns {Number}
			 * @since 2.1.5
			 */
			count: function() {
				return this._plugins.length;
			},
	
			/**
			 * Returns all registered plugin instances.
			 * @returns {Array} array of plugin objects.
			 * @since 2.1.5
			 */
			getAll: function() {
				return this._plugins;
			},
	
			/**
			 * Calls enabled plugins for `chart` on the specified hook and with the given args.
			 * This method immediately returns as soon as a plugin explicitly returns false. The
			 * returned value can be used, for instance, to interrupt the current action.
			 * @param {Object} chart - The chart instance for which plugins should be called.
			 * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
			 * @param {Array} [args] - Extra arguments to apply to the hook call.
			 * @returns {Boolean} false if any of the plugins return false, else returns true.
			 */
			notify: function(chart, hook, args) {
				var descriptors = this.descriptors(chart);
				var ilen = descriptors.length;
				var i, descriptor, plugin, params, method;
	
				for (i=0; i<ilen; ++i) {
					descriptor = descriptors[i];
					plugin = descriptor.plugin;
					method = plugin[hook];
					if (typeof method === 'function') {
						params = [chart].concat(args || []);
						params.push(descriptor.options);
						if (method.apply(plugin, params) === false) {
							return false;
						}
					}
				}
	
				return true;
			},
	
			/**
			 * Returns descriptors of enabled plugins for the given chart.
			 * @returns {Array} [{ plugin, options }]
			 * @private
			 */
			descriptors: function(chart) {
				var cache = chart._plugins || (chart._plugins = {});
				if (cache.id === this._cacheId) {
					return cache.descriptors;
				}
	
				var plugins = [];
				var descriptors = [];
				var config = (chart && chart.config) || {};
				var defaults = Chart.defaults.global.plugins;
				var options = (config.options && config.options.plugins) || {};
	
				this._plugins.concat(config.plugins || []).forEach(function(plugin) {
					var idx = plugins.indexOf(plugin);
					if (idx !== -1) {
						return;
					}
	
					var id = plugin.id;
					var opts = options[id];
					if (opts === false) {
						return;
					}
	
					if (opts === true) {
						opts = helpers.clone(defaults[id]);
					}
	
					plugins.push(plugin);
					descriptors.push({
						plugin: plugin,
						options: opts || {}
					});
				});
	
				cache.descriptors = descriptors;
				cache.id = this._cacheId;
				return descriptors;
			}
		};
	
		/**
		 * Plugin extension hooks.
		 * @interface IPlugin
		 * @since 2.1.0
		 */
		/**
		 * @method IPlugin#beforeInit
		 * @desc Called before initializing `chart`.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#afterInit
		 * @desc Called after `chart` has been initialized and before the first update.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeUpdate
		 * @desc Called before updating `chart`. If any plugin returns `false`, the update
		 * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart update.
		 */
		/**
		 * @method IPlugin#afterUpdate
		 * @desc Called after `chart` has been updated and before rendering. Note that this
		 * hook will not be called if the chart update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetsUpdate
	 	 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
		 * the datasets update is cancelled until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} false to cancel the datasets update.
		 * @since version 2.1.5
		 */
		/**
		 * @method IPlugin#afterDatasetsUpdate
		 * @desc Called after the `chart` datasets have been updated. Note that this hook
		 * will not be called if the datasets update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @since version 2.1.5
		 */
		/**
		 * @method IPlugin#beforeLayout
		 * @desc Called before laying out `chart`. If any plugin returns `false`,
		 * the layout update is cancelled until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart layout.
		 */
		/**
		 * @method IPlugin#afterLayout
		 * @desc Called after the `chart` has been layed out. Note that this hook will not
		 * be called if the layout update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeRender
		 * @desc Called before rendering `chart`. If any plugin returns `false`,
		 * the rendering is cancelled until another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart rendering.
		 */
		/**
		 * @method IPlugin#afterRender
		 * @desc Called after the `chart` has been fully rendered (and animation completed). Note
		 * that this hook will not be called if the rendering has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDraw
		 * @desc Called before drawing `chart` at every animation frame specified by the given
		 * easing value. If any plugin returns `false`, the frame drawing is cancelled until
		 * another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart drawing.
		 */
		/**
		 * @method IPlugin#afterDraw
		 * @desc Called after the `chart` has been drawn for the specific easing value. Note
		 * that this hook will not be called if the drawing has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetsDraw
	 	 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
		 * the datasets drawing is cancelled until another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart datasets drawing.
		 */
		/**
		 * @method IPlugin#afterDatasetsDraw
		 * @desc Called after the `chart` datasets have been drawn. Note that this hook
		 * will not be called if the datasets drawing has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeEvent
	 	 * @desc Called before processing the specified `event`. If any plugin returns `false`,
		 * the event will be discarded.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {IEvent} event - The event object.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#afterEvent
		 * @desc Called after the `event` has been consumed. Note that this hook
		 * will not be called if the `event` has been previously discarded.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {IEvent} event - The event object.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#resize
		 * @desc Called after the chart as been resized.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#destroy
		 * @desc Called after the chart as been destroyed.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
	
		/**
		 * Provided for backward compatibility, use Chart.plugins instead
		 * @namespace Chart.pluginService
		 * @deprecated since version 2.1.5
		 * @todo remove at version 3
		 * @private
		 */
		Chart.pluginService = Chart.plugins;
	
		/**
		 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
		 * effect, instead simply create/register plugins via plain JavaScript objects.
		 * @interface Chart.PluginBase
		 * @deprecated since version 2.5.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.PluginBase = helpers.inherits({});
	};


/***/ },
/* 71 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.elements = {};
	
		Chart.Element = function(configuration) {
			helpers.extend(this, configuration);
			this.initialize.apply(this, arguments);
		};
	
		helpers.extend(Chart.Element.prototype, {
	
			initialize: function() {
				this.hidden = false;
			},
	
			pivot: function() {
				var me = this;
				if (!me._view) {
					me._view = helpers.clone(me._model);
				}
				me._start = helpers.clone(me._view);
				return me;
			},
	
			transition: function(ease) {
				var me = this;
	
				if (!me._view) {
					me._view = helpers.clone(me._model);
				}
	
				// No animation -> No Transition
				if (ease === 1) {
					me._view = me._model;
					me._start = null;
					return me;
				}
	
				if (!me._start) {
					me.pivot();
				}
	
				helpers.each(me._model, function(value, key) {
	
					if (key[0] === '_') {
						// Only non-underscored properties
					// Init if doesn't exist
					} else if (!me._view.hasOwnProperty(key)) {
						if (typeof value === 'number' && !isNaN(me._view[key])) {
							me._view[key] = value * ease;
						} else {
							me._view[key] = value;
						}
					// No unnecessary computations
					} else if (value === me._view[key]) {
						// It's the same! Woohoo!
					// Color transitions if possible
					} else if (typeof value === 'string') {
						try {
							var color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);
							me._view[key] = color.rgbString();
						} catch (err) {
							me._view[key] = value;
						}
					// Number transitions
					} else if (typeof value === 'number') {
						var startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;
						me._view[key] = ((me._model[key] - startVal) * ease) + startVal;
					// Everything else
					} else {
						me._view[key] = value;
					}
				}, me);
	
				return me;
			},
	
			tooltipPosition: function() {
				return {
					x: this._model.x,
					y: this._model.y
				};
			},
	
			hasValue: function() {
				return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
			}
		});
	
		Chart.Element.extend = helpers.inherits;
	
	};


/***/ },
/* 72 */
/***/ function(module, exports) {

	/* global window: false */
	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.global.animation = {
			duration: 1000,
			easing: 'easeOutQuart',
			onProgress: helpers.noop,
			onComplete: helpers.noop
		};
	
		Chart.Animation = Chart.Element.extend({
			currentStep: null, // the current animation step
			numSteps: 60, // default number of steps
			easing: '', // the easing to use for this animation
			render: null, // render function used by the animation service
	
			onAnimationProgress: null, // user specified callback to fire on each step of the animation
			onAnimationComplete: null // user specified callback to fire when the animation finishes
		});
	
		Chart.animationService = {
			frameDuration: 17,
			animations: [],
			dropFrames: 0,
			request: null,
	
			/**
			 * @function Chart.animationService.addAnimation
			 * @param chartInstance {ChartController} the chart to animate
			 * @param animationObject {IAnimation} the animation that we will animate
			 * @param duration {Number} length of animation in ms
			 * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions
			 */
			addAnimation: function(chartInstance, animationObject, duration, lazy) {
				var me = this;
	
				if (!lazy) {
					chartInstance.animating = true;
				}
	
				for (var index = 0; index < me.animations.length; ++index) {
					if (me.animations[index].chartInstance === chartInstance) {
						// replacing an in progress animation
						me.animations[index].animationObject = animationObject;
						return;
					}
				}
	
				me.animations.push({
					chartInstance: chartInstance,
					animationObject: animationObject
				});
	
				// If there are no animations queued, manually kickstart a digest, for lack of a better word
				if (me.animations.length === 1) {
					me.requestAnimationFrame();
				}
			},
			// Cancel the animation for a given chart instance
			cancelAnimation: function(chartInstance) {
				var index = helpers.findIndex(this.animations, function(animationWrapper) {
					return animationWrapper.chartInstance === chartInstance;
				});
	
				if (index !== -1) {
					this.animations.splice(index, 1);
					chartInstance.animating = false;
				}
			},
			requestAnimationFrame: function() {
				var me = this;
				if (me.request === null) {
					// Skip animation frame requests until the active one is executed.
					// This can happen when processing mouse events, e.g. 'mousemove'
					// and 'mouseout' events will trigger multiple renders.
					me.request = helpers.requestAnimFrame.call(window, function() {
						me.request = null;
						me.startDigest();
					});
				}
			},
			startDigest: function() {
				var me = this;
	
				var startTime = Date.now();
				var framesToDrop = 0;
	
				if (me.dropFrames > 1) {
					framesToDrop = Math.floor(me.dropFrames);
					me.dropFrames = me.dropFrames % 1;
				}
	
				var i = 0;
				while (i < me.animations.length) {
					if (me.animations[i].animationObject.currentStep === null) {
						me.animations[i].animationObject.currentStep = 0;
					}
	
					me.animations[i].animationObject.currentStep += 1 + framesToDrop;
	
					if (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {
						me.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;
					}
	
					me.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);
					if (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {
						me.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);
					}
	
					if (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {
						if (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {
							me.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);
						}
	
						// executed the last frame. Remove the animation.
						me.animations[i].chartInstance.animating = false;
	
						me.animations.splice(i, 1);
					} else {
						++i;
					}
				}
	
				var endTime = Date.now();
				var dropFrames = (endTime - startTime) / me.frameDuration;
	
				me.dropFrames += dropFrames;
	
				// Do we have more stuff to animate?
				if (me.animations.length > 0) {
					me.requestAnimationFrame();
				}
			}
		};
	};


/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
		var plugins = Chart.plugins;
		var platform = Chart.platform;
	
		// Create a dictionary of chart types, to allow for extension of existing types
		Chart.types = {};
	
		// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
		// Destroy method on the chart will remove the instance of the chart from this reference.
		Chart.instances = {};
	
		// Controllers available for dataset visualization eg. bar, line, slice, etc.
		Chart.controllers = {};
	
		/**
		 * Initializes the given config with global and chart default values.
		 */
		function initConfig(config) {
			config = config || {};
	
			// Do NOT use configMerge() for the data object because this method merges arrays
			// and so would change references to labels and datasets, preventing data updates.
			var data = config.data = config.data || {};
			data.datasets = data.datasets || [];
			data.labels = data.labels || [];
	
			config.options = helpers.configMerge(
				Chart.defaults.global,
				Chart.defaults[config.type],
				config.options || {});
	
			return config;
		}
	
		/**
		 * Updates the config of the chart
		 * @param chart {Chart.Controller} chart to update the options for
		 */
		function updateConfig(chart) {
			var newOptions = chart.options;
	
			// Update Scale(s) with options
			if (newOptions.scale) {
				chart.scale.options = newOptions.scale;
			} else if (newOptions.scales) {
				newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {
					chart.scales[scaleOptions.id].options = scaleOptions;
				});
			}
	
			// Tooltip
			chart.tooltip._options = newOptions.tooltips;
		}
	
		/**
		 * @class Chart.Controller
		 * The main controller of a chart.
		 */
		Chart.Controller = function(item, config, instance) {
			var me = this;
	
			config = initConfig(config);
	
			var context = platform.acquireContext(item, config);
			var canvas = context && context.canvas;
			var height = canvas && canvas.height;
			var width = canvas && canvas.width;
	
			instance.ctx = context;
			instance.canvas = canvas;
			instance.config = config;
			instance.width = width;
			instance.height = height;
			instance.aspectRatio = height? width / height : null;
	
			me.id = helpers.uid();
			me.chart = instance;
			me.config = config;
			me.options = config.options;
			me._bufferedRender = false;
	
			// Add the chart instance to the global namespace
			Chart.instances[me.id] = me;
	
			Object.defineProperty(me, 'data', {
				get: function() {
					return me.config.data;
				}
			});
	
			if (!context || !canvas) {
				// The given item is not a compatible context2d element, let's return before finalizing
				// the chart initialization but after setting basic chart / controller properties that
				// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
				// https://github.com/chartjs/Chart.js/issues/2807
				console.error("Failed to create chart: can't acquire context from the given item");
				return me;
			}
	
			me.initialize();
			me.update();
	
			return me;
		};
	
		helpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller.prototype */ {
			initialize: function() {
				var me = this;
	
				// Before init plugin notification
				plugins.notify(me, 'beforeInit');
	
				helpers.retinaScale(me.chart);
	
				me.bindEvents();
	
				if (me.options.responsive) {
					// Initial resize before chart draws (must be silent to preserve initial animations).
					me.resize(true);
				}
	
				// Make sure scales have IDs and are built before we build any controllers.
				me.ensureScalesHaveIDs();
				me.buildScales();
				me.initToolTip();
	
				// After init plugin notification
				plugins.notify(me, 'afterInit');
	
				return me;
			},
	
			clear: function() {
				helpers.clear(this.chart);
				return this;
			},
	
			stop: function() {
				// Stops any current animation loop occurring
				Chart.animationService.cancelAnimation(this);
				return this;
			},
	
			resize: function(silent) {
				var me = this;
				var chart = me.chart;
				var options = me.options;
				var canvas = chart.canvas;
				var aspectRatio = (options.maintainAspectRatio && chart.aspectRatio) || null;
	
				// the canvas render width and height will be casted to integers so make sure that
				// the canvas display style uses the same integer values to avoid blurring effect.
				var newWidth = Math.floor(helpers.getMaximumWidth(canvas));
				var newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));
	
				if (chart.width === newWidth && chart.height === newHeight) {
					return;
				}
	
				canvas.width = chart.width = newWidth;
				canvas.height = chart.height = newHeight;
				canvas.style.width = newWidth + 'px';
				canvas.style.height = newHeight + 'px';
	
				helpers.retinaScale(chart);
	
				if (!silent) {
					// Notify any plugins about the resize
					var newSize = {width: newWidth, height: newHeight};
					plugins.notify(me, 'resize', [newSize]);
	
					// Notify of resize
					if (me.options.onResize) {
						me.options.onResize(me, newSize);
					}
	
					me.stop();
					me.update(me.options.responsiveAnimationDuration);
				}
			},
	
			ensureScalesHaveIDs: function() {
				var options = this.options;
				var scalesOptions = options.scales || {};
				var scaleOptions = options.scale;
	
				helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
					xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
				});
	
				helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
					yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
				});
	
				if (scaleOptions) {
					scaleOptions.id = scaleOptions.id || 'scale';
				}
			},
	
			/**
			 * Builds a map of scale ID to scale object for future lookup.
			 */
			buildScales: function() {
				var me = this;
				var options = me.options;
				var scales = me.scales = {};
				var items = [];
	
				if (options.scales) {
					items = items.concat(
						(options.scales.xAxes || []).map(function(xAxisOptions) {
							return {options: xAxisOptions, dtype: 'category'};
						}),
						(options.scales.yAxes || []).map(function(yAxisOptions) {
							return {options: yAxisOptions, dtype: 'linear'};
						})
					);
				}
	
				if (options.scale) {
					items.push({options: options.scale, dtype: 'radialLinear', isDefault: true});
				}
	
				helpers.each(items, function(item) {
					var scaleOptions = item.options;
					var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);
					var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
					if (!scaleClass) {
						return;
					}
	
					var scale = new scaleClass({
						id: scaleOptions.id,
						options: scaleOptions,
						ctx: me.chart.ctx,
						chart: me
					});
	
					scales[scale.id] = scale;
	
					// TODO(SB): I think we should be able to remove this custom case (options.scale)
					// and consider it as a regular scale part of the "scales"" map only! This would
					// make the logic easier and remove some useless? custom code.
					if (item.isDefault) {
						me.scale = scale;
					}
				});
	
				Chart.scaleService.addScalesToLayout(this);
			},
	
			buildOrUpdateControllers: function() {
				var me = this;
				var types = [];
				var newControllers = [];
	
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					var meta = me.getDatasetMeta(datasetIndex);
					if (!meta.type) {
						meta.type = dataset.type || me.config.type;
					}
	
					types.push(meta.type);
	
					if (meta.controller) {
						meta.controller.updateIndex(datasetIndex);
					} else {
						meta.controller = new Chart.controllers[meta.type](me, datasetIndex);
						newControllers.push(meta.controller);
					}
				}, me);
	
				if (types.length > 1) {
					for (var i = 1; i < types.length; i++) {
						if (types[i] !== types[i - 1]) {
							me.isCombo = true;
							break;
						}
					}
				}
	
				return newControllers;
			},
	
			/**
			 * Reset the elements of all datasets
			 * @private
			 */
			resetElements: function() {
				var me = this;
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.reset();
				}, me);
			},
	
			/**
			* Resets the chart back to it's state before the initial animation
			*/
			reset: function() {
				this.resetElements();
				this.tooltip.initialize();
			},
	
			update: function(animationDuration, lazy) {
				var me = this;
	
				updateConfig(me);
	
				if (plugins.notify(me, 'beforeUpdate') === false) {
					return;
				}
	
				// In case the entire data object changed
				me.tooltip._data = me.data;
	
				// Make sure dataset controllers are updated and new controllers are reset
				var newControllers = me.buildOrUpdateControllers();
	
				// Make sure all dataset controllers have correct meta data counts
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
				}, me);
	
				me.updateLayout();
	
				// Can only reset the new controllers after the scales have been updated
				helpers.each(newControllers, function(controller) {
					controller.reset();
				});
	
				me.updateDatasets();
	
				// Do this before render so that any plugins that need final scale updates can use it
				plugins.notify(me, 'afterUpdate');
	
				if (me._bufferedRender) {
					me._bufferedRequest = {
						lazy: lazy,
						duration: animationDuration
					};
				} else {
					me.render(animationDuration, lazy);
				}
			},
	
			/**
			 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
			 * hook, in which case, plugins will not be called on `afterLayout`.
			 * @private
			 */
			updateLayout: function() {
				var me = this;
	
				if (plugins.notify(me, 'beforeLayout') === false) {
					return;
				}
	
				Chart.layoutService.update(this, this.chart.width, this.chart.height);
	
				/**
				 * Provided for backward compatibility, use `afterLayout` instead.
				 * @method IPlugin#afterScaleUpdate
				 * @deprecated since version 2.5.0
				 * @todo remove at version 3
				 */
				plugins.notify(me, 'afterScaleUpdate');
				plugins.notify(me, 'afterLayout');
			},
	
			/**
			 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
			 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
			 * @private
			 */
			updateDatasets: function() {
				var me = this;
	
				if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
					return;
				}
	
				for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
					me.getDatasetMeta(i).controller.update();
				}
	
				plugins.notify(me, 'afterDatasetsUpdate');
			},
	
			render: function(duration, lazy) {
				var me = this;
	
				if (plugins.notify(me, 'beforeRender') === false) {
					return;
				}
	
				var animationOptions = me.options.animation;
				var onComplete = function() {
					plugins.notify(me, 'afterRender');
					var callback = animationOptions && animationOptions.onComplete;
					if (callback && callback.call) {
						callback.call(me);
					}
				};
	
				if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
					var animation = new Chart.Animation();
					animation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps
					animation.easing = animationOptions.easing;
	
					// render function
					animation.render = function(chartInstance, animationObject) {
						var easingFunction = helpers.easingEffects[animationObject.easing];
						var stepDecimal = animationObject.currentStep / animationObject.numSteps;
						var easeDecimal = easingFunction(stepDecimal);
	
						chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);
					};
	
					// user events
					animation.onAnimationProgress = animationOptions.onProgress;
					animation.onAnimationComplete = onComplete;
	
					Chart.animationService.addAnimation(me, animation, duration, lazy);
				} else {
					me.draw();
					onComplete();
				}
	
				return me;
			},
	
			draw: function(easingValue) {
				var me = this;
	
				me.clear();
	
				if (easingValue === undefined || easingValue === null) {
					easingValue = 1;
				}
	
				if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
					return;
				}
	
				// Draw all the scales
				helpers.each(me.boxes, function(box) {
					box.draw(me.chartArea);
				}, me);
	
				if (me.scale) {
					me.scale.draw();
				}
	
				me.drawDatasets(easingValue);
	
				// Finally draw the tooltip
				me.tooltip.transition(easingValue).draw();
	
				plugins.notify(me, 'afterDraw', [easingValue]);
			},
	
			/**
			 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
			 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
			 * @private
			 */
			drawDatasets: function(easingValue) {
				var me = this;
	
				if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
					return;
				}
	
				// Draw each dataset via its respective controller (reversed to support proper line stacking)
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					if (me.isDatasetVisible(datasetIndex)) {
						me.getDatasetMeta(datasetIndex).controller.draw(easingValue);
					}
				}, me, true);
	
				plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
			},
	
			// Get the single element that was clicked on
			// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
			getElementAtEvent: function(e) {
				return Chart.Interaction.modes.single(this, e);
			},
	
			getElementsAtEvent: function(e) {
				return Chart.Interaction.modes.label(this, e, {intersect: true});
			},
	
			getElementsAtXAxis: function(e) {
				return Chart.Interaction.modes['x-axis'](this, e, {intersect: true});
			},
	
			getElementsAtEventForMode: function(e, mode, options) {
				var method = Chart.Interaction.modes[mode];
				if (typeof method === 'function') {
					return method(this, e, options);
				}
	
				return [];
			},
	
			getDatasetAtEvent: function(e) {
				return Chart.Interaction.modes.dataset(this, e, {intersect: true});
			},
	
			getDatasetMeta: function(datasetIndex) {
				var me = this;
				var dataset = me.data.datasets[datasetIndex];
				if (!dataset._meta) {
					dataset._meta = {};
				}
	
				var meta = dataset._meta[me.id];
				if (!meta) {
					meta = dataset._meta[me.id] = {
						type: null,
						data: [],
						dataset: null,
						controller: null,
						hidden: null,			// See isDatasetVisible() comment
						xAxisID: null,
						yAxisID: null
					};
				}
	
				return meta;
			},
	
			getVisibleDatasetCount: function() {
				var count = 0;
				for (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {
					if (this.isDatasetVisible(i)) {
						count++;
					}
				}
				return count;
			},
	
			isDatasetVisible: function(datasetIndex) {
				var meta = this.getDatasetMeta(datasetIndex);
	
				// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
				// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
				return typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
			},
	
			generateLegend: function() {
				return this.options.legendCallback(this);
			},
	
			destroy: function() {
				var me = this;
				var canvas = me.chart.canvas;
				var meta, i, ilen;
	
				me.stop();
	
				// dataset controllers need to cleanup associated data
				for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
					meta = me.getDatasetMeta(i);
					if (meta.controller) {
						meta.controller.destroy();
						meta.controller = null;
					}
				}
	
				if (canvas) {
					me.unbindEvents();
					helpers.clear(me.chart);
					platform.releaseContext(me.chart.ctx);
					me.chart.canvas = null;
					me.chart.ctx = null;
				}
	
				plugins.notify(me, 'destroy');
	
				delete Chart.instances[me.id];
			},
	
			toBase64Image: function() {
				return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
			},
	
			initToolTip: function() {
				var me = this;
				me.tooltip = new Chart.Tooltip({
					_chart: me.chart,
					_chartInstance: me,
					_data: me.data,
					_options: me.options.tooltips
				}, me);
				me.tooltip.initialize();
			},
	
			/**
			 * @private
			 */
			bindEvents: function() {
				var me = this;
				var listeners = me._listeners = {};
				var listener = function() {
					me.eventHandler.apply(me, arguments);
				};
	
				helpers.each(me.options.events, function(type) {
					platform.addEventListener(me, type, listener);
					listeners[type] = listener;
				});
	
				// Responsiveness is currently based on the use of an iframe, however this method causes
				// performance issues and could be troublesome when used with ad blockers. So make sure
				// that the user is still able to create a chart without iframe when responsive is false.
				// See https://github.com/chartjs/Chart.js/issues/2210
				if (me.options.responsive) {
					listener = function() {
						me.resize();
					};
	
					platform.addEventListener(me, 'resize', listener);
					listeners.resize = listener;
				}
			},
	
			/**
			 * @private
			 */
			unbindEvents: function() {
				var me = this;
				var listeners = me._listeners;
				if (!listeners) {
					return;
				}
	
				delete me._listeners;
				helpers.each(listeners, function(listener, type) {
					platform.removeEventListener(me, type, listener);
				});
			},
	
			updateHoverStyle: function(elements, mode, enabled) {
				var method = enabled? 'setHoverStyle' : 'removeHoverStyle';
				var element, i, ilen;
	
				for (i=0, ilen=elements.length; i<ilen; ++i) {
					element = elements[i];
					if (element) {
						this.getDatasetMeta(element._datasetIndex).controller[method](element);
					}
				}
			},
	
			/**
			 * @private
			 */
			eventHandler: function(e) {
				var me = this;
				var tooltip = me.tooltip;
	
				if (plugins.notify(me, 'beforeEvent', [e]) === false) {
					return;
				}
	
				// Buffer any update calls so that renders do not occur
				me._bufferedRender = true;
				me._bufferedRequest = null;
	
				var changed = me.handleEvent(e);
				changed |= tooltip && tooltip.handleEvent(e);
	
				plugins.notify(me, 'afterEvent', [e]);
	
				var bufferedRequest = me._bufferedRequest;
				if (bufferedRequest) {
					// If we have an update that was triggered, we need to do a normal render
					me.render(bufferedRequest.duration, bufferedRequest.lazy);
				} else if (changed && !me.animating) {
					// If entering, leaving, or changing elements, animate the change via pivot
					me.stop();
	
					// We only need to render at this point. Updating will cause scales to be
					// recomputed generating flicker & using more memory than necessary.
					me.render(me.options.hover.animationDuration, true);
				}
	
				me._bufferedRender = false;
				me._bufferedRequest = null;
	
				return me;
			},
	
			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event the event to handle
			 * @return {Boolean} true if the chart needs to re-render
			 */
			handleEvent: function(e) {
				var me = this;
				var options = me.options || {};
				var hoverOptions = options.hover;
				var changed = false;
	
				me.lastActive = me.lastActive || [];
	
				// Find Active Elements for hover and tooltips
				if (e.type === 'mouseout') {
					me.active = [];
				} else {
					me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
				}
	
				// On Hover hook
				if (hoverOptions.onHover) {
					// Need to call with native event here to not break backwards compatibility
					hoverOptions.onHover.call(me, e.native, me.active);
				}
	
				if (e.type === 'mouseup' || e.type === 'click') {
					if (options.onClick) {
						// Use e.native here for backwards compatibility
						options.onClick.call(me, e.native, me.active);
					}
				}
	
				// Remove styling for last active (even if it may still be active)
				if (me.lastActive.length) {
					me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
				}
	
				// Built in hover styling
				if (me.active.length && hoverOptions.mode) {
					me.updateHoverStyle(me.active, hoverOptions.mode, true);
				}
	
				changed = !helpers.arrayEquals(me.active, me.lastActive);
	
				// Remember Last Actives
				me.lastActive = me.active;
	
				return changed;
			}
		});
	};


/***/ },
/* 74 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
	
		/**
		 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
		 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
		 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
		 */
		function listenArrayEvents(array, listener) {
			if (array._chartjs) {
				array._chartjs.listeners.push(listener);
				return;
			}
	
			Object.defineProperty(array, '_chartjs', {
				configurable: true,
				enumerable: false,
				value: {
					listeners: [listener]
				}
			});
	
			arrayEvents.forEach(function(key) {
				var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
				var base = array[key];
	
				Object.defineProperty(array, key, {
					configurable: true,
					enumerable: false,
					value: function() {
						var args = Array.prototype.slice.call(arguments);
						var res = base.apply(this, args);
	
						helpers.each(array._chartjs.listeners, function(object) {
							if (typeof object[method] === 'function') {
								object[method].apply(object, args);
							}
						});
	
						return res;
					}
				});
			});
		}
	
		/**
		 * Removes the given array event listener and cleanup extra attached properties (such as
		 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
		 */
		function unlistenArrayEvents(array, listener) {
			var stub = array._chartjs;
			if (!stub) {
				return;
			}
	
			var listeners = stub.listeners;
			var index = listeners.indexOf(listener);
			if (index !== -1) {
				listeners.splice(index, 1);
			}
	
			if (listeners.length > 0) {
				return;
			}
	
			arrayEvents.forEach(function(key) {
				delete array[key];
			});
	
			delete array._chartjs;
		}
	
		// Base class for all dataset controllers (line, bar, etc)
		Chart.DatasetController = function(chart, datasetIndex) {
			this.initialize(chart, datasetIndex);
		};
	
		helpers.extend(Chart.DatasetController.prototype, {
	
			/**
			 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
			 * @type {Chart.core.element}
			 */
			datasetElementType: null,
	
			/**
			 * Element type used to generate a meta data (e.g. Chart.element.Point).
			 * @type {Chart.core.element}
			 */
			dataElementType: null,
	
			initialize: function(chart, datasetIndex) {
				var me = this;
				me.chart = chart;
				me.index = datasetIndex;
				me.linkScales();
				me.addElements();
			},
	
			updateIndex: function(datasetIndex) {
				this.index = datasetIndex;
			},
	
			linkScales: function() {
				var me = this;
				var meta = me.getMeta();
				var dataset = me.getDataset();
	
				if (meta.xAxisID === null) {
					meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
				}
				if (meta.yAxisID === null) {
					meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
				}
			},
	
			getDataset: function() {
				return this.chart.data.datasets[this.index];
			},
	
			getMeta: function() {
				return this.chart.getDatasetMeta(this.index);
			},
	
			getScaleForId: function(scaleID) {
				return this.chart.scales[scaleID];
			},
	
			reset: function() {
				this.update(true);
			},
	
			/**
			 * @private
			 */
			destroy: function() {
				if (this._data) {
					unlistenArrayEvents(this._data, this);
				}
			},
	
			createMetaDataset: function() {
				var me = this;
				var type = me.datasetElementType;
				return type && new type({
					_chart: me.chart.chart,
					_datasetIndex: me.index
				});
			},
	
			createMetaData: function(index) {
				var me = this;
				var type = me.dataElementType;
				return type && new type({
					_chart: me.chart.chart,
					_datasetIndex: me.index,
					_index: index
				});
			},
	
			addElements: function() {
				var me = this;
				var meta = me.getMeta();
				var data = me.getDataset().data || [];
				var metaData = meta.data;
				var i, ilen;
	
				for (i=0, ilen=data.length; i<ilen; ++i) {
					metaData[i] = metaData[i] || me.createMetaData(i);
				}
	
				meta.dataset = meta.dataset || me.createMetaDataset();
			},
	
			addElementAndReset: function(index) {
				var element = this.createMetaData(index);
				this.getMeta().data.splice(index, 0, element);
				this.updateElement(element, index, true);
			},
	
			buildOrUpdateElements: function() {
				var me = this;
				var dataset = me.getDataset();
				var data = dataset.data || (dataset.data = []);
	
				// In order to correctly handle data addition/deletion animation (an thus simulate
				// real-time charts), we need to monitor these data modifications and synchronize
				// the internal meta data accordingly.
				if (me._data !== data) {
					if (me._data) {
						// This case happens when the user replaced the data array instance.
						unlistenArrayEvents(me._data, me);
					}
	
					listenArrayEvents(data, me);
					me._data = data;
				}
	
				// Re-sync meta data in case the user replaced the data array or if we missed
				// any updates and so make sure that we handle number of datapoints changing.
				me.resyncElements();
			},
	
			update: helpers.noop,
	
			draw: function(ease) {
				var easingDecimal = ease || 1;
				var i, len;
				var metaData = this.getMeta().data;
				for (i = 0, len = metaData.length; i < len; ++i) {
					metaData[i].transition(easingDecimal).draw();
				}
			},
	
			removeHoverStyle: function(element, elementOpts) {
				var dataset = this.chart.data.datasets[element._datasetIndex],
					index = element._index,
					custom = element.custom || {},
					valueOrDefault = helpers.getValueAtIndexOrDefault,
					model = element._model;
	
				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
			},
	
			setHoverStyle: function(element) {
				var dataset = this.chart.data.datasets[element._datasetIndex],
					index = element._index,
					custom = element.custom || {},
					valueOrDefault = helpers.getValueAtIndexOrDefault,
					getHoverColor = helpers.getHoverColor,
					model = element._model;
	
				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},
	
			/**
			 * @private
			 */
			resyncElements: function() {
				var me = this;
				var meta = me.getMeta();
				var data = me.getDataset().data;
				var numMeta = meta.data.length;
				var numData = data.length;
	
				if (numData < numMeta) {
					meta.data.splice(numData, numMeta - numData);
				} else if (numData > numMeta) {
					me.insertElements(numMeta, numData - numMeta);
				}
			},
	
			/**
			 * @private
			 */
			insertElements: function(start, count) {
				for (var i=0; i<count; ++i) {
					this.addElementAndReset(start + i);
				}
			},
	
			/**
			 * @private
			 */
			onDataPush: function() {
				this.insertElements(this.getDataset().data.length-1, arguments.length);
			},
	
			/**
			 * @private
			 */
			onDataPop: function() {
				this.getMeta().data.pop();
			},
	
			/**
			 * @private
			 */
			onDataShift: function() {
				this.getMeta().data.shift();
			},
	
			/**
			 * @private
			 */
			onDataSplice: function(start, count) {
				this.getMeta().data.splice(start, count);
				this.insertElements(start, arguments.length - 2);
			},
	
			/**
			 * @private
			 */
			onDataUnshift: function() {
				this.insertElements(0, arguments.length);
			}
		});
	
		Chart.DatasetController.extend = helpers.inherits;
	};


/***/ },
/* 75 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		// The layout service is very self explanatory.  It's responsible for the layout within a chart.
		// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
		// It is this service's responsibility of carrying out that layout.
		Chart.layoutService = {
			defaults: {},
	
			// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.
			addBox: function(chartInstance, box) {
				if (!chartInstance.boxes) {
					chartInstance.boxes = [];
				}
				chartInstance.boxes.push(box);
			},
	
			removeBox: function(chartInstance, box) {
				if (!chartInstance.boxes) {
					return;
				}
				chartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);
			},
	
			// The most important function
			update: function(chartInstance, width, height) {
	
				if (!chartInstance) {
					return;
				}
	
				var layoutOptions = chartInstance.options.layout;
				var padding = layoutOptions ? layoutOptions.padding : null;
	
				var leftPadding = 0;
				var rightPadding = 0;
				var topPadding = 0;
				var bottomPadding = 0;
	
				if (!isNaN(padding)) {
					// options.layout.padding is a number. assign to all
					leftPadding = padding;
					rightPadding = padding;
					topPadding = padding;
					bottomPadding = padding;
				} else {
					leftPadding = padding.left || 0;
					rightPadding = padding.right || 0;
					topPadding = padding.top || 0;
					bottomPadding = padding.bottom || 0;
				}
	
				var leftBoxes = helpers.where(chartInstance.boxes, function(box) {
					return box.options.position === 'left';
				});
				var rightBoxes = helpers.where(chartInstance.boxes, function(box) {
					return box.options.position === 'right';
				});
				var topBoxes = helpers.where(chartInstance.boxes, function(box) {
					return box.options.position === 'top';
				});
				var bottomBoxes = helpers.where(chartInstance.boxes, function(box) {
					return box.options.position === 'bottom';
				});
	
				// Boxes that overlay the chartarea such as the radialLinear scale
				var chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {
					return box.options.position === 'chartArea';
				});
	
				// Ensure that full width boxes are at the very top / bottom
				topBoxes.sort(function(a, b) {
					return (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);
				});
				bottomBoxes.sort(function(a, b) {
					return (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);
				});
	
				// Essentially we now have any number of boxes on each of the 4 sides.
				// Our canvas looks like the following.
				// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
				// B1 is the bottom axis
				// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
				// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
				// an error will be thrown.
				//
				// |----------------------------------------------------|
				// |                  T1 (Full Width)                   |
				// |----------------------------------------------------|
				// |    |    |                 T2                  |    |
				// |    |----|-------------------------------------|----|
				// |    |    | C1 |                           | C2 |    |
				// |    |    |----|                           |----|    |
				// |    |    |                                     |    |
				// | L1 | L2 |           ChartArea (C0)            | R1 |
				// |    |    |                                     |    |
				// |    |    |----|                           |----|    |
				// |    |    | C3 |                           | C4 |    |
				// |    |----|-------------------------------------|----|
				// |    |    |                 B1                  |    |
				// |----------------------------------------------------|
				// |                  B2 (Full Width)                   |
				// |----------------------------------------------------|
				//
				// What we do to find the best sizing, we do the following
				// 1. Determine the minimum size of the chart area.
				// 2. Split the remaining width equally between each vertical axis
				// 3. Split the remaining height equally between each horizontal axis
				// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
				// 5. Adjust the sizes of each axis based on it's minimum reported size.
				// 6. Refit each axis
				// 7. Position each axis in the final location
				// 8. Tell the chart the final location of the chart area
				// 9. Tell any axes that overlay the chart area the positions of the chart area
	
				// Step 1
				var chartWidth = width - leftPadding - rightPadding;
				var chartHeight = height - topPadding - bottomPadding;
				var chartAreaWidth = chartWidth / 2; // min 50%
				var chartAreaHeight = chartHeight / 2; // min 50%
	
				// Step 2
				var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
	
				// Step 3
				var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
	
				// Step 4
				var maxChartAreaWidth = chartWidth;
				var maxChartAreaHeight = chartHeight;
				var minBoxSizes = [];
	
				function getMinimumBoxSize(box) {
					var minSize;
					var isHorizontal = box.isHorizontal();
	
					if (isHorizontal) {
						minSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
						maxChartAreaHeight -= minSize.height;
					} else {
						minSize = box.update(verticalBoxWidth, chartAreaHeight);
						maxChartAreaWidth -= minSize.width;
					}
	
					minBoxSizes.push({
						horizontal: isHorizontal,
						minSize: minSize,
						box: box,
					});
				}
	
				helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
	
				// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
				var maxHorizontalLeftPadding = 0;
				var maxHorizontalRightPadding = 0;
				var maxVerticalTopPadding = 0;
				var maxVerticalBottomPadding = 0;
	
				helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
					if (horizontalBox.getPadding) {
						var boxPadding = horizontalBox.getPadding();
						maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
						maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
					}
				});
	
				helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
					if (verticalBox.getPadding) {
						var boxPadding = verticalBox.getPadding();
						maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
						maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
					}
				});
	
				// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
				// be if the axes are drawn at their minimum sizes.
				// Steps 5 & 6
				var totalLeftBoxesWidth = leftPadding;
				var totalRightBoxesWidth = rightPadding;
				var totalTopBoxesHeight = topPadding;
				var totalBottomBoxesHeight = bottomPadding;
	
				// Function to fit a box
				function fitBox(box) {
					var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
						return minBox.box === box;
					});
	
					if (minBoxSize) {
						if (box.isHorizontal()) {
							var scaleMargin = {
								left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
								right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
								top: 0,
								bottom: 0
							};
	
							// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
							// on the margin. Sometimes they need to increase in size slightly
							box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
						} else {
							box.update(minBoxSize.minSize.width, maxChartAreaHeight);
						}
					}
				}
	
				// Update, and calculate the left and right margins for the horizontal boxes
				helpers.each(leftBoxes.concat(rightBoxes), fitBox);
	
				helpers.each(leftBoxes, function(box) {
					totalLeftBoxesWidth += box.width;
				});
	
				helpers.each(rightBoxes, function(box) {
					totalRightBoxesWidth += box.width;
				});
	
				// Set the Left and Right margins for the horizontal boxes
				helpers.each(topBoxes.concat(bottomBoxes), fitBox);
	
				// Figure out how much margin is on the top and bottom of the vertical boxes
				helpers.each(topBoxes, function(box) {
					totalTopBoxesHeight += box.height;
				});
	
				helpers.each(bottomBoxes, function(box) {
					totalBottomBoxesHeight += box.height;
				});
	
				function finalFitVerticalBox(box) {
					var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
						return minSize.box === box;
					});
	
					var scaleMargin = {
						left: 0,
						right: 0,
						top: totalTopBoxesHeight,
						bottom: totalBottomBoxesHeight
					};
	
					if (minBoxSize) {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
					}
				}
	
				// Let the left layout know the final margin
				helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
	
				// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
				totalLeftBoxesWidth = leftPadding;
				totalRightBoxesWidth = rightPadding;
				totalTopBoxesHeight = topPadding;
				totalBottomBoxesHeight = bottomPadding;
	
				helpers.each(leftBoxes, function(box) {
					totalLeftBoxesWidth += box.width;
				});
	
				helpers.each(rightBoxes, function(box) {
					totalRightBoxesWidth += box.width;
				});
	
				helpers.each(topBoxes, function(box) {
					totalTopBoxesHeight += box.height;
				});
				helpers.each(bottomBoxes, function(box) {
					totalBottomBoxesHeight += box.height;
				});
	
				// We may be adding some padding to account for rotated x axis labels
				var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
				totalLeftBoxesWidth += leftPaddingAddition;
				totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
	
				var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
				totalTopBoxesHeight += topPaddingAddition;
				totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);
	
				// Figure out if our chart area changed. This would occur if the dataset layout label rotation
				// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
				// without calling `fit` again
				var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
				var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
	
				if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
					helpers.each(leftBoxes, function(box) {
						box.height = newMaxChartAreaHeight;
					});
	
					helpers.each(rightBoxes, function(box) {
						box.height = newMaxChartAreaHeight;
					});
	
					helpers.each(topBoxes, function(box) {
						if (!box.options.fullWidth) {
							box.width = newMaxChartAreaWidth;
						}
					});
	
					helpers.each(bottomBoxes, function(box) {
						if (!box.options.fullWidth) {
							box.width = newMaxChartAreaWidth;
						}
					});
	
					maxChartAreaHeight = newMaxChartAreaHeight;
					maxChartAreaWidth = newMaxChartAreaWidth;
				}
	
				// Step 7 - Position the boxes
				var left = leftPadding + leftPaddingAddition;
				var top = topPadding + topPaddingAddition;
	
				function placeBox(box) {
					if (box.isHorizontal()) {
						box.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;
						box.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
						box.top = top;
						box.bottom = top + box.height;
	
						// Move to next point
						top = box.bottom;
	
					} else {
	
						box.left = left;
						box.right = left + box.width;
						box.top = totalTopBoxesHeight;
						box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
	
						// Move to next point
						left = box.right;
					}
				}
	
				helpers.each(leftBoxes.concat(topBoxes), placeBox);
	
				// Account for chart width and height
				left += maxChartAreaWidth;
				top += maxChartAreaHeight;
	
				helpers.each(rightBoxes, placeBox);
				helpers.each(bottomBoxes, placeBox);
	
				// Step 8
				chartInstance.chartArea = {
					left: totalLeftBoxesWidth,
					top: totalTopBoxesHeight,
					right: totalLeftBoxesWidth + maxChartAreaWidth,
					bottom: totalTopBoxesHeight + maxChartAreaHeight
				};
	
				// Step 9
				helpers.each(chartAreaBoxes, function(box) {
					box.left = chartInstance.chartArea.left;
					box.top = chartInstance.chartArea.top;
					box.right = chartInstance.chartArea.right;
					box.bottom = chartInstance.chartArea.bottom;
	
					box.update(maxChartAreaWidth, maxChartAreaHeight);
				});
			}
		};
	};


/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.scaleService = {
			// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
			// use the new chart options to grab the correct scale
			constructors: {},
			// Use a registration function so that we can move to an ES6 map when we no longer need to support
			// old browsers
	
			// Scale config defaults
			defaults: {},
			registerScaleType: function(type, scaleConstructor, defaults) {
				this.constructors[type] = scaleConstructor;
				this.defaults[type] = helpers.clone(defaults);
			},
			getScaleConstructor: function(type) {
				return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
			},
			getScaleDefaults: function(type) {
				// Return the scale defaults merged with the global settings so that we always use the latest ones
				return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};
			},
			updateScaleDefaults: function(type, additions) {
				var defaults = this.defaults;
				if (defaults.hasOwnProperty(type)) {
					defaults[type] = helpers.extend(defaults[type], additions);
				}
			},
			addScalesToLayout: function(chartInstance) {
				// Adds each scale to the chart.boxes array to be sized accordingly
				helpers.each(chartInstance.scales, function(scale) {
					Chart.layoutService.addBox(chartInstance, scale);
				});
			}
		};
	};


/***/ },
/* 77 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		/**
		 * Namespace to hold static tick generation functions
		 * @namespace Chart.Ticks
		 */
		Chart.Ticks = {
			/**
			 * Namespace to hold generators for different types of ticks
			 * @namespace Chart.Ticks.generators
			 */
			generators: {
				/**
				 * Interface for the options provided to the numeric tick generator
				 * @interface INumericTickGenerationOptions
				 */
				/**
				 * The maximum number of ticks to display
				 * @name INumericTickGenerationOptions#maxTicks
				 * @type Number
				 */
				/**
				 * The distance between each tick.
				 * @name INumericTickGenerationOptions#stepSize
				 * @type Number
				 * @optional
				 */
				/**
				 * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
				 * @name INumericTickGenerationOptions#min
				 * @type Number
				 * @optional
				 */
				/**
				 * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
				 * @name INumericTickGenerationOptions#max
				 * @type Number
				 * @optional
				 */
	
				/**
				 * Generate a set of linear ticks
				 * @method Chart.Ticks.generators.linear
				 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
				 * @param dataRange {IRange} the range of the data
				 * @returns {Array<Number>} array of tick values
				 */
				linear: function(generationOptions, dataRange) {
					var ticks = [];
					// To get a "nice" value for the tick spacing, we will use the appropriately named
					// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
					// for details.
	
					var spacing;
					if (generationOptions.stepSize && generationOptions.stepSize > 0) {
						spacing = generationOptions.stepSize;
					} else {
						var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
						spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
					}
					var niceMin = Math.floor(dataRange.min / spacing) * spacing;
					var niceMax = Math.ceil(dataRange.max / spacing) * spacing;
	
					// If min, max and stepSize is set and they make an evenly spaced scale use it.
					if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
						// If very close to our whole number, use it.
						if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
							niceMin = generationOptions.min;
							niceMax = generationOptions.max;
						}
					}
	
					var numSpaces = (niceMax - niceMin) / spacing;
					// If very close to our rounded value, use it.
					if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
						numSpaces = Math.round(numSpaces);
					} else {
						numSpaces = Math.ceil(numSpaces);
					}
	
					// Put the values into the ticks array
					ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
					for (var j = 1; j < numSpaces; ++j) {
						ticks.push(niceMin + (j * spacing));
					}
					ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
	
					return ticks;
				},
	
				/**
				 * Generate a set of logarithmic ticks
				 * @method Chart.Ticks.generators.logarithmic
				 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
				 * @param dataRange {IRange} the range of the data
				 * @returns {Array<Number>} array of tick values
				 */
				logarithmic: function(generationOptions, dataRange) {
					var ticks = [];
					var getValueOrDefault = helpers.getValueOrDefault;
	
					// Figure out what the max number of ticks we can support it is based on the size of
					// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
					// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
					// the graph
					var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
	
					var endExp = Math.floor(helpers.log10(dataRange.max));
					var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
					var exp;
					var significand;
	
					if (tickVal === 0) {
						exp = Math.floor(helpers.log10(dataRange.minNotZero));
						significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
	
						ticks.push(tickVal);
						tickVal = significand * Math.pow(10, exp);
					} else {
						exp = Math.floor(helpers.log10(tickVal));
						significand = Math.floor(tickVal / Math.pow(10, exp));
					}
	
					do {
						ticks.push(tickVal);
	
						++significand;
						if (significand === 10) {
							significand = 1;
							++exp;
						}
	
						tickVal = significand * Math.pow(10, exp);
					} while (exp < endExp || (exp === endExp && significand < endSignificand));
	
					var lastTick = getValueOrDefault(generationOptions.max, tickVal);
					ticks.push(lastTick);
	
					return ticks;
				}
			},
	
			/**
			 * Namespace to hold formatters for different types of ticks
			 * @namespace Chart.Ticks.formatters
			 */
			formatters: {
				/**
				 * Formatter for value labels
				 * @method Chart.Ticks.formatters.values
				 * @param value the value to display
				 * @return {String|Array} the label to display
				 */
				values: function(value) {
					return helpers.isArray(value) ? value : '' + value;
				},
	
				/**
				 * Formatter for linear numeric ticks
				 * @method Chart.Ticks.formatters.linear
				 * @param tickValue {Number} the value to be formatted
				 * @param index {Number} the position of the tickValue parameter in the ticks array
				 * @param ticks {Array<Number>} the list of ticks being converted
				 * @return {String} string representation of the tickValue parameter
				 */
				linear: function(tickValue, index, ticks) {
					// If we have lots of ticks, don't use the ones
					var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
	
					// If we have a number like 2.5 as the delta, figure out how many decimal places we need
					if (Math.abs(delta) > 1) {
						if (tickValue !== Math.floor(tickValue)) {
							// not an integer
							delta = tickValue - Math.floor(tickValue);
						}
					}
	
					var logDelta = helpers.log10(Math.abs(delta));
					var tickString = '';
	
					if (tickValue !== 0) {
						var numDecimal = -1 * Math.floor(logDelta);
						numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
						tickString = tickValue.toFixed(numDecimal);
					} else {
						tickString = '0'; // never show decimal places for 0
					}
	
					return tickString;
				},
	
				logarithmic: function(tickValue, index, ticks) {
					var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));
	
					if (tickValue === 0) {
						return '0';
					} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
						return tickValue.toExponential();
					}
					return '';
				}
			}
		};
	};


/***/ },
/* 78 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.scale = {
			display: true,
			position: 'left',
	
			// grid line settings
			gridLines: {
				display: true,
				color: 'rgba(0, 0, 0, 0.1)',
				lineWidth: 1,
				drawBorder: true,
				drawOnChartArea: true,
				drawTicks: true,
				tickMarkLength: 10,
				zeroLineWidth: 1,
				zeroLineColor: 'rgba(0,0,0,0.25)',
				offsetGridLines: false,
				borderDash: [],
				borderDashOffset: 0.0
			},
	
			// scale label
			scaleLabel: {
				// actual label
				labelString: '',
	
				// display property
				display: false
			},
	
			// label settings
			ticks: {
				beginAtZero: false,
				minRotation: 0,
				maxRotation: 50,
				mirror: false,
				padding: 0,
				reverse: false,
				display: true,
				autoSkip: true,
				autoSkipPadding: 0,
				labelOffset: 0,
				// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
				callback: Chart.Ticks.formatters.values
			}
		};
	
		function computeTextSize(context, tick, font) {
			return helpers.isArray(tick) ?
				helpers.longestText(context, font, tick) :
				context.measureText(tick).width;
		}
	
		function parseFontOptions(options) {
			var getValueOrDefault = helpers.getValueOrDefault;
			var globalDefaults = Chart.defaults.global;
			var size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
			var style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
			var family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
	
			return {
				size: size,
				style: style,
				family: family,
				font: helpers.fontString(size, style, family)
			};
		}
	
		Chart.Scale = Chart.Element.extend({
			/**
			 * Get the padding needed for the scale
			 * @method getPadding
			 * @private
			 * @returns {Padding} the necessary padding
			 */
			getPadding: function() {
				var me = this;
				return {
					left: me.paddingLeft || 0,
					top: me.paddingTop || 0,
					right: me.paddingRight || 0,
					bottom: me.paddingBottom || 0
				};
			},
	
			// These methods are ordered by lifecyle. Utilities then follow.
			// Any function defined here is inherited by all scale types.
			// Any function can be extended by the scale type
	
			beforeUpdate: function() {
				helpers.callCallback(this.options.beforeUpdate, [this]);
			},
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
	
				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();
	
				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = helpers.extend({
					left: 0,
					right: 0,
					top: 0,
					bottom: 0
				}, margins);
				me.longestTextCache = me.longestTextCache || {};
	
				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
	
				// Data min/max
				me.beforeDataLimits();
				me.determineDataLimits();
				me.afterDataLimits();
	
				// Ticks
				me.beforeBuildTicks();
				me.buildTicks();
				me.afterBuildTicks();
	
				me.beforeTickToLabelConversion();
				me.convertTicksToLabels();
				me.afterTickToLabelConversion();
	
				// Tick Rotation
				me.beforeCalculateTickRotation();
				me.calculateTickRotation();
				me.afterCalculateTickRotation();
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();
	
				return me.minSize;
	
			},
			afterUpdate: function() {
				helpers.callCallback(this.options.afterUpdate, [this]);
			},
	
			//
	
			beforeSetDimensions: function() {
				helpers.callCallback(this.options.beforeSetDimensions, [this]);
			},
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;
	
					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}
	
				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
			},
			afterSetDimensions: function() {
				helpers.callCallback(this.options.afterSetDimensions, [this]);
			},
	
			// Data limits
			beforeDataLimits: function() {
				helpers.callCallback(this.options.beforeDataLimits, [this]);
			},
			determineDataLimits: helpers.noop,
			afterDataLimits: function() {
				helpers.callCallback(this.options.afterDataLimits, [this]);
			},
	
			//
			beforeBuildTicks: function() {
				helpers.callCallback(this.options.beforeBuildTicks, [this]);
			},
			buildTicks: helpers.noop,
			afterBuildTicks: function() {
				helpers.callCallback(this.options.afterBuildTicks, [this]);
			},
	
			beforeTickToLabelConversion: function() {
				helpers.callCallback(this.options.beforeTickToLabelConversion, [this]);
			},
			convertTicksToLabels: function() {
				var me = this;
				// Convert ticks to strings
				var tickOpts = me.options.ticks;
				me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);
			},
			afterTickToLabelConversion: function() {
				helpers.callCallback(this.options.afterTickToLabelConversion, [this]);
			},
	
			//
	
			beforeCalculateTickRotation: function() {
				helpers.callCallback(this.options.beforeCalculateTickRotation, [this]);
			},
			calculateTickRotation: function() {
				var me = this;
				var context = me.ctx;
				var tickOpts = me.options.ticks;
	
				// Get the width of each grid by calculating the difference
				// between x offsets between 0 and 1.
				var tickFont = parseFontOptions(tickOpts);
				context.font = tickFont.font;
	
				var labelRotation = tickOpts.minRotation || 0;
	
				if (me.options.display && me.isHorizontal()) {
					var originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);
					var labelWidth = originalLabelWidth;
					var cosRotation;
					var sinRotation;
	
					// Allow 3 pixels x2 padding either side for label readability
					var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
	
					// Max label rotation can be set or default to 90 - also act as a loop counter
					while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
						var angleRadians = helpers.toRadians(labelRotation);
						cosRotation = Math.cos(angleRadians);
						sinRotation = Math.sin(angleRadians);
	
						if (sinRotation * originalLabelWidth > me.maxHeight) {
							// go back one step
							labelRotation--;
							break;
						}
	
						labelRotation++;
						labelWidth = cosRotation * originalLabelWidth;
					}
				}
	
				me.labelRotation = labelRotation;
			},
			afterCalculateTickRotation: function() {
				helpers.callCallback(this.options.afterCalculateTickRotation, [this]);
			},
	
			//
	
			beforeFit: function() {
				helpers.callCallback(this.options.beforeFit, [this]);
			},
			fit: function() {
				var me = this;
				// Reset
				var minSize = me.minSize = {
					width: 0,
					height: 0
				};
	
				var opts = me.options;
				var tickOpts = opts.ticks;
				var scaleLabelOpts = opts.scaleLabel;
				var gridLineOpts = opts.gridLines;
				var display = opts.display;
				var isHorizontal = me.isHorizontal();
	
				var tickFont = parseFontOptions(tickOpts);
				var scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;
				var tickMarkLength = opts.gridLines.tickMarkLength;
	
				// Width
				if (isHorizontal) {
					// subtract the margins to line up with the chartArea if we are a full width scale
					minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
				} else {
					minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
				}
	
				// height
				if (isHorizontal) {
					minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
				} else {
					minSize.height = me.maxHeight; // fill all the height
				}
	
				// Are we showing a title for the scale?
				if (scaleLabelOpts.display && display) {
					if (isHorizontal) {
						minSize.height += scaleLabelFontSize;
					} else {
						minSize.width += scaleLabelFontSize;
					}
				}
	
				// Don't bother fitting the ticks if we are not showing them
				if (tickOpts.display && display) {
					var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);
					var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);
					var lineSpace = tickFont.size * 0.5;
	
					if (isHorizontal) {
						// A horizontal axis is more constrained by the height.
						me.longestLabelWidth = largestTextWidth;
	
						var angleRadians = helpers.toRadians(me.labelRotation);
						var cosRotation = Math.cos(angleRadians);
						var sinRotation = Math.sin(angleRadians);
	
						// TODO - improve this calculation
						var labelHeight = (sinRotation * largestTextWidth)
							+ (tickFont.size * tallestLabelHeightInLines)
							+ (lineSpace * tallestLabelHeightInLines);
	
						minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);
						me.ctx.font = tickFont.font;
	
						var firstTick = me.ticks[0];
						var firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);
	
						var lastTick = me.ticks[me.ticks.length - 1];
						var lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);
	
						// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated
						// by the font height
						if (me.labelRotation !== 0) {
							me.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
							me.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;
						} else {
							me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
							me.paddingRight = lastLabelWidth / 2 + 3;
						}
					} else {
						// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first
						// Account for padding
	
						if (tickOpts.mirror) {
							largestTextWidth = 0;
						} else {
							largestTextWidth += me.options.ticks.padding;
						}
						minSize.width += largestTextWidth;
						me.paddingTop = tickFont.size / 2;
						me.paddingBottom = tickFont.size / 2;
					}
				}
	
				me.handleMargins();
	
				me.width = minSize.width;
				me.height = minSize.height;
			},
	
			/**
			 * Handle margins and padding interactions
			 * @private
			 */
			handleMargins: function() {
				var me = this;
				if (me.margins) {
					me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
					me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
					me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
					me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
				}
			},
	
			afterFit: function() {
				helpers.callCallback(this.options.afterFit, [this]);
			},
	
			// Shared Methods
			isHorizontal: function() {
				return this.options.position === 'top' || this.options.position === 'bottom';
			},
			isFullWidth: function() {
				return (this.options.fullWidth);
			},
	
			// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
			getRightValue: function(rawValue) {
				// Null and undefined values first
				if (rawValue === null || typeof(rawValue) === 'undefined') {
					return NaN;
				}
				// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
				if (typeof(rawValue) === 'number' && !isFinite(rawValue)) {
					return NaN;
				}
				// If it is in fact an object, dive in one more level
				if (typeof(rawValue) === 'object') {
					if ((rawValue instanceof Date) || (rawValue.isValid)) {
						return rawValue;
					}
					return this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);
				}
	
				// Value is good, return it
				return rawValue;
			},
	
			// Used to get the value to display in the tooltip for the data at the given index
			// function getLabelForIndex(index, datasetIndex)
			getLabelForIndex: helpers.noop,
	
			// Used to get data value locations.  Value can either be an index or a numerical value
			getPixelForValue: helpers.noop,
	
			// Used to get the data value from a given pixel. This is the inverse of getPixelForValue
			getValueForPixel: helpers.noop,
	
			// Used for tick location, should
			getPixelForTick: function(index, includeOffset) {
				var me = this;
				if (me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
					var pixel = (tickWidth * index) + me.paddingLeft;
	
					if (includeOffset) {
						pixel += tickWidth / 2;
					}
	
					var finalVal = me.left + Math.round(pixel);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
				return me.top + (index * (innerHeight / (me.ticks.length - 1)));
			},
	
			// Utility for getting the pixel location of a percentage of scale
			getPixelForDecimal: function(decimal /* , includeOffset*/) {
				var me = this;
				if (me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var valueOffset = (innerWidth * decimal) + me.paddingLeft;
	
					var finalVal = me.left + Math.round(valueOffset);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				return me.top + (decimal * me.height);
			},
	
			getBasePixel: function() {
				return this.getPixelForValue(this.getBaseValue());
			},
	
			getBaseValue: function() {
				var me = this;
				var min = me.min;
				var max = me.max;
	
				return me.beginAtZero ? 0:
					min < 0 && max < 0? max :
					min > 0 && max > 0? min :
					0;
			},
	
			// Actually draw the scale on the canvas
			// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
			draw: function(chartArea) {
				var me = this;
				var options = me.options;
				if (!options.display) {
					return;
				}
	
				var context = me.ctx;
				var globalDefaults = Chart.defaults.global;
				var optionTicks = options.ticks;
				var gridLines = options.gridLines;
				var scaleLabel = options.scaleLabel;
	
				var isRotated = me.labelRotation !== 0;
				var skipRatio;
				var useAutoskipper = optionTicks.autoSkip;
				var isHorizontal = me.isHorizontal();
	
				// figure out the maximum number of gridlines to show
				var maxTicks;
				if (optionTicks.maxTicksLimit) {
					maxTicks = optionTicks.maxTicksLimit;
				}
	
				var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
				var tickFont = parseFontOptions(optionTicks);
	
				var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
				var borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
				var borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
	
				var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
				var scaleLabelFont = parseFontOptions(scaleLabel);
	
				var labelRotationRadians = helpers.toRadians(me.labelRotation);
				var cosRotation = Math.cos(labelRotationRadians);
				var longestRotatedLabel = me.longestLabelWidth * cosRotation;
	
				// Make sure we draw text in the correct color and font
				context.fillStyle = tickFontColor;
	
				var itemsToDraw = [];
	
				if (isHorizontal) {
					skipRatio = false;
	
					// Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation
					// See #2584
					if (isRotated) {
						longestRotatedLabel /= 2;
					}
	
					if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {
						skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));
					}
	
					// if they defined a max number of optionTicks,
					// increase skipRatio until that number is met
					if (maxTicks && me.ticks.length > maxTicks) {
						while (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {
							if (!skipRatio) {
								skipRatio = 1;
							}
							skipRatio += 1;
						}
					}
	
					if (!useAutoskipper) {
						skipRatio = false;
					}
				}
	
	
				var xTickStart = options.position === 'right' ? me.left : me.right - tl;
				var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
				var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
				var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;
	
				helpers.each(me.ticks, function(label, index) {
					// If the callback returned a null or undefined value, do not draw this line
					if (label === undefined || label === null) {
						return;
					}
	
					var isLastTick = me.ticks.length === index + 1;
	
					// Since we always show the last tick,we need may need to hide the last shown one before
					var shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);
					if (shouldSkip && !isLastTick || (label === undefined || label === null)) {
						return;
					}
	
					var lineWidth, lineColor;
					if (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {
						// Draw the first index specially
						lineWidth = gridLines.zeroLineWidth;
						lineColor = gridLines.zeroLineColor;
					} else {
						lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);
						lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);
					}
	
					// Common properties
					var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
					var textAlign = 'middle';
					var textBaseline = 'middle';
	
					if (isHorizontal) {
	
						if (options.position === 'bottom') {
							// bottom
							textBaseline = !isRotated? 'top':'middle';
							textAlign = !isRotated? 'center': 'right';
							labelY = me.top + tl;
						} else {
							// top
							textBaseline = !isRotated? 'bottom':'middle';
							textAlign = !isRotated? 'center': 'left';
							labelY = me.bottom - tl;
						}
	
						var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines
						labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)
	
						tx1 = tx2 = x1 = x2 = xLineValue;
						ty1 = yTickStart;
						ty2 = yTickEnd;
						y1 = chartArea.top;
						y2 = chartArea.bottom;
					} else {
						var isLeft = options.position === 'left';
						var tickPadding = optionTicks.padding;
						var labelXOffset;
	
						if (optionTicks.mirror) {
							textAlign = isLeft ? 'left' : 'right';
							labelXOffset = tickPadding;
						} else {
							textAlign = isLeft ? 'right' : 'left';
							labelXOffset = tl + tickPadding;
						}
	
						labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;
	
						var yLineValue = me.getPixelForTick(index); // xvalues for grid lines
						yLineValue += helpers.aliasPixel(lineWidth);
						labelY = me.getPixelForTick(index, gridLines.offsetGridLines);
	
						tx1 = xTickStart;
						tx2 = xTickEnd;
						x1 = chartArea.left;
						x2 = chartArea.right;
						ty1 = ty2 = y1 = y2 = yLineValue;
					}
	
					itemsToDraw.push({
						tx1: tx1,
						ty1: ty1,
						tx2: tx2,
						ty2: ty2,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
						labelX: labelX,
						labelY: labelY,
						glWidth: lineWidth,
						glColor: lineColor,
						glBorderDash: borderDash,
						glBorderDashOffset: borderDashOffset,
						rotation: -1 * labelRotationRadians,
						label: label,
						textBaseline: textBaseline,
						textAlign: textAlign
					});
				});
	
				// Draw all of the tick labels, tick marks, and grid lines at the correct places
				helpers.each(itemsToDraw, function(itemToDraw) {
					if (gridLines.display) {
						context.save();
						context.lineWidth = itemToDraw.glWidth;
						context.strokeStyle = itemToDraw.glColor;
						if (context.setLineDash) {
							context.setLineDash(itemToDraw.glBorderDash);
							context.lineDashOffset = itemToDraw.glBorderDashOffset;
						}
	
						context.beginPath();
	
						if (gridLines.drawTicks) {
							context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
							context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
						}
	
						if (gridLines.drawOnChartArea) {
							context.moveTo(itemToDraw.x1, itemToDraw.y1);
							context.lineTo(itemToDraw.x2, itemToDraw.y2);
						}
	
						context.stroke();
						context.restore();
					}
	
					if (optionTicks.display) {
						context.save();
						context.translate(itemToDraw.labelX, itemToDraw.labelY);
						context.rotate(itemToDraw.rotation);
						context.font = tickFont.font;
						context.textBaseline = itemToDraw.textBaseline;
						context.textAlign = itemToDraw.textAlign;
	
						var label = itemToDraw.label;
						if (helpers.isArray(label)) {
							for (var i = 0, y = 0; i < label.length; ++i) {
								// We just make sure the multiline element is a string here..
								context.fillText('' + label[i], 0, y);
								// apply same lineSpacing as calculated @ L#320
								y += (tickFont.size * 1.5);
							}
						} else {
							context.fillText(label, 0, 0);
						}
						context.restore();
					}
				});
	
				if (scaleLabel.display) {
					// Draw the scale label
					var scaleLabelX;
					var scaleLabelY;
					var rotation = 0;
	
					if (isHorizontal) {
						scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
						scaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);
					} else {
						var isLeft = options.position === 'left';
						scaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);
						scaleLabelY = me.top + ((me.bottom - me.top) / 2);
						rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
					}
	
					context.save();
					context.translate(scaleLabelX, scaleLabelY);
					context.rotate(rotation);
					context.textAlign = 'center';
					context.textBaseline = 'middle';
					context.fillStyle = scaleLabelFontColor; // render in correct colour
					context.font = scaleLabelFont.font;
					context.fillText(scaleLabel.labelString, 0, 0);
					context.restore();
				}
	
				if (gridLines.drawBorder) {
					// Draw the line at the edge of the axis
					context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);
					context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);
					var x1 = me.left,
						x2 = me.right,
						y1 = me.top,
						y2 = me.bottom;
	
					var aliasPixel = helpers.aliasPixel(context.lineWidth);
					if (isHorizontal) {
						y1 = y2 = options.position === 'top' ? me.bottom : me.top;
						y1 += aliasPixel;
						y2 += aliasPixel;
					} else {
						x1 = x2 = options.position === 'left' ? me.right : me.left;
						x1 += aliasPixel;
						x2 += aliasPixel;
					}
	
					context.beginPath();
					context.moveTo(x1, y1);
					context.lineTo(x2, y2);
					context.stroke();
				}
			}
		});
	};


/***/ },
/* 79 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.global.title = {
			display: false,
			position: 'top',
			fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)
	
			fontStyle: 'bold',
			padding: 10,
	
			// actual title
			text: ''
		};
	
		var noop = helpers.noop;
		Chart.Title = Chart.Element.extend({
	
			initialize: function(config) {
				var me = this;
				helpers.extend(me, config);
	
				// Contains hit boxes for each dataset (in dataset order)
				me.legendHitBoxes = [];
			},
	
			// These methods are ordered by lifecycle. Utilities then follow.
	
			beforeUpdate: noop,
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
	
				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();
	
				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = margins;
	
				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
				// Labels
				me.beforeBuildLabels();
				me.buildLabels();
				me.afterBuildLabels();
	
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();
	
				return me.minSize;
	
			},
			afterUpdate: noop,
	
			//
	
			beforeSetDimensions: noop,
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;
	
					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}
	
				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
	
				// Reset minSize
				me.minSize = {
					width: 0,
					height: 0
				};
			},
			afterSetDimensions: noop,
	
			//
	
			beforeBuildLabels: noop,
			buildLabels: noop,
			afterBuildLabels: noop,
	
			//
	
			beforeFit: noop,
			fit: function() {
				var me = this,
					valueOrDefault = helpers.getValueOrDefault,
					opts = me.options,
					globalDefaults = Chart.defaults.global,
					display = opts.display,
					fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
					minSize = me.minSize;
	
				if (me.isHorizontal()) {
					minSize.width = me.maxWidth; // fill all the width
					minSize.height = display ? fontSize + (opts.padding * 2) : 0;
				} else {
					minSize.width = display ? fontSize + (opts.padding * 2) : 0;
					minSize.height = me.maxHeight; // fill all the height
				}
	
				me.width = minSize.width;
				me.height = minSize.height;
	
			},
			afterFit: noop,
	
			// Shared Methods
			isHorizontal: function() {
				var pos = this.options.position;
				return pos === 'top' || pos === 'bottom';
			},
	
			// Actually draw the title block on the canvas
			draw: function() {
				var me = this,
					ctx = me.ctx,
					valueOrDefault = helpers.getValueOrDefault,
					opts = me.options,
					globalDefaults = Chart.defaults.global;
	
				if (opts.display) {
					var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
						fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),
						fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),
						titleFont = helpers.fontString(fontSize, fontStyle, fontFamily),
						rotation = 0,
						titleX,
						titleY,
						top = me.top,
						left = me.left,
						bottom = me.bottom,
						right = me.right,
						maxWidth;
	
					ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
					ctx.font = titleFont;
	
					// Horizontal
					if (me.isHorizontal()) {
						titleX = left + ((right - left) / 2); // midpoint of the width
						titleY = top + ((bottom - top) / 2); // midpoint of the height
						maxWidth = right - left;
					} else {
						titleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);
						titleY = top + ((bottom - top) / 2);
						maxWidth = bottom - top;
						rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
					}
	
					ctx.save();
					ctx.translate(titleX, titleY);
					ctx.rotate(rotation);
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText(opts.text, 0, 0, maxWidth);
					ctx.restore();
				}
			}
		});
	
		function createNewTitleBlockAndAttach(chartInstance, titleOpts) {
			var title = new Chart.Title({
				ctx: chartInstance.chart.ctx,
				options: titleOpts,
				chart: chartInstance
			});
			chartInstance.titleBlock = title;
			Chart.layoutService.addBox(chartInstance, title);
		}
	
		// Register the title plugin
		Chart.plugins.register({
			beforeInit: function(chartInstance) {
				var titleOpts = chartInstance.options.title;
	
				if (titleOpts) {
					createNewTitleBlockAndAttach(chartInstance, titleOpts);
				}
			},
			beforeUpdate: function(chartInstance) {
				var titleOpts = chartInstance.options.title;
	
				if (titleOpts) {
					titleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);
	
					if (chartInstance.titleBlock) {
						chartInstance.titleBlock.options = titleOpts;
					} else {
						createNewTitleBlockAndAttach(chartInstance, titleOpts);
					}
				} else {
					Chart.layoutService.removeBox(chartInstance, chartInstance.titleBlock);
					delete chartInstance.titleBlock;
				}
			}
		});
	};


/***/ },
/* 80 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
		var noop = helpers.noop;
	
		Chart.defaults.global.legend = {
	
			display: true,
			position: 'top',
			fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)
			reverse: false,
	
			// a callback that will handle
			onClick: function(e, legendItem) {
				var index = legendItem.datasetIndex;
				var ci = this.chart;
				var meta = ci.getDatasetMeta(index);
	
				// See controller.isDatasetVisible comment
				meta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;
	
				// We hid a dataset ... rerender the chart
				ci.update();
			},
	
			onHover: null,
	
			labels: {
				boxWidth: 40,
				padding: 10,
				// Generates labels shown in the legend
				// Valid properties to return:
				// text : text to display
				// fillStyle : fill of coloured box
				// strokeStyle: stroke of coloured box
				// hidden : if this legend item refers to a hidden item
				// lineCap : cap style for line
				// lineDash
				// lineDashOffset :
				// lineJoin :
				// lineWidth :
				generateLabels: function(chart) {
					var data = chart.data;
					return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
						return {
							text: dataset.label,
							fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
							hidden: !chart.isDatasetVisible(i),
							lineCap: dataset.borderCapStyle,
							lineDash: dataset.borderDash,
							lineDashOffset: dataset.borderDashOffset,
							lineJoin: dataset.borderJoinStyle,
							lineWidth: dataset.borderWidth,
							strokeStyle: dataset.borderColor,
							pointStyle: dataset.pointStyle,
	
							// Below is extra data used for toggling the datasets
							datasetIndex: i
						};
					}, this) : [];
				}
			}
		};
	
		/**
		 * Helper function to get the box width based on the usePointStyle option
		 * @param labelopts {Object} the label options on the legend
		 * @param fontSize {Number} the label font size
		 * @return {Number} width of the color box area
		 */
		function getBoxWidth(labelOpts, fontSize) {
			return labelOpts.usePointStyle ?
				fontSize * Math.SQRT2 :
				labelOpts.boxWidth;
		}
	
		Chart.Legend = Chart.Element.extend({
	
			initialize: function(config) {
				helpers.extend(this, config);
	
				// Contains hit boxes for each dataset (in dataset order)
				this.legendHitBoxes = [];
	
				// Are we in doughnut mode which has a different data type
				this.doughnutMode = false;
			},
	
			// These methods are ordered by lifecycle. Utilities then follow.
			// Any function defined here is inherited by all legend types.
			// Any function can be extended by the legend type
	
			beforeUpdate: noop,
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
	
				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();
	
				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = margins;
	
				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
				// Labels
				me.beforeBuildLabels();
				me.buildLabels();
				me.afterBuildLabels();
	
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();
	
				return me.minSize;
			},
			afterUpdate: noop,
	
			//
	
			beforeSetDimensions: noop,
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;
	
					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}
	
				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
	
				// Reset minSize
				me.minSize = {
					width: 0,
					height: 0
				};
			},
			afterSetDimensions: noop,
	
			//
	
			beforeBuildLabels: noop,
			buildLabels: function() {
				var me = this;
				var labelOpts = me.options.labels;
				var legendItems = labelOpts.generateLabels.call(me, me.chart);
	
				if (labelOpts.filter) {
					legendItems = legendItems.filter(function(item) {
						return labelOpts.filter(item, me.chart.data);
					});
				}
	
				if (me.options.reverse) {
					legendItems.reverse();
				}
	
				me.legendItems = legendItems;
			},
			afterBuildLabels: noop,
	
			//
	
			beforeFit: noop,
			fit: function() {
				var me = this;
				var opts = me.options;
				var labelOpts = opts.labels;
				var display = opts.display;
	
				var ctx = me.ctx;
	
				var globalDefault = Chart.defaults.global,
					itemOrDefault = helpers.getValueOrDefault,
					fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
					fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
					fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
					labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
	
				// Reset hit boxes
				var hitboxes = me.legendHitBoxes = [];
	
				var minSize = me.minSize;
				var isHorizontal = me.isHorizontal();
	
				if (isHorizontal) {
					minSize.width = me.maxWidth; // fill all the width
					minSize.height = display ? 10 : 0;
				} else {
					minSize.width = display ? 10 : 0;
					minSize.height = me.maxHeight; // fill all the height
				}
	
				// Increase sizes here
				if (display) {
					ctx.font = labelFont;
	
					if (isHorizontal) {
						// Labels
	
						// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
						var lineWidths = me.lineWidths = [0];
						var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;
	
						ctx.textAlign = 'left';
						ctx.textBaseline = 'top';
	
						helpers.each(me.legendItems, function(legendItem, i) {
							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
	
							if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
								totalHeight += fontSize + (labelOpts.padding);
								lineWidths[lineWidths.length] = me.left;
							}
	
							// Store the hitbox width and height here. Final position will be updated in `draw`
							hitboxes[i] = {
								left: 0,
								top: 0,
								width: width,
								height: fontSize
							};
	
							lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
						});
	
						minSize.height += totalHeight;
	
					} else {
						var vPadding = labelOpts.padding;
						var columnWidths = me.columnWidths = [];
						var totalWidth = labelOpts.padding;
						var currentColWidth = 0;
						var currentColHeight = 0;
						var itemHeight = fontSize + vPadding;
	
						helpers.each(me.legendItems, function(legendItem, i) {
							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
	
							// If too tall, go to new column
							if (currentColHeight + itemHeight > minSize.height) {
								totalWidth += currentColWidth + labelOpts.padding;
								columnWidths.push(currentColWidth); // previous column width
	
								currentColWidth = 0;
								currentColHeight = 0;
							}
	
							// Get max width
							currentColWidth = Math.max(currentColWidth, itemWidth);
							currentColHeight += itemHeight;
	
							// Store the hitbox width and height here. Final position will be updated in `draw`
							hitboxes[i] = {
								left: 0,
								top: 0,
								width: itemWidth,
								height: fontSize
							};
						});
	
						totalWidth += currentColWidth;
						columnWidths.push(currentColWidth);
						minSize.width += totalWidth;
					}
				}
	
				me.width = minSize.width;
				me.height = minSize.height;
			},
			afterFit: noop,
	
			// Shared Methods
			isHorizontal: function() {
				return this.options.position === 'top' || this.options.position === 'bottom';
			},
	
			// Actually draw the legend on the canvas
			draw: function() {
				var me = this;
				var opts = me.options;
				var labelOpts = opts.labels;
				var globalDefault = Chart.defaults.global,
					lineDefault = globalDefault.elements.line,
					legendWidth = me.width,
					lineWidths = me.lineWidths;
	
				if (opts.display) {
					var ctx = me.ctx,
						cursor,
						itemOrDefault = helpers.getValueOrDefault,
						fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),
						fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
						fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
						fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
						labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
	
					// Canvas setup
					ctx.textAlign = 'left';
					ctx.textBaseline = 'top';
					ctx.lineWidth = 0.5;
					ctx.strokeStyle = fontColor; // for strikethrough effect
					ctx.fillStyle = fontColor; // render in correct colour
					ctx.font = labelFont;
	
					var boxWidth = getBoxWidth(labelOpts, fontSize),
						hitboxes = me.legendHitBoxes;
	
					// current position
					var drawLegendBox = function(x, y, legendItem) {
						if (isNaN(boxWidth) || boxWidth <= 0) {
							return;
						}
	
						// Set the ctx for the box
						ctx.save();
	
						ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
						ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
						ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
						ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
						ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
						ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
						var isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);
	
						if (ctx.setLineDash) {
							// IE 9 and 10 do not support line dash
							ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));
						}
	
						if (opts.labels && opts.labels.usePointStyle) {
							// Recalculate x and y for drawPoint() because its expecting
							// x and y to be center of figure (instead of top left)
							var radius = fontSize * Math.SQRT2 / 2;
							var offSet = radius / Math.SQRT2;
							var centerX = x + offSet;
							var centerY = y + offSet;
	
							// Draw pointStyle as legend symbol
							Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
						} else {
							// Draw box as legend symbol
							if (!isLineWidthZero) {
								ctx.strokeRect(x, y, boxWidth, fontSize);
							}
							ctx.fillRect(x, y, boxWidth, fontSize);
						}
	
						ctx.restore();
					};
					var fillText = function(x, y, legendItem, textWidth) {
						ctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);
	
						if (legendItem.hidden) {
							// Strikethrough the text if hidden
							ctx.beginPath();
							ctx.lineWidth = 2;
							ctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));
							ctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));
							ctx.stroke();
						}
					};
	
					// Horizontal
					var isHorizontal = me.isHorizontal();
					if (isHorizontal) {
						cursor = {
							x: me.left + ((legendWidth - lineWidths[0]) / 2),
							y: me.top + labelOpts.padding,
							line: 0
						};
					} else {
						cursor = {
							x: me.left + labelOpts.padding,
							y: me.top + labelOpts.padding,
							line: 0
						};
					}
	
					var itemHeight = fontSize + labelOpts.padding;
					helpers.each(me.legendItems, function(legendItem, i) {
						var textWidth = ctx.measureText(legendItem.text).width,
							width = boxWidth + (fontSize / 2) + textWidth,
							x = cursor.x,
							y = cursor.y;
	
						if (isHorizontal) {
							if (x + width >= legendWidth) {
								y = cursor.y += itemHeight;
								cursor.line++;
								x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
							}
						} else if (y + itemHeight > me.bottom) {
							x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
							y = cursor.y = me.top + labelOpts.padding;
							cursor.line++;
						}
	
						drawLegendBox(x, y, legendItem);
	
						hitboxes[i].left = x;
						hitboxes[i].top = y;
	
						// Fill the actual label
						fillText(x, y, legendItem, textWidth);
	
						if (isHorizontal) {
							cursor.x += width + (labelOpts.padding);
						} else {
							cursor.y += itemHeight;
						}
	
					});
				}
			},
	
			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @return {Boolean} true if a change occured
			 */
			handleEvent: function(e) {
				var me = this;
				var opts = me.options;
				var type = e.type === 'mouseup' ? 'click' : e.type;
				var changed = false;
	
				if (type === 'mousemove') {
					if (!opts.onHover) {
						return;
					}
				} else if (type === 'click') {
					if (!opts.onClick) {
						return;
					}
				} else {
					return;
				}
	
				// Chart event already has relative position in it
				var x = e.x,
					y = e.y;
	
				if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
					// See if we are touching one of the dataset boxes
					var lh = me.legendHitBoxes;
					for (var i = 0; i < lh.length; ++i) {
						var hitBox = lh[i];
	
						if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
							// Touching an element
							if (type === 'click') {
								// use e.native for backwards compatibility
								opts.onClick.call(me, e.native, me.legendItems[i]);
								changed = true;
								break;
							} else if (type === 'mousemove') {
								// use e.native for backwards compatibility
								opts.onHover.call(me, e.native, me.legendItems[i]);
								changed = true;
								break;
							}
						}
					}
				}
	
				return changed;
			}
		});
	
		function createNewLegendAndAttach(chartInstance, legendOpts) {
			var legend = new Chart.Legend({
				ctx: chartInstance.chart.ctx,
				options: legendOpts,
				chart: chartInstance
			});
			chartInstance.legend = legend;
			Chart.layoutService.addBox(chartInstance, legend);
		}
	
		// Register the legend plugin
		Chart.plugins.register({
			beforeInit: function(chartInstance) {
				var legendOpts = chartInstance.options.legend;
	
				if (legendOpts) {
					createNewLegendAndAttach(chartInstance, legendOpts);
				}
			},
			beforeUpdate: function(chartInstance) {
				var legendOpts = chartInstance.options.legend;
	
				if (legendOpts) {
					legendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);
	
					if (chartInstance.legend) {
						chartInstance.legend.options = legendOpts;
					} else {
						createNewLegendAndAttach(chartInstance, legendOpts);
					}
				} else {
					Chart.layoutService.removeBox(chartInstance, chartInstance.legend);
					delete chartInstance.legend;
				}
			},
			afterEvent: function(chartInstance, e) {
				var legend = chartInstance.legend;
				if (legend) {
					legend.handleEvent(e);
				}
			}
		});
	};


/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
		var helpers = Chart.helpers;
	
		/**
		 * Helper function to get relative position for an event
		 * @param {Event|IEvent} event - The event to get the position for
		 * @param {Chart} chart - The chart
		 * @returns {Point} the event position
		 */
		function getRelativePosition(e, chart) {
			if (e.native) {
				return {
					x: e.x,
					y: e.y
				};
			}
	
			return helpers.getRelativePosition(e, chart);
		}
	
		/**
		 * Helper function to traverse all of the visible elements in the chart
		 * @param chart {chart} the chart
		 * @param handler {Function} the callback to execute for each visible item
		 */
		function parseVisibleItems(chart, handler) {
			var datasets = chart.data.datasets;
			var meta, i, j, ilen, jlen;
	
			for (i = 0, ilen = datasets.length; i < ilen; ++i) {
				if (!chart.isDatasetVisible(i)) {
					continue;
				}
	
				meta = chart.getDatasetMeta(i);
				for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
					var element = meta.data[j];
					if (!element._view.skip) {
						handler(element);
					}
				}
			}
		}
	
		/**
		 * Helper function to get the items that intersect the event position
		 * @param items {ChartElement[]} elements to filter
		 * @param position {Point} the point to be nearest to
		 * @return {ChartElement[]} the nearest items
		 */
		function getIntersectItems(chart, position) {
			var elements = [];
	
			parseVisibleItems(chart, function(element) {
				if (element.inRange(position.x, position.y)) {
					elements.push(element);
				}
			});
	
			return elements;
		}
	
		/**
		 * Helper function to get the items nearest to the event position considering all visible items in teh chart
		 * @param chart {Chart} the chart to look at elements from
		 * @param position {Point} the point to be nearest to
		 * @param intersect {Boolean} if true, only consider items that intersect the position
		 * @param distanceMetric {Function} Optional function to provide the distance between
		 * @return {ChartElement[]} the nearest items
		 */
		function getNearestItems(chart, position, intersect, distanceMetric) {
			var minDistance = Number.POSITIVE_INFINITY;
			var nearestItems = [];
	
			if (!distanceMetric) {
				distanceMetric = helpers.distanceBetweenPoints;
			}
	
			parseVisibleItems(chart, function(element) {
				if (intersect && !element.inRange(position.x, position.y)) {
					return;
				}
	
				var center = element.getCenterPoint();
				var distance = distanceMetric(position, center);
	
				if (distance < minDistance) {
					nearestItems = [element];
					minDistance = distance;
				} else if (distance === minDistance) {
					// Can have multiple items at the same distance in which case we sort by size
					nearestItems.push(element);
				}
			});
	
			return nearestItems;
		}
	
		function indexMode(chart, e, options) {
			var position = getRelativePosition(e, chart.chart);
			var distanceMetric = function(pt1, pt2) {
				return Math.abs(pt1.x - pt2.x);
			};
			var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
			var elements = [];
	
			if (!items.length) {
				return [];
			}
	
			chart.data.datasets.forEach(function(dataset, datasetIndex) {
				if (chart.isDatasetVisible(datasetIndex)) {
					var meta = chart.getDatasetMeta(datasetIndex),
						element = meta.data[items[0]._index];
	
					// don't count items that are skipped (null data)
					if (element && !element._view.skip) {
						elements.push(element);
					}
				}
			});
	
			return elements;
		}
	
		/**
		 * @interface IInteractionOptions
		 */
		/**
		 * If true, only consider items that intersect the point
		 * @name IInterfaceOptions#boolean
		 * @type Boolean
		 */
	
		/**
		 * Contains interaction related functions
		 * @namespace Chart.Interaction
		 */
		Chart.Interaction = {
			// Helper function for different modes
			modes: {
				single: function(chart, e) {
					var position = getRelativePosition(e, chart.chart);
					var elements = [];
	
					parseVisibleItems(chart, function(element) {
						if (element.inRange(position.x, position.y)) {
							elements.push(element);
							return elements;
						}
					});
	
					return elements.slice(0, 1);
				},
	
				/**
				 * @function Chart.Interaction.modes.label
				 * @deprecated since version 2.4.0
				 */
				label: indexMode,
	
				/**
				 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
				 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
				 * @function Chart.Interaction.modes.index
				 * @since v2.4.0
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use during interaction
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				index: indexMode,
	
				/**
				 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
				 * If the options.intersect is false, we find the nearest item and return the items in that dataset
				 * @function Chart.Interaction.modes.dataset
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use during interaction
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				dataset: function(chart, e, options) {
					var position = getRelativePosition(e, chart.chart);
					var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);
	
					if (items.length > 0) {
						items = chart.getDatasetMeta(items[0]._datasetIndex).data;
					}
	
					return items;
				},
	
				/**
				 * @function Chart.Interaction.modes.x-axis
				 * @deprecated since version 2.4.0. Use index mode and intersect == true
				 */
				'x-axis': function(chart, e) {
					return indexMode(chart, e, true);
				},
	
				/**
				 * Point mode returns all elements that hit test based on the event position
				 * of the event
				 * @function Chart.Interaction.modes.intersect
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				point: function(chart, e) {
					var position = getRelativePosition(e, chart.chart);
					return getIntersectItems(chart, position);
				},
	
				/**
				 * nearest mode returns the element closest to the point
				 * @function Chart.Interaction.modes.intersect
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				nearest: function(chart, e, options) {
					var position = getRelativePosition(e, chart.chart);
					var nearestItems = getNearestItems(chart, position, options.intersect);
	
					// We have multiple items at the same distance from the event. Now sort by smallest
					if (nearestItems.length > 1) {
						nearestItems.sort(function(a, b) {
							var sizeA = a.getArea();
							var sizeB = b.getArea();
							var ret = sizeA - sizeB;
	
							if (ret === 0) {
								// if equal sort by dataset index
								ret = a._datasetIndex - b._datasetIndex;
							}
	
							return ret;
						});
					}
	
					// Return only 1 item
					return nearestItems.slice(0, 1);
				},
	
				/**
				 * x mode returns the elements that hit-test at the current x coordinate
				 * @function Chart.Interaction.modes.x
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				x: function(chart, e, options) {
					var position = getRelativePosition(e, chart.chart);
					var items = [];
					var intersectsItem = false;
	
					parseVisibleItems(chart, function(element) {
						if (element.inXRange(position.x)) {
							items.push(element);
						}
	
						if (element.inRange(position.x, position.y)) {
							intersectsItem = true;
						}
					});
	
					// If we want to trigger on an intersect and we don't have any items
					// that intersect the position, return nothing
					if (options.intersect && !intersectsItem) {
						items = [];
					}
					return items;
				},
	
				/**
				 * y mode returns the elements that hit-test at the current y coordinate
				 * @function Chart.Interaction.modes.y
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				y: function(chart, e, options) {
					var position = getRelativePosition(e, chart.chart);
					var items = [];
					var intersectsItem = false;
	
					parseVisibleItems(chart, function(element) {
						if (element.inYRange(position.y)) {
							items.push(element);
						}
	
						if (element.inRange(position.x, position.y)) {
							intersectsItem = true;
						}
					});
	
					// If we want to trigger on an intersect and we don't have any items
					// that intersect the position, return nothing
					if (options.intersect && !intersectsItem) {
						items = [];
					}
					return items;
				}
			}
		};
	};


/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		/**
	 	 * Helper method to merge the opacity into a color
	 	 */
		function mergeOpacity(colorString, opacity) {
			var color = helpers.color(colorString);
			return color.alpha(opacity * color.alpha()).rgbaString();
		}
	
		Chart.defaults.global.tooltips = {
			enabled: true,
			custom: null,
			mode: 'nearest',
			position: 'average',
			intersect: true,
			backgroundColor: 'rgba(0,0,0,0.8)',
			titleFontStyle: 'bold',
			titleSpacing: 2,
			titleMarginBottom: 6,
			titleFontColor: '#fff',
			titleAlign: 'left',
			bodySpacing: 2,
			bodyFontColor: '#fff',
			bodyAlign: 'left',
			footerFontStyle: 'bold',
			footerSpacing: 2,
			footerMarginTop: 6,
			footerFontColor: '#fff',
			footerAlign: 'left',
			yPadding: 6,
			xPadding: 6,
			caretSize: 5,
			cornerRadius: 6,
			multiKeyBackground: '#fff',
			displayColors: true,
			callbacks: {
				// Args are: (tooltipItems, data)
				beforeTitle: helpers.noop,
				title: function(tooltipItems, data) {
					// Pick first xLabel for now
					var title = '';
					var labels = data.labels;
					var labelCount = labels ? labels.length : 0;
	
					if (tooltipItems.length > 0) {
						var item = tooltipItems[0];
	
						if (item.xLabel) {
							title = item.xLabel;
						} else if (labelCount > 0 && item.index < labelCount) {
							title = labels[item.index];
						}
					}
	
					return title;
				},
				afterTitle: helpers.noop,
	
				// Args are: (tooltipItems, data)
				beforeBody: helpers.noop,
	
				// Args are: (tooltipItem, data)
				beforeLabel: helpers.noop,
				label: function(tooltipItem, data) {
					var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
					return datasetLabel + ': ' + tooltipItem.yLabel;
				},
				labelColor: function(tooltipItem, chartInstance) {
					var meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);
					var activeElement = meta.data[tooltipItem.index];
					var view = activeElement._view;
					return {
						borderColor: view.borderColor,
						backgroundColor: view.backgroundColor
					};
				},
				afterLabel: helpers.noop,
	
				// Args are: (tooltipItems, data)
				afterBody: helpers.noop,
	
				// Args are: (tooltipItems, data)
				beforeFooter: helpers.noop,
				footer: helpers.noop,
				afterFooter: helpers.noop
			}
		};
	
		// Helper to push or concat based on if the 2nd parameter is an array or not
		function pushOrConcat(base, toPush) {
			if (toPush) {
				if (helpers.isArray(toPush)) {
					// base = base.concat(toPush);
					Array.prototype.push.apply(base, toPush);
				} else {
					base.push(toPush);
				}
			}
	
			return base;
		}
	
		// Private helper to create a tooltip item model
		// @param element : the chart element (point, arc, bar) to create the tooltip item for
		// @return : new tooltip item
		function createTooltipItem(element) {
			var xScale = element._xScale;
			var yScale = element._yScale || element._scale; // handle radar || polarArea charts
			var index = element._index,
				datasetIndex = element._datasetIndex;
	
			return {
				xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
				yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
				index: index,
				datasetIndex: datasetIndex,
				x: element._model.x,
				y: element._model.y
			};
		}
	
		/**
		 * Helper to get the reset model for the tooltip
		 * @param tooltipOpts {Object} the tooltip options
		 */
		function getBaseModel(tooltipOpts) {
			var globalDefaults = Chart.defaults.global;
			var getValueOrDefault = helpers.getValueOrDefault;
	
			return {
				// Positioning
				xPadding: tooltipOpts.xPadding,
				yPadding: tooltipOpts.yPadding,
				xAlign: tooltipOpts.xAlign,
				yAlign: tooltipOpts.yAlign,
	
				// Body
				bodyFontColor: tooltipOpts.bodyFontColor,
				_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
				_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
				_bodyAlign: tooltipOpts.bodyAlign,
				bodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
				bodySpacing: tooltipOpts.bodySpacing,
	
				// Title
				titleFontColor: tooltipOpts.titleFontColor,
				_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
				_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
				titleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
				_titleAlign: tooltipOpts.titleAlign,
				titleSpacing: tooltipOpts.titleSpacing,
				titleMarginBottom: tooltipOpts.titleMarginBottom,
	
				// Footer
				footerFontColor: tooltipOpts.footerFontColor,
				_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
				_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
				footerFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
				_footerAlign: tooltipOpts.footerAlign,
				footerSpacing: tooltipOpts.footerSpacing,
				footerMarginTop: tooltipOpts.footerMarginTop,
	
				// Appearance
				caretSize: tooltipOpts.caretSize,
				cornerRadius: tooltipOpts.cornerRadius,
				backgroundColor: tooltipOpts.backgroundColor,
				opacity: 0,
				legendColorBackground: tooltipOpts.multiKeyBackground,
				displayColors: tooltipOpts.displayColors
			};
		}
	
		/**
		 * Get the size of the tooltip
		 */
		function getTooltipSize(tooltip, model) {
			var ctx = tooltip._chart.ctx;
	
			var height = model.yPadding * 2; // Tooltip Padding
			var width = 0;
	
			// Count of all lines in the body
			var body = model.body;
			var combinedBodyLength = body.reduce(function(count, bodyItem) {
				return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
			}, 0);
			combinedBodyLength += model.beforeBody.length + model.afterBody.length;
	
			var titleLineCount = model.title.length;
			var footerLineCount = model.footer.length;
			var titleFontSize = model.titleFontSize,
				bodyFontSize = model.bodyFontSize,
				footerFontSize = model.footerFontSize;
	
			height += titleLineCount * titleFontSize; // Title Lines
			height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
			height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
			height += combinedBodyLength * bodyFontSize; // Body Lines
			height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
			height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
			height += footerLineCount * (footerFontSize); // Footer Lines
			height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
	
			// Title width
			var widthPadding = 0;
			var maxLineWidth = function(line) {
				width = Math.max(width, ctx.measureText(line).width + widthPadding);
			};
	
			ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
			helpers.each(model.title, maxLineWidth);
	
			// Body width
			ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
			helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
	
			// Body lines may include some extra width due to the color box
			widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
			helpers.each(body, function(bodyItem) {
				helpers.each(bodyItem.before, maxLineWidth);
				helpers.each(bodyItem.lines, maxLineWidth);
				helpers.each(bodyItem.after, maxLineWidth);
			});
	
			// Reset back to 0
			widthPadding = 0;
	
			// Footer width
			ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
			helpers.each(model.footer, maxLineWidth);
	
			// Add padding
			width += 2 * model.xPadding;
	
			return {
				width: width,
				height: height
			};
		}
	
		/**
		 * Helper to get the alignment of a tooltip given the size
		 */
		function determineAlignment(tooltip, size) {
			var model = tooltip._model;
			var chart = tooltip._chart;
			var chartArea = tooltip._chartInstance.chartArea;
			var xAlign = 'center';
			var yAlign = 'center';
	
			if (model.y < size.height) {
				yAlign = 'top';
			} else if (model.y > (chart.height - size.height)) {
				yAlign = 'bottom';
			}
	
			var lf, rf; // functions to determine left, right alignment
			var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
			var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
			var midX = (chartArea.left + chartArea.right) / 2;
			var midY = (chartArea.top + chartArea.bottom) / 2;
	
			if (yAlign === 'center') {
				lf = function(x) {
					return x <= midX;
				};
				rf = function(x) {
					return x > midX;
				};
			} else {
				lf = function(x) {
					return x <= (size.width / 2);
				};
				rf = function(x) {
					return x >= (chart.width - (size.width / 2));
				};
			}
	
			olf = function(x) {
				return x + size.width > chart.width;
			};
			orf = function(x) {
				return x - size.width < 0;
			};
			yf = function(y) {
				return y <= midY ? 'top' : 'bottom';
			};
	
			if (lf(model.x)) {
				xAlign = 'left';
	
				// Is tooltip too wide and goes over the right side of the chart.?
				if (olf(model.x)) {
					xAlign = 'center';
					yAlign = yf(model.y);
				}
			} else if (rf(model.x)) {
				xAlign = 'right';
	
				// Is tooltip too wide and goes outside left edge of canvas?
				if (orf(model.x)) {
					xAlign = 'center';
					yAlign = yf(model.y);
				}
			}
	
			var opts = tooltip._options;
			return {
				xAlign: opts.xAlign ? opts.xAlign : xAlign,
				yAlign: opts.yAlign ? opts.yAlign : yAlign
			};
		}
	
		/**
		 * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
		 */
		function getBackgroundPoint(vm, size, alignment) {
			// Background Position
			var x = vm.x;
			var y = vm.y;
	
			var caretSize = vm.caretSize,
				caretPadding = vm.caretPadding,
				cornerRadius = vm.cornerRadius,
				xAlign = alignment.xAlign,
				yAlign = alignment.yAlign,
				paddingAndSize = caretSize + caretPadding,
				radiusAndPadding = cornerRadius + caretPadding;
	
			if (xAlign === 'right') {
				x -= size.width;
			} else if (xAlign === 'center') {
				x -= (size.width / 2);
			}
	
			if (yAlign === 'top') {
				y += paddingAndSize;
			} else if (yAlign === 'bottom') {
				y -= size.height + paddingAndSize;
			} else {
				y -= (size.height / 2);
			}
	
			if (yAlign === 'center') {
				if (xAlign === 'left') {
					x += paddingAndSize;
				} else if (xAlign === 'right') {
					x -= paddingAndSize;
				}
			} else if (xAlign === 'left') {
				x -= radiusAndPadding;
			} else if (xAlign === 'right') {
				x += radiusAndPadding;
			}
	
			return {
				x: x,
				y: y
			};
		}
	
		Chart.Tooltip = Chart.Element.extend({
			initialize: function() {
				this._model = getBaseModel(this._options);
			},
	
			// Get the title
			// Args are: (tooltipItem, data)
			getTitle: function() {
				var me = this;
				var opts = me._options;
				var callbacks = opts.callbacks;
	
				var beforeTitle = callbacks.beforeTitle.apply(me, arguments),
					title = callbacks.title.apply(me, arguments),
					afterTitle = callbacks.afterTitle.apply(me, arguments);
	
				var lines = [];
				lines = pushOrConcat(lines, beforeTitle);
				lines = pushOrConcat(lines, title);
				lines = pushOrConcat(lines, afterTitle);
	
				return lines;
			},
	
			// Args are: (tooltipItem, data)
			getBeforeBody: function() {
				var lines = this._options.callbacks.beforeBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
			},
	
			// Args are: (tooltipItem, data)
			getBody: function(tooltipItems, data) {
				var me = this;
				var callbacks = me._options.callbacks;
				var bodyItems = [];
	
				helpers.each(tooltipItems, function(tooltipItem) {
					var bodyItem = {
						before: [],
						lines: [],
						after: []
					};
					pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
	
					bodyItems.push(bodyItem);
				});
	
				return bodyItems;
			},
	
			// Args are: (tooltipItem, data)
			getAfterBody: function() {
				var lines = this._options.callbacks.afterBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
			},
	
			// Get the footer and beforeFooter and afterFooter lines
			// Args are: (tooltipItem, data)
			getFooter: function() {
				var me = this;
				var callbacks = me._options.callbacks;
	
				var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
				var footer = callbacks.footer.apply(me, arguments);
				var afterFooter = callbacks.afterFooter.apply(me, arguments);
	
				var lines = [];
				lines = pushOrConcat(lines, beforeFooter);
				lines = pushOrConcat(lines, footer);
				lines = pushOrConcat(lines, afterFooter);
	
				return lines;
			},
	
			update: function(changed) {
				var me = this;
				var opts = me._options;
	
				// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
				// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
				// which breaks any animations.
				var existingModel = me._model;
				var model = me._model = getBaseModel(opts);
				var active = me._active;
	
				var data = me._data;
				var chartInstance = me._chartInstance;
	
				// In the case where active.length === 0 we need to keep these at existing values for good animations
				var alignment = {
					xAlign: existingModel.xAlign,
					yAlign: existingModel.yAlign
				};
				var backgroundPoint = {
					x: existingModel.x,
					y: existingModel.y
				};
				var tooltipSize = {
					width: existingModel.width,
					height: existingModel.height
				};
				var tooltipPosition = {
					x: existingModel.caretX,
					y: existingModel.caretY
				};
	
				var i, len;
	
				if (active.length) {
					model.opacity = 1;
	
					var labelColors = [];
					tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);
	
					var tooltipItems = [];
					for (i = 0, len = active.length; i < len; ++i) {
						tooltipItems.push(createTooltipItem(active[i]));
					}
	
					// If the user provided a filter function, use it to modify the tooltip items
					if (opts.filter) {
						tooltipItems = tooltipItems.filter(function(a) {
							return opts.filter(a, data);
						});
					}
	
					// If the user provided a sorting function, use it to modify the tooltip items
					if (opts.itemSort) {
						tooltipItems = tooltipItems.sort(function(a, b) {
							return opts.itemSort(a, b, data);
						});
					}
	
					// Determine colors for boxes
					helpers.each(tooltipItems, function(tooltipItem) {
						labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));
					});
	
					// Build the Text Lines
					model.title = me.getTitle(tooltipItems, data);
					model.beforeBody = me.getBeforeBody(tooltipItems, data);
					model.body = me.getBody(tooltipItems, data);
					model.afterBody = me.getAfterBody(tooltipItems, data);
					model.footer = me.getFooter(tooltipItems, data);
	
					// Initial positioning and colors
					model.x = Math.round(tooltipPosition.x);
					model.y = Math.round(tooltipPosition.y);
					model.caretPadding = helpers.getValueOrDefault(tooltipPosition.padding, 2);
					model.labelColors = labelColors;
	
					// data points
					model.dataPoints = tooltipItems;
	
					// We need to determine alignment of the tooltip
					tooltipSize = getTooltipSize(this, model);
					alignment = determineAlignment(this, tooltipSize);
					// Final Size and Position
					backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
				} else {
					model.opacity = 0;
				}
	
				model.xAlign = alignment.xAlign;
				model.yAlign = alignment.yAlign;
				model.x = backgroundPoint.x;
				model.y = backgroundPoint.y;
				model.width = tooltipSize.width;
				model.height = tooltipSize.height;
	
				// Point where the caret on the tooltip points to
				model.caretX = tooltipPosition.x;
				model.caretY = tooltipPosition.y;
	
				me._model = model;
	
				if (changed && opts.custom) {
					opts.custom.call(me, model);
				}
	
				return me;
			},
			drawCaret: function(tooltipPoint, size, opacity) {
				var vm = this._view;
				var ctx = this._chart.ctx;
				var x1, x2, x3;
				var y1, y2, y3;
				var caretSize = vm.caretSize;
				var cornerRadius = vm.cornerRadius;
				var xAlign = vm.xAlign,
					yAlign = vm.yAlign;
				var ptX = tooltipPoint.x,
					ptY = tooltipPoint.y;
				var width = size.width,
					height = size.height;
	
				if (yAlign === 'center') {
					// Left or right side
					if (xAlign === 'left') {
						x1 = ptX;
						x2 = x1 - caretSize;
						x3 = x1;
					} else {
						x1 = ptX + width;
						x2 = x1 + caretSize;
						x3 = x1;
					}
	
					y2 = ptY + (height / 2);
					y1 = y2 - caretSize;
					y3 = y2 + caretSize;
				} else {
					if (xAlign === 'left') {
						x1 = ptX + cornerRadius;
						x2 = x1 + caretSize;
						x3 = x2 + caretSize;
					} else if (xAlign === 'right') {
						x1 = ptX + width - cornerRadius;
						x2 = x1 - caretSize;
						x3 = x2 - caretSize;
					} else {
						x2 = ptX + (width / 2);
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					}
	
					if (yAlign === 'top') {
						y1 = ptY;
						y2 = y1 - caretSize;
						y3 = y1;
					} else {
						y1 = ptY + height;
						y2 = y1 + caretSize;
						y3 = y1;
					}
				}
	
				ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.lineTo(x3, y3);
				ctx.closePath();
				ctx.fill();
			},
			drawTitle: function(pt, vm, ctx, opacity) {
				var title = vm.title;
	
				if (title.length) {
					ctx.textAlign = vm._titleAlign;
					ctx.textBaseline = 'top';
	
					var titleFontSize = vm.titleFontSize,
						titleSpacing = vm.titleSpacing;
	
					ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
					ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
	
					var i, len;
					for (i = 0, len = title.length; i < len; ++i) {
						ctx.fillText(title[i], pt.x, pt.y);
						pt.y += titleFontSize + titleSpacing; // Line Height and spacing
	
						if (i + 1 === title.length) {
							pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
						}
					}
				}
			},
			drawBody: function(pt, vm, ctx, opacity) {
				var bodyFontSize = vm.bodyFontSize;
				var bodySpacing = vm.bodySpacing;
				var body = vm.body;
	
				ctx.textAlign = vm._bodyAlign;
				ctx.textBaseline = 'top';
	
				var textColor = mergeOpacity(vm.bodyFontColor, opacity);
				ctx.fillStyle = textColor;
				ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
	
				// Before Body
				var xLinePadding = 0;
				var fillLineOfText = function(line) {
					ctx.fillText(line, pt.x + xLinePadding, pt.y);
					pt.y += bodyFontSize + bodySpacing;
				};
	
				// Before body lines
				helpers.each(vm.beforeBody, fillLineOfText);
	
				var drawColorBoxes = vm.displayColors;
				xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;
	
				// Draw body lines now
				helpers.each(body, function(bodyItem, i) {
					helpers.each(bodyItem.before, fillLineOfText);
	
					helpers.each(bodyItem.lines, function(line) {
						// Draw Legend-like boxes if needed
						if (drawColorBoxes) {
							// Fill a white rect so that colours merge nicely if the opacity is < 1
							ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
							ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
	
							// Border
							ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
							ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
	
							// Inner square
							ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
							ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
	
							ctx.fillStyle = textColor;
						}
	
						fillLineOfText(line);
					});
	
					helpers.each(bodyItem.after, fillLineOfText);
				});
	
				// Reset back to 0 for after body
				xLinePadding = 0;
	
				// After body lines
				helpers.each(vm.afterBody, fillLineOfText);
				pt.y -= bodySpacing; // Remove last body spacing
			},
			drawFooter: function(pt, vm, ctx, opacity) {
				var footer = vm.footer;
	
				if (footer.length) {
					pt.y += vm.footerMarginTop;
	
					ctx.textAlign = vm._footerAlign;
					ctx.textBaseline = 'top';
	
					ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
					ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
	
					helpers.each(footer, function(line) {
						ctx.fillText(line, pt.x, pt.y);
						pt.y += vm.footerFontSize + vm.footerSpacing;
					});
				}
			},
			drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
				ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
				helpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);
				ctx.fill();
			},
			draw: function() {
				var ctx = this._chart.ctx;
				var vm = this._view;
	
				if (vm.opacity === 0) {
					return;
				}
	
				var tooltipSize = {
					width: vm.width,
					height: vm.height
				};
				var pt = {
					x: vm.x,
					y: vm.y
				};
	
				// IE11/Edge does not like very small opacities, so snap to 0
				var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
	
				if (this._options.enabled) {
					// Draw Background
					this.drawBackground(pt, vm, ctx, tooltipSize, opacity);
	
					// Draw Caret
					this.drawCaret(pt, tooltipSize, opacity);
	
					// Draw Title, Body, and Footer
					pt.x += vm.xPadding;
					pt.y += vm.yPadding;
	
					// Titles
					this.drawTitle(pt, vm, ctx, opacity);
	
					// Body
					this.drawBody(pt, vm, ctx, opacity);
	
					// Footer
					this.drawFooter(pt, vm, ctx, opacity);
				}
			},
	
			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @returns {Boolean} true if the tooltip changed
			 */
			handleEvent: function(e) {
				var me = this;
				var options = me._options;
				var changed = false;
	
				me._lastActive = me._lastActive || [];
	
				// Find Active Elements for tooltips
				if (e.type === 'mouseout') {
					me._active = [];
				} else {
					me._active = me._chartInstance.getElementsAtEventForMode(e, options.mode, options);
				}
	
				// Remember Last Actives
				changed = !helpers.arrayEquals(me._active, me._lastActive);
				me._lastActive = me._active;
	
				if (options.enabled || options.custom) {
					me._eventPosition = {
						x: e.x,
						y: e.y
					};
	
					var model = me._model;
					me.update(true);
					me.pivot();
	
					// See if our tooltip position changed
					changed |= (model.x !== me._model.x) || (model.y !== me._model.y);
				}
	
				return changed;
			}
		});
	
		/**
		 * @namespace Chart.Tooltip.positioners
		 */
		Chart.Tooltip.positioners = {
			/**
			 * Average mode places the tooltip at the average position of the elements shown
			 * @function Chart.Tooltip.positioners.average
			 * @param elements {ChartElement[]} the elements being displayed in the tooltip
			 * @returns {Point} tooltip position
			 */
			average: function(elements) {
				if (!elements.length) {
					return false;
				}
	
				var i, len;
				var x = 0;
				var y = 0;
				var count = 0;
	
				for (i = 0, len = elements.length; i < len; ++i) {
					var el = elements[i];
					if (el && el.hasValue()) {
						var pos = el.tooltipPosition();
						x += pos.x;
						y += pos.y;
						++count;
					}
				}
	
				return {
					x: Math.round(x / count),
					y: Math.round(y / count)
				};
			},
	
			/**
			 * Gets the tooltip position nearest of the item nearest to the event position
			 * @function Chart.Tooltip.positioners.nearest
			 * @param elements {Chart.Element[]} the tooltip elements
			 * @param eventPosition {Point} the position of the event in canvas coordinates
			 * @returns {Point} the tooltip position
			 */
			nearest: function(elements, eventPosition) {
				var x = eventPosition.x;
				var y = eventPosition.y;
	
				var nearestElement;
				var minDistance = Number.POSITIVE_INFINITY;
				var i, len;
				for (i = 0, len = elements.length; i < len; ++i) {
					var el = elements[i];
					if (el && el.hasValue()) {
						var center = el.getCenterPoint();
						var d = helpers.distanceBetweenPoints(eventPosition, center);
	
						if (d < minDistance) {
							minDistance = d;
							nearestElement = el;
						}
					}
				}
	
				if (nearestElement) {
					var tp = nearestElement.tooltipPosition();
					x = tp.x;
					y = tp.y;
				}
	
				return {
					x: x,
					y: y
				};
			}
		};
	};


/***/ },
/* 83 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers,
			globalOpts = Chart.defaults.global;
	
		globalOpts.elements.arc = {
			backgroundColor: globalOpts.defaultColor,
			borderColor: '#fff',
			borderWidth: 2
		};
	
		Chart.elements.Arc = Chart.Element.extend({
			inLabelRange: function(mouseX) {
				var vm = this._view;
	
				if (vm) {
					return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
				}
				return false;
			},
			inRange: function(chartX, chartY) {
				var vm = this._view;
	
				if (vm) {
					var pointRelativePosition = helpers.getAngleFromPoint(vm, {
							x: chartX,
							y: chartY
						}),
						angle = pointRelativePosition.angle,
						distance = pointRelativePosition.distance;
	
					// Sanitise angle range
					var startAngle = vm.startAngle;
					var endAngle = vm.endAngle;
					while (endAngle < startAngle) {
						endAngle += 2.0 * Math.PI;
					}
					while (angle > endAngle) {
						angle -= 2.0 * Math.PI;
					}
					while (angle < startAngle) {
						angle += 2.0 * Math.PI;
					}
	
					// Check if within the range of the open/close angle
					var betweenAngles = (angle >= startAngle && angle <= endAngle),
						withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);
	
					return (betweenAngles && withinRadius);
				}
				return false;
			},
			getCenterPoint: function() {
				var vm = this._view;
				var halfAngle = (vm.startAngle + vm.endAngle) / 2;
				var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
				return {
					x: vm.x + Math.cos(halfAngle) * halfRadius,
					y: vm.y + Math.sin(halfAngle) * halfRadius
				};
			},
			getArea: function() {
				var vm = this._view;
				return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
			},
			tooltipPosition: function() {
				var vm = this._view;
	
				var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),
					rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
				return {
					x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
					y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
				};
			},
			draw: function() {
	
				var ctx = this._chart.ctx,
					vm = this._view,
					sA = vm.startAngle,
					eA = vm.endAngle;
	
				ctx.beginPath();
	
				ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
				ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
	
				ctx.closePath();
				ctx.strokeStyle = vm.borderColor;
				ctx.lineWidth = vm.borderWidth;
	
				ctx.fillStyle = vm.backgroundColor;
	
				ctx.fill();
				ctx.lineJoin = 'bevel';
	
				if (vm.borderWidth) {
					ctx.stroke();
				}
			}
		});
	};


/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
		var globalDefaults = Chart.defaults.global;
	
		Chart.defaults.global.elements.line = {
			tension: 0.4,
			backgroundColor: globalDefaults.defaultColor,
			borderWidth: 3,
			borderColor: globalDefaults.defaultColor,
			borderCapStyle: 'butt',
			borderDash: [],
			borderDashOffset: 0.0,
			borderJoinStyle: 'miter',
			capBezierPoints: true,
			fill: true, // do we fill in the area between the line and its base axis
		};
	
		Chart.elements.Line = Chart.Element.extend({
			draw: function() {
				var me = this;
				var vm = me._view;
				var spanGaps = vm.spanGaps;
				var fillPoint = vm.scaleZero;
				var loop = me._loop;
	
				// Handle different fill modes for cartesian lines
				if (!loop) {
					if (vm.fill === 'top') {
						fillPoint = vm.scaleTop;
					} else if (vm.fill === 'bottom') {
						fillPoint = vm.scaleBottom;
					}
				}
	
				var ctx = me._chart.ctx;
				ctx.save();
	
				// Helper function to draw a line to a point
				function lineToPoint(previousPoint, point) {
					var pointVM = point._view;
					if (point._view.steppedLine === true) {
						ctx.lineTo(pointVM.x, previousPoint._view.y);
						ctx.lineTo(pointVM.x, pointVM.y);
					} else if (point._view.tension === 0) {
						ctx.lineTo(pointVM.x, pointVM.y);
					} else {
						ctx.bezierCurveTo(
							previousPoint._view.controlPointNextX,
							previousPoint._view.controlPointNextY,
							pointVM.controlPointPreviousX,
							pointVM.controlPointPreviousY,
							pointVM.x,
							pointVM.y
						);
					}
				}
	
				var points = me._children.slice(); // clone array
				var lastDrawnIndex = -1;
	
				// If we are looping, adding the first point again
				if (loop && points.length) {
					points.push(points[0]);
				}
	
				var index, current, previous, currentVM;
	
				// Fill Line
				if (points.length && vm.fill) {
					ctx.beginPath();
	
					for (index = 0; index < points.length; ++index) {
						current = points[index];
						previous = helpers.previousItem(points, index);
						currentVM = current._view;
	
						// First point moves to it's starting position no matter what
						if (index === 0) {
							if (loop) {
								ctx.moveTo(fillPoint.x, fillPoint.y);
							} else {
								ctx.moveTo(currentVM.x, fillPoint);
							}
	
							if (!currentVM.skip) {
								lastDrawnIndex = index;
								ctx.lineTo(currentVM.x, currentVM.y);
							}
						} else {
							previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
	
							if (currentVM.skip) {
								// Only do this if this is the first point that is skipped
								if (!spanGaps && lastDrawnIndex === (index - 1)) {
									if (loop) {
										ctx.lineTo(fillPoint.x, fillPoint.y);
									} else {
										ctx.lineTo(previous._view.x, fillPoint);
									}
								}
							} else {
								if (lastDrawnIndex !== (index - 1)) {
									// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.
									// If the first data point is NaN, then there is no real gap to skip
									if (spanGaps && lastDrawnIndex !== -1) {
										// We are spanning the gap, so simple draw a line to this point
										lineToPoint(previous, current);
									} else if (loop) {
										ctx.lineTo(currentVM.x, currentVM.y);
									} else {
										ctx.lineTo(currentVM.x, fillPoint);
										ctx.lineTo(currentVM.x, currentVM.y);
									}
								} else {
									// Line to next point
									lineToPoint(previous, current);
								}
								lastDrawnIndex = index;
							}
						}
					}
	
					if (!loop && lastDrawnIndex !== -1) {
						ctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);
					}
	
					ctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;
					ctx.closePath();
					ctx.fill();
				}
	
				// Stroke Line Options
				var globalOptionLineElements = globalDefaults.elements.line;
				ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
	
				// IE 9 and 10 do not support line dash
				if (ctx.setLineDash) {
					ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
				}
	
				ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
				ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
				ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
				ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
	
				// Stroke Line
				ctx.beginPath();
				lastDrawnIndex = -1;
	
				for (index = 0; index < points.length; ++index) {
					current = points[index];
					previous = helpers.previousItem(points, index);
					currentVM = current._view;
	
					// First point moves to it's starting position no matter what
					if (index === 0) {
						if (!currentVM.skip) {
							ctx.moveTo(currentVM.x, currentVM.y);
							lastDrawnIndex = index;
						}
					} else {
						previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
	
						if (!currentVM.skip) {
							if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
								// There was a gap and this is the first point after the gap
								ctx.moveTo(currentVM.x, currentVM.y);
							} else {
								// Line to next point
								lineToPoint(previous, current);
							}
							lastDrawnIndex = index;
						}
					}
				}
	
				ctx.stroke();
				ctx.restore();
			}
		});
	};


/***/ },
/* 85 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers,
			globalOpts = Chart.defaults.global,
			defaultColor = globalOpts.defaultColor;
	
		globalOpts.elements.point = {
			radius: 3,
			pointStyle: 'circle',
			backgroundColor: defaultColor,
			borderWidth: 1,
			borderColor: defaultColor,
			// Hover
			hitRadius: 1,
			hoverRadius: 4,
			hoverBorderWidth: 1
		};
	
		function xRange(mouseX) {
			var vm = this._view;
			return vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
		}
	
		function yRange(mouseY) {
			var vm = this._view;
			return vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
		}
	
		Chart.elements.Point = Chart.Element.extend({
			inRange: function(mouseX, mouseY) {
				var vm = this._view;
				return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
			},
	
			inLabelRange: xRange,
			inXRange: xRange,
			inYRange: yRange,
	
			getCenterPoint: function() {
				var vm = this._view;
				return {
					x: vm.x,
					y: vm.y
				};
			},
			getArea: function() {
				return Math.PI * Math.pow(this._view.radius, 2);
			},
			tooltipPosition: function() {
				var vm = this._view;
				return {
					x: vm.x,
					y: vm.y,
					padding: vm.radius + vm.borderWidth
				};
			},
			draw: function(chartArea) {
				var vm = this._view;
				var model = this._model;
				var ctx = this._chart.ctx;
				var pointStyle = vm.pointStyle;
				var radius = vm.radius;
				var x = vm.x;
				var y = vm.y;
				var color = Chart.helpers.color;
				var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
				var ratio = 0;
	
				if (vm.skip) {
					return;
				}
	
				ctx.strokeStyle = vm.borderColor || defaultColor;
				ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);
				ctx.fillStyle = vm.backgroundColor || defaultColor;
	
				// Cliping for Points.
				// going out from inner charArea?
				if ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {
					// Point fade out
					if (model.x < chartArea.left) {
						ratio = (x - model.x) / (chartArea.left - model.x);
					} else if (chartArea.right*errMargin < model.x) {
						ratio = (model.x - x) / (model.x - chartArea.right);
					} else if (model.y < chartArea.top) {
						ratio = (y - model.y) / (chartArea.top - model.y);
					} else if (chartArea.bottom*errMargin < model.y) {
						ratio = (model.y - y) / (model.y - chartArea.bottom);
					}
					ratio = Math.round(ratio*100) / 100;
					ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
					ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
				}
	
				Chart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);
			}
		});
	};


/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var globalOpts = Chart.defaults.global;
	
		globalOpts.elements.rectangle = {
			backgroundColor: globalOpts.defaultColor,
			borderWidth: 0,
			borderColor: globalOpts.defaultColor,
			borderSkipped: 'bottom'
		};
	
		function isVertical(bar) {
			return bar._view.width !== undefined;
		}
	
		/**
		 * Helper function to get the bounds of the bar regardless of the orientation
		 * @private
		 * @param bar {Chart.Element.Rectangle} the bar
		 * @return {Bounds} bounds of the bar
		 */
		function getBarBounds(bar) {
			var vm = bar._view;
			var x1, x2, y1, y2;
	
			if (isVertical(bar)) {
				// vertical
				var halfWidth = vm.width / 2;
				x1 = vm.x - halfWidth;
				x2 = vm.x + halfWidth;
				y1 = Math.min(vm.y, vm.base);
				y2 = Math.max(vm.y, vm.base);
			} else {
				// horizontal bar
				var halfHeight = vm.height / 2;
				x1 = Math.min(vm.x, vm.base);
				x2 = Math.max(vm.x, vm.base);
				y1 = vm.y - halfHeight;
				y2 = vm.y + halfHeight;
			}
	
			return {
				left: x1,
				top: y1,
				right: x2,
				bottom: y2
			};
		}
	
		Chart.elements.Rectangle = Chart.Element.extend({
			draw: function() {
				var ctx = this._chart.ctx;
				var vm = this._view;
				var left, right, top, bottom, signX, signY, borderSkipped;
				var borderWidth = vm.borderWidth;
	
				if (!vm.horizontal) {
					// bar
					left = vm.x - vm.width / 2;
					right = vm.x + vm.width / 2;
					top = vm.y;
					bottom = vm.base;
					signX = 1;
					signY = bottom > top? 1: -1;
					borderSkipped = vm.borderSkipped || 'bottom';
				} else {
					// horizontal bar
					left = vm.base;
					right = vm.x;
					top = vm.y - vm.height / 2;
					bottom = vm.y + vm.height / 2;
					signX = right > left? 1: -1;
					signY = 1;
					borderSkipped = vm.borderSkipped || 'left';
				}
	
				// Canvas doesn't allow us to stroke inside the width so we can
				// adjust the sizes to fit if we're setting a stroke on the line
				if (borderWidth) {
					// borderWidth shold be less than bar width and bar height.
					var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
					borderWidth = borderWidth > barSize? barSize: borderWidth;
					var halfStroke = borderWidth / 2;
					// Adjust borderWidth when bar top position is near vm.base(zero).
					var borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);
					var borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);
					var borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);
					var borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);
					// not become a vertical line?
					if (borderLeft !== borderRight) {
						top = borderTop;
						bottom = borderBottom;
					}
					// not become a horizontal line?
					if (borderTop !== borderBottom) {
						left = borderLeft;
						right = borderRight;
					}
				}
	
				ctx.beginPath();
				ctx.fillStyle = vm.backgroundColor;
				ctx.strokeStyle = vm.borderColor;
				ctx.lineWidth = borderWidth;
	
				// Corner points, from bottom-left to bottom-right clockwise
				// | 1 2 |
				// | 0 3 |
				var corners = [
					[left, bottom],
					[left, top],
					[right, top],
					[right, bottom]
				];
	
				// Find first (starting) corner with fallback to 'bottom'
				var borders = ['bottom', 'left', 'top', 'right'];
				var startCorner = borders.indexOf(borderSkipped, 0);
				if (startCorner === -1) {
					startCorner = 0;
				}
	
				function cornerAt(index) {
					return corners[(startCorner + index) % 4];
				}
	
				// Draw rectangle from 'startCorner'
				var corner = cornerAt(0);
				ctx.moveTo(corner[0], corner[1]);
	
				for (var i = 1; i < 4; i++) {
					corner = cornerAt(i);
					ctx.lineTo(corner[0], corner[1]);
				}
	
				ctx.fill();
				if (borderWidth) {
					ctx.stroke();
				}
			},
			height: function() {
				var vm = this._view;
				return vm.base - vm.y;
			},
			inRange: function(mouseX, mouseY) {
				var inRange = false;
	
				if (this._view) {
					var bounds = getBarBounds(this);
					inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
				}
	
				return inRange;
			},
			inLabelRange: function(mouseX, mouseY) {
				var me = this;
				if (!me._view) {
					return false;
				}
	
				var inRange = false;
				var bounds = getBarBounds(me);
	
				if (isVertical(me)) {
					inRange = mouseX >= bounds.left && mouseX <= bounds.right;
				} else {
					inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
				}
	
				return inRange;
			},
			inXRange: function(mouseX) {
				var bounds = getBarBounds(this);
				return mouseX >= bounds.left && mouseX <= bounds.right;
			},
			inYRange: function(mouseY) {
				var bounds = getBarBounds(this);
				return mouseY >= bounds.top && mouseY <= bounds.bottom;
			},
			getCenterPoint: function() {
				var vm = this._view;
				var x, y;
				if (isVertical(this)) {
					x = vm.x;
					y = (vm.y + vm.base) / 2;
				} else {
					x = (vm.x + vm.base) / 2;
					y = vm.y;
				}
	
				return {x: x, y: y};
			},
			getArea: function() {
				var vm = this._view;
				return vm.width * Math.abs(vm.y - vm.base);
			},
			tooltipPosition: function() {
				var vm = this._view;
				return {
					x: vm.x,
					y: vm.y
				};
			}
		});
	
	};


/***/ },
/* 87 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers,
			noop = helpers.noop;
	
		Chart.LinearScaleBase = Chart.Scale.extend({
			handleTickRangeOptions: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
	
				// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
				// do nothing since that would make the chart weird. If the user really wants a weird chart
				// axis, they can manually override it
				if (tickOpts.beginAtZero) {
					var minSign = helpers.sign(me.min);
					var maxSign = helpers.sign(me.max);
	
					if (minSign < 0 && maxSign < 0) {
						// move the top up to 0
						me.max = 0;
					} else if (minSign > 0 && maxSign > 0) {
						// move the bottom down to 0
						me.min = 0;
					}
				}
	
				if (tickOpts.min !== undefined) {
					me.min = tickOpts.min;
				} else if (tickOpts.suggestedMin !== undefined) {
					me.min = Math.min(me.min, tickOpts.suggestedMin);
				}
	
				if (tickOpts.max !== undefined) {
					me.max = tickOpts.max;
				} else if (tickOpts.suggestedMax !== undefined) {
					me.max = Math.max(me.max, tickOpts.suggestedMax);
				}
	
				if (me.min === me.max) {
					me.max++;
	
					if (!tickOpts.beginAtZero) {
						me.min--;
					}
				}
			},
			getTickLimit: noop,
			handleDirectionalChanges: noop,
	
			buildTicks: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
	
				// Figure out what the max number of ticks we can support it is based on the size of
				// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
				// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
				// the graph. Make sure we always have at least 2 ticks
				var maxTicks = me.getTickLimit();
				maxTicks = Math.max(2, maxTicks);
	
				var numericGeneratorOptions = {
					maxTicks: maxTicks,
					min: tickOpts.min,
					max: tickOpts.max,
					stepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
				};
				var ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);
	
				me.handleDirectionalChanges();
	
				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max = helpers.max(ticks);
				me.min = helpers.min(ticks);
	
				if (tickOpts.reverse) {
					ticks.reverse();
	
					me.start = me.max;
					me.end = me.min;
				} else {
					me.start = me.min;
					me.end = me.max;
				}
			},
			convertTicksToLabels: function() {
				var me = this;
				me.ticksAsNumbers = me.ticks.slice();
				me.zeroLineIndex = me.ticks.indexOf(0);
	
				Chart.Scale.prototype.convertTicksToLabels.call(me);
			}
		});
	};


/***/ },
/* 88 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
		// Default config for a category scale
		var defaultConfig = {
			position: 'bottom'
		};
	
		var DatasetScale = Chart.Scale.extend({
			/**
			* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
			* else fall back to data.labels
			* @private
			*/
			getLabels: function() {
				var data = this.chart.data;
				return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
			},
			// Implement this so that
			determineDataLimits: function() {
				var me = this;
				var labels = me.getLabels();
				me.minIndex = 0;
				me.maxIndex = labels.length - 1;
				var findIndex;
	
				if (me.options.ticks.min !== undefined) {
					// user specified min value
					findIndex = helpers.indexOf(labels, me.options.ticks.min);
					me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
				}
	
				if (me.options.ticks.max !== undefined) {
					// user specified max value
					findIndex = helpers.indexOf(labels, me.options.ticks.max);
					me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
				}
	
				me.min = labels[me.minIndex];
				me.max = labels[me.maxIndex];
			},
	
			buildTicks: function() {
				var me = this;
				var labels = me.getLabels();
				// If we are viewing some subset of labels, slice the original array
				me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
			},
	
			getLabelForIndex: function(index, datasetIndex) {
				var me = this;
				var data = me.chart.data;
				var isHorizontal = me.isHorizontal();
	
				if (data.yLabels && !isHorizontal) {
					return me.getRightValue(data.datasets[datasetIndex].data[index]);
				}
				return me.ticks[index - me.minIndex];
			},
	
			// Used to get data value locations.  Value can either be an index or a numerical value
			getPixelForValue: function(value, index, datasetIndex, includeOffset) {
				var me = this;
				// 1 is added because we need the length but we have the indexes
				var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
	
				if (value !== undefined && isNaN(index)) {
					var labels = me.getLabels();
					var idx = labels.indexOf(value);
					index = idx !== -1 ? idx : index;
				}
	
				if (me.isHorizontal()) {
					var valueWidth = me.width / offsetAmt;
					var widthOffset = (valueWidth * (index - me.minIndex));
	
					if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {
						widthOffset += (valueWidth / 2);
					}
	
					return me.left + Math.round(widthOffset);
				}
				var valueHeight = me.height / offsetAmt;
				var heightOffset = (valueHeight * (index - me.minIndex));
	
				if (me.options.gridLines.offsetGridLines && includeOffset) {
					heightOffset += (valueHeight / 2);
				}
	
				return me.top + Math.round(heightOffset);
			},
			getPixelForTick: function(index, includeOffset) {
				return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var value;
				var offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
				var horz = me.isHorizontal();
				var valueDimension = (horz ? me.width : me.height) / offsetAmt;
	
				pixel -= horz ? me.left : me.top;
	
				if (me.options.gridLines.offsetGridLines) {
					pixel -= (valueDimension / 2);
				}
	
				if (pixel <= 0) {
					value = 0;
				} else {
					value = Math.round(pixel / valueDimension);
				}
	
				return value;
			},
			getBasePixel: function() {
				return this.bottom;
			}
		});
	
		Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
	
	};


/***/ },
/* 89 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		var defaultConfig = {
			position: 'left',
			ticks: {
				callback: Chart.Ticks.formatters.linear
			}
		};
	
		var LinearScale = Chart.LinearScaleBase.extend({
			determineDataLimits: function() {
				var me = this;
				var opts = me.options;
				var chart = me.chart;
				var data = chart.data;
				var datasets = data.datasets;
				var isHorizontal = me.isHorizontal();
	
				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
				}
	
				// First Calculate the range
				me.min = null;
				me.max = null;
	
				var hasStacks = opts.stacked;
				if (hasStacks === undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}
	
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
							meta.stack !== undefined) {
							hasStacks = true;
						}
					});
				}
	
				if (opts.stacked || hasStacks) {
					var valuesPerStack = {};
	
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var key = [
							meta.type,
							// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
							((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
							meta.stack
						].join('.');
	
						if (valuesPerStack[key] === undefined) {
							valuesPerStack[key] = {
								positiveValues: [],
								negativeValues: []
							};
						}
	
						// Store these per type
						var positiveValues = valuesPerStack[key].positiveValues;
						var negativeValues = valuesPerStack[key].negativeValues;
	
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}
	
								positiveValues[index] = positiveValues[index] || 0;
								negativeValues[index] = negativeValues[index] || 0;
	
								if (opts.relativePoints) {
									positiveValues[index] = 100;
								} else if (value < 0) {
									negativeValues[index] += value;
								} else {
									positiveValues[index] += value;
								}
							});
						}
					});
	
					helpers.each(valuesPerStack, function(valuesForType) {
						var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
						var minVal = helpers.min(values);
						var maxVal = helpers.max(values);
						me.min = me.min === null ? minVal : Math.min(me.min, minVal);
						me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
					});
	
				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}
	
								if (me.min === null) {
									me.min = value;
								} else if (value < me.min) {
									me.min = value;
								}
	
								if (me.max === null) {
									me.max = value;
								} else if (value > me.max) {
									me.max = value;
								}
							});
						}
					});
				}
	
				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				this.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var maxTicks;
				var me = this;
				var tickOpts = me.options.ticks;
	
				if (me.isHorizontal()) {
					maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
				} else {
					// The factor of 2 used to scale the font size has been experimentally determined.
					var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);
					maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
				}
	
				return maxTicks;
			},
			// Called after the ticks are built. We need
			handleDirectionalChanges: function() {
				if (!this.isHorizontal()) {
					// We are in a vertical orientation. The top value is the highest. So reverse the array
					this.ticks.reverse();
				}
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			// Utils
			getPixelForValue: function(value) {
				// This must be called after fit has been run so that
				// this.left, this.top, this.right, and this.bottom have been defined
				var me = this;
				var start = me.start;
	
				var rightValue = +me.getRightValue(value);
				var pixel;
				var range = me.end - start;
	
				if (me.isHorizontal()) {
					pixel = me.left + (me.width / range * (rightValue - start));
					return Math.round(pixel);
				}
	
				pixel = me.bottom - (me.height / range * (rightValue - start));
				return Math.round(pixel);
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var isHorizontal = me.isHorizontal();
				var innerDimension = isHorizontal ? me.width : me.height;
				var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
				return me.start + ((me.end - me.start) * offset);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.ticksAsNumbers[index]);
			}
		});
		Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
	
	};


/***/ },
/* 90 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		var defaultConfig = {
			position: 'left',
	
			// label settings
			ticks: {
				callback: Chart.Ticks.formatters.logarithmic
			}
		};
	
		var LogarithmicScale = Chart.Scale.extend({
			determineDataLimits: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
				var chart = me.chart;
				var data = chart.data;
				var datasets = data.datasets;
				var getValueOrDefault = helpers.getValueOrDefault;
				var isHorizontal = me.isHorizontal();
				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
				}
	
				// Calculate Range
				me.min = null;
				me.max = null;
				me.minNotZero = null;
	
				var hasStacks = opts.stacked;
				if (hasStacks === undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}
	
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
							meta.stack !== undefined) {
							hasStacks = true;
						}
					});
				}
	
				if (opts.stacked || hasStacks) {
					var valuesPerStack = {};
	
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var key = [
							meta.type,
							// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
							((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
							meta.stack
						].join('.');
	
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							if (valuesPerStack[key] === undefined) {
								valuesPerStack[key] = [];
							}
	
							helpers.each(dataset.data, function(rawValue, index) {
								var values = valuesPerStack[key];
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}
	
								values[index] = values[index] || 0;
	
								if (opts.relativePoints) {
									values[index] = 100;
								} else {
									// Don't need to split positive and negative since the log scale can't handle a 0 crossing
									values[index] += value;
								}
							});
						}
					});
	
					helpers.each(valuesPerStack, function(valuesForType) {
						var minVal = helpers.min(valuesForType);
						var maxVal = helpers.max(valuesForType);
						me.min = me.min === null ? minVal : Math.min(me.min, minVal);
						me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
					});
	
				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}
	
								if (me.min === null) {
									me.min = value;
								} else if (value < me.min) {
									me.min = value;
								}
	
								if (me.max === null) {
									me.max = value;
								} else if (value > me.max) {
									me.max = value;
								}
	
								if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
									me.minNotZero = value;
								}
							});
						}
					});
				}
	
				me.min = getValueOrDefault(tickOpts.min, me.min);
				me.max = getValueOrDefault(tickOpts.max, me.max);
	
				if (me.min === me.max) {
					if (me.min !== 0 && me.min !== null) {
						me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
						me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
					} else {
						me.min = 1;
						me.max = 10;
					}
				}
			},
			buildTicks: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
	
				var generationOptions = {
					min: tickOpts.min,
					max: tickOpts.max
				};
				var ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);
	
				if (!me.isHorizontal()) {
					// We are in a vertical orientation. The top value is the highest. So reverse the array
					ticks.reverse();
				}
	
				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max = helpers.max(ticks);
				me.min = helpers.min(ticks);
	
				if (tickOpts.reverse) {
					ticks.reverse();
	
					me.start = me.max;
					me.end = me.min;
				} else {
					me.start = me.min;
					me.end = me.max;
				}
			},
			convertTicksToLabels: function() {
				this.tickValues = this.ticks.slice();
	
				Chart.Scale.prototype.convertTicksToLabels.call(this);
			},
			// Get the correct tooltip label
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.tickValues[index]);
			},
			getPixelForValue: function(value) {
				var me = this;
				var innerDimension;
				var pixel;
	
				var start = me.start;
				var newVal = +me.getRightValue(value);
				var range;
				var opts = me.options;
				var tickOpts = opts.ticks;
	
				if (me.isHorizontal()) {
					range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0
					if (newVal === 0) {
						pixel = me.left;
					} else {
						innerDimension = me.width;
						pixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
					}
				} else {
					// Bottom - top since pixels increase downward on a screen
					innerDimension = me.height;
					if (start === 0 && !tickOpts.reverse) {
						range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
						if (newVal === start) {
							pixel = me.bottom;
						} else if (newVal === me.minNotZero) {
							pixel = me.bottom - innerDimension * 0.02;
						} else {
							pixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));
						}
					} else if (me.end === 0 && tickOpts.reverse) {
						range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
						if (newVal === me.end) {
							pixel = me.top;
						} else if (newVal === me.minNotZero) {
							pixel = me.top + innerDimension * 0.02;
						} else {
							pixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));
						}
					} else {
						range = helpers.log10(me.end) - helpers.log10(start);
						innerDimension = me.height;
						pixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
					}
				}
				return pixel;
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var range = helpers.log10(me.end) - helpers.log10(me.start);
				var value, innerDimension;
	
				if (me.isHorizontal()) {
					innerDimension = me.width;
					value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
				} else {  // todo: if start === 0
					innerDimension = me.height;
					value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
				}
				return value;
			}
		});
		Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
	
	};


/***/ },
/* 91 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
		var globalDefaults = Chart.defaults.global;
	
		var defaultConfig = {
			display: true,
	
			// Boolean - Whether to animate scaling the chart from the centre
			animate: true,
			lineArc: false,
			position: 'chartArea',
	
			angleLines: {
				display: true,
				color: 'rgba(0, 0, 0, 0.1)',
				lineWidth: 1
			},
	
			// label settings
			ticks: {
				// Boolean - Show a backdrop to the scale label
				showLabelBackdrop: true,
	
				// String - The colour of the label backdrop
				backdropColor: 'rgba(255,255,255,0.75)',
	
				// Number - The backdrop padding above & below the label in pixels
				backdropPaddingY: 2,
	
				// Number - The backdrop padding to the side of the label in pixels
				backdropPaddingX: 2,
	
				callback: Chart.Ticks.formatters.linear
			},
	
			pointLabels: {
				// Number - Point label font size in pixels
				fontSize: 10,
	
				// Function - Used to convert point labels
				callback: function(label) {
					return label;
				}
			}
		};
	
		function getValueCount(scale) {
			return !scale.options.lineArc ? scale.chart.data.labels.length : 0;
		}
	
		function getPointLabelFontOptions(scale) {
			var pointLabelOptions = scale.options.pointLabels;
			var fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
			var fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
			var fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
			var font = helpers.fontString(fontSize, fontStyle, fontFamily);
	
			return {
				size: fontSize,
				style: fontStyle,
				family: fontFamily,
				font: font
			};
		}
	
		function measureLabelSize(ctx, fontSize, label) {
			if (helpers.isArray(label)) {
				return {
					w: helpers.longestText(ctx, ctx.font, label),
					h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
				};
			}
	
			return {
				w: ctx.measureText(label).width,
				h: fontSize
			};
		}
	
		function determineLimits(angle, pos, size, min, max) {
			if (angle === min || angle === max) {
				return {
					start: pos - (size / 2),
					end: pos + (size / 2)
				};
			} else if (angle < min || angle > max) {
				return {
					start: pos - size - 5,
					end: pos
				};
			}
	
			return {
				start: pos,
				end: pos + size + 5
			};
		}
	
		/**
		 * Helper function to fit a radial linear scale with point labels
		 */
		function fitWithPointLabels(scale) {
			/*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
			 *
			 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
			 */
	
			var plFont = getPointLabelFontOptions(scale);
	
			// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
			// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
			var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
			var furthestLimits = {
				l: scale.width,
				r: 0,
				t: scale.height,
				b: 0
			};
			var furthestAngles = {};
			var i;
			var textSize;
			var pointPosition;
	
			scale.ctx.font = plFont.font;
			scale._pointLabelSizes = [];
	
			var valueCount = getValueCount(scale);
			for (i = 0; i < valueCount; i++) {
				pointPosition = scale.getPointPosition(i, largestPossibleRadius);
				textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
				scale._pointLabelSizes[i] = textSize;
	
				// Add quarter circle to make degree 0 mean top of circle
				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians) % 360;
				var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
				var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
	
				if (hLimits.start < furthestLimits.l) {
					furthestLimits.l = hLimits.start;
					furthestAngles.l = angleRadians;
				}
	
				if (hLimits.end > furthestLimits.r) {
					furthestLimits.r = hLimits.end;
					furthestAngles.r = angleRadians;
				}
	
				if (vLimits.start < furthestLimits.t) {
					furthestLimits.t = vLimits.start;
					furthestAngles.t = angleRadians;
				}
	
				if (vLimits.end > furthestLimits.b) {
					furthestLimits.b = vLimits.end;
					furthestAngles.b = angleRadians;
				}
			}
	
			scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
		}
	
		/**
		 * Helper function to fit a radial linear scale with no point labels
		 */
		function fit(scale) {
			var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
			scale.drawingArea = Math.round(largestPossibleRadius);
			scale.setCenterPoint(0, 0, 0, 0);
		}
	
		function getTextAlignForAngle(angle) {
			if (angle === 0 || angle === 180) {
				return 'center';
			} else if (angle < 180) {
				return 'left';
			}
	
			return 'right';
		}
	
		function fillText(ctx, text, position, fontSize) {
			if (helpers.isArray(text)) {
				var y = position.y;
				var spacing = 1.5 * fontSize;
	
				for (var i = 0; i < text.length; ++i) {
					ctx.fillText(text[i], position.x, y);
					y+= spacing;
				}
			} else {
				ctx.fillText(text, position.x, position.y);
			}
		}
	
		function adjustPointPositionForLabelHeight(angle, textSize, position) {
			if (angle === 90 || angle === 270) {
				position.y -= (textSize.h / 2);
			} else if (angle > 270 || angle < 90) {
				position.y -= textSize.h;
			}
		}
	
		function drawPointLabels(scale) {
			var ctx = scale.ctx;
			var getValueOrDefault = helpers.getValueOrDefault;
			var opts = scale.options;
			var angleLineOpts = opts.angleLines;
			var pointLabelOpts = opts.pointLabels;
	
			ctx.lineWidth = angleLineOpts.lineWidth;
			ctx.strokeStyle = angleLineOpts.color;
	
			var outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);
	
			// Point Label Font
			var plFont = getPointLabelFontOptions(scale);
	
			ctx.textBaseline = 'top';
	
			for (var i = getValueCount(scale) - 1; i >= 0; i--) {
				if (angleLineOpts.display) {
					var outerPosition = scale.getPointPosition(i, outerDistance);
					ctx.beginPath();
					ctx.moveTo(scale.xCenter, scale.yCenter);
					ctx.lineTo(outerPosition.x, outerPosition.y);
					ctx.stroke();
					ctx.closePath();
				}
				// Extra 3px out for some label spacing
				var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);
	
				// Keep this in loop since we may support array properties here
				var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
				ctx.font = plFont.font;
				ctx.fillStyle = pointLabelFontColor;
	
				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians);
				ctx.textAlign = getTextAlignForAngle(angle);
				adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
				fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
			}
		}
	
		function drawRadiusLine(scale, gridLineOpts, radius, index) {
			var ctx = scale.ctx;
			ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);
			ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
	
			if (scale.options.lineArc) {
				// Draw circular arcs between the points
				ctx.beginPath();
				ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.stroke();
			} else {
				// Draw straight lines connecting each index
				var valueCount = getValueCount(scale);
	
				if (valueCount === 0) {
					return;
				}
	
				ctx.beginPath();
				var pointPosition = scale.getPointPosition(0, radius);
				ctx.moveTo(pointPosition.x, pointPosition.y);
	
				for (var i = 1; i < valueCount; i++) {
					pointPosition = scale.getPointPosition(i, radius);
					ctx.lineTo(pointPosition.x, pointPosition.y);
				}
	
				ctx.closePath();
				ctx.stroke();
			}
		}
	
		function numberOrZero(param) {
			return helpers.isNumber(param) ? param : 0;
		}
	
		var LinearRadialScale = Chart.LinearScaleBase.extend({
			setDimensions: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
				// Set the unconstrained dimension before label rotation
				me.width = me.maxWidth;
				me.height = me.maxHeight;
				me.xCenter = Math.round(me.width / 2);
				me.yCenter = Math.round(me.height / 2);
	
				var minSize = helpers.min([me.height, me.width]);
				var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
			},
			determineDataLimits: function() {
				var me = this;
				var chart = me.chart;
				var min = Number.POSITIVE_INFINITY;
				var max = Number.NEGATIVE_INFINITY;
	
				helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
					if (chart.isDatasetVisible(datasetIndex)) {
						var meta = chart.getDatasetMeta(datasetIndex);
	
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}
	
							min = Math.min(value, min);
							max = Math.max(value, max);
						});
					}
				});
	
				me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
				me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);
	
				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				me.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var tickOpts = this.options.ticks;
				var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
			},
			convertTicksToLabels: function() {
				var me = this;
				Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);
	
				// Point labels
				me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			fit: function() {
				if (this.options.lineArc) {
					fit(this);
				} else {
					fitWithPointLabels(this);
				}
			},
			/**
			 * Set radius reductions and determine new radius and center point
			 * @private
			 */
			setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
				var me = this;
				var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
				var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
				var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
				var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
	
				radiusReductionLeft = numberOrZero(radiusReductionLeft);
				radiusReductionRight = numberOrZero(radiusReductionRight);
				radiusReductionTop = numberOrZero(radiusReductionTop);
				radiusReductionBottom = numberOrZero(radiusReductionBottom);
	
				me.drawingArea = Math.min(
					Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
					Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
				me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
			},
			setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
				var me = this;
				var maxRight = me.width - rightMovement - me.drawingArea,
					maxLeft = leftMovement + me.drawingArea,
					maxTop = topMovement + me.drawingArea,
					maxBottom = me.height - bottomMovement - me.drawingArea;
	
				me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
				me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
			},
	
			getIndexAngle: function(index) {
				var angleMultiplier = (Math.PI * 2) / getValueCount(this);
				var startAngle = this.chart.options && this.chart.options.startAngle ?
					this.chart.options.startAngle :
					0;
	
				var startAngleRadians = startAngle * Math.PI * 2 / 360;
	
				// Start from the top instead of right, so remove a quarter of the circle
				return index * angleMultiplier + startAngleRadians;
			},
			getDistanceFromCenterForValue: function(value) {
				var me = this;
	
				if (value === null) {
					return 0; // null always in center
				}
	
				// Take into account half font size + the yPadding of the top value
				var scalingFactor = me.drawingArea / (me.max - me.min);
				if (me.options.reverse) {
					return (me.max - value) * scalingFactor;
				}
				return (value - me.min) * scalingFactor;
			},
			getPointPosition: function(index, distanceFromCenter) {
				var me = this;
				var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
				return {
					x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
					y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
				};
			},
			getPointPositionForValue: function(index, value) {
				return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
			},
	
			getBasePosition: function() {
				var me = this;
				var min = me.min;
				var max = me.max;
	
				return me.getPointPositionForValue(0,
					me.beginAtZero? 0:
					min < 0 && max < 0? max :
					min > 0 && max > 0? min :
					0);
			},
	
			draw: function() {
				var me = this;
				var opts = me.options;
				var gridLineOpts = opts.gridLines;
				var tickOpts = opts.ticks;
				var getValueOrDefault = helpers.getValueOrDefault;
	
				if (opts.display) {
					var ctx = me.ctx;
	
					// Tick Font
					var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
					var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
					var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
					var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
	
					helpers.each(me.ticks, function(label, index) {
						// Don't draw a centre value (if it is minimum)
						if (index > 0 || opts.reverse) {
							var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
							var yHeight = me.yCenter - yCenterOffset;
	
							// Draw circular lines around the scale
							if (gridLineOpts.display && index !== 0) {
								drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
							}
	
							if (tickOpts.display) {
								var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
								ctx.font = tickLabelFont;
	
								if (tickOpts.showLabelBackdrop) {
									var labelWidth = ctx.measureText(label).width;
									ctx.fillStyle = tickOpts.backdropColor;
									ctx.fillRect(
										me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,
										yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,
										labelWidth + tickOpts.backdropPaddingX * 2,
										tickFontSize + tickOpts.backdropPaddingY * 2
									);
								}
	
								ctx.textAlign = 'center';
								ctx.textBaseline = 'middle';
								ctx.fillStyle = tickFontColor;
								ctx.fillText(label, me.xCenter, yHeight);
							}
						}
					});
	
					if (!opts.lineArc) {
						drawPointLabels(me);
					}
				}
			}
		});
		Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
	
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* global window: false */
	'use strict';
	
	var moment = __webpack_require__(93);
	moment = typeof(moment) === 'function' ? moment : window.moment;
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
		var time = {
			units: [{
				name: 'millisecond',
				steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
			}, {
				name: 'second',
				steps: [1, 2, 5, 10, 30]
			}, {
				name: 'minute',
				steps: [1, 2, 5, 10, 30]
			}, {
				name: 'hour',
				steps: [1, 2, 3, 6, 12]
			}, {
				name: 'day',
				steps: [1, 2, 5]
			}, {
				name: 'week',
				maxStep: 4
			}, {
				name: 'month',
				maxStep: 3
			}, {
				name: 'quarter',
				maxStep: 4
			}, {
				name: 'year',
				maxStep: false
			}]
		};
	
		var defaultConfig = {
			position: 'bottom',
	
			time: {
				parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
				format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
				unit: false, // false == automatic or override with week, month, year, etc.
				round: false, // none, or override with week, month, year, etc.
				displayFormat: false, // DEPRECATED
				isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
				minUnit: 'millisecond',
	
				// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
				displayFormats: {
					millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
					second: 'h:mm:ss a', // 11:20:01 AM
					minute: 'h:mm:ss a', // 11:20:01 AM
					hour: 'MMM D, hA', // Sept 4, 5PM
					day: 'll', // Sep 4 2015
					week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
					month: 'MMM YYYY', // Sept 2015
					quarter: '[Q]Q - YYYY', // Q3
					year: 'YYYY' // 2015
				}
			},
			ticks: {
				autoSkip: false
			}
		};
	
		var TimeScale = Chart.Scale.extend({
			initialize: function() {
				if (!moment) {
					throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
				}
	
				Chart.Scale.prototype.initialize.call(this);
			},
			getLabelMoment: function(datasetIndex, index) {
				if (datasetIndex === null || index === null) {
					return null;
				}
	
				if (typeof this.labelMoments[datasetIndex] !== 'undefined') {
					return this.labelMoments[datasetIndex][index];
				}
	
				return null;
			},
			getLabelDiff: function(datasetIndex, index) {
				var me = this;
				if (datasetIndex === null || index === null) {
					return null;
				}
	
				if (me.labelDiffs === undefined) {
					me.buildLabelDiffs();
				}
	
				if (typeof me.labelDiffs[datasetIndex] !== 'undefined') {
					return me.labelDiffs[datasetIndex][index];
				}
	
				return null;
			},
			getMomentStartOf: function(tick) {
				var me = this;
				if (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {
					return tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);
				}
				return tick.clone().startOf(me.tickUnit);
			},
			determineDataLimits: function() {
				var me = this;
				me.labelMoments = [];
	
				// Only parse these once. If the dataset does not have data as x,y pairs, we will use
				// these
				var scaleLabelMoments = [];
				if (me.chart.data.labels && me.chart.data.labels.length > 0) {
					helpers.each(me.chart.data.labels, function(label) {
						var labelMoment = me.parseTime(label);
	
						if (labelMoment.isValid()) {
							if (me.options.time.round) {
								labelMoment.startOf(me.options.time.round);
							}
							scaleLabelMoments.push(labelMoment);
						}
					}, me);
	
					me.firstTick = moment.min.call(me, scaleLabelMoments);
					me.lastTick = moment.max.call(me, scaleLabelMoments);
				} else {
					me.firstTick = null;
					me.lastTick = null;
				}
	
				helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {
					var momentsForDataset = [];
					var datasetVisible = me.chart.isDatasetVisible(datasetIndex);
	
					if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {
						helpers.each(dataset.data, function(value) {
							var labelMoment = me.parseTime(me.getRightValue(value));
	
							if (labelMoment.isValid()) {
								if (me.options.time.round) {
									labelMoment.startOf(me.options.time.round);
								}
								momentsForDataset.push(labelMoment);
	
								if (datasetVisible) {
									// May have gone outside the scale ranges, make sure we keep the first and last ticks updated
									me.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;
									me.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;
								}
							}
						}, me);
					} else {
						// We have no labels. Use the ones from the scale
						momentsForDataset = scaleLabelMoments;
					}
	
					me.labelMoments.push(momentsForDataset);
				}, me);
	
				// Set these after we've done all the data
				if (me.options.time.min) {
					me.firstTick = me.parseTime(me.options.time.min);
				}
	
				if (me.options.time.max) {
					me.lastTick = me.parseTime(me.options.time.max);
				}
	
				// We will modify these, so clone for later
				me.firstTick = (me.firstTick || moment()).clone();
				me.lastTick = (me.lastTick || moment()).clone();
			},
			buildLabelDiffs: function() {
				var me = this;
				me.labelDiffs = [];
				var scaleLabelDiffs = [];
				// Parse common labels once
				if (me.chart.data.labels && me.chart.data.labels.length > 0) {
					helpers.each(me.chart.data.labels, function(label) {
						var labelMoment = me.parseTime(label);
	
						if (labelMoment.isValid()) {
							if (me.options.time.round) {
								labelMoment.startOf(me.options.time.round);
							}
							scaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));
						}
					}, me);
				}
	
				helpers.each(me.chart.data.datasets, function(dataset) {
					var diffsForDataset = [];
	
					if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {
						helpers.each(dataset.data, function(value) {
							var labelMoment = me.parseTime(me.getRightValue(value));
	
							if (labelMoment.isValid()) {
								if (me.options.time.round) {
									labelMoment.startOf(me.options.time.round);
								}
								diffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));
							}
						}, me);
					} else {
						// We have no labels. Use common ones
						diffsForDataset = scaleLabelDiffs;
					}
	
					me.labelDiffs.push(diffsForDataset);
				}, me);
			},
			buildTicks: function() {
				var me = this;
	
				me.ctx.save();
				var tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
				var tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
				var tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
				var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
				me.ctx.font = tickLabelFont;
	
				me.ticks = [];
				me.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step
				me.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)
	
				// Set unit override if applicable
				if (me.options.time.unit) {
					me.tickUnit = me.options.time.unit || 'day';
					me.displayFormat = me.options.time.displayFormats[me.tickUnit];
					me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
					me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);
				} else {
					// Determine the smallest needed unit of the time
					var innerWidth = me.isHorizontal() ? me.width : me.height;
	
					// Crude approximation of what the label length might be
					var tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);
					var tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;
					var cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));
					var sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));
					tickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
					var labelCapacity = innerWidth / (tickLabelWidth);
	
					// Start as small as possible
					me.tickUnit = me.options.time.minUnit;
					me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
					me.displayFormat = me.options.time.displayFormats[me.tickUnit];
	
					var unitDefinitionIndex = 0;
					var unitDefinition = time.units[unitDefinitionIndex];
	
					// While we aren't ideal and we don't have units left
					while (unitDefinitionIndex < time.units.length) {
						// Can we scale this unit. If `false` we can scale infinitely
						me.unitScale = 1;
	
						if (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {
							// Use one of the predefined steps
							for (var idx = 0; idx < unitDefinition.steps.length; ++idx) {
								if (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {
									me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);
									break;
								}
							}
	
							break;
						} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {
							// We have a max step. Scale this unit
							me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));
							break;
						} else {
							// Move to the next unit up
							++unitDefinitionIndex;
							unitDefinition = time.units[unitDefinitionIndex];
	
							me.tickUnit = unitDefinition.name;
							var leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);
							var trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);
							me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;
							me.displayFormat = me.options.time.displayFormats[unitDefinition.name];
						}
					}
				}
	
				var roundedStart;
	
				// Only round the first tick if we have no hard minimum
				if (!me.options.time.min) {
					me.firstTick = me.getMomentStartOf(me.firstTick);
					roundedStart = me.firstTick;
				} else {
					roundedStart = me.getMomentStartOf(me.firstTick);
				}
	
				// Only round the last tick if we have no hard maximum
				if (!me.options.time.max) {
					var roundedEnd = me.getMomentStartOf(me.lastTick);
					var delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);
					if (delta < 0) {
						// Do not use end of because we need me to be in the next time unit
						me.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));
					} else if (delta >= 0) {
						me.lastTick = roundedEnd;
					}
	
					me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
				}
	
				// Tick displayFormat override
				if (me.options.time.displayFormat) {
					me.displayFormat = me.options.time.displayFormat;
				}
	
				// first tick. will have been rounded correctly if options.time.min is not specified
				me.ticks.push(me.firstTick.clone());
	
				// For every unit in between the first and last moment, create a moment and add it to the ticks tick
				for (var i = me.unitScale; i <= me.scaleSizeInUnits; i += me.unitScale) {
					var newTick = roundedStart.clone().add(i, me.tickUnit);
	
					// Are we greater than the max time
					if (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {
						break;
					}
	
					me.ticks.push(newTick);
				}
	
				// Always show the right tick
				var diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);
				if (diff !== 0 || me.scaleSizeInUnits === 0) {
					// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart
					// but the last tick was not rounded.
					if (me.options.time.max) {
						me.ticks.push(me.lastTick.clone());
						me.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);
					} else {
						me.ticks.push(me.lastTick.clone());
						me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
					}
				}
	
				me.ctx.restore();
	
				// Invalidate label diffs cache
				me.labelDiffs = undefined;
			},
			// Get tooltip label
			getLabelForIndex: function(index, datasetIndex) {
				var me = this;
				var label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';
				var value = me.chart.data.datasets[datasetIndex].data[index];
	
				if (value !== null && typeof value === 'object') {
					label = me.getRightValue(value);
				}
	
				// Format nicely
				if (me.options.time.tooltipFormat) {
					label = me.parseTime(label).format(me.options.time.tooltipFormat);
				}
	
				return label;
			},
			// Function to format an individual tick mark
			tickFormatFunction: function(tick, index, ticks) {
				var formattedTick = tick.format(this.displayFormat);
				var tickOpts = this.options.ticks;
				var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);
	
				if (callback) {
					return callback(formattedTick, index, ticks);
				}
				return formattedTick;
			},
			convertTicksToLabels: function() {
				var me = this;
				me.tickMoments = me.ticks;
				me.ticks = me.ticks.map(me.tickFormatFunction, me);
			},
			getPixelForValue: function(value, index, datasetIndex) {
				var me = this;
				var offset = null;
				if (index !== undefined && datasetIndex !== undefined) {
					offset = me.getLabelDiff(datasetIndex, index);
				}
	
				if (offset === null) {
					if (!value || !value.isValid) {
						// not already a moment object
						value = me.parseTime(me.getRightValue(value));
					}
					if (value && value.isValid && value.isValid()) {
						offset = value.diff(me.firstTick, me.tickUnit, true);
					}
				}
	
				if (offset !== null) {
					var decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;
	
					if (me.isHorizontal()) {
						var valueOffset = (me.width * decimal);
						return me.left + Math.round(valueOffset);
					}
	
					var heightOffset = (me.height * decimal);
					return me.top + Math.round(heightOffset);
				}
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.tickMoments[index], null, null);
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var innerDimension = me.isHorizontal() ? me.width : me.height;
				var offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;
				offset *= me.scaleSizeInUnits;
				return me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');
			},
			parseTime: function(label) {
				var me = this;
				if (typeof me.options.time.parser === 'string') {
					return moment(label, me.options.time.parser);
				}
				if (typeof me.options.time.parser === 'function') {
					return me.options.time.parser(label);
				}
				// Date objects
				if (typeof label.getMonth === 'function' || typeof label === 'number') {
					return moment(label);
				}
				// Moment support
				if (label.isValid && label.isValid()) {
					return label;
				}
				// Custom parsing (return an instance of moment)
				if (typeof me.options.time.format !== 'string' && me.options.time.format.call) {
					console.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');
					return me.options.time.format(label);
				}
				// Moment format parsing
				return moment(label, me.options.time.format);
			}
		});
		Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
	
	};


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.17.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, (function () { 'use strict';
	
	var hookCallback;
	
	function hooks () {
	    return hookCallback.apply(null, arguments);
	}
	
	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback = callback;
	}
	
	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}
	
	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn't for
	    // input != null
	    return input != null && Object.prototype.toString.call(input) === '[object Object]';
	}
	
	function isObjectEmpty(obj) {
	    var k;
	    for (k in obj) {
	        // even if its not own property I'd still call it non-empty
	        return false;
	    }
	    return true;
	}
	
	function isNumber(input) {
	    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	}
	
	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}
	
	function map(arr, fn) {
	    var res = [], i;
	    for (i = 0; i < arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}
	
	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}
	
	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] = b[i];
	        }
	    }
	
	    if (hasOwnProp(b, 'toString')) {
	        a.toString = b.toString;
	    }
	
	    if (hasOwnProp(b, 'valueOf')) {
	        a.valueOf = b.valueOf;
	    }
	
	    return a;
	}
	
	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}
	
	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null
	    };
	}
	
	function getParsingFlags(m) {
	    if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	    }
	    return m._pf;
	}
	
	var some;
	if (Array.prototype.some) {
	    some = Array.prototype.some;
	} else {
	    some = function (fun) {
	        var t = Object(this);
	        var len = t.length >>> 0;
	
	        for (var i = 0; i < len; i++) {
	            if (i in t && fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }
	
	        return false;
	    };
	}
	
	var some$1 = some;
	
	function isValid(m) {
	    if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
	            return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) &&
	            flags.overflow < 0 &&
	            !flags.empty &&
	            !flags.invalidMonth &&
	            !flags.invalidWeekday &&
	            !flags.nullInput &&
	            !flags.invalidFormat &&
	            !flags.userInvalidated &&
	            (!flags.meridiem || (flags.meridiem && parsedParts));
	
	        if (m._strict) {
	            isNowValid = isNowValid &&
	                flags.charsLeftOver === 0 &&
	                flags.unusedTokens.length === 0 &&
	                flags.bigHour === undefined;
	        }
	
	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}
	
	function createInvalid (flags) {
	    var m = createUTC(NaN);
	    if (flags != null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated = true;
	    }
	
	    return m;
	}
	
	function isUndefined(input) {
	    return input === void 0;
	}
	
	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];
	
	function copyConfig(to, from) {
	    var i, prop, val;
	
	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i = from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f = from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l = from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	    }
	
	    if (momentProperties.length > 0) {
	        for (i in momentProperties) {
	            prop = momentProperties[i];
	            val = from[prop];
	            if (!isUndefined(val)) {
	                to[prop] = val;
	            }
	        }
	    }
	
	    return to;
	}
	
	var updateInProgress = false;
	
	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d = new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	    }
	}
	
	function isMoment (obj) {
	    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}
	
	function absFloor (number) {
	    if (number < 0) {
	        // -0 -> 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}
	
	function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;
	
	    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	    }
	
	    return value;
	}
	
	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;
	    for (i = 0; i < len; i++) {
	        if ((dontConvert && array1[i] !== array2[i]) ||
	            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}
	
	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false &&
	            (typeof console !==  'undefined') && console.warn) {
	        console.warn('Deprecation warning: ' + msg);
	    }
	}
	
	function deprecate(msg, fn) {
	    var firstTime = true;
	
	    return extend(function () {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args = [];
	            var arg;
	            for (var i = 0; i < arguments.length; i++) {
	                arg = '';
	                if (typeof arguments[i] === 'object') {
	                    arg += '\n[' + i + '] ';
	                    for (var key in arguments[0]) {
	                        arg += key + ': ' + arguments[0][key] + ', ';
	                    }
	                    arg = arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg = arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	            firstTime = false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}
	
	var deprecations = {};
	
	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	    }
	}
	
	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;
	
	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}
	
	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop = config[i];
	        if (isFunction(prop)) {
	            this[i] = prop;
	        } else {
	            this['_' + i] = prop;
	        }
	    }
	    this._config = config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _ordinalParseLenient.
	    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	}
	
	function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                res[prop] = {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] != null) {
	                res[prop] = childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don't modify parent config
	            res[prop] = extend({}, res[prop]);
	        }
	    }
	    return res;
	}
	
	function Locale(config) {
	    if (config != null) {
	        this.set(config);
	    }
	}
	
	var keys;
	
	if (Object.keys) {
	    keys = Object.keys;
	} else {
	    keys = function (obj) {
	        var i, res = [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}
	
	var keys$1 = keys;
	
	var defaultCalendar = {
	    sameDay : '[Today at] LT',
	    nextDay : '[Tomorrow at] LT',
	    nextWeek : 'dddd [at] LT',
	    lastDay : '[Yesterday at] LT',
	    lastWeek : '[Last] dddd [at] LT',
	    sameElse : 'L'
	};
	
	function calendar (key, mom, now) {
	    var output = this._calendar[key] || this._calendar['sameElse'];
	    return isFunction(output) ? output.call(mom, now) : output;
	}
	
	var defaultLongDateFormat = {
	    LTS  : 'h:mm:ss A',
	    LT   : 'h:mm A',
	    L    : 'MM/DD/YYYY',
	    LL   : 'MMMM D, YYYY',
	    LLL  : 'MMMM D, YYYY h:mm A',
	    LLLL : 'dddd, MMMM D, YYYY h:mm A'
	};
	
	function longDateFormat (key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];
	
	    if (format || !formatUpper) {
	        return format;
	    }
	
	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });
	
	    return this._longDateFormat[key];
	}
	
	var defaultInvalidDate = 'Invalid date';
	
	function invalidDate () {
	    return this._invalidDate;
	}
	
	var defaultOrdinal = '%d';
	var defaultOrdinalParse = /\d{1,2}/;
	
	function ordinal (number) {
	    return this._ordinal.replace('%d', number);
	}
	
	var defaultRelativeTime = {
	    future : 'in %s',
	    past   : '%s ago',
	    s  : 'a few seconds',
	    m  : 'a minute',
	    mm : '%d minutes',
	    h  : 'an hour',
	    hh : '%d hours',
	    d  : 'a day',
	    dd : '%d days',
	    M  : 'a month',
	    MM : '%d months',
	    y  : 'a year',
	    yy : '%d years'
	};
	
	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}
	
	function pastFuture (diff, output) {
	    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}
	
	var aliases = {};
	
	function addUnitAlias (unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}
	
	function normalizeUnits(units) {
	    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}
	
	function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;
	
	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp = normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] = inputObject[prop];
	            }
	        }
	    }
	
	    return normalizedInput;
	}
	
	var priorities = {};
	
	function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	}
	
	function getPrioritizedUnits(unitsObj) {
	    var units = [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}
	
	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value != null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}
	
	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}
	
	function set$1 (mom, unit, value) {
	    if (mom.isValid()) {
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	    }
	}
	
	// MOMENTS
	
	function stringGet (units) {
	    units = normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}
	
	
	function stringSet (units, value) {
	    if (typeof units === 'object') {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);
	        for (var i = 0; i < prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}
	
	function zeroFill(number, targetLength, forceSign) {
	    var absNumber = '' + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number >= 0;
	    return (sign ? (forceSign ? '+' : '') : '-') +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}
	
	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	
	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	
	var formatFunctions = {};
	
	var formatTokenFunctions = {};
	
	// token:    'M'
	// padded:   ['MM', 2]
	// ordinal:  'Mo'
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func = callback;
	    if (typeof callback === 'string') {
	        func = function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] = func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}
	
	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, '');
	    }
	    return input.replace(/\\/g, '');
	}
	
	function makeFormatFunction(format) {
	    var array = format.match(formattingTokens), i, length;
	
	    for (i = 0, length = array.length; i < length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] = formatTokenFunctions[array[i]];
	        } else {
	            array[i] = removeFormattingTokens(array[i]);
	        }
	    }
	
	    return function (mom) {
	        var output = '', i;
	        for (i = 0; i < length; i++) {
	            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}
	
	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }
	
	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	
	    return formatFunctions[format](m);
	}
	
	function expandFormat(format, locale) {
	    var i = 5;
	
	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }
	
	    localFormattingTokens.lastIndex = 0;
	    while (i >= 0 && localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	    }
	
	    return format;
	}
	
	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
	
	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf
	
	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
	
	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	
	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
	
	
	var regexes = {};
	
	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict && strictRegex) ? strictRegex : regex;
	    };
	}
	
	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }
	
	    return regexes[token](config._strict, config._locale);
	}
	
	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}
	
	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}
	
	var tokens = {};
	
	function addParseToken (token, callback) {
	    var i, func = callback;
	    if (typeof token === 'string') {
	        token = [token];
	    }
	    if (isNumber(callback)) {
	        func = function (input, array) {
	            array[callback] = toInt(input);
	        };
	    }
	    for (i = 0; i < token.length; i++) {
	        tokens[token[i]] = func;
	    }
	}
	
	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	    });
	}
	
	function addTimeToArrayFromToken(token, input, config) {
	    if (input != null && hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}
	
	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;
	
	var indexOf;
	
	if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	} else {
	    indexOf = function (o) {
	        // I know
	        var i;
	        for (i = 0; i < this.length; ++i) {
	            if (this[i] === o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	
	var indexOf$1 = indexOf;
	
	function daysInMonth(year, month) {
	    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	}
	
	// FORMATTING
	
	addFormatToken('M', ['MM', 2], 'Mo', function () {
	    return this.month() + 1;
	});
	
	addFormatToken('MMM', 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});
	
	addFormatToken('MMMM', 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});
	
	// ALIASES
	
	addUnitAlias('month', 'M');
	
	// PRIORITY
	
	addUnitPriority('month', 8);
	
	// PARSING
	
	addRegexToken('M',    match1to2);
	addRegexToken('MM',   match1to2, match2);
	addRegexToken('MMM',  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});
	
	addParseToken(['M', 'MM'], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	});
	
	addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict);
	    // if we didn't find a month name, mark the date as invalid.
	    if (month != null) {
	        array[MONTH] = month;
	    } else {
	        getParsingFlags(config).invalidMonth = input;
	    }
	});
	
	// LOCALES
	
	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths (m, format) {
	    if (!m) {
	        return this._months;
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	}
	
	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return this._monthsShort;
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}
	
	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc = monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	        for (i = 0; i < 12; ++i) {
	            mom = createUTC([2000, i]);
	            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	        }
	    }
	
	    if (strict) {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}
	
	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;
	
	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }
	
	    if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	    }
	
	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        if (strict && !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	        }
	        if (!strict && !this._monthsParse[i]) {
	            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict && this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}
	
	// MOMENTS
	
	function setMonth (mom, value) {
	    var dayOfMonth;
	
	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }
	
	    if (typeof value === 'string') {
	        if (/^\d+$/.test(value)) {
	            value = toInt(value);
	        } else {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }
	
	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	    return mom;
	}
	
	function getSetMonth (value) {
	    if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, 'Month');
	    }
	}
	
	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}
	
	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsShortRegex')) {
	            this._monthsShortRegex = defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex && isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}
	
	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            this._monthsRegex = defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex && isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}
	
	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }
	
	    var shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom;
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, ''));
	        longPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.monthsShort(mom, ''));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	    }
	    for (i = 0; i < 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }
	
	    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	}
	
	// FORMATTING
	
	addFormatToken('Y', 0, 0, function () {
	    var y = this.year();
	    return y <= 9999 ? '' + y : '+' + y;
	});
	
	addFormatToken(0, ['YY', 2], 0, function () {
	    return this.year() % 100;
	});
	
	addFormatToken(0, ['YYYY',   4],       0, 'year');
	addFormatToken(0, ['YYYYY',  5],       0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
	
	// ALIASES
	
	addUnitAlias('year', 'y');
	
	// PRIORITIES
	
	addUnitPriority('year', 1);
	
	// PARSING
	
	addRegexToken('Y',      matchSigned);
	addRegexToken('YY',     match1to2, match2);
	addRegexToken('YYYY',   match1to4, match4);
	addRegexToken('YYYYY',  match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);
	
	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	});
	
	// HELPERS
	
	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}
	
	function isLeapYear(year) {
	    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}
	
	// HOOKS
	
	hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};
	
	// MOMENTS
	
	var getSetYear = makeGetSet('FullYear', true);
	
	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}
	
	function createDate (y, m, d, h, M, s, ms) {
	    //can't just apply() to create a date:
	    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	    var date = new Date(y, m, d, h, M, s, ms);
	
	    //the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	    }
	    return date;
	}
	
	function createUTCDate (y) {
	    var date = new Date(Date.UTC.apply(null, arguments));
	
	    //the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	    }
	    return date;
	}
	
	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
	
	    return -fwdlw + fwd - 1;
	}
	
	//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;
	
	    if (dayOfYear <= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear > daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	    }
	
	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}
	
	function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;
	
	    if (week < 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week > weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	    } else {
	        resYear = mom.year();
	        resWeek = week;
	    }
	
	    return {
	        week: resWeek,
	        year: resYear
	    };
	}
	
	function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}
	
	// FORMATTING
	
	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
	
	// ALIASES
	
	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');
	
	// PRIORITIES
	
	addUnitPriority('week', 5);
	addUnitPriority('isoWeek', 5);
	
	// PARSING
	
	addRegexToken('w',  match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W',  match1to2);
	addRegexToken('WW', match1to2, match2);
	
	addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	});
	
	// HELPERS
	
	// LOCALES
	
	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}
	
	var defaultLocaleWeek = {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 1st is the first week of the year.
	};
	
	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}
	
	function localeFirstDayOfYear () {
	    return this._week.doy;
	}
	
	// MOMENTS
	
	function getSetWeek (input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}
	
	function getSetISOWeek (input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}
	
	// FORMATTING
	
	addFormatToken('d', 0, 'do', 'day');
	
	addFormatToken('dd', 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});
	
	addFormatToken('ddd', 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});
	
	addFormatToken('dddd', 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});
	
	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');
	
	// ALIASES
	
	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');
	
	// PRIORITY
	addUnitPriority('day', 11);
	addUnitPriority('weekday', 11);
	addUnitPriority('isoWeekday', 11);
	
	// PARSING
	
	addRegexToken('d',    match1to2);
	addRegexToken('e',    match1to2);
	addRegexToken('E',    match1to2);
	addRegexToken('dd',   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken('ddd',   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken('dddd',   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});
	
	addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn't get a weekday name, mark the date as invalid
	    if (weekday != null) {
	        week.d = weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday = input;
	    }
	});
	
	addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	    week[token] = toInt(input);
	});
	
	// HELPERS
	
	function parseWeekday(input, locale) {
	    if (typeof input !== 'string') {
	        return input;
	    }
	
	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }
	
	    input = locale.weekdaysParse(input);
	    if (typeof input === 'number') {
	        return input;
	    }
	
	    return null;
	}
	
	function parseIsoWeekday(input, locale) {
	    if (typeof input === 'string') {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}
	
	// LOCALES
	
	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays (m, format) {
	    if (!m) {
	        return this._weekdays;
	    }
	    return isArray(this._weekdays) ? this._weekdays[m.day()] :
	        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	}
	
	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort (m) {
	    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}
	
	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin (m) {
	    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}
	
	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];
	
	        for (i = 0; i < 7; ++i) {
	            mom = createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	        }
	    }
	
	    if (strict) {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}
	
	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;
	
	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }
	
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	    }
	
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	
	        mom = createUTC([2000, 1]).day(i);
	        if (strict && !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	        }
	        if (!this._weekdaysParse[i]) {
	            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}
	
	// MOMENTS
	
	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, 'd');
	    } else {
	        return day;
	    }
	}
	
	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, 'd');
	}
	
	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	
	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.
	
	    if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}
	
	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            this._weekdaysRegex = defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex && isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}
	
	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex && isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}
	
	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex && isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}
	
	
	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }
	
	    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom, minp, shortp, longp;
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, '');
	        shortp = this.weekdaysShort(mom, '');
	        longp = this.weekdays(mom, '');
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }
	
	    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;
	
	    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	}
	
	// FORMATTING
	
	function hFormat() {
	    return this.hours() % 12 || 12;
	}
	
	function kFormat() {
	    return this.hours() || 24;
	}
	
	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);
	addFormatToken('k', ['kk', 2], 0, kFormat);
	
	addFormatToken('hmm', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});
	
	addFormatToken('hmmss', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});
	
	addFormatToken('Hmm', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2);
	});
	
	addFormatToken('Hmmss', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});
	
	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}
	
	meridiem('a', true);
	meridiem('A', false);
	
	// ALIASES
	
	addUnitAlias('hour', 'h');
	
	// PRIORITY
	addUnitPriority('hour', 13);
	
	// PARSING
	
	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}
	
	addRegexToken('a',  matchMeridiem);
	addRegexToken('A',  matchMeridiem);
	addRegexToken('H',  match1to2);
	addRegexToken('h',  match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);
	
	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);
	
	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['a', 'A'], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	});
	
	// LOCALES
	
	function localeIsPM (input) {
	    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + '').toLowerCase().charAt(0) === 'p');
	}
	
	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours > 11) {
	        return isLower ? 'pm' : 'PM';
	    } else {
	        return isLower ? 'am' : 'AM';
	    }
	}
	
	
	// MOMENTS
	
	// Setting the hour should keep the time, because the user explicitly
	// specified which hour he wants. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet('Hours', true);
	
	// months
	// week
	// weekdays
	// meridiem
	var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    ordinalParse: defaultOrdinalParse,
	    relativeTime: defaultRelativeTime,
	
	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,
	
	    week: defaultLocaleWeek,
	
	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,
	
	    meridiemParse: defaultLocaleMeridiemParse
	};
	
	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;
	
	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace('_', '-') : key;
	}
	
	// pick the locale from the array
	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
	    var i = 0, j, next, locale, split;
	
	    while (i < names.length) {
	        split = normalizeLocale(names[i]).split('-');
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split('-') : null;
	        while (j > 0) {
	            locale = loadLocale(split.slice(0, j).join('-'));
	            if (locale) {
	                return locale;
	            }
	            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return null;
	}
	
	function loadLocale(name) {
	    var oldLocale = null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] && (typeof module !== 'undefined') &&
	            module && module.exports) {
	        try {
	            oldLocale = globalLocale._abbr;
	            __webpack_require__(95)("./" + name);
	            // because defineLocale currently also sets the global locale, we
	            // want to undo that for lazy loaded locales
	            getSetGlobalLocale(oldLocale);
	        } catch (e) { }
	    }
	    return locales[name];
	}
	
	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data = getLocale(key);
	        }
	        else {
	            data = defineLocale(key, values);
	        }
	
	        if (data) {
	            // moment.duration._locale = moment._locale = data;
	            globalLocale = data;
	        }
	    }
	
	    return globalLocale._abbr;
	}
	
	function defineLocale (name, config) {
	    if (config !== null) {
	        var parentConfig = baseConfig;
	        config.abbr = name;
	        if (locales[name] != null) {
	            deprecateSimple('defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                    'an existing locale. moment.defineLocale(localeName, ' +
	                    'config) should only be used for creating a new locale ' +
	                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	            parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	            if (locales[config.parentLocale] != null) {
	                parentConfig = locales[config.parentLocale]._config;
	            } else {
	                if (!localeFamilies[config.parentLocale]) {
	                    localeFamilies[config.parentLocale] = [];
	                }
	                localeFamilies[config.parentLocale].push({
	                    name: name,
	                    config: config
	                });
	                return null;
	            }
	        }
	        locales[name] = new Locale(mergeConfigs(parentConfig, config));
	
	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }
	
	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won't end up with the child locale set.
	        getSetGlobalLocale(name);
	
	
	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}
	
	function updateLocale(name, config) {
	    if (config != null) {
	        var locale, parentConfig = baseConfig;
	        // MERGE
	        if (locales[name] != null) {
	            parentConfig = locales[name]._config;
	        }
	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale;
	
	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	            if (locales[name].parentLocale != null) {
	                locales[name] = locales[name].parentLocale;
	            } else if (locales[name] != null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}
	
	// returns locale data
	function getLocale (key) {
	    var locale;
	
	    if (key && key._locale && key._locale._abbr) {
	        key = key._locale._abbr;
	    }
	
	    if (!key) {
	        return globalLocale;
	    }
	
	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key = [key];
	    }
	
	    return chooseLocale(key);
	}
	
	function listLocales() {
	    return keys$1(locales);
	}
	
	function checkOverflow (m) {
	    var overflow;
	    var a = m._a;
	
	    if (a && getParsingFlags(m).overflow === -2) {
	        overflow =
	            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	            -1;
	
	        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	            overflow = DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	            overflow = WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	            overflow = WEEKDAY;
	        }
	
	        getParsingFlags(m).overflow = overflow;
	    }
	
	    return m;
	}
	
	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	
	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
	
	var isoDates = [
	    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	    ['YYYY-DDD', /\d{4}-\d{3}/],
	    ['YYYY-MM', /\d{4}-\d\d/, false],
	    ['YYYYYYMMDD', /[+-]\d{10}/],
	    ['YYYYMMDD', /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    ['GGGG[W]WWE', /\d{4}W\d{3}/],
	    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	    ['YYYYDDD', /\d{7}/]
	];
	
	// iso time formats and regexes
	var isoTimes = [
	    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	    ['HH:mm', /\d\d:\d\d/],
	    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	    ['HHmmss', /\d\d\d\d\d\d/],
	    ['HHmm', /\d\d\d\d/],
	    ['HH', /\d\d/]
	];
	
	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
	
	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;
	
	    if (match) {
	        getParsingFlags(config).iso = true;
	
	        for (i = 0, l = isoDates.length; i < l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat = isoDates[i][0];
	                allowTime = isoDates[i][2] !== false;
	                break;
	            }
	        }
	        if (dateFormat == null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[3]) {
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be 'T' or space
	                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat == null) {
	                config._isValid = false;
	                return;
	            }
	        }
	        if (!allowTime && timeFormat != null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat = 'Z';
	            } else {
	                config._isValid = false;
	                return;
	            }
	        }
	        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid = false;
	    }
	}
	
	// date from iso format or fallback
	function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);
	
	    if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	    }
	
	    configFromISO(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	        hooks.createFromInputFallback(config);
	    }
	}
	
	hooks.createFromInputFallback = deprecate(
	    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
	    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
	    'discouraged and will be removed in an upcoming major release. Please refer to ' +
	    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	    function (config) {
	        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	    }
	);
	
	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a != null) {
	        return a;
	    }
	    if (b != null) {
	        return b;
	    }
	    return c;
	}
	
	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}
	
	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input = [], currentDate, yearToUse;
	
	    if (config._d) {
	        return;
	    }
	
	    currentDate = currentDateArray(config);
	
	    //compute day of the year from weeks and weekdays
	    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	    }
	
	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
	
	        if (config._dayOfYear > daysInYear(yearToUse)) {
	            getParsingFlags(config)._overflowDayOfYear = true;
	        }
	
	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	    }
	
	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don't default anything
	    for (i = 0; i < 3 && config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	    }
	
	    // Zero out whatever was not defaulted, including time
	    for (; i < 7; i++) {
	        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	    }
	
	    // Check for 24:00:00.000
	    if (config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	    }
	
	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }
	
	    if (config._nextDay) {
	        config._a[HOUR] = 24;
	    }
	}
	
	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
	
	    w = config._w;
	    if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4;
	
	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);
	        if (weekday < 1 || weekday > 7) {
	            weekdayOverflow = true;
	        }
	    } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;
	
	        var curWeek = weekOfYear(createLocal(), dow, doy);
	
	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
	
	        // Default to current week.
	        week = defaults(w.w, curWeek.week);
	
	        if (w.d != null) {
	            // weekday -- low day numbers are considered next week
	            weekday = w.d;
	            if (weekday < 0 || weekday > 6) {
	                weekdayOverflow = true;
	            }
	        } else if (w.e != null) {
	            // local weekday -- counting starts from begining of week
	            weekday = w.e + dow;
	            if (w.e < 0 || w.e > 6) {
	                weekdayOverflow = true;
	            }
	        } else {
	            // default to begining of week
	            weekday = dow;
	        }
	    }
	    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	    } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	}
	
	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};
	
	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }
	
	    config._a = [];
	    getParsingFlags(config).empty = true;
	
	    // This array is used to make a Date, either with `new Date` or `Date.UTC`
	    var string = '' + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;
	
	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
	
	    for (i = 0; i < tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log('token', token, 'parsedInput', parsedInput,
	        //         'regex', getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped = string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length > 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength += parsedInput.length;
	        }
	        // don't parse if it's not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty = false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict && !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }
	
	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	    if (string.length > 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }
	
	    // clear _12h flag if hour is <= 12
	    if (config._a[HOUR] <= 12 &&
	        getParsingFlags(config).bigHour === true &&
	        config._a[HOUR] > 0) {
	        getParsingFlags(config).bigHour = undefined;
	    }
	
	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem;
	    // handle meridiem
	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	
	    configFromArray(config);
	    checkOverflow(config);
	}
	
	
	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;
	
	    if (meridiem == null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);
	        if (isPm && hour < 12) {
	            hour += 12;
	        }
	        if (!isPm && hour === 12) {
	            hour = 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}
	
	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,
	
	        scoreToBeat,
	        i,
	        currentScore;
	
	    if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	    }
	
	    for (i = 0; i < config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);
	        if (config._useUTC != null) {
	            tempConfig._useUTC = config._useUTC;
	        }
	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);
	
	        if (!isValid(tempConfig)) {
	            continue;
	        }
	
	        // if there is any input that was not parsed add a penalty for that format
	        currentScore += getParsingFlags(tempConfig).charsLeftOver;
	
	        //or tokens
	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	
	        getParsingFlags(tempConfig).score = currentScore;
	
	        if (scoreToBeat == null || currentScore < scoreToBeat) {
	            scoreToBeat = currentScore;
	            bestMoment = tempConfig;
	        }
	    }
	
	    extend(config, bestMoment || tempConfig);
	}
	
	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }
	
	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj && parseInt(obj, 10);
	    });
	
	    configFromArray(config);
	}
	
	function createFromConfig (config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, 'd');
	        res._nextDay = undefined;
	    }
	
	    return res;
	}
	
	function prepareConfig (config) {
	    var input = config._i,
	        format = config._f;
	
	    config._locale = config._locale || getLocale(config._l);
	
	    if (input === null || (format === undefined && input === '')) {
	        return createInvalid({nullInput: true});
	    }
	
	    if (typeof input === 'string') {
	        config._i = input = config._locale.preparse(input);
	    }
	
	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d = input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }
	
	    if (!isValid(config)) {
	        config._d = null;
	    }
	
	    return config;
	}
	
	function configFromInput(config) {
	    var input = config._i;
	    if (input === undefined) {
	        config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	    } else if (typeof input === 'string') {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (typeof(input) === 'object') {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}
	
	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c = {};
	
	    if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	    }
	
	    if ((isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)) {
	        input = undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;
	
	    return createFromConfig(c);
	}
	
	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}
	
	var prototypeMin = deprecate(
	    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other < this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);
	
	var prototypeMax = deprecate(
	    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other > this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);
	
	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length === 1 && isArray(moments[0])) {
	        moments = moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res = moments[0];
	    for (i = 1; i < moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res = moments[i];
	        }
	    }
	    return res;
	}
	
	// TODO: Use [].sort instead?
	function min () {
	    var args = [].slice.call(arguments, 0);
	
	    return pickBy('isBefore', args);
	}
	
	function max () {
	    var args = [].slice.call(arguments, 0);
	
	    return pickBy('isAfter', args);
	}
	
	var now = function () {
	    return Date.now ? Date.now() : +(new Date());
	};
	
	function Duration (duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;
	
	    // representation for dateAddRemove
	    this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days = +days +
	        weeks * 7;
	    // It is impossible translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months = +months +
	        quarters * 3 +
	        years * 12;
	
	    this._data = {};
	
	    this._locale = getLocale();
	
	    this._bubble();
	}
	
	function isDuration (obj) {
	    return obj instanceof Duration;
	}
	
	function absRound (number) {
	    if (number < 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}
	
	// FORMATTING
	
	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = '+';
	        if (offset < 0) {
	            offset = -offset;
	            sign = '-';
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}
	
	offset('Z', ':');
	offset('ZZ', '');
	
	// PARSING
	
	addRegexToken('Z',  matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	});
	
	// HELPERS
	
	// timezone chunker
	// '+10:00' > ['10',  '00']
	// '-1530'  > ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;
	
	function offsetFromString(matcher, string) {
	    var matches = (string || '').match(matcher);
	
	    if (matches === null) {
	        return null;
	    }
	
	    var chunk   = matches[matches.length - 1] || [];
	    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	    return minutes === 0 ?
	      0 :
	      parts[0] === '+' ? minutes : -minutes;
	}
	
	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}
	
	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}
	
	// HOOKS
	
	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};
	
	// MOMENTS
	
	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime) {
	    var offset = this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    if (input != null) {
	        if (typeof input === 'string') {
	            input = offsetFromString(matchShortOffset, input);
	            if (input === null) {
	                return this;
	            }
	        } else if (Math.abs(input) < 16) {
	            input = input * 60;
	        }
	        if (!this._isUTC && keepLocalTime) {
	            localAdjust = getDateOffset(this);
	        }
	        this._offset = input;
	        this._isUTC = true;
	        if (localAdjust != null) {
	            this.add(localAdjust, 'm');
	        }
	        if (offset !== input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress = true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress = null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}
	
	function getSetZone (input, keepLocalTime) {
	    if (input != null) {
	        if (typeof input !== 'string') {
	            input = -input;
	        }
	
	        this.utcOffset(input, keepLocalTime);
	
	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}
	
	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}
	
	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;
	
	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), 'm');
	        }
	    }
	    return this;
	}
	
	function setOffsetToParsedOffset () {
	    if (this._tzm != null) {
	        this.utcOffset(this._tzm);
	    } else if (typeof this._i === 'string') {
	        var tZone = offsetFromString(matchOffset, this._i);
	        if (tZone != null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}
	
	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input = input ? createLocal(input).utcOffset() : 0;
	
	    return (this.utcOffset() - input) % 60 === 0;
	}
	
	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() > this.clone().month(0).utcOffset() ||
	        this.utcOffset() > this.clone().month(5).utcOffset()
	    );
	}
	
	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }
	
	    var c = {};
	
	    copyConfig(c, this);
	    c = prepareConfig(c);
	
	    if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() &&
	            compareArrays(c._a, other.toArray()) > 0;
	    } else {
	        this._isDSTShifted = false;
	    }
	
	    return this._isDSTShifted;
	}
	
	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}
	
	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}
	
	function isUtc () {
	    return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}
	
	// ASP.NET json date format regex
	var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
	
	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
	
	function createDuration (input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	        match = null,
	        sign,
	        ret,
	        diffRes;
	
	    if (isDuration(input)) {
	        duration = {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration = {};
	        if (key) {
	            duration[key] = input;
	        } else {
	            duration.milliseconds = input;
	        }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match = isoRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration == null) {// checks for null or undefined
	        duration = {};
	    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
	
	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	    }
	
	    ret = new Duration(duration);
	
	    if (isDuration(input) && hasOwnProp(input, '_locale')) {
	        ret._locale = input._locale;
	    }
	
	    return ret;
	}
	
	createDuration.fn = Duration.prototype;
	
	function parseIso (inp, sign) {
	    // We'd normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp && parseFloat(inp.replace(',', '.'));
	    // apply sign while we're at it
	    return (isNaN(res) ? 0 : res) * sign;
	}
	
	function positiveMomentsDifference(base, other) {
	    var res = {milliseconds: 0, months: 0};
	
	    res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, 'M').isAfter(other)) {
	        --res.months;
	    }
	
	    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
	
	    return res;
	}
	
	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() && other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }
	
	    other = cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	    } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	    }
	
	    return res;
	}
	
	// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !== null && !isNaN(+period)) {
	            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	            tmp = val; val = period; period = tmp;
	        }
	
	        val = typeof val === 'string' ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}
	
	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);
	
	    if (!mom.isValid()) {
	        // No op
	        return;
	    }
	
	    updateOffset = updateOffset == null ? true : updateOffset;
	
	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (days) {
	        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	    }
	    if (months) {
	        setMonth(mom, get(mom, 'Month') + months * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}
	
	var add      = createAdder(1, 'add');
	var subtract = createAdder(-1, 'subtract');
	
	function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, 'days', true);
	    return diff < -6 ? 'sameElse' :
	            diff < -1 ? 'lastWeek' :
	            diff < 0 ? 'lastDay' :
	            diff < 1 ? 'sameDay' :
	            diff < 2 ? 'nextDay' :
	            diff < 7 ? 'nextWeek' : 'sameElse';
	}
	
	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we're local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf('day'),
	        format = hooks.calendarFormat(this, sod) || 'sameElse';
	
	    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
	
	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}
	
	function clone () {
	    return new Moment(this);
	}
	
	function isAfter (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() > localInput.valueOf();
	    } else {
	        return localInput.valueOf() < this.clone().startOf(units).valueOf();
	    }
	}
	
	function isBefore (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() < localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() < localInput.valueOf();
	    }
	}
	
	function isBetween (from, to, units, inclusivity) {
	    inclusivity = inclusivity || '()';
	    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	}
	
	function isSame (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units || 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() === localInput.valueOf();
	    } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	    }
	}
	
	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input,units);
	}
	
	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input,units);
	}
	
	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        delta, output;
	
	    if (!this.isValid()) {
	        return NaN;
	    }
	
	    that = cloneWithOffset(input, this);
	
	    if (!that.isValid()) {
	        return NaN;
	    }
	
	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
	
	    units = normalizeUnits(units);
	
	    if (units === 'year' || units === 'month' || units === 'quarter') {
	        output = monthDiff(this, that);
	        if (units === 'quarter') {
	            output = output / 3;
	        } else if (units === 'year') {
	            output = output / 12;
	        }
	    } else {
	        delta = this - that;
	        output = units === 'second' ? delta / 1e3 : // 1000
	            units === 'minute' ? delta / 6e4 : // 1000 * 60
	            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	            delta;
	    }
	    return asFloat ? output : absFloor(output);
	}
	
	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor = a.clone().add(wholeMonthDiff, 'months'),
	        anchor2, adjust;
	
	    if (b - anchor < 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor2 - anchor);
	    }
	
	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}
	
	hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
	
	function toString () {
	    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}
	
	function toISOString () {
	    var m = this.clone().utc();
	    if (0 < m.year() && m.year() <= 9999) {
	        if (isFunction(Date.prototype.toISOString)) {
	            // native implementation is ~50x faster, use it when we can
	            return this.toDate().toISOString();
	        } else {
	            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    } else {
	        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	    }
	}
	
	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return 'moment.invalid(/* ' + this._i + ' */)';
	    }
	    var func = 'moment';
	    var zone = '';
	    if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	        zone = 'Z';
	    }
	    var prefix = '[' + func + '("]';
	    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
	    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	    var suffix = zone + '[")]';
	
	    return this.format(prefix + year + datetime + suffix);
	}
	
	function format (inputString) {
	    if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}
	
	function from (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}
	
	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}
	
	function to (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}
	
	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}
	
	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;
	
	    if (key === undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData = getLocale(key);
	        if (newLocaleData != null) {
	            this._locale = newLocaleData;
	        }
	        return this;
	    }
	}
	
	var lang = deprecate(
	    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	    function (key) {
	        if (key === undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);
	
	function localeData () {
	    return this._locale;
	}
	
	function startOf (units) {
	    units = normalizeUnits(units);
	    // the following switch intentionally omits break keywords
	    // to utilize falling through the cases.
	    switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	        case 'date':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	    }
	
	    // weeks are a special case
	    if (units === 'week') {
	        this.weekday(0);
	    }
	    if (units === 'isoWeek') {
	        this.isoWeekday(1);
	    }
	
	    // quarters are also special
	    if (units === 'quarter') {
	        this.month(Math.floor(this.month() / 3) * 3);
	    }
	
	    return this;
	}
	
	function endOf (units) {
	    units = normalizeUnits(units);
	    if (units === undefined || units === 'millisecond') {
	        return this;
	    }
	
	    // 'date' is an alias for 'day', so it should be considered as such.
	    if (units === 'date') {
	        units = 'day';
	    }
	
	    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	}
	
	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}
	
	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}
	
	function toDate () {
	    return new Date(this.valueOf());
	}
	
	function toArray () {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}
	
	function toObject () {
	    var m = this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}
	
	function toJSON () {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	}
	
	function isValid$1 () {
	    return isValid(this);
	}
	
	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}
	
	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}
	
	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}
	
	// FORMATTING
	
	addFormatToken(0, ['gg', 2], 0, function () {
	    return this.weekYear() % 100;
	});
	
	addFormatToken(0, ['GG', 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});
	
	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}
	
	addWeekYearFormatToken('gggg',     'weekYear');
	addWeekYearFormatToken('ggggg',    'weekYear');
	addWeekYearFormatToken('GGGG',  'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');
	
	// ALIASES
	
	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');
	
	// PRIORITY
	
	addUnitPriority('weekYear', 1);
	addUnitPriority('isoWeekYear', 1);
	
	
	// PARSING
	
	addRegexToken('G',      matchSigned);
	addRegexToken('g',      matchSigned);
	addRegexToken('GG',     match1to2, match2);
	addRegexToken('gg',     match1to2, match2);
	addRegexToken('GGGG',   match1to4, match4);
	addRegexToken('gggg',   match1to4, match4);
	addRegexToken('GGGGG',  match1to6, match6);
	addRegexToken('ggggg',  match1to6, match6);
	
	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	});
	
	addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	});
	
	// MOMENTS
	
	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}
	
	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}
	
	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}
	
	function getWeeksInYear () {
	    var weekInfo = this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}
	
	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget = weeksInYear(input, dow, doy);
	        if (week > weeksTarget) {
	            week = weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}
	
	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
	
	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}
	
	// FORMATTING
	
	addFormatToken('Q', 0, 'Qo', 'quarter');
	
	// ALIASES
	
	addUnitAlias('quarter', 'Q');
	
	// PRIORITY
	
	addUnitPriority('quarter', 7);
	
	// PARSING
	
	addRegexToken('Q', match1);
	addParseToken('Q', function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	});
	
	// MOMENTS
	
	function getSetQuarter (input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}
	
	// FORMATTING
	
	addFormatToken('D', ['DD', 2], 'Do', 'date');
	
	// ALIASES
	
	addUnitAlias('date', 'D');
	
	// PRIOROITY
	addUnitPriority('date', 9);
	
	// PARSING
	
	addRegexToken('D',  match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function (isStrict, locale) {
	    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	});
	
	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0], 10);
	});
	
	// MOMENTS
	
	var getSetDayOfMonth = makeGetSet('Date', true);
	
	// FORMATTING
	
	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
	
	// ALIASES
	
	addUnitAlias('dayOfYear', 'DDD');
	
	// PRIORITY
	addUnitPriority('dayOfYear', 4);
	
	// PARSING
	
	addRegexToken('DDD',  match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	});
	
	// HELPERS
	
	// MOMENTS
	
	function getSetDayOfYear (input) {
	    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}
	
	// FORMATTING
	
	addFormatToken('m', ['mm', 2], 0, 'minute');
	
	// ALIASES
	
	addUnitAlias('minute', 'm');
	
	// PRIORITY
	
	addUnitPriority('minute', 14);
	
	// PARSING
	
	addRegexToken('m',  match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);
	
	// MOMENTS
	
	var getSetMinute = makeGetSet('Minutes', false);
	
	// FORMATTING
	
	addFormatToken('s', ['ss', 2], 0, 'second');
	
	// ALIASES
	
	addUnitAlias('second', 's');
	
	// PRIORITY
	
	addUnitPriority('second', 15);
	
	// PARSING
	
	addRegexToken('s',  match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);
	
	// MOMENTS
	
	var getSetSecond = makeGetSet('Seconds', false);
	
	// FORMATTING
	
	addFormatToken('S', 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});
	
	addFormatToken(0, ['SS', 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});
	
	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	    return this.millisecond() * 1000000;
	});
	
	
	// ALIASES
	
	addUnitAlias('millisecond', 'ms');
	
	// PRIORITY
	
	addUnitPriority('millisecond', 16);
	
	// PARSING
	
	addRegexToken('S',    match1to3, match1);
	addRegexToken('SS',   match1to3, match2);
	addRegexToken('SSS',  match1to3, match3);
	
	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
	    addRegexToken(token, matchUnsigned);
	}
	
	function parseMs(input, array) {
	    array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}
	
	for (token = 'S'; token.length <= 9; token += 'S') {
	    addParseToken(token, parseMs);
	}
	// MOMENTS
	
	var getSetMillisecond = makeGetSet('Milliseconds', false);
	
	// FORMATTING
	
	addFormatToken('z',  0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');
	
	// MOMENTS
	
	function getZoneAbbr () {
	    return this._isUTC ? 'UTC' : '';
	}
	
	function getZoneName () {
	    return this._isUTC ? 'Coordinated Universal Time' : '';
	}
	
	var proto = Moment.prototype;
	
	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$1;
	proto.lang              = lang;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;
	
	// Year
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;
	
	// Week Year
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;
	
	// Quarter
	proto.quarter = proto.quarters = getSetQuarter;
	
	// Month
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;
	
	// Week
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;
	
	// Day
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;
	
	// Hour
	proto.hour = proto.hours = getSetHour;
	
	// Minute
	proto.minute = proto.minutes = getSetMinute;
	
	// Second
	proto.second = proto.seconds = getSetSecond;
	
	// Millisecond
	proto.millisecond = proto.milliseconds = getSetMillisecond;
	
	// Offset
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;
	
	// Timezone
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;
	
	// Deprecations
	proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
	
	function createUnix (input) {
	    return createLocal(input * 1000);
	}
	
	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}
	
	function preParsePostFormat (string) {
	    return string;
	}
	
	var proto$1 = Locale.prototype;
	
	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;
	
	// Month
	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;
	
	// Week
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;
	
	// Day of Week
	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;
	
	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;
	
	// Hours
	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;
	
	function get$1 (format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	}
	
	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index = format;
	        format = undefined;
	    }
	
	    format = format || '';
	
	    if (index != null) {
	        return get$1(format, index, field, 'month');
	    }
	
	    var i;
	    var out = [];
	    for (i = 0; i < 12; i++) {
	        out[i] = get$1(format, i, field, 'month');
	    }
	    return out;
	}
	
	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted === 'boolean') {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	    } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;
	
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	    }
	
	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;
	
	    if (index != null) {
	        return get$1(format, (index + shift) % 7, field, 'day');
	    }
	
	    var i;
	    var out = [];
	    for (i = 0; i < 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, 'day');
	    }
	    return out;
	}
	
	function listMonths (format, index) {
	    return listMonthsImpl(format, index, 'months');
	}
	
	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, 'monthsShort');
	}
	
	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	}
	
	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	}
	
	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	}
	
	getSetGlobalLocale('en', {
	    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (toInt(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});
	
	// Side effect imports
	hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
	
	var mathAbs = Math.abs;
	
	function abs () {
	    var data           = this._data;
	
	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days         = mathAbs(this._days);
	    this._months       = mathAbs(this._months);
	
	    data.milliseconds  = mathAbs(data.milliseconds);
	    data.seconds       = mathAbs(data.seconds);
	    data.minutes       = mathAbs(data.minutes);
	    data.hours         = mathAbs(data.hours);
	    data.months        = mathAbs(data.months);
	    data.years         = mathAbs(data.years);
	
	    return this;
	}
	
	function addSubtract$1 (duration, input, value, direction) {
	    var other = createDuration(input, value);
	
	    duration._milliseconds += direction * other._milliseconds;
	    duration._days         += direction * other._days;
	    duration._months       += direction * other._months;
	
	    return duration._bubble();
	}
	
	// supports only 2.0-style add(1, 's') or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}
	
	// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}
	
	function absCeil (number) {
	    if (number < 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}
	
	function bubble () {
	    var milliseconds = this._milliseconds;
	    var days         = this._days;
	    var months       = this._months;
	    var data         = this._data;
	    var seconds, minutes, hours, years, monthsFromDays;
	
	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	            (milliseconds <= 0 && days <= 0 && months <= 0))) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	    }
	
	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds = milliseconds % 1000;
	
	    seconds           = absFloor(milliseconds / 1000);
	    data.seconds      = seconds % 60;
	
	    minutes           = absFloor(seconds / 60);
	    data.minutes      = minutes % 60;
	
	    hours             = absFloor(minutes / 60);
	    data.hours        = hours % 24;
	
	    days += absFloor(hours / 24);
	
	    // convert days to months
	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays));
	
	    // 12 months -> 1 year
	    years = absFloor(months / 12);
	    months %= 12;
	
	    data.days   = days;
	    data.months = months;
	    data.years  = years;
	
	    return this;
	}
	
	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	}
	
	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}
	
	function as (units) {
	    var days;
	    var months;
	    var milliseconds = this._milliseconds;
	
	    units = normalizeUnits(units);
	
	    if (units === 'month' || units === 'year') {
	        days   = this._days   + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);
	        return units === 'month' ? months : months / 12;
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case 'week'   : return days / 7     + milliseconds / 6048e5;
	            case 'day'    : return days         + milliseconds / 864e5;
	            case 'hour'   : return days * 24    + milliseconds / 36e5;
	            case 'minute' : return days * 1440  + milliseconds / 6e4;
	            case 'second' : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error('Unknown unit ' + units);
	        }
	    }
	}
	
	// TODO: Use this.as('ms')?
	function valueOf$1 () {
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}
	
	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}
	
	var asMilliseconds = makeAs('ms');
	var asSeconds      = makeAs('s');
	var asMinutes      = makeAs('m');
	var asHours        = makeAs('h');
	var asDays         = makeAs('d');
	var asWeeks        = makeAs('w');
	var asMonths       = makeAs('M');
	var asYears        = makeAs('y');
	
	function get$2 (units) {
	    units = normalizeUnits(units);
	    return this[units + 's']();
	}
	
	function makeGetter(name) {
	    return function () {
	        return this._data[name];
	    };
	}
	
	var milliseconds = makeGetter('milliseconds');
	var seconds      = makeGetter('seconds');
	var minutes      = makeGetter('minutes');
	var hours        = makeGetter('hours');
	var days         = makeGetter('days');
	var months       = makeGetter('months');
	var years        = makeGetter('years');
	
	function weeks () {
	    return absFloor(this.days() / 7);
	}
	
	var round = Math.round;
	var thresholds = {
	    s: 45,  // seconds to minute
	    m: 45,  // minutes to hour
	    h: 22,  // hours to day
	    d: 26,  // days to month
	    M: 11   // months to year
	};
	
	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}
	
	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds  = round(duration.as('s'));
	    var minutes  = round(duration.as('m'));
	    var hours    = round(duration.as('h'));
	    var days     = round(duration.as('d'));
	    var months   = round(duration.as('M'));
	    var years    = round(duration.as('y'));
	
	    var a = seconds < thresholds.s && ['s', seconds]  ||
	            minutes <= 1           && ['m']           ||
	            minutes < thresholds.m && ['mm', minutes] ||
	            hours   <= 1           && ['h']           ||
	            hours   < thresholds.h && ['hh', hours]   ||
	            days    <= 1           && ['d']           ||
	            days    < thresholds.d && ['dd', days]    ||
	            months  <= 1           && ['M']           ||
	            months  < thresholds.M && ['MM', months]  ||
	            years   <= 1           && ['y']           || ['yy', years];
	
	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration > 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	}
	
	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction === undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) === 'function') {
	        round = roundingFunction;
	        return true;
	    }
	    return false;
	}
	
	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	        return false;
	    }
	    if (limit === undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] = limit;
	    return true;
	}
	
	function humanize (withSuffix) {
	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);
	
	    if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	    }
	
	    return locale.postformat(output);
	}
	
	var abs$1 = Math.abs;
	
	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days         = abs$1(this._days);
	    var months       = abs$1(this._months);
	    var minutes, hours, years;
	
	    // 3600 seconds -> 60 minutes -> 1 hour
	    minutes           = absFloor(seconds / 60);
	    hours             = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60;
	
	    // 12 months -> 1 year
	    years  = absFloor(months / 12);
	    months %= 12;
	
	
	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds;
	    var total = this.asSeconds();
	
	    if (!total) {
	        // this is the same as C#'s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return 'P0D';
	    }
	
	    return (total < 0 ? '-' : '') +
	        'P' +
	        (Y ? Y + 'Y' : '') +
	        (M ? M + 'M' : '') +
	        (D ? D + 'D' : '') +
	        ((h || m || s) ? 'T' : '') +
	        (h ? h + 'H' : '') +
	        (m ? m + 'M' : '') +
	        (s ? s + 'S' : '');
	}
	
	var proto$2 = Duration.prototype;
	
	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;
	
	// Deprecations
	proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	proto$2.lang = lang;
	
	// Side effect imports
	
	// FORMATTING
	
	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');
	
	// PARSING
	
	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function (input, array, config) {
	    config._d = new Date(toInt(input));
	});
	
	// Side effect imports
	
	
	hooks.version = '2.17.1';
	
	setHookCallback(createLocal);
	
	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;
	
	return hooks;
	
	})));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(94)(module)))

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 96,
		"./af.js": 96,
		"./ar": 97,
		"./ar-dz": 98,
		"./ar-dz.js": 98,
		"./ar-ly": 99,
		"./ar-ly.js": 99,
		"./ar-ma": 100,
		"./ar-ma.js": 100,
		"./ar-sa": 101,
		"./ar-sa.js": 101,
		"./ar-tn": 102,
		"./ar-tn.js": 102,
		"./ar.js": 97,
		"./az": 103,
		"./az.js": 103,
		"./be": 104,
		"./be.js": 104,
		"./bg": 105,
		"./bg.js": 105,
		"./bn": 106,
		"./bn.js": 106,
		"./bo": 107,
		"./bo.js": 107,
		"./br": 108,
		"./br.js": 108,
		"./bs": 109,
		"./bs.js": 109,
		"./ca": 110,
		"./ca.js": 110,
		"./cs": 111,
		"./cs.js": 111,
		"./cv": 112,
		"./cv.js": 112,
		"./cy": 113,
		"./cy.js": 113,
		"./da": 114,
		"./da.js": 114,
		"./de": 115,
		"./de-at": 116,
		"./de-at.js": 116,
		"./de.js": 115,
		"./dv": 117,
		"./dv.js": 117,
		"./el": 118,
		"./el.js": 118,
		"./en-au": 119,
		"./en-au.js": 119,
		"./en-ca": 120,
		"./en-ca.js": 120,
		"./en-gb": 121,
		"./en-gb.js": 121,
		"./en-ie": 122,
		"./en-ie.js": 122,
		"./en-nz": 123,
		"./en-nz.js": 123,
		"./eo": 124,
		"./eo.js": 124,
		"./es": 125,
		"./es-do": 126,
		"./es-do.js": 126,
		"./es.js": 125,
		"./et": 127,
		"./et.js": 127,
		"./eu": 128,
		"./eu.js": 128,
		"./fa": 129,
		"./fa.js": 129,
		"./fi": 130,
		"./fi.js": 130,
		"./fo": 131,
		"./fo.js": 131,
		"./fr": 132,
		"./fr-ca": 133,
		"./fr-ca.js": 133,
		"./fr-ch": 134,
		"./fr-ch.js": 134,
		"./fr.js": 132,
		"./fy": 135,
		"./fy.js": 135,
		"./gd": 136,
		"./gd.js": 136,
		"./gl": 137,
		"./gl.js": 137,
		"./he": 138,
		"./he.js": 138,
		"./hi": 139,
		"./hi.js": 139,
		"./hr": 140,
		"./hr.js": 140,
		"./hu": 141,
		"./hu.js": 141,
		"./hy-am": 142,
		"./hy-am.js": 142,
		"./id": 143,
		"./id.js": 143,
		"./is": 144,
		"./is.js": 144,
		"./it": 145,
		"./it.js": 145,
		"./ja": 146,
		"./ja.js": 146,
		"./jv": 147,
		"./jv.js": 147,
		"./ka": 148,
		"./ka.js": 148,
		"./kk": 149,
		"./kk.js": 149,
		"./km": 150,
		"./km.js": 150,
		"./ko": 151,
		"./ko.js": 151,
		"./ky": 152,
		"./ky.js": 152,
		"./lb": 153,
		"./lb.js": 153,
		"./lo": 154,
		"./lo.js": 154,
		"./lt": 155,
		"./lt.js": 155,
		"./lv": 156,
		"./lv.js": 156,
		"./me": 157,
		"./me.js": 157,
		"./mi": 158,
		"./mi.js": 158,
		"./mk": 159,
		"./mk.js": 159,
		"./ml": 160,
		"./ml.js": 160,
		"./mr": 161,
		"./mr.js": 161,
		"./ms": 162,
		"./ms-my": 163,
		"./ms-my.js": 163,
		"./ms.js": 162,
		"./my": 164,
		"./my.js": 164,
		"./nb": 165,
		"./nb.js": 165,
		"./ne": 166,
		"./ne.js": 166,
		"./nl": 167,
		"./nl-be": 168,
		"./nl-be.js": 168,
		"./nl.js": 167,
		"./nn": 169,
		"./nn.js": 169,
		"./pa-in": 170,
		"./pa-in.js": 170,
		"./pl": 171,
		"./pl.js": 171,
		"./pt": 172,
		"./pt-br": 173,
		"./pt-br.js": 173,
		"./pt.js": 172,
		"./ro": 174,
		"./ro.js": 174,
		"./ru": 175,
		"./ru.js": 175,
		"./se": 176,
		"./se.js": 176,
		"./si": 177,
		"./si.js": 177,
		"./sk": 178,
		"./sk.js": 178,
		"./sl": 179,
		"./sl.js": 179,
		"./sq": 180,
		"./sq.js": 180,
		"./sr": 181,
		"./sr-cyrl": 182,
		"./sr-cyrl.js": 182,
		"./sr.js": 181,
		"./ss": 183,
		"./ss.js": 183,
		"./sv": 184,
		"./sv.js": 184,
		"./sw": 185,
		"./sw.js": 185,
		"./ta": 186,
		"./ta.js": 186,
		"./te": 187,
		"./te.js": 187,
		"./tet": 188,
		"./tet.js": 188,
		"./th": 189,
		"./th.js": 189,
		"./tl-ph": 190,
		"./tl-ph.js": 190,
		"./tlh": 191,
		"./tlh.js": 191,
		"./tr": 192,
		"./tr.js": 192,
		"./tzl": 193,
		"./tzl.js": 193,
		"./tzm": 194,
		"./tzm-latn": 195,
		"./tzm-latn.js": 195,
		"./tzm.js": 194,
		"./uk": 196,
		"./uk.js": 196,
		"./uz": 197,
		"./uz.js": 197,
		"./vi": 198,
		"./vi.js": 198,
		"./x-pseudo": 199,
		"./x-pseudo.js": 199,
		"./yo": 200,
		"./yo.js": 200,
		"./zh-cn": 201,
		"./zh-cn.js": 201,
		"./zh-hk": 202,
		"./zh-hk.js": 202,
		"./zh-tw": 203,
		"./zh-tw.js": 203
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 95;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var af = moment.defineLocale('af', {
	    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	    meridiemParse: /vm|nm/i,
	    isPM : function (input) {
	        return /^nm$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'vm' : 'VM';
	        } else {
	            return isLower ? 'nm' : 'NM';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Vandag om] LT',
	        nextDay : '[Mre om] LT',
	        nextWeek : 'dddd [om] LT',
	        lastDay : '[Gister om] LT',
	        lastWeek : '[Laas] dddd [om] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'oor %s',
	        past : '%s gelede',
	        s : '\'n paar sekondes',
	        m : '\'n minuut',
	        mm : '%d minute',
	        h : '\'n uur',
	        hh : '%d ure',
	        d : '\'n dag',
	        dd : '%d dae',
	        M : '\'n maand',
	        MM : '%d maande',
	        y : '\'n jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
	    },
	    week : {
	        dow : 1, // Maandag is die eerste dag van die week.
	        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	    }
	});
	
	return af;
	
	})));


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! author : Ahmed Elkhatib
	//! author : forabi https://github.com/forabi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    '  ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    '  ',
	    '  ',
	    '  '
	];
	
	var ar = moment.defineLocale('ar', {
	    months : months,
	    monthsShort : months,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ar;
	
	})));


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Algeria) [ar-dz]
	//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var arDz = moment.defineLocale('ar-dz', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 4  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arDz;
	
	})));


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Lybia) [ar-ly]
	//! author : Ali Hmer: https://github.com/kikoanis
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '1',
	    '2': '2',
	    '3': '3',
	    '4': '4',
	    '5': '5',
	    '6': '6',
	    '7': '7',
	    '8': '8',
	    '9': '9',
	    '0': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	
	var arLy = moment.defineLocale('ar-ly', {
	    months : months,
	    monthsShort : months,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arLy;
	
	})));


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var arMa = moment.defineLocale('ar-ma', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arMa;
	
	})));


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var arSa = moment.defineLocale('ar-sa', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arSa;
	
	})));


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	//! author : Nader Toukabri : https://github.com/naderio
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var arTn = moment.defineLocale('ar-tn', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: ' %s',
	        past: ' %s',
	        s: '',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return arTn;
	
	})));


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var suffixes = {
	    1: '-inci',
	    5: '-inci',
	    8: '-inci',
	    70: '-inci',
	    80: '-inci',
	    2: '-nci',
	    7: '-nci',
	    20: '-nci',
	    50: '-nci',
	    3: '-nc',
	    4: '-nc',
	    100: '-nc',
	    6: '-nc',
	    9: '-uncu',
	    10: '-uncu',
	    30: '-uncu',
	    60: '-nc',
	    90: '-nc'
	};
	
	var az = moment.defineLocale('az', {
	    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	    weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
	    weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
	    weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugn saat] LT',
	        nextDay : '[sabah saat] LT',
	        nextWeek : '[gln hft] dddd [saat] LT',
	        lastDay : '[dnn] LT',
	        lastWeek : '[ken hft] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s vvl',
	        s : 'birne saniyy',
	        m : 'bir dqiq',
	        mm : '%d dqiq',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gn',
	        dd : '%d gn',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir il',
	        yy : '%d il'
	    },
	    meridiemParse: /gec|shr|gndz|axam/,
	    isPM : function (input) {
	        return /^(gndz|axam)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'gec';
	        } else if (hour < 12) {
	            return 'shr';
	        } else if (hour < 17) {
	            return 'gndz';
	        } else {
	            return 'axam';
	        }
	    },
	    ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '-nc';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return az;
	
	})));


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': withoutSuffix ? '__' : '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	
	var be = moment.defineLocale('be', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : {
	        format: '______'.split('_'),
	        standalone: '______'.split('_'),
	        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        lastDay: '[ ] LT',
	        nextWeek: function () {
	            return '[] dddd [] LT';
	        },
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[ ] dddd [] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithPlural,
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /|||/,
	    isPM : function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}-(||)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return be;
	
	})));


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var bg = moment.defineLocale('bg', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[ ] dddd [] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|||||)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-';
	        } else if (last2Digits === 0) {
	            return number + '-';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-';
	        } else if (lastDigit === 1) {
	            return number + '-';
	        } else if (lastDigit === 2) {
	            return number + '-';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-';
	        } else {
	            return number + '-';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bg;
	
	})));


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var bn = moment.defineLocale('bn', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                (meridiem === '' && hour < 5) ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bn;
	
	})));


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var bo = moment.defineLocale('bo', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[], LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                (meridiem === '' && hour < 5) ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bo;
	
	})));


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function relativeTimeWithMutation(number, withoutSuffix, key) {
	    var format = {
	        'mm': 'munutenn',
	        'MM': 'miz',
	        'dd': 'devezh'
	    };
	    return number + ' ' + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
	    switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	    }
	}
	function lastNumber(number) {
	    if (number > 9) {
	        return lastNumber(number % 10);
	    }
	    return number;
	}
	function mutation(text, number) {
	    if (number === 2) {
	        return softMutation(text);
	    }
	    return text;
	}
	function softMutation(text) {
	    var mutationTable = {
	        'm': 'v',
	        'b': 'v',
	        'd': 'z'
	    };
	    if (mutationTable[text.charAt(0)] === undefined) {
	        return text;
	    }
	    return mutationTable[text.charAt(0)] + text.substring(1);
	}
	
	var br = moment.defineLocale('br', {
	    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h[e]mm A',
	        LTS : 'h[e]mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [a viz] MMMM YYYY',
	        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	    },
	    calendar : {
	        sameDay : '[Hiziv da] LT',
	        nextDay : '[Warc\'hoazh da] LT',
	        nextWeek : 'dddd [da] LT',
	        lastDay : '[Dec\'h da] LT',
	        lastWeek : 'dddd [paset da] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'a-benn %s',
	        past : '%s \'zo',
	        s : 'un nebeud segondenno',
	        m : 'ur vunutenn',
	        mm : relativeTimeWithMutation,
	        h : 'un eur',
	        hh : '%d eur',
	        d : 'un devezh',
	        dd : relativeTimeWithMutation,
	        M : 'ur miz',
	        MM : relativeTimeWithMutation,
	        y : 'ur bloaz',
	        yy : specialMutationForYears
	    },
	    ordinalParse: /\d{1,2}(a|vet)/,
	    ordinal : function (number) {
	        var output = (number === 1) ? 'a' : 'vet';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return br;
	
	})));


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Markovi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}
	
	var bs = moment.defineLocale('bs', {
	    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bs;
	
	})));


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ca = moment.defineLocale('ca', {
	    months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	    monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	    weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextDay : function () {
	            return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastDay : function () {
	            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'd\'aqu %s',
	        past : 'fa %s',
	        s : 'uns segons',
	        m : 'un minut',
	        mm : '%d minuts',
	        h : 'una hora',
	        hh : '%d hores',
	        d : 'un dia',
	        dd : '%d dies',
	        M : 'un mes',
	        MM : '%d mesos',
	        y : 'un any',
	        yy : '%d anys'
	    },
	    ordinalParse: /\d{1,2}(r|n|t||a)/,
	    ordinal : function (number, period) {
	        var output = (number === 1) ? 'r' :
	            (number === 2) ? 'n' :
	            (number === 3) ? 'r' :
	            (number === 4) ? 't' : '';
	        if (period === 'w' || period === 'W') {
	            output = 'a';
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return ca;
	
	})));


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
	var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dn');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'msce' : 'msc');
	            } else {
	                return result + 'msci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	    }
	}
	
	var cs = moment.defineLocale('cs', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParse : (function (months, monthsShort) {
	        var i, _monthsParse = [];
	        for (i = 0; i < 12; i++) {
	            // use custom parser to solve problem with July (ervenec)
	            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	        }
	        return _monthsParse;
	    }(months, monthsShort)),
	    shortMonthsParse : (function (monthsShort) {
	        var i, _shortMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	        }
	        return _shortMonthsParse;
	    }(monthsShort)),
	    longMonthsParse : (function (months) {
	        var i, _longMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	        }
	        return _longMonthsParse;
	    }(months)),
	    weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
	    weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
	    weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm',
	        l : 'D. M. YYYY'
	    },
	    calendar : {
	        sameDay: '[dnes v] LT',
	        nextDay: '[ztra v] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve stedu v] LT';
	                case 4:
	                    return '[ve tvrtek v] LT';
	                case 5:
	                    return '[v ptek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	            }
	        },
	        lastDay: '[vera v] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minulou nedli v] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [v] LT';
	                case 3:
	                    return '[minulou stedu v] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'ped %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse : /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return cs;
	
	})));


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var cv = moment.defineLocale('cv', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'YYYY [] MMMM [] D[-]',
	        LLL : 'YYYY [] MMMM [] D[-], HH:mm',
	        LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
	    },
	    calendar : {
	        sameDay: '[] LT []',
	        nextDay: '[] LT []',
	        lastDay: '[] LT []',
	        nextWeek: '[] dddd LT []',
	        lastWeek: '[] dddd LT []',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (output) {
	            var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
	            return output + affix;
	        },
	        past : '%s ',
	        s : '- ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-/,
	    ordinal : '%d-',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return cv;
	
	})));


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen : https://github.com/robgallen
	//! author : https://github.com/ryangreaves
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var cy = moment.defineLocale('cy', {
	    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    // time formats are the same as en-gb
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[Heddiw am] LT',
	        nextDay: '[Yfory am] LT',
	        nextWeek: 'dddd [am] LT',
	        lastDay: '[Ddoe am] LT',
	        lastWeek: 'dddd [diwethaf am] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'mewn %s',
	        past: '%s yn l',
	        s: 'ychydig eiliadau',
	        m: 'munud',
	        mm: '%d munud',
	        h: 'awr',
	        hh: '%d awr',
	        d: 'diwrnod',
	        dd: '%d diwrnod',
	        M: 'mis',
	        MM: '%d mis',
	        y: 'blwyddyn',
	        yy: '%d flynedd'
	    },
	    ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	    ordinal: function (number) {
	        var b = number,
	            output = '',
	            lookup = [
	                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	            ];
	        if (b > 20) {
	            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                output = 'fed'; // not 30ain, 70ain or 90ain
	            } else {
	                output = 'ain';
	            }
	        } else if (b > 0) {
	            output = lookup[b];
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return cy;
	
	})));


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var da = moment.defineLocale('da', {
	    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
	    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[I dag kl.] LT',
	        nextDay : '[I morgen kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[I gr kl.] LT',
	        lastWeek : '[sidste] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'f sekunder',
	        m : 'et minut',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dage',
	        M : 'en mned',
	        MM : '%d mneder',
	        y : 'et r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return da;
	
	})));


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	
	var de = moment.defineLocale('de', {
	    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return de;
	
	})));


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	
	var deAt = moment.defineLocale('de-at', {
	    months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return deAt;
	
	})));


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	var weekdays = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	
	var dv = moment.defineLocale('dv', {
	    months : months,
	    monthsShort : months,
	    weekdays : weekdays,
	    weekdaysShort : weekdays,
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/M/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : ' %d',
	        h : '',
	        hh : ' %d',
	        d : '',
	        dd : ' %d',
	        M : '',
	        MM : ' %d',
	        y : '',
	        yy : ' %d'
	    },
	    preparse: function (string) {
	        return string.replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '');
	    },
	    week : {
	        dow : 7,  // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return dv;
	
	})));


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}
	
	
	var el = moment.defineLocale('el', {
	    monthsNominativeEl : '___________'.split('_'),
	    monthsGenitiveEl : '___________'.split('_'),
	    months : function (momentToFormat, format) {
	        if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	            return this._monthsGenitiveEl[momentToFormat.month()];
	        } else {
	            return this._monthsNominativeEl[momentToFormat.month()];
	        }
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? '' : '';
	        } else {
	            return isLower ? '' : '';
	        }
	    },
	    isPM : function (input) {
	        return ((input + '').toLowerCase()[0] === '');
	    },
	    meridiemParse : /[]\.??\.?/i,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendarEl : {
	        sameDay : '[ {}] LT',
	        nextDay : '[ {}] LT',
	        nextWeek : 'dddd [{}] LT',
	        lastDay : '[ {}] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 6:
	                    return '[ ] dddd [{}] LT';
	                default:
	                    return '[ ] dddd [{}] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    calendar : function (key, mom) {
	        var output = this._calendarEl[key],
	            hours = mom && mom.hours();
	        if (isFunction(output)) {
	            output = output.apply(mom);
	        }
	        return output.replace('{}', (hours % 12 === 1 ? '' : ''));
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4st is the first week of the year.
	    }
	});
	
	return el;
	
	})));


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	//! author : Jared Morse : https://github.com/jarcoal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enAu = moment.defineLocale('en-au', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enAu;
	
	})));


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enCa = moment.defineLocale('en-ca', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'YYYY-MM-DD',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});
	
	return enCa;
	
	})));


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enGb = moment.defineLocale('en-gb', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enGb;
	
	})));


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enIe = moment.defineLocale('en-ie', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enIe;
	
	})));


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	//! author : Luke McGregor : https://github.com/lukemcgregor
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enNz = moment.defineLocale('en-nz', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enNz;
	
	})));


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var eo = moment.defineLocale('eo', {
	    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
	    weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
	    weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D[-an de] MMMM, YYYY',
	        LLL : 'D[-an de] MMMM, YYYY HH:mm',
	        LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	    },
	    meridiemParse: /[ap]\.t\.m/i,
	    isPM: function (input) {
	        return input.charAt(0).toLowerCase() === 'p';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'p.t.m.' : 'P.T.M.';
	        } else {
	            return isLower ? 'a.t.m.' : 'A.T.M.';
	        }
	    },
	    calendar : {
	        sameDay : '[Hodia je] LT',
	        nextDay : '[Morga je] LT',
	        nextWeek : 'dddd [je] LT',
	        lastDay : '[Hiera je] LT',
	        lastWeek : '[pasinta] dddd [je] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'je %s',
	        past : 'anta %s',
	        s : 'sekundoj',
	        m : 'minuto',
	        mm : '%d minutoj',
	        h : 'horo',
	        hh : '%d horoj',
	        d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
	        dd : '%d tagoj',
	        M : 'monato',
	        MM : '%d monatoj',
	        y : 'jaro',
	        yy : '%d jaroj'
	    },
	    ordinalParse: /\d{1,2}a/,
	    ordinal : '%da',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return eo;
	
	})));


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napur : https://github.com/julionc
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	var es = moment.defineLocale('es', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ao',
	        yy : '%d aos'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return es;
	
	})));


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	var esDo = moment.defineLocale('es-do', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY h:mm A',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ao',
	        yy : '%d aos'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return esDo;
	
	})));


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
	        'm' : ['he minuti', 'ks minut'],
	        'mm': [number + ' minuti', number + ' minutit'],
	        'h' : ['he tunni', 'tund aega', 'ks tund'],
	        'hh': [number + ' tunni', number + ' tundi'],
	        'd' : ['he peva', 'ks pev'],
	        'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
	        'MM': [number + ' kuu', number + ' kuud'],
	        'y' : ['he aasta', 'aasta', 'ks aasta'],
	        'yy': [number + ' aasta', number + ' aastat']
	    };
	    if (withoutSuffix) {
	        return format[key][2] ? format[key][2] : format[key][1];
	    }
	    return isFuture ? format[key][0] : format[key][1];
	}
	
	var et = moment.defineLocale('et', {
	    months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	    monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	    weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
	    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	    longDateFormat : {
	        LT   : 'H:mm',
	        LTS : 'H:mm:ss',
	        L    : 'DD.MM.YYYY',
	        LL   : 'D. MMMM YYYY',
	        LLL  : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[Tna,] LT',
	        nextDay  : '[Homme,] LT',
	        nextWeek : '[Jrgmine] dddd LT',
	        lastDay  : '[Eile,] LT',
	        lastWeek : '[Eelmine] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s prast',
	        past   : '%s tagasi',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : '%d peva',
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return et;
	
	})));


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var eu = moment.defineLocale('eu', {
	    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY[ko] MMMM[ren] D[a]',
	        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	        l : 'YYYY-M-D',
	        ll : 'YYYY[ko] MMM D[a]',
	        lll : 'YYYY[ko] MMM D[a] HH:mm',
	        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	    },
	    calendar : {
	        sameDay : '[gaur] LT[etan]',
	        nextDay : '[bihar] LT[etan]',
	        nextWeek : 'dddd LT[etan]',
	        lastDay : '[atzo] LT[etan]',
	        lastWeek : '[aurreko] dddd LT[etan]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s barru',
	        past : 'duela %s',
	        s : 'segundo batzuk',
	        m : 'minutu bat',
	        mm : '%d minutu',
	        h : 'ordu bat',
	        hh : '%d ordu',
	        d : 'egun bat',
	        dd : '%d egun',
	        M : 'hilabete bat',
	        MM : '%d hilabete',
	        y : 'urte bat',
	        yy : '%d urte'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return eu;
	
	})));


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var fa = moment.defineLocale('fa', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '\u200c__\u200c__\u200c__'.split('_'),
	    weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /  |  /,
	    isPM: function (input) {
	        return /  /.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '  ';
	        } else {
	            return '  ';
	        }
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : 'dddd [] [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[-]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12 // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return fa;
	
	})));


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
	var numbersFuture = [
	        'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
	        numbersPast[7], numbersPast[8], numbersPast[9]
	    ];
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = '';
	    switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'pivn' : 'piv';
	        case 'dd':
	            result = isFuture ? 'pivn' : 'piv';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	    }
	    result = verbalNumber(number, isFuture) + ' ' + result;
	    return result;
	}
	function verbalNumber(number, isFuture) {
	    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}
	
	var fi = moment.defineLocale('fi', {
	    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	    monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
	    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'Do MMMM[ta] YYYY',
	        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	        l : 'D.M.YYYY',
	        ll : 'Do MMM YYYY',
	        lll : 'Do MMM YYYY, [klo] HH.mm',
	        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	    },
	    calendar : {
	        sameDay : '[tnn] [klo] LT',
	        nextDay : '[huomenna] [klo] LT',
	        nextWeek : 'dddd [klo] LT',
	        lastDay : '[eilen] [klo] LT',
	        lastWeek : '[viime] dddd[na] [klo] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s pst',
	        past : '%s sitten',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fi;
	
	})));


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var fo = moment.defineLocale('fo', {
	    months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
	    weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
	    weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D. MMMM, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ dag kl.] LT',
	        nextDay : '[ morgin kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[ gjr kl.] LT',
	        lastWeek : '[sstu] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'um %s',
	        past : '%s sani',
	        s : 'f sekund',
	        m : 'ein minutt',
	        mm : '%d minuttir',
	        h : 'ein tmi',
	        hh : '%d tmar',
	        d : 'ein dagur',
	        dd : '%d dagar',
	        M : 'ein mnai',
	        MM : '%d mnair',
	        y : 'eitt r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fo;
	
	})));


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var fr = moment.defineLocale('fr', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui ] LT',
	        nextDay: '[Demain ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[Hier ] LT',
	        lastWeek: 'dddd [dernier ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : '');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fr;
	
	})));


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var frCa = moment.defineLocale('fr-ca', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui ] LT',
	        nextDay: '[Demain ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[Hier ] LT',
	        lastWeek: 'dddd [dernier ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : 'e');
	    }
	});
	
	return frCa;
	
	})));


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var frCh = moment.defineLocale('fr-ch', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui ] LT',
	        nextDay: '[Demain ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[Hier ] LT',
	        lastWeek: 'dddd [dernier ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : 'e');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return frCh;
	
	})));


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
	
	var fy = moment.defineLocale('fy', {
	    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[hjoed om] LT',
	        nextDay: '[moarn om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[juster om] LT',
	        lastWeek: '[frne] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'oer %s',
	        past : '%s lyn',
	        s : 'in pear sekonden',
	        m : 'ien mint',
	        mm : '%d minuten',
	        h : 'ien oere',
	        hh : '%d oeren',
	        d : 'ien dei',
	        dd : '%d dagen',
	        M : 'ien moanne',
	        MM : '%d moannen',
	        y : 'ien jier',
	        yy : '%d jierren'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fy;
	
	})));


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = [
	    'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
	];
	
	var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];
	
	var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
	
	var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
	
	var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];
	
	var gd = moment.defineLocale('gd', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParseExact : true,
	    weekdays : weekdays,
	    weekdaysShort : weekdaysShort,
	    weekdaysMin : weekdaysMin,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[An-diugh aig] LT',
	        nextDay : '[A-mireach aig] LT',
	        nextWeek : 'dddd [aig] LT',
	        lastDay : '[An-d aig] LT',
	        lastWeek : 'dddd [seo chaidh] [aig] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ann an %s',
	        past : 'bho chionn %s',
	        s : 'beagan diogan',
	        m : 'mionaid',
	        mm : '%d mionaidean',
	        h : 'uair',
	        hh : '%d uairean',
	        d : 'latha',
	        dd : '%d latha',
	        M : 'mos',
	        MM : '%d mosan',
	        y : 'bliadhna',
	        yy : '%d bliadhna'
	    },
	    ordinalParse : /\d{1,2}(d|na|mh)/,
	    ordinal : function (number) {
	        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return gd;
	
	})));


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var gl = moment.defineLocale('gl', {
	    months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
	    monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	        },
	        lastDay : function () {
	            return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
	        },
	        lastWeek : function () {
	            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (str) {
	            if (str.indexOf('un') === 0) {
	                return 'n' + str;
	            }
	            return 'en ' + str;
	        },
	        past : 'hai %s',
	        s : 'uns segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'unha hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ano',
	        yy : '%d anos'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return gl;
	
	})));


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var he = moment.defineLocale('he', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D []MMMM YYYY',
	        LLL : 'D []MMMM YYYY HH:mm',
	        LLLL : 'dddd, D []MMMM YYYY HH:mm',
	        l : 'D/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ]LT',
	        nextDay : '[ ]LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ]LT',
	        lastWeek : '[] dddd [ ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        d : '',
	        dd : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        M : '',
	        MM : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        y : '',
	        yy : function (number) {
	            if (number === 2) {
	                return '';
	            } else if (number % 10 === 0 && number !== 10) {
	                return number + ' ';
	            }
	            return number + ' ';
	        }
	    },
	    meridiemParse: /"|"| | | ||/i,
	    isPM : function (input) {
	        return /^("| |)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 5) {
	            return ' ';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 12) {
	            return isLower ? '"' : ' ';
	        } else if (hour < 18) {
	            return isLower ? '"' : ' ';
	        } else {
	            return '';
	        }
	    }
	});
	
	return he;
	
	})));


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var hi = moment.defineLocale('hi', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.___._._._._._.'.split('_'),
	    monthsParseExact: true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return hi;
	
	})));


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Markovi : https://github.com/bmarkovic
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}
	
	var hr = moment.defineLocale('hr', {
	    months : {
	        format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	        standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	    },
	    monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return hr;
	
	})));


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
	function translate(number, withoutSuffix, key, isFuture) {
	    var num = number,
	        suffix;
	    switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
	    }
	    return '';
	}
	function week(isFuture) {
	    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	}
	
	var hu = moment.defineLocale('hu', {
	    months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
	    monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
	    weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
	    weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
	    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY.MM.DD.',
	        LL : 'YYYY. MMMM D.',
	        LLL : 'YYYY. MMMM D. H:mm',
	        LLLL : 'YYYY. MMMM D., dddd H:mm'
	    },
	    meridiemParse: /de|du/i,
	    isPM: function (input) {
	        return input.charAt(1).toLowerCase() === 'u';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower === true ? 'de' : 'DE';
	        } else {
	            return isLower === true ? 'du' : 'DU';
	        }
	    },
	    calendar : {
	        sameDay : '[ma] LT[-kor]',
	        nextDay : '[holnap] LT[-kor]',
	        nextWeek : function () {
	            return week.call(this, true);
	        },
	        lastDay : '[tegnap] LT[-kor]',
	        lastWeek : function () {
	            return week.call(this, false);
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s mlva',
	        past : '%s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return hu;
	
	})));


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var hyAm = moment.defineLocale('hy-am', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[] LT',
	        nextDay: '[] LT',
	        lastDay: '[] LT',
	        nextWeek: function () {
	            return 'dddd [ ] LT';
	        },
	        lastWeek: function () {
	            return '[] dddd [ ] LT';
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    meridiemParse: /|||/,
	    isPM: function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-';
	                }
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return hyAm;
	
	})));


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var id = moment.defineLocale('id', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|siang|sore|malam/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'siang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sore' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'siang';
	        } else if (hours < 19) {
	            return 'sore';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Besok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kemarin pukul] LT',
	        lastWeek : 'dddd [lalu pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lalu',
	        s : 'beberapa detik',
	        m : 'semenit',
	        mm : '%d menit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return id;
	
	})));


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik rn Sigursson : https://github.com/hinrik
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(n) {
	    if (n % 100 === 11) {
	        return true;
	    } else if (n % 10 === 1) {
	        return false;
	    }
	    return true;
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
	        case 'm':
	            return withoutSuffix ? 'mnta' : 'mntu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
	            } else if (withoutSuffix) {
	                return result + 'mnta';
	            }
	            return result + 'mntu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dgum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mnuur';
	            }
	            return isFuture ? 'mnu' : 'mnui';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mnuir';
	                }
	                return result + (isFuture ? 'mnui' : 'mnuum');
	            } else if (withoutSuffix) {
	                return result + 'mnuur';
	            }
	            return result + (isFuture ? 'mnu' : 'mnui');
	        case 'y':
	            return withoutSuffix || isFuture ? 'r' : 'ri';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
	            }
	            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
	    }
	}
	
	var is = moment.defineLocale('is', {
	    months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
	    weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
	    weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
	    weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	    },
	    calendar : {
	        sameDay : '[ dag kl.] LT',
	        nextDay : '[ morgun kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[ gr kl.] LT',
	        lastWeek : '[sasta] dddd [kl.] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'eftir %s',
	        past : 'fyrir %s san',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : 'klukkustund',
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return is;
	
	})));


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var it = moment.defineLocale('it', {
	    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	    weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
	    weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	    weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Oggi alle] LT',
	        nextDay: '[Domani alle] LT',
	        nextWeek: 'dddd [alle] LT',
	        lastDay: '[Ieri alle] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[la scorsa] dddd [alle] LT';
	                default:
	                    return '[lo scorso] dddd [alle] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	        },
	        past : '%s fa',
	        s : 'alcuni secondi',
	        m : 'un minuto',
	        mm : '%d minuti',
	        h : 'un\'ora',
	        hh : '%d ore',
	        d : 'un giorno',
	        dd : '%d giorni',
	        M : 'un mese',
	        MM : '%d mesi',
	        y : 'un anno',
	        yy : '%d anni'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return it;
	
	})));


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ja = moment.defineLocale('ja', {
	    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahm',
	        LTS : 'Ahms',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYYMD',
	        LLL : 'YYYYMDAhm',
	        LLLL : 'YYYYMDAhm dddd'
	    },
	    meridiemParse: /|/i,
	    isPM : function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[]dddd LT',
	        lastDay : '[] LT',
	        lastWeek : '[]dddd LT',
	        sameElse : 'L'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1',
	        mm : '%d',
	        h : '1',
	        hh : '%d',
	        d : '1',
	        dd : '%d',
	        M : '1',
	        MM : '%d',
	        y : '1',
	        yy : '%d'
	    }
	});
	
	return ja;
	
	})));


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Javanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var jv = moment.defineLocale('jv', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /enjing|siyang|sonten|ndalu/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'enjing') {
	            return hour;
	        } else if (meridiem === 'siyang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'enjing';
	        } else if (hours < 15) {
	            return 'siyang';
	        } else if (hours < 19) {
	            return 'sonten';
	        } else {
	            return 'ndalu';
	        }
	    },
	    calendar : {
	        sameDay : '[Dinten puniko pukul] LT',
	        nextDay : '[Mbenjang pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kala wingi pukul] LT',
	        lastWeek : 'dddd [kepengker pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'wonten ing %s',
	        past : '%s ingkang kepengker',
	        s : 'sawetawis detik',
	        m : 'setunggal menit',
	        mm : '%d menit',
	        h : 'setunggal jam',
	        hh : '%d jam',
	        d : 'sedinten',
	        dd : '%d dinten',
	        M : 'sewulan',
	        MM : '%d wulan',
	        y : 'setaun',
	        yy : '%d taun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return jv;
	
	})));


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ka = moment.defineLocale('ka', {
	    months : {
	        standalone: '___________'.split('_'),
	        format: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : {
	        standalone: '______'.split('_'),
	        format: '______'.split('_'),
	        isFormat: /(|)/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[] LT[-]',
	        nextDay : '[] LT[-]',
	        lastDay : '[] LT[-]',
	        nextWeek : '[] dddd LT[-]',
	        lastWeek : '[] dddd LT-',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return (/(|||)/).test(s) ?
	                s.replace(/$/, '') :
	                s + '';
	        },
	        past : function (s) {
	            if ((/(||||)/).test(s)) {
	                return s.replace(/(|)$/, ' ');
	            }
	            if ((//).test(s)) {
	                return s.replace(/$/, ' ');
	            }
	        },
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
	    ordinal : function (number) {
	        if (number === 0) {
	            return number;
	        }
	        if (number === 1) {
	            return number + '-';
	        }
	        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	            return '-' + number;
	        }
	        return number + '-';
	    },
	    week : {
	        dow : 1,
	        doy : 7
	    }
	});
	
	return ka;
	
	})));


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var suffixes = {
	    0: '-',
	    1: '-',
	    2: '-',
	    3: '-',
	    4: '-',
	    5: '-',
	    6: '-',
	    7: '-',
	    8: '-',
	    9: '-',
	    10: '-',
	    20: '-',
	    30: '-',
	    40: '-',
	    50: '-',
	    60: '-',
	    70: '-',
	    80: '-',
	    90: '-',
	    100: '-'
	};
	
	var kk = moment.defineLocale('kk', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[ ] dddd [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return kk;
	
	})));


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var km = moment.defineLocale('km', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[ ] LT',
	        lastWeek: 'dddd [] [] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: '%s',
	        past: '%s',
	        s: '',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return km;
	
	})));


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//! author : Kyungwook, Park : https://github.com/kyungw00k
	//! author : Jeeeyul Lee <jeeeyul@gmail.com>
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ko = moment.defineLocale('ko', {
	    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h m',
	        LTS : 'A h m s',
	        L : 'YYYY.MM.DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D A h m',
	        LLLL : 'YYYY MMMM D dddd A h m'
	    },
	    calendar : {
	        sameDay : ' LT',
	        nextDay : ' LT',
	        nextWeek : 'dddd LT',
	        lastDay : ' LT',
	        lastWeek : ' dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        ss : '%d',
	        m : '',
	        mm : '%d',
	        h : ' ',
	        hh : '%d',
	        d : '',
	        dd : '%d',
	        M : ' ',
	        MM : '%d',
	        y : ' ',
	        yy : '%d'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    meridiemParse : /|/,
	    isPM : function (token) {
	        return token === '';
	    },
	    meridiem : function (hour, minute, isUpper) {
	        return hour < 12 ? '' : '';
	    }
	});
	
	return ko;
	
	})));


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	
	var suffixes = {
	    0: '-',
	    1: '-',
	    2: '-',
	    3: '-',
	    4: '-',
	    5: '-',
	    6: '-',
	    7: '-',
	    8: '-',
	    9: '-',
	    10: '-',
	    20: '-',
	    30: '-',
	    40: '-',
	    50: '-',
	    60: '-',
	    70: '-',
	    80: '-',
	    90: '-',
	    100: '-'
	};
	
	var ky = moment.defineLocale('ky', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[ ] dddd [] [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|||)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ky;
	
	})));


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch
	//! author : David Raison : https://github.com/kwisatz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eng Minutt', 'enger Minutt'],
	        'h': ['eng Stonn', 'enger Stonn'],
	        'd': ['een Dag', 'engem Dag'],
	        'M': ['ee Mount', 'engem Mount'],
	        'y': ['ee Joer', 'engem Joer']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'a ' + string;
	    }
	    return 'an ' + string;
	}
	function processPastTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'viru ' + string;
	    }
	    return 'virun ' + string;
	}
	/**
	 * Returns true if the word before the given number loses the '-n' ending.
	 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
	    number = parseInt(number, 10);
	    if (isNaN(number)) {
	        return false;
	    }
	    if (number < 0) {
	        // Negative Number --> always true
	        return true;
	    } else if (number < 10) {
	        // Only 1 digit
	        if (4 <= number && number <= 7) {
	            return true;
	        }
	        return false;
	    } else if (number < 100) {
	        // 2 digits
	        var lastDigit = number % 10, firstDigit = number / 10;
	        if (lastDigit === 0) {
	            return eifelerRegelAppliesToNumber(firstDigit);
	        }
	        return eifelerRegelAppliesToNumber(lastDigit);
	    } else if (number < 10000) {
	        // 3 or 4 digits --> recursively check first digit
	        while (number >= 10) {
	            number = number / 10;
	        }
	        return eifelerRegelAppliesToNumber(number);
	    } else {
	        // Anything larger than 4 digits: recursively check first n-3 digits
	        number = number / 1000;
	        return eifelerRegelAppliesToNumber(number);
	    }
	}
	
	var lb = moment.defineLocale('lb', {
	    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
	    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm [Auer]',
	        LTS: 'H:mm:ss [Auer]',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm [Auer]',
	        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	    },
	    calendar: {
	        sameDay: '[Haut um] LT',
	        sameElse: 'L',
	        nextDay: '[Muer um] LT',
	        nextWeek: 'dddd [um] LT',
	        lastDay: '[Gschter um] LT',
	        lastWeek: function () {
	            // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	            switch (this.day()) {
	                case 2:
	                case 4:
	                    return '[Leschten] dddd [um] LT';
	                default:
	                    return '[Leschte] dddd [um] LT';
	            }
	        }
	    },
	    relativeTime : {
	        future : processFutureTime,
	        past : processPastTime,
	        s : 'e puer Sekonnen',
	        m : processRelativeTime,
	        mm : '%d Minutten',
	        h : processRelativeTime,
	        hh : '%d Stonnen',
	        d : processRelativeTime,
	        dd : '%d Deeg',
	        M : processRelativeTime,
	        MM : '%d Mint',
	        y : processRelativeTime,
	        yy : '%d Joer'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal: '%d.',
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return lb;
	
	})));


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var lo = moment.defineLocale('lo', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM: function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[]dddd[] LT',
	        lastDay : '[] LT',
	        lastWeek : '[]dddd[] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    },
	    ordinalParse: /()\d{1,2}/,
	    ordinal : function (number) {
	        return '' + number;
	    }
	});
	
	return lo;
	
	})));


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozras : https://github.com/mmozuras
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var units = {
	    'm' : 'minut_minuts_minut',
	    'mm': 'minuts_minui_minutes',
	    'h' : 'valanda_valandos_valand',
	    'hh': 'valandos_valand_valandas',
	    'd' : 'diena_dienos_dien',
	    'dd': 'dienos_dien_dienas',
	    'M' : 'mnuo_mnesio_mnes',
	    'MM': 'mnesiai_mnesi_mnesius',
	    'y' : 'metai_met_metus',
	    'yy': 'metai_met_metus'
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
	    if (withoutSuffix) {
	        return 'kelios sekunds';
	    } else {
	        return isFuture ? 'keli sekundi' : 'kelias sekundes';
	    }
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
	    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
	    return number % 10 === 0 || (number > 10 && number < 20);
	}
	function forms(key) {
	    return units[key].split('_');
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    if (number === 1) {
	        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	    } else if (withoutSuffix) {
	        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	    } else {
	        if (isFuture) {
	            return result + forms(key)[1];
	        } else {
	            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	        }
	    }
	}
	var lt = moment.defineLocale('lt', {
	    months : {
	        format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
	        standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
	        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	    },
	    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	    weekdays : {
	        format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
	        standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
	        isFormat: /dddd HH:mm/
	    },
	    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
	    weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY [m.] MMMM D [d.]',
	        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYY [m.] MMMM D [d.]',
	        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	    },
	    calendar : {
	        sameDay : '[iandien] LT',
	        nextDay : '[Rytoj] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[Vakar] LT',
	        lastWeek : '[Prajus] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'po %s',
	        past : 'prie %s',
	        s : translateSeconds,
	        m : translateSingular,
	        mm : translate,
	        h : translateSingular,
	        hh : translate,
	        d : translateSingular,
	        dd : translate,
	        M : translateSingular,
	        MM : translate,
	        y : translateSingular,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}-oji/,
	    ordinal : function (number) {
	        return number + '-oji';
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return lt;
	
	})));


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jnis Elmeris : https://github.com/JanisE
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var units = {
	    'm': 'mintes_mintm_minte_mintes'.split('_'),
	    'mm': 'mintes_mintm_minte_mintes'.split('_'),
	    'h': 'stundas_stundm_stunda_stundas'.split('_'),
	    'hh': 'stundas_stundm_stunda_stundas'.split('_'),
	    'd': 'dienas_dienm_diena_dienas'.split('_'),
	    'dd': 'dienas_dienm_diena_dienas'.split('_'),
	    'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
	    'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
	    'y': 'gada_gadiem_gads_gadi'.split('_'),
	    'yy': 'gada_gadiem_gads_gadi'.split('_')
	};
	/**
	 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	 */
	function format(forms, number, withoutSuffix) {
	    if (withoutSuffix) {
	        // E.g. "21 minte", "3 mintes".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	    } else {
	        // E.g. "21 mintes" as in "pc 21 mintes".
	        // E.g. "3 mintm" as in "pc 3 mintm".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	    }
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    return number + ' ' + format(units[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
	    return format(units[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
	    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
	}
	
	var lv = moment.defineLocale('lv', {
	    months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY.',
	        LL : 'YYYY. [gada] D. MMMM',
	        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	    },
	    calendar : {
	        sameDay : '[odien pulksten] LT',
	        nextDay : '[Rt pulksten] LT',
	        nextWeek : 'dddd [pulksten] LT',
	        lastDay : '[Vakar pulksten] LT',
	        lastWeek : '[Pagju] dddd [pulksten] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'pc %s',
	        past : 'pirms %s',
	        s : relativeSeconds,
	        m : relativeTimeWithSingular,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithSingular,
	        hh : relativeTimeWithPlural,
	        d : relativeTimeWithSingular,
	        dd : relativeTimeWithPlural,
	        M : relativeTimeWithSingular,
	        MM : relativeTimeWithPlural,
	        y : relativeTimeWithSingular,
	        yy : relativeTimeWithPlural
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return lv;
	
	})));


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jednog minuta'],
	        mm: ['minut', 'minuta', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mjesec', 'mjeseca', 'mjeseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};
	
	var me = moment.defineLocale('me', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sjutra u] LT',
	
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jue u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prole] [nedjelje] [u] LT',
	                '[prolog] [ponedjeljka] [u] LT',
	                '[prolog] [utorka] [u] LT',
	                '[prole] [srijede] [u] LT',
	                '[prolog] [etvrtka] [u] LT',
	                '[prolog] [petka] [u] LT',
	                '[prole] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mjesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return me;
	
	})));


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maori [mi]
	//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var mi = moment.defineLocale('mi', {
	    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
	    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
	    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
	    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY [i] HH:mm',
	        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
	    },
	    calendar: {
	        sameDay: '[i teie mahana, i] LT',
	        nextDay: '[apopo i] LT',
	        nextWeek: 'dddd [i] LT',
	        lastDay: '[inanahi i] LT',
	        lastWeek: 'dddd [whakamutunga i] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'i roto i %s',
	        past: '%s i mua',
	        s: 'te hkona ruarua',
	        m: 'he meneti',
	        mm: '%d meneti',
	        h: 'te haora',
	        hh: '%d haora',
	        d: 'he ra',
	        dd: '%d ra',
	        M: 'he marama',
	        MM: '%d marama',
	        y: 'he tau',
	        yy: '%d tau'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return mi;
	
	})));


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var mk = moment.defineLocale('mk', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : 'e_o_____a'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : '[] dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|||||)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-';
	        } else if (last2Digits === 0) {
	            return number + '-';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-';
	        } else if (lastDigit === 1) {
	            return number + '-';
	        } else if (lastDigit === 2) {
	            return number + '-';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-';
	        } else {
	            return number + '-';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return mk;
	
	})));


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ml = moment.defineLocale('ml', {
	    months : '___________'.split('_'),
	    monthsShort : '._._._.___._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm -',
	        LTS : 'A h:mm:ss -',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm -',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm -'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    meridiemParse: /|| ||/i,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                meridiem === ' ' ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return ' ';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    }
	});
	
	return ml;
	
	})));


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
	    var output = '';
	    if (withoutSuffix) {
	        switch (string) {
	            case 's': output = ' '; break;
	            case 'm': output = ' '; break;
	            case 'mm': output = '%d '; break;
	            case 'h': output = ' '; break;
	            case 'hh': output = '%d '; break;
	            case 'd': output = ' '; break;
	            case 'dd': output = '%d '; break;
	            case 'M': output = ' '; break;
	            case 'MM': output = '%d '; break;
	            case 'y': output = ' '; break;
	            case 'yy': output = '%d '; break;
	        }
	    }
	    else {
	        switch (string) {
	            case 's': output = ' '; break;
	            case 'm': output = ' '; break;
	            case 'mm': output = '%d '; break;
	            case 'h': output = ' '; break;
	            case 'hh': output = '%d '; break;
	            case 'd': output = ' '; break;
	            case 'dd': output = '%d '; break;
	            case 'M': output = ' '; break;
	            case 'MM': output = '%d '; break;
	            case 'y': output = ' '; break;
	            case 'yy': output = '%d '; break;
	        }
	    }
	    return output.replace(/%d/i, number);
	}
	
	var mr = moment.defineLocale('mr', {
	    months : '___________'.split('_'),
	    monthsShort: '._._._._._._._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek: '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future: '%s',
	        past: '%s',
	        s: relativeTimeMr,
	        m: relativeTimeMr,
	        mm: relativeTimeMr,
	        h: relativeTimeMr,
	        hh: relativeTimeMr,
	        d: relativeTimeMr,
	        dd: relativeTimeMr,
	        M: relativeTimeMr,
	        MM: relativeTimeMr,
	        y: relativeTimeMr,
	        yy: relativeTimeMr
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return mr;
	
	})));


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ms = moment.defineLocale('ms', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ms;
	
	})));


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var msMy = moment.defineLocale('ms-my', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return msMy;
	
	})));


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	//! author : David Rossellat : https://github.com/gholadr
	//! author : Tin Aung Lin : https://github.com/thanyawzinmin
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var my = moment.defineLocale('my', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[.] LT []',
	        nextDay: '[] LT []',
	        nextWeek: 'dddd LT []',
	        lastDay: '[.] LT []',
	        lastWeek: '[] dddd LT []',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: ' %s ',
	        past: ' %s ',
	        s: '.',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return my;
	
	})));


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokml [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var nb = moment.defineLocale('nb', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
	    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[i dag kl.] LT',
	        nextDay: '[i morgen kl.] LT',
	        nextWeek: 'dddd [kl.] LT',
	        lastDay: '[i gr kl.] LT',
	        lastWeek: '[forrige] dddd [kl.] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'noen sekunder',
	        m : 'ett minutt',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dager',
	        M : 'en mned',
	        MM : '%d mneder',
	        y : 'ett r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nb;
	
	})));


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var ne = moment.defineLocale('ne', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.___._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '._._._._._._.'.split('_'),
	    weekdaysMin : '._._._._._._.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 3) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 16) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[] dddd[,] LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd[,] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ne;
	
	})));


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Rling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
	
	var nl = moment.defineLocale('nl', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	
	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
	
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	
	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'n minuut',
	        mm : '%d minuten',
	        h : 'n uur',
	        hh : '%d uur',
	        d : 'n dag',
	        dd : '%d dagen',
	        M : 'n maand',
	        MM : '%d maanden',
	        y : 'n jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nl;
	
	})));


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch (Belgium) [nl-be]
	//! author : Joris Rling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
	
	var nlBe = moment.defineLocale('nl-be', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	
	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
	
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	
	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'n minuut',
	        mm : '%d minuten',
	        h : 'n uur',
	        hh : '%d uur',
	        d : 'n dag',
	        dd : '%d dagen',
	        M : 'n maand',
	        MM : '%d maanden',
	        y : 'n jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nlBe;
	
	})));


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var nn = moment.defineLocale('nn', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	    weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
	    weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[I dag klokka] LT',
	        nextDay: '[I morgon klokka] LT',
	        nextWeek: 'dddd [klokka] LT',
	        lastDay: '[I gr klokka] LT',
	        lastWeek: '[Fregande] dddd [klokka] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s sidan',
	        s : 'nokre sekund',
	        m : 'eit minutt',
	        mm : '%d minutt',
	        h : 'ein time',
	        hh : '%d timar',
	        d : 'ein dag',
	        dd : '%d dagar',
	        M : 'ein mnad',
	        MM : '%d mnader',
	        y : 'eit r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nn;
	
	})));


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var paIn = moment.defineLocale('pa-in', {
	    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return paIn;
	
	})));


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
	var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
	function plural(n) {
	    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	}
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minut';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzin';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesice' : 'miesicy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	    }
	}
	
	var pl = moment.defineLocale('pl', {
	    months : function (momentToFormat, format) {
	        if (format === '') {
	            // Hack: if format empty we know this is used to generate
	            // RegExp by moment. Give then back both valid forms of months
	            // in RegExp ready format.
	            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	        } else if (/D MMMM/.test(format)) {
	            return monthsSubjective[momentToFormat.month()];
	        } else {
	            return monthsNominative[momentToFormat.month()];
	        }
	    },
	    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
	    weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
	    weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
	    weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Dzi o] LT',
	        nextDay: '[Jutro o] LT',
	        nextWeek: '[W] dddd [o] LT',
	        lastDay: '[Wczoraj o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[W zesz niedziel o] LT';
	                case 3:
	                    return '[W zesz rod o] LT';
	                case 6:
	                    return '[W zesz sobot o] LT';
	                default:
	                    return '[W zeszy] dddd [o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : '%s temu',
	        s : 'kilka sekund',
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : '1 dzie',
	        dd : '%d dni',
	        M : 'miesic',
	        MM : translate,
	        y : 'rok',
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return pl;
	
	})));


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var pt = moment.defineLocale('pt', {
	    months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	    weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje s] LT',
	        nextDay: '[Amanh s] LT',
	        nextWeek: 'dddd [s] LT',
	        lastDay: '[Ontem s] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                '[ltima] dddd [s] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : 'h %s',
	        s : 'segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um ms',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return pt;
	
	})));


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ptBr = moment.defineLocale('pt-br', {
	    months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	    weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje s] LT',
	        nextDay: '[Amanh s] LT',
	        nextWeek: 'dddd [s] LT',
	        lastDay: '[Ontem s] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                '[ltima] dddd [s] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : '%s atrs',
	        s : 'poucos segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um ms',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d'
	});
	
	return ptBr;
	
	})));


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	            'mm': 'minute',
	            'hh': 'ore',
	            'dd': 'zile',
	            'MM': 'luni',
	            'yy': 'ani'
	        },
	        separator = ' ';
	    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	        separator = ' de ';
	    }
	    return number + separator + format[key];
	}
	
	var ro = moment.defineLocale('ro', {
	    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
	    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
	    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[azi la] LT',
	        nextDay: '[mine la] LT',
	        nextWeek: 'dddd [la] LT',
	        lastDay: '[ieri la] LT',
	        lastWeek: '[fosta] dddd [la] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'peste %s',
	        past : '%s n urm',
	        s : 'cteva secunde',
	        m : 'un minut',
	        mm : relativeTimeWithPlural,
	        h : 'o or',
	        hh : relativeTimeWithPlural,
	        d : 'o zi',
	        dd : relativeTimeWithPlural,
	        M : 'o lun',
	        MM : relativeTimeWithPlural,
	        y : 'un an',
	        yy : relativeTimeWithPlural
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ro;
	
	})));


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensle : https://github.com/Oire
	//! author :   : https://github.com/socketpair
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
	
	// http://new.gramota.ru/spravka/rules/139-prop :  103
	//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	var ru = moment.defineLocale('ru', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : {
	        //  CLDR  "."  ".",        ?
	        format: '._._._.____._._._._.'.split('_'),
	        standalone: '._.__.____._._._._.'.split('_')
	    },
	    weekdays : {
	        standalone: '______'.split('_'),
	        format: '______'.split('_'),
	        isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	
	    //    ,   ,  ,  4 ,      
	    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
	
	    //  
	    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
	
	    //    
	    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
	
	    // ,     
	    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        lastDay: '[ ] LT',
	        nextWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[] dddd [] LT';
	                } else {
	                    return '[] dddd [] LT';
	                }
	            }
	        },
	        lastWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[] dddd [] LT';
	                } else {
	                    return '[] dddd [] LT';
	                }
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : '',
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /|||/i,
	    isPM : function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}-(||)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            case 'w':
	            case 'W':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ru;
	
	})));


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Brd Rolstad Henriksen : https://github.com/karamell
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	
	var se = moment.defineLocale('se', {
	    months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
	    monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
	    weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
	    weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
	    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'MMMM D. [b.] YYYY',
	        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[otne ti] LT',
	        nextDay: '[ihttin ti] LT',
	        nextWeek: 'dddd [ti] LT',
	        lastDay: '[ikte ti] LT',
	        lastWeek: '[ovddit] dddd [ti] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s geaes',
	        past : 'mait %s',
	        s : 'moadde sekunddat',
	        m : 'okta minuhta',
	        mm : '%d minuhtat',
	        h : 'okta diimmu',
	        hh : '%d diimmut',
	        d : 'okta beaivi',
	        dd : '%d beaivvit',
	        M : 'okta mnnu',
	        MM : '%d mnut',
	        y : 'okta jahki',
	        yy : '%d jagit'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return se;
	
	})));


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	/*jshint -W100*/
	var si = moment.defineLocale('si', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'a h:mm',
	        LTS : 'a h:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D, a h:mm',
	        LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
	    },
	    calendar : {
	        sameDay : '[] LT[]',
	        nextDay : '[] LT[]',
	        nextWeek : 'dddd LT[]',
	        lastDay : '[] LT[]',
	        lastWeek : '[] dddd LT[]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s ',
	        s : ' ',
	        m : '',
	        mm : ' %d',
	        h : '',
	        hh : ' %d',
	        d : '',
	        dd : ' %d',
	        M : '',
	        MM : ' %d',
	        y : '',
	        yy : ' %d'
	    },
	    ordinalParse: /\d{1,2} /,
	    ordinal : function (number) {
	        return number + ' ';
	    },
	    meridiemParse : / | |.|../,
	    isPM : function (input) {
	        return input === '..' || input === ' ';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? '..' : ' ';
	        } else {
	            return isLower ? '..' : ' ';
	        }
	    }
	});
	
	return si;
	
	})));


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
	var monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minty' : 'mint');
	            } else {
	                return result + 'mintami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodn');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'de' : 'dom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dn');
	            } else {
	                return result + 'dami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	    }
	}
	
	var sk = moment.defineLocale('sk', {
	    months : months,
	    monthsShort : monthsShort,
	    weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
	    weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
	    weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[dnes o] LT',
	        nextDay: '[zajtra o] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo tvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	            }
	        },
	        lastDay: '[vera o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minul nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [o] LT';
	                case 3:
	                    return '[minul stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [o] LT';
	                case 6:
	                    return '[minul sobotu o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'pred %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return sk;
	
	})));


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovek : https://github.com/sedovsek
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	    }
	}
	
	var sl = moment.defineLocale('sl', {
	    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
	    weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
	    weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danes ob] LT',
	        nextDay  : '[jutri ob] LT',
	
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	            }
	        },
	        lastDay  : '[veraj ob] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[prejnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejnji] dddd [ob] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ez %s',
	        past   : 'pred %s',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : processRelativeTime,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return sl;
	
	})));


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakrim Ismani : https://github.com/flakerimi
	//! author : Menelion Elensle : https://github.com/Oire
	//! author : Oerd Cukalla : https://github.com/oerd
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var sq = moment.defineLocale('sq', {
	    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
	    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
	    weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
	    weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
	    weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /PD|MD/,
	    isPM: function (input) {
	        return input.charAt(0) === 'M';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        return hours < 12 ? 'PD' : 'MD';
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Sot n] LT',
	        nextDay : '[Nesr n] LT',
	        nextWeek : 'dddd [n] LT',
	        lastDay : '[Dje n] LT',
	        lastWeek : 'dddd [e kaluar n] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'n %s',
	        past : '%s m par',
	        s : 'disa sekonda',
	        m : 'nj minut',
	        mm : '%d minuta',
	        h : 'nj or',
	        hh : '%d or',
	        d : 'nj dit',
	        dd : '%d dit',
	        M : 'nj muaj',
	        MM : '%d muaj',
	        y : 'nj vit',
	        yy : '%d vite'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return sq;
	
	})));


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jedne minute'],
	        mm: ['minut', 'minute', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mesec', 'meseca', 'meseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};
	
	var sr = moment.defineLocale('sr', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sutra u] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jue u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prole] [nedelje] [u] LT',
	                '[prolog] [ponedeljka] [u] LT',
	                '[prolog] [utorka] [u] LT',
	                '[prole] [srede] [u] LT',
	                '[prolog] [etvrtka] [u] LT',
	                '[prolog] [petka] [u] LT',
	                '[prole] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'pre %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return sr;
	
	})));


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var translator = {
	    words: { //Different grammatical cases
	        m: [' ', ' '],
	        mm: ['', '', ''],
	        h: [' ', ' '],
	        hh: ['', '', ''],
	        dd: ['', '', ''],
	        MM: ['', '', ''],
	        yy: ['', '', '']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};
	
	var srCyrl = moment.defineLocale('sr-cyrl', {
	    months: '___________'.split('_'),
	    monthsShort: '._._._.____._._._._.'.split('_'),
	    monthsParseExact: true,
	    weekdays: '______'.split('_'),
	    weekdaysShort: '._._._._._._.'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[] [] [] LT';
	                case 3:
	                    return '[] [] [] LT';
	                case 6:
	                    return '[] [] [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	            }
	        },
	        lastDay  : '[ ] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past   : ' %s',
	        s      : ' ',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : '',
	        dd     : translator.translate,
	        M      : '',
	        MM     : translator.translate,
	        y      : '',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return srCyrl;
	
	})));


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : siSwati [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	
	var ss = moment.defineLocale('ss', {
	    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Namuhla nga] LT',
	        nextDay : '[Kusasa nga] LT',
	        nextWeek : 'dddd [nga] LT',
	        lastDay : '[Itolo nga] LT',
	        lastWeek : 'dddd [leliphelile] [nga] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'nga %s',
	        past : 'wenteka nga %s',
	        s : 'emizuzwana lomcane',
	        m : 'umzuzu',
	        mm : '%d emizuzu',
	        h : 'lihora',
	        hh : '%d emahora',
	        d : 'lilanga',
	        dd : '%d emalanga',
	        M : 'inyanga',
	        MM : '%d tinyanga',
	        y : 'umnyaka',
	        yy : '%d iminyaka'
	    },
	    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'ekuseni';
	        } else if (hours < 15) {
	            return 'emini';
	        } else if (hours < 19) {
	            return 'entsambama';
	        } else {
	            return 'ebusuku';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ekuseni') {
	            return hour;
	        } else if (meridiem === 'emini') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	            if (hour === 0) {
	                return 0;
	            }
	            return hour + 12;
	        }
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return ss;
	
	})));


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var sv = moment.defineLocale('sv', {
	    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
	    weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Idag] LT',
	        nextDay: '[Imorgon] LT',
	        lastDay: '[Igr] LT',
	        nextWeek: '[P] dddd LT',
	        lastWeek: '[I] dddd[s] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : 'fr %s sedan',
	        s : 'ngra sekunder',
	        m : 'en minut',
	        mm : '%d minuter',
	        h : 'en timme',
	        hh : '%d timmar',
	        d : 'en dag',
	        dd : '%d dagar',
	        M : 'en mnad',
	        MM : '%d mnader',
	        y : 'ett r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}(e|a)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'e' :
	            (b === 1) ? 'a' :
	            (b === 2) ? 'a' :
	            (b === 3) ? 'e' : 'e';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return sv;
	
	})));


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var sw = moment.defineLocale('sw', {
	    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[leo saa] LT',
	        nextDay : '[kesho saa] LT',
	        nextWeek : '[wiki ijayo] dddd [saat] LT',
	        lastDay : '[jana] LT',
	        lastWeek : '[wiki iliyopita] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s baadaye',
	        past : 'tokea %s',
	        s : 'hivi punde',
	        m : 'dakika moja',
	        mm : 'dakika %d',
	        h : 'saa limoja',
	        hh : 'masaa %d',
	        d : 'siku moja',
	        dd : 'masiku %d',
	        M : 'mwezi mmoja',
	        MM : 'miezi %d',
	        y : 'mwaka mmoja',
	        yy : 'miaka %d'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return sw;
	
	})));


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var ta = moment.defineLocale('ta', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, HH:mm',
	        LLLL : 'dddd, D MMMM YYYY, HH:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[ ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : ' ',
	        mm : '%d ',
	        h : '  ',
	        hh : '%d  ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number + '';
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // refer http://ta.wikipedia.org/s/1er1
	    meridiemParse: /|||||/,
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 2) {
	            return ' ';
	        } else if (hour < 6) {
	            return ' ';  // 
	        } else if (hour < 10) {
	            return ' '; // 
	        } else if (hour < 14) {
	            return ' '; // 
	        } else if (hour < 18) {
	            return ' '; // 
	        } else if (hour < 22) {
	            return ' '; // 
	        } else {
	            return ' ';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 2 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else {
	            return hour + 12;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ta;
	
	})));


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var te = moment.defineLocale('te', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.____._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return te;
	
	})));


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tetun Dili (East Timor) [tet]
	//! author : Joshua Brooks : https://github.com/joshbrooks
	//! author : Onorio De J. Afonso : https://github.com/marobo
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tet = moment.defineLocale('tet', {
	    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
	    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Ohin iha] LT',
	        nextDay: '[Aban iha] LT',
	        nextWeek: 'dddd [iha] LT',
	        lastDay: '[Horiseik iha] LT',
	        lastWeek: 'dddd [semana kotuk] [iha] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'iha %s',
	        past : '%s liuba',
	        s : 'minutu balun',
	        m : 'minutu ida',
	        mm : 'minutus %d',
	        h : 'horas ida',
	        hh : 'horas %d',
	        d : 'loron ida',
	        dd : 'loron %d',
	        M : 'fulan ida',
	        MM : 'fulan %d',
	        y : 'tinan ida',
	        yy : 'tinan %d'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return tet;
	
	})));


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var th = moment.defineLocale('th', {
	    months : '___________'.split('_'),
	    monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
	    monthsParseExact: true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'), // yes, three characters difference
	    weekdaysMin : '._._._._._._.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY  H:mm',
	        LLLL : 'dddd D MMMM YYYY  H:mm'
	    },
	    meridiemParse: /|/,
	    isPM: function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd[ ] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[]dddd[ ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});
	
	return th;
	
	})));


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman : https://github.com/hagmandan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tlPh = moment.defineLocale('tl-ph', {
	    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'MM/D/YYYY',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY HH:mm',
	        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: 'LT [ngayong araw]',
	        nextDay: '[Bukas ng] LT',
	        nextWeek: 'LT [sa susunod na] dddd',
	        lastDay: 'LT [kahapon]',
	        lastWeek: 'LT [noong nakaraang] dddd',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'sa loob ng %s',
	        past : '%s ang nakalipas',
	        s : 'ilang segundo',
	        m : 'isang minuto',
	        mm : '%d minuto',
	        h : 'isang oras',
	        hh : '%d oras',
	        d : 'isang araw',
	        dd : '%d araw',
	        M : 'isang buwan',
	        MM : '%d buwan',
	        y : 'isang taon',
	        yy : '%d taon'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return tlPh;
	
	})));


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');
	
	function translateFuture(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'leS' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'waQ' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'nem' :
	    time + ' pIq';
	    return time;
	}
	
	function translatePast(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'Hu' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'wen' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'ben' :
	    time + ' ret';
	    return time;
	}
	
	function translate(number, withoutSuffix, string, isFuture) {
	    var numberNoun = numberAsNoun(number);
	    switch (string) {
	        case 'mm':
	            return numberNoun + ' tup';
	        case 'hh':
	            return numberNoun + ' rep';
	        case 'dd':
	            return numberNoun + ' jaj';
	        case 'MM':
	            return numberNoun + ' jar';
	        case 'yy':
	            return numberNoun + ' DIS';
	    }
	}
	
	function numberAsNoun(number) {
	    var hundred = Math.floor((number % 1000) / 100),
	    ten = Math.floor((number % 100) / 10),
	    one = number % 10,
	    word = '';
	    if (hundred > 0) {
	        word += numbersNouns[hundred] + 'vatlh';
	    }
	    if (ten > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	    }
	    if (one > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	    }
	    return (word === '') ? 'pagh' : word;
	}
	
	var tlh = moment.defineLocale('tlh', {
	    months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
	    monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[DaHjaj] LT',
	        nextDay: '[waleS] LT',
	        nextWeek: 'LLL',
	        lastDay: '[waHu] LT',
	        lastWeek: 'LLL',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : translateFuture,
	        past : translatePast,
	        s : 'puS lup',
	        m : 'wa tup',
	        mm : translate,
	        h : 'wa rep',
	        hh : translate,
	        d : 'wa jaj',
	        dd : translate,
	        M : 'wa jar',
	        MM : translate,
	        y : 'wa DIS',
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return tlh;
	
	})));


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiit Kaya: https://github.com/BYK
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var suffixes = {
	    1: '\'inci',
	    5: '\'inci',
	    8: '\'inci',
	    70: '\'inci',
	    80: '\'inci',
	    2: '\'nci',
	    7: '\'nci',
	    20: '\'nci',
	    50: '\'nci',
	    3: '\'nc',
	    4: '\'nc',
	    100: '\'nc',
	    6: '\'nc',
	    9: '\'uncu',
	    10: '\'uncu',
	    30: '\'uncu',
	    60: '\'nc',
	    90: '\'nc'
	};
	
	var tr = moment.defineLocale('tr', {
	    months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
	    monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
	    weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
	    weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
	    weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugn saat] LT',
	        nextDay : '[yarn saat] LT',
	        nextWeek : '[haftaya] dddd [saat] LT',
	        lastDay : '[dn] LT',
	        lastWeek : '[geen hafta] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s nce',
	        s : 'birka saniye',
	        m : 'bir dakika',
	        mm : '%d dakika',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gn',
	        dd : '%d gn',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir yl',
	        yy : '%d yl'
	    },
	    ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '\'nc';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return tr;
	
	})));


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	//! author : Iust Canun
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	var tzl = moment.defineLocale('tzl', {
	    months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	    weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
	    weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
	    weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM [dallas] YYYY',
	        LLL : 'D. MMMM [dallas] YYYY HH.mm',
	        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	    },
	    meridiemParse: /d\'o|d\'a/i,
	    isPM : function (input) {
	        return 'd\'o' === input.toLowerCase();
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'd\'o' : 'D\'O';
	        } else {
	            return isLower ? 'd\'a' : 'D\'A';
	        }
	    },
	    calendar : {
	        sameDay : '[oxhi ] LT',
	        nextDay : '[dem ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ieiri ] LT',
	        lastWeek : '[sr el] dddd [lasteu ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'osprei %s',
	        past : 'ja%s',
	        s : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's': ['viensas secunds', '\'iensas secunds'],
	        'm': ['\'n mut', '\'iens mut'],
	        'mm': [number + ' muts', '' + number + ' muts'],
	        'h': ['\'n ora', '\'iensa ora'],
	        'hh': [number + ' oras', '' + number + ' oras'],
	        'd': ['\'n ziua', '\'iensa ziua'],
	        'dd': [number + ' ziuas', '' + number + ' ziuas'],
	        'M': ['\'n mes', '\'iens mes'],
	        'MM': [number + ' mesen', '' + number + ' mesen'],
	        'y': ['\'n ar', '\'iens ar'],
	        'yy': [number + ' ars', '' + number + ' ars']
	    };
	    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}
	
	return tzl;
	
	})));


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tzm = moment.defineLocale('tzm', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[ ] LT',
	        lastWeek: 'dddd [] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '   %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d o',
	        M : 'o',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return tzm;
	
	})));


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tzmLatn = moment.defineLocale('tzm-latn', {
	    months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	    monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[asdkh g] LT',
	        nextDay: '[aska g] LT',
	        nextWeek: 'dddd [g] LT',
	        lastDay: '[assant g] LT',
	        lastWeek: 'dddd [g] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dadkh s yan %s',
	        past : 'yan %s',
	        s : 'imik',
	        m : 'minu',
	        mm : '%d minu',
	        h : 'saa',
	        hh : '%d tassain',
	        d : 'ass',
	        dd : '%d ossan',
	        M : 'ayowr',
	        MM : '%d iyyirn',
	        y : 'asgas',
	        yy : '%d isgasn'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return tzmLatn;
	
	})));


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': withoutSuffix ? '__' : '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	function weekdaysCaseReplace(m, format) {
	    var weekdays = {
	        'nominative': '______'.split('_'),
	        'accusative': '______'.split('_'),
	        'genitive': '______'.split('_')
	    },
	    nounCase = (/(\[[]\]) ?dddd/).test(format) ?
	        'accusative' :
	        ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
	            'genitive' :
	            'nominative');
	    return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
	    return function () {
	        return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
	    };
	}
	
	var uk = moment.defineLocale('uk', {
	    months : {
	        'format': '___________'.split('_'),
	        'standalone': '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : weekdaysCaseReplace,
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: processHoursFunction('[ '),
	        nextDay: processHoursFunction('[ '),
	        lastDay: processHoursFunction('[ '),
	        nextWeek: processHoursFunction('[] dddd ['),
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[] dddd [').call(this);
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : '',
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	    meridiemParse: /|||/,
	    isPM: function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}-(|)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return uk;
	
	})));


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var uz = moment.defineLocale('uz', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'D MMMM YYYY, dddd HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT []',
	        nextDay : '[] LT []',
	        nextWeek : 'dddd [ ] LT []',
	        lastDay : '[ ] LT []',
	        lastWeek : '[] dddd [ ] LT []',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s ',
	        past : '  %s ',
	        s : '',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return uz;
	
	})));


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var vi = moment.defineLocale('vi', {
	    months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
	    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
	    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /sa|ch/i,
	    isPM : function (input) {
	        return /^ch$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'sa' : 'SA';
	        } else {
	            return isLower ? 'ch' : 'CH';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM [nm] YYYY',
	        LLL : 'D MMMM [nm] YYYY HH:mm',
	        LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
	        l : 'DD/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hm nay lc] LT',
	        nextDay: '[Ngy mai lc] LT',
	        nextWeek: 'dddd [tun ti lc] LT',
	        lastDay: '[Hm qua lc] LT',
	        lastWeek: 'dddd [tun ri lc] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s ti',
	        past : '%s trc',
	        s : 'vi giy',
	        m : 'mt pht',
	        mm : '%d pht',
	        h : 'mt gi',
	        hh : '%d gi',
	        d : 'mt ngy',
	        dd : '%d ngy',
	        M : 'mt thng',
	        MM : '%d thng',
	        y : 'mt nm',
	        yy : '%d nm'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return vi;
	
	})));


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var xPseudo = moment.defineLocale('x-pseudo', {
	    months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
	    monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
	    weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
	    weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[T~d~ t] LT',
	        nextDay : '[T~m~rr~w t] LT',
	        nextWeek : 'dddd [t] LT',
	        lastDay : '[~st~rd~ t] LT',
	        lastWeek : '[L~st] dddd [t] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '~ %s',
	        past : '%s ~g',
	        s : ' ~fw ~sc~ds',
	        m : ' ~m~t',
	        mm : '%d m~~ts',
	        h : '~ h~r',
	        hh : '%d h~rs',
	        d : ' ~d',
	        dd : '%d d~s',
	        M : ' ~m~th',
	        MM : '%d m~t~hs',
	        y : ' ~r',
	        yy : '%d ~rs'
	    },
	    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return xPseudo;
	
	})));


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Yoruba Nigeria [yo]
	//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var yo = moment.defineLocale('yo', {
	    months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
	    monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
	    weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
	    weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
	    weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Oni ni] LT',
	        nextDay : '[la ni] LT',
	        nextWeek : 'dddd [s ton\'b] [ni] LT',
	        lastDay : '[Ana ni] LT',
	        lastWeek : 'dddd [s tol] [ni] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ni %s',
	        past : '%s kja',
	        s : 'isju aaya die',
	        m : 'isju kan',
	        mm : 'isju %d',
	        h : 'wakati kan',
	        hh : 'wakati %d',
	        d : 'j kan',
	        dd : 'j %d',
	        M : 'osu kan',
	        MM : 'osu %d',
	        y : 'dun kan',
	        yy : 'dun %d'
	    },
	    ordinalParse : /j\s\d{1,2}/,
	    ordinal : 'j %d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return yo;
	
	})));


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var zhCn = moment.defineLocale('zh-cn', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahmm',
	        LTS : 'Ahms',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMDAhmm',
	        LLLL : 'YYYYMMMDddddAhmm',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMDAhmm',
	        llll : 'YYYYMMMDddddAhmm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' ||
	                meridiem === '') {
	            return hour;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        } else {
	            // ''
	            return hour >= 11 ? hour : hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : function () {
	            return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	        },
	        nextDay : function () {
	            return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	        },
	        lastDay : function () {
	            return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	        },
	        nextWeek : function () {
	            var startOfWeek, prefix;
	            startOfWeek = moment().startOf('week');
	            prefix = this.diff(startOfWeek, 'days') >= 7 ? '[]' : '[]';
	            return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	        },
	        lastWeek : function () {
	            var startOfWeek, prefix;
	            startOfWeek = moment().startOf('week');
	            prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
	            return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	        },
	        sameElse : 'LL'
	    },
	    ordinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            case 'M':
	                return number + '';
	            case 'w':
	            case 'W':
	                return number + '';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    },
	    week : {
	        // GB/T 7408-1994ISO 8601:1988
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return zhCn;
	
	})));


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Hong Kong) [zh-hk]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	//! author : Konstantin : https://github.com/skfd
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var zhHk = moment.defineLocale('zh-hk', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahmm',
	        LTS : 'Ahms',
	        L : 'YYYYMMMD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMDAhmm',
	        LLLL : 'YYYYMMMDddddAhmm',
	        l : 'YYYYMMMD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMDAhmm',
	        llll : 'YYYYMMMDddddAhmm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[]LT',
	        nextDay : '[]LT',
	        nextWeek : '[]ddddLT',
	        lastDay : '[]LT',
	        lastWeek : '[]ddddLT',
	        sameElse : 'L'
	    },
	    ordinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});
	
	return zhHk;
	
	})));


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(93)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var zhTw = moment.defineLocale('zh-tw', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahmm',
	        LTS : 'Ahms',
	        L : 'YYYYMMMD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMDAhmm',
	        LLLL : 'YYYYMMMDddddAhmm',
	        l : 'YYYYMMMD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMDAhmm',
	        llll : 'YYYYMMMDddddAhmm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[]LT',
	        nextDay : '[]LT',
	        nextWeek : '[]ddddLT',
	        lastDay : '[]LT',
	        lastWeek : '[]ddddLT',
	        sameElse : 'L'
	    },
	    ordinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});
	
	return zhTw;
	
	})));


/***/ },
/* 204 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.bar = {
			hover: {
				mode: 'label'
			},
	
			scales: {
				xAxes: [{
					type: 'category',
	
					// Specific to Bar Controller
					categoryPercentage: 0.8,
					barPercentage: 0.9,
	
					// grid line settings
					gridLines: {
						offsetGridLines: true
					}
				}],
				yAxes: [{
					type: 'linear'
				}]
			}
		};
	
		Chart.controllers.bar = Chart.DatasetController.extend({
	
			dataElementType: Chart.elements.Rectangle,
	
			initialize: function(chart, datasetIndex) {
				Chart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);
	
				var me = this;
				var meta = me.getMeta();
				var dataset = me.getDataset();
	
				meta.stack = dataset.stack;
				// Use this to indicate that this is a bar dataset.
				meta.bar = true;
			},
	
			// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible
			getStackCount: function() {
				var me = this;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
	
				var stacks = [];
				helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {
					var dsMeta = me.chart.getDatasetMeta(datasetIndex);
					if (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&
						(yScale.options.stacked === false ||
						(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||
						(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {
						stacks.push(dsMeta.stack);
					}
				}, me);
	
				return stacks.length;
			},
	
			update: function(reset) {
				var me = this;
				helpers.each(me.getMeta().data, function(rectangle, index) {
					me.updateElement(rectangle, index, reset);
				}, me);
			},
	
			updateElement: function(rectangle, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				var yScale = me.getScaleForId(meta.yAxisID);
				var scaleBase = yScale.getBasePixel();
				var rectangleElementOptions = me.chart.options.elements.rectangle;
				var custom = rectangle.custom || {};
				var dataset = me.getDataset();
	
				rectangle._xScale = xScale;
				rectangle._yScale = yScale;
				rectangle._datasetIndex = me.index;
				rectangle._index = index;
	
				var ruler = me.getRuler(index); // The index argument for compatible
				rectangle._model = {
					x: me.calculateBarX(index, me.index, ruler),
					y: reset ? scaleBase : me.calculateBarY(index, me.index),
	
					// Tooltip
					label: me.chart.data.labels[index],
					datasetLabel: dataset.label,
	
					// Appearance
					horizontal: false,
					base: reset ? scaleBase : me.calculateBarBase(me.index, index),
					width: me.calculateBarWidth(ruler),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),
					borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,
					borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
				};
	
				rectangle.pivot();
			},
	
			calculateBarBase: function(datasetIndex, index) {
				var me = this;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				var base = yScale.getBaseValue();
				var original = base;
	
				if ((yScale.options.stacked === true) ||
					(yScale.options.stacked === undefined && meta.stack !== undefined)) {
					var chart = me.chart;
					var datasets = chart.data.datasets;
					var value = Number(datasets[datasetIndex].data[index]);
	
					for (var i = 0; i < datasetIndex; i++) {
						var currentDs = datasets[i];
						var currentDsMeta = chart.getDatasetMeta(i);
						if (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i) &&
							meta.stack === currentDsMeta.stack) {
							var currentVal = Number(currentDs.data[index]);
							base += value < 0 ? Math.min(currentVal, original) : Math.max(currentVal, original);
						}
					}
	
					return yScale.getPixelForValue(base);
				}
	
				return yScale.getBasePixel();
			},
	
			getRuler: function() {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				var stackCount = me.getStackCount();
	
				var tickWidth = xScale.width / xScale.ticks.length;
				var categoryWidth = tickWidth * xScale.options.categoryPercentage;
				var categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;
				var fullBarWidth = categoryWidth / stackCount;
	
				var barWidth = fullBarWidth * xScale.options.barPercentage;
				var barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);
	
				return {
					stackCount: stackCount,
					tickWidth: tickWidth,
					categoryWidth: categoryWidth,
					categorySpacing: categorySpacing,
					fullBarWidth: fullBarWidth,
					barWidth: barWidth,
					barSpacing: barSpacing
				};
			},
	
			calculateBarWidth: function(ruler) {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				if (xScale.options.barThickness) {
					return xScale.options.barThickness;
				}
				return ruler.barWidth;
			},
	
			// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible
			getStackIndex: function(datasetIndex) {
				var me = this;
				var meta = me.chart.getDatasetMeta(datasetIndex);
				var yScale = me.getScaleForId(meta.yAxisID);
				var dsMeta, j;
				var stacks = [meta.stack];
	
				for (j = 0; j < datasetIndex; ++j) {
					dsMeta = this.chart.getDatasetMeta(j);
					if (dsMeta.bar && this.chart.isDatasetVisible(j) &&
						(yScale.options.stacked === false ||
						(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||
						(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {
						stacks.push(dsMeta.stack);
					}
				}
	
				return stacks.length - 1;
			},
	
			calculateBarX: function(index, datasetIndex, ruler) {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				var stackIndex = me.getStackIndex(datasetIndex);
				var leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);
				leftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;
	
				return leftTick +
					(ruler.barWidth / 2) +
					ruler.categorySpacing +
					(ruler.barWidth * stackIndex) +
					(ruler.barSpacing / 2) +
					(ruler.barSpacing * stackIndex);
			},
	
			calculateBarY: function(index, datasetIndex) {
				var me = this;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				var value = Number(me.getDataset().data[index]);
	
				if (yScale.options.stacked ||
					(yScale.options.stacked === undefined && meta.stack !== undefined)) {
					var base = yScale.getBaseValue();
					var sumPos = base,
						sumNeg = base;
	
					for (var i = 0; i < datasetIndex; i++) {
						var ds = me.chart.data.datasets[i];
						var dsMeta = me.chart.getDatasetMeta(i);
						if (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i) &&
							meta.stack === dsMeta.stack) {
							var stackedVal = Number(ds.data[index]);
							if (stackedVal < 0) {
								sumNeg += stackedVal || 0;
							} else {
								sumPos += stackedVal || 0;
							}
						}
					}
	
					if (value < 0) {
						return yScale.getPixelForValue(sumNeg + value);
					}
					return yScale.getPixelForValue(sumPos + value);
				}
	
				return yScale.getPixelForValue(value);
			},
	
			draw: function(ease) {
				var me = this;
				var easingDecimal = ease || 1;
				var metaData = me.getMeta().data;
				var dataset = me.getDataset();
				var i, len;
	
				Chart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);
				for (i = 0, len = metaData.length; i < len; ++i) {
					var d = dataset.data[i];
					if (d !== null && d !== undefined && !isNaN(d)) {
						metaData[i].transition(easingDecimal).draw();
					}
				}
				Chart.canvasHelpers.unclipArea(me.chart.chart.ctx);
			},
	
			setHoverStyle: function(rectangle) {
				var dataset = this.chart.data.datasets[rectangle._datasetIndex];
				var index = rectangle._index;
	
				var custom = rectangle.custom || {};
				var model = rectangle._model;
				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},
	
			removeHoverStyle: function(rectangle) {
				var dataset = this.chart.data.datasets[rectangle._datasetIndex];
				var index = rectangle._index;
				var custom = rectangle.custom || {};
				var model = rectangle._model;
				var rectangleElementOptions = this.chart.options.elements.rectangle;
	
				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
			}
	
		});
	
	
		// including horizontalBar in the bar file, instead of a file of its own
		// it extends bar (like pie extends doughnut)
		Chart.defaults.horizontalBar = {
			hover: {
				mode: 'label'
			},
	
			scales: {
				xAxes: [{
					type: 'linear',
					position: 'bottom'
				}],
				yAxes: [{
					position: 'left',
					type: 'category',
	
					// Specific to Horizontal Bar Controller
					categoryPercentage: 0.8,
					barPercentage: 0.9,
	
					// grid line settings
					gridLines: {
						offsetGridLines: true
					}
				}]
			},
			elements: {
				rectangle: {
					borderSkipped: 'left'
				}
			},
			tooltips: {
				callbacks: {
					title: function(tooltipItems, data) {
						// Pick first xLabel for now
						var title = '';
	
						if (tooltipItems.length > 0) {
							if (tooltipItems[0].yLabel) {
								title = tooltipItems[0].yLabel;
							} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {
								title = data.labels[tooltipItems[0].index];
							}
						}
	
						return title;
					},
					label: function(tooltipItem, data) {
						var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
						return datasetLabel + ': ' + tooltipItem.xLabel;
					}
				}
			}
		};
	
		Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
	
			// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible
			getStackCount: function() {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
	
				var stacks = [];
				helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {
					var dsMeta = me.chart.getDatasetMeta(datasetIndex);
					if (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&
						(xScale.options.stacked === false ||
						(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||
						(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {
						stacks.push(dsMeta.stack);
					}
				}, me);
	
				return stacks.length;
			},
	
			updateElement: function(rectangle, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				var yScale = me.getScaleForId(meta.yAxisID);
				var scaleBase = xScale.getBasePixel();
				var custom = rectangle.custom || {};
				var dataset = me.getDataset();
				var rectangleElementOptions = me.chart.options.elements.rectangle;
	
				rectangle._xScale = xScale;
				rectangle._yScale = yScale;
				rectangle._datasetIndex = me.index;
				rectangle._index = index;
	
				var ruler = me.getRuler(index); // The index argument for compatible
				rectangle._model = {
					x: reset ? scaleBase : me.calculateBarX(index, me.index),
					y: me.calculateBarY(index, me.index, ruler),
	
					// Tooltip
					label: me.chart.data.labels[index],
					datasetLabel: dataset.label,
	
					// Appearance
					horizontal: true,
					base: reset ? scaleBase : me.calculateBarBase(me.index, index),
					height: me.calculateBarHeight(ruler),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),
					borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,
					borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
				};
	
				rectangle.pivot();
			},
	
			calculateBarBase: function(datasetIndex, index) {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				var base = xScale.getBaseValue();
				var originalBase = base;
	
				if (xScale.options.stacked ||
					(xScale.options.stacked === undefined && meta.stack !== undefined)) {
					var chart = me.chart;
					var datasets = chart.data.datasets;
					var value = Number(datasets[datasetIndex].data[index]);
	
					for (var i = 0; i < datasetIndex; i++) {
						var currentDs = datasets[i];
						var currentDsMeta = chart.getDatasetMeta(i);
						if (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i) &&
							meta.stack === currentDsMeta.stack) {
							var currentVal = Number(currentDs.data[index]);
							base += value < 0 ? Math.min(currentVal, originalBase) : Math.max(currentVal, originalBase);
						}
					}
	
					return xScale.getPixelForValue(base);
				}
	
				return xScale.getBasePixel();
			},
	
			getRuler: function() {
				var me = this;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				var stackCount = me.getStackCount();
	
				var tickHeight = yScale.height / yScale.ticks.length;
				var categoryHeight = tickHeight * yScale.options.categoryPercentage;
				var categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;
				var fullBarHeight = categoryHeight / stackCount;
	
				var barHeight = fullBarHeight * yScale.options.barPercentage;
				var barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);
	
				return {
					stackCount: stackCount,
					tickHeight: tickHeight,
					categoryHeight: categoryHeight,
					categorySpacing: categorySpacing,
					fullBarHeight: fullBarHeight,
					barHeight: barHeight,
					barSpacing: barSpacing
				};
			},
	
			calculateBarHeight: function(ruler) {
				var me = this;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				if (yScale.options.barThickness) {
					return yScale.options.barThickness;
				}
				return ruler.barHeight;
			},
	
			// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible
			getStackIndex: function(datasetIndex) {
				var me = this;
				var meta = me.chart.getDatasetMeta(datasetIndex);
				var xScale = me.getScaleForId(meta.xAxisID);
				var dsMeta, j;
				var stacks = [meta.stack];
	
				for (j = 0; j < datasetIndex; ++j) {
					dsMeta = this.chart.getDatasetMeta(j);
					if (dsMeta.bar && this.chart.isDatasetVisible(j) &&
						(xScale.options.stacked === false ||
						(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||
						(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {
						stacks.push(dsMeta.stack);
					}
				}
	
				return stacks.length - 1;
			},
	
			calculateBarX: function(index, datasetIndex) {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				var value = Number(me.getDataset().data[index]);
	
				if (xScale.options.stacked ||
					(xScale.options.stacked === undefined && meta.stack !== undefined)) {
					var base = xScale.getBaseValue();
					var sumPos = base,
						sumNeg = base;
	
					for (var i = 0; i < datasetIndex; i++) {
						var ds = me.chart.data.datasets[i];
						var dsMeta = me.chart.getDatasetMeta(i);
						if (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i) &&
							meta.stack === dsMeta.stack) {
							var stackedVal = Number(ds.data[index]);
							if (stackedVal < 0) {
								sumNeg += stackedVal || 0;
							} else {
								sumPos += stackedVal || 0;
							}
						}
					}
	
					if (value < 0) {
						return xScale.getPixelForValue(sumNeg + value);
					}
					return xScale.getPixelForValue(sumPos + value);
				}
	
				return xScale.getPixelForValue(value);
			},
	
			calculateBarY: function(index, datasetIndex, ruler) {
				var me = this;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				var stackIndex = me.getStackIndex(datasetIndex);
				var topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);
				topTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;
	
				return topTick +
					(ruler.barHeight / 2) +
					ruler.categorySpacing +
					(ruler.barHeight * stackIndex) +
					(ruler.barSpacing / 2) +
					(ruler.barSpacing * stackIndex);
			}
		});
	};


/***/ },
/* 205 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.bubble = {
			hover: {
				mode: 'single'
			},
	
			scales: {
				xAxes: [{
					type: 'linear', // bubble should probably use a linear scale by default
					position: 'bottom',
					id: 'x-axis-0' // need an ID so datasets can reference the scale
				}],
				yAxes: [{
					type: 'linear',
					position: 'left',
					id: 'y-axis-0'
				}]
			},
	
			tooltips: {
				callbacks: {
					title: function() {
						// Title doesn't make sense for scatter since we format the data as a point
						return '';
					},
					label: function(tooltipItem, data) {
						var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
						var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
						return datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';
					}
				}
			}
		};
	
		Chart.controllers.bubble = Chart.DatasetController.extend({
	
			dataElementType: Chart.elements.Point,
	
			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var points = meta.data;
	
				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				});
			},
	
			updateElement: function(point, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var xScale = me.getScaleForId(meta.xAxisID);
				var yScale = me.getScaleForId(meta.yAxisID);
	
				var custom = point.custom || {};
				var dataset = me.getDataset();
				var data = dataset.data[index];
				var pointElementOptions = me.chart.options.elements.point;
				var dsIndex = me.index;
	
				helpers.extend(point, {
					// Utility
					_xScale: xScale,
					_yScale: yScale,
					_datasetIndex: dsIndex,
					_index: index,
	
					// Desired view properties
					_model: {
						x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),
						y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),
						// Appearance
						radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),
	
						// Tooltip
						hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
					}
				});
	
				// Trick to reset the styles of the point
				Chart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);
	
				var model = point._model;
				model.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));
	
				point.pivot();
			},
	
			getRadius: function(value) {
				return value.r || this.chart.options.elements.point.radius;
			},
	
			setHoverStyle: function(point) {
				var me = this;
				Chart.DatasetController.prototype.setHoverStyle.call(me, point);
	
				// Radius
				var dataset = me.chart.data.datasets[point._datasetIndex];
				var index = point._index;
				var custom = point.custom || {};
				var model = point._model;
				model.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);
			},
	
			removeHoverStyle: function(point) {
				var me = this;
				Chart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);
	
				var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];
				var custom = point.custom || {};
				var model = point._model;
	
				model.radius = custom.radius ? custom.radius : me.getRadius(dataVal);
			}
		});
	};


/***/ },
/* 206 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers,
			defaults = Chart.defaults;
	
		defaults.doughnut = {
			animation: {
				// Boolean - Whether we animate the rotation of the Doughnut
				animateRotate: true,
				// Boolean - Whether we animate scaling the Doughnut from the centre
				animateScale: false
			},
			aspectRatio: 1,
			hover: {
				mode: 'single'
			},
			legendCallback: function(chart) {
				var text = [];
				text.push('<ul class="' + chart.id + '-legend">');
	
				var data = chart.data;
				var datasets = data.datasets;
				var labels = data.labels;
	
				if (datasets.length) {
					for (var i = 0; i < datasets[0].data.length; ++i) {
						text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
						if (labels[i]) {
							text.push(labels[i]);
						}
						text.push('</li>');
					}
				}
	
				text.push('</ul>');
				return text.join('');
			},
			legend: {
				labels: {
					generateLabels: function(chart) {
						var data = chart.data;
						if (data.labels.length && data.datasets.length) {
							return data.labels.map(function(label, i) {
								var meta = chart.getDatasetMeta(0);
								var ds = data.datasets[0];
								var arc = meta.data[i];
								var custom = arc && arc.custom || {};
								var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
								var arcOpts = chart.options.elements.arc;
								var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
								var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
								var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
	
								return {
									text: label,
									fillStyle: fill,
									strokeStyle: stroke,
									lineWidth: bw,
									hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
	
									// Extra data used for toggling the correct item
									index: i
								};
							});
						}
						return [];
					}
				},
	
				onClick: function(e, legendItem) {
					var index = legendItem.index;
					var chart = this.chart;
					var i, ilen, meta;
	
					for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
						meta = chart.getDatasetMeta(i);
						// toggle visibility of index if exists
						if (meta.data[index]) {
							meta.data[index].hidden = !meta.data[index].hidden;
						}
					}
	
					chart.update();
				}
			},
	
			// The percentage of the chart that we cut out of the middle.
			cutoutPercentage: 50,
	
			// The rotation of the chart, where the first data arc begins.
			rotation: Math.PI * -0.5,
	
			// The total circumference of the chart.
			circumference: Math.PI * 2.0,
	
			// Need to override these to give a nice default
			tooltips: {
				callbacks: {
					title: function() {
						return '';
					},
					label: function(tooltipItem, data) {
						var dataLabel = data.labels[tooltipItem.index];
						var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
	
						if (helpers.isArray(dataLabel)) {
							// show value on first line of multiline label
							// need to clone because we are changing the value
							dataLabel = dataLabel.slice();
							dataLabel[0] += value;
						} else {
							dataLabel += value;
						}
	
						return dataLabel;
					}
				}
			}
		};
	
		defaults.pie = helpers.clone(defaults.doughnut);
		helpers.extend(defaults.pie, {
			cutoutPercentage: 0
		});
	
	
		Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
	
			dataElementType: Chart.elements.Arc,
	
			linkScales: helpers.noop,
	
			// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
			getRingIndex: function(datasetIndex) {
				var ringIndex = 0;
	
				for (var j = 0; j < datasetIndex; ++j) {
					if (this.chart.isDatasetVisible(j)) {
						++ringIndex;
					}
				}
	
				return ringIndex;
			},
	
			update: function(reset) {
				var me = this;
				var chart = me.chart,
					chartArea = chart.chartArea,
					opts = chart.options,
					arcOpts = opts.elements.arc,
					availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,
					availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,
					minSize = Math.min(availableWidth, availableHeight),
					offset = {
						x: 0,
						y: 0
					},
					meta = me.getMeta(),
					cutoutPercentage = opts.cutoutPercentage,
					circumference = opts.circumference;
	
				// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
				if (circumference < Math.PI * 2.0) {
					var startAngle = opts.rotation % (Math.PI * 2.0);
					startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
					var endAngle = startAngle + circumference;
					var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
					var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
					var contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
					var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
					var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
					var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
					var cutout = cutoutPercentage / 100.0;
					var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};
					var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};
					var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
					minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
					offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
				}
	
				chart.borderWidth = me.getMaxBorderWidth(meta.data);
				chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
				chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
				chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
				chart.offsetX = offset.x * chart.outerRadius;
				chart.offsetY = offset.y * chart.outerRadius;
	
				meta.total = me.calculateTotal();
	
				me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
				me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
	
				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},
	
			updateElement: function(arc, index, reset) {
				var me = this;
				var chart = me.chart,
					chartArea = chart.chartArea,
					opts = chart.options,
					animationOpts = opts.animation,
					centerX = (chartArea.left + chartArea.right) / 2,
					centerY = (chartArea.top + chartArea.bottom) / 2,
					startAngle = opts.rotation, // non reset case handled later
					endAngle = opts.rotation, // non reset case handled later
					dataset = me.getDataset(),
					circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
					innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,
					outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,
					valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
	
				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
	
					// Desired view properties
					_model: {
						x: centerX + chart.offsetX,
						y: centerY + chart.offsetY,
						startAngle: startAngle,
						endAngle: endAngle,
						circumference: circumference,
						outerRadius: outerRadius,
						innerRadius: innerRadius,
						label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
					}
				});
	
				var model = arc._model;
				// Resets the visual styles
				this.removeHoverStyle(arc);
	
				// Set correct angles if not resetting
				if (!reset || !animationOpts.animateRotate) {
					if (index === 0) {
						model.startAngle = opts.rotation;
					} else {
						model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
					}
	
					model.endAngle = model.startAngle + model.circumference;
				}
	
				arc.pivot();
			},
	
			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},
	
			calculateTotal: function() {
				var dataset = this.getDataset();
				var meta = this.getMeta();
				var total = 0;
				var value;
	
				helpers.each(meta.data, function(element, index) {
					value = dataset.data[index];
					if (!isNaN(value) && !element.hidden) {
						total += Math.abs(value);
					}
				});
	
				/* if (total === 0) {
					total = NaN;
				}*/
	
				return total;
			},
	
			calculateCircumference: function(value) {
				var total = this.getMeta().total;
				if (total > 0 && !isNaN(value)) {
					return (Math.PI * 2.0) * (value / total);
				}
				return 0;
			},
	
			// gets the max border or hover width to properly scale pie charts
			getMaxBorderWidth: function(elements) {
				var max = 0,
					index = this.index,
					length = elements.length,
					borderWidth,
					hoverWidth;
	
				for (var i = 0; i < length; i++) {
					borderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;
					hoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
	
					max = borderWidth > max ? borderWidth : max;
					max = hoverWidth > max ? hoverWidth : max;
				}
				return max;
			}
		});
	};


/***/ },
/* 207 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.line = {
			showLines: true,
			spanGaps: false,
	
			hover: {
				mode: 'label'
			},
	
			scales: {
				xAxes: [{
					type: 'category',
					id: 'x-axis-0'
				}],
				yAxes: [{
					type: 'linear',
					id: 'y-axis-0'
				}]
			}
		};
	
		function lineEnabled(dataset, options) {
			return helpers.getValueOrDefault(dataset.showLine, options.showLines);
		}
	
		Chart.controllers.line = Chart.DatasetController.extend({
	
			datasetElementType: Chart.elements.Line,
	
			dataElementType: Chart.elements.Point,
	
			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var line = meta.dataset;
				var points = meta.data || [];
				var options = me.chart.options;
				var lineElementOptions = options.elements.line;
				var scale = me.getScaleForId(meta.yAxisID);
				var i, ilen, custom;
				var dataset = me.getDataset();
				var showLine = lineEnabled(dataset, options);
	
				// Update Line
				if (showLine) {
					custom = line.custom || {};
	
					// Compatibility: If the properties are defined with only the old name, use those values
					if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
						dataset.lineTension = dataset.tension;
					}
	
					// Utility
					line._scale = scale;
					line._datasetIndex = me.index;
					// Data
					line._children = points;
					// Model
					line._model = {
						// Appearance
						// The default behavior of lines is to break at null values, according
						// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
						// This option gives lines the ability to span gaps
						spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
						tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
						fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
						steppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
						cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
						// Scale
						scaleTop: scale.top,
						scaleBottom: scale.bottom,
						scaleZero: scale.getBasePixel()
					};
	
					line.pivot();
				}
	
				// Update Points
				for (i=0, ilen=points.length; i<ilen; ++i) {
					me.updateElement(points[i], i, reset);
				}
	
				if (showLine && line._model.tension !== 0) {
					me.updateBezierControlPoints();
				}
	
				// Now pivot the point for animation
				for (i=0, ilen=points.length; i<ilen; ++i) {
					points[i].pivot();
				}
			},
	
			getPointBackgroundColor: function(point, index) {
				var backgroundColor = this.chart.options.elements.point.backgroundColor;
				var dataset = this.getDataset();
				var custom = point.custom || {};
	
				if (custom.backgroundColor) {
					backgroundColor = custom.backgroundColor;
				} else if (dataset.pointBackgroundColor) {
					backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
				} else if (dataset.backgroundColor) {
					backgroundColor = dataset.backgroundColor;
				}
	
				return backgroundColor;
			},
	
			getPointBorderColor: function(point, index) {
				var borderColor = this.chart.options.elements.point.borderColor;
				var dataset = this.getDataset();
				var custom = point.custom || {};
	
				if (custom.borderColor) {
					borderColor = custom.borderColor;
				} else if (dataset.pointBorderColor) {
					borderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
				} else if (dataset.borderColor) {
					borderColor = dataset.borderColor;
				}
	
				return borderColor;
			},
	
			getPointBorderWidth: function(point, index) {
				var borderWidth = this.chart.options.elements.point.borderWidth;
				var dataset = this.getDataset();
				var custom = point.custom || {};
	
				if (!isNaN(custom.borderWidth)) {
					borderWidth = custom.borderWidth;
				} else if (!isNaN(dataset.pointBorderWidth)) {
					borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
				} else if (!isNaN(dataset.borderWidth)) {
					borderWidth = dataset.borderWidth;
				}
	
				return borderWidth;
			},
	
			updateElement: function(point, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var custom = point.custom || {};
				var dataset = me.getDataset();
				var datasetIndex = me.index;
				var value = dataset.data[index];
				var yScale = me.getScaleForId(meta.yAxisID);
				var xScale = me.getScaleForId(meta.xAxisID);
				var pointOptions = me.chart.options.elements.point;
				var x, y;
				var labels = me.chart.data.labels || [];
				var includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;
	
				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}
				if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
					dataset.pointHitRadius = dataset.hitRadius;
				}
	
				x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);
				y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
	
				// Utility
				point._xScale = xScale;
				point._yScale = yScale;
				point._datasetIndex = datasetIndex;
				point._index = index;
	
				// Desired view properties
				point._model = {
					x: x,
					y: y,
					skip: custom.skip || isNaN(x) || isNaN(y),
					// Appearance
					radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
					pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
					backgroundColor: me.getPointBackgroundColor(point, index),
					borderColor: me.getPointBorderColor(point, index),
					borderWidth: me.getPointBorderWidth(point, index),
					tension: meta.dataset._model ? meta.dataset._model.tension : 0,
					steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
					// Tooltip
					hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
				};
			},
	
			calculatePointY: function(value, index, datasetIndex) {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				var sumPos = 0;
				var sumNeg = 0;
				var i, ds, dsMeta;
	
				if (yScale.options.stacked) {
					for (i = 0; i < datasetIndex; i++) {
						ds = chart.data.datasets[i];
						dsMeta = chart.getDatasetMeta(i);
						if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
							var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
							if (stackedRightValue < 0) {
								sumNeg += stackedRightValue || 0;
							} else {
								sumPos += stackedRightValue || 0;
							}
						}
					}
	
					var rightValue = Number(yScale.getRightValue(value));
					if (rightValue < 0) {
						return yScale.getPixelForValue(sumNeg + rightValue);
					}
					return yScale.getPixelForValue(sumPos + rightValue);
				}
	
				return yScale.getPixelForValue(value);
			},
	
			updateBezierControlPoints: function() {
				var me = this;
				var meta = me.getMeta();
				var area = me.chart.chartArea;
				var points = (meta.data || []);
				var i, ilen, point, model, controlPoints;
	
				// Only consider points that are drawn in case the spanGaps option is used
				if (meta.dataset._model.spanGaps) {
					points = points.filter(function(pt) {
						return !pt._model.skip;
					});
				}
	
				function capControlPoint(pt, min, max) {
					return Math.max(Math.min(pt, max), min);
				}
	
				if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
					helpers.splineCurveMonotone(points);
				} else {
					for (i = 0, ilen = points.length; i < ilen; ++i) {
						point = points[i];
						model = point._model;
						controlPoints = helpers.splineCurve(
							helpers.previousItem(points, i)._model,
							model,
							helpers.nextItem(points, i)._model,
							meta.dataset._model.tension
						);
						model.controlPointPreviousX = controlPoints.previous.x;
						model.controlPointPreviousY = controlPoints.previous.y;
						model.controlPointNextX = controlPoints.next.x;
						model.controlPointNextY = controlPoints.next.y;
					}
				}
	
				if (me.chart.options.elements.line.capBezierPoints) {
					for (i = 0, ilen = points.length; i < ilen; ++i) {
						model = points[i]._model;
						model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
						model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
						model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
						model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
					}
				}
			},
	
			draw: function(ease) {
				var me = this;
				var meta = me.getMeta();
				var points = meta.data || [];
				var easingDecimal = ease || 1;
				var i, ilen;
	
				// Transition Point Locations
				for (i=0, ilen=points.length; i<ilen; ++i) {
					points[i].transition(easingDecimal);
				}
	
				Chart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);
				// Transition and Draw the line
				if (lineEnabled(me.getDataset(), me.chart.options)) {
					meta.dataset.transition(easingDecimal).draw();
				}
				Chart.canvasHelpers.unclipArea(me.chart.chart.ctx);
	
				// Draw the points
				for (i=0, ilen=points.length; i<ilen; ++i) {
					points[i].draw(me.chart.chartArea);
				}
			},
	
			setHoverStyle: function(point) {
				// Point
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var index = point._index;
				var custom = point.custom || {};
				var model = point._model;
	
				model.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},
	
			removeHoverStyle: function(point) {
				var me = this;
				var dataset = me.chart.data.datasets[point._datasetIndex];
				var index = point._index;
				var custom = point.custom || {};
				var model = point._model;
	
				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}
	
				model.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
				model.backgroundColor = me.getPointBackgroundColor(point, index);
				model.borderColor = me.getPointBorderColor(point, index);
				model.borderWidth = me.getPointBorderWidth(point, index);
			}
		});
	};


/***/ },
/* 208 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.polarArea = {
	
			scale: {
				type: 'radialLinear',
				lineArc: true, // so that lines are circular
				ticks: {
					beginAtZero: true
				}
			},
	
			// Boolean - Whether to animate the rotation of the chart
			animation: {
				animateRotate: true,
				animateScale: true
			},
	
			startAngle: -0.5 * Math.PI,
			aspectRatio: 1,
			legendCallback: function(chart) {
				var text = [];
				text.push('<ul class="' + chart.id + '-legend">');
	
				var data = chart.data;
				var datasets = data.datasets;
				var labels = data.labels;
	
				if (datasets.length) {
					for (var i = 0; i < datasets[0].data.length; ++i) {
						text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
						if (labels[i]) {
							text.push(labels[i]);
						}
						text.push('</li>');
					}
				}
	
				text.push('</ul>');
				return text.join('');
			},
			legend: {
				labels: {
					generateLabels: function(chart) {
						var data = chart.data;
						if (data.labels.length && data.datasets.length) {
							return data.labels.map(function(label, i) {
								var meta = chart.getDatasetMeta(0);
								var ds = data.datasets[0];
								var arc = meta.data[i];
								var custom = arc.custom || {};
								var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
								var arcOpts = chart.options.elements.arc;
								var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
								var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
								var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
	
								return {
									text: label,
									fillStyle: fill,
									strokeStyle: stroke,
									lineWidth: bw,
									hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
	
									// Extra data used for toggling the correct item
									index: i
								};
							});
						}
						return [];
					}
				},
	
				onClick: function(e, legendItem) {
					var index = legendItem.index;
					var chart = this.chart;
					var i, ilen, meta;
	
					for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
						meta = chart.getDatasetMeta(i);
						meta.data[index].hidden = !meta.data[index].hidden;
					}
	
					chart.update();
				}
			},
	
			// Need to override these to give a nice default
			tooltips: {
				callbacks: {
					title: function() {
						return '';
					},
					label: function(tooltipItem, data) {
						return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;
					}
				}
			}
		};
	
		Chart.controllers.polarArea = Chart.DatasetController.extend({
	
			dataElementType: Chart.elements.Arc,
	
			linkScales: helpers.noop,
	
			update: function(reset) {
				var me = this;
				var chart = me.chart;
				var chartArea = chart.chartArea;
				var meta = me.getMeta();
				var opts = chart.options;
				var arcOpts = opts.elements.arc;
				var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
				chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
				chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
				chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
	
				me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
				me.innerRadius = me.outerRadius - chart.radiusLength;
	
				meta.count = me.countVisibleElements();
	
				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},
	
			updateElement: function(arc, index, reset) {
				var me = this;
				var chart = me.chart;
				var dataset = me.getDataset();
				var opts = chart.options;
				var animationOpts = opts.animation;
				var scale = chart.scale;
				var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
				var labels = chart.data.labels;
	
				var circumference = me.calculateCircumference(dataset.data[index]);
				var centerX = scale.xCenter;
				var centerY = scale.yCenter;
	
				// If there is NaN data before us, we need to calculate the starting angle correctly.
				// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
				var visibleCount = 0;
				var meta = me.getMeta();
				for (var i = 0; i < index; ++i) {
					if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
						++visibleCount;
					}
				}
	
				// var negHalfPI = -0.5 * Math.PI;
				var datasetStartAngle = opts.startAngle;
				var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
				var startAngle = datasetStartAngle + (circumference * visibleCount);
				var endAngle = startAngle + (arc.hidden ? 0 : circumference);
	
				var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
	
				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,
	
					// Desired view properties
					_model: {
						x: centerX,
						y: centerY,
						innerRadius: 0,
						outerRadius: reset ? resetRadius : distance,
						startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
						endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
						label: getValueAtIndexOrDefault(labels, index, labels[index])
					}
				});
	
				// Apply border and fill style
				me.removeHoverStyle(arc);
	
				arc.pivot();
			},
	
			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},
	
			countVisibleElements: function() {
				var dataset = this.getDataset();
				var meta = this.getMeta();
				var count = 0;
	
				helpers.each(meta.data, function(element, index) {
					if (!isNaN(dataset.data[index]) && !element.hidden) {
						count++;
					}
				});
	
				return count;
			},
	
			calculateCircumference: function(value) {
				var count = this.getMeta().count;
				if (count > 0 && !isNaN(value)) {
					return (2 * Math.PI) / count;
				}
				return 0;
			}
		});
	};


/***/ },
/* 209 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var helpers = Chart.helpers;
	
		Chart.defaults.radar = {
			aspectRatio: 1,
			scale: {
				type: 'radialLinear'
			},
			elements: {
				line: {
					tension: 0 // no bezier in radar
				}
			}
		};
	
		Chart.controllers.radar = Chart.DatasetController.extend({
	
			datasetElementType: Chart.elements.Line,
	
			dataElementType: Chart.elements.Point,
	
			linkScales: helpers.noop,
	
			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var line = meta.dataset;
				var points = meta.data;
				var custom = line.custom || {};
				var dataset = me.getDataset();
				var lineElementOptions = me.chart.options.elements.line;
				var scale = me.chart.scale;
	
				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
					dataset.lineTension = dataset.tension;
				}
	
				helpers.extend(meta.dataset, {
					// Utility
					_datasetIndex: me.index,
					// Data
					_children: points,
					_loop: true,
					// Model
					_model: {
						// Appearance
						tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
	
						// Scale
						scaleTop: scale.top,
						scaleBottom: scale.bottom,
						scaleZero: scale.getBasePosition()
					}
				});
	
				meta.dataset.pivot();
	
				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				}, me);
	
				// Update bezier control points
				me.updateBezierControlPoints();
			},
			updateElement: function(point, index, reset) {
				var me = this;
				var custom = point.custom || {};
				var dataset = me.getDataset();
				var scale = me.chart.scale;
				var pointElementOptions = me.chart.options.elements.point;
				var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
	
				helpers.extend(point, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,
	
					// Desired view properties
					_model: {
						x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
						y: reset ? scale.yCenter : pointPosition.y,
	
						// Appearance
						tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
						radius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
						borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
						pointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
	
						// Tooltip
						hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
					}
				});
	
				point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
			},
			updateBezierControlPoints: function() {
				var chartArea = this.chart.chartArea;
				var meta = this.getMeta();
	
				helpers.each(meta.data, function(point, index) {
					var model = point._model;
					var controlPoints = helpers.splineCurve(
						helpers.previousItem(meta.data, index, true)._model,
						model,
						helpers.nextItem(meta.data, index, true)._model,
						model.tension
					);
	
					// Prevent the bezier going outside of the bounds of the graph
					model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
					model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
	
					model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
					model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
	
					// Now pivot the point for animation
					point.pivot();
				});
			},
	
			draw: function(ease) {
				var meta = this.getMeta();
				var easingDecimal = ease || 1;
	
				// Transition Point Locations
				helpers.each(meta.data, function(point) {
					point.transition(easingDecimal);
				});
	
				// Transition and Draw the line
				meta.dataset.transition(easingDecimal).draw();
	
				// Draw the points
				helpers.each(meta.data, function(point) {
					point.draw();
				});
			},
	
			setHoverStyle: function(point) {
				// Point
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var custom = point.custom || {};
				var index = point._index;
				var model = point._model;
	
				model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},
	
			removeHoverStyle: function(point) {
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var custom = point.custom || {};
				var index = point._index;
				var model = point._model;
				var pointElementOptions = this.chart.options.elements.point;
	
				model.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);
				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
			}
		});
	};


/***/ },
/* 210 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		Chart.Bar = function(context, config) {
			config.type = 'bar';
	
			return new Chart(context, config);
		};
	
	};


/***/ },
/* 211 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		Chart.Bubble = function(context, config) {
			config.type = 'bubble';
			return new Chart(context, config);
		};
	
	};


/***/ },
/* 212 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		Chart.Doughnut = function(context, config) {
			config.type = 'doughnut';
	
			return new Chart(context, config);
		};
	
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		Chart.Line = function(context, config) {
			config.type = 'line';
	
			return new Chart(context, config);
		};
	
	};


/***/ },
/* 214 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		Chart.PolarArea = function(context, config) {
			config.type = 'polarArea';
	
			return new Chart(context, config);
		};
	
	};


/***/ },
/* 215 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		Chart.Radar = function(context, config) {
			config.type = 'radar';
	
			return new Chart(context, config);
		};
	
	};


/***/ },
/* 216 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(Chart) {
	
		var defaultConfig = {
			hover: {
				mode: 'single'
			},
	
			scales: {
				xAxes: [{
					type: 'linear', // scatter should not use a category axis
					position: 'bottom',
					id: 'x-axis-1' // need an ID so datasets can reference the scale
				}],
				yAxes: [{
					type: 'linear',
					position: 'left',
					id: 'y-axis-1'
				}]
			},
	
			tooltips: {
				callbacks: {
					title: function() {
						// Title doesn't make sense for scatter since we format the data as a point
						return '';
					},
					label: function(tooltipItem) {
						return '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';
					}
				}
			}
		};
	
		// Register the default config for this type
		Chart.defaults.scatter = defaultConfig;
	
		// Scatter charts use line controllers
		Chart.controllers.scatter = Chart.controllers.line;
	
		Chart.Scatter = function(context, config) {
			config.type = 'scatter';
			return new Chart(context, config);
		};
	
	};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.C = exports.UNIT = undefined;
	
	var _toConsumableArray2 = __webpack_require__(218);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	exports.ellipsoidSizes = ellipsoidSizes;
	exports.crsToUnit = crsToUnit;
	exports.reasonnableEpsilonForUnit = reasonnableEpsilonForUnit;
	exports.assertCrsIsValid = assertCrsIsValid;
	exports.crsIsGeographic = crsIsGeographic;
	exports.crsIsGeocentric = crsIsGeocentric;
	exports.convertValueToUnit = convertValueToUnit;
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _proj = __webpack_require__(227);
	
	var _proj2 = _interopRequireDefault(_proj);
	
	var _MathExtended = __webpack_require__(228);
	
	var _MathExtended2 = _interopRequireDefault(_MathExtended);
	
	var _Ellipsoid = __webpack_require__(229);
	
	var _Ellipsoid2 = _interopRequireDefault(_Ellipsoid);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Coordinates
	 * Description: Coordonnes cartographiques
	 */
	
	function ellipsoidSizes() {
	    return {
	        x: 6378137,
	        y: 6378137,
	        z: 6356752.3142451793
	    };
	}
	
	var ellipsoid = new _Ellipsoid2.default(ellipsoidSizes());
	
	var UNIT = exports.UNIT = {
	    RADIAN: 0,
	    DEGREE: 1,
	    METER: 2
	};
	
	function _unitFromProj4Unit(projunit) {
	    if (projunit === 'degrees') {
	        return UNIT.DEGREE;
	    } else if (projunit === 'm') {
	        return UNIT.METER;
	    } else if (projunit === 'radians') {
	        return UNIT.RADIAN;
	    } else {
	        return undefined;
	    }
	}
	
	function crsToUnit(crs) {
	    switch (crs) {
	        case 'EPSG:4326':
	            return UNIT.DEGREE;
	        case 'EPSG:4978':
	            return UNIT.METER;
	        default:
	            {
	                var p = _proj2.default.defs(crs);
	                if (!p) {
	                    return undefined;
	                }
	                return _unitFromProj4Unit(p.units);
	            }
	    }
	}
	
	function reasonnableEpsilonForUnit(unit) {
	    switch (unit) {
	        case UNIT.RADIAN:
	            return 0.00001;
	        case UNIT.DEGREE:
	            return 0.01;
	        case UNIT.METER:
	            return 0.001;
	        default:
	            return 0;
	    }
	}
	
	function _crsToUnitWithError(crs) {
	    var u = crsToUnit(crs);
	    if (crs === undefined || u === undefined) {
	        throw new Error('Invalid crs paramater value \'' + crs + '\'');
	    }
	    return u;
	}
	
	function assertCrsIsValid(crs) {
	    _crsToUnitWithError(crs);
	}
	
	function crsIsGeographic(crs) {
	    return _crsToUnitWithError(crs) != UNIT.METER;
	}
	
	function crsIsGeocentric(crs) {
	    return _crsToUnitWithError(crs) == UNIT.METER;
	}
	
	function _assertIsGeographic(crs) {
	    if (!crsIsGeographic(crs)) {
	        throw new Error('Can\'t query crs ' + crs + ' long/lat');
	    }
	}
	
	function _assertIsGeocentric(crs) {
	    if (!crsIsGeocentric(crs)) {
	        throw new Error('Can\'t query crs ' + crs + ' x/y/z');
	    }
	}
	
	// Only support explicit conversions
	function _convert(coordsIn, newCrs) {
	    if (newCrs === coordsIn.crs) {
	        var refUnit = crsToUnit(newCrs);
	        if (coordsIn._internalStorageUnit != refUnit) {
	            // custom internal unit
	            if (coordsIn._internalStorageUnit == UNIT.DEGREE && refUnit == UNIT.RADIAN) {
	                return new (Function.prototype.bind.apply(Coordinates, [null].concat([newCrs], (0, _toConsumableArray3.default)(coordsIn._values.map(function (x) {
	                    return _MathExtended2.default.degToRad(x);
	                })))))();
	            } else if (coordsIn._internalStorageUnit == UNIT.RADIAN && refUnit == UNIT.DEGREE) {
	                return new (Function.prototype.bind.apply(Coordinates, [null].concat([newCrs], (0, _toConsumableArray3.default)(coordsIn._values.map(function (x) {
	                    return _MathExtended2.default.radToDeg(x);
	                })))))();
	            }
	        } else {
	            // No need to create a new object as Coordinates objects are mostly
	            // immutable (there's no .setLongitude() method etc)
	            return coordsIn;
	        }
	    } else {
	        if (coordsIn.crs === 'EPSG:4326' && newCrs === 'EPSG:4978') {
	            var cartesian = ellipsoid.cartographicToCartesian(coordsIn);
	            return new Coordinates(newCrs, cartesian.x, cartesian.y, cartesian.z);
	        }
	
	        if (coordsIn.crs === 'EPSG:4978' && newCrs === 'EPSG:4326') {
	            var geo = ellipsoid.cartesianToCartographic({
	                x: coordsIn._values[0],
	                y: coordsIn._values[1],
	                z: coordsIn._values[2]
	            });
	            return new Coordinates(newCrs, geo.longitude, geo.latitude, geo.h);
	        }
	
	        if (coordsIn.crs in _proj2.default.defs && newCrs in _proj2.default.defs) {
	            var p = (0, _proj2.default)(coordsIn.crs, newCrs, [coordsIn._values[0], coordsIn._values[1]]);
	            return new Coordinates(newCrs, p[0], p[1], coordsIn._values[2]);
	        }
	
	        throw new Error('Cannot convert from crs ' + coordsIn.crs + ' (unit=' + coordsIn._internalStorageUnit + ') to ' + newCrs);
	    }
	}
	
	function convertValueToUnit(unitIn, unitOut, value) {
	    if (unitOut == undefined || unitIn == unitOut) {
	        return value;
	    } else {
	        if (unitIn == UNIT.DEGREE && unitOut == UNIT.RADIAN) {
	            return _MathExtended2.default.degToRad(value);
	        }
	        if (unitIn == UNIT.RADIAN && unitOut == UNIT.DEGREE) {
	            return _MathExtended2.default.radToDeg(value);
	        }
	        throw new Error('Cannot convert from unit ' + unitIn + ' to ' + unitOut);
	    }
	}
	
	/**
	 * Build a Coordinates object, given a crs and a number of coordinates value.
	 * crs parameter can currently only be WGS84
	 */
	function Coordinates(crs) {
	    _crsToUnitWithError(crs);
	    this.crs = crs;
	    this._values = new Float64Array(3);
	
	    for (var _len = arguments.length, coordinates = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        coordinates[_key - 1] = arguments[_key];
	    }
	
	    if (coordinates.length == 1 && coordinates[0] instanceof THREE.Vector3) {
	        this._values[0] = coordinates[0].x;
	        this._values[1] = coordinates[0].y;
	        this._values[2] = coordinates[0].z;
	    } else {
	        for (var i = 0; i < coordinates.length && i < 3; i++) {
	            this._values[i] = coordinates[i];
	        }
	        for (var _i = coordinates.length; _i < 3; _i++) {
	            this._values[_i] = 0;
	        }
	    }
	    this._internalStorageUnit = crsToUnit(crs);
	}
	
	Coordinates.prototype.clone = function clone() {
	    var r = new (Function.prototype.bind.apply(Coordinates, [null].concat([this.crs], (0, _toConsumableArray3.default)(this._values))))();
	    r._internalStorageUnit = this._internalStorageUnit;
	    return r;
	};
	
	Coordinates.prototype.longitude = function longitude(unit) {
	    _assertIsGeographic(this.crs);
	    return convertValueToUnit(this._internalStorageUnit, unit, this._values[0]);
	};
	
	Coordinates.prototype.latitude = function latitude(unit) {
	    _assertIsGeographic(this.crs);
	    return convertValueToUnit(this._internalStorageUnit, unit, this._values[1]);
	};
	
	Coordinates.prototype.altitude = function altitude() {
	    _assertIsGeographic(this.crs);
	    return this._values[2];
	};
	
	Coordinates.prototype.setAltitude = function setAltitude(altitude) {
	    _assertIsGeographic(this.crs);
	    this._values[2] = altitude;
	};
	
	Coordinates.prototype.x = function x() {
	    _assertIsGeocentric(this.crs);
	    return this._values[0];
	};
	
	Coordinates.prototype.y = function y() {
	    _assertIsGeocentric(this.crs);
	    return this._values[1];
	};
	
	Coordinates.prototype.z = function z() {
	    _assertIsGeocentric(this.crs);
	    return this._values[2];
	};
	
	Coordinates.prototype.xyz = function xyz() {
	    _assertIsGeocentric(this.crs);
	    var v = new THREE.Vector3();
	    v.fromArray(this._values);
	    return v;
	};
	
	Coordinates.prototype.as = function as(crs) {
	    if (crs === undefined || !crsToUnit(crs)) {
	        throw new Error('Invalid crs paramater value \'' + crs + '\'');
	    }
	    return _convert(this, crs);
	};
	
	var C = exports.C = {
	
	    /**
	     * Return a Coordinates object from a position object. The object just
	     * needs to have x, y, z properties.
	     *
	     * @param {string} crs - The crs of the original position
	     * @param {Object} position - the position to transform
	     * @param {number} position.x - the x component of the position
	     * @param {number} position.y - the y component of the position
	     * @param {number} position.z - the z component of the position
	     */
	    EPSG_4326: function EPSG_4326() {
	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	        }
	
	        return new (Function.prototype.bind.apply(Coordinates, [null].concat(['EPSG:4326'], args)))();
	    },
	    EPSG_4326_Radians: function EPSG_4326() {
	        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	            args[_key3] = arguments[_key3];
	        }
	
	        var result = new (Function.prototype.bind.apply(Coordinates, [null].concat(['EPSG:4326'], args)))();
	        result._internalStorageUnit = UNIT.RADIAN;
	        return result;
	    }
	};
	
	exports.default = Coordinates;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(219);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(220), __esModule: true };

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(54);
	__webpack_require__(221);
	module.exports = __webpack_require__(15).Array.from;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(16)
	  , $export        = __webpack_require__(14)
	  , toObject       = __webpack_require__(5)
	  , call           = __webpack_require__(222)
	  , isArrayIter    = __webpack_require__(223)
	  , toLength       = __webpack_require__(47)
	  , createProperty = __webpack_require__(224)
	  , getIterFn      = __webpack_require__(57);
	
	$export($export.S + $export.F * !__webpack_require__(225)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(20);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(34)
	  , ITERATOR   = __webpack_require__(53)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(19)
	  , createDesc      = __webpack_require__(27);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(53)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.THREE = global.THREE || {})));
	}(this, (function (exports) { 'use strict';
	
		// Polyfills
	
		if ( Number.EPSILON === undefined ) {
	
			Number.EPSILON = Math.pow( 2, - 52 );
	
		}
	
		//
	
		if ( Math.sign === undefined ) {
	
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
			Math.sign = function ( x ) {
	
				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
			};
	
		}
	
		if ( Function.prototype.name === undefined ) {
	
			// Missing in IE9-11.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
			Object.defineProperty( Function.prototype, 'name', {
	
				get: function () {
	
					return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];
	
				}
	
			} );
	
		}
	
		if ( Object.assign === undefined ) {
	
			// Missing in IE.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
			( function () {
	
				Object.assign = function ( target ) {
	
					'use strict';
	
					if ( target === undefined || target === null ) {
	
						throw new TypeError( 'Cannot convert undefined or null to object' );
	
					}
	
					var output = Object( target );
	
					for ( var index = 1; index < arguments.length; index ++ ) {
	
						var source = arguments[ index ];
	
						if ( source !== undefined && source !== null ) {
	
							for ( var nextKey in source ) {
	
								if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
	
									output[ nextKey ] = source[ nextKey ];
	
								}
	
							}
	
						}
	
					}
	
					return output;
	
				};
	
			} )();
	
		}
	
		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */
	
		function EventDispatcher() {}
	
		EventDispatcher.prototype = {
	
			addEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) this._listeners = {};
	
				var listeners = this._listeners;
	
				if ( listeners[ type ] === undefined ) {
	
					listeners[ type ] = [];
	
				}
	
				if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
					listeners[ type ].push( listener );
	
				}
	
			},
	
			hasEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return false;
	
				var listeners = this._listeners;
	
				return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;
	
			},
	
			removeEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ type ];
	
				if ( listenerArray !== undefined ) {
	
					var index = listenerArray.indexOf( listener );
	
					if ( index !== - 1 ) {
	
						listenerArray.splice( index, 1 );
	
					}
	
				}
	
			},
	
			dispatchEvent: function ( event ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];
	
				if ( listenerArray !== undefined ) {
	
					event.target = this;
	
					var array = [], i = 0;
					var length = listenerArray.length;
	
					for ( i = 0; i < length; i ++ ) {
	
						array[ i ] = listenerArray[ i ];
	
					}
	
					for ( i = 0; i < length; i ++ ) {
	
						array[ i ].call( this, event );
	
					}
	
				}
	
			}
	
		};
	
		var REVISION = '84';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var NearestFilter = 1003;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipMapLinearFilter = 1008;
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RGB_S3TC_DXT1_Format = 2001;
		var RGBA_S3TC_DXT1_Format = 2002;
		var RGBA_S3TC_DXT3_Format = 2003;
		var RGBA_S3TC_DXT5_Format = 2004;
		var RGB_PVRTC_4BPPV1_Format = 2100;
		var RGB_PVRTC_2BPPV1_Format = 2101;
		var RGBA_PVRTC_4BPPV1_Format = 2102;
		var RGBA_PVRTC_2BPPV1_Format = 2103;
		var RGB_ETC1_Format = 2151;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var _Math = {
	
			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,
	
			generateUUID: function () {
	
				// http://www.broofa.com/Tools/Math.uuid.htm
	
				var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
				var uuid = new Array( 36 );
				var rnd = 0, r;
	
				return function generateUUID() {
	
					for ( var i = 0; i < 36; i ++ ) {
	
						if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
							uuid[ i ] = '-';
	
						} else if ( i === 14 ) {
	
							uuid[ i ] = '4';
	
						} else {
	
							if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
							r = rnd & 0xf;
							rnd = rnd >> 4;
							uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
						}
	
					}
	
					return uuid.join( '' );
	
				};
	
			}(),
	
			clamp: function ( value, min, max ) {
	
				return Math.max( min, Math.min( max, value ) );
	
			},
	
			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation
	
			euclideanModulo: function ( n, m ) {
	
				return ( ( n % m ) + m ) % m;
	
			},
	
			// Linear mapping from range <a1, a2> to range <b1, b2>
	
			mapLinear: function ( x, a1, a2, b1, b2 ) {
	
				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
			},
	
			// https://en.wikipedia.org/wiki/Linear_interpolation
	
			lerp: function ( x, y, t ) {
	
				return ( 1 - t ) * x + t * y;
	
			},
	
			// http://en.wikipedia.org/wiki/Smoothstep
	
			smoothstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * ( 3 - 2 * x );
	
			},
	
			smootherstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
			},
	
			// Random integer from <low, high> interval
	
			randInt: function ( low, high ) {
	
				return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
			},
	
			// Random float from <low, high> interval
	
			randFloat: function ( low, high ) {
	
				return low + Math.random() * ( high - low );
	
			},
	
			// Random float from <-range/2, range/2> interval
	
			randFloatSpread: function ( range ) {
	
				return range * ( 0.5 - Math.random() );
	
			},
	
			degToRad: function ( degrees ) {
	
				return degrees * _Math.DEG2RAD;
	
			},
	
			radToDeg: function ( radians ) {
	
				return radians * _Math.RAD2DEG;
	
			},
	
			isPowerOfTwo: function ( value ) {
	
				return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
			},
	
			nearestPowerOfTwo: function ( value ) {
	
				return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
			},
	
			nextPowerOfTwo: function ( value ) {
	
				value --;
				value |= value >> 1;
				value |= value >> 2;
				value |= value >> 4;
				value |= value >> 8;
				value |= value >> 16;
				value ++;
	
				return value;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		function Vector2( x, y ) {
	
			this.x = x || 0;
			this.y = y || 0;
	
		}
	
		Vector2.prototype = {
	
			constructor: Vector2,
	
			isVector2: true,
	
			get width() {
	
				return this.x;
	
			},
	
			set width( value ) {
	
				this.x = value;
	
			},
	
			get height() {
	
				return this.y;
	
			},
	
			set height( value ) {
	
				this.y = value;
	
			},
	
			//
	
			set: function ( x, y ) {
	
				this.x = x;
				this.y = y;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
	
				return this;
	
			},
	
			multiply: function ( v ) {
	
				this.x *= v.x;
				this.y *= v.y;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
	
				}
	
				return this;
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector2();
						max = new Vector2();
	
					}
	
					min.set( minVal, minVal );
					max.set( maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y );
	
			},
	
			lengthManhattan: function() {
	
				return Math.abs( this.x ) + Math.abs( this.y );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			angle: function () {
	
				// computes the angle in radians with respect to the positive x-axis
	
				var angle = Math.atan2( this.y, this.x );
	
				if ( angle < 0 ) angle += 2 * Math.PI;
	
				return angle;
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
	
				return this;
	
			},
	
			rotateAround: function ( center, angle ) {
	
				var c = Math.cos( angle ), s = Math.sin( angle );
	
				var x = this.x - center.x;
				var y = this.y - center.y;
	
				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */
	
		var textureId = 0;
	
		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			Object.defineProperty( this, 'id', { value: textureId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
	
			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];
	
			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	
			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
	
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
	
			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
			this.format = format !== undefined ? format : RGBAFormat;
			this.type = type !== undefined ? type : UnsignedByteType;
	
			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
	
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
	
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding : LinearEncoding;
	
			this.version = 0;
			this.onUpdate = null;
	
		}
	
		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;
	
		Texture.prototype = {
	
			constructor: Texture,
	
			isTexture: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );
	
				this.mapping = source.mapping;
	
				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;
	
				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;
	
				this.anisotropy = source.anisotropy;
	
				this.format = source.format;
				this.type = source.type;
	
				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );
	
				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				if ( meta.textures[ this.uuid ] !== undefined ) {
	
					return meta.textures[ this.uuid ];
	
				}
	
				function getDataURL( image ) {
	
					var canvas;
	
					if ( image.toDataURL !== undefined ) {
	
						canvas = image;
	
					} else {
	
						canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
						canvas.width = image.width;
						canvas.height = image.height;
	
						canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
					}
	
					if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
						return canvas.toDataURL( 'image/jpeg', 0.6 );
	
					} else {
	
						return canvas.toDataURL( 'image/png' );
	
					}
	
				}
	
				var output = {
					metadata: {
						version: 4.4,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},
	
					uuid: this.uuid,
					name: this.name,
	
					mapping: this.mapping,
	
					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					wrap: [ this.wrapS, this.wrapT ],
	
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
	
					flipY: this.flipY
				};
	
				if ( this.image !== undefined ) {
	
					// TODO: Move to THREE.Image
	
					var image = this.image;
	
					if ( image.uuid === undefined ) {
	
						image.uuid = _Math.generateUUID(); // UGH
	
					}
	
					if ( meta.images[ image.uuid ] === undefined ) {
	
						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: getDataURL( image )
						};
	
					}
	
					output.image = image.uuid;
	
				}
	
				meta.textures[ this.uuid ] = output;
	
				return output;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			},
	
			transformUv: function ( uv ) {
	
				if ( this.mapping !== UVMapping ) return;
	
				uv.multiply( this.repeat );
				uv.add( this.offset );
	
				if ( uv.x < 0 || uv.x > 1 ) {
	
					switch ( this.wrapS ) {
	
						case RepeatWrapping:
	
							uv.x = uv.x - Math.floor( uv.x );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.x = uv.x < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
								uv.x = Math.ceil( uv.x ) - uv.x;
	
							} else {
	
								uv.x = uv.x - Math.floor( uv.x );
	
							}
							break;
	
					}
	
				}
	
				if ( uv.y < 0 || uv.y > 1 ) {
	
					switch ( this.wrapT ) {
	
						case RepeatWrapping:
	
							uv.y = uv.y - Math.floor( uv.y );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.y = uv.y < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
								uv.y = Math.ceil( uv.y ) - uv.y;
	
							} else {
	
								uv.y = uv.y - Math.floor( uv.y );
	
							}
							break;
	
					}
	
				}
	
				if ( this.flipY ) {
	
					uv.y = 1 - uv.y;
	
				}
	
			}
	
		};
	
		Object.assign( Texture.prototype, EventDispatcher.prototype );
	
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector4( x, y, z, w ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;
	
		}
	
		Vector4.prototype = {
	
			constructor: Vector4,
	
			isVector4: true,
	
			set: function ( x, y, z, w ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setW: function ( w ) {
	
				this.w = w;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z, this.w );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
					this.w *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
					this.z = 0;
					this.w = 0;
	
				}
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			setAxisAngleFromQuaternion: function ( q ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
				// q is assumed to be normalized
	
				this.w = 2 * Math.acos( q.w );
	
				var s = Math.sqrt( 1 - q.w * q.w );
	
				if ( s < 0.0001 ) {
	
					 this.x = 1;
					 this.y = 0;
					 this.z = 0;
	
				} else {
	
					 this.x = q.x / s;
					 this.y = q.y / s;
					 this.z = q.z / s;
	
				}
	
				return this;
	
			},
	
			setAxisAngleFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
					te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms
	
					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
						// this singularity is identity matrix so angle = 0
	
						this.set( 1, 0, 0, 0 );
	
						return this; // zero angle, arbitrary axis
	
					}
	
					// otherwise this singularity is angle = 180
	
					angle = Math.PI;
	
					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;
	
					if ( ( xx > yy ) && ( xx > zz ) ) {
	
						// m11 is the largest diagonal term
	
						if ( xx < epsilon ) {
	
							x = 0;
							y = 0.707106781;
							z = 0.707106781;
	
						} else {
	
							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;
	
						}
	
					} else if ( yy > zz ) {
	
						// m22 is the largest diagonal term
	
						if ( yy < epsilon ) {
	
							x = 0.707106781;
							y = 0;
							z = 0.707106781;
	
						} else {
	
							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;
	
						}
	
					} else {
	
						// m33 is the largest diagonal term so base result on this
	
						if ( zz < epsilon ) {
	
							x = 0.707106781;
							y = 0.707106781;
							z = 0;
	
						} else {
	
							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;
	
						}
	
					}
	
					this.set( x, y, z, angle );
	
					return this; // return 180 deg rotation
	
				}
	
				// as we have reached here there are no singularities so we can handle normally
	
				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
				if ( Math.abs( s ) < 0.001 ) s = 1;
	
				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case
	
				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
				return this;
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector4();
						max = new Vector4();
	
					}
	
					min.set( minVal, minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
				this.w = attribute.getW( index );
	
				return this;
	
			}
	
		};
	
		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */
	
		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {
	
			this.uuid = _Math.generateUUID();
	
			this.width = width;
			this.height = height;
	
			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;
	
			this.viewport = new Vector4( 0, 0, width, height );
	
			options = options || {};
	
			if ( options.minFilter === undefined ) options.minFilter = LinearFilter;
	
			this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
	
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	
		}
	
		WebGLRenderTarget.prototype = {
	
			constructor: WebGLRenderTarget,
	
			isWebGLRenderTarget: true,
	
			setSize: function ( width, height ) {
	
				if ( this.width !== width || this.height !== height ) {
	
					this.width = width;
					this.height = height;
	
					this.dispose();
	
				}
	
				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.width = source.width;
				this.height = source.height;
	
				this.viewport.copy( source.viewport );
	
				this.texture = source.texture.clone();
	
				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype );
	
		/**
		 * @author alteredq / http://alteredqualia.com
		 */
	
		function WebGLRenderTargetCube( width, height, options ) {
	
			WebGLRenderTarget.call( this, width, height, options );
	
			this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
			this.activeMipMapLevel = 0;
	
		}
	
		WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
	
		WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Quaternion( x, y, z, w ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;
	
		}
	
		Quaternion.prototype = {
	
			constructor: Quaternion,
	
			get x () {
	
				return this._x;
	
			},
	
			set x ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			},
	
			get y () {
	
				return this._y;
	
			},
	
			set y ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			},
	
			get z () {
	
				return this._z;
	
			},
	
			set z ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			},
	
			get w () {
	
				return this._w;
	
			},
	
			set w ( value ) {
	
				this._w = value;
				this.onChangeCallback();
	
			},
	
			set: function ( x, y, z, w ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._w );
	
			},
	
			copy: function ( quaternion ) {
	
				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromEuler: function ( euler, update ) {
	
				if ( (euler && euler.isEuler) === false ) {
	
					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m
	
				var c1 = Math.cos( euler._x / 2 );
				var c2 = Math.cos( euler._y / 2 );
				var c3 = Math.cos( euler._z / 2 );
				var s1 = Math.sin( euler._x / 2 );
				var s2 = Math.sin( euler._y / 2 );
				var s3 = Math.sin( euler._z / 2 );
	
				var order = euler.order;
	
				if ( order === 'XYZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'YXZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'ZXY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'ZYX' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'YZX' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'XZY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				}
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromAxisAngle: function ( axis, angle ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
				// assumes axis is normalized
	
				var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
					trace = m11 + m22 + m33,
					s;
	
				if ( trace > 0 ) {
	
					s = 0.5 / Math.sqrt( trace + 1.0 );
	
					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;
	
				} else if ( m11 > m22 && m11 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;
	
				} else if ( m22 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;
	
				} else {
	
					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromUnitVectors: function () {
	
				// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
				// assumes direction vectors vFrom and vTo are normalized
	
				var v1, r;
	
				var EPS = 0.000001;
	
				return function setFromUnitVectors( vFrom, vTo ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					r = vFrom.dot( vTo ) + 1;
	
					if ( r < EPS ) {
	
						r = 0;
	
						if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
							v1.set( - vFrom.y, vFrom.x, 0 );
	
						} else {
	
							v1.set( 0, - vFrom.z, vFrom.y );
	
						}
	
					} else {
	
						v1.crossVectors( vFrom, vTo );
	
					}
	
					this._x = v1.x;
					this._y = v1.y;
					this._z = v1.z;
					this._w = r;
	
					return this.normalize();
	
				};
	
			}(),
	
			inverse: function () {
	
				return this.conjugate().normalize();
	
			},
	
			conjugate: function () {
	
				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
			},
	
			lengthSq: function () {
	
				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
			},
	
			normalize: function () {
	
				var l = this.length();
	
				if ( l === 0 ) {
	
					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;
	
				} else {
	
					l = 1 / l;
	
					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			multiply: function ( q, p ) {
	
				if ( p !== undefined ) {
	
					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );
	
				}
	
				return this.multiplyQuaternions( this, q );
	
			},
	
			premultiply: function ( q ) {
	
				return this.multiplyQuaternions( q, this );
	
			},
	
			multiplyQuaternions: function ( a, b ) {
	
				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			slerp: function ( qb, t ) {
	
				if ( t === 0 ) return this;
				if ( t === 1 ) return this.copy( qb );
	
				var x = this._x, y = this._y, z = this._z, w = this._w;
	
				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
				if ( cosHalfTheta < 0 ) {
	
					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;
	
					cosHalfTheta = - cosHalfTheta;
	
				} else {
	
					this.copy( qb );
	
				}
	
				if ( cosHalfTheta >= 1.0 ) {
	
					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;
	
					return this;
	
				}
	
				var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
				if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
					this._w = 0.5 * ( w + this._w );
					this._x = 0.5 * ( x + this._x );
					this._y = 0.5 * ( y + this._y );
					this._z = 0.5 * ( z + this._z );
	
					return this;
	
				}
	
				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			equals: function ( quaternion ) {
	
				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;
	
				return array;
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		};
	
		Object.assign( Quaternion, {
	
			slerp: function( qa, qb, qm, t ) {
	
				return qm.copy( qa ).slerp( qb, t );
	
			},
	
			slerpFlat: function(
					dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
				// fuzz-free, array-based Quaternion SLERP operation
	
				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],
	
					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];
	
				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
					var s = 1 - t,
	
						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;
	
					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {
	
						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );
	
						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;
	
					}
	
					var tDir = t * dir;
	
					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;
	
					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {
	
						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;
	
					}
	
				}
	
				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author *kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector3( x, y, z ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
	
		}
	
		Vector3.prototype = {
	
			constructor: Vector3,
	
			isVector3: true,
	
			set: function ( x, y, z ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
	
				return this;
	
			},
	
			multiply: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );
	
				}
	
				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
					this.z = 0;
	
				}
	
				return this;
	
			},
	
			multiplyVectors: function ( a, b ) {
	
				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;
	
				return this;
	
			},
	
			applyEuler: function () {
	
				var quaternion;
	
				return function applyEuler( euler ) {
	
					if ( (euler && euler.isEuler) === false ) {
	
						console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
					}
	
					if ( quaternion === undefined ) quaternion = new Quaternion();
	
					return this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				};
	
			}(),
	
			applyAxisAngle: function () {
	
				var quaternion;
	
				return function applyAxisAngle( axis, angle ) {
	
					if ( quaternion === undefined ) quaternion = new Quaternion();
	
					return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				};
	
			}(),
	
			applyMatrix3: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
				var w =  e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ];
	
				return this.divideScalar( w );
	
			},
	
			applyQuaternion: function ( q ) {
	
				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	
				// calculate quat * vector
	
				var ix =  qw * x + qy * z - qz * y;
				var iy =  qw * y + qz * x - qx * z;
				var iz =  qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;
	
				// calculate result * inverse quat
	
				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
				return this;
	
			},
	
			project: function () {
	
				var matrix;
	
				return function project( camera ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
					return this.applyMatrix4( matrix );
	
				};
	
			}(),
	
			unproject: function () {
	
				var matrix;
	
				return function unproject( camera ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
					return this.applyMatrix4( matrix );
	
				};
	
			}(),
	
			transformDirection: function ( m ) {
	
				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
				return this.normalize();
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector3();
						max = new Vector3();
	
					}
	
					min.set( minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			cross: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );
	
				}
	
				var x = this.x, y = this.y, z = this.z;
	
				this.x = y * v.z - z * v.y;
				this.y = z * v.x - x * v.z;
				this.z = x * v.y - y * v.x;
	
				return this;
	
			},
	
			crossVectors: function ( a, b ) {
	
				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;
	
				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;
	
				return this;
	
			},
	
			projectOnVector: function ( vector ) {
	
				var scalar = vector.dot( this ) / vector.lengthSq();
	
				return this.copy( vector ).multiplyScalar( scalar );
	
			},
	
			projectOnPlane: function () {
	
				var v1;
	
				return function projectOnPlane( planeNormal ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					v1.copy( this ).projectOnVector( planeNormal );
	
					return this.sub( v1 );
	
				};
	
			}(),
	
			reflect: function () {
	
				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length
	
				var v1;
	
				return function reflect( normal ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
				};
	
			}(),
	
			angleTo: function ( v ) {
	
				var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
				// clamp, to handle numerical problems
	
				return Math.acos( _Math.clamp( theta, - 1, 1 ) );
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	
				return dx * dx + dy * dy + dz * dz;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
	
			},
	
			setFromSpherical: function( s ) {
	
				var sinPhiRadius = Math.sin( s.phi ) * s.radius;
	
				this.x = sinPhiRadius * Math.sin( s.theta );
				this.y = Math.cos( s.phi ) * s.radius;
				this.z = sinPhiRadius * Math.cos( s.theta );
	
				return this;
	
			},
	
			setFromCylindrical: function( c ) {
	
				this.x = c.radius * Math.sin( c.theta );
				this.y = c.y;
				this.z = c.radius * Math.cos( c.theta );
	
				return this;
	
			},
	
			setFromMatrixPosition: function ( m ) {
	
				return this.setFromMatrixColumn( m, 3 );
	
			},
	
			setFromMatrixScale: function ( m ) {
	
				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();
	
				this.x = sx;
				this.y = sy;
				this.z = sz;
	
				return this;
	
			},
	
			setFromMatrixColumn: function ( m, index ) {
	
				if ( typeof m === 'number' ) {
	
					console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
					var temp = m;
					m = index;
					index = temp;
	
				}
	
				return this.fromArray( m.elements, index * 4 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Matrix4() {
	
			this.elements = new Float32Array( [
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			] );
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Matrix4.prototype = {
	
			constructor: Matrix4,
	
			isMatrix4: true,
	
			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new Matrix4().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				this.elements.set( m.elements );
	
				return this;
	
			},
	
			copyPosition: function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];
	
				return this;
	
			},
	
			extractBasis: function ( xAxis, yAxis, zAxis ) {
	
				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );
	
				return this;
	
			},
	
			makeBasis: function ( xAxis, yAxis, zAxis ) {
	
				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0,       0,       0,       1
				);
	
				return this;
	
			},
	
			extractRotation: function () {
	
				var v1;
	
				return function extractRotation( m ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					var te = this.elements;
					var me = m.elements;
	
					var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
					var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
					var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
	
					te[ 0 ] = me[ 0 ] * scaleX;
					te[ 1 ] = me[ 1 ] * scaleX;
					te[ 2 ] = me[ 2 ] * scaleX;
	
					te[ 4 ] = me[ 4 ] * scaleY;
					te[ 5 ] = me[ 5 ] * scaleY;
					te[ 6 ] = me[ 6 ] * scaleY;
	
					te[ 8 ] = me[ 8 ] * scaleZ;
					te[ 9 ] = me[ 9 ] * scaleZ;
					te[ 10 ] = me[ 10 ] * scaleZ;
	
					return this;
	
				};
	
			}(),
	
			makeRotationFromEuler: function ( euler ) {
	
				if ( (euler && euler.isEuler) === false ) {
	
					console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
				}
	
				var te = this.elements;
	
				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );
	
				if ( euler.order === 'XYZ' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;
	
					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;
	
					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YXZ' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;
	
					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;
	
					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZXY' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;
	
					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;
	
					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZYX' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;
	
					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;
	
					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YZX' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;
	
					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;
	
					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;
	
				} else if ( euler.order === 'XZY' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;
	
					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;
	
					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;
	
				}
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			makeRotationFromQuaternion: function ( q ) {
	
				var te = this.elements;
	
				var x = q.x, y = q.y, z = q.z, w = q.w;
				var x2 = x + x, y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;
	
				te[ 0 ] = 1 - ( yy + zz );
				te[ 4 ] = xy - wz;
				te[ 8 ] = xz + wy;
	
				te[ 1 ] = xy + wz;
				te[ 5 ] = 1 - ( xx + zz );
				te[ 9 ] = yz - wx;
	
				te[ 2 ] = xz - wy;
				te[ 6 ] = yz + wx;
				te[ 10 ] = 1 - ( xx + yy );
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			lookAt: function () {
	
				var x, y, z;
	
				return function lookAt( eye, target, up ) {
	
					if ( x === undefined ) {
	
						x = new Vector3();
						y = new Vector3();
						z = new Vector3();
	
					}
	
					var te = this.elements;
	
					z.subVectors( eye, target ).normalize();
	
					if ( z.lengthSq() === 0 ) {
	
						z.z = 1;
	
					}
	
					x.crossVectors( up, z ).normalize();
	
					if ( x.lengthSq() === 0 ) {
	
						z.z += 0.0001;
						x.crossVectors( up, z ).normalize();
	
					}
	
					y.crossVectors( z, x );
	
	
					te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
					te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
					te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
					return this;
	
				};
	
			}(),
	
			multiply: function ( m, n ) {
	
				if ( n !== undefined ) {
	
					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );
	
				}
	
				return this.multiplyMatrices( this, m );
	
			},
	
			premultiply: function ( m ) {
	
				return this.multiplyMatrices( m, this );
	
			},
	
			multiplyMatrices: function ( a, b ) {
	
				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;
	
				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
				return this;
	
			},
	
			multiplyToArray: function ( a, b, r ) {
	
				var te = this.elements;
	
				this.multiplyMatrices( a, b );
	
				r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
				r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
				r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
				r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
				return this;
	
			},
	
			applyToBufferAttribute: function () {
	
				var v1;
	
				return function applyToBufferAttribute( attribute ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );
	
						v1.applyMatrix4( this );
	
						attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
					}
	
					return attribute;
	
				};
	
			}(),
	
			determinant: function () {
	
				var te = this.elements;
	
				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)
	
				);
	
			},
	
			transpose: function () {
	
				var te = this.elements;
				var tmp;
	
				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
				return this;
	
			},
	
			setPosition: function ( v ) {
	
				var te = this.elements;
	
				te[ 12 ] = v.x;
				te[ 13 ] = v.y;
				te[ 14 ] = v.z;
	
				return this;
	
			},
	
			getInverse: function ( m, throwOnDegenerate ) {
	
				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
	
					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	
				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
	
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
	
				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
	
				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
	
				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
	
				return this;
	
			},
	
			scale: function ( v ) {
	
				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;
	
				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
				return this;
	
			},
	
			getMaxScaleOnAxis: function () {
	
				var te = this.elements;
	
				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
			},
	
			makeTranslation: function ( x, y, z ) {
	
				this.set(
	
					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationX: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					1, 0,  0, 0,
					0, c, - s, 0,
					0, s,  c, 0,
					0, 0,  0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationY: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationZ: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					c, - s, 0, 0,
					s,  c, 0, 0,
					0,  0, 1, 0,
					0,  0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationAxis: function ( axis, angle ) {
	
				// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;
	
				this.set(
	
					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1
	
				);
	
				 return this;
	
			},
	
			makeScale: function ( x, y, z ) {
	
				this.set(
	
					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeShear: function ( x, y, z ) {
	
				this.set(
	
					1, y, z, 0,
					x, 1, z, 0,
					x, y, 1, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			compose: function ( position, quaternion, scale ) {
	
				this.makeRotationFromQuaternion( quaternion );
				this.scale( scale );
				this.setPosition( position );
	
				return this;
	
			},
	
			decompose: function () {
	
				var vector, matrix;
	
				return function decompose( position, quaternion, scale ) {
	
					if ( vector === undefined ) {
	
						vector = new Vector3();
						matrix = new Matrix4();
	
					}
	
					var te = this.elements;
	
					var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
					var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
					var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
					// if determine is negative, we need to invert one scale
					var det = this.determinant();
					if ( det < 0 ) {
	
						sx = - sx;
	
					}
	
					position.x = te[ 12 ];
					position.y = te[ 13 ];
					position.z = te[ 14 ];
	
					// scale the rotation part
	
					matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
					var invSX = 1 / sx;
					var invSY = 1 / sy;
					var invSZ = 1 / sz;
	
					matrix.elements[ 0 ] *= invSX;
					matrix.elements[ 1 ] *= invSX;
					matrix.elements[ 2 ] *= invSX;
	
					matrix.elements[ 4 ] *= invSY;
					matrix.elements[ 5 ] *= invSY;
					matrix.elements[ 6 ] *= invSY;
	
					matrix.elements[ 8 ] *= invSZ;
					matrix.elements[ 9 ] *= invSZ;
					matrix.elements[ 10 ] *= invSZ;
	
					quaternion.setFromRotationMatrix( matrix );
	
					scale.x = sx;
					scale.y = sy;
					scale.z = sz;
	
					return this;
	
				};
	
			}(),
	
			makePerspective: function ( left, right, top, bottom, near, far ) {
	
				if ( far === undefined ) {
	
					console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
	
				}
	
				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );
	
				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );
	
				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
				return this;
	
			},
	
			makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );
	
				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;
	
				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
				return this;
	
			},
	
			equals: function ( matrix ) {
	
				var te = this.elements;
				var me = matrix.elements;
	
				for ( var i = 0; i < 16; i ++ ) {
	
					if ( te[ i ] !== me[ i ] ) return false;
	
				}
	
				return true;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for( var i = 0; i < 16; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];
	
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
	
				array[ offset + 8 ]  = te[ 8 ];
				array[ offset + 9 ]  = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];
	
				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];
	
				return array;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	
			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.flipY = false;
	
		}
	
		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;
	
		CubeTexture.prototype.isCubeTexture = true;
	
		Object.defineProperty( CubeTexture.prototype, 'images', {
	
			get: function () {
	
				return this.image;
	
			},
	
			set: function ( value ) {
	
				this.image = value;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */
	
		var emptyTexture = new Texture();
		var emptyCubeTexture = new CubeTexture();
	
		// --- Base for inner nodes (including the root) ---
	
		function UniformContainer() {
	
			this.seq = [];
			this.map = {};
	
		}
	
		// --- Utilities ---
	
		// Array Caches (provide typed arrays for temporary by size)
	
		var arrayCacheF32 = [];
		var arrayCacheI32 = [];
	
		// Flattening for arrays of vectors and matrices
	
		function flatten( array, nBlocks, blockSize ) {
	
			var firstElem = array[ 0 ];
	
			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983
	
			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];
	
			if ( r === undefined ) {
	
				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;
	
			}
	
			if ( nBlocks !== 0 ) {
	
				firstElem.toArray( r, 0 );
	
				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
	
					offset += blockSize;
					array[ i ].toArray( r, offset );
	
				}
	
			}
	
			return r;
	
		}
	
		// Texture unit allocation
	
		function allocTexUnits( renderer, n ) {
	
			var r = arrayCacheI32[ n ];
	
			if ( r === undefined ) {
	
				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;
	
			}
	
			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();
	
			return r;
	
		}
	
		// --- Setters ---
	
		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.
	
		// Single scalar
	
		function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
		function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }
	
		// Single float vector (from flat array or THREE.VectorN)
	
		function setValue2fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );
	
		}
	
		function setValue3fv( gl, v ) {
	
			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );
	
		}
	
		function setValue4fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
	
		}
	
		// Single matrix (from flat array or MatrixN)
	
		function setValue2fm( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, v.elements || v );
	
		}
	
		function setValue3fm( gl, v ) {
	
			gl.uniformMatrix3fv( this.addr, false, v.elements || v );
	
		}
	
		function setValue4fm( gl, v ) {
	
			gl.uniformMatrix4fv( this.addr, false, v.elements || v );
	
		}
	
		// Single texture (2D / Cube)
	
		function setValueT1( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );
	
		}
	
		function setValueT6( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );
	
		}
	
		// Integer / Boolean vectors or arrays thereof (always flat arrays)
	
		function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
		function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
		function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }
	
		// Helper to pick the right setter for the singular case
	
		function getSingularSetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4
	
				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4
	
				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// Array of scalars
	
		function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
		function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }
	
		// Array of vectors (flat or from THREE classes)
	
		function setValueV2a( gl, v ) {
	
			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );
	
		}
	
		function setValueV3a( gl, v ) {
	
			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );
	
		}
	
		function setValueV4a( gl, v ) {
	
			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );
	
		}
	
		// Array of matrices (flat or from THREE clases)
	
		function setValueM2a( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );
	
		}
	
		function setValueM3a( gl, v ) {
	
			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );
	
		}
	
		function setValueM4a( gl, v ) {
	
			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );
	
		}
	
		// Array of textures (2D / Cube)
	
		function setValueT1a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
	
			}
	
		}
	
		function setValueT6a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
	
			}
	
		}
	
		// Helper to pick the right setter for a pure (bottom-level) array
	
		function getPureArraySetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4
	
				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4
	
				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// --- Uniform Classes ---
	
		function SingleUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function PureArrayUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function StructuredUniform( id ) {
	
			this.id = id;
	
			UniformContainer.call( this ); // mix-in
	
		}
	
		StructuredUniform.prototype.setValue = function( gl, value ) {
	
			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.
	
			var seq = this.seq;
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );
	
			}
	
		};
	
		// --- Top-level ---
	
		// Parser - builds up the property tree from the path strings
	
		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
	
		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.
	
		function addUniform( container, uniformObject ) {
	
			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;
	
		}
	
		function parseUniform( activeInfo, addr, container ) {
	
			var path = activeInfo.name,
				pathLength = path.length;
	
			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;
	
			for (; ;) {
	
				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,
	
					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];
	
				if ( idIsIndex ) id = id | 0; // convert to integer
	
				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix
	
					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );
	
					break;
	
				} else {
					// step into inner node / create it in case it doesn't exist
	
					var map = container.map,
						next = map[ id ];
	
					if ( next === undefined ) {
	
						next = new StructuredUniform( id );
						addUniform( container, next );
	
					}
	
					container = next;
	
				}
	
			}
	
		}
	
		// Root Container
	
		function WebGLUniforms( gl, program, renderer ) {
	
			UniformContainer.call( this );
	
			this.renderer = renderer;
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
			for ( var i = 0; i < n; ++ i ) {
	
				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );
	
				parseUniform( info, addr, this );
	
			}
	
		}
	
		WebGLUniforms.prototype.setValue = function( gl, name, value ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, value, this.renderer );
	
		};
	
		WebGLUniforms.prototype.set = function( gl, object, name ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );
	
		};
	
		WebGLUniforms.prototype.setOptional = function( gl, object, name ) {
	
			var v = object[ name ];
	
			if ( v !== undefined ) this.setValue( gl, name, v );
	
		};
	
	
		// Static interface
	
		WebGLUniforms.upload = function( gl, seq, values, renderer ) {
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ],
					v = values[ u.id ];
	
				if ( v.needsUpdate !== false ) {
					// note: always updating when .needsUpdate is undefined
	
					u.setValue( gl, v.value, renderer );
	
				}
	
			}
	
		};
	
		WebGLUniforms.seqWithValue = function( seq, values ) {
	
			var r = [];
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				if ( u.id in values ) r.push( u );
	
			}
	
			return r;
	
		};
	
		/**
		 * Uniform Utilities
		 */
	
		var UniformsUtils = {
	
			merge: function ( uniforms ) {
	
				var merged = {};
	
				for ( var u = 0; u < uniforms.length; u ++ ) {
	
					var tmp = this.clone( uniforms[ u ] );
	
					for ( var p in tmp ) {
	
						merged[ p ] = tmp[ p ];
	
					}
	
				}
	
				return merged;
	
			},
	
			clone: function ( uniforms_src ) {
	
				var uniforms_dst = {};
	
				for ( var u in uniforms_src ) {
	
					uniforms_dst[ u ] = {};
	
					for ( var p in uniforms_src[ u ] ) {
	
						var parameter_src = uniforms_src[ u ][ p ];
	
						if ( parameter_src && ( parameter_src.isColor ||
							parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
							parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
							parameter_src.isTexture ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.clone();
	
						} else if ( Array.isArray( parameter_src ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.slice();
	
						} else {
	
							uniforms_dst[ u ][ p ] = parameter_src;
	
						}
	
					}
	
				}
	
				return uniforms_dst;
	
			}
	
		};
	
		var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
	
		var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
	
		var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
	
		var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
	
		var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
	
		var begin_vertex = "\nvec3 transformed = vec3( position );\n";
	
		var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
	
		var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
	
		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
	
		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";
	
		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
	
		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
	
		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
	
		var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
	
		var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
	
		var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	
		var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
	
		var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";
	
		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
	
		var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
	
		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
	
		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
	
		var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
	
		var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
	
		var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
	
		var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
	
		var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
	
		var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
	
		var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
	
		var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
	
		var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
	
		var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
	
		var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
	
		var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
	
		var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
	
		var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
	
		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
	
		var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
	
		var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
	
		var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
	
		var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
	
		var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
	
		var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
	
		var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
	
		var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
	
		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
	
		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";
	
		var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
	
		var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
	
		var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
	
		var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";
	
		var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";
	
		var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
	
		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
	
		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
	
		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
	
		var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";
	
		var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
	
		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
	
		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
	
		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
	
		var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
	
		var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
	
		var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
	
		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
	
		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
	
		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
	
		var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
	
		var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	
		var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
	
		var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";
	
		var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
	
		var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
	
		var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
	
		var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
	
		var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
	
		var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
	
		var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
	
		var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
	
		var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
	
		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";
	
		var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
	
		var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
	
		var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
	
		var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
	
		var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";
	
		var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
	
		var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
	
		var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
	
		var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";
	
		var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_vertex: envmap_vertex,
			fog_vertex: fog_vertex,
			fog_pars_vertex: fog_pars_vertex,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			gradientmap_pars_fragment: gradientmap_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars: lights_pars,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_template: lights_template,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_flip: normal_flip,
			normal_fragment: normal_fragment,
			normalmap_pars_fragment: normalmap_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,
	
			cube_frag: cube_frag,
			cube_vert: cube_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Color( r, g, b ) {
	
			if ( g === undefined && b === undefined ) {
	
				// r is THREE.Color, hex or string
				return this.set( r );
	
			}
	
			return this.setRGB( r, g, b );
	
		}
	
		Color.prototype = {
	
			constructor: Color,
	
			isColor: true,
	
			r: 1, g: 1, b: 1,
	
			set: function ( value ) {
	
				if ( value && value.isColor ) {
	
					this.copy( value );
	
				} else if ( typeof value === 'number' ) {
	
					this.setHex( value );
	
				} else if ( typeof value === 'string' ) {
	
					this.setStyle( value );
	
				}
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.r = scalar;
				this.g = scalar;
				this.b = scalar;
	
				return this;
	
			},
	
			setHex: function ( hex ) {
	
				hex = Math.floor( hex );
	
				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;
	
				return this;
	
			},
	
			setRGB: function ( r, g, b ) {
	
				this.r = r;
				this.g = g;
				this.b = b;
	
				return this;
	
			},
	
			setHSL: function () {
	
				function hue2rgb( p, q, t ) {
	
					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;
	
				}
	
				return function setHSL( h, s, l ) {
	
					// h,s,l ranges are in 0.0 - 1.0
					h = _Math.euclideanModulo( h, 1 );
					s = _Math.clamp( s, 0, 1 );
					l = _Math.clamp( l, 0, 1 );
	
					if ( s === 0 ) {
	
						this.r = this.g = this.b = l;
	
					} else {
	
						var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
						var q = ( 2 * l ) - p;
	
						this.r = hue2rgb( q, p, h + 1 / 3 );
						this.g = hue2rgb( q, p, h );
						this.b = hue2rgb( q, p, h - 1 / 3 );
	
					}
	
					return this;
	
				};
	
			}(),
	
			setStyle: function ( style ) {
	
				function handleAlpha( string ) {
	
					if ( string === undefined ) return;
	
					if ( parseFloat( string ) < 1 ) {
	
						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
					}
	
				}
	
	
				var m;
	
				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
					// rgb / hsl
	
					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];
	
					switch ( name ) {
	
						case 'rgb':
						case 'rgba':
	
							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							break;
	
						case 'hsl':
						case 'hsla':
	
							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this.setHSL( h, s, l );
	
							}
	
							break;
	
					}
	
				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
					// hex color
	
					var hex = m[ 1 ];
					var size = hex.length;
	
					if ( size === 3 ) {
	
						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
						return this;
	
					} else if ( size === 6 ) {
	
						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
						return this;
	
					}
	
				}
	
				if ( style && style.length > 0 ) {
	
					// color keywords
					var hex = ColorKeywords[ style ];
	
					if ( hex !== undefined ) {
	
						// red
						this.setHex( hex );
	
					} else {
	
						// unknown color
						console.warn( 'THREE.Color: Unknown color ' + style );
	
					}
	
				}
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this.r, this.g, this.b );
	
			},
	
			copy: function ( color ) {
	
				this.r = color.r;
				this.g = color.g;
				this.b = color.b;
	
				return this;
	
			},
	
			copyGammaToLinear: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );
	
				return this;
	
			},
	
			copyLinearToGamma: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );
	
				return this;
	
			},
	
			convertGammaToLinear: function () {
	
				var r = this.r, g = this.g, b = this.b;
	
				this.r = r * r;
				this.g = g * g;
				this.b = b * b;
	
				return this;
	
			},
	
			convertLinearToGamma: function () {
	
				this.r = Math.sqrt( this.r );
				this.g = Math.sqrt( this.g );
				this.b = Math.sqrt( this.b );
	
				return this;
	
			},
	
			getHex: function () {
	
				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
			},
	
			getHexString: function () {
	
				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
			},
	
			getHSL: function ( optionalTarget ) {
	
				// h,s,l ranges are in 0.0 - 1.0
	
				var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
				var r = this.r, g = this.g, b = this.b;
	
				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );
	
				var hue, saturation;
				var lightness = ( min + max ) / 2.0;
	
				if ( min === max ) {
	
					hue = 0;
					saturation = 0;
	
				} else {
	
					var delta = max - min;
	
					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
					switch ( max ) {
	
						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;
	
					}
	
					hue /= 6;
	
				}
	
				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;
	
				return hsl;
	
			},
	
			getStyle: function () {
	
				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
			},
	
			offsetHSL: function ( h, s, l ) {
	
				var hsl = this.getHSL();
	
				hsl.h += h; hsl.s += s; hsl.l += l;
	
				this.setHSL( hsl.h, hsl.s, hsl.l );
	
				return this;
	
			},
	
			add: function ( color ) {
	
				this.r += color.r;
				this.g += color.g;
				this.b += color.b;
	
				return this;
	
			},
	
			addColors: function ( color1, color2 ) {
	
				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.r += s;
				this.g += s;
				this.b += s;
	
				return this;
	
			},
	
			sub: function( color ) {
	
				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );
	
				return this;
	
			},
	
			multiply: function ( color ) {
	
				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				this.r *= s;
				this.g *= s;
				this.b *= s;
	
				return this;
	
			},
	
			lerp: function ( color, alpha ) {
	
				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;
	
				return this;
	
			},
	
			equals: function ( c ) {
	
				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;
	
				return array;
	
			},
	
			toJSON: function () {
	
				return this.getHex();
	
			}
	
		};
	
		var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { data: data, width: width, height: height };
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.generateMipmaps  = false;
			this.flipY = false;
			this.unpackAlignment = 1;
	
		}
	
		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;
	
		DataTexture.prototype.isDataTexture = true;
	
		/**
		 * Uniforms library for shared webgl shaders
		 */
	
		var UniformsLib = {
	
			common: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
	
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },
	
				specularMap: { value: null },
				alphaMap: { value: null },
	
				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 }
	
			},
	
			aomap: {
	
				aoMap: { value: null },
				aoMapIntensity: { value: 1 }
	
			},
	
			lightmap: {
	
				lightMap: { value: null },
				lightMapIntensity: { value: 1 }
	
			},
	
			emissivemap: {
	
				emissiveMap: { value: null }
	
			},
	
			bumpmap: {
	
				bumpMap: { value: null },
				bumpScale: { value: 1 }
	
			},
	
			normalmap: {
	
				normalMap: { value: null },
				normalScale: { value: new Vector2( 1, 1 ) }
	
			},
	
			displacementmap: {
	
				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 }
	
			},
	
			roughnessmap: {
	
				roughnessMap: { value: null }
	
			},
	
			metalnessmap: {
	
				metalnessMap: { value: null }
	
			},
	
			gradientmap: {
	
				gradientMap: { value: null }
	
			},
	
			fog: {
	
				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }
	
			},
	
			lights: {
	
				ambientLightColor: { value: [] },
	
				directionalLights: { value: [], properties: {
					direction: {},
					color: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },
	
				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },
	
				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },
	
				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} },
	
				// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
				rectAreaLights: { value: [], properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				} }
	
			},
	
			points: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */
	
		var ShaderLib = {
	
			basic: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.fog
				] ),
	
				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag
	
			},
	
			lambert: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) }
					}
				] ),
	
				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag
	
			},
	
			phong: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.gradientmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						specular: { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}
				] ),
	
				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag
	
			},
	
			standard: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity: { value: 1 } // temporary
					}
				] ),
	
				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag
	
			},
	
			points: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.points,
					UniformsLib.fog
				] ),
	
				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag
	
			},
	
			dashed: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.fog,
					{
						scale: { value: 1 },
						dashSize: { value: 1 },
						totalSize: { value: 2 }
					}
				] ),
	
				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag
	
			},
	
			depth: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.displacementmap
				] ),
	
				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag
	
			},
	
			normal: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					{
						opacity: { value: 1.0 }
					}
				] ),
	
				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			cube: {
	
				uniforms: {
					tCube: { value: null },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 }
				},
	
				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			equirect: {
	
				uniforms: {
					tEquirect: { value: null },
					tFlip: { value: - 1 }
				},
	
				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag
	
			},
	
			distanceRGBA: {
	
				uniforms: {
					lightPos: { value: new Vector3() }
				},
	
				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag
	
			}
	
		};
	
		ShaderLib.physical = {
	
			uniforms: UniformsUtils.merge( [
				ShaderLib.standard.uniforms,
				{
					clearCoat: { value: 0 },
					clearCoatRoughness: { value: 0 }
				}
			] ),
	
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Box2( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
	
		}
	
		Box2.prototype = {
	
			constructor: Box2,
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector2();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			containsPoint: function ( point ) {
	
				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ? false : true;
	
			},
	
			containsBox: function ( box ) {
	
				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector2();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector2();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlarePlugin( renderer, flares ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var shader, program, attributes, uniforms;
	
			var tempTexture, occlusionTexture;
	
			function init() {
	
				var vertices = new Float32Array( [
					- 1, - 1,  0, 0,
					 1, - 1,  1, 0,
					 1,  1,  1, 1,
					- 1,  1,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				// buffers
	
				vertexBuffer     = gl.createBuffer();
				elementBuffer    = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				// textures
	
				tempTexture      = gl.createTexture();
				occlusionTexture = gl.createTexture();
	
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
				program = createProgram( shader );
	
				attributes = {
					vertex: gl.getAttribLocation ( program, "position" ),
					uv:     gl.getAttribLocation ( program, "uv" )
				};
	
				uniforms = {
					renderType:     gl.getUniformLocation( program, "renderType" ),
					map:            gl.getUniformLocation( program, "map" ),
					occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
					opacity:        gl.getUniformLocation( program, "opacity" ),
					color:          gl.getUniformLocation( program, "color" ),
					scale:          gl.getUniformLocation( program, "scale" ),
					rotation:       gl.getUniformLocation( program, "rotation" ),
					screenPosition: gl.getUniformLocation( program, "screenPosition" )
				};
	
			}
	
			/*
			 * Render lens flares
			 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
			 *         reads these back and calculates occlusion.
			 */
	
			this.render = function ( scene, camera, viewport ) {
	
				if ( flares.length === 0 ) return;
	
				var tempPosition = new Vector3();
	
				var invAspect = viewport.w / viewport.z,
					halfViewportWidth = viewport.z * 0.5,
					halfViewportHeight = viewport.w * 0.5;
	
				var size = 16 / viewport.w,
					scale = new Vector2( size * invAspect, size );
	
				var screenPosition = new Vector3( 1, 1, 0 ),
					screenPositionPixels = new Vector2( 1, 1 );
	
				var validArea = new Box2();
	
				validArea.min.set( viewport.x, viewport.y );
				validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.vertex );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				// loop through all lens flares to update their occlusion and positions
				// setup gl and common used attribs/uniforms
	
				gl.uniform1i( uniforms.occlusionMap, 0 );
				gl.uniform1i( uniforms.map, 1 );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				state.disable( gl.CULL_FACE );
				state.setDepthWrite( false );
	
				for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
					size = 16 / viewport.w;
					scale.set( size * invAspect, size );
	
					// calc object screen position
	
					var flare = flares[ i ];
	
					tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
					tempPosition.applyMatrix4( camera.matrixWorldInverse );
					tempPosition.applyMatrix4( camera.projectionMatrix );
	
					// setup arrays for gl programs
	
					screenPosition.copy( tempPosition );
	
					// horizontal and vertical coordinate of the lower left corner of the pixels to copy
	
					screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
					screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;
	
					// screen cull
	
					if ( validArea.containsPoint( screenPositionPixels ) === true ) {
	
						// save current RGB to temp texture
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, null );
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// render pink quad
	
						gl.uniform1i( uniforms.renderType, 0 );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
						state.disable( gl.BLEND );
						state.enable( gl.DEPTH_TEST );
	
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// copy result to occlusionMap
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// restore graphics
	
						gl.uniform1i( uniforms.renderType, 1 );
						state.disable( gl.DEPTH_TEST );
	
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// update object positions
	
						flare.positionScreen.copy( screenPosition );
	
						if ( flare.customUpdateCallback ) {
	
							flare.customUpdateCallback( flare );
	
						} else {
	
							flare.updateLensFlares();
	
						}
	
						// render flares
	
						gl.uniform1i( uniforms.renderType, 2 );
						state.enable( gl.BLEND );
	
						for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
							var sprite = flare.lensFlares[ j ];
	
							if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
								screenPosition.x = sprite.x;
								screenPosition.y = sprite.y;
								screenPosition.z = sprite.z;
	
								size = sprite.size * sprite.scale / viewport.w;
	
								scale.x = size * invAspect;
								scale.y = size;
	
								gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
								gl.uniform2f( uniforms.scale, scale.x, scale.y );
								gl.uniform1f( uniforms.rotation, sprite.rotation );
	
								gl.uniform1f( uniforms.opacity, sprite.opacity );
								gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
								state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
								renderer.setTexture2D( sprite.texture, 1 );
	
								gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
							}
	
						}
	
					}
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
				state.enable( gl.DEPTH_TEST );
				state.setDepthWrite( true );
	
				renderer.resetGLState();
	
			};
	
			function createProgram( shader ) {
	
				var program = gl.createProgram();
	
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
				var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
				gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
				gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
				gl.compileShader( fragmentShader );
				gl.compileShader( vertexShader );
	
				gl.attachShader( program, fragmentShader );
				gl.attachShader( program, vertexShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
		}
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpritePlugin( renderer, sprites ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var program, attributes, uniforms;
	
			var texture;
	
			// decompose matrixWorld
	
			var spritePosition = new Vector3();
			var spriteRotation = new Quaternion();
			var spriteScale = new Vector3();
	
			function init() {
	
				var vertices = new Float32Array( [
					- 0.5, - 0.5,  0, 0,
					  0.5, - 0.5,  1, 0,
					  0.5,   0.5,  1, 1,
					- 0.5,   0.5,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				vertexBuffer  = gl.createBuffer();
				elementBuffer = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				program = createProgram();
	
				attributes = {
					position:			gl.getAttribLocation ( program, 'position' ),
					uv:					gl.getAttribLocation ( program, 'uv' )
				};
	
				uniforms = {
					uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
					uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
					rotation:			gl.getUniformLocation( program, 'rotation' ),
					scale:				gl.getUniformLocation( program, 'scale' ),
	
					color:				gl.getUniformLocation( program, 'color' ),
					map:				gl.getUniformLocation( program, 'map' ),
					opacity:			gl.getUniformLocation( program, 'opacity' ),
	
					modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
					projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
					fogType:			gl.getUniformLocation( program, 'fogType' ),
					fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
					fogNear:			gl.getUniformLocation( program, 'fogNear' ),
					fogFar:				gl.getUniformLocation( program, 'fogFar' ),
					fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
					alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
				};
	
				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = 8;
				canvas.height = 8;
	
				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 0, 8, 8 );
	
				texture = new Texture( canvas );
				texture.needsUpdate = true;
	
			}
	
			this.render = function ( scene, camera ) {
	
				if ( sprites.length === 0 ) return;
	
				// setup gl
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.position );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				state.disable( gl.CULL_FACE );
				state.enable( gl.BLEND );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				state.activeTexture( gl.TEXTURE0 );
				gl.uniform1i( uniforms.map, 0 );
	
				var oldFogType = 0;
				var sceneFogType = 0;
				var fog = scene.fog;
	
				if ( fog ) {
	
					gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
					if ( fog.isFog ) {
	
						gl.uniform1f( uniforms.fogNear, fog.near );
						gl.uniform1f( uniforms.fogFar, fog.far );
	
						gl.uniform1i( uniforms.fogType, 1 );
						oldFogType = 1;
						sceneFogType = 1;
	
					} else if ( fog.isFogExp2 ) {
	
						gl.uniform1f( uniforms.fogDensity, fog.density );
	
						gl.uniform1i( uniforms.fogType, 2 );
						oldFogType = 2;
						sceneFogType = 2;
	
					}
	
				} else {
	
					gl.uniform1i( uniforms.fogType, 0 );
					oldFogType = 0;
					sceneFogType = 0;
	
				}
	
	
				// update positions and sort
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
	
					sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
				}
	
				sprites.sort( painterSortStable );
	
				// render all sprites
	
				var scale = [];
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
					var material = sprite.material;
	
					if ( material.visible === false ) continue;
	
					gl.uniform1f( uniforms.alphaTest, material.alphaTest );
					gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
					sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
					scale[ 0 ] = spriteScale.x;
					scale[ 1 ] = spriteScale.y;
	
					var fogType = 0;
	
					if ( scene.fog && material.fog ) {
	
						fogType = sceneFogType;
	
					}
	
					if ( oldFogType !== fogType ) {
	
						gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;
	
					}
	
					if ( material.map !== null ) {
	
						gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
						gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
					} else {
	
						gl.uniform2f( uniforms.uvOffset, 0, 0 );
						gl.uniform2f( uniforms.uvScale, 1, 1 );
	
					}
	
					gl.uniform1f( uniforms.opacity, material.opacity );
					gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
					gl.uniform1f( uniforms.rotation, material.rotation );
					gl.uniform2fv( uniforms.scale, scale );
	
					state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
					state.setDepthTest( material.depthTest );
					state.setDepthWrite( material.depthWrite );
	
					if ( material.map ) {
	
						renderer.setTexture2D( material.map, 0 );
	
					} else {
	
						renderer.setTexture2D( texture, 0 );
	
					}
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
	
				renderer.resetGLState();
	
			};
	
			function createProgram() {
	
				var program = gl.createProgram();
	
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
				gl.shaderSource( vertexShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform float rotation;',
					'uniform vec2 scale;',
					'uniform vec2 uvOffset;',
					'uniform vec2 uvScale;',
	
					'attribute vec2 position;',
					'attribute vec2 uv;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vUV = uvOffset + uv * uvScale;',
	
						'vec2 alignedPosition = position * scale;',
	
						'vec2 rotatedPosition;',
						'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
						'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
						'vec4 finalPosition;',
	
						'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
						'finalPosition.xy += rotatedPosition;',
						'finalPosition = projectionMatrix * finalPosition;',
	
						'gl_Position = finalPosition;',
	
					'}'
	
				].join( '\n' ) );
	
				gl.shaderSource( fragmentShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'uniform vec3 color;',
					'uniform sampler2D map;',
					'uniform float opacity;',
	
					'uniform int fogType;',
					'uniform vec3 fogColor;',
					'uniform float fogDensity;',
					'uniform float fogNear;',
					'uniform float fogFar;',
					'uniform float alphaTest;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vec4 texture = texture2D( map, vUV );',
	
						'if ( texture.a < alphaTest ) discard;',
	
						'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
						'if ( fogType > 0 ) {',
	
							'float depth = gl_FragCoord.z / gl_FragCoord.w;',
							'float fogFactor = 0.0;',
	
							'if ( fogType == 1 ) {',
	
								'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
							'} else {',
	
								'const float LOG2 = 1.442695;',
								'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
								'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
							'}',
	
							'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
						'}',
	
					'}'
	
				].join( '\n' ) );
	
				gl.compileShader( vertexShader );
				gl.compileShader( fragmentShader );
	
				gl.attachShader( program, vertexShader );
				gl.attachShader( program, fragmentShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
			function painterSortStable( a, b ) {
	
				if ( a.renderOrder !== b.renderOrder ) {
	
					return a.renderOrder - b.renderOrder;
	
				} else if ( a.z !== b.z ) {
	
					return b.z - a.z;
	
				} else {
	
					return b.id - a.id;
	
				}
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		var materialId = 0;
	
		function Material() {
	
			Object.defineProperty( this, 'id', { value: materialId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Material';
	
			this.fog = true;
			this.lights = true;
	
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
			this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
	
			this.opacity = 1;
			this.transparent = false;
	
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
	
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
	
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
	
			this.colorWrite = true;
	
			this.precision = null; // override the renderer's default precision for this material
	
			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
	
			this.alphaTest = 0;
			this.premultipliedAlpha = false;
	
			this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
			this.visible = true;
	
			this._needsUpdate = true;
	
		}
	
		Material.prototype = {
	
			constructor: Material,
	
			isMaterial: true,
	
			get needsUpdate() {
	
				return this._needsUpdate;
	
			},
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.update();
				this._needsUpdate = value;
	
			},
	
			setValues: function ( values ) {
	
				if ( values === undefined ) return;
	
				for ( var key in values ) {
	
					var newValue = values[ key ];
	
					if ( newValue === undefined ) {
	
						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;
	
					}
	
					var currentValue = this[ key ];
	
					if ( currentValue === undefined ) {
	
						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;
	
					}
	
					if ( currentValue && currentValue.isColor ) {
	
						currentValue.set( newValue );
	
					} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {
	
						currentValue.copy( newValue );
	
					} else if ( key === 'overdraw' ) {
	
						// ensure overdraw is backwards-compatible with legacy boolean type
						this[ key ] = Number( newValue );
	
					} else {
	
						this[ key ] = newValue;
	
					}
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				var isRoot = meta === undefined;
	
				if ( isRoot ) {
	
					meta = {
						textures: {},
						images: {}
					};
	
				}
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};
	
				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;
	
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.color && this.color.isColor ) data.color = this.color.getHex();
	
				if ( this.roughness !== undefined ) data.roughness = this.roughness;
				if ( this.metalness !== undefined ) data.metalness = this.metalness;
	
				if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
				if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
				if ( this.shininess !== undefined ) data.shininess = this.shininess;
				if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
				if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;
	
				if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
				if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
				if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
				if ( this.bumpMap && this.bumpMap.isTexture ) {
	
					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;
	
				}
				if ( this.normalMap && this.normalMap.isTexture ) {
	
					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalScale = this.normalScale.toArray();
	
				}
				if ( this.displacementMap && this.displacementMap.isTexture ) {
	
					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;
	
				}
				if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
				if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
				if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
				if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
				if ( this.envMap && this.envMap.isTexture ) {
	
					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap
	
				}
	
				if ( this.gradientMap && this.gradientMap.isTexture ) {
	
					data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
	
				}
	
				if ( this.size !== undefined ) data.size = this.size;
				if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
				if ( this.blending !== NormalBlending ) data.blending = this.blending;
				if ( this.shading !== SmoothShading ) data.shading = this.shading;
				if ( this.side !== FrontSide ) data.side = this.side;
				if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;
	
				if ( this.opacity < 1 ) data.opacity = this.opacity;
				if ( this.transparent === true ) data.transparent = this.transparent;
	
				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;
	
				if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
				if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
				if ( this.wireframe === true ) data.wireframe = this.wireframe;
				if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
				if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
				if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
	
				data.skinning = this.skinning;
				data.morphTargets = this.morphTargets;
	
				// TODO: Copied from Object3D.toJSON
	
				function extractFromCache( cache ) {
	
					var values = [];
	
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
	
					return values;
	
				}
	
				if ( isRoot ) {
	
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( textures.length > 0 ) data.textures = textures;
					if ( images.length > 0 ) data.images = images;
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.name = source.name;
	
				this.fog = source.fog;
				this.lights = source.lights;
	
				this.blending = source.blending;
				this.side = source.side;
				this.shading = source.shading;
				this.vertexColors = source.vertexColors;
	
				this.opacity = source.opacity;
				this.transparent = source.transparent;
	
				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;
	
				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;
	
				this.colorWrite = source.colorWrite;
	
				this.precision = source.precision;
	
				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;
	
				this.alphaTest = source.alphaTest;
	
				this.premultipliedAlpha = source.premultipliedAlpha;
	
				this.overdraw = source.overdraw;
	
				this.visible = source.visible;
				this.clipShadows = source.clipShadows;
				this.clipIntersection = source.clipIntersection;
	
				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;
	
				if ( srcPlanes !== null ) {
	
					var n = srcPlanes.length;
					dstPlanes = new Array( n );
	
					for ( var i = 0; i !== n; ++ i )
						dstPlanes[ i ] = srcPlanes[ i ].clone();
	
				}
	
				this.clippingPlanes = dstPlanes;
	
				return this;
	
			},
	
			update: function () {
	
				this.dispatchEvent( { type: 'update' } );
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		Object.assign( Material.prototype, EventDispatcher.prototype );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function ShaderMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'ShaderMaterial';
	
			this.defines = {};
			this.uniforms = {};
	
			this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
			this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
			this.linewidth = 1;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes
	
			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals
	
			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};
	
			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};
	
			this.index0AttributeName = undefined;
	
			if ( parameters !== undefined ) {
	
				if ( parameters.attributes !== undefined ) {
	
					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
				}
	
				this.setValues( parameters );
	
			}
	
		}
	
		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;
	
		ShaderMaterial.prototype.isShaderMaterial = true;
	
		ShaderMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
	
			this.uniforms = UniformsUtils.clone( source.uniforms );
	
			this.defines = source.defines;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			this.lights = source.lights;
			this.clipping = source.clipping;
	
			this.skinning = source.skinning;
	
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			this.extensions = source.extensions;
	
			return this;
	
		};
	
		ShaderMaterial.prototype.toJSON = function ( meta ) {
	
			var data = Material.prototype.toJSON.call( this, meta );
	
			data.uniforms = this.uniforms;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
	
			return data;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */
	
		function MeshDepthMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshDepthMaterial';
	
			this.depthPacking = BasicDepthPacking;
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.map = null;
	
			this.alphaMap = null;
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
	
		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
	
		MeshDepthMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.depthPacking = source.depthPacking;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			this.map = source.map;
	
			this.alphaMap = source.alphaMap;
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			return this;
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Box3( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
	
		}
	
		Box3.prototype = {
	
			constructor: Box3,
	
			isBox3: true,
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromArray: function ( array ) {
	
				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;
	
				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];
	
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;
	
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;
	
				}
	
				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );
	
				return this;
	
			},
	
			setFromBufferAttribute: function ( attribute ) {
	
				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;
	
				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;
	
				for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
					var x = attribute.getX( i );
					var y = attribute.getY( i );
					var z = attribute.getZ( i );
	
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;
	
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;
	
				}
	
				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );
	
				return this;
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector3();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			setFromObject: function ( object ) {
	
				this.makeEmpty();
	
				return this.expandByObject( object );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			expandByObject: function () {
	
				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms
	
				var v1 = new Vector3();
	
				return function expandByObject( object ) {
	
					var scope = this;
	
					object.updateMatrixWorld( true );
	
					object.traverse( function ( node ) {
	
						var i, l;
	
						var geometry = node.geometry;
	
						if ( geometry !== undefined ) {
	
							if ( geometry.isGeometry ) {
	
								var vertices = geometry.vertices;
	
								for ( i = 0, l = vertices.length; i < l; i ++ ) {
	
									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );
	
									scope.expandByPoint( v1 );
	
								}
	
							} else if ( geometry.isBufferGeometry ) {
	
								var attribute = geometry.attributes.position;
	
								if ( attribute !== undefined ) {
	
									for ( i = 0, l = attribute.count; i < l; i ++ ) {
	
										v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
	
										scope.expandByPoint( v1 );
	
									}
	
								}
	
							}
	
						}
	
					} );
	
					return this;
	
				};
	
			}(),
	
			containsPoint: function ( point ) {
	
				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ||
					point.z < this.min.z || point.z > this.max.z ? false : true;
	
			},
	
			containsBox: function ( box ) {
	
				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y &&
					this.min.z <= box.min.z && box.max.z <= this.max.z;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector3();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ||
					box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	
			},
	
			intersectsSphere: ( function () {
	
				var closestPoint;
	
				return function intersectsSphere( sphere ) {
	
					if ( closestPoint === undefined ) closestPoint = new Vector3();
	
					// Find the point on the AABB closest to the sphere center.
					this.clampPoint( sphere.center, closestPoint );
	
					// If that point is inside the sphere, the AABB and sphere intersect.
					return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
				};
	
			} )(),
	
			intersectsPlane: function ( plane ) {
	
				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.
	
				var min, max;
	
				if ( plane.normal.x > 0 ) {
	
					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;
	
				} else {
	
					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;
	
				}
	
				if ( plane.normal.y > 0 ) {
	
					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;
	
				} else {
	
					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;
	
				}
	
				if ( plane.normal.z > 0 ) {
	
					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;
	
				} else {
	
					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;
	
				}
	
				return ( min <= plane.constant && max >= plane.constant );
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			getBoundingSphere: function () {
	
				var v1 = new Vector3();
	
				return function getBoundingSphere( optionalTarget ) {
	
					var result = optionalTarget || new Sphere();
	
					this.getCenter( result.center );
	
					result.radius = this.getSize( v1 ).length() * 0.5;
	
					return result;
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if( this.isEmpty() ) this.makeEmpty();
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			applyMatrix4: function () {
	
				var points = [
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3()
				];
	
				return function applyMatrix4( matrix ) {
	
					// transform of empty box is an empty box.
					if( this.isEmpty() ) return this;
	
					// NOTE: I am using a binary pattern to specify all 2^3 combinations below
					points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
					points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
					points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
					points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
					points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
					points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
					points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
					points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111
	
					this.setFromPoints( points );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Sphere( center, radius ) {
	
			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;
	
		}
	
		Sphere.prototype = {
	
			constructor: Sphere,
	
			set: function ( center, radius ) {
	
				this.center.copy( center );
				this.radius = radius;
	
				return this;
	
			},
	
			setFromPoints: function () {
	
				var box;
	
				return function setFromPoints( points, optionalCenter ) {
	
					if ( box === undefined ) box = new Box3(); // see #10547
	
					var center = this.center;
	
					if ( optionalCenter !== undefined ) {
	
						center.copy( optionalCenter );
	
					} else {
	
						box.setFromPoints( points ).getCenter( center );
	
					}
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = points.length; i < il; i ++ ) {
	
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
					}
	
					this.radius = Math.sqrt( maxRadiusSq );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( sphere ) {
	
				this.center.copy( sphere.center );
				this.radius = sphere.radius;
	
				return this;
	
			},
	
			empty: function () {
	
				return ( this.radius <= 0 );
	
			},
	
			containsPoint: function ( point ) {
	
				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return ( point.distanceTo( this.center ) - this.radius );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				var radiusSum = this.radius + sphere.radius;
	
				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsSphere( this );
	
			},
	
			intersectsPlane: function ( plane ) {
	
				// We use the following equation to compute the signed distance from
				// the center of the sphere to the plane.
				//
				// distance = q * n - d
				//
				// If this distance is greater than the radius of the sphere,
				// then there is no intersection.
	
				return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var deltaLengthSq = this.center.distanceToSquared( point );
	
				var result = optionalTarget || new Vector3();
	
				result.copy( point );
	
				if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
					result.sub( this.center ).normalize();
					result.multiplyScalar( this.radius ).add( this.center );
	
				}
	
				return result;
	
			},
	
			getBoundingBox: function ( optionalTarget ) {
	
				var box = optionalTarget || new Box3();
	
				box.set( this.center, this.center );
				box.expandByScalar( this.radius );
	
				return box;
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.center.add( offset );
	
				return this;
	
			},
	
			equals: function ( sphere ) {
	
				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */
	
		function Matrix3() {
	
			this.elements = new Float32Array( [
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			] );
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Matrix3.prototype = {
	
			constructor: Matrix3,
	
			isMatrix3: true,
	
			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0,
					0, 1, 0,
					0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				var me = m.elements;
	
				this.set(
	
					me[ 0 ], me[ 3 ], me[ 6 ],
					me[ 1 ], me[ 4 ], me[ 7 ],
					me[ 2 ], me[ 5 ], me[ 8 ]
	
				);
	
				return this;
	
			},
	
			setFromMatrix4: function( m ) {
	
				var me = m.elements;
	
				this.set(
	
					me[ 0 ], me[ 4 ], me[  8 ],
					me[ 1 ], me[ 5 ], me[  9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]
	
				);
	
				return this;
	
			},
	
			applyToBufferAttribute: function () {
	
				var v1;
	
				return function applyToBufferAttribute( attribute ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );
	
						v1.applyMatrix3( this );
	
						attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
					}
	
					return attribute;
	
				};
	
			}(),
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
				return this;
	
			},
	
			determinant: function () {
	
				var te = this.elements;
	
				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
			},
	
			getInverse: function ( matrix, throwOnDegenerate ) {
	
				if ( matrix && matrix.isMatrix4 ) {
	
					console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );
	
				}
	
				var me = matrix.elements,
					te = this.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
	
					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,
	
					det = n11 * t11 + n21 * t12 + n31 * t13;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
	
				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
	
				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
	
				return this;
	
			},
	
			transpose: function () {
	
				var tmp, m = this.elements;
	
				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
				return this;
	
			},
	
			getNormalMatrix: function ( matrix4 ) {
	
				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	
			},
	
			transposeIntoArray: function ( r ) {
	
				var m = this.elements;
	
				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];
	
				return this;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for( var i = 0; i < 9; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
	
				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
	
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ]  = te[ 8 ];
	
				return array;
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Plane( normal, constant ) {
	
			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;
	
		}
	
		Plane.prototype = {
	
			constructor: Plane,
	
			set: function ( normal, constant ) {
	
				this.normal.copy( normal );
				this.constant = constant;
	
				return this;
	
			},
	
			setComponents: function ( x, y, z, w ) {
	
				this.normal.set( x, y, z );
				this.constant = w;
	
				return this;
	
			},
	
			setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
				return this;
	
			},
	
			setFromCoplanarPoints: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function setFromCoplanarPoints( a, b, c ) {
	
					var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
					// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
					this.setFromNormalAndCoplanarPoint( normal, a );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( plane ) {
	
				this.normal.copy( plane.normal );
				this.constant = plane.constant;
	
				return this;
	
			},
	
			normalize: function () {
	
				// Note: will lead to a divide by zero if the plane is invalid.
	
				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;
	
				return this;
	
			},
	
			negate: function () {
	
				this.constant *= - 1;
				this.normal.negate();
	
				return this;
	
			},
	
			distanceToPoint: function ( point ) {
	
				return this.normal.dot( point ) + this.constant;
	
			},
	
			distanceToSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) - sphere.radius;
	
			},
	
			projectPoint: function ( point, optionalTarget ) {
	
				return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
			},
	
			orthoPoint: function ( point, optionalTarget ) {
	
				var perpendicularMagnitude = this.distanceToPoint( point );
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
			},
	
			intersectLine: function () {
	
				var v1 = new Vector3();
	
				return function intersectLine( line, optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					var direction = line.delta( v1 );
	
					var denominator = this.normal.dot( direction );
	
					if ( denominator === 0 ) {
	
						// line is coplanar, return origin
						if ( this.distanceToPoint( line.start ) === 0 ) {
	
							return result.copy( line.start );
	
						}
	
						// Unsure if this is the correct method to handle this case.
						return undefined;
	
					}
	
					var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
					if ( t < 0 || t > 1 ) {
	
						return undefined;
	
					}
	
					return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
				};
	
			}(),
	
			intersectsLine: function ( line ) {
	
				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );
	
				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsPlane( this );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				return sphere.intersectsPlane( this );
	
			},
	
			coplanarPoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( - this.constant );
	
			},
	
			applyMatrix4: function () {
	
				var v1 = new Vector3();
				var m1 = new Matrix3();
	
				return function applyMatrix4( matrix, optionalNormalMatrix ) {
	
					var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
	
					// transform normal based on theory here:
					// http://www.songho.ca/opengl/gl_normaltransform.html
					var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
					var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
	
					// recalculate constant (like in setFromNormalAndCoplanarPoint)
					this.constant = - referencePoint.dot( normal );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.constant = this.constant - offset.dot( this.normal );
	
				return this;
	
			},
	
			equals: function ( plane ) {
	
				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */
	
		function Frustum( p0, p1, p2, p3, p4, p5 ) {
	
			this.planes = [
	
				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()
	
			];
	
		}
	
		Frustum.prototype = {
	
			constructor: Frustum,
	
			set: function ( p0, p1, p2, p3, p4, p5 ) {
	
				var planes = this.planes;
	
				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( frustum ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					planes[ i ].copy( frustum.planes[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromMatrix: function ( m ) {
	
				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
				return this;
	
			},
	
			intersectsObject: function () {
	
				var sphere = new Sphere();
	
				return function intersectsObject( object ) {
	
					var geometry = object.geometry;
	
					if ( geometry.boundingSphere === null )
						geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere )
						.applyMatrix4( object.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSprite: function () {
	
				var sphere = new Sphere();
	
				return function intersectsSprite( sprite ) {
	
					sphere.center.set( 0, 0, 0 );
					sphere.radius = 0.7071067811865476;
					sphere.applyMatrix4( sprite.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					var distance = planes[ i ].distanceToPoint( center );
	
					if ( distance < negRadius ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			},
	
			intersectsBox: function () {
	
				var p1 = new Vector3(),
					p2 = new Vector3();
	
				return function intersectsBox( box ) {
	
					var planes = this.planes;
	
					for ( var i = 0; i < 6 ; i ++ ) {
	
						var plane = planes[ i ];
	
						p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
						p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
						p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
						p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
						p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
						p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
						var d1 = plane.distanceToPoint( p1 );
						var d2 = plane.distanceToPoint( p2 );
	
						// if both outside plane, no intersection
	
						if ( d1 < 0 && d2 < 0 ) {
	
							return false;
	
						}
	
					}
	
					return true;
	
				};
	
			}(),
	
	
			containsPoint: function ( point ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {
	
			var _gl = _renderer.context,
			_state = _renderer.state,
			_frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),
	
			_lightShadows = _lights.shadows,
	
			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),
	
			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),
	
			_renderList = [],
	
			_MorphingFlag = 1,
			_SkinningFlag = 2,
	
			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),
	
			_materialCache = {};
	
			var cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];
	
			var cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];
	
			var cube2DViewPorts = [
				new Vector4(), new Vector4(), new Vector4(),
				new Vector4(), new Vector4(), new Vector4()
			];
	
			// init
	
			var depthMaterialTemplate = new MeshDepthMaterial();
			depthMaterialTemplate.depthPacking = RGBADepthPacking;
			depthMaterialTemplate.clipping = true;
	
			var distanceShader = ShaderLib[ "distanceRGBA" ];
			var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );
	
			for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
				var useMorphing = ( i & _MorphingFlag ) !== 0;
				var useSkinning = ( i & _SkinningFlag ) !== 0;
	
				var depthMaterial = depthMaterialTemplate.clone();
				depthMaterial.morphTargets = useMorphing;
				depthMaterial.skinning = useSkinning;
	
				_depthMaterials[ i ] = depthMaterial;
	
				var distanceMaterial = new ShaderMaterial( {
					defines: {
						'USE_SHADOWMAP': ''
					},
					uniforms: distanceUniforms,
					vertexShader: distanceShader.vertexShader,
					fragmentShader: distanceShader.fragmentShader,
					morphTargets: useMorphing,
					skinning: useSkinning,
					clipping: true
				} );
	
				_distanceMaterials[ i ] = distanceMaterial;
	
			}
	
			//
	
			var scope = this;
	
			this.enabled = false;
	
			this.autoUpdate = true;
			this.needsUpdate = false;
	
			this.type = PCFShadowMap;
	
			this.renderReverseSided = true;
			this.renderSingleSided = true;
	
			this.render = function ( scene, camera ) {
	
				if ( scope.enabled === false ) return;
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
				if ( _lightShadows.length === 0 ) return;
	
				// Set GL state for depth map.
				_state.buffers.color.setClear( 1, 1, 1, 1 );
				_state.disable( _gl.BLEND );
				_state.setDepthTest( true );
				_state.setScissorTest( false );
	
				// render depth map
	
				var faceCount, isPointLight;
	
				for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {
	
					var light = _lightShadows[ i ];
					var shadow = light.shadow;
	
					if ( shadow === undefined ) {
	
						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;
	
					}
	
					var shadowCamera = shadow.camera;
	
					_shadowMapSize.copy( shadow.mapSize );
					_shadowMapSize.min( _maxShadowMapSize );
	
					if ( light && light.isPointLight ) {
	
						faceCount = 6;
						isPointLight = true;
	
						var vpWidth = _shadowMapSize.x;
						var vpHeight = _shadowMapSize.y;
	
						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction
	
						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
						_shadowMapSize.x *= 4.0;
						_shadowMapSize.y *= 2.0;
	
					} else {
	
						faceCount = 1;
						isPointLight = false;
	
					}
	
					if ( shadow.map === null ) {
	
						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
	
						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
	
						shadowCamera.updateProjectionMatrix();
	
					}
	
					if ( shadow.isSpotLightShadow ) {
	
						shadow.update( light );
	
					}
	
					// TODO (abelnation / sam-g-steel): is this needed?
					if (shadow && shadow.isRectAreaLightShadow ) {
	
						shadow.update( light );
	
					}
	
					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;
	
					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );
	
					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();
	
					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not
	
					for ( var face = 0; face < faceCount; face ++ ) {
	
						if ( isPointLight ) {
	
							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );
	
							var vpDimensions = cube2DViewPorts[ face ];
							_state.viewport( vpDimensions );
	
						} else {
	
							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );
	
						}
	
						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
						// compute shadow matrix
	
						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);
	
						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
						// update camera matrices and frustum
	
						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );
	
						// set object matrices & frustum culling
	
						_renderList.length = 0;
	
						projectObject( scene, camera, shadowCamera );
	
						// render shadow map
						// render regular objects
	
						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;
	
							if ( material && material.isMultiMaterial ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
									}
	
								}
	
							} else {
	
								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
							}
	
						}
	
					}
	
				}
	
				// Restore GL state.
				var clearColor = _renderer.getClearColor(),
				clearAlpha = _renderer.getClearAlpha();
				_renderer.setClearColor( clearColor, clearAlpha );
	
				scope.needsUpdate = false;
	
			};
	
			function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
				var geometry = object.geometry;
	
				var result = null;
	
				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;
	
				if ( isPointLight ) {
	
					materialVariants = _distanceMaterials;
					customMaterial = object.customDistanceMaterial;
	
				}
	
				if ( ! customMaterial ) {
	
					var useMorphing = false;
	
					if ( material.morphTargets ) {
	
						if ( geometry && geometry.isBufferGeometry ) {
	
							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	
						} else if ( geometry && geometry.isGeometry ) {
	
							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	
						}
	
					}
	
					var useSkinning = object.isSkinnedMesh && material.skinning;
	
					var variantIndex = 0;
	
					if ( useMorphing ) variantIndex |= _MorphingFlag;
					if ( useSkinning ) variantIndex |= _SkinningFlag;
	
					result = materialVariants[ variantIndex ];
	
				} else {
	
					result = customMaterial;
	
				}
	
				if ( _renderer.localClippingEnabled &&
					 material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {
	
					// in this case we need a unique material instance reflecting the
					// appropriate state
	
					var keyA = result.uuid, keyB = material.uuid;
	
					var materialsForVariant = _materialCache[ keyA ];
	
					if ( materialsForVariant === undefined ) {
	
						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;
	
					}
	
					var cachedMaterial = materialsForVariant[ keyB ];
	
					if ( cachedMaterial === undefined ) {
	
						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;
	
					}
	
					result = cachedMaterial;
	
				}
	
				result.visible = material.visible;
				result.wireframe = material.wireframe;
	
				var side = material.side;
	
				if ( scope.renderSingleSided && side == DoubleSide ) {
	
					side = FrontSide;
	
				}
	
				if ( scope.renderReverseSided ) {
	
					if ( side === FrontSide ) side = BackSide;
					else if ( side === BackSide ) side = FrontSide;
	
				}
	
				result.side = side;
	
				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;
	
				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;
	
				if ( isPointLight && result.uniforms.lightPos !== undefined ) {
	
					result.uniforms.lightPos.value.copy( lightPositionWorld );
	
				}
	
				return result;
	
			}
	
			function projectObject( object, camera, shadowCamera ) {
	
				if ( object.visible === false ) return;
	
				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;
	
				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
	
					if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
						var material = object.material;
	
						if ( material.visible === true ) {
	
							object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
							_renderList.push( object );
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					projectObject( children[ i ], camera, shadowCamera );
	
				}
	
			}
	
		}
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Ray( origin, direction ) {
	
			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3();
	
		}
	
		Ray.prototype = {
	
			constructor: Ray,
	
			set: function ( origin, direction ) {
	
				this.origin.copy( origin );
				this.direction.copy( direction );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( ray ) {
	
				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );
	
				return this;
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
			},
	
			lookAt: function ( v ) {
	
				this.direction.copy( v ).sub( this.origin ).normalize();
	
				return this;
	
			},
	
			recast: function () {
	
				var v1 = new Vector3();
	
				return function recast( t ) {
	
					this.origin.copy( this.at( t, v1 ) );
	
					return this;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				result.subVectors( point, this.origin );
				var directionDistance = result.dot( this.direction );
	
				if ( directionDistance < 0 ) {
	
					return result.copy( this.origin );
	
				}
	
				return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return Math.sqrt( this.distanceSqToPoint( point ) );
	
			},
	
			distanceSqToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceSqToPoint( point ) {
	
					var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
					// point behind the ray
	
					if ( directionDistance < 0 ) {
	
						return this.origin.distanceToSquared( point );
	
					}
	
					v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
					return v1.distanceToSquared( point );
	
				};
	
			}(),
	
			distanceSqToSegment: function () {
	
				var segCenter = new Vector3();
				var segDir = new Vector3();
				var diff = new Vector3();
	
				return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
					// It returns the min distance between the ray and the segment
					// defined by v0 and v1
					// It can also set two optional targets :
					// - The closest point on the ray
					// - The closest point on the segment
	
					segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
					segDir.copy( v1 ).sub( v0 ).normalize();
					diff.copy( this.origin ).sub( segCenter );
	
					var segExtent = v0.distanceTo( v1 ) * 0.5;
					var a01 = - this.direction.dot( segDir );
					var b0 = diff.dot( this.direction );
					var b1 = - diff.dot( segDir );
					var c = diff.lengthSq();
					var det = Math.abs( 1 - a01 * a01 );
					var s0, s1, sqrDist, extDet;
	
					if ( det > 0 ) {
	
						// The ray and segment are not parallel.
	
						s0 = a01 * b1 - b0;
						s1 = a01 * b0 - b1;
						extDet = segExtent * det;
	
						if ( s0 >= 0 ) {
	
							if ( s1 >= - extDet ) {
	
								if ( s1 <= extDet ) {
	
									// region 0
									// Minimum at interior points of ray and segment.
	
									var invDet = 1 / det;
									s0 *= invDet;
									s1 *= invDet;
									sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
								} else {
	
									// region 1
	
									s1 = segExtent;
									s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
									sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
								}
	
							} else {
	
								// region 5
	
								s1 = - segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							if ( s1 <= - extDet ) {
	
								// region 4
	
								s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							} else if ( s1 <= extDet ) {
	
								// region 3
	
								s0 = 0;
								s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 2
	
								s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						}
	
					} else {
	
						// Ray and segment are parallel.
	
						s1 = ( a01 > 0 ) ? - segExtent : segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
					}
	
					if ( optionalPointOnRay ) {
	
						optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
					}
	
					if ( optionalPointOnSegment ) {
	
						optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
					}
	
					return sqrDist;
	
				};
	
			}(),
	
			intersectSphere: function () {
	
				var v1 = new Vector3();
	
				return function intersectSphere( sphere, optionalTarget ) {
	
					v1.subVectors( sphere.center, this.origin );
					var tca = v1.dot( this.direction );
					var d2 = v1.dot( v1 ) - tca * tca;
					var radius2 = sphere.radius * sphere.radius;
	
					if ( d2 > radius2 ) return null;
	
					var thc = Math.sqrt( radius2 - d2 );
	
					// t0 = first intersect point - entrance on front of sphere
					var t0 = tca - thc;
	
					// t1 = second intersect point - exit point on back of sphere
					var t1 = tca + thc;
	
					// test to see if both t0 and t1 are behind the ray - if so, return null
					if ( t0 < 0 && t1 < 0 ) return null;
	
					// test to see if t0 is behind the ray:
					// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
					// in order to always return an intersect point that is in front of the ray.
					if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
					// else t0 is in front of the ray, so return the first collision point scaled by t0
					return this.at( t0, optionalTarget );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
			},
	
			distanceToPlane: function ( plane ) {
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
						return 0;
	
					}
	
					// Null is preferable to undefined since undefined means.... it is undefined
	
					return null;
	
				}
	
				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
				// Return if the ray never intersects the plane
	
				return t >= 0 ? t :  null;
	
			},
	
			intersectPlane: function ( plane, optionalTarget ) {
	
				var t = this.distanceToPlane( plane );
	
				if ( t === null ) {
	
					return null;
	
				}
	
				return this.at( t, optionalTarget );
	
			},
	
	
	
			intersectsPlane: function ( plane ) {
	
				// check if the ray lies on the plane first
	
				var distToPoint = plane.distanceToPoint( this.origin );
	
				if ( distToPoint === 0 ) {
	
					return true;
	
				}
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator * distToPoint < 0 ) {
	
					return true;
	
				}
	
				// ray origin is behind the plane (and is pointing behind it)
	
				return false;
	
			},
	
			intersectBox: function ( box, optionalTarget ) {
	
				var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;
	
				var origin = this.origin;
	
				if ( invdirx >= 0 ) {
	
					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;
	
				} else {
	
					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;
	
				}
	
				if ( invdiry >= 0 ) {
	
					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;
	
				} else {
	
					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;
	
				}
	
				if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN
	
				if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
				if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
				if ( invdirz >= 0 ) {
	
					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;
	
				} else {
	
					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;
	
				}
	
				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
				if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
				if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
				//return point closest to the ray (positive side)
	
				if ( tmax < 0 ) return null;
	
				return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
			},
	
			intersectsBox: ( function () {
	
				var v = new Vector3();
	
				return function intersectsBox( box ) {
	
					return this.intersectBox( box, v ) !== null;
	
				};
	
			} )(),
	
			intersectTriangle: function () {
	
				// Compute the offset origin, edges, and normal.
				var diff = new Vector3();
				var edge1 = new Vector3();
				var edge2 = new Vector3();
				var normal = new Vector3();
	
				return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	
					edge1.subVectors( b, a );
					edge2.subVectors( c, a );
					normal.crossVectors( edge1, edge2 );
	
					// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
					// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
					//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
					//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
					//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
					var DdN = this.direction.dot( normal );
					var sign;
	
					if ( DdN > 0 ) {
	
						if ( backfaceCulling ) return null;
						sign = 1;
	
					} else if ( DdN < 0 ) {
	
						sign = - 1;
						DdN = - DdN;
	
					} else {
	
						return null;
	
					}
	
					diff.subVectors( this.origin, a );
					var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
					// b1 < 0, no intersection
					if ( DdQxE2 < 0 ) {
	
						return null;
	
					}
	
					var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
					// b2 < 0, no intersection
					if ( DdE1xQ < 0 ) {
	
						return null;
	
					}
	
					// b1+b2 > 1, no intersection
					if ( DdQxE2 + DdE1xQ > DdN ) {
	
						return null;
	
					}
	
					// Line intersects triangle, check if ray does.
					var QdN = - sign * diff.dot( normal );
	
					// t < 0, no intersection
					if ( QdN < 0 ) {
	
						return null;
	
					}
	
					// Ray intersects triangle.
					return this.at( QdN / DdN, optionalTarget );
	
				};
	
			}(),
	
			applyMatrix4: function ( matrix4 ) {
	
				this.direction.add( this.origin ).applyMatrix4( matrix4 );
				this.origin.applyMatrix4( matrix4 );
				this.direction.sub( this.origin );
				this.direction.normalize();
	
				return this;
	
			},
	
			equals: function ( ray ) {
	
				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Euler( x, y, z, order ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;
	
		}
	
		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
		Euler.DefaultOrder = 'XYZ';
	
		Euler.prototype = {
	
			constructor: Euler,
	
			isEuler: true,
	
			get x () {
	
				return this._x;
	
			},
	
			set x ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			},
	
			get y () {
	
				return this._y;
	
			},
	
			set y ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			},
	
			get z () {
	
				return this._z;
	
			},
	
			set z ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			},
	
			get order () {
	
				return this._order;
	
			},
	
			set order ( value ) {
	
				this._order = value;
				this.onChangeCallback();
	
			},
	
			set: function ( x, y, z, order ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._order );
	
			},
	
			copy: function ( euler ) {
	
				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m, order, update ) {
	
				var clamp = _Math.clamp;
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				order = order || this._order;
	
				if ( order === 'XYZ' ) {
	
					this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
					if ( Math.abs( m13 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );
	
					} else {
	
						this._x = Math.atan2( m32, m22 );
						this._z = 0;
	
					}
	
				} else if ( order === 'YXZ' ) {
	
					this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
					if ( Math.abs( m23 ) < 0.99999 ) {
	
						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );
	
					} else {
	
						this._y = Math.atan2( - m31, m11 );
						this._z = 0;
	
					}
	
				} else if ( order === 'ZXY' ) {
	
					this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
					if ( Math.abs( m32 ) < 0.99999 ) {
	
						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );
	
					} else {
	
						this._y = 0;
						this._z = Math.atan2( m21, m11 );
	
					}
	
				} else if ( order === 'ZYX' ) {
	
					this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
					if ( Math.abs( m31 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );
	
					} else {
	
						this._x = 0;
						this._z = Math.atan2( - m12, m22 );
	
					}
	
				} else if ( order === 'YZX' ) {
	
					this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
					if ( Math.abs( m21 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );
	
					} else {
	
						this._x = 0;
						this._y = Math.atan2( m13, m33 );
	
					}
	
				} else if ( order === 'XZY' ) {
	
					this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
					if ( Math.abs( m12 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );
	
					} else {
	
						this._x = Math.atan2( - m23, m33 );
						this._y = 0;
	
					}
	
				} else {
	
					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
	
				}
	
				this._order = order;
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromQuaternion: function () {
	
				var matrix;
	
				return function setFromQuaternion( q, order, update ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.makeRotationFromQuaternion( q );
	
					return this.setFromRotationMatrix( matrix, order, update );
	
				};
	
			}(),
	
			setFromVector3: function ( v, order ) {
	
				return this.set( v.x, v.y, v.z, order || this._order );
	
			},
	
			reorder: function () {
	
				// WARNING: this discards revolution information -bhouston
	
				var q = new Quaternion();
	
				return function reorder( newOrder ) {
	
					q.setFromEuler( this );
	
					return this.setFromQuaternion( q, newOrder );
	
				};
	
			}(),
	
			equals: function ( euler ) {
	
				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
			},
	
			fromArray: function ( array ) {
	
				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;
	
				return array;
	
			},
	
			toVector3: function ( optionalResult ) {
	
				if ( optionalResult ) {
	
					return optionalResult.set( this._x, this._y, this._z );
	
				} else {
	
					return new Vector3( this._x, this._y, this._z );
	
				}
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Layers() {
	
			this.mask = 1;
	
		}
	
		Layers.prototype = {
	
			constructor: Layers,
	
			set: function ( channel ) {
	
				this.mask = 1 << channel;
	
			},
	
			enable: function ( channel ) {
	
				this.mask |= 1 << channel;
	
			},
	
			toggle: function ( channel ) {
	
				this.mask ^= 1 << channel;
	
			},
	
			disable: function ( channel ) {
	
				this.mask &= ~ ( 1 << channel );
	
			},
	
			test: function ( layers ) {
	
				return ( this.mask & layers.mask ) !== 0;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */
	
		var object3DId = 0;
	
		function Object3D() {
	
			Object.defineProperty( this, 'id', { value: object3DId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Object3D';
	
			this.parent = null;
			this.children = [];
	
			this.up = Object3D.DefaultUp.clone();
	
			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );
	
			function onRotationChange() {
	
				quaternion.setFromEuler( rotation, false );
	
			}
	
			function onQuaternionChange() {
	
				rotation.setFromQuaternion( quaternion, undefined, false );
	
			}
	
			rotation.onChange( onRotationChange );
			quaternion.onChange( onQuaternionChange );
	
			Object.defineProperties( this, {
				position: {
					enumerable: true,
					value: position
				},
				rotation: {
					enumerable: true,
					value: rotation
				},
				quaternion: {
					enumerable: true,
					value: quaternion
				},
				scale: {
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );
	
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
	
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
	
			this.layers = new Layers();
			this.visible = true;
	
			this.castShadow = false;
			this.receiveShadow = false;
	
			this.frustumCulled = true;
			this.renderOrder = 0;
	
			this.userData = {};
	
			this.onBeforeRender = function () {};
			this.onAfterRender = function () {};
	
		}
	
		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;
	
		Object3D.prototype = {
	
			constructor: Object3D,
	
			isObject3D: true,
	
			applyMatrix: function ( matrix ) {
	
				this.matrix.multiplyMatrices( matrix, this.matrix );
	
				this.matrix.decompose( this.position, this.quaternion, this.scale );
	
			},
	
			setRotationFromAxisAngle: function ( axis, angle ) {
	
				// assumes axis is normalized
	
				this.quaternion.setFromAxisAngle( axis, angle );
	
			},
	
			setRotationFromEuler: function ( euler ) {
	
				this.quaternion.setFromEuler( euler, true );
	
			},
	
			setRotationFromMatrix: function ( m ) {
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				this.quaternion.setFromRotationMatrix( m );
	
			},
	
			setRotationFromQuaternion: function ( q ) {
	
				// assumes q is normalized
	
				this.quaternion.copy( q );
	
			},
	
			rotateOnAxis: function () {
	
				// rotate object on axis in object space
				// axis is assumed to be normalized
	
				var q1 = new Quaternion();
	
				return function rotateOnAxis( axis, angle ) {
	
					q1.setFromAxisAngle( axis, angle );
	
					this.quaternion.multiply( q1 );
	
					return this;
	
				};
	
			}(),
	
			rotateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function rotateX( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function rotateY( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function rotateZ( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			translateOnAxis: function () {
	
				// translate object by distance along axis in object space
				// axis is assumed to be normalized
	
				var v1 = new Vector3();
	
				return function translateOnAxis( axis, distance ) {
	
					v1.copy( axis ).applyQuaternion( this.quaternion );
	
					this.position.add( v1.multiplyScalar( distance ) );
	
					return this;
	
				};
	
			}(),
	
			translateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function translateX( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function translateY( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function translateZ( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			localToWorld: function ( vector ) {
	
				return vector.applyMatrix4( this.matrixWorld );
	
			},
	
			worldToLocal: function () {
	
				var m1 = new Matrix4();
	
				return function worldToLocal( vector ) {
	
					return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
				};
	
			}(),
	
			lookAt: function () {
	
				// This routine does not support objects with rotated and/or translated parent(s)
	
				var m1 = new Matrix4();
	
				return function lookAt( vector ) {
	
					m1.lookAt( vector, this.position, this.up );
	
					this.quaternion.setFromRotationMatrix( m1 );
	
				};
	
			}(),
	
			add: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.add( arguments[ i ] );
	
					}
	
					return this;
	
				}
	
				if ( object === this ) {
	
					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;
	
				}
	
				if ( ( object && object.isObject3D ) ) {
	
					if ( object.parent !== null ) {
	
						object.parent.remove( object );
	
					}
	
					object.parent = this;
					object.dispatchEvent( { type: 'added' } );
	
					this.children.push( object );
	
				} else {
	
					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
				}
	
				return this;
	
			},
	
			remove: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.remove( arguments[ i ] );
	
					}
	
				}
	
				var index = this.children.indexOf( object );
	
				if ( index !== - 1 ) {
	
					object.parent = null;
	
					object.dispatchEvent( { type: 'removed' } );
	
					this.children.splice( index, 1 );
	
				}
	
			},
	
			getObjectById: function ( id ) {
	
				return this.getObjectByProperty( 'id', id );
	
			},
	
			getObjectByName: function ( name ) {
	
				return this.getObjectByProperty( 'name', name );
	
			},
	
			getObjectByProperty: function ( name, value ) {
	
				if ( this[ name ] === value ) return this;
	
				for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );
	
					if ( object !== undefined ) {
	
						return object;
	
					}
	
				}
	
				return undefined;
	
			},
	
			getWorldPosition: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				this.updateMatrixWorld( true );
	
				return result.setFromMatrixPosition( this.matrixWorld );
	
			},
	
			getWorldQuaternion: function () {
	
				var position = new Vector3();
				var scale = new Vector3();
	
				return function getWorldQuaternion( optionalTarget ) {
	
					var result = optionalTarget || new Quaternion();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, result, scale );
	
					return result;
	
				};
	
			}(),
	
			getWorldRotation: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldRotation( optionalTarget ) {
	
					var result = optionalTarget || new Euler();
	
					this.getWorldQuaternion( quaternion );
	
					return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
				};
	
			}(),
	
			getWorldScale: function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
	
				return function getWorldScale( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, quaternion, result );
	
					return result;
	
				};
	
			}(),
	
			getWorldDirection: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldDirection( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.getWorldQuaternion( quaternion );
	
					return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
				};
	
			}(),
	
			raycast: function () {},
	
			traverse: function ( callback ) {
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverse( callback );
	
				}
	
			},
	
			traverseVisible: function ( callback ) {
	
				if ( this.visible === false ) return;
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverseVisible( callback );
	
				}
	
			},
	
			traverseAncestors: function ( callback ) {
	
				var parent = this.parent;
	
				if ( parent !== null ) {
	
					callback( parent );
	
					parent.traverseAncestors( callback );
	
				}
	
			},
	
			updateMatrix: function () {
	
				this.matrix.compose( this.position, this.quaternion, this.scale );
	
				this.matrixWorldNeedsUpdate = true;
	
			},
	
			updateMatrixWorld: function ( force ) {
	
				if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
				if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
					if ( this.parent === null ) {
	
						this.matrixWorld.copy( this.matrix );
	
					} else {
	
						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
					}
	
					this.matrixWorldNeedsUpdate = false;
	
					force = true;
	
				}
	
				// update children
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].updateMatrixWorld( force );
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				// meta is '' when called from JSON.stringify
				var isRootObject = ( meta === undefined || meta === '' );
	
				var output = {};
	
				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {
	
					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {}
					};
	
					output.metadata = {
						version: 4.4,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};
	
				}
	
				// standard Object3D serialization
	
				var object = {};
	
				object.uuid = this.uuid;
				object.type = this.type;
	
				if ( this.name !== '' ) object.name = this.name;
				if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
				if ( this.castShadow === true ) object.castShadow = true;
				if ( this.receiveShadow === true ) object.receiveShadow = true;
				if ( this.visible === false ) object.visible = false;
	
				object.matrix = this.matrix.toArray();
	
				//
	
				if ( this.geometry !== undefined ) {
	
					if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
	
						meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
	
					}
	
					object.geometry = this.geometry.uuid;
	
				}
	
				if ( this.material !== undefined ) {
	
					if ( meta.materials[ this.material.uuid ] === undefined ) {
	
						meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
	
					}
	
					object.material = this.material.uuid;
	
				}
	
				//
	
				if ( this.children.length > 0 ) {
	
					object.children = [];
	
					for ( var i = 0; i < this.children.length; i ++ ) {
	
						object.children.push( this.children[ i ].toJSON( meta ).object );
	
					}
	
				}
	
				if ( isRootObject ) {
	
					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( geometries.length > 0 ) output.geometries = geometries;
					if ( materials.length > 0 ) output.materials = materials;
					if ( textures.length > 0 ) output.textures = textures;
					if ( images.length > 0 ) output.images = images;
	
				}
	
				output.object = object;
	
				return output;
	
				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {
	
					var values = [];
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
					return values;
	
				}
	
			},
	
			clone: function ( recursive ) {
	
				return new this.constructor().copy( this, recursive );
	
			},
	
			copy: function ( source, recursive ) {
	
				if ( recursive === undefined ) recursive = true;
	
				this.name = source.name;
	
				this.up.copy( source.up );
	
				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );
	
				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );
	
				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
				this.layers.mask = source.layers.mask;
				this.visible = source.visible;
	
				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;
	
				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;
	
				this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
				if ( recursive === true ) {
	
					for ( var i = 0; i < source.children.length; i ++ ) {
	
						var child = source.children[ i ];
						this.add( child.clone() );
	
					}
	
				}
	
				return this;
	
			}
	
		};
	
		Object.assign( Object3D.prototype, EventDispatcher.prototype );
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Line3( start, end ) {
	
			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();
	
		}
	
		Line3.prototype = {
	
			constructor: Line3,
	
			set: function ( start, end ) {
	
				this.start.copy( start );
				this.end.copy( end );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( line ) {
	
				this.start.copy( line.start );
				this.end.copy( line.end );
	
				return this;
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
			},
	
			delta: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.subVectors( this.end, this.start );
	
			},
	
			distanceSq: function () {
	
				return this.start.distanceToSquared( this.end );
	
			},
	
			distance: function () {
	
				return this.start.distanceTo( this.end );
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			closestPointToPointParameter: function () {
	
				var startP = new Vector3();
				var startEnd = new Vector3();
	
				return function closestPointToPointParameter( point, clampToLine ) {
	
					startP.subVectors( point, this.start );
					startEnd.subVectors( this.end, this.start );
	
					var startEnd2 = startEnd.dot( startEnd );
					var startEnd_startP = startEnd.dot( startP );
	
					var t = startEnd_startP / startEnd2;
	
					if ( clampToLine ) {
	
						t = _Math.clamp( t, 0, 1 );
	
					}
	
					return t;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
				var t = this.closestPointToPointParameter( point, clampToLine );
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );
	
				return this;
	
			},
	
			equals: function ( line ) {
	
				return line.start.equals( this.start ) && line.end.equals( this.end );
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Triangle( a, b, c ) {
	
			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();
	
		}
	
		Triangle.normal = function () {
	
			var v0 = new Vector3();
	
			return function normal( a, b, c, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );
	
				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {
	
					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
				}
	
				return result.set( 0, 0, 0 );
	
			};
	
		}();
	
		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		Triangle.barycoordFromPoint = function () {
	
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();
	
			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {
	
				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );
	
				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );
	
				var denom = ( dot00 * dot11 - dot01 * dot01 );
	
				var result = optionalTarget || new Vector3();
	
				// collinear or singular triangle
				if ( denom === 0 ) {
	
					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );
	
				}
	
				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );
	
			};
	
		}();
	
		Triangle.containsPoint = function () {
	
			var v1 = new Vector3();
	
			return function containsPoint( point, a, b, c ) {
	
				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
			};
	
		}();
	
		Triangle.prototype = {
	
			constructor: Triangle,
	
			set: function ( a, b, c ) {
	
				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );
	
				return this;
	
			},
	
			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( triangle ) {
	
				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );
	
				return this;
	
			},
	
			area: function () {
	
				var v0 = new Vector3();
				var v1 = new Vector3();
	
				return function area() {
	
					v0.subVectors( this.c, this.b );
					v1.subVectors( this.a, this.b );
	
					return v0.cross( v1 ).length() * 0.5;
	
				};
	
			}(),
	
			midpoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
			},
	
			normal: function ( optionalTarget ) {
	
				return Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
			},
	
			plane: function ( optionalTarget ) {
	
				var result = optionalTarget || new Plane();
	
				return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
			},
	
			barycoordFromPoint: function ( point, optionalTarget ) {
	
				return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
			},
	
			containsPoint: function ( point ) {
	
				return Triangle.containsPoint( point, this.a, this.b, this.c );
	
			},
	
			closestPointToPoint: function () {
	
				var plane, edgeList, projectedPoint, closestPoint;
	
				return function closestPointToPoint( point, optionalTarget ) {
	
					if ( plane === undefined ) {
	
						plane = new Plane();
						edgeList = [ new Line3(), new Line3(), new Line3() ];
						projectedPoint = new Vector3();
						closestPoint = new Vector3();
	
					}
	
					var result = optionalTarget || new Vector3();
					var minDistance = Infinity;
	
					// project the point onto the plane of the triangle
	
					plane.setFromCoplanarPoints( this.a, this.b, this.c );
					plane.projectPoint( point, projectedPoint );
	
					// check if the projection lies within the triangle
	
					if( this.containsPoint( projectedPoint ) === true ) {
	
						// if so, this is the closest point
	
						result.copy( projectedPoint );
	
					} else {
	
						// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
	
						edgeList[ 0 ].set( this.a, this.b );
						edgeList[ 1 ].set( this.b, this.c );
						edgeList[ 2 ].set( this.c, this.a );
	
						for( var i = 0; i < edgeList.length; i ++ ) {
	
							edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );
	
							var distance = projectedPoint.distanceToSquared( closestPoint );
	
							if( distance < minDistance ) {
	
								minDistance = distance;
	
								result.copy( closestPoint );
	
							}
	
						}
	
					}
	
					return result;
	
				};
	
			}(),
	
			equals: function ( triangle ) {
	
				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Face3( a, b, c, normal, color, materialIndex ) {
	
			this.a = a;
			this.b = b;
			this.c = c;
	
			this.normal = (normal && normal.isVector3) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
			this.color = (color && color.isColor) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];
	
			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
		}
	
		Face3.prototype = {
	
			constructor: Face3,
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.a = source.a;
				this.b = source.b;
				this.c = source.c;
	
				this.normal.copy( source.normal );
				this.color.copy( source.color );
	
				this.materialIndex = source.materialIndex;
	
				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
				}
	
				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
					this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
				}
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */
	
		function MeshBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshBasicMaterial';
	
			this.color = new Color( 0xffffff ); // emissive
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
	
		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
	
		MeshBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferAttribute( array, itemSize, normalized ) {
	
			if ( Array.isArray( array ) ) {
	
				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
			}
	
			this.uuid = _Math.generateUUID();
	
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.onUploadCallback = function () {};
	
			this.version = 0;
	
		}
	
		BufferAttribute.prototype = {
	
			constructor: BufferAttribute,
	
			isBufferAttribute: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.itemSize : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;
	
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.itemSize;
				index2 *= attribute.itemSize;
	
				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			copyArray: function ( array ) {
	
				this.array.set( array );
	
				return this;
	
			},
	
			copyColorsArray: function ( colors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
					var color = colors[ i ];
	
					if ( color === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();
	
					}
	
					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;
	
				}
	
				return this;
	
			},
	
			copyIndicesArray: function ( indices ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					var index = indices[ i ];
	
					array[ offset ++ ] = index.a;
					array[ offset ++ ] = index.b;
					array[ offset ++ ] = index.c;
	
				}
	
				return this;
	
			},
	
			copyVector2sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
	
				}
	
				return this;
	
			},
	
			copyVector3sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
	
				}
	
				return this;
	
			},
	
			copyVector4sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.array[ index * this.itemSize ];
	
			},
	
			setX: function ( index, x ) {
	
				this.array[ index * this.itemSize ] = x;
	
				return this;
	
			},
	
			getY: function ( index ) {
	
				return this.array[ index * this.itemSize + 1 ];
	
			},
	
			setY: function ( index, y ) {
	
				this.array[ index * this.itemSize + 1 ] = y;
	
				return this;
	
			},
	
			getZ: function ( index ) {
	
				return this.array[ index * this.itemSize + 2 ];
	
			},
	
			setZ: function ( index, z ) {
	
				this.array[ index * this.itemSize + 2 ] = z;
	
				return this;
	
			},
	
			getW: function ( index ) {
	
				return this.array[ index * this.itemSize + 3 ];
	
			},
	
			setW: function ( index, w ) {
	
				this.array[ index * this.itemSize + 3 ] = w;
	
				return this;
	
			},
	
			setXY: function ( index, x, y ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;
	
				return this;
	
			},
	
			onUpload: function ( callback ) {
	
				this.onUploadCallback = callback;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this.array, this.itemSize ).copy( this );
	
			}
	
		};
	
		//
	
		function Int8BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int8Array( array ), itemSize );
	
		}
	
		Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
	
	
		function Uint8BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint8Array( array ), itemSize );
	
		}
	
		Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
	
	
		function Uint8ClampedBufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );
	
		}
	
		Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
	
	
		function Int16BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int16Array( array ), itemSize );
	
		}
	
		Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
	
	
		function Uint16BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint16Array( array ), itemSize );
	
		}
	
		Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
	
	
		function Int32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int32Array( array ), itemSize );
	
		}
	
		Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
	
	
		function Uint32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint32Array( array ), itemSize );
	
		}
	
		Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
	
	
		function Float32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Float32Array( array ), itemSize );
	
		}
	
		Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
	
	
		function Float64BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Float64Array( array ), itemSize );
	
		}
	
		Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectGeometry() {
	
			this.indices = [];
			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];
	
			this.groups = [];
	
			this.morphTargets = {};
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			// this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Object.assign( DirectGeometry.prototype, {
	
			computeGroups: function ( geometry ) {
	
				var group;
				var groups = [];
				var materialIndex = undefined;
	
				var faces = geometry.faces;
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					// materials
	
					if ( face.materialIndex !== materialIndex ) {
	
						materialIndex = face.materialIndex;
	
						if ( group !== undefined ) {
	
							group.count = ( i * 3 ) - group.start;
							groups.push( group );
	
						}
	
						group = {
							start: i * 3,
							materialIndex: materialIndex
						};
	
					}
	
				}
	
				if ( group !== undefined ) {
	
					group.count = ( i * 3 ) - group.start;
					groups.push( group );
	
				}
	
				this.groups = groups;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;
	
				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
				// morphs
	
				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;
	
				var morphTargetsPosition;
	
				if ( morphTargetsLength > 0 ) {
	
					morphTargetsPosition = [];
	
					for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
						morphTargetsPosition[ i ] = [];
	
					}
	
					this.morphTargets.position = morphTargetsPosition;
	
				}
	
				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;
	
				var morphTargetsNormal;
	
				if ( morphNormalsLength > 0 ) {
	
					morphTargetsNormal = [];
	
					for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
						morphTargetsNormal[ i ] = [];
	
					}
	
					this.morphTargets.normal = morphTargetsNormal;
	
				}
	
				// skins
	
				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;
	
				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;
	
				//
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
					} else {
	
						var normal = face.normal;
	
						this.normals.push( normal, normal, normal );
	
					}
	
					var vertexColors = face.vertexColors;
	
					if ( vertexColors.length === 3 ) {
	
						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
					} else {
	
						var color = face.color;
	
						this.colors.push( color, color, color );
	
					}
	
					if ( hasFaceVertexUv === true ) {
	
						var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					if ( hasFaceVertexUv2 === true ) {
	
						var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					// morphs
	
					for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
						var morphTarget = morphTargets[ j ].vertices;
	
						morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
					}
	
					for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
						var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
						morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
					}
	
					// skins
	
					if ( hasSkinIndices ) {
	
						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
					}
	
					if ( hasSkinWeights ) {
	
						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
					}
	
				}
	
				this.computeGroups( geometry );
	
				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				return this;
	
			}
	
		} );
	
		// http://stackoverflow.com/questions/1669190/javascript-min-max-array-values/13440842#13440842
	
		function arrayMax( array ) {
	
			var length = array.length, max = - Infinity;
	
			while ( length -- ) {
	
				if ( array[ length ] > max ) {
	
					max = array[ length ];
	
				}
	
			}
	
			return max;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */
	
		var count = 0;
		function GeometryIdCount() { return count++; }
	
		function Geometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Geometry';
	
			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
	
			this.morphTargets = [];
			this.morphNormals = [];
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Geometry.prototype = {
	
			constructor: Geometry,
	
			isGeometry: true,
	
			applyMatrix: function ( matrix ) {
	
				var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );
	
				}
	
				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
					}
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1;
	
				return function rotateX( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1;
	
				return function rotateY( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1;
	
				return function rotateZ( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1;
	
				return function translate( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1;
	
				return function scale( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj;
	
				return function lookAt( vector ) {
	
					if ( obj === undefined ) obj = new Object3D();
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			fromBufferGeometry: function ( geometry ) {
	
				var scope = this;
	
				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;
	
				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
				if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
				var tempNormals = [];
				var tempUVs = [];
				var tempUVs2 = [];
	
				for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
					scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
	
					if ( normals !== undefined ) {
	
						tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
					}
	
					if ( colors !== undefined ) {
	
						scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
					}
	
					if ( uvs !== undefined ) {
	
						tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
					}
	
				}
	
				function addFace( a, b, c, materialIndex ) {
	
					var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
					var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
	
					scope.faces.push( face );
	
					if ( uvs !== undefined ) {
	
						scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
					}
	
				}
	
				if ( indices !== undefined ) {
	
					var groups = geometry.groups;
	
					if ( groups.length > 0 ) {
	
						for ( var i = 0; i < groups.length; i ++ ) {
	
							var group = groups[ i ];
	
							var start = group.start;
							var count = group.count;
	
							for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );
	
							}
	
						}
	
					} else {
	
						for ( var i = 0; i < indices.length; i += 3 ) {
	
							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
						addFace( i, i + 1, i + 2 );
	
					}
	
				}
	
				this.computeFaceNormals();
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				return this;
	
			},
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			normalize: function () {
	
				this.computeBoundingSphere();
	
				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;
	
				var s = radius === 0 ? 1 : 1.0 / radius;
	
				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);
	
				this.applyMatrix( matrix );
	
				return this;
	
			},
	
			computeFaceNormals: function () {
	
				var cb = new Vector3(), ab = new Vector3();
	
				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					var face = this.faces[ f ];
	
					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					cb.normalize();
	
					face.normal.copy( cb );
	
				}
	
			},
	
			computeVertexNormals: function ( areaWeighted ) {
	
				if ( areaWeighted === undefined ) areaWeighted = true;
	
				var v, vl, f, fl, face, vertices;
	
				vertices = new Array( this.vertices.length );
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ] = new Vector3();
	
				}
	
				if ( areaWeighted ) {
	
					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm
	
					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];
	
						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );
	
						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );
	
					}
	
				} else {
	
					this.computeFaceNormals();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );
	
					}
	
				}
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ].normalize();
	
				}
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
					} else {
	
						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeFlatVertexNormals: function () {
	
				var f, fl, face;
	
				this.computeFaceNormals();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );
	
					} else {
	
						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeMorphNormals: function () {
	
				var i, il, f, fl, face;
	
				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					if ( ! face.__originalFaceNormal ) {
	
						face.__originalFaceNormal = face.normal.clone();
	
					} else {
	
						face.__originalFaceNormal.copy( face.normal );
	
					}
	
					if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
						if ( ! face.__originalVertexNormals[ i ] ) {
	
							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
						} else {
	
							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
						}
	
					}
	
				}
	
				// use temp geometry to compute face and vertex normals for each morph
	
				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;
	
				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
					// create on first access
	
					if ( ! this.morphNormals[ i ] ) {
	
						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];
	
						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
						var faceNormal, vertexNormals;
	
						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
	
							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );
	
						}
	
					}
	
					var morphNormals = this.morphNormals[ i ];
	
					// set vertices to morph target
	
					tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
					// compute morph normals
	
					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();
	
					// store morph normals
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];
	
						faceNormal.copy( face.normal );
	
						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
					}
	
				}
	
				// restore original normals
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;
	
				}
	
			},
	
			computeLineDistances: function () {
	
				var d = 0;
				var vertices = this.vertices;
	
				for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
					if ( i > 0 ) {
	
						d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
					}
	
					this.lineDistances[ i ] = d;
	
				}
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				this.boundingBox.setFromPoints( this.vertices );
	
			},
	
			computeBoundingSphere: function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new Sphere();
	
				}
	
				this.boundingSphere.setFromPoints( this.vertices );
	
			},
	
			merge: function ( geometry, matrix, materialIndexOffset ) {
	
				if ( ( geometry && geometry.isGeometry ) === false ) {
	
					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;
	
				}
	
				var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;
	
				if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
				if ( matrix !== undefined ) {
	
					normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				}
	
				// vertices
	
				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
					var vertex = vertices2[ i ];
	
					var vertexCopy = vertex.clone();
	
					if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
					vertices1.push( vertexCopy );
	
				}
	
				// colors
	
				for ( var i = 0, il = colors2.length; i < il; i ++ ) {
	
					colors1.push( colors2[ i ].clone() );
	
				}
	
				// faces
	
				for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
					var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;
	
					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );
	
					if ( normalMatrix !== undefined ) {
	
						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
						normal = faceVertexNormals[ j ].clone();
	
						if ( normalMatrix !== undefined ) {
	
							normal.applyMatrix3( normalMatrix ).normalize();
	
						}
	
						faceCopy.vertexNormals.push( normal );
	
					}
	
					faceCopy.color.copy( face.color );
	
					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );
	
					}
	
					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
					faces1.push( faceCopy );
	
				}
	
				// uvs
	
				for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
					var uv = uvs2[ i ], uvCopy = [];
	
					if ( uv === undefined ) {
	
						continue;
	
					}
	
					for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
						uvCopy.push( uv[ j ].clone() );
	
					}
	
					uvs1.push( uvCopy );
	
				}
	
			},
	
			mergeMesh: function ( mesh ) {
	
				if ( ( mesh && mesh.isMesh ) === false ) {
	
					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;
	
				}
	
				mesh.matrixAutoUpdate && mesh.updateMatrix();
	
				this.merge( mesh.geometry, mesh.matrix );
	
			},
	
			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */
	
			mergeVertices: function () {
	
				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];
	
				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;
	
				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
					if ( verticesMap[ key ] === undefined ) {
	
						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;
	
					} else {
	
						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];
	
					}
	
				}
	
	
				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];
	
				for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
					face = this.faces[ i ];
	
					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];
	
					indices = [ face.a, face.b, face.c ];
	
					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {
	
						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
							faceIndicesToRemove.push( i );
							break;
	
						}
	
					}
	
				}
	
				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
					var idx = faceIndicesToRemove[ i ];
	
					this.faces.splice( idx, 1 );
	
					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
						this.faceVertexUvs[ j ].splice( idx, 1 );
	
					}
	
				}
	
				// Use unique set of vertices
	
				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;
	
			},
	
			sortFacesByMaterialIndex: function () {
	
				var faces = this.faces;
				var length = faces.length;
	
				// tag faces
	
				for ( var i = 0; i < length; i ++ ) {
	
					faces[ i ]._id = i;
	
				}
	
				// sort faces
	
				function materialIndexSort( a, b ) {
	
					return a.materialIndex - b.materialIndex;
	
				}
	
				faces.sort( materialIndexSort );
	
				// sort uvs
	
				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];
	
				var newUvs1, newUvs2;
	
				if ( uvs1 && uvs1.length === length ) newUvs1 = [];
				if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
				for ( var i = 0; i < length; i ++ ) {
	
					var id = faces[ i ]._id;
	
					if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
					if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
				}
	
				if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
				if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};
	
				// standard Geometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				var vertices = [];
	
				for ( var i = 0; i < this.vertices.length; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};
	
				for ( var i = 0; i < this.faces.length; i ++ ) {
	
					var face = this.faces[ i ];
	
					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;
	
					var faceType = 0;
	
					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );
	
					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );
	
					if ( hasFaceVertexUv ) {
	
						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);
	
					}
	
					if ( hasFaceNormal ) {
	
						faces.push( getNormalIndex( face.normal ) );
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						var vertexNormals = face.vertexNormals;
	
						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);
	
					}
	
					if ( hasFaceColor ) {
	
						faces.push( getColorIndex( face.color ) );
	
					}
	
					if ( hasFaceVertexColor ) {
	
						var vertexColors = face.vertexColors;
	
						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);
	
					}
	
				}
	
				function setBit( value, position, enabled ) {
	
					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
				}
	
				function getNormalIndex( normal ) {
	
					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
					if ( normalsHash[ hash ] !== undefined ) {
	
						return normalsHash[ hash ];
	
					}
	
					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );
	
					return normalsHash[ hash ];
	
				}
	
				function getColorIndex( color ) {
	
					var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
					if ( colorsHash[ hash ] !== undefined ) {
	
						return colorsHash[ hash ];
	
					}
	
					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );
	
					return colorsHash[ hash ];
	
				}
	
				function getUvIndex( uv ) {
	
					var hash = uv.x.toString() + uv.y.toString();
	
					if ( uvsHash[ hash ] !== undefined ) {
	
						return uvsHash[ hash ];
	
					}
	
					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );
	
					return uvsHash[ hash ];
	
				}
	
				data.data = {};
	
				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) data.data.colors = colors;
				if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
				data.data.faces = faces;
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				// Handle primitives
	
				var parameters = this.parameters;
	
				if ( parameters !== undefined ) {
	
					var values = [];
	
					for ( var key in parameters ) {
	
						values.push( parameters[ key ] );
	
					}
	
					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;
	
				}
	
				return new this.constructor().copy( this );
				*/
	
				return new Geometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				var i, il, j, jl, k, kl;
	
				// reset
	
				this.vertices = [];
				this.colors = [];
				this.faces = [];
				this.faceVertexUvs = [[]];
				this.morphTargets = [];
				this.morphNormals = [];
				this.skinWeights = [];
				this.skinIndices = [];
				this.lineDistances = [];
				this.boundingBox = null;
				this.boundingSphere = null;
	
				// name
	
				this.name = source.name;
	
				// vertices
	
				var vertices = source.vertices;
	
				for ( i = 0, il = vertices.length; i < il; i ++ ) {
	
					this.vertices.push( vertices[ i ].clone() );
	
				}
	
				// colors
	
				var colors = source.colors;
	
				for ( i = 0, il = colors.length; i < il; i ++ ) {
	
					this.colors.push( colors[ i ].clone() );
	
				}
	
				// faces
	
				var faces = source.faces;
	
				for ( i = 0, il = faces.length; i < il; i ++ ) {
	
					this.faces.push( faces[ i ].clone() );
	
				}
	
				// face vertex uvs
	
				for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
					var faceVertexUvs = source.faceVertexUvs[ i ];
	
					if ( this.faceVertexUvs[ i ] === undefined ) {
	
						this.faceVertexUvs[ i ] = [];
	
					}
	
					for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
						var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
						for ( k = 0, kl = uvs.length; k < kl; k ++ ) {
	
							var uv = uvs[ k ];
	
							uvsCopy.push( uv.clone() );
	
						}
	
						this.faceVertexUvs[ i ].push( uvsCopy );
	
					}
	
				}
	
				// morph targets
	
				var morphTargets = source.morphTargets;
	
				for ( i = 0, il = morphTargets.length; i < il; i ++ ) {
	
					var morphTarget = {};
					morphTarget.name = morphTargets[ i ].name;
	
					// vertices
	
					if ( morphTargets[ i ].vertices !== undefined ) {
	
						morphTarget.vertices = [];
	
						for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {
	
							morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );
	
						}
	
					}
	
					// normals
	
					if ( morphTargets[ i ].normals !== undefined ) {
	
						morphTarget.normals = [];
	
						for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {
	
							morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );
	
						}
	
					}
	
					this.morphTargets.push( morphTarget );
	
				}
	
				// morph normals
	
				var morphNormals = source.morphNormals;
	
				for ( i = 0, il = morphNormals.length; i < il; i ++ ) {
	
					var morphNormal = {};
	
					// vertex normals
	
					if ( morphNormals[ i ].vertexNormals !== undefined ) {
	
						morphNormal.vertexNormals = [];
	
						for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {
	
							var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
							var destVertexNormal = {};
	
							destVertexNormal.a = srcVertexNormal.a.clone();
							destVertexNormal.b = srcVertexNormal.b.clone();
							destVertexNormal.c = srcVertexNormal.c.clone();
	
							morphNormal.vertexNormals.push( destVertexNormal );
	
						}
	
					}
	
					// face normals
	
					if ( morphNormals[ i ].faceNormals !== undefined ) {
	
						morphNormal.faceNormals = [];
	
						for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {
	
							morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );
	
						}
	
					}
	
					this.morphNormals.push( morphNormal );
	
				}
	
				// skin weights
	
				var skinWeights = source.skinWeights;
	
				for ( i = 0, il = skinWeights.length; i < il; i ++ ) {
	
					this.skinWeights.push( skinWeights[ i ].clone() );
	
				}
	
				// skin indices
	
				var skinIndices = source.skinIndices;
	
				for ( i = 0, il = skinIndices.length; i < il; i ++ ) {
	
					this.skinIndices.push( skinIndices[ i ].clone() );
	
				}
	
				// line distances
	
				var lineDistances = source.lineDistances;
	
				for ( i = 0, il = lineDistances.length; i < il; i ++ ) {
	
					this.lineDistances.push( lineDistances[ i ] );
	
				}
	
				// bounding box
	
				var boundingBox = source.boundingBox;
	
				if ( boundingBox !== null ) {
	
					this.boundingBox = boundingBox.clone();
	
				}
	
				// bounding sphere
	
				var boundingSphere = source.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					this.boundingSphere = boundingSphere.clone();
	
				}
	
				// update flags
	
				this.elementsNeedUpdate = source.elementsNeedUpdate;
				this.verticesNeedUpdate = source.verticesNeedUpdate;
				this.uvsNeedUpdate = source.uvsNeedUpdate;
				this.normalsNeedUpdate = source.normalsNeedUpdate;
				this.colorsNeedUpdate = source.colorsNeedUpdate;
				this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
				this.groupsNeedUpdate = source.groupsNeedUpdate;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		Object.assign( Geometry.prototype, EventDispatcher.prototype );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'BufferGeometry';
	
			this.index = null;
			this.attributes = {};
	
			this.morphAttributes = {};
	
			this.groups = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			this.drawRange = { start: 0, count: Infinity };
	
		}
	
		BufferGeometry.prototype = {
	
			constructor: BufferGeometry,
	
			isBufferGeometry: true,
	
			getIndex: function () {
	
				return this.index;
	
			},
	
			setIndex: function ( index ) {
	
				if ( Array.isArray( index ) ) {
	
					this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
	
				} else {
	
					this.index = index;
	
				}
	
			},
	
			addAttribute: function ( name, attribute ) {
	
				if ( ( attribute && attribute.isBufferAttribute ) === false && ( attribute && attribute.isInterleavedBufferAttribute ) === false ) {
	
					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
					this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
					return;
	
				}
	
				if ( name === 'index' ) {
	
					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );
	
					return;
	
				}
	
				this.attributes[ name ] = attribute;
	
				return this;
	
			},
	
			getAttribute: function ( name ) {
	
				return this.attributes[ name ];
	
			},
	
			removeAttribute: function ( name ) {
	
				delete this.attributes[ name ];
	
				return this;
	
			},
	
			addGroup: function ( start, count, materialIndex ) {
	
				this.groups.push( {
	
					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0
	
				} );
	
			},
	
			clearGroups: function () {
	
				this.groups = [];
	
			},
	
			setDrawRange: function ( start, count ) {
	
				this.drawRange.start = start;
				this.drawRange.count = count;
	
			},
	
			applyMatrix: function ( matrix ) {
	
				var position = this.attributes.position;
	
				if ( position !== undefined ) {
	
					matrix.applyToBufferAttribute( position );
					position.needsUpdate = true;
	
				}
	
				var normal = this.attributes.normal;
	
				if ( normal !== undefined ) {
	
					var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
					normalMatrix.applyToBufferAttribute( normal );
					normal.needsUpdate = true;
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1;
	
				return function rotateX( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1;
	
				return function rotateY( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1;
	
				return function rotateZ( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1;
	
				return function translate( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1;
	
				return function scale( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj;
	
				return function lookAt( vector ) {
	
					if ( obj === undefined ) obj = new Object3D();
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			setFromObject: function ( object ) {
	
				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
				var geometry = object.geometry;
	
				if ( object.isPoints || object.isLine ) {
	
					var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );
	
					this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
						var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );
	
						this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
					}
	
					if ( geometry.boundingSphere !== null ) {
	
						this.boundingSphere = geometry.boundingSphere.clone();
	
					}
	
					if ( geometry.boundingBox !== null ) {
	
						this.boundingBox = geometry.boundingBox.clone();
	
					}
	
				} else if ( object.isMesh ) {
	
					if ( geometry && geometry.isGeometry ) {
	
						this.fromGeometry( geometry );
	
					}
	
				}
	
				return this;
	
			},
	
			updateFromObject: function ( object ) {
	
				var geometry = object.geometry;
	
				if ( object.isMesh ) {
	
					var direct = geometry.__directGeometry;
	
					if ( geometry.elementsNeedUpdate === true ) {
	
						direct = undefined;
						geometry.elementsNeedUpdate = false;
	
					}
	
					if ( direct === undefined ) {
	
						return this.fromGeometry( geometry );
	
					}
	
					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;
	
					geometry = direct;
	
				}
	
				var attribute;
	
				if ( geometry.verticesNeedUpdate === true ) {
	
					attribute = this.attributes.position;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;
	
					}
	
					geometry.verticesNeedUpdate = false;
	
				}
	
				if ( geometry.normalsNeedUpdate === true ) {
	
					attribute = this.attributes.normal;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;
	
					}
	
					geometry.normalsNeedUpdate = false;
	
				}
	
				if ( geometry.colorsNeedUpdate === true ) {
	
					attribute = this.attributes.color;
	
					if ( attribute !== undefined ) {
	
						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;
	
					}
	
					geometry.colorsNeedUpdate = false;
	
				}
	
				if ( geometry.uvsNeedUpdate ) {
	
					attribute = this.attributes.uv;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;
	
					}
	
					geometry.uvsNeedUpdate = false;
	
				}
	
				if ( geometry.lineDistancesNeedUpdate ) {
	
					attribute = this.attributes.lineDistance;
	
					if ( attribute !== undefined ) {
	
						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;
	
					}
	
					geometry.lineDistancesNeedUpdate = false;
	
				}
	
				if ( geometry.groupsNeedUpdate ) {
	
					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;
	
					geometry.groupsNeedUpdate = false;
	
				}
	
				return this;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
	
				return this.fromDirectGeometry( geometry.__directGeometry );
	
			},
	
			fromDirectGeometry: function ( geometry ) {
	
				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
				if ( geometry.normals.length > 0 ) {
	
					var normals = new Float32Array( geometry.normals.length * 3 );
					this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
				}
	
				if ( geometry.colors.length > 0 ) {
	
					var colors = new Float32Array( geometry.colors.length * 3 );
					this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
				}
	
				if ( geometry.uvs.length > 0 ) {
	
					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
				}
	
				if ( geometry.uvs2.length > 0 ) {
	
					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
				}
	
				if ( geometry.indices.length > 0 ) {
	
					var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
					var indices = new TypeArray( geometry.indices.length * 3 );
					this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
				}
	
				// groups
	
				this.groups = geometry.groups;
	
				// morphs
	
				for ( var name in geometry.morphTargets ) {
	
					var array = [];
					var morphTargets = geometry.morphTargets[ name ];
	
					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
						var morphTarget = morphTargets[ i ];
	
						var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );
	
						array.push( attribute.copyVector3sArray( morphTarget ) );
	
					}
	
					this.morphAttributes[ name ] = array;
	
				}
	
				// skinning
	
				if ( geometry.skinIndices.length > 0 ) {
	
					var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
					this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
				}
	
				if ( geometry.skinWeights.length > 0 ) {
	
					var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
					this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
				}
	
				//
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				return this;
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				var position = this.attributes.position;
	
				if ( position !== undefined ) {
	
					this.boundingBox.setFromBufferAttribute( position );
	
				} else {
	
					this.boundingBox.makeEmpty();
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
				}
	
			},
	
			computeBoundingSphere: function () {
	
				var box = new Box3();
				var vector = new Vector3();
	
				return function computeBoundingSphere() {
	
					if ( this.boundingSphere === null ) {
	
						this.boundingSphere = new Sphere();
	
					}
	
					var position = this.attributes.position;
	
					if ( position ) {
	
						var center = this.boundingSphere.center;
	
						box.setFromBufferAttribute( position );
						box.getCenter( center );
	
						// hoping to find a boundingSphere with a radius smaller than the
						// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
						var maxRadiusSq = 0;
	
						for ( var i = 0, il = position.count; i < il; i ++ ) {
	
							vector.x = position.getX( i );
							vector.y = position.getY( i );
							vector.z = position.getZ( i );
							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
						}
	
						this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
						if ( isNaN( this.boundingSphere.radius ) ) {
	
							console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
						}
	
					}
	
				};
	
			}(),
	
			computeFaceNormals: function () {
	
				// backwards compatibility
	
			},
	
			computeVertexNormals: function () {
	
				var index = this.index;
				var attributes = this.attributes;
				var groups = this.groups;
	
				if ( attributes.position ) {
	
					var positions = attributes.position.array;
	
					if ( attributes.normal === undefined ) {
	
						this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
					} else {
	
						// reset existing normals to zero
	
						var array = attributes.normal.array;
	
						for ( var i = 0, il = array.length; i < il; i ++ ) {
	
							array[ i ] = 0;
	
						}
	
					}
	
					var normals = attributes.normal.array;
	
					var vA, vB, vC;
					var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
					var cb = new Vector3(), ab = new Vector3();
	
					// indexed elements
	
					if ( index ) {
	
						var indices = index.array;
	
						if ( groups.length === 0 ) {
	
							this.addGroup( 0, indices.length );
	
						}
	
						for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
							var group = groups[ j ];
	
							var start = group.start;
							var count = group.count;
	
							for ( var i = start, il = start + count; i < il; i += 3 ) {
	
								vA = indices[ i + 0 ] * 3;
								vB = indices[ i + 1 ] * 3;
								vC = indices[ i + 2 ] * 3;
	
								pA.fromArray( positions, vA );
								pB.fromArray( positions, vB );
								pC.fromArray( positions, vC );
	
								cb.subVectors( pC, pB );
								ab.subVectors( pA, pB );
								cb.cross( ab );
	
								normals[ vA ] += cb.x;
								normals[ vA + 1 ] += cb.y;
								normals[ vA + 2 ] += cb.z;
	
								normals[ vB ] += cb.x;
								normals[ vB + 1 ] += cb.y;
								normals[ vB + 2 ] += cb.z;
	
								normals[ vC ] += cb.x;
								normals[ vC + 1 ] += cb.y;
								normals[ vC + 2 ] += cb.z;
	
							}
	
						}
	
					} else {
	
						// non-indexed elements (unconnected triangle soup)
	
						for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;
	
							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;
	
							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;
	
						}
	
					}
	
					this.normalizeNormals();
	
					attributes.normal.needsUpdate = true;
	
				}
	
			},
	
			merge: function ( geometry, offset ) {
	
				if ( ( geometry && geometry.isBufferGeometry ) === false ) {
	
					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;
	
				}
	
				if ( offset === undefined ) offset = 0;
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					if ( geometry.attributes[ key ] === undefined ) continue;
	
					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;
	
					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;
	
					var attributeSize = attribute2.itemSize;
	
					for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
						attributeArray1[ j ] = attributeArray2[ i ];
	
					}
	
				}
	
				return this;
	
			},
	
			normalizeNormals: function () {
	
				var normals = this.attributes.normal.array;
	
				var x, y, z, n;
	
				for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
					x = normals[ i ];
					y = normals[ i + 1 ];
					z = normals[ i + 2 ];
	
					n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
					normals[ i ] *= n;
					normals[ i + 1 ] *= n;
					normals[ i + 2 ] *= n;
	
				}
	
			},
	
			toNonIndexed: function () {
	
				if ( this.index === null ) {
	
					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;
	
				}
	
				var geometry2 = new BufferGeometry();
	
				var indices = this.index.array;
				var attributes = this.attributes;
	
				for ( var name in attributes ) {
	
					var attribute = attributes[ name ];
	
					var array = attribute.array;
					var itemSize = attribute.itemSize;
	
					var array2 = new array.constructor( indices.length * itemSize );
	
					var index = 0, index2 = 0;
	
					for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
						index = indices[ i ] * itemSize;
	
						for ( var j = 0; j < itemSize; j ++ ) {
	
							array2[ index2 ++ ] = array[ index ++ ];
	
						}
	
					}
	
					geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
	
				}
	
				return geometry2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};
	
				// standard BufferGeometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				data.data = { attributes: {} };
	
				var index = this.index;
	
				if ( index !== null ) {
	
					var array = Array.prototype.slice.call( index.array );
	
					data.data.index = {
						type: index.array.constructor.name,
						array: array
					};
	
				}
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
	
					var array = Array.prototype.slice.call( attribute.array );
	
					data.data.attributes[ key ] = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: array,
						normalized: attribute.normalized
					};
	
				}
	
				var groups = this.groups;
	
				if ( groups.length > 0 ) {
	
					data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
				}
	
				var boundingSphere = this.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				// Handle primitives
	
				var parameters = this.parameters;
	
				if ( parameters !== undefined ) {
	
					var values = [];
	
					for ( var key in parameters ) {
	
						values.push( parameters[ key ] );
	
					}
	
					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;
	
				}
	
				return new this.constructor().copy( this );
				*/
	
				return new BufferGeometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				var name, i, l;
	
				// reset
	
				this.index = null;
				this.attributes = {};
				this.morphAttributes = {};
				this.groups = [];
				this.boundingBox = null;
				this.boundingSphere = null;
	
				// name
	
				this.name = source.name;
	
				// index
	
				var index = source.index;
	
				if ( index !== null ) {
	
					this.setIndex( index.clone() );
	
				}
	
				// attributes
	
				var attributes = source.attributes;
	
				for ( name in attributes ) {
	
					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );
	
				}
	
				// morph attributes
	
				var morphAttributes = source.morphAttributes;
	
				for ( name in morphAttributes ) {
	
					var array = [];
					var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
	
					for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {
	
						array.push( morphAttribute[ i ].clone() );
	
					}
	
					this.morphAttributes[ name ] = array;
	
				}
	
				// groups
	
				var groups = source.groups;
	
				for ( i = 0, l = groups.length; i < l; i ++ ) {
	
					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
				// bounding box
	
				var boundingBox = source.boundingBox;
	
				if ( boundingBox !== null ) {
	
					this.boundingBox = boundingBox.clone();
	
				}
	
				// bounding sphere
	
				var boundingSphere = source.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					this.boundingSphere = boundingSphere.clone();
	
				}
	
				// draw range
	
				this.drawRange.start = source.drawRange.start;
				this.drawRange.count = source.drawRange.count;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		BufferGeometry.MaxIndex = 65535;
	
		Object.assign( BufferGeometry.prototype, EventDispatcher.prototype );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */
	
		function Mesh( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Mesh';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
			this.drawMode = TrianglesDrawMode;
	
			this.updateMorphTargets();
	
		}
	
		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Mesh,
	
			isMesh: true,
	
			setDrawMode: function ( value ) {
	
				this.drawMode = value;
	
			},
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.drawMode = source.drawMode;
	
				return this;
	
			},
	
			updateMorphTargets: function () {
	
				var morphTargets = this.geometry.morphTargets;
	
				if ( morphTargets !== undefined && morphTargets.length > 0 ) {
	
					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
	
					for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {
	
						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ morphTargets[ m ].name ] = m;
	
					}
	
				}
	
			},
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				var vA = new Vector3();
				var vB = new Vector3();
				var vC = new Vector3();
	
				var tempA = new Vector3();
				var tempB = new Vector3();
				var tempC = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				var barycoord = new Vector3();
	
				var intersectionPoint = new Vector3();
				var intersectionPointWorld = new Vector3();
	
				function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
					Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
					uv1.multiplyScalar( barycoord.x );
					uv2.multiplyScalar( barycoord.y );
					uv3.multiplyScalar( barycoord.z );
	
					uv1.add( uv2 ).add( uv3 );
	
					return uv1.clone();
	
				}
	
				function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
	
					var intersect;
					var material = object.material;
	
					if ( material.side === BackSide ) {
	
						intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
					} else {
	
						intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
	
					}
	
					if ( intersect === null ) return null;
	
					intersectionPointWorld.copy( point );
					intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
					return {
						distance: distance,
						point: intersectionPointWorld.clone(),
						object: object
					};
	
				}
	
				function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {
	
					vA.fromBufferAttribute( position, a );
					vB.fromBufferAttribute( position, b );
					vC.fromBufferAttribute( position, c );
	
					var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
					if ( intersection ) {
	
						if ( uv ) {
	
							uvA.fromBufferAttribute( uv, a );
							uvB.fromBufferAttribute( uv, b );
							uvC.fromBufferAttribute( uv, c );
	
							intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC, uvA, uvB, uvC );
	
						}
	
						intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
						intersection.faceIndex = a;
	
					}
	
					return intersection;
	
				}
	
				return function raycast( raycaster, intersects ) {
	
					var geometry = this.geometry;
					var material = this.material;
					var matrixWorld = this.matrixWorld;
	
					if ( material === undefined ) return;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					// Check boundingBox before continuing
	
					if ( geometry.boundingBox !== null ) {
	
						if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
					}
	
					var intersection;
	
					if ( geometry.isBufferGeometry ) {
	
						var a, b, c;
						var index = geometry.index;
						var position = geometry.attributes.position;
						var uv = geometry.attributes.uv;
						var i, l;
	
						if ( index !== null ) {
	
							// indexed buffer geometry
	
							for ( i = 0, l = index.count; i < l; i += 3 ) {
	
								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						} else {
	
							// non-indexed buffer geometry
	
							for ( i = 0, l = position.count; i < l; i += 3 ) {
	
								a = i;
								b = i + 1;
								c = i + 2;
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.index = a; // triangle number in positions buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						}
	
					} else if ( geometry.isGeometry ) {
	
						var fvA, fvB, fvC;
						var isFaceMaterial = ( material && material.isMultiMaterial );
						var materials = isFaceMaterial === true ? material.materials : null;
	
						var vertices = geometry.vertices;
						var faces = geometry.faces;
						var uvs;
	
						var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
						if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
						for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
							var face = faces[ f ];
							var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
	
							if ( faceMaterial === undefined ) continue;
	
							fvA = vertices[ face.a ];
							fvB = vertices[ face.b ];
							fvC = vertices[ face.c ];
	
							if ( faceMaterial.morphTargets === true ) {
	
								var morphTargets = geometry.morphTargets;
								var morphInfluences = this.morphTargetInfluences;
	
								vA.set( 0, 0, 0 );
								vB.set( 0, 0, 0 );
								vC.set( 0, 0, 0 );
	
								for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
									var influence = morphInfluences[ t ];
	
									if ( influence === 0 ) continue;
	
									var targets = morphTargets[ t ].vertices;
	
									vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
									vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
									vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
								}
	
								vA.add( fvA );
								vB.add( fvB );
								vC.add( fvC );
	
								fvA = vA;
								fvB = vB;
								fvC = vC;
	
							}
	
							intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
							if ( intersection ) {
	
								if ( uvs ) {
	
									var uvs_f = uvs[ f ];
									uvA.copy( uvs_f[ 0 ] );
									uvB.copy( uvs_f[ 1 ] );
									uvC.copy( uvs_f[ 2 ] );
	
									intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
								}
	
								intersection.face = face;
								intersection.faceIndex = f;
								intersects.push( intersection );
	
							}
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
		 */
	
		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			Geometry.call( this );
	
			this.type = 'BoxGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();
	
		}
	
		BoxGeometry.prototype = Object.create( Geometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'BoxBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			var scope = this;
	
			// segments
	
			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var numberOfVertices = 0;
			var groupStart = 0;
	
			// build each side of the box geometry
	
			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
			buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
			buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
	
				var segmentWidth = width / gridX;
				var segmentHeight = height / gridY;
	
				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;
	
				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;
	
				var vertexCounter = 0;
				var groupCount = 0;
	
				var ix, iy;
	
				var vector = new Vector3();
	
				// generate vertices, normals and uvs
	
				for ( iy = 0; iy < gridY1; iy ++ ) {
	
					var y = iy * segmentHeight - heightHalf;
	
					for ( ix = 0; ix < gridX1; ix ++ ) {
	
						var x = ix * segmentWidth - widthHalf;
	
						// set values to correct vector component
	
						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;
	
						// now apply vector to vertex buffer
	
						vertices.push( vector.x, vector.y, vector.z );
	
						// set values to correct vector component
	
						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;
	
						// now apply vector to normal buffer
	
						normals.push( vector.x, vector.y, vector.z );
	
						// uvs
	
						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );
	
						// counters
	
						vertexCounter += 1;
	
					}
	
				}
	
				// indices
	
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment
	
				for ( iy = 0; iy < gridY; iy ++ ) {
	
					for ( ix = 0; ix < gridX; ix ++ ) {
	
						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
						// increase counter
	
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, materialIndex );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
				// update total number of vertices
	
				numberOfVertices += vertexCounter;
	
			}
	
		}
	
		BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */
	
		function PlaneGeometry( width, height, widthSegments, heightSegments ) {
	
			Geometry.call( this );
	
			this.type = 'PlaneGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
		}
	
		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */
	
		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PlaneBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			var width_half = width / 2;
			var height_half = height / 2;
	
			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;
	
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
	
			var segment_width = width / gridX;
			var segment_height = height / gridY;
	
			var ix, iy;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// generate vertices, normals and uvs
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				var y = iy * segment_height - height_half;
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var x = ix * segment_width - width_half;
	
					vertices.push( x, - y, 0 );
	
					normals.push( 0, 0, 1 );
	
					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );
	
				}
	
			}
	
			// indices
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function Camera() {
	
			Object3D.call( this );
	
			this.type = 'Camera';
	
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
	
		}
	
		Camera.prototype = Object.create( Object3D.prototype );
		Camera.prototype.constructor = Camera;
	
		Camera.prototype.isCamera = true;
	
		Camera.prototype.getWorldDirection = function () {
	
			var quaternion = new Quaternion();
	
			return function getWorldDirection( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
			};
	
		}();
	
		Camera.prototype.lookAt = function () {
	
			// This routine does not support cameras with rotated and/or translated parent(s)
	
			var m1 = new Matrix4();
	
			return function lookAt( vector ) {
	
				m1.lookAt( this.position, vector, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}();
	
		Camera.prototype.clone = function () {
	
			return new this.constructor().copy( this );
	
		};
	
		Camera.prototype.copy = function ( source ) {
	
			Object3D.prototype.copy.call( this, source );
	
			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */
	
		function PerspectiveCamera( fov, aspect, near, far ) {
	
			Camera.call( this );
	
			this.type = 'PerspectiveCamera';
	
			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;
	
			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;
	
			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;
	
			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
	
			this.updateProjectionMatrix();
	
		}
	
		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: PerspectiveCamera,
	
			isPerspectiveCamera: true,
	
			copy: function ( source ) {
	
				Camera.prototype.copy.call( this, source );
	
				this.fov = source.fov;
				this.zoom = source.zoom;
	
				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;
	
				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;
	
				return this;
	
			},
	
			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {
	
				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	
				this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();
	
			},
	
			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {
	
				var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );
	
				return 0.5 * this.getFilmHeight() / vExtentSlope;
	
			},
	
			getEffectiveFOV: function () {
	
				return _Math.RAD2DEG * 2 * Math.atan(
						Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
	
			},
	
			getFilmWidth: function () {
	
				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );
	
			},
	
			getFilmHeight: function () {
	
				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );
	
			},
	
			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
	
				this.aspect = fullWidth / fullHeight;
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function() {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var near = this.near,
					top = near * Math.tan(
							_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;
	
				if ( view !== null ) {
	
					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;
	
					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;
	
				}
	
				var skew = this.filmOffset;
				if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
	
				this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.fov = this.fov;
				data.object.zoom = this.zoom;
	
				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;
	
				data.object.aspect = this.aspect;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */
	
		function OrthographicCamera( left, right, top, bottom, near, far ) {
	
			Camera.call( this );
	
			this.type = 'OrthographicCamera';
	
			this.zoom = 1;
			this.view = null;
	
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
	
			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;
	
			this.updateProjectionMatrix();
	
		}
	
		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: OrthographicCamera,
	
			isOrthographicCamera: true,
	
			copy: function ( source ) {
	
				Camera.prototype.copy.call( this, source );
	
				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;
	
				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				return this;
	
			},
	
			setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function() {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;
	
				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;
	
				if ( this.view !== null ) {
	
					var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
					var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
					var scaleW = ( this.right - this.left ) / this.view.width;
					var scaleH = ( this.top - this.bottom ) / this.view.height;
	
					left += scaleW * ( this.view.offsetX / zoomW );
					right = left + scaleW * ( this.view.width / zoomW );
					top -= scaleH * ( this.view.offsetY / zoomH );
					bottom = top - scaleH * ( this.view.height / zoomH );
	
				}
	
				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			var type, size;
	
			function setIndex( index ) {
	
				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
					type = gl.UNSIGNED_INT;
					size = 4;
	
				} else if ( index.array instanceof Uint16Array ) {
	
					type = gl.UNSIGNED_SHORT;
					size = 2;
	
				} else {
	
					type = gl.UNSIGNED_BYTE;
					size = 1;
	
				}
	
			}
	
			function render( start, count ) {
	
				gl.drawElements( mode, count, type, start * size );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry, start, count ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			return {
	
				setMode: setMode,
				setIndex: setIndex,
				render: render,
				renderInstances: renderInstances
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			function render( start, count ) {
	
				gl.drawArrays( mode, start, count );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				var position = geometry.attributes.position;
	
				var count = 0;
	
				if ( position.isInterleavedBufferAttribute ) {
	
					count = position.data.count;
	
					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
				} else {
	
					count = position.count;
	
					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
				}
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			return {
				setMode: setMode,
				render: render,
				renderInstances: renderInstances
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLLights() {
	
			var lights = {};
	
			return {
	
				get: function ( light ) {
	
					if ( lights[ light.id ] !== undefined ) {
	
						return lights[ light.id ];
	
					}
	
					var uniforms;
	
					switch ( light.type ) {
	
						case 'DirectionalLight':
							uniforms = {
								direction: new Vector3(),
								color: new Color(),
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'SpotLight':
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;
	
						case 'RectAreaLight':
							uniforms = {
								color: new Color(),
								position: new Vector3(),
								halfWidth: new Vector3(),
								halfHeight: new Vector3()
								// TODO (abelnation): set RectAreaLight shadow uniforms
							};
							break;
	
					}
	
					lights[ light.id ] = uniforms;
	
					return uniforms;
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var programIdCount = 0;
	
		function getEncodingComponents( encoding ) {
	
			switch ( encoding ) {
	
				case LinearEncoding:
					return [ 'Linear','( value )' ];
				case sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );
	
			}
	
		}
	
		function getTexelDecodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";
	
		}
	
		function getTexelEncodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";
	
		}
	
		function getToneMappingFunction( functionName, toneMapping ) {
	
			var toneMappingName;
	
			switch ( toneMapping ) {
	
				case LinearToneMapping:
					toneMappingName = "Linear";
					break;
	
				case ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;
	
				case Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;
	
				case CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;
	
				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );
	
			}
	
			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
	
		}
	
		function generateExtensions( extensions, parameters, rendererExtensions ) {
	
			extensions = extensions || {};
	
			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
			];
	
			return chunks.filter( filterEmptyLine ).join( '\n' );
	
		}
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		function replaceLightNums( string, parameters ) {
	
			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
		}
	
		function parseIncludes( string ) {
	
			var pattern = /#include +<([\w\d.]+)>/g;
	
			function replace( match, include ) {
	
				var replace = ShaderChunk[ include ];
	
				if ( replace === undefined ) {
	
					throw new Error( 'Can not resolve #include <' + include + '>' );
	
				}
	
				return parseIncludes( replace );
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function unrollLoops( string ) {
	
			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
			function replace( match, start, end, snippet ) {
	
				var unroll = '';
	
				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
				}
	
				return unroll;
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function WebGLProgram( renderer, code, material, parameters ) {
	
			var gl = renderer.context;
	
			var extensions = material.extensions;
			var defines = material.defines;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;
	
					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material.isRawShaderMaterial ) {
	
				prefixVertex = [
	
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			} else {
	
				prefixVertex = [
	
		        
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_BONES ' + parameters.maxBones,
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
					'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
	
					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',
	
					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',
	
					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			}
	
			vertexShader = parseIncludes( vertexShader, parameters );
			vertexShader = replaceLightNums( vertexShader, parameters );
	
			fragmentShader = parseIncludes( fragmentShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
	
			if ( ! material.isShaderMaterial ) {
	
				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );
	
			var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms =
						new WebGLUniforms( gl, program, renderer );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLPrograms( renderer, capabilities ) {
	
			var programs = [];
	
			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshToonMaterial: 'phong',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points'
			};
	
			var parameterNames = [
				"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
				"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap", "gradientMap",
				"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
			];
	
	
			function allocateBones( object ) {
	
				if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
					return 1024;
	
				} else {
	
					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)
	
					var nVertexUniforms = capabilities.maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
					var maxBones = nVertexMatrices;
	
					if ( object !== undefined && (object && object.isSkinnedMesh) ) {
	
						maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
						if ( maxBones < object.skeleton.bones.length ) {
	
							console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
						}
	
					}
	
					return maxBones;
	
				}
	
			}
	
			function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
	
				var encoding;
	
				if ( ! map ) {
	
					encoding = LinearEncoding;
	
				} else if ( map.isTexture ) {
	
					encoding = map.encoding;
	
				} else if ( map.isWebGLRenderTarget ) {
	
					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;
	
				}
	
				// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
				if ( encoding === LinearEncoding && gammaOverrideLinear ) {
	
					encoding = GammaEncoding;
	
				}
	
				return encoding;
	
			}
	
			this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {
	
				var shaderID = shaderIDs[ material.type ];
	
				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)
	
				var maxBones = allocateBones( object );
				var precision = renderer.getPrecision();
	
				if ( material.precision !== null ) {
	
					precision = capabilities.getMaxPrecision( material.precision );
	
					if ( precision !== material.precision ) {
	
						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
					}
	
				}
	
				var currentRenderTarget = renderer.getCurrentRenderTarget();
	
				var parameters = {
	
					shaderID: shaderID,
	
					precision: precision,
					supportsVertexTextures: capabilities.vertexTextures,
					outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
					map: !! material.map,
					mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
					envMap: !! material.envMap,
					envMapMode: material.envMap && material.envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
					envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
					lightMap: !! material.lightMap,
					aoMap: !! material.aoMap,
					emissiveMap: !! material.emissiveMap,
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
					bumpMap: !! material.bumpMap,
					normalMap: !! material.normalMap,
					displacementMap: !! material.displacementMap,
					roughnessMap: !! material.roughnessMap,
					metalnessMap: !! material.metalnessMap,
					specularMap: !! material.specularMap,
					alphaMap: !! material.alphaMap,
	
					gradientMap: !! material.gradientMap,
	
					combine: material.combine,
	
					vertexColors: material.vertexColors,
	
					fog: !! fog,
					useFog: material.fog,
					fogExp: (fog && fog.isFogExp2),
	
					flatShading: material.shading === FlatShading,
	
					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
					skinning: material.skinning,
					maxBones: maxBones,
					useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,
	
					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numRectAreaLights: lights.rectArea.length,
					numHemiLights: lights.hemi.length,
	
					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,
	
					shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,
	
					toneMapping: renderer.toneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,
	
					premultipliedAlpha: material.premultipliedAlpha,
	
					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,
	
					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
	
				};
	
				return parameters;
	
			};
	
			this.getProgramCode = function ( material, parameters ) {
	
				var array = [];
	
				if ( parameters.shaderID ) {
	
					array.push( parameters.shaderID );
	
				} else {
	
					array.push( material.fragmentShader );
					array.push( material.vertexShader );
	
				}
	
				if ( material.defines !== undefined ) {
	
					for ( var name in material.defines ) {
	
						array.push( name );
						array.push( material.defines[ name ] );
	
					}
	
				}
	
				for ( var i = 0; i < parameterNames.length; i ++ ) {
	
					array.push( parameters[ parameterNames[ i ] ] );
	
				}
	
				return array.join();
	
			};
	
			this.acquireProgram = function ( material, parameters, code ) {
	
				var program;
	
				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
					var programInfo = programs[ p ];
	
					if ( programInfo.code === code ) {
	
						program = programInfo;
						++ program.usedTimes;
	
						break;
	
					}
	
				}
	
				if ( program === undefined ) {
	
					program = new WebGLProgram( renderer, code, material, parameters );
					programs.push( program );
	
				}
	
				return program;
	
			};
	
			this.releaseProgram = function( program ) {
	
				if ( -- program.usedTimes === 0 ) {
	
					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();
	
					// Free WebGL resources
					program.destroy();
	
				}
	
			};
	
			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLGeometries( gl, properties, info ) {
	
			var geometries = {};
	
			function onGeometryDispose( event ) {
	
				var geometry = event.target;
				var buffergeometry = geometries[ geometry.id ];
	
				if ( buffergeometry.index !== null ) {
	
					deleteAttribute( buffergeometry.index );
	
				}
	
				deleteAttributes( buffergeometry.attributes );
	
				geometry.removeEventListener( 'dispose', onGeometryDispose );
	
				delete geometries[ geometry.id ];
	
				// TODO
	
				var property = properties.get( geometry );
	
				if ( property.wireframe ) {
	
					deleteAttribute( property.wireframe );
	
				}
	
				properties.delete( geometry );
	
				var bufferproperty = properties.get( buffergeometry );
	
				if ( bufferproperty.wireframe ) {
	
					deleteAttribute( bufferproperty.wireframe );
	
				}
	
				properties.delete( buffergeometry );
	
				//
	
				info.memory.geometries --;
	
			}
	
			function getAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data ).__webglBuffer;
	
				}
	
				return properties.get( attribute ).__webglBuffer;
	
			}
	
			function deleteAttribute( attribute ) {
	
				var buffer = getAttributeBuffer( attribute );
	
				if ( buffer !== undefined ) {
	
					gl.deleteBuffer( buffer );
					removeAttributeBuffer( attribute );
	
				}
	
			}
	
			function deleteAttributes( attributes ) {
	
				for ( var name in attributes ) {
	
					deleteAttribute( attributes[ name ] );
	
				}
	
			}
	
			function removeAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					properties.delete( attribute.data );
	
				} else {
	
					properties.delete( attribute );
	
				}
	
			}
	
			return {
	
				get: function ( object ) {
	
					var geometry = object.geometry;
	
					if ( geometries[ geometry.id ] !== undefined ) {
	
						return geometries[ geometry.id ];
	
					}
	
					geometry.addEventListener( 'dispose', onGeometryDispose );
	
					var buffergeometry;
	
					if ( geometry.isBufferGeometry ) {
	
						buffergeometry = geometry;
	
					} else if ( geometry.isGeometry ) {
	
						if ( geometry._bufferGeometry === undefined ) {
	
							geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
	
						}
	
						buffergeometry = geometry._bufferGeometry;
	
					}
	
					geometries[ geometry.id ] = buffergeometry;
	
					info.memory.geometries ++;
	
					return buffergeometry;
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLObjects( gl, properties, info ) {
	
			var geometries = new WebGLGeometries( gl, properties, info );
	
			//
	
			function update( object ) {
	
				// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	
				var geometry = geometries.get( object );
	
				if ( object.geometry.isGeometry ) {
	
					geometry.updateFromObject( object );
	
				}
	
				var index = geometry.index;
				var attributes = geometry.attributes;
	
				if ( index !== null ) {
	
					updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );
	
				}
	
				for ( var name in attributes ) {
	
					updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );
	
				}
	
				// morph targets
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var name in morphAttributes ) {
	
					var array = morphAttributes[ name ];
	
					for ( var i = 0, l = array.length; i < l; i ++ ) {
	
						updateAttribute( array[ i ], gl.ARRAY_BUFFER );
	
					}
	
				}
	
				return geometry;
	
			}
	
			function updateAttribute( attribute, bufferType ) {
	
				var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;
	
				var attributeProperties = properties.get( data );
	
				if ( attributeProperties.__webglBuffer === undefined ) {
	
					createBuffer( attributeProperties, data, bufferType );
	
				} else if ( attributeProperties.version !== data.version ) {
	
					updateBuffer( attributeProperties, data, bufferType );
	
				}
	
			}
	
			function createBuffer( attributeProperties, data, bufferType ) {
	
				attributeProperties.__webglBuffer = gl.createBuffer();
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
				var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
				gl.bufferData( bufferType, data.array, usage );
	
				var type = gl.FLOAT;
				var array = data.array;
	
				if ( array instanceof Float32Array ) {
	
					type = gl.FLOAT;
	
				} else if ( array instanceof Float64Array ) {
	
					console.warn( "Unsupported data buffer format: Float64Array" );
	
				} else if ( array instanceof Uint16Array ) {
	
					type = gl.UNSIGNED_SHORT;
	
				} else if ( array instanceof Int16Array ) {
	
					type = gl.SHORT;
	
				} else if ( array instanceof Uint32Array ) {
	
					type = gl.UNSIGNED_INT;
	
				} else if ( array instanceof Int32Array ) {
	
					type = gl.INT;
	
				} else if ( array instanceof Int8Array ) {
	
					type = gl.BYTE;
	
				} else if ( array instanceof Uint8Array ) {
	
					type = gl.UNSIGNED_BYTE;
	
				}
	
				attributeProperties.bytesPerElement = array.BYTES_PER_ELEMENT;
				attributeProperties.type = type;
				attributeProperties.version = data.version;
	
				data.onUploadCallback();
	
			}
	
			function updateBuffer( attributeProperties, data, bufferType ) {
	
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
				if ( data.dynamic === false ) {
	
					gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );
	
				} else if ( data.updateRange.count === - 1 ) {
	
					// Not using update ranges
	
					gl.bufferSubData( bufferType, 0, data.array );
	
				} else if ( data.updateRange.count === 0 ) {
	
					console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
				} else {
	
					gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
									  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );
	
					data.updateRange.count = 0; // reset range
	
				}
	
				attributeProperties.version = data.version;
	
			}
	
			function getAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data ).__webglBuffer;
	
				}
	
				return properties.get( attribute ).__webglBuffer;
	
			}
	
			function getAttributeProperties( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data );
	
				}
	
				return properties.get( attribute );
	
			}
	
			function getWireframeAttribute( geometry ) {
	
				var property = properties.get( geometry );
	
				if ( property.wireframe !== undefined ) {
	
					return property.wireframe;
	
				}
	
				var indices = [];
	
				var index = geometry.index;
				var attributes = geometry.attributes;
	
				// console.time( 'wireframe' );
	
				if ( index !== null ) {
	
					var array = index.array;
	
					for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				} else {
	
					var array = attributes.position.array;
	
					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
						var a = i + 0;
						var b = i + 1;
						var c = i + 2;
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				}
	
				// console.timeEnd( 'wireframe' );
	
				var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
	
				updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
				property.wireframe = attribute;
	
				return attribute;
	
			}
	
			return {
	
				getAttributeBuffer: getAttributeBuffer,
				getAttributeProperties: getAttributeProperties,
				getWireframeAttribute: getWireframeAttribute,
	
				update: update
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {
	
			var _infoMemory = info.memory;
			var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );
	
			//
	
			function clampToMaxSize( image, maxSize ) {
	
				if ( image.width > maxSize || image.height > maxSize ) {
	
					// Warning: Scaling through the canvas will only work with images that use
					// premultiplied alpha.
	
					var scale = maxSize / Math.max( image.width, image.height );
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = Math.floor( image.width * scale );
					canvas.height = Math.floor( image.height * scale );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function isPowerOfTwo( image ) {
	
				return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );
	
			}
	
			function makePowerOfTwo( image ) {
	
				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = _Math.nearestPowerOfTwo( image.width );
					canvas.height = _Math.nearestPowerOfTwo( image.height );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function textureNeedsPowerOfTwo( texture ) {
	
				return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
					( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );
	
			}
	
			// Fallback filters for non-power-of-2 textures
	
			function filterFallback( f ) {
	
				if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {
	
					return _gl.NEAREST;
	
				}
	
				return _gl.LINEAR;
	
			}
	
			//
	
			function onTextureDispose( event ) {
	
				var texture = event.target;
	
				texture.removeEventListener( 'dispose', onTextureDispose );
	
				deallocateTexture( texture );
	
				_infoMemory.textures --;
	
	
			}
	
			function onRenderTargetDispose( event ) {
	
				var renderTarget = event.target;
	
				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
				deallocateRenderTarget( renderTarget );
	
				_infoMemory.textures --;
	
			}
	
			//
	
			function deallocateTexture( texture ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
					// cube texture
	
					_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
				} else {
	
					// 2D texture
	
					if ( textureProperties.__webglInit === undefined ) return;
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				// remove all webgl properties
				properties.delete( texture );
	
			}
	
			function deallocateRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				if ( ! renderTarget ) return;
	
				if ( textureProperties.__webglTexture !== undefined ) {
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				if ( renderTarget.depthTexture ) {
	
					renderTarget.depthTexture.dispose();
	
				}
	
				if ( renderTarget.isWebGLRenderTargetCube ) {
	
					for ( var i = 0; i < 6; i ++ ) {
	
						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
					}
	
				} else {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
				}
	
				properties.delete( renderTarget.texture );
				properties.delete( renderTarget );
	
			}
	
			//
	
	
	
			function setTexture2D( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					var image = texture.image;
	
					if ( image === undefined ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
	
					} else if ( image.complete === false ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
	
					} else {
	
						uploadTexture( textureProperties, texture, slot );
						return;
	
					}
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			}
	
			function setTextureCube( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image.length === 6 ) {
	
					if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
						if ( ! textureProperties.__image__webglTextureCube ) {
	
							texture.addEventListener( 'dispose', onTextureDispose );
	
							textureProperties.__image__webglTextureCube = _gl.createTexture();
	
							_infoMemory.textures ++;
	
						}
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
						_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
						var isCompressed = ( texture && texture.isCompressedTexture );
						var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );
	
						var cubeImage = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed && ! isDataTexture ) {
	
								cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
							} else {
	
								cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
							}
	
						}
	
						var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = paramThreeToGL( texture.format ),
						glType = paramThreeToGL( texture.type );
	
						setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed ) {
	
								if ( isDataTexture ) {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
								}
	
							} else {
	
								var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
								for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
									mipmap = mipmaps[ j ];
	
									if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
										if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
											state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
										} else {
	
											console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );
	
										}
	
									} else {
	
										state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
									}
	
								}
	
							}
	
						}
	
						if ( texture.generateMipmaps && isPowerOfTwoImage ) {
	
							_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
						}
	
						textureProperties.__version = texture.version;
	
						if ( texture.onUpdate ) texture.onUpdate( texture );
	
					} else {
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					}
	
				}
	
			}
	
			function setTextureCubeDynamic( texture, slot ) {
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
			}
	
			function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {
	
				var extension;
	
				if ( isPowerOfTwoImage ) {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
				} else {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
					}
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
					}
	
				}
	
				extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension ) {
	
					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
					if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
					}
	
				}
	
			}
	
			function uploadTexture( textureProperties, texture, slot ) {
	
				if ( textureProperties.__webglInit === undefined ) {
	
					textureProperties.__webglInit = true;
	
					texture.addEventListener( 'dispose', onTextureDispose );
	
					textureProperties.__webglTexture = _gl.createTexture();
	
					_infoMemory.textures ++;
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
				var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
				if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
	
					image = makePowerOfTwo( image );
	
				}
	
				var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );
	
				setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
	
				var mipmap, mipmaps = texture.mipmaps;
	
				if ( texture.isDepthTexture ) {
	
					// populate depth texture with dummy data
	
					var internalFormat = _gl.DEPTH_COMPONENT;
	
					if ( texture.type === FloatType ) {
	
						if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
						internalFormat = _gl.DEPTH_COMPONENT32F;
	
					} else if ( _isWebGL2 ) {
	
						// WebGL 2.0 requires signed internalformat for glTexImage2D
						internalFormat = _gl.DEPTH_COMPONENT16;
	
					}
	
					if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {
	
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {
	
						        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
	
							texture.type = UnsignedShortType;
							glType = paramThreeToGL( texture.type );
	
						}
	
					}
	
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.format === DepthStencilFormat ) {
	
						internalFormat = _gl.DEPTH_STENCIL;
	
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {
	
						        console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
	
							texture.type = UnsignedInt248Type;
							glType = paramThreeToGL( texture.type );
	
						}
	
					}
	
					state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );
	
				} else if ( texture.isDataTexture ) {
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
					}
	
				} else if ( texture.isCompressedTexture ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
	
						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
								state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
							} else {
	
								console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
							}
	
						} else {
	
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
					}
	
				} else {
	
					// regular Texture (image, video, canvas)
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
	
					}
	
				}
	
				if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				textureProperties.__version = texture.version;
	
				if ( texture.onUpdate ) texture.onUpdate( texture );
	
			}
	
			// Render targets
	
			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
	
				var glFormat = paramThreeToGL( renderTarget.texture.format );
				var glType = paramThreeToGL( renderTarget.texture.type );
				state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget ) {
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else {
	
					// FIXME: We don't support !depth !stencil
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	
			}
	
			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {
	
				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
				if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {
	
					throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
	
				}
	
				// upload an empty depth texture with framebuffer size
				if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {
					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;
				}
	
				setTexture2D( renderTarget.depthTexture, 0 );
	
				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
	
				if ( renderTarget.depthTexture.format === DepthFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else {
	
					throw new Error('Unknown depthTexture format')
	
				}
	
			}
	
			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
	
				if ( renderTarget.depthTexture ) {
	
					if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');
	
					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
	
				} else {
	
					if ( isCube ) {
	
						renderTargetProperties.__webglDepthbuffer = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
						}
	
					} else {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
					}
	
				}
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
	
				// Setup framebuffer
	
				if ( isCube ) {
	
					renderTargetProperties.__webglFramebuffer = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
					}
	
				} else {
	
					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
				}
	
				// Setup color buffer
	
				if ( isCube ) {
	
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
	
					}
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
					state.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				// Setup depth and stencil buffers
	
				if ( renderTarget.depthBuffer ) {
	
					setupDepthRenderbuffer( renderTarget );
	
				}
	
			}
	
			function updateRenderTargetMipmap( renderTarget ) {
	
				var texture = renderTarget.texture;
	
				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== NearestFilter &&
						texture.minFilter !== LinearFilter ) {
	
					var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					var webglTexture = properties.get( texture ).__webglTexture;
	
					state.bindTexture( target, webglTexture );
					_gl.generateMipmap( target );
					state.bindTexture( target, null );
	
				}
	
			}
	
			this.setTexture2D = setTexture2D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	
		}
	
		/**
		 * @author fordacious / fordacious.github.io
		 */
	
		function WebGLProperties() {
	
			var properties = {};
	
			return {
	
				get: function ( object ) {
	
					var uuid = object.uuid;
					var map = properties[ uuid ];
	
					if ( map === undefined ) {
	
						map = {};
						properties[ uuid ] = map;
	
					}
	
					return map;
	
				},
	
				delete: function ( object ) {
	
					delete properties[ object.uuid ];
	
				},
	
				clear: function () {
	
					properties = {};
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLState( gl, extensions, paramThreeToGL ) {
	
			function ColorBuffer() {
	
				var locked = false;
	
				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4();
	
				return {
	
					setMask: function ( colorMask ) {
	
						if ( currentColorMask !== colorMask && ! locked ) {
	
							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( r, g, b, a, premultipliedAlpha ) {
	
						if ( premultipliedAlpha === true ) {
	
							r *= a; g *= a; b *= a;
	
						}
	
						color.set( r, g, b, a );
	
						if ( currentColorClear.equals( color ) === false ) {
	
							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentColorMask = null;
						currentColorClear.set( 0, 0, 0, 1 );
	
					}
	
				};
	
			}
	
			function DepthBuffer() {
	
				var locked = false;
	
				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;
	
				return {
	
					setTest: function ( depthTest ) {
	
						if ( depthTest ) {
	
							enable( gl.DEPTH_TEST );
	
						} else {
	
							disable( gl.DEPTH_TEST );
	
						}
	
					},
	
					setMask: function ( depthMask ) {
	
						if ( currentDepthMask !== depthMask && ! locked ) {
	
							gl.depthMask( depthMask );
							currentDepthMask = depthMask;
	
						}
	
					},
	
					setFunc: function ( depthFunc ) {
	
						if ( currentDepthFunc !== depthFunc ) {
	
							if ( depthFunc ) {
	
								switch ( depthFunc ) {
	
									case NeverDepth:
	
										gl.depthFunc( gl.NEVER );
										break;
	
									case AlwaysDepth:
	
										gl.depthFunc( gl.ALWAYS );
										break;
	
									case LessDepth:
	
										gl.depthFunc( gl.LESS );
										break;
	
									case LessEqualDepth:
	
										gl.depthFunc( gl.LEQUAL );
										break;
	
									case EqualDepth:
	
										gl.depthFunc( gl.EQUAL );
										break;
	
									case GreaterEqualDepth:
	
										gl.depthFunc( gl.GEQUAL );
										break;
	
									case GreaterDepth:
	
										gl.depthFunc( gl.GREATER );
										break;
	
									case NotEqualDepth:
	
										gl.depthFunc( gl.NOTEQUAL );
										break;
	
									default:
	
										gl.depthFunc( gl.LEQUAL );
	
								}
	
							} else {
	
								gl.depthFunc( gl.LEQUAL );
	
							}
	
							currentDepthFunc = depthFunc;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( depth ) {
	
						if ( currentDepthClear !== depth ) {
	
							gl.clearDepth( depth );
							currentDepthClear = depth;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;
	
					}
	
				};
	
			}
	
			function StencilBuffer() {
	
				var locked = false;
	
				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;
	
				return {
	
					setTest: function ( stencilTest ) {
	
						if ( stencilTest ) {
	
							enable( gl.STENCIL_TEST );
	
						} else {
	
							disable( gl.STENCIL_TEST );
	
						}
	
					},
	
					setMask: function ( stencilMask ) {
	
						if ( currentStencilMask !== stencilMask && ! locked ) {
	
							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;
	
						}
	
					},
	
					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
	
						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {
	
							gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
	
							currentStencilFunc = stencilFunc;
							currentStencilRef = stencilRef;
							currentStencilFuncMask = stencilMask;
	
						}
	
					},
	
					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
	
						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {
	
							gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
	
							currentStencilFail = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( stencil ) {
	
						if ( currentStencilClear !== stencil ) {
	
							gl.clearStencil( stencil );
							currentStencilClear = stencil;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;
	
					}
	
				};
	
			}
	
			//
	
			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();
	
			var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );
	
			var capabilities = {};
	
			var compressedTextureFormats = null;
	
			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;
	
			var currentFlipSided = null;
			var currentCullFace = null;
	
			var currentLineWidth = null;
	
			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;
	
			var currentScissorTest = null;
	
			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	
			var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
			var lineWidthAvailable = parseFloat( version ) >= 1.0;
	
			var currentTextureSlot = null;
			var currentBoundTextures = {};
	
			var currentScissor = new Vector4();
			var currentViewport = new Vector4();
	
			function createTexture( type, target, count ) {
	
				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();
	
				gl.bindTexture( type, texture );
				gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
				gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
	
				for ( var i = 0; i < count; i ++ ) {
	
					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
	
				}
	
				return texture;
	
			}
	
			var emptyTextures = {};
			emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
			emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	
			//
	
			function init() {
	
				colorBuffer.setClear( 0, 0, 0, 1 );
				depthBuffer.setClear( 1 );
				stencilBuffer.setClear( 0 );
	
				enable( gl.DEPTH_TEST );
				setDepthFunc( LessEqualDepth );
	
				setFlipSided( false );
				setCullFace( CullFaceBack );
				enable( gl.CULL_FACE );
	
				enable( gl.BLEND );
				setBlending( NormalBlending );
	
			}
	
			function initAttributes() {
	
				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
					newAttributes[ i ] = 0;
	
				}
	
			}
	
			function enableAttribute( attribute ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== 0 ) {
	
					var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					extension.vertexAttribDivisorANGLE( attribute, 0 );
					attributeDivisors[ attribute ] = 0;
	
				}
	
			}
	
			function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
					extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;
	
				}
	
			}
	
			function disableUnusedAttributes() {
	
				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
	
					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
			}
	
			function enable( id ) {
	
				if ( capabilities[ id ] !== true ) {
	
					gl.enable( id );
					capabilities[ id ] = true;
	
				}
	
			}
	
			function disable( id ) {
	
				if ( capabilities[ id ] !== false ) {
	
					gl.disable( id );
					capabilities[ id ] = false;
	
				}
	
			}
	
			function getCompressedTextureFormats() {
	
				if ( compressedTextureFormats === null ) {
	
					compressedTextureFormats = [];
	
					if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {
	
						var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
						for ( var i = 0; i < formats.length; i ++ ) {
	
							compressedTextureFormats.push( formats[ i ] );
	
						}
	
					}
	
				}
	
				return compressedTextureFormats;
	
			}
	
			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
	
				if ( blending !== NoBlending ) {
	
					enable( gl.BLEND );
	
				} else {
	
					disable( gl.BLEND );
	
				}
	
				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
	
					if ( blending === AdditiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
						}
	
					} else if ( blending === SubtractiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
						}
	
					} else if ( blending === MultiplyBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
						}
	
					} else {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						}
	
					}
	
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
	
				}
	
				if ( blending === CustomBlending ) {
	
					blendEquationAlpha = blendEquationAlpha || blendEquation;
					blendSrcAlpha = blendSrcAlpha || blendSrc;
					blendDstAlpha = blendDstAlpha || blendDst;
	
					if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
						gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;
	
					}
	
					if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
						gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;
	
					}
	
				} else {
	
					currentBlendEquation = null;
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendEquationAlpha = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
	
				}
	
			}
	
			// TODO Deprecate
	
			function setColorWrite( colorWrite ) {
	
				colorBuffer.setMask( colorWrite );
	
			}
	
			function setDepthTest( depthTest ) {
	
				depthBuffer.setTest( depthTest );
	
			}
	
			function setDepthWrite( depthWrite ) {
	
				depthBuffer.setMask( depthWrite );
	
			}
	
			function setDepthFunc( depthFunc ) {
	
				depthBuffer.setFunc( depthFunc );
	
			}
	
			function setStencilTest( stencilTest ) {
	
				stencilBuffer.setTest( stencilTest );
	
			}
	
			function setStencilWrite( stencilWrite ) {
	
				stencilBuffer.setMask( stencilWrite );
	
			}
	
			function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {
	
				stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );
	
			}
	
			function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {
	
				stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );
	
			}
	
			//
	
			function setFlipSided( flipSided ) {
	
				if ( currentFlipSided !== flipSided ) {
	
					if ( flipSided ) {
	
						gl.frontFace( gl.CW );
	
					} else {
	
						gl.frontFace( gl.CCW );
	
					}
	
					currentFlipSided = flipSided;
	
				}
	
			}
	
			function setCullFace( cullFace ) {
	
				if ( cullFace !== CullFaceNone ) {
	
					enable( gl.CULL_FACE );
	
					if ( cullFace !== currentCullFace ) {
	
						if ( cullFace === CullFaceBack ) {
	
							gl.cullFace( gl.BACK );
	
						} else if ( cullFace === CullFaceFront ) {
	
							gl.cullFace( gl.FRONT );
	
						} else {
	
							gl.cullFace( gl.FRONT_AND_BACK );
	
						}
	
					}
	
				} else {
	
					disable( gl.CULL_FACE );
	
				}
	
				currentCullFace = cullFace;
	
			}
	
			function setLineWidth( width ) {
	
				if ( width !== currentLineWidth ) {
	
					if ( lineWidthAvailable ) gl.lineWidth( width );
	
					currentLineWidth = width;
	
				}
	
			}
	
			function setPolygonOffset( polygonOffset, factor, units ) {
	
				if ( polygonOffset ) {
	
					enable( gl.POLYGON_OFFSET_FILL );
	
					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
	
						gl.polygonOffset( factor, units );
	
						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;
	
					}
	
				} else {
	
					disable( gl.POLYGON_OFFSET_FILL );
	
				}
	
			}
	
			function getScissorTest() {
	
				return currentScissorTest;
	
			}
	
			function setScissorTest( scissorTest ) {
	
				currentScissorTest = scissorTest;
	
				if ( scissorTest ) {
	
					enable( gl.SCISSOR_TEST );
	
				} else {
	
					disable( gl.SCISSOR_TEST );
	
				}
	
			}
	
			// texture
	
			function activeTexture( webglSlot ) {
	
				if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
				if ( currentTextureSlot !== webglSlot ) {
	
					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;
	
				}
	
			}
	
			function bindTexture( webglType, webglTexture ) {
	
				if ( currentTextureSlot === null ) {
	
					activeTexture();
	
				}
	
				var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
				if ( boundTexture === undefined ) {
	
					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
				}
	
				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
	
					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;
	
				}
	
			}
	
			function compressedTexImage2D() {
	
				try {
	
					gl.compressedTexImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( error );
	
				}
	
			}
	
			function texImage2D() {
	
				try {
	
					gl.texImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( error );
	
				}
	
			}
	
			//
	
			function scissor( scissor ) {
	
				if ( currentScissor.equals( scissor ) === false ) {
	
					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );
	
				}
	
			}
	
			function viewport( viewport ) {
	
				if ( currentViewport.equals( viewport ) === false ) {
	
					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );
	
				}
	
			}
	
			//
	
			function reset() {
	
				for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
					if ( enabledAttributes[ i ] === 1 ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
				capabilities = {};
	
				compressedTextureFormats = null;
	
				currentTextureSlot = null;
				currentBoundTextures = {};
	
				currentBlending = null;
	
				currentFlipSided = null;
				currentCullFace = null;
	
				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();
	
			}
	
			return {
	
				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},
	
				init: init,
				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,
	
				setBlending: setBlending,
	
				setColorWrite: setColorWrite,
				setDepthTest: setDepthTest,
				setDepthWrite: setDepthWrite,
				setDepthFunc: setDepthFunc,
				setStencilTest: setStencilTest,
				setStencilWrite: setStencilWrite,
				setStencilFunc: setStencilFunc,
				setStencilOp: setStencilOp,
	
				setFlipSided: setFlipSided,
				setCullFace: setCullFace,
	
				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,
	
				getScissorTest: getScissorTest,
				setScissorTest: setScissorTest,
	
				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,
	
				scissor: scissor,
				viewport: viewport,
	
				reset: reset
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLCapabilities( gl, extensions, parameters ) {
	
			var maxAnisotropy;
	
			function getMaxAnisotropy() {
	
				if ( maxAnisotropy !== undefined ) return maxAnisotropy;
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension !== null ) {
	
					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
				} else {
	
					maxAnisotropy = 0;
	
				}
	
				return maxAnisotropy;
	
			}
	
			function getMaxPrecision( precision ) {
	
				if ( precision === 'highp' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
						return 'highp';
	
					}
	
					precision = 'mediump';
	
				}
	
				if ( precision === 'mediump' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
						return 'mediump';
	
					}
	
				}
	
				return 'lowp';
	
			}
	
			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );
	
			if ( maxPrecision !== precision ) {
	
				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;
	
			}
	
			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );
	
			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
			var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
			var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
			var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
			var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
			var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;
	
			return {
	
				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,
	
				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
	
				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,
	
				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,
	
				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLExtensions( gl ) {
	
			var extensions = {};
	
			return {
	
				get: function ( name ) {
	
					if ( extensions[ name ] !== undefined ) {
	
						return extensions[ name ];
	
					}
	
					var extension;
	
					switch ( name ) {
	
						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;
	
						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;
	
						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;
	
						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;
	
						case 'WEBGL_compressed_texture_etc1':
							extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
							break;
	
						default:
							extension = gl.getExtension( name );
	
					}
	
					if ( extension === null ) {
	
						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
					}
	
					extensions[ name ] = extension;
	
					return extension;
	
				}
	
			};
	
		}
	
		/**
		 * @author tschw
		 */
	
		function WebGLClipping() {
	
			var scope = this,
	
				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,
	
				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),
	
				uniform = { value: null, needsUpdate: false };
	
			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;
	
			this.init = function( planes, enableLocalClipping, camera ) {
	
				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;
	
				localClippingEnabled = enableLocalClipping;
	
				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;
	
				return enabled;
	
			};
	
			this.beginShadows = function() {
	
				renderingShadows = true;
				projectPlanes( null );
	
			};
	
			this.endShadows = function() {
	
				renderingShadows = false;
				resetGlobalState();
	
			};
	
			this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
	
				if ( ! localClippingEnabled ||
						planes === null || planes.length === 0 ||
						renderingShadows && ! clipShadows ) {
					// there's no local clipping
	
					if ( renderingShadows ) {
						// there's no global clipping
	
						projectPlanes( null );
	
					} else {
	
						resetGlobalState();
					}
	
				} else {
	
					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,
	
						dstArray = cache.clippingState || null;
	
					uniform.value = dstArray; // ensure unique state
	
					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
	
					for ( var i = 0; i !== lGlobal; ++ i ) {
	
						dstArray[ i ] = globalState[ i ];
	
					}
	
					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;
	
				}
	
	
			};
	
			function resetGlobalState() {
	
				if ( uniform.value !== globalState ) {
	
					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;
	
				}
	
				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;
	
			}
	
			function projectPlanes( planes, camera, dstOffset, skipTransform ) {
	
				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;
	
				if ( nPlanes !== 0 ) {
	
					dstArray = uniform.value;
	
					if ( skipTransform !== true || dstArray === null ) {
	
						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;
	
						viewNormalMatrix.getNormalMatrix( viewMatrix );
	
						if ( dstArray === null || dstArray.length < flatSize ) {
	
							dstArray = new Float32Array( flatSize );
	
						}
	
						for ( var i = 0, i4 = dstOffset;
											i !== nPlanes; ++ i, i4 += 4 ) {
	
							plane.copy( planes[ i ] ).
									applyMatrix4( viewMatrix, viewNormalMatrix );
	
							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;
	
						}
	
					}
	
					uniform.value = dstArray;
					uniform.needsUpdate = true;
	
				}
	
				scope.numPlanes = nPlanes;
				
				return dstArray;
	
			}
	
		}
	
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */
	
		function WebGLRenderer( parameters ) {
	
			console.log( 'THREE.WebGLRenderer', REVISION );
	
			parameters = parameters || {};
	
			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
				_context = parameters.context !== undefined ? parameters.context : null,
	
				_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
				_depth = parameters.depth !== undefined ? parameters.depth : true,
				_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
				_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
				_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
				_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	
			var lights = [];
	
			var opaqueObjects = [];
			var opaqueObjectsLastIndex = - 1;
			var transparentObjects = [];
			var transparentObjectsLastIndex = - 1;
	
			var morphInfluences = new Float32Array( 8 );
	
			var sprites = [];
			var lensFlares = [];
	
			// public properties
	
			this.domElement = _canvas;
			this.context = null;
	
			// clearing
	
			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;
	
			// scene graph
	
			this.sortObjects = true;
	
			// user-defined clipping
	
			this.clippingPlanes = [];
			this.localClippingEnabled = false;
	
			// physically based shading
	
			this.gammaFactor = 2.0;	// for backwards compatibility
			this.gammaInput = false;
			this.gammaOutput = false;
	
			// physical lights
	
			this.physicallyCorrectLights = false;
	
			// tone mapping
	
			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;
	
			// morphs
	
			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;
	
			// internal properties
	
			var _this = this,
	
				// internal state cache
	
				_currentProgram = null,
				_currentRenderTarget = null,
				_currentFramebuffer = null,
				_currentMaterialId = - 1,
				_currentGeometryProgram = '',
				_currentCamera = null,
	
				_currentScissor = new Vector4(),
				_currentScissorTest = null,
	
				_currentViewport = new Vector4(),
	
				//
	
				_usedTextureUnits = 0,
	
				//
	
				_clearColor = new Color( 0x000000 ),
				_clearAlpha = 0,
	
				_width = _canvas.width,
				_height = _canvas.height,
	
				_pixelRatio = 1,
	
				_scissor = new Vector4( 0, 0, _width, _height ),
				_scissorTest = false,
	
				_viewport = new Vector4( 0, 0, _width, _height ),
	
				// frustum
	
				_frustum = new Frustum(),
	
				// clipping
	
				_clipping = new WebGLClipping(),
				_clippingEnabled = false,
				_localClippingEnabled = false,
	
				_sphere = new Sphere(),
	
				// camera matrices cache
	
				_projScreenMatrix = new Matrix4(),
	
				_vector3 = new Vector3(),
				_matrix4 = new Matrix4(),
				_matrix42 = new Matrix4(),
	
				// light arrays cache
	
				_lights = {
	
					hash: '',
	
				ambient: [ 0, 0, 0 ],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				rectArea: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
	
					shadows: []
	
				},
	
				// info
	
				_infoRender = {
	
					calls: 0,
					vertices: 0,
					faces: 0,
					points: 0
	
				};
	
			this.info = {
	
				render: _infoRender,
				memory: {
	
					geometries: 0,
					textures: 0
	
				},
				programs: null
	
			};
	
	
			// initialize
	
			var _gl;
	
			try {
	
				var attributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};
	
				_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
				if ( _gl === null ) {
	
					if ( _canvas.getContext( 'webgl' ) !== null ) {
	
						throw 'Error creating WebGL context with your selected attributes.';
	
					} else {
	
						throw 'Error creating WebGL context.';
	
					}
	
				}
	
				// Some experimental-webgl implementations do not have getShaderPrecisionFormat
	
				if ( _gl.getShaderPrecisionFormat === undefined ) {
	
					_gl.getShaderPrecisionFormat = function () {
	
						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
	
					};
	
				}
	
				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
			} catch ( error ) {
	
				console.error( 'THREE.WebGLRenderer: ' + error );
	
			}
	
			var extensions = new WebGLExtensions( _gl );
	
			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extensions.get( 'OES_element_index_uint' ) ) {
	
				BufferGeometry.MaxIndex = 4294967296;
	
			}
	
			var capabilities = new WebGLCapabilities( _gl, extensions, parameters );
	
			var state = new WebGLState( _gl, extensions, paramThreeToGL );
			var properties = new WebGLProperties();
			var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
			var objects = new WebGLObjects( _gl, properties, this.info );
			var programCache = new WebGLPrograms( this, capabilities );
			var lightCache = new WebGLLights();
	
			this.info.programs = programCache.programs;
	
			var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
			//
	
			var backgroundPlaneCamera, backgroundPlaneMesh;
			var backgroundBoxCamera, backgroundBoxMesh;
	
			//
	
			function getTargetPixelRatio() {
	
				return _currentRenderTarget === null ? _pixelRatio : 1;
	
			}
	
			function setDefaultGLState() {
	
				state.init();
	
				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
			}
	
			function resetGLState() {
	
				_currentProgram = null;
				_currentCamera = null;
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
	
				state.reset();
	
			}
	
			setDefaultGLState();
	
			this.context = _gl;
			this.capabilities = capabilities;
			this.extensions = extensions;
			this.properties = properties;
			this.state = state;
	
			// shadow map
	
			var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );
	
			this.shadowMap = shadowMap;
	
	
			// Plugins
	
			var spritePlugin = new SpritePlugin( this, sprites );
			var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );
	
			// API
	
			this.getContext = function () {
	
				return _gl;
	
			};
	
			this.getContextAttributes = function () {
	
				return _gl.getContextAttributes();
	
			};
	
			this.forceContextLoss = function () {
	
				extensions.get( 'WEBGL_lose_context' ).loseContext();
	
			};
	
			this.getMaxAnisotropy = function () {
	
				return capabilities.getMaxAnisotropy();
	
			};
	
			this.getPrecision = function () {
	
				return capabilities.precision;
	
			};
	
			this.getPixelRatio = function () {
	
				return _pixelRatio;
	
			};
	
			this.setPixelRatio = function ( value ) {
	
				if ( value === undefined ) return;
	
				_pixelRatio = value;
	
				this.setSize( _viewport.z, _viewport.w, false );
	
			};
	
			this.getSize = function () {
	
				return {
					width: _width,
					height: _height
				};
	
			};
	
			this.setSize = function ( width, height, updateStyle ) {
	
				_width = width;
				_height = height;
	
				_canvas.width = width * _pixelRatio;
				_canvas.height = height * _pixelRatio;
	
				if ( updateStyle !== false ) {
	
					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';
	
				}
	
				this.setViewport( 0, 0, width, height );
	
			};
	
			this.setViewport = function ( x, y, width, height ) {
	
				state.viewport( _viewport.set( x, y, width, height ) );
	
			};
	
			this.setScissor = function ( x, y, width, height ) {
	
				state.scissor( _scissor.set( x, y, width, height ) );
	
			};
	
			this.setScissorTest = function ( boolean ) {
	
				state.setScissorTest( _scissorTest = boolean );
	
			};
	
			// Clearing
	
			this.getClearColor = function () {
	
				return _clearColor;
	
			};
	
			this.setClearColor = function ( color, alpha ) {
	
				_clearColor.set( color );
	
				_clearAlpha = alpha !== undefined ? alpha : 1;
	
				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
			};
	
			this.getClearAlpha = function () {
	
				return _clearAlpha;
	
			};
	
			this.setClearAlpha = function ( alpha ) {
	
				_clearAlpha = alpha;
	
				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
			};
	
			this.clear = function ( color, depth, stencil ) {
	
				var bits = 0;
	
				if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
				if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
				_gl.clear( bits );
	
			};
	
			this.clearColor = function () {
	
				this.clear( true, false, false );
	
			};
	
			this.clearDepth = function () {
	
				this.clear( false, true, false );
	
			};
	
			this.clearStencil = function () {
	
				this.clear( false, false, true );
	
			};
	
			this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );
	
			};
	
			// Reset
	
			this.resetGLState = resetGLState;
	
			this.dispose = function() {
	
				transparentObjects = [];
				transparentObjectsLastIndex = -1;
				opaqueObjects = [];
				opaqueObjectsLastIndex = -1;
	
				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
			};
	
			// Events
	
			function onContextLost( event ) {
	
				event.preventDefault();
	
				resetGLState();
				setDefaultGLState();
	
				properties.clear();
	
			}
	
			function onMaterialDispose( event ) {
	
				var material = event.target;
	
				material.removeEventListener( 'dispose', onMaterialDispose );
	
				deallocateMaterial( material );
	
			}
	
			// Buffer deallocation
	
			function deallocateMaterial( material ) {
	
				releaseMaterialProgramReference( material );
	
				properties.delete( material );
	
			}
	
	
			function releaseMaterialProgramReference( material ) {
	
				var programInfo = properties.get( material ).program;
	
				material.program = undefined;
	
				if ( programInfo !== undefined ) {
	
					programCache.releaseProgram( programInfo );
	
				}
	
			}
	
			// Buffer rendering
	
			this.renderBufferImmediate = function ( object, program, material ) {
	
				state.initAttributes();
	
				var buffers = properties.get( object );
	
				if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
				if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
				if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
				if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
				var attributes = program.getAttributes();
	
				if ( object.hasPositions ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasNormals ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
					if ( ! material.isMeshPhongMaterial &&
						! material.isMeshStandardMaterial &&
						! material.isMeshNormalMaterial &&
						material.shading === FlatShading ) {
	
						for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
							var array = object.normalArray;
	
							var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
							var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
							var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
							array[ i + 0 ] = nx;
							array[ i + 1 ] = ny;
							array[ i + 2 ] = nz;
	
							array[ i + 3 ] = nx;
							array[ i + 4 ] = ny;
							array[ i + 5 ] = nz;
	
							array[ i + 6 ] = nx;
							array[ i + 7 ] = ny;
							array[ i + 8 ] = nz;
	
						}
	
					}
	
					_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.normal );
	
					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasUvs && material.map ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.uv );
	
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasColors && material.vertexColors !== NoColors ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.color );
	
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				state.disableUnusedAttributes();
	
				_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
				object.count = 0;
	
			};
	
			this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
				setMaterial( material );
	
				var program = setProgram( camera, fog, material, object );
	
				var updateBuffers = false;
				var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	
				if ( geometryProgram !== _currentGeometryProgram ) {
	
					_currentGeometryProgram = geometryProgram;
					updateBuffers = true;
	
				}
	
				// morph targets
	
				var morphTargetInfluences = object.morphTargetInfluences;
	
				if ( morphTargetInfluences !== undefined ) {
	
					var activeInfluences = [];
	
					for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
						var influence = morphTargetInfluences[ i ];
						activeInfluences.push( [ influence, i ] );
	
					}
	
					activeInfluences.sort( absNumericalSort );
	
					if ( activeInfluences.length > 8 ) {
	
						activeInfluences.length = 8;
	
					}
	
					var morphAttributes = geometry.morphAttributes;
	
					for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
						var influence = activeInfluences[ i ];
						morphInfluences[ i ] = influence[ 0 ];
	
						if ( influence[ 0 ] !== 0 ) {
	
							var index = influence[ 1 ];
	
							if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
							if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
						} else {
	
							if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
							if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
						}
	
					}
	
					for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {
	
						morphInfluences[ i ] = 0.0;
	
					}
	
					program.getUniforms().setValue(
						_gl, 'morphTargetInfluences', morphInfluences );
	
					updateBuffers = true;
	
				}
	
				//
	
				var index = geometry.index;
				var position = geometry.attributes.position;
				var rangeFactor = 1;
	
				if ( material.wireframe === true ) {
	
					index = objects.getWireframeAttribute( geometry );
					rangeFactor = 2;
	
				}
	
				var renderer;
	
				if ( index !== null ) {
	
					renderer = indexedBufferRenderer;
					renderer.setIndex( index );
	
				} else {
	
					renderer = bufferRenderer;
	
				}
	
				if ( updateBuffers ) {
	
					setupVertexAttributes( material, program, geometry );
	
					if ( index !== null ) {
	
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );
	
					}
	
				}
	
				//
	
				var dataCount = 0;
	
				if ( index !== null ) {
	
					dataCount = index.count;
	
				} else if ( position !== undefined ) {
	
					dataCount = position.count;
	
				}
	
				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;
	
				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;
	
				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
				if ( drawCount === 0 ) return;
	
				//
	
				if ( object.isMesh ) {
	
					if ( material.wireframe === true ) {
	
						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );
	
					} else {
	
						switch ( object.drawMode ) {
	
							case TrianglesDrawMode:
								renderer.setMode( _gl.TRIANGLES );
								break;
	
							case TriangleStripDrawMode:
								renderer.setMode( _gl.TRIANGLE_STRIP );
								break;
	
							case TriangleFanDrawMode:
								renderer.setMode( _gl.TRIANGLE_FAN );
								break;
	
						}
	
					}
	
	
				} else if ( object.isLine ) {
	
					var lineWidth = material.linewidth;
	
					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
					state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
					if ( object.isLineSegments ) {
	
						renderer.setMode( _gl.LINES );
	
					} else {
	
						renderer.setMode( _gl.LINE_STRIP );
	
					}
	
				} else if ( object.isPoints ) {
	
					renderer.setMode( _gl.POINTS );
	
				}
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					if ( geometry.maxInstancedCount > 0 ) {
	
						renderer.renderInstances( geometry, drawStart, drawCount );
	
					}
	
				} else {
	
					renderer.render( drawStart, drawCount );
	
				}
	
			};
	
			function setupVertexAttributes( material, program, geometry, startIndex ) {
	
				var extension;
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					if ( extension === null ) {
	
						console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;
	
					}
	
				}
	
				if ( startIndex === undefined ) startIndex = 0;
	
				state.initAttributes();
	
				var geometryAttributes = geometry.attributes;
	
				var programAttributes = program.getAttributes();
	
				var materialDefaultAttributeValues = material.defaultAttributeValues;
	
				for ( var name in programAttributes ) {
	
					var programAttribute = programAttributes[ name ];
	
					if ( programAttribute >= 0 ) {
	
						var geometryAttribute = geometryAttributes[ name ];
	
						if ( geometryAttribute !== undefined ) {
	
							var normalized = geometryAttribute.normalized;
							var size = geometryAttribute.itemSize;
	
							var attributeProperties = objects.getAttributeProperties( geometryAttribute );
	
							var buffer = attributeProperties.__webglBuffer;
							var type = attributeProperties.type;
							var bytesPerElement = attributeProperties.bytesPerElement;
	
							if ( geometryAttribute.isInterleavedBufferAttribute ) {
	
								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;
	
								if ( data && data.isInstancedInterleavedBuffer ) {
	
									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );
	
							} else {
	
								if ( geometryAttribute.isInstancedBufferAttribute ) {
	
									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );
	
							}
	
						} else if ( materialDefaultAttributeValues !== undefined ) {
	
							var value = materialDefaultAttributeValues[ name ];
	
							if ( value !== undefined ) {
	
								switch ( value.length ) {
	
									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;
	
									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;
	
									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;
	
									default:
										_gl.vertexAttrib1fv( programAttribute, value );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				state.disableUnusedAttributes();
	
			}
	
			// Sorting
	
			function absNumericalSort( a, b ) {
	
				return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );
	
			}
	
			function painterSortStable( a, b ) {
	
				if ( a.object.renderOrder !== b.object.renderOrder ) {
	
					return a.object.renderOrder - b.object.renderOrder;
	
				} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {
	
					return a.material.program.id - b.material.program.id;
	
				} else if ( a.material.id !== b.material.id ) {
	
					return a.material.id - b.material.id;
	
				} else if ( a.z !== b.z ) {
	
					return a.z - b.z;
	
				} else {
	
					return a.id - b.id;
	
				}
	
			}
	
			function reversePainterSortStable( a, b ) {
	
				if ( a.object.renderOrder !== b.object.renderOrder ) {
	
					return a.object.renderOrder - b.object.renderOrder;
	
				} if ( a.z !== b.z ) {
	
					return b.z - a.z;
	
				} else {
	
					return a.id - b.id;
	
				}
	
			}
	
			// Rendering
	
			this.render = function ( scene, camera, renderTarget, forceClear ) {
	
				if ( camera !== undefined && camera.isCamera !== true ) {
	
					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;
	
				}
	
				// reset caching for this frame
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
				_currentCamera = null;
	
				// update scene graph
	
				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
				// update camera matrices and frustum
	
				if ( camera.parent === null ) camera.updateMatrixWorld();
	
				camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
	
				lights.length = 0;
	
				opaqueObjectsLastIndex = - 1;
				transparentObjectsLastIndex = - 1;
	
				sprites.length = 0;
				lensFlares.length = 0;
	
				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
	
				projectObject( scene, camera );
	
				opaqueObjects.length = opaqueObjectsLastIndex + 1;
				transparentObjects.length = transparentObjectsLastIndex + 1;
	
				if ( _this.sortObjects === true ) {
	
					opaqueObjects.sort( painterSortStable );
					transparentObjects.sort( reversePainterSortStable );
	
				}
	
				//
	
				if ( _clippingEnabled ) _clipping.beginShadows();
	
				setupShadows( lights );
	
				shadowMap.render( scene, camera );
	
				setupLights( lights, camera );
	
				if ( _clippingEnabled ) _clipping.endShadows();
	
				//
	
				_infoRender.calls = 0;
				_infoRender.vertices = 0;
				_infoRender.faces = 0;
				_infoRender.points = 0;
	
				if ( renderTarget === undefined ) {
	
					renderTarget = null;
	
				}
	
				this.setRenderTarget( renderTarget );
	
				//
	
				var background = scene.background;
	
				if ( background === null ) {
	
					state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
				} else if ( background && background.isColor ) {
	
					state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );
					forceClear = true;
	
				}
	
				if ( this.autoClear || forceClear ) {
	
					this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
				}
	
				if ( background && background.isCubeTexture ) {
	
					if ( backgroundBoxCamera === undefined ) {
	
						backgroundBoxCamera = new PerspectiveCamera();
	
						backgroundBoxMesh = new Mesh(
							new BoxBufferGeometry( 5, 5, 5 ),
							new ShaderMaterial( {
								uniforms: ShaderLib.cube.uniforms,
								vertexShader: ShaderLib.cube.vertexShader,
								fragmentShader: ShaderLib.cube.fragmentShader,
								side: BackSide,
								depthTest: false,
								depthWrite: false,
								fog: false
							} )
						);
	
					}
	
					backgroundBoxCamera.projectionMatrix.copy( camera.projectionMatrix );
	
					backgroundBoxCamera.matrixWorld.extractRotation( camera.matrixWorld );
					backgroundBoxCamera.matrixWorldInverse.getInverse( backgroundBoxCamera.matrixWorld );
	
	
					backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
					backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundBoxCamera.matrixWorldInverse, backgroundBoxMesh.matrixWorld );
	
					objects.update( backgroundBoxMesh );
	
					_this.renderBufferDirect( backgroundBoxCamera, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );
	
				} else if ( background && background.isTexture ) {
	
					if ( backgroundPlaneCamera === undefined ) {
	
						backgroundPlaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	
						backgroundPlaneMesh = new Mesh(
							new PlaneBufferGeometry( 2, 2 ),
							new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
						);
	
					}
	
					backgroundPlaneMesh.material.map = background;
	
					objects.update( backgroundPlaneMesh );
	
					_this.renderBufferDirect( backgroundPlaneCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );
	
				}
	
				//
	
				if ( scene.overrideMaterial ) {
	
					var overrideMaterial = scene.overrideMaterial;
	
					renderObjects( opaqueObjects, scene, camera, overrideMaterial );
					renderObjects( transparentObjects, scene, camera, overrideMaterial );
	
				} else {
	
					// opaque pass (front-to-back order)
	
					state.setBlending( NoBlending );
					renderObjects( opaqueObjects, scene, camera );
	
					// transparent pass (back-to-front order)
	
					renderObjects( transparentObjects, scene, camera );
	
				}
	
				// custom render plugins (post pass)
	
				spritePlugin.render( scene, camera );
				lensFlarePlugin.render( scene, camera, _currentViewport );
	
				// Generate mipmap if we're using any kind of mipmap filtering
	
				if ( renderTarget ) {
	
					textures.updateRenderTargetMipmap( renderTarget );
	
				}
	
				// Ensure depth buffer writing is enabled so it can be cleared on next render
	
				state.setDepthTest( true );
				state.setDepthWrite( true );
				state.setColorWrite( true );
	
				// _gl.finish();
	
			};
	
			function pushRenderItem( object, geometry, material, z, group ) {
	
				var array, index;
	
				// allocate the next position in the appropriate array
	
				if ( material.transparent ) {
	
					array = transparentObjects;
					index = ++ transparentObjectsLastIndex;
	
				} else {
	
					array = opaqueObjects;
					index = ++ opaqueObjectsLastIndex;
	
				}
	
				// recycle existing render item or grow the array
	
				var renderItem = array[ index ];
	
				if ( renderItem !== undefined ) {
	
					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.z = _vector3.z;
					renderItem.group = group;
	
				} else {
	
					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						z: _vector3.z,
						group: group
					};
	
					// assert( index === array.length );
					array.push( renderItem );
	
				}
	
			}
	
			// TODO Duplicated code (Frustum)
	
			function isObjectViewable( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
	
				_sphere.copy( geometry.boundingSphere ).
				applyMatrix4( object.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSpriteViewable( sprite ) {
	
				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSphereViewable( sphere ) {
	
				if ( ! _frustum.intersectsSphere( sphere ) ) return false;
	
				var numPlanes = _clipping.numPlanes;
	
				if ( numPlanes === 0 ) return true;
	
				var planes = _this.clippingPlanes,
	
					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;
	
				do {
	
					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
	
				} while ( ++ i !== numPlanes );
	
				return true;
	
			}
	
			function projectObject( object, camera ) {
	
				if ( object.visible === false ) return;
	
				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;
	
				if ( visible ) {
	
					if ( object.isLight ) {
	
						lights.push( object );
	
					} else if ( object.isSprite ) {
	
						if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {
	
							sprites.push( object );
	
						}
	
					} else if ( object.isLensFlare ) {
	
						lensFlares.push( object );
	
					} else if ( object.isImmediateRenderObject ) {
	
						if ( _this.sortObjects === true ) {
	
							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyMatrix4( _projScreenMatrix );
	
						}
	
						pushRenderItem( object, null, object.material, _vector3.z, null );
	
					} else if ( object.isMesh || object.isLine || object.isPoints ) {
	
						if ( object.isSkinnedMesh ) {
	
							object.skeleton.update();
	
						}
	
						if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {
	
							var material = object.material;
	
							if ( material.visible === true ) {
	
								if ( _this.sortObjects === true ) {
	
									_vector3.setFromMatrixPosition( object.matrixWorld );
									_vector3.applyMatrix4( _projScreenMatrix );
	
								}
	
								var geometry = objects.update( object );
	
								if ( material.isMultiMaterial ) {
	
									var groups = geometry.groups;
									var materials = material.materials;
	
									for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
										var group = groups[ i ];
										var groupMaterial = materials[ group.materialIndex ];
	
										if ( groupMaterial.visible === true ) {
	
											pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );
	
										}
	
									}
	
								} else {
	
									pushRenderItem( object, geometry, material, _vector3.z, null );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					projectObject( children[ i ], camera );
	
				}
	
			}
	
			function renderObjects( renderList, scene, camera, overrideMaterial ) {
	
				for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
					var renderItem = renderList[ i ];
	
					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;
	
					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
					object.onBeforeRender( _this, scene, camera, geometry, material, group );
	
					if ( object.isImmediateRenderObject ) {
	
						setMaterial( material );
	
						var program = setProgram( camera, scene.fog, material, object );
	
						_currentGeometryProgram = '';
	
						object.render( function ( object ) {
	
							_this.renderBufferImmediate( object, program, material );
	
						} );
	
					} else {
	
						_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );
	
					}
	
					object.onAfterRender( _this, scene, camera, geometry, material, group );
	
	
				}
	
			}
	
			function initMaterial( material, fog, object ) {
	
				var materialProperties = properties.get( material );
	
				var parameters = programCache.getParameters(
					material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );
	
				var code = programCache.getProgramCode( material, parameters );
	
				var program = materialProperties.program;
				var programChange = true;
	
				if ( program === undefined ) {
	
					// new material
					material.addEventListener( 'dispose', onMaterialDispose );
	
				} else if ( program.code !== code ) {
	
					// changed glsl or parameters
					releaseMaterialProgramReference( material );
	
				} else if ( parameters.shaderID !== undefined ) {
	
					// same glsl and uniform list
					return;
	
				} else {
	
					// only rebuild uniform list
					programChange = false;
	
				}
	
				if ( programChange ) {
	
					if ( parameters.shaderID ) {
	
						var shader = ShaderLib[ parameters.shaderID ];
	
						materialProperties.__webglShader = {
							name: material.type,
							uniforms: UniformsUtils.clone( shader.uniforms ),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader
						};
	
					} else {
	
						materialProperties.__webglShader = {
							name: material.type,
							uniforms: material.uniforms,
							vertexShader: material.vertexShader,
							fragmentShader: material.fragmentShader
						};
	
					}
	
					material.__webglShader = materialProperties.__webglShader;
	
					program = programCache.acquireProgram( material, parameters, code );
	
					materialProperties.program = program;
					material.program = program;
	
				}
	
				var attributes = program.getAttributes();
	
				if ( material.morphTargets ) {
	
					material.numSupportedMorphTargets = 0;
	
					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
						if ( attributes[ 'morphTarget' + i ] >= 0 ) {
	
							material.numSupportedMorphTargets ++;
	
						}
	
					}
	
				}
	
				if ( material.morphNormals ) {
	
					material.numSupportedMorphNormals = 0;
	
					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
						if ( attributes[ 'morphNormal' + i ] >= 0 ) {
	
							material.numSupportedMorphNormals ++;
	
						}
	
					}
	
				}
	
				var uniforms = materialProperties.__webglShader.uniforms;
	
				if ( ! material.isShaderMaterial &&
					! material.isRawShaderMaterial ||
					material.clipping === true ) {
	
					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;
	
				}
	
				materialProperties.fog = fog;
	
				// store the light setup it was created for
	
				materialProperties.lightsHash = _lights.hash;
	
				if ( material.lights ) {
	
					// wire up the material to this renderer's lighting state
	
					uniforms.ambientLightColor.value = _lights.ambient;
					uniforms.directionalLights.value = _lights.directional;
					uniforms.spotLights.value = _lights.spot;
					uniforms.rectAreaLights.value = _lights.rectArea;
					uniforms.pointLights.value = _lights.point;
					uniforms.hemisphereLights.value = _lights.hemi;
	
					uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
					uniforms.spotShadowMap.value = _lights.spotShadowMap;
					uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
					uniforms.pointShadowMap.value = _lights.pointShadowMap;
					uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms
	
				}
	
				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
						WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
	
				materialProperties.uniformsList = uniformsList;
	
			}
	
			function setMaterial( material ) {
	
				material.side === DoubleSide
					? state.disable( _gl.CULL_FACE )
					: state.enable( _gl.CULL_FACE );
	
				state.setFlipSided( material.side === BackSide );
	
				material.transparent === true
					? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
					: state.setBlending( NoBlending );
	
				state.setDepthFunc( material.depthFunc );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
				state.setColorWrite( material.colorWrite );
				state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
			}
	
			function setProgram( camera, fog, material, object ) {
	
				_usedTextureUnits = 0;
	
				var materialProperties = properties.get( material );
	
				if ( _clippingEnabled ) {
	
					if ( _localClippingEnabled || camera !== _currentCamera ) {
	
						var useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;
	
						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
							material.clippingPlanes, material.clipIntersection, material.clipShadows,
							camera, materialProperties, useCache );
	
					}
	
				}
	
				if ( material.needsUpdate === false ) {
	
					if ( materialProperties.program === undefined ) {
	
						material.needsUpdate = true;
	
					} else if ( material.fog && materialProperties.fog !== fog ) {
	
						material.needsUpdate = true;
	
					} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {
	
						material.needsUpdate = true;
	
					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
						materialProperties.numIntersection  !== _clipping.numIntersection ) ) {
	
						material.needsUpdate = true;
	
					}
	
				}
	
				if ( material.needsUpdate ) {
	
					initMaterial( material, fog, object );
					material.needsUpdate = false;
	
				}
	
				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;
	
				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.__webglShader.uniforms;
	
				if ( program.id !== _currentProgram ) {
	
					_gl.useProgram( program.program );
					_currentProgram = program.id;
	
					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;
	
				}
	
				if ( material.id !== _currentMaterialId ) {
	
					_currentMaterialId = material.id;
	
					refreshMaterial = true;
	
				}
	
				if ( refreshProgram || camera !== _currentCamera ) {
	
					p_uniforms.set( _gl, camera, 'projectionMatrix' );
	
					if ( capabilities.logarithmicDepthBuffer ) {
	
						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
					}
	
	
					if ( camera !== _currentCamera ) {
	
						_currentCamera = camera;
	
						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:
	
						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done
	
					}
	
					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)
	
					if ( material.isShaderMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.envMap ) {
	
						var uCamPos = p_uniforms.map.cameraPosition;
	
						if ( uCamPos !== undefined ) {
	
							uCamPos.setValue( _gl,
								_vector3.setFromMatrixPosition( camera.matrixWorld ) );
	
						}
	
					}
	
					if ( material.isMeshPhongMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ||
						material.skinning ) {
	
						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
	
					}
	
					p_uniforms.set( _gl, _this, 'toneMappingExposure' );
					p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );
	
				}
	
				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// not sure why, but otherwise weird things happen
	
				if ( material.skinning ) {
	
					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
	
					var skeleton = object.skeleton;
	
					if ( skeleton ) {
	
						if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {
	
							p_uniforms.set( _gl, skeleton, 'boneTexture' );
							p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
							p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );
	
						} else {
	
							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
	
						}
	
					}
	
				}
	
				if ( refreshMaterial ) {
	
					if ( material.lights ) {
	
						// the current material requires lighting info
	
						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required
	
						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
					}
	
					// refresh uniforms common to several materials
	
					if ( fog && material.fog ) {
	
						refreshUniformsFog( m_uniforms, fog );
	
					}
	
					if ( material.isMeshBasicMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.isMeshNormalMaterial ||
						material.isMeshDepthMaterial ) {
	
						refreshUniformsCommon( m_uniforms, material );
	
					}
	
					// refresh single material specific uniforms
	
					if ( material.isLineBasicMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
	
					} else if ( material.isLineDashedMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
						refreshUniformsDash( m_uniforms, material );
	
					} else if ( material.isPointsMaterial ) {
	
						refreshUniformsPoints( m_uniforms, material );
	
					} else if ( material.isMeshLambertMaterial ) {
	
						refreshUniformsLambert( m_uniforms, material );
	
					} else if ( material.isMeshToonMaterial ) {
	
						refreshUniformsToon( m_uniforms, material );
	
					} else if ( material.isMeshPhongMaterial ) {
	
						refreshUniformsPhong( m_uniforms, material );
	
					} else if ( material.isMeshPhysicalMaterial ) {
	
						refreshUniformsPhysical( m_uniforms, material );
	
					} else if ( material.isMeshStandardMaterial ) {
	
						refreshUniformsStandard( m_uniforms, material );
	
					} else if ( material.isMeshDepthMaterial ) {
	
						if ( material.displacementMap ) {
	
							m_uniforms.displacementMap.value = material.displacementMap;
							m_uniforms.displacementScale.value = material.displacementScale;
							m_uniforms.displacementBias.value = material.displacementBias;
	
						}
	
					} else if ( material.isMeshNormalMaterial ) {
	
						refreshUniformsNormal( m_uniforms, material );
	
					}
	
					// RectAreaLight Texture
					// TODO (mrdoob): Find a nicer implementation
	
					if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE;
					if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE;
	
					WebGLUniforms.upload(
						_gl, materialProperties.uniformsList, m_uniforms, _this );
	
				}
	
	
				// common matrices
	
				p_uniforms.set( _gl, object, 'modelViewMatrix' );
				p_uniforms.set( _gl, object, 'normalMatrix' );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
	
				return program;
	
			}
	
			// Uniforms (refresh uniforms objects)
	
			function refreshUniformsCommon( uniforms, material ) {
	
				uniforms.opacity.value = material.opacity;
	
				uniforms.diffuse.value = material.color;
	
				if ( material.emissive ) {
	
					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
				}
	
				uniforms.map.value = material.map;
				uniforms.specularMap.value = material.specularMap;
				uniforms.alphaMap.value = material.alphaMap;
	
				if ( material.lightMap ) {
	
					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
				}
	
				if ( material.aoMap ) {
	
					uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
				}
	
				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map
	
				var uvScaleMap;
	
				if ( material.map ) {
	
					uvScaleMap = material.map;
	
				} else if ( material.specularMap ) {
	
					uvScaleMap = material.specularMap;
	
				} else if ( material.displacementMap ) {
	
					uvScaleMap = material.displacementMap;
	
				} else if ( material.normalMap ) {
	
					uvScaleMap = material.normalMap;
	
				} else if ( material.bumpMap ) {
	
					uvScaleMap = material.bumpMap;
	
				} else if ( material.roughnessMap ) {
	
					uvScaleMap = material.roughnessMap;
	
				} else if ( material.metalnessMap ) {
	
					uvScaleMap = material.metalnessMap;
	
				} else if ( material.alphaMap ) {
	
					uvScaleMap = material.alphaMap;
	
				} else if ( material.emissiveMap ) {
	
					uvScaleMap = material.emissiveMap;
	
				}
	
				if ( uvScaleMap !== undefined ) {
	
					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {
	
						uvScaleMap = uvScaleMap.texture;
	
					}
	
					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
				uniforms.envMap.value = material.envMap;
	
				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;
	
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;
	
			}
	
			function refreshUniformsLine( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
	
			}
	
			function refreshUniformsDash( uniforms, material ) {
	
				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;
	
			}
	
			function refreshUniformsPoints( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;
	
				uniforms.map.value = material.map;
	
				if ( material.map !== null ) {
	
					var offset = material.map.offset;
					var repeat = material.map.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
			}
	
			function refreshUniformsFog( uniforms, fog ) {
	
				uniforms.fogColor.value = fog.color;
	
				if ( fog.isFog ) {
	
					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;
	
				} else if ( fog.isFogExp2 ) {
	
					uniforms.fogDensity.value = fog.density;
	
				}
	
			}
	
			function refreshUniformsLambert( uniforms, material ) {
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
			}
	
			function refreshUniformsPhong( uniforms, material ) {
	
				uniforms.specular.value = material.specular;
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
			}
	
			function refreshUniformsToon( uniforms, material ) {
	
				refreshUniformsPhong( uniforms, material );
	
				if ( material.gradientMap ) {
	
					uniforms.gradientMap.value = material.gradientMap;
	
				}
	
			}
	
			function refreshUniformsStandard( uniforms, material ) {
	
				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;
	
				if ( material.roughnessMap ) {
	
					uniforms.roughnessMap.value = material.roughnessMap;
	
				}
	
				if ( material.metalnessMap ) {
	
					uniforms.metalnessMap.value = material.metalnessMap;
	
				}
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
				if ( material.envMap ) {
	
					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;
	
				}
	
			}
	
			function refreshUniformsPhysical( uniforms, material ) {
	
				uniforms.clearCoat.value = material.clearCoat;
				uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	
				refreshUniformsStandard( uniforms, material );
	
			}
	
			function refreshUniformsNormal( uniforms, material ) {
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
			}
	
			// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
			function markUniformsLightsNeedsUpdate( uniforms, value ) {
	
				uniforms.ambientLightColor.needsUpdate = value;
	
				uniforms.directionalLights.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;
	
			}
	
			// Lighting
	
			function setupShadows( lights ) {
	
				var lightShadowsLength = 0;
	
				for ( var i = 0, l = lights.length; i < l; i ++ ) {
	
					var light = lights[ i ];
	
					if ( light.castShadow ) {
	
						_lights.shadows[ lightShadowsLength ++ ] = light;
	
					}
	
				}
	
				_lights.shadows.length = lightShadowsLength;
	
			}
	
			function setupLights( lights, camera ) {
	
				var l, ll, light,
					r = 0, g = 0, b = 0,
					color,
					intensity,
					distance,
					shadowMap,
	
					viewMatrix = camera.matrixWorldInverse,
	
				directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				rectAreaLength = 0,
				hemiLength = 0;
	
				for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
					light = lights[ l ];
	
					color = light.color;
					intensity = light.intensity;
					distance = light.distance;
	
					shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
	
					if ( light.isAmbientLight ) {
	
						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;
	
					} else if ( light.isDirectionalLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.directionalShadowMap[ directionalLength ] = shadowMap;
						_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
						_lights.directional[ directionalLength ++ ] = uniforms;
	
					} else if ( light.isSpotLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.spotShadowMap[ spotLength ] = shadowMap;
						_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
						_lights.spot[ spotLength ++ ] = uniforms;
	
					} else if ( light.isRectAreaLight ) {
	
						var uniforms = lightCache.get( light );
	
						// (a) intensity controls irradiance of entire light
						uniforms.color
							.copy( color )
							.multiplyScalar( intensity / ( light.width * light.height ) );
	
						// (b) intensity controls the radiance per light area
						// uniforms.color.copy( color ).multiplyScalar( intensity );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						// extract local rotation of light to derive width/height half vectors
						_matrix42.identity();
						_matrix4.copy( light.matrixWorld );
						_matrix4.premultiply( viewMatrix );
						_matrix42.extractRotation( _matrix4 );
	
						uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
						uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );
	
						uniforms.halfWidth.applyMatrix4( _matrix42 );
						uniforms.halfHeight.applyMatrix4( _matrix42 );
	
						// TODO (abelnation): RectAreaLight distance?
						// uniforms.distance = distance;
	
						_lights.rectArea[ rectAreaLength ++ ] = uniforms;
	
					} else if ( light.isPointLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.pointShadowMap[ pointLength ] = shadowMap;
	
						if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {
	
							_lights.pointShadowMatrix[ pointLength ] = new Matrix4();
	
						}
	
						// for point lights we set the shadow matrix to be a translation-only matrix
						// equal to inverse of the light's position
						_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
						_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );
	
						_lights.point[ pointLength ++ ] = uniforms;
	
					} else if ( light.isHemisphereLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();
	
						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
						_lights.hemi[ hemiLength ++ ] = uniforms;
	
					}
	
				}
	
				_lights.ambient[ 0 ] = r;
				_lights.ambient[ 1 ] = g;
				_lights.ambient[ 2 ] = b;
	
				_lights.directional.length = directionalLength;
				_lights.spot.length = spotLength;
				_lights.rectArea.length = rectAreaLength;
				_lights.point.length = pointLength;
				_lights.hemi.length = hemiLength;
	
				// TODO (sam-g-steel) why aren't we using join
				_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;
	
			}
	
			// GL state setting
	
			this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
				state.setCullFace( cullFace );
				state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );
	
			};
	
			// Textures
	
			function allocTextureUnit() {
	
				var textureUnit = _usedTextureUnits;
	
				if ( textureUnit >= capabilities.maxTextures ) {
	
					console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
				}
	
				_usedTextureUnits += 1;
	
				return textureUnit;
	
			}
	
			this.allocTextureUnit = allocTextureUnit;
	
			// this.setTexture2D = setTexture2D;
			this.setTexture2D = ( function() {
	
				var warned = false;
	
				// backwards compatibility: peel texture.texture
				return function setTexture2D( texture, slot ) {
	
					if ( texture && texture.isWebGLRenderTarget ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTexture = ( function() {
	
				var warned = false;
	
				return function setTexture( texture, slot ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
						warned = true;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTextureCube = ( function() {
	
				var warned = false;
	
				return function setTextureCube( texture, slot ) {
	
					// backwards compatibility: peel texture.texture
					if ( texture && texture.isWebGLRenderTargetCube ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
					// TODO: unify these code paths
					if ( ( texture && texture.isCubeTexture ) ||
						( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
						// CompressedTexture can have Array in image :/
	
						// this function alone should take care of cube textures
						textures.setTextureCube( texture, slot );
	
					} else {
	
						// assumed: texture property of THREE.WebGLRenderTargetCube
	
						textures.setTextureCubeDynamic( texture, slot );
	
					}
	
				};
	
			}() );
	
			this.getCurrentRenderTarget = function() {
	
				return _currentRenderTarget;
	
			};
	
			this.setRenderTarget = function ( renderTarget ) {
	
				_currentRenderTarget = renderTarget;
	
				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
					textures.setupRenderTarget( renderTarget );
	
				}
	
				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				var framebuffer;
	
				if ( renderTarget ) {
	
					var renderTargetProperties = properties.get( renderTarget );
	
					if ( isCube ) {
	
						framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
					} else {
	
						framebuffer = renderTargetProperties.__webglFramebuffer;
	
					}
	
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;
	
					_currentViewport.copy( renderTarget.viewport );
	
				} else {
	
					framebuffer = null;
	
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
					_currentScissorTest = _scissorTest;
	
					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
	
				}
	
				if ( _currentFramebuffer !== framebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
					_currentFramebuffer = framebuffer;
	
				}
	
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );
	
				state.viewport( _currentViewport );
	
				if ( isCube ) {
	
					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
	
				}
	
			};
	
			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
				if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {
	
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;
	
				}
	
				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
				if ( framebuffer ) {
	
					var restore = false;
	
					if ( framebuffer !== _currentFramebuffer ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
						restore = true;
	
					}
	
					try {
	
						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;
	
						if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;
	
						}
	
						if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
							! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
							! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;
	
						}
	
						if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	
							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
	
								_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );
	
							}
	
						} else {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
						}
	
					} finally {
	
						if ( restore ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
						}
	
					}
	
				}
	
			};
	
			// Map three.js constants to WebGL constants
	
			function paramThreeToGL( p ) {
	
				var extension;
	
				if ( p === RepeatWrapping ) return _gl.REPEAT;
				if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
				if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
				if ( p === NearestFilter ) return _gl.NEAREST;
				if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
				if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
				if ( p === LinearFilter ) return _gl.LINEAR;
				if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
				if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
				if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
				if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
				if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
				if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
				if ( p === ByteType ) return _gl.BYTE;
				if ( p === ShortType ) return _gl.SHORT;
				if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
				if ( p === IntType ) return _gl.INT;
				if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
				if ( p === FloatType ) return _gl.FLOAT;
	
				if ( p === HalfFloatType ) {
	
					extension = extensions.get( 'OES_texture_half_float' );
	
					if ( extension !== null ) return extension.HALF_FLOAT_OES;
	
				}
	
				if ( p === AlphaFormat ) return _gl.ALPHA;
				if ( p === RGBFormat ) return _gl.RGB;
				if ( p === RGBAFormat ) return _gl.RGBA;
				if ( p === LuminanceFormat ) return _gl.LUMINANCE;
				if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
				if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
				if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;
	
				if ( p === AddEquation ) return _gl.FUNC_ADD;
				if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
				if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
				if ( p === ZeroFactor ) return _gl.ZERO;
				if ( p === OneFactor ) return _gl.ONE;
				if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
				if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
				if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
				if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
				if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
				if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
				if ( p === DstColorFactor ) return _gl.DST_COLOR;
				if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
				if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
					}
	
				}
	
				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
					}
	
				}
	
				if ( p === RGB_ETC1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
					if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
				}
	
				if ( p === MinEquation || p === MaxEquation ) {
	
					extension = extensions.get( 'EXT_blend_minmax' );
	
					if ( extension !== null ) {
	
						if ( p === MinEquation ) return extension.MIN_EXT;
						if ( p === MaxEquation ) return extension.MAX_EXT;
	
					}
	
				}
	
				if ( p === UnsignedInt248Type ) {
	
					extension = extensions.get( 'WEBGL_depth_texture' );
	
					if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;
	
				}
	
				return 0;
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function FogExp2 ( color, density ) {
	
			this.name = '';
	
			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;
	
		}
	
		FogExp2.prototype.isFogExp2 = true;
	
		FogExp2.prototype.clone = function () {
	
			return new FogExp2( this.color.getHex(), this.density );
	
		};
	
		FogExp2.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Fog ( color, near, far ) {
	
			this.name = '';
	
			this.color = new Color( color );
	
			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;
	
		}
	
		Fog.prototype.isFog = true;
	
		Fog.prototype.clone = function () {
	
			return new Fog( this.color.getHex(), this.near, this.far );
	
		};
	
		Fog.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Scene () {
	
			Object3D.call( this );
	
			this.type = 'Scene';
	
			this.background = null;
			this.fog = null;
			this.overrideMaterial = null;
	
			this.autoUpdate = true; // checked by the renderer
	
		}
	
		Scene.prototype = Object.create( Object3D.prototype );
	
		Scene.prototype.constructor = Scene;
	
		Scene.prototype.copy = function ( source, recursive ) {
	
			Object3D.prototype.copy.call( this, source, recursive );
	
			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
	
			return this;
	
		};
	
		Scene.prototype.toJSON = function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
	
			return data;
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlare( texture, size, distance, blending, color ) {
	
			Object3D.call( this );
	
			this.lensFlares = [];
	
			this.positionScreen = new Vector3();
			this.customUpdateCallback = undefined;
	
			if ( texture !== undefined ) {
	
				this.add( texture, size, distance, blending, color );
	
			}
	
		}
	
		LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LensFlare,
	
			isLensFlare: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.positionScreen.copy( source.positionScreen );
				this.customUpdateCallback = source.customUpdateCallback;
	
				for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
					this.lensFlares.push( source.lensFlares[ i ] );
	
				}
	
				return this;
	
			},
	
			add: function ( texture, size, distance, blending, color, opacity ) {
	
				if ( size === undefined ) size = - 1;
				if ( distance === undefined ) distance = 0;
				if ( opacity === undefined ) opacity = 1;
				if ( color === undefined ) color = new Color( 0xffffff );
				if ( blending === undefined ) blending = NormalBlending;
	
				distance = Math.min( distance, Math.max( 0, distance ) );
	
				this.lensFlares.push( {
					texture: texture,	// THREE.Texture
					size: size, 		// size in pixels (-1 = use texture.width)
					distance: distance, 	// distance (0-1) from light source (0=at light source)
					x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
					scale: 1, 		// scale
					rotation: 0, 		// rotation
					opacity: opacity,	// opacity
					color: color,		// color
					blending: blending	// blending
				} );
	
			},
	
			/*
			 * Update lens flares update positions on all flares based on the screen position
			 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
			 */
	
			updateLensFlares: function () {
	
				var f, fl = this.lensFlares.length;
				var flare;
				var vecX = - this.positionScreen.x * 2;
				var vecY = - this.positionScreen.y * 2;
	
				for ( f = 0; f < fl; f ++ ) {
	
					flare = this.lensFlares[ f ];
	
					flare.x = this.positionScreen.x + vecX * flare.distance;
					flare.y = this.positionScreen.y + vecY * flare.distance;
	
					flare.wantedRotation = flare.x * Math.PI * 0.25;
					flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */
	
		function SpriteMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'SpriteMaterial';
	
			this.color = new Color( 0xffffff );
			this.map = null;
	
			this.rotation = 0;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;
	
		SpriteMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.map = source.map;
	
			this.rotation = source.rotation;
	
			return this;
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Sprite( material ) {
	
			Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();
	
		}
	
		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Sprite,
	
			isSprite: true,
	
			raycast: ( function () {
	
				var matrixPosition = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
					var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
					var guessSizeSq = this.scale.x * this.scale.y / 4;
	
					if ( distanceSq > guessSizeSq ) {
	
						return;
	
					}
	
					intersects.push( {
	
						distance: Math.sqrt( distanceSq ),
						point: this.position,
						face: null,
						object: this
	
					} );
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LOD() {
	
			Object3D.call( this );
	
			this.type = 'LOD';
	
			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );
	
		}
	
	
		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LOD,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source, false );
	
				var levels = source.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					this.addLevel( level.object.clone(), level.distance );
	
				}
	
				return this;
	
			},
	
			addLevel: function ( object, distance ) {
	
				if ( distance === undefined ) distance = 0;
	
				distance = Math.abs( distance );
	
				var levels = this.levels;
	
				for ( var l = 0; l < levels.length; l ++ ) {
	
					if ( distance < levels[ l ].distance ) {
	
						break;
	
					}
	
				}
	
				levels.splice( l, 0, { distance: distance, object: object } );
	
				this.add( object );
	
			},
	
			getObjectForDistance: function ( distance ) {
	
				var levels = this.levels;
	
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
					if ( distance < levels[ i ].distance ) {
	
						break;
	
					}
	
				}
	
				return levels[ i - 1 ].object;
	
			},
	
			raycast: ( function () {
	
				var matrixPosition = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
					this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
				};
	
			}() ),
	
			update: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function update( camera ) {
	
					var levels = this.levels;
	
					if ( levels.length > 1 ) {
	
						v1.setFromMatrixPosition( camera.matrixWorld );
						v2.setFromMatrixPosition( this.matrixWorld );
	
						var distance = v1.distanceTo( v2 );
	
						levels[ 0 ].object.visible = true;
	
						for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
							if ( distance >= levels[ i ].distance ) {
	
								levels[ i - 1 ].object.visible = false;
								levels[ i ].object.visible = true;
	
							} else {
	
								break;
	
							}
	
						}
	
						for ( ; i < l; i ++ ) {
	
							levels[ i ].object.visible = false;
	
						}
	
					}
	
				};
	
			}(),
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.levels = [];
	
				var levels = this.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );
	
				}
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */
	
		function Skeleton( bones, boneInverses, useVertexTexture ) {
	
			this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
			this.identityMatrix = new Matrix4();
	
			// copy the bone array
	
			bones = bones || [];
	
			this.bones = bones.slice( 0 );
	
			// create a bone texture or an array of floats
	
			if ( this.useVertexTexture ) {
	
				// layout (1 matrix = 4 pixels)
				//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
				//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
				//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
				//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
	
				var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
				size = _Math.nextPowerOfTwo( Math.ceil( size ) );
				size = Math.max( size, 4 );
	
				this.boneTextureWidth = size;
				this.boneTextureHeight = size;
	
				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );
	
			} else {
	
				this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
			}
	
			// use the supplied bone inverses or calculate the inverses
	
			if ( boneInverses === undefined ) {
	
				this.calculateInverses();
	
			} else {
	
				if ( this.bones.length === boneInverses.length ) {
	
					this.boneInverses = boneInverses.slice( 0 );
	
				} else {
	
					console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
					this.boneInverses = [];
	
					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
						this.boneInverses.push( new Matrix4() );
	
					}
	
				}
	
			}
	
		}
	
		Object.assign( Skeleton.prototype, {
	
			calculateInverses: function () {
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					var inverse = new Matrix4();
	
					if ( this.bones[ b ] ) {
	
						inverse.getInverse( this.bones[ b ].matrixWorld );
	
					}
	
					this.boneInverses.push( inverse );
	
				}
	
			},
	
			pose: function () {
	
				var bone;
	
				// recover the bind-time world matrices
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					bone = this.bones[ b ];
	
					if ( bone ) {
	
						bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
					}
	
				}
	
				// compute the local matrices, positions, rotations and scales
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					bone = this.bones[ b ];
	
					if ( bone ) {
	
						if ( bone.parent && bone.parent.isBone ) {
	
							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );
	
						} else {
	
							bone.matrix.copy( bone.matrixWorld );
	
						}
	
						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
					}
	
				}
	
			},
	
			update: ( function () {
	
				var offsetMatrix = new Matrix4();
	
				return function update() {
	
					// flatten bone matrices to array
	
					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
						// compute the offset between the current and the original transform
	
						var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
						offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
						offsetMatrix.toArray( this.boneMatrices, b * 16 );
	
					}
	
					if ( this.useVertexTexture ) {
	
						this.boneTexture.needsUpdate = true;
	
					}
	
				};
	
			} )(),
	
			clone: function () {
	
				return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function Bone() {
	
			Object3D.call( this );
	
			this.type = 'Bone';
	
		}
	
		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Bone,
	
			isBone: true
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function SkinnedMesh( geometry, material, useVertexTexture ) {
	
			Mesh.call( this, geometry, material );
	
			this.type = 'SkinnedMesh';
	
			this.bindMode = "attached";
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
	
			// init bones
	
			// TODO: remove bone creation as there is no reason (other than
			// convenience) for THREE.SkinnedMesh to do this.
	
			var bones = [];
	
			if ( this.geometry && this.geometry.bones !== undefined ) {
	
				var bone, gbone;
	
				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
					gbone = this.geometry.bones[ b ];
	
					bone = new Bone();
					bones.push( bone );
	
					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
				}
	
				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
					gbone = this.geometry.bones[ b ];
	
					if ( gbone.parent !== - 1 && gbone.parent !== null &&
							bones[ gbone.parent ] !== undefined ) {
	
						bones[ gbone.parent ].add( bones[ b ] );
	
					} else {
	
						this.add( bones[ b ] );
	
					}
	
				}
	
			}
	
			this.normalizeSkinWeights();
	
			this.updateMatrixWorld( true );
			this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );
	
		}
	
	
		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
	
			constructor: SkinnedMesh,
	
			isSkinnedMesh: true,
	
			bind: function( skeleton, bindMatrix ) {
	
				this.skeleton = skeleton;
	
				if ( bindMatrix === undefined ) {
	
					this.updateMatrixWorld( true );
	
					this.skeleton.calculateInverses();
	
					bindMatrix = this.matrixWorld;
	
				}
	
				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );
	
			},
	
			pose: function () {
	
				this.skeleton.pose();
	
			},
	
			normalizeSkinWeights: function () {
	
				if ( this.geometry && this.geometry.isGeometry ) {
	
					for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {
	
						var sw = this.geometry.skinWeights[ i ];
	
						var scale = 1.0 / sw.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							sw.multiplyScalar( scale );
	
						} else {
	
							sw.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
					}
	
				} else if ( this.geometry && this.geometry.isBufferGeometry ) {
	
					var vec = new Vector4();
	
					var skinWeight = this.geometry.attributes.skinWeight;
	
					for ( var i = 0; i < skinWeight.count; i ++ ) {
	
						vec.x = skinWeight.getX( i );
						vec.y = skinWeight.getY( i );
						vec.z = skinWeight.getZ( i );
						vec.w = skinWeight.getW( i );
	
						var scale = 1.0 / vec.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							vec.multiplyScalar( scale );
	
						} else {
	
							vec.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
						skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
	
					}
	
				}
	
			},
	
			updateMatrixWorld: function( force ) {
	
				Mesh.prototype.updateMatrixWorld.call( this, true );
	
				if ( this.bindMode === "attached" ) {
	
					this.bindMatrixInverse.getInverse( this.matrixWorld );
	
				} else if ( this.bindMode === "detached" ) {
	
					this.bindMatrixInverse.getInverse( this.bindMatrix );
	
				} else {
	
					console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );
	
				}
	
			},
	
			clone: function() {
	
				return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */
	
		function LineBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineBasicMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;
	
		LineBasicMaterial.prototype.isLineBasicMaterial = true;
	
		LineBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Line( geometry, material, mode ) {
	
			if ( mode === 1 ) {
	
				console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
				return new LineSegments( geometry, material );
	
			}
	
			Object3D.call( this );
	
			this.type = 'Line';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Line,
	
			isLine: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var precision = raycaster.linePrecision;
					var precisionSq = precision * precision;
	
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var vStart = new Vector3();
					var vEnd = new Vector3();
					var interSegment = new Vector3();
					var interRay = new Vector3();
					var step = (this && this.isLineSegments) ? 2 : 1;
	
					if ( geometry.isBufferGeometry ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
								var a = indices[ i ];
								var b = indices[ i + 1 ];
	
								vStart.fromArray( positions, a * 3 );
								vEnd.fromArray( positions, b * 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
								vStart.fromArray( positions, 3 * i );
								vEnd.fromArray( positions, 3 * i + 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						}
	
					} else if ( geometry.isGeometry ) {
	
						var vertices = geometry.vertices;
						var nbVertices = vertices.length;
	
						for ( var i = 0; i < nbVertices - 1; i += step ) {
	
							var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
							if ( distSq > precisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LineSegments( geometry, material ) {
	
			Line.call( this, geometry, material );
	
			this.type = 'LineSegments';
	
		}
	
		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
	
			constructor: LineSegments,
	
			isLineSegments: true
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */
	
		function PointsMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'PointsMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.map = null;
	
			this.size = 1;
			this.sizeAttenuation = true;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;
	
		PointsMaterial.prototype.isPointsMaterial = true;
	
		PointsMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Points( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Points';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Points,
	
			isPoints: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var object = this;
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
					var threshold = raycaster.params.Points.threshold;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
					var localThresholdSq = localThreshold * localThreshold;
					var position = new Vector3();
	
					function testPoint( point, index ) {
	
						var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
						if ( rayPointDistanceSq < localThresholdSq ) {
	
							var intersectPoint = ray.closestPointToPoint( point );
							intersectPoint.applyMatrix4( matrixWorld );
	
							var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
							if ( distance < raycaster.near || distance > raycaster.far ) return;
	
							intersects.push( {
	
								distance: distance,
								distanceToRay: Math.sqrt( rayPointDistanceSq ),
								point: intersectPoint.clone(),
								index: index,
								face: null,
								object: object
	
							} );
	
						}
	
					}
	
					if ( geometry.isBufferGeometry ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
								var a = indices[ i ];
	
								position.fromArray( positions, a * 3 );
	
								testPoint( position, a );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
								position.fromArray( positions, i * 3 );
	
								testPoint( position, i );
	
							}
	
						}
	
					} else {
	
						var vertices = geometry.vertices;
	
						for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
							testPoint( vertices[ i ], i );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Group() {
	
			Object3D.call( this );
	
			this.type = 'Group';
	
		}
	
		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Group
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.generateMipmaps = false;
	
			var scope = this;
	
			function update() {
	
				requestAnimationFrame( update );
	
				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
	
					scope.needsUpdate = true;
	
				}
	
			}
	
			update();
	
		}
	
		VideoTexture.prototype = Object.create( Texture.prototype );
		VideoTexture.prototype.constructor = VideoTexture;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;
	
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
	
			this.flipY = false;
	
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
	
			this.generateMipmaps = false;
	
		}
	
		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;
	
		CompressedTexture.prototype.isCompressedTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.needsUpdate = true;
	
		}
	
		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;
	
		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */
	
		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
	
			format = format !== undefined ? format : DepthFormat;
	
			if ( format !== DepthFormat && format !== DepthStencilFormat ) {
	
				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )
	
			}
	
			if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.image = { width: width, height: height };
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.flipY = false;
			this.generateMipmaps	= false;
	
		}
	
		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function WireframeGeometry( geometry ) {
	
			BufferGeometry.call( this );
	
			this.type = 'WireframeGeometry';
	
			// buffer
	
			var vertices = [];
	
			// helper variables
	
			var i, j, l, o, ol;
			var edge = [ 0, 0 ], edges = {}, e;
			var key, keys = [ 'a', 'b', 'c' ];
			var vertex;
	
			// different logic for Geometry and BufferGeometry
	
			if ( geometry && geometry.isGeometry ) {
	
				// create a data structure that contains all edges without duplicates
	
				var faces = geometry.faces;
	
				for ( i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( j = 0; j < 3; j ++ ) {
	
						edge[ 0 ] = face[ keys[ j ] ];
						edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
						edge.sort( sortFunction ); // sorting prevents duplicates
	
						key = edge.toString();
	
						if ( edges[ key ] === undefined ) {
	
							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
						}
	
					}
	
				}
	
				// generate vertices
	
				for ( key in edges ) {
	
					e = edges[ key ];
	
					vertex = geometry.vertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					vertex = geometry.vertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			} else if ( geometry && geometry.isBufferGeometry ) {
	
				var position, indices, groups;
				var group, start, count;
				var index1, index2;
	
				vertex = new Vector3();
	
				if ( geometry.index !== null ) {
	
					// indexed BufferGeometry
	
					position = geometry.attributes.position;
					indices = geometry.index;
					groups = geometry.groups;
	
					if ( groups.length === 0 ) {
	
						geometry.addGroup( 0, indices.count );
	
					}
	
					// create a data structure that contains all eges without duplicates
	
					for ( o = 0, ol = groups.length; o < ol; ++ o ) {
	
						group = groups[ o ];
	
						start = group.start;
						count = group.count;
	
						for ( i = start, l = ( start + count ); i < l; i += 3 ) {
	
							for ( j = 0; j < 3; j ++ ) {
	
								edge[ 0 ] = indices.getX( i + j );
								edge[ 1 ] = indices.getX( i + ( j + 1 ) % 3 );
								edge.sort( sortFunction ); // sorting prevents duplicates
	
								key = edge.toString();
	
								if ( edges[ key ] === undefined ) {
	
									edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
								}
	
							}
	
						}
	
					}
	
					// generate vertices
	
					for ( key in edges ) {
	
						e = edges[ key ];
	
						vertex.fromBufferAttribute( position, e.index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
						vertex.fromBufferAttribute( position, e.index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
					}
	
				} else {
	
					// non-indexed BufferGeometry
	
					position = geometry.attributes.position;
	
					for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {
	
						for ( j = 0; j < 3; j ++ ) {
	
							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
	
							index1 = 3 * i + j;
							vertex.fromBufferAttribute( position, index1 );
							vertices.push( vertex.x, vertex.y, vertex.z );
	
							index2 = 3 * i + ( ( j + 1 ) % 3 );
							vertex.fromBufferAttribute( position, index2 );
							vertices.push( vertex.x, vertex.y, vertex.z );
	
						}
	
					}
	
				}
	
			}
	
			// build geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
			// custom array sort function
	
			function sortFunction( a, b ) {
	
				return a - b;
	
			}
	
		}
	
		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;
	
		/**
		 * @author zz85 / https://github.com/zz85
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */
	
		function ParametricGeometry( func, slices, stacks ) {
	
			Geometry.call( this );
	
			this.type = 'ParametricGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();
	
		}
	
		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */
	
		function ParametricBufferGeometry( func, slices, stacks ) {
	
			BufferGeometry.call( this );
	
			this.type = 'ParametricBufferGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var uvs = [];
	
			var i, j;
	
			// generate vertices and uvs
	
			var sliceCount = slices + 1;
	
			for ( i = 0; i <= stacks; i ++ ) {
	
				var v = i / stacks;
	
				for ( j = 0; j <= slices; j ++ ) {
	
					var u = j / slices;
	
					var p = func( u, v );
					vertices.push( p.x, p.y, p.z );
	
					uvs.push( u, v );
	
				}
	
			}
	
			// generate indices
	
			for ( i = 0; i < stacks; i ++ ) {
	
				for ( j = 0; j < slices; j ++ ) {
	
					var a = i * sliceCount + j;
					var b = i * sliceCount + j + 1;
					var c = ( i + 1 ) * sliceCount + j + 1;
					var d = ( i + 1 ) * sliceCount + j;
	
					// faces one and two
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// generate normals
	
			this.computeVertexNormals();
	
		}
	
		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
	
		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function PolyhedronGeometry( vertices, indices, radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'PolyhedronGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();
	
		}
	
		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PolyhedronBufferGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			radius = radius || 1;
			detail = detail || 0;
	
			// default buffer data
	
			var vertexBuffer = [];
			var uvBuffer = [];
	
			// the subdivision creates the vertex buffer data
	
			subdivide( detail );
	
			// all vertices should lie on a conceptual sphere with a given radius
	
			appplyRadius( radius );
	
			// finally, create the uv data
	
			generateUVs();
	
			// build non-indexed geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
			this.normalizeNormals();
	
			// helper functions
	
			function subdivide( detail ) {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				// iterate over all faces and apply a subdivison with the given detail value
	
				for ( var i = 0; i < indices.length; i += 3 ) {
	
					// get the vertices of the face
	
					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );
	
					// perform subdivision
	
					subdivideFace( a, b, c, detail );
	
				}
	
			}
	
			function subdivideFace( a, b, c, detail ) {
	
				var cols = Math.pow( 2, detail );
	
				// we use this multidimensional array as a data structure for creating the subdivision
	
				var v = [];
	
				var i, j;
	
				// construct all of the vertices for this subdivision
	
				for ( i = 0; i <= cols; i ++ ) {
	
					v[ i ] = [];
	
					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );
	
					var rows = cols - i;
	
					for ( j = 0; j <= rows; j ++ ) {
	
						if ( j === 0 && i === cols ) {
	
							v[ i ][ j ] = aj;
	
						} else {
	
							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
	
						}
	
					}
	
				}
	
				// construct all of the faces
	
				for ( i = 0; i < cols; i ++ ) {
	
					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
						var k = Math.floor( j / 2 );
	
						if ( j % 2 === 0 ) {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );
	
						} else {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
	
						}
	
					}
	
				}
	
			}
	
			function appplyRadius( radius ) {
	
				var vertex = new Vector3();
	
				// iterate over the entire buffer and apply the radius to each vertex
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					vertex.normalize().multiplyScalar( radius );
	
					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;
	
				}
	
			}
	
			function generateUVs() {
	
				var vertex = new Vector3();
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );
	
				}
	
				correctUVs();
	
				correctSeam();
	
			}
	
			function correctSeam() {
	
				// handle case when face straddles the seam, see #3269
	
				for ( var i = 0; i < uvBuffer.length; i += 6 ) {
	
					// uv data of a single face
	
					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];
	
					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );
	
					// 0.9 is somewhat arbitrary
	
					if ( max > 0.9 && min < 0.1 ) {
	
						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;
	
					}
	
				}
	
			}
	
			function pushVertex( vertex ) {
	
				vertexBuffer.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			function getVertexByIndex( index, vertex ) {
	
				var stride = index * 3;
	
				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];
	
			}
	
			function correctUVs() {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				var centroid = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {
	
					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
	
					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
	
					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
	
					var azi = azimuth( centroid );
	
					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );
	
				}
	
			}
	
			function correctUV( uv, stride, vector, azimuth ) {
	
				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {
	
					uvBuffer[ stride ] = uv.x - 1;
	
				}
	
				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {
	
					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
	
				}
	
			}
	
			// Angle around the Y axis, counter-clockwise when looking from above.
	
			function azimuth( vector ) {
	
				return Math.atan2( vector.z, - vector.x );
	
			}
	
	
			// Angle above the XZ plane.
	
			function inclination( vector ) {
	
				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
			}
	
		}
	
		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function TetrahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'TetrahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TetrahedronBufferGeometry( radius, detail ) {
	
			var vertices = [
				1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
			];
	
			var indices = [
				2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'TetrahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function OctahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'OctahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function OctahedronBufferGeometry( radius, detail ) {
	
			var vertices = [
				1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
			];
	
			var indices = [
				0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'OctahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function IcosahedronGeometry( radius, detail ) {
	
		 	Geometry.call( this );
	
			this.type = 'IcosahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function IcosahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
			var vertices = [
				- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
				 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
				 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
			];
	
			var indices = [
				 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
				 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
				 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
				 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'IcosahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
	
		/**
		 * @author Abe Pazos / https://hamoid.com
		 */
	
		function DodecahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'DodecahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function DodecahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;
	
			var vertices = [
	
				// (1, 1, 1)
				- 1, - 1, - 1,    - 1, - 1,  1,
				- 1,  1, - 1,    - 1,  1,  1,
				  1, - 1, - 1,     1, - 1,  1,
				  1,  1, - 1,     1,  1,  1,
	
				// (0, 1/, )
				 0, - r, - t,     0, - r,  t,
				 0,  r, - t,     0,  r,  t,
	
				// (1/, , 0)
				- r, - t,  0,    - r,  t,  0,
				 r, - t,  0,     r,  t,  0,
	
				// (, 0, 1/)
				- t,  0, - r,     t,  0, - r,
				- t,  0,  r,     t,  0,  r
			];
	
			var indices = [
				 3, 11,  7,      3,  7, 15,      3, 15, 13,
				 7, 19, 17,      7, 17,  6,      7,  6, 15,
				17,  4,  8,     17,  8, 10,     17, 10,  6,
				 8,  0, 16,      8, 16,  2,      8,  2, 10,
				 0, 12,  1,      0,  1, 18,      0, 18, 16,
				 6, 10,  2,      6,  2, 13,      6, 13, 15,
				 2, 16, 18,      2, 18,  3,      2,  3, 13,
				18,  1,  9,     18,  9, 11,     18, 11,  3,
				 4, 14, 12,      4, 12,  0,      4,  0,  8,
				11,  9,  5,     11,  5, 19,     11, 19,  7,
				19,  5, 14,     19, 14,  4,     19,  4, 17,
				 1, 12, 14,      1, 14,  5,      1,  5,  9
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'DodecahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
	
		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 */
	
		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
	
			Geometry.call( this );
	
			this.type = 'TubeGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
	
			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
	
			// expose internals
	
			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;
	
			// create geometry
	
			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();
	
		}
	
		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TubeBufferGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;
	
			var frames = path.computeFrenetFrames( tubularSegments, closed );
	
			// expose internals
	
			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;
	
			// helper variables
	
			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
	
			var i, j;
	
			// buffer
	
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
	
			// create buffer data
	
			generateBufferData();
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// functions
	
			function generateBufferData() {
	
				for ( i = 0; i < tubularSegments; i ++ ) {
	
					generateSegment( i );
	
				}
	
				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
	
				generateSegment( ( closed === false ) ? tubularSegments : 0 );
	
				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries
	
				generateUVs();
	
				// finally create faces
	
				generateIndices();
	
			}
	
			function generateSegment( i ) {
	
				// we use getPointAt to sample evenly distributed points from the given path
	
				var P = path.getPointAt( i / tubularSegments );
	
				// retrieve corresponding normal and binormal
	
				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];
	
				// generate normals and vertices for the current segment
	
				for ( j = 0; j <= radialSegments; j ++ ) {
	
					var v = j / radialSegments * Math.PI * 2;
	
					var sin =   Math.sin( v );
					var cos = - Math.cos( v );
	
					// normal
	
					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// vertex
	
					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			}
	
			function generateIndices() {
	
				for ( j = 1; j <= tubularSegments; j ++ ) {
	
					for ( i = 1; i <= radialSegments; i ++ ) {
	
						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
					}
	
				}
	
			}
	
			function generateUVs() {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					for ( j = 0; j <= radialSegments; j ++ ) {
	
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
	
						uvs.push( uv.x, uv.y );
	
					}
	
				}
	
			}
	
		}
	
		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 */
	
		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
	
			Geometry.call( this );
	
			this.type = 'TorusKnotGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
	
			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();
	
		}
	
		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 * see: http://www.blackpawn.com/texts/pqtorus/
		 */
	
		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusKnotBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			radius = radius || 100;
			tube = tube || 40;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var i, j;
	
			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
	
			var P1 = new Vector3();
			var P2 = new Vector3();
	
			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();
	
			// generate vertices, normals and uvs
	
			for ( i = 0; i <= tubularSegments; ++ i ) {
	
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
	
				var u = i / tubularSegments * p * Math.PI * 2;
	
				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
	
				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
	
				// calculate orthonormal basis
	
				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );
	
				// normalize B, N. T can be ignored, we don't use it
	
				B.normalize();
				N.normalize();
	
				for ( j = 0; j <= radialSegments; ++ j ) {
	
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
	
					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );
	
					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
	
					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
	
					normal.subVectors( vertex, P1 ).normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= tubularSegments; j ++ ) {
	
				for ( i = 1; i <= radialSegments; i ++ ) {
	
					// indices
	
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// this function calculates the current position on the torus curve
	
			function calculatePositionOnCurve( u, p, q, radius, position ) {
	
				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );
	
				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;
	
			}
	
		}
	
		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
		 */
	
		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			Geometry.call( this );
	
			this.type = 'TorusGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	
		}
	
		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			radius = radius || 100;
			tube = tube || 40;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();
	
			var j, i;
	
			// generate vertices, normals and uvs
	
			for ( j = 0; j <= radialSegments; j ++ ) {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;
	
					// vertex
	
					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );
					normal.subVectors( vertex, center ).normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= radialSegments; j ++ ) {
	
				for ( i = 1; i <= tubularSegments; i ++ ) {
	
					// indices
	
					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		var ShapeUtils = {
	
			// calculate area of the contour polygon
	
			area: function ( contour ) {
	
				var n = contour.length;
				var a = 0.0;
	
				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
				}
	
				return a * 0.5;
	
			},
	
			triangulate: ( function () {
	
				/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */
	
				function snip( contour, u, v, w, n, verts ) {
	
					var p;
					var ax, ay, bx, by;
					var cx, cy, px, py;
	
					ax = contour[ verts[ u ] ].x;
					ay = contour[ verts[ u ] ].y;
	
					bx = contour[ verts[ v ] ].x;
					by = contour[ verts[ v ] ].y;
	
					cx = contour[ verts[ w ] ].x;
					cy = contour[ verts[ w ] ].y;
	
					if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;
	
					var aX, aY, bX, bY, cX, cY;
					var apx, apy, bpx, bpy, cpx, cpy;
					var cCROSSap, bCROSScp, aCROSSbp;
	
					aX = cx - bx;  aY = cy - by;
					bX = ax - cx;  bY = ay - cy;
					cX = bx - ax;  cY = by - ay;
	
					for ( p = 0; p < n; p ++ ) {
	
						px = contour[ verts[ p ] ].x;
						py = contour[ verts[ p ] ].y;
	
						if ( ( ( px === ax ) && ( py === ay ) ) ||
							 ( ( px === bx ) && ( py === by ) ) ||
							 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
						apx = px - ax;  apy = py - ay;
						bpx = px - bx;  bpy = py - by;
						cpx = px - cx;  cpy = py - cy;
	
						// see if p is inside triangle abc
	
						aCROSSbp = aX * bpy - aY * bpx;
						cCROSSap = cX * apy - cY * apx;
						bCROSScp = bX * cpy - bY * cpx;
	
						if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
					}
	
					return true;
	
				}
	
				// takes in an contour array and returns
	
				return function triangulate( contour, indices ) {
	
					var n = contour.length;
	
					if ( n < 3 ) return null;
	
					var result = [],
						verts = [],
						vertIndices = [];
	
					/* we want a counter-clockwise polygon in verts */
	
					var u, v, w;
	
					if ( ShapeUtils.area( contour ) > 0.0 ) {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
					} else {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
					}
	
					var nv = n;
	
					/*  remove nv - 2 vertices, creating 1 triangle every time */
	
					var count = 2 * nv;   /* error detection */
	
					for ( v = nv - 1; nv > 2; ) {
	
						/* if we loop, it is probably a non-simple polygon */
	
						if ( ( count -- ) <= 0 ) {
	
							//** Triangulate: ERROR - probable bad polygon!
	
							//throw ( "Warning, unable to triangulate polygon!" );
							//return null;
							// Sometimes warning is fine, especially polygons are triangulated in reverse.
							console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
							if ( indices ) return vertIndices;
							return result;
	
						}
	
						/* three consecutive vertices in current polygon, <u,v,w> */
	
						u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
						v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
						w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
						if ( snip( contour, u, v, w, nv, verts ) ) {
	
							var a, b, c, s, t;
	
							/* true names of the vertices */
	
							a = verts[ u ];
							b = verts[ v ];
							c = verts[ w ];
	
							/* output Triangle */
	
							result.push( [ contour[ a ],
								contour[ b ],
								contour[ c ] ] );
	
	
							vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
							/* remove v from the remaining polygon */
	
							for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
								verts[ s ] = verts[ t ];
	
							}
	
							nv --;
	
							/* reset error detection counter */
	
							count = 2 * nv;
	
						}
	
					}
	
					if ( indices ) return vertIndices;
					return result;
	
				}
	
			} )(),
	
			triangulateShape: function ( contour, holes ) {
	
				function removeDupEndPts(points) {
	
					var l = points.length;
	
					if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
	
						points.pop();
	
					}
	
				}
	
				removeDupEndPts( contour );
				holes.forEach( removeDupEndPts );
	
				function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
					// inOtherPt needs to be collinear to the inSegment
					if ( inSegPt1.x !== inSegPt2.x ) {
	
						if ( inSegPt1.x < inSegPt2.x ) {
	
							return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
						} else {
	
							return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
						}
	
					} else {
	
						if ( inSegPt1.y < inSegPt2.y ) {
	
							return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
						} else {
	
							return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
						}
	
					}
	
				}
	
				function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
					var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
					var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
					var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
					var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
					var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
					var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
					if ( Math.abs( limit ) > Number.EPSILON ) {
	
						// not parallel
	
						var perpSeg2;
						if ( limit > 0 ) {
	
							if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
						} else {
	
							if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
						}
	
						// i.e. to reduce rounding errors
						// intersection at endpoint of segment#1?
						if ( perpSeg2 === 0 ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt1 ];
	
						}
						if ( perpSeg2 === limit ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt2 ];
	
						}
						// intersection at endpoint of segment#2?
						if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
						if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
						// return real intersection point
						var factorSeg1 = perpSeg2 / limit;
						return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
									y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
					} else {
	
						// parallel or collinear
						if ( ( perpSeg1 !== 0 ) ||
							 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
						// they are collinear or degenerate
						var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
						var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
						// both segments are points
						if ( seg1Pt && seg2Pt ) {
	
							if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
								 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
							return [ inSeg1Pt1 ];                 						// they are the same point
	
						}
						// segment#1  is a single point
						if ( seg1Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
							return [ inSeg1Pt1 ];
	
						}
						// segment#2  is a single point
						if ( seg2Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
							return [ inSeg2Pt1 ];
	
						}
	
						// they are collinear segments, which might overlap
						var seg1min, seg1max, seg1minVal, seg1maxVal;
						var seg2min, seg2max, seg2minVal, seg2maxVal;
						if ( seg1dx !== 0 ) {
	
							// the segments are NOT on a vertical line
							if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
							}
							if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
							}
	
						} else {
	
							// the segments are on a vertical line
							if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
							}
							if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
							}
	
						}
						if ( seg1minVal <= seg2minVal ) {
	
							if ( seg1maxVal <  seg2minVal )	return [];
							if ( seg1maxVal === seg2minVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg2min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
							return	[ seg2min, seg2max ];
	
						} else {
	
							if ( seg1minVal >  seg2maxVal )	return [];
							if ( seg1minVal === seg2maxVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg1min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
							return	[ seg1min, seg2max ];
	
						}
	
					}
	
				}
	
				function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
					// The order of legs is important
	
					// translation of all points, so that Vertex is at (0,0)
					var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
					var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
					var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
					// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
					var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
					var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
					if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
						// angle != 180 deg.
	
						var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
						// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
						if ( from2toAngle > 0 ) {
	
							// main angle < 180 deg.
							return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
						} else {
	
							// main angle > 180 deg.
							return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
						}
	
					} else {
	
						// angle == 180 deg.
						// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
						return	( from2otherAngle > 0 );
	
					}
	
				}
	
	
				function removeHoles( contour, holes ) {
	
					var shape = contour.concat(); // work on this shape
					var hole;
	
					function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
						// Check if hole point lies within angle around shape point
						var lastShapeIdx = shape.length - 1;
	
						var prevShapeIdx = inShapeIdx - 1;
						if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
						var nextShapeIdx = inShapeIdx + 1;
						if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
						var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
							return	false;
	
						}
	
						// Check if shape point lies within angle around hole point
						var lastHoleIdx = hole.length - 1;
	
						var prevHoleIdx = inHoleIdx - 1;
						if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
						var nextHoleIdx = inHoleIdx + 1;
						if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
						insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
							return	false;
	
						}
	
						return	true;
	
					}
	
					function intersectsShapeEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with shape edges
						var sIdx, nextIdx, intersection;
						for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
							nextIdx = sIdx + 1; nextIdx %= shape.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
						return	false;
	
					}
	
					var indepHoles = [];
	
					function intersectsHoleEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with hole edges
						var ihIdx, chkHole,
							hIdx, nextIdx, intersection;
						for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
							chkHole = holes[ indepHoles[ ihIdx ]];
							for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
								nextIdx = hIdx + 1; nextIdx %= chkHole.length;
								intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
								if ( intersection.length > 0 )		return	true;
	
							}
	
						}
						return	false;
	
					}
	
					var holeIndex, shapeIndex,
						shapePt, holePt,
						holeIdx, cutKey, failedCuts = [],
						tmpShape1, tmpShape2,
						tmpHole1, tmpHole2;
	
					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
						indepHoles.push( h );
	
					}
	
					var minShapeIndex = 0;
					var counter = indepHoles.length * 2;
					while ( indepHoles.length > 0 ) {
	
						counter --;
						if ( counter < 0 ) {
	
							console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
							break;
	
						}
	
						// search for shape-vertex and hole-vertex,
						// which can be connected without intersections
						for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
							shapePt = shape[ shapeIndex ];
							holeIndex	= - 1;
	
							// search for hole which can be reached without intersections
							for ( var h = 0; h < indepHoles.length; h ++ ) {
	
								holeIdx = indepHoles[ h ];
	
								// prevent multiple checks
								cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
								if ( failedCuts[ cutKey ] !== undefined )			continue;
	
								hole = holes[ holeIdx ];
								for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
									holePt = hole[ h2 ];
									if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
									if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
									if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
									holeIndex = h2;
									indepHoles.splice( h, 1 );
	
									tmpShape1 = shape.slice( 0, shapeIndex + 1 );
									tmpShape2 = shape.slice( shapeIndex );
									tmpHole1 = hole.slice( holeIndex );
									tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
									shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
									minShapeIndex = shapeIndex;
	
									// Debug only, to show the selected cuts
									// glob_CutLines.push( [ shapePt, holePt ] );
	
									break;
	
								}
								if ( holeIndex >= 0 )	break;		// hole-vertex found
	
								failedCuts[ cutKey ] = true;			// remember failure
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
						}
	
					}
	
					return shape; 			/* shape with no holes */
	
				}
	
	
				var i, il, f, face,
					key, index,
					allPointsMap = {};
	
				// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
				var allpoints = contour.concat();
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					Array.prototype.push.apply( allpoints, holes[ h ] );
	
				}
	
				//console.log( "allpoints",allpoints, allpoints.length );
	
				// prepare all points map
	
				for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
					key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
					if ( allPointsMap[ key ] !== undefined ) {
	
						console.warn( "THREE.ShapeUtils: Duplicate point", key, i );
	
					}
	
					allPointsMap[ key ] = i;
	
				}
	
				// remove holes by cutting paths to holes and adding them to the shape
				var shapeWithoutHoles = removeHoles( contour, holes );
	
				var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
				//console.log( "triangles",triangles, triangles.length );
	
				// check all face vertices against all points map
	
				for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
					face = triangles[ i ];
	
					for ( f = 0; f < 3; f ++ ) {
	
						key = face[ f ].x + ":" + face[ f ].y;
	
						index = allPointsMap[ key ];
	
						if ( index !== undefined ) {
	
							face[ f ] = index;
	
						}
	
					}
	
				}
	
				return triangles.concat();
	
			},
	
			isClockWise: function ( pts ) {
	
				return ShapeUtils.area( pts ) < 0;
	
			}
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.Curve> // curve to extrude shape along
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/
	
		function ExtrudeGeometry( shapes, options ) {
	
			if ( typeof( shapes ) === "undefined" ) {
	
				shapes = [];
				return;
	
			}
	
			Geometry.call( this );
	
			this.type = 'ExtrudeGeometry';
	
			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
			this.addShapeList( shapes, options );
	
			this.computeFaceNormals();
	
			// can't really use automatic vertex normals
			// as then front and back sides get smoothed too
			// should do separate smoothing just for sides
	
			//this.computeVertexNormals();
	
			//console.log( "took", ( Date.now() - startTime ) );
	
		}
	
		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
	
		ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
			var sl = shapes.length;
	
			for ( var s = 0; s < sl; s ++ ) {
	
				var shape = shapes[ s ];
				this.addShape( shape, options );
	
			}
	
		};
	
		ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
			var amount = options.amount !== undefined ? options.amount : 100;
	
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
			var steps = options.steps !== undefined ? options.steps : 1;
	
			var extrudePath = options.extrudePath;
			var extrudePts, extrudeByPath = false;
	
			// Use default WorldUVGenerator if no UV generators are specified.
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
	
			var splineTube, binormal, normal, position2;
			if ( extrudePath ) {
	
				extrudePts = extrudePath.getSpacedPoints( steps );
	
				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion
	
				// SETUP TNB variables
	
				// TODO1 - have a .isClosed in spline?
	
				splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );
	
				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
	
			}
	
			// Safeguards if bevels are not enabled
	
			if ( ! bevelEnabled ) {
	
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
	
			}
	
			// Variables initialization
	
			var ahole, h, hl; // looping of holes
			var scope = this;
	
			var shapesOffset = this.vertices.length;
	
			var shapePoints = shape.extractPoints( curveSegments );
	
			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;
	
			var reverse = ! ShapeUtils.isClockWise( vertices );
	
			if ( reverse ) {
	
				vertices = vertices.reverse();
	
				// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
	
					if ( ShapeUtils.isClockWise( ahole ) ) {
	
						holes[ h ] = ahole.reverse();
	
					}
	
				}
	
				reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
			}
	
	
			var faces = ShapeUtils.triangulateShape( vertices, holes );
	
			/* Vertices */
	
			var contour = vertices; // vertices has all points but contour has only points of circumference
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				vertices = vertices.concat( ahole );
	
			}
	
	
			function scalePt2( pt, vec, size ) {
	
				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
				return vec.clone().multiplyScalar( size ).add( pt );
	
			}
	
			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;
	
	
			// Find directions for point movement
	
	
			function getBevelVec( inPt, inPrev, inNext ) {
	
				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
				var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html
	
				var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	
				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
					// not collinear
	
					// length of vectors for normalizing
	
					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
					// shift adjacent points by unit vectors to the left
	
					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
					// scaling factor for v_prev to intersection point
	
					var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
							  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
					// vector from inPt to intersection point
	
					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {
	
						return	new Vector2( v_trans_x, v_trans_y );
	
					} else {
	
						shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
					}
	
				} else {
	
					// handle special case of collinear edges
	
					var direction_eq = false;		// assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {
	
						if ( v_next_x > Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( v_prev_x < - Number.EPSILON ) {
	
							if ( v_next_x < - Number.EPSILON ) {
	
								direction_eq = true;
	
							}
	
						} else {
	
							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
								direction_eq = true;
	
							}
	
						}
	
					}
	
					if ( direction_eq ) {
	
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y =  v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );
	
					} else {
	
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
					}
	
				}
	
				return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
			}
	
	
			var contourMovements = [];
	
			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)
	
				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
			}
	
			var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				oneHoleMovements = [];
	
				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
					if ( j === il ) j = 0;
					if ( k === il ) k = 0;
	
					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
				}
	
				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );
	
			}
	
	
			// Loop bevelSegments, 1 for the front, 1 for the back
	
			for ( b = 0; b < bevelSegments; b ++ ) {
	
				//for ( b = bevelSegments; b > 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						v( vert.x, vert.y,  - z );
	
					}
	
				}
	
			}
	
			bs = bevelSize;
	
			// Back facing vertices
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, 0 );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
			// Add stepped vertices...
			// Including front facing vertices
	
			var s;
	
			for ( s = 1; s <= steps; s ++ ) {
	
				for ( i = 0; i < vlen; i ++ ) {
	
					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y, amount / steps * s );
	
					} else {
	
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
						v( position2.x, position2.y, position2.z );
	
					}
	
				}
	
			}
	
	
			// Add bevel segments planes
	
			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos ( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y,  amount + z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						if ( ! extrudeByPath ) {
	
							v( vert.x, vert.y,  amount + z );
	
						} else {
	
							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
						}
	
					}
	
				}
	
			}
	
			/* Faces */
	
			// Top and bottom faces
	
			buildLidFaces();
	
			// Sides faces
	
			buildSideFaces();
	
	
			/////  Internal functions
	
			function buildLidFaces() {
	
				if ( bevelEnabled ) {
	
					var layer = 0; // steps + 1
					var offset = vlen * layer;
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
					}
	
					layer = steps + bevelSegments * 2;
					offset = vlen * layer;
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
					}
	
				} else {
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
					}
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
					}
	
				}
	
			}
	
			// Create faces for the z-sides of the shape
	
			function buildSideFaces() {
	
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );
	
					//, true
					layeroffset += ahole.length;
	
				}
	
			}
	
			function sidewalls( contour, layeroffset ) {
	
				var j, k;
				i = contour.length;
	
				while ( -- i >= 0 ) {
	
					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;
	
					//console.log('b', i,j, i-1, k,vertices.length);
	
					var s = 0, sl = steps  + bevelSegments * 2;
	
					for ( s = 0; s < sl; s ++ ) {
	
						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );
	
						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
	
						f4( a, b, c, d, contour, s, sl, j, k );
	
					}
	
				}
	
			}
	
	
			function v( x, y, z ) {
	
				scope.vertices.push( new Vector3( x, y, z ) );
	
			}
	
			function f3( a, b, c ) {
	
				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
	
				scope.faces.push( new Face3( a, b, c, null, null, 0 ) );
	
				var uvs = uvgen.generateTopUV( scope, a, b, c );
	
				scope.faceVertexUvs[ 0 ].push( uvs );
	
			}
	
			function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
				d += shapesOffset;
	
				scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
				scope.faces.push( new Face3( b, c, d, null, null, 1 ) );
	
				var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
			}
	
		};
	
		ExtrudeGeometry.WorldUVGenerator = {
	
			generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
				var vertices = geometry.vertices;
	
				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
	
				return [
					new Vector2( a.x, a.y ),
					new Vector2( b.x, b.y ),
					new Vector2( c.x, c.y )
				];
	
			},
	
			generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
				var vertices = geometry.vertices;
	
				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
				var d = vertices[ indexD ];
	
				if ( Math.abs( a.y - b.y ) < 0.01 ) {
	
					return [
						new Vector2( a.x, 1 - a.z ),
						new Vector2( b.x, 1 - b.z ),
						new Vector2( c.x, 1 - c.z ),
						new Vector2( d.x, 1 - d.z )
					];
	
				} else {
	
					return [
						new Vector2( a.y, 1 - a.z ),
						new Vector2( b.y, 1 - b.z ),
						new Vector2( c.y, 1 - c.z ),
						new Vector2( d.y, 1 - d.z )
					];
	
				}
	
			}
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float> // how far from text outline is bevel
		 * }
		 */
	
		function TextGeometry( text, parameters ) {
	
			parameters = parameters || {};
	
			var font = parameters.font;
	
			if ( ( font && font.isFont ) === false ) {
	
				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();
	
			}
	
			var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	
			// translate parameters to ExtrudeGeometry API
	
			parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
			// defaults
	
			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
			ExtrudeGeometry.call( this, shapes, parameters );
	
			this.type = 'TextGeometry';
	
		}
	
		TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'SphereGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	
		}
	
		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'SphereBufferGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
	
			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
			var thetaEnd = thetaStart + thetaLength;
	
			var ix, iy;
	
			var index = 0;
			var grid = [];
	
			var vertex = new Vector3();
			var normal = new Vector3();
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// generate vertices, normals and uvs
	
			for ( iy = 0; iy <= heightSegments; iy ++ ) {
	
				var verticesRow = [];
	
				var v = iy / heightSegments;
	
				for ( ix = 0; ix <= widthSegments; ix ++ ) {
	
					var u = ix / widthSegments;
	
					// vertex
	
					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normal.set( vertex.x, vertex.y, vertex.z ).normalize();
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( u, 1 - v );
	
					verticesRow.push( index ++ );
	
				}
	
				grid.push( verticesRow );
	
			}
	
			// indices
	
			for ( iy = 0; iy < heightSegments; iy ++ ) {
	
				for ( ix = 0; ix < widthSegments; ix ++ ) {
	
					var a = grid[ iy ][ ix + 1 ];
					var b = grid[ iy ][ ix ];
					var c = grid[ iy + 1 ][ ix ];
					var d = grid[ iy + 1 ][ ix + 1 ];
	
					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
	
		/**
		 * @author Kaleb Murphy
		 */
	
		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'RingGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	
		}
	
		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'RingBufferGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			innerRadius = innerRadius || 20;
			outerRadius = outerRadius || 50;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// some helper variables
	
			var segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;
	
			// generate vertices, normals and uvs
	
			for ( j = 0; j <= phiSegments; j ++ ) {
	
				for ( i = 0; i <= thetaSegments; i ++ ) {
	
					// values are generate from the inside of the ring to the outside
	
					segment = thetaStart + i / thetaSegments * thetaLength;
	
					// vertex
	
					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normals.push( 0, 0, 1 );
	
					// uv
	
					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;
	
					uvs.push( uv.x, uv.y );
	
				}
	
				// increase the radius for next row of vertices
	
				radius += radiusStep;
	
			}
	
			// indices
	
			for ( j = 0; j < phiSegments; j ++ ) {
	
				var thetaSegmentLevel = j * ( thetaSegments + 1 );
	
				for ( i = 0; i < thetaSegments; i ++ ) {
	
					segment = i + thetaSegmentLevel;
	
					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;
	
		/**
		 * @author astrodud / http://astrodud.isgreat.org/
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 */
	
		// points - to create a closed torus, one must use a set of points
		//    like so: [ a, b, c, d, a ], see first is the same as last.
		// segments - the number of circumference segments to create
		// phiStart - the starting radian
		// phiLength - the radian (0 to 2PI) range of the lathed section
		//    2PI is a closed lathe, less than 2PI is a portion.
	
		function LatheGeometry( points, segments, phiStart, phiLength ) {
	
			Geometry.call( this );
	
			this.type = 'LatheGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();
	
		}
	
		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'LatheBufferGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;
	
			// clamp phiLength so it's in range of [ 0, 2PI ]
	
			phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
	
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var uvs = [];
	
			// helper variables
	
			var base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;
	
			// generate vertices and uvs
	
			for ( i = 0; i <= segments; i ++ ) {
	
				var phi = phiStart + i * inverseSegments * phiLength;
	
				var sin = Math.sin( phi );
				var cos = Math.cos( phi );
	
				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
	
					// vertex
	
					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// uv
	
					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );
	
					uvs.push( uv.x, uv.y );
	
	
				}
	
			}
	
			// indices
	
			for ( i = 0; i < segments; i ++ ) {
	
				for ( j = 0; j < ( points.length - 1 ); j ++ ) {
	
					base = j + i * points.length;
	
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// generate normals
	
			this.computeVertexNormals();
	
			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).
	
			if ( phiLength === Math.PI * 2 ) {
	
				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();
	
				// this is the buffer offset for the last line of vertices
	
				base = segments * points.length * 3;
	
				for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
	
					// select the normal of the vertex in the first line
	
					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];
	
					// select the normal of the vertex in the last line
	
					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];
	
					// average normals
	
					n.addVectors( n1, n2 ).normalize();
	
					// assign the new values to both normals
	
					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
	
				}
	
			}
	
		}
	
		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
	
		/**
		 * @author jonobr1 / http://jonobr1.com
		 */
	
		function ShapeGeometry( shapes, curveSegments ) {
	
			Geometry.call( this );
	
			this.type = 'ShapeGeometry';
	
			if ( typeof curveSegments === 'object' ) {
	
				console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );
	
				curveSegments = curveSegments.curveSegments;
	
			}
	
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};
	
			this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
			this.mergeVertices();
	
		}
	
		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function ShapeBufferGeometry( shapes, curveSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'ShapeBufferGeometry';
	
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};
	
			curveSegments = curveSegments || 12;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var groupStart = 0;
			var groupCount = 0;
	
			// allow single and array values for "shapes" parameter
	
			if ( Array.isArray( shapes ) === false ) {
	
				addShape( shapes );
	
			} else {
	
				for ( var i = 0; i < shapes.length; i ++ ) {
	
					addShape( shapes[ i ] );
	
					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support
	
					groupStart += groupCount;
					groupCount = 0;
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	
			// helper functions
	
			function addShape( shape ) {
	
				var i, l, shapeHole;
	
				var indexOffset = vertices.length / 3;
				var points = shape.extractPoints( curveSegments );
	
				var shapeVertices = points.shape;
				var shapeHoles = points.holes;
	
				// check direction of vertices
	
				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {
	
					shapeVertices = shapeVertices.reverse();
	
					// also check if holes are in the opposite direction
	
					for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
						shapeHole = shapeHoles[ i ];
	
						if ( ShapeUtils.isClockWise( shapeHole ) === true ) {
	
							shapeHoles[ i ] = shapeHole.reverse();
	
						}
	
					}
	
				}
	
				var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );
	
				// join vertices of inner and outer paths to a single array
	
				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
					shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );
	
				}
	
				// vertices, normals, uvs
	
				for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {
	
					var vertex = shapeVertices[ i ];
	
					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs
	
				}
	
				// incides
	
				for ( i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					var a = face[ 0 ] + indexOffset;
					var b = face[ 1 ] + indexOffset;
					var c = face[ 2 ] + indexOffset;
	
					indices.push( a, b, c );
					groupCount += 3;
	
				}
	
			}
	
		}
	
		ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function EdgesGeometry( geometry, thresholdAngle ) {
	
			BufferGeometry.call( this );
	
			this.type = 'EdgesGeometry';
	
			this.parameters = {
				thresholdAngle: thresholdAngle
			};
	
			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
			// buffer
	
			var vertices = [];
	
			// helper variables
	
			var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
			var edge = [ 0, 0 ], edges = {};
			var key, keys = [ 'a', 'b', 'c' ];
	
			// prepare source geometry
	
			var geometry2;
	
			if ( geometry.isBufferGeometry ) {
	
				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );
	
			} else {
	
				geometry2 = geometry.clone();
	
			}
	
			geometry2.mergeVertices();
			geometry2.computeFaceNormals();
	
			var sourceVertices = geometry2.vertices;
			var faces = geometry2.faces;
	
			// now create a data structure where each entry represents an edge with its adjoining faces
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					key = edge.toString();
	
					if ( edges[ key ] === undefined ) {
	
						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };
	
					} else {
	
						edges[ key ].face2 = i;
	
					}
	
				}
	
			}
	
			// generate vertices
	
			for ( key in edges ) {
	
				var e = edges[ key ];
	
				// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
	
				if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {
	
					var vertex = sourceVertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					vertex = sourceVertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			}
	
			// build geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
			// custom array sort function
	
			function sortFunction( a, b ) {
	
				return a - b;
	
			}
	
		}
	
		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CylinderGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();
	
		}
	
		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CylinderBufferGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			var scope = this;
	
			radiusTop = radiusTop !== undefined ? radiusTop : 20;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
			height = height !== undefined ? height : 100;
	
			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;
	
			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var index = 0;
			var indexOffset = 0;
			var indexArray = [];
			var halfHeight = height / 2;
			var groupStart = 0;
	
			// generate geometry
	
			generateTorso();
	
			if ( openEnded === false ) {
	
				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			function generateTorso() {
	
				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;
	
				// generate vertices, normals and uvs
	
				for ( y = 0; y <= heightSegments; y ++ ) {
	
					var indexRow = [];
	
					var v = y / heightSegments;
	
					// calculate the radius of the current row
	
					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
					for ( x = 0; x <= radialSegments; x ++ ) {
	
						var u = x / radialSegments;
	
						var theta = u * thetaLength + thetaStart;
	
						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );
	
						// vertex
	
						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );
	
						// normal
	
						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );
	
						// uv
	
						uvs.push( u, 1 - v );
	
						// save index of vertex in respective row
	
						indexRow.push( index ++ );
	
					}
	
					// now save vertices of the row in our index array
	
					indexArray.push( indexRow );
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					for ( y = 0; y < heightSegments; y ++ ) {
	
						// we use the index array to access the correct indices
	
						var a = indexArray[ y ][ x ];
						var b = indexArray[ y + 1 ][ x ];
						var c = indexArray[ y + 1 ][ x + 1 ];
						var d = indexArray[ y ][ x + 1 ];
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
						// update group counter
	
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, 0 );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
			}
	
			function generateCap( top ) {
	
				var x, centerIndexStart, centerIndexEnd;
	
				var uv = new Vector2();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;
	
				// save the index of the first center vertex
				centerIndexStart = index;
	
				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment
	
				for ( x = 1; x <= radialSegments; x ++ ) {
	
					// vertex
	
					vertices.push( 0, halfHeight * sign, 0 );
	
					// normal
	
					normals.push( 0, sign, 0 );
	
					// uv
	
					uvs.push( 0.5, 0.5 );
	
					// increase index
	
					index ++;
	
				}
	
				// save the index of the last center vertex
	
				centerIndexEnd = index;
	
				// now we generate the surrounding vertices, normals and uvs
	
				for ( x = 0; x <= radialSegments; x ++ ) {
	
					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;
	
					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );
	
					// vertex
	
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normals.push( 0, sign, 0 );
	
					// uv
	
					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );
	
					// increase index
	
					index ++;
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;
	
					if ( top === true ) {
	
						// face top
	
						indices.push( i, i + 1, c );
	
					} else {
	
						// face bottom
	
						indices.push( i + 1, i, c );
	
					}
	
					groupCount += 3;
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
			}
	
		}
	
		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 */
	
		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;
	
		/**
		 * @author: abelnation / http://github.com/abelnation
		 */
	
		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeBufferGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
	
		/**
		 * @author hughes
		 */
	
		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CircleGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	
		}
	
		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CircleBufferGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var i, s;
			var vertex = new Vector3();
			var uv = new Vector2();
	
			// center point
	
			vertices.push( 0, 0, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( 0.5, 0.5 );
	
			for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {
	
				var segment = thetaStart + s / segments * thetaLength;
	
				// vertex
	
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal
	
				normals.push( 0, 0, 1 );
	
				// uvs
	
				uv.x = ( vertices[ i ] / radius + 1 ) / 2;
				uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
	
				uvs.push( uv.x, uv.y );
	
			}
	
			// indices
	
			for ( i = 1; i <= segments; i ++ ) {
	
				indices.push( i, i + 1, 0 );
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
	
	
	
		var Geometries = Object.freeze({
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			SphereGeometry: SphereGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ShapeBufferGeometry: ShapeBufferGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleGeometry: CircleGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			BoxGeometry: BoxGeometry,
			BoxBufferGeometry: BoxBufferGeometry
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ShadowMaterial() {
	
			ShaderMaterial.call( this, {
				uniforms: UniformsUtils.merge( [
					UniformsLib.lights,
					{
						opacity: { value: 1.0 }
					}
				] ),
				vertexShader: ShaderChunk[ 'shadow_vert' ],
				fragmentShader: ShaderChunk[ 'shadow_frag' ]
			} );
	
			this.lights = true;
			this.transparent = true;
	
			Object.defineProperties( this, {
				opacity: {
					enumerable: true,
					get: function () {
						return this.uniforms.opacity.value;
					},
					set: function ( value ) {
						this.uniforms.opacity.value = value;
					}
				}
			} );
	
		}
	
		ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;
	
		ShadowMaterial.prototype.isShadowMaterial = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function RawShaderMaterial( parameters ) {
	
			ShaderMaterial.call( this, parameters );
	
			this.type = 'RawShaderMaterial';
	
		}
	
		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;
	
		RawShaderMaterial.prototype.isRawShaderMaterial = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function MultiMaterial( materials ) {
	
			this.uuid = _Math.generateUUID();
	
			this.type = 'MultiMaterial';
	
			this.materials = Array.isArray( materials ) ? materials : [];
	
			this.visible = true;
	
		}
	
		MultiMaterial.prototype = {
	
			constructor: MultiMaterial,
	
			isMultiMaterial: true,
	
			toJSON: function ( meta ) {
	
				var output = {
					metadata: {
						version: 4.2,
						type: 'material',
						generator: 'MaterialExporter'
					},
					uuid: this.uuid,
					type: this.type,
					materials: []
				};
	
				var materials = this.materials;
	
				for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
					var material = materials[ i ].toJSON( meta );
					delete material.metadata;
	
					output.materials.push( material );
	
				}
	
				output.visible = this.visible;
	
				return output;
	
			},
	
			clone: function () {
	
				var material = new this.constructor();
	
				for ( var i = 0; i < this.materials.length; i ++ ) {
	
					material.materials.push( this.materials[ i ].clone() );
	
				}
	
				material.visible = this.visible;
	
				return material;
	
			}
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshStandardMaterial( parameters ) {
	
			Material.call( this );
	
			this.defines = { 'STANDARD': '' };
	
			this.type = 'MeshStandardMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 0.5;
			this.metalness = 0.5;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.roughnessMap = null;
	
			this.metalnessMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.envMapIntensity = 1.0;
	
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
	
		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
	
		MeshStandardMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.defines = { 'STANDARD': '' };
	
			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.roughnessMap = source.roughnessMap;
	
			this.metalnessMap = source.metalnessMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
	
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  reflectivity: <float>
		 * }
		 */
	
		function MeshPhysicalMaterial( parameters ) {
	
			MeshStandardMaterial.call( this );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.type = 'MeshPhysicalMaterial';
	
			this.reflectivity = 0.5; // maps to F0 = 0.04
	
			this.clearCoat = 0.0;
			this.clearCoatRoughness = 0.0;
	
			this.setValues( parameters );
	
		}
	
		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
	
		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
	
		MeshPhysicalMaterial.prototype.copy = function ( source ) {
	
			MeshStandardMaterial.prototype.copy.call( this, source );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.reflectivity = source.reflectivity;
	
			this.clearCoat = source.clearCoat;
			this.clearCoatRoughness = source.clearCoatRoughness;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshPhongMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshPhongMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
	
		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
	
		MeshPhongMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author takahirox / http://github.com/takahirox
		 *
		 * parameters = {
		 *  gradientMap: new THREE.Texture( <Image> )
		 * }
		 */
	
		function MeshToonMaterial( parameters ) {
	
			MeshPhongMaterial.call( this );
	
			this.defines = { 'TOON': '' };
	
			this.type = 'MeshToonMaterial';
	
			this.gradientMap = null;
	
			this.setValues( parameters );
	
		}
	
		MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
		MeshToonMaterial.prototype.constructor = MeshToonMaterial;
	
		MeshToonMaterial.prototype.isMeshToonMaterial = true;
	
		MeshToonMaterial.prototype.copy = function ( source ) {
	
			MeshPhongMaterial.prototype.copy.call( this, source );
	
			this.gradientMap = source.gradientMap;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshNormalMaterial( parameters ) {
	
			Material.call( this, parameters );
	
			this.type = 'MeshNormalMaterial';
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
	
		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
	
		MeshNormalMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshLambertMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshLambertMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
	
		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
	
		MeshLambertMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */
	
		function LineDashedMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineDashedMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
	
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineDashedMaterial.prototype = Object.create( Material.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;
	
		LineDashedMaterial.prototype.isLineDashedMaterial = true;
	
		LineDashedMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
	
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
	
			return this;
	
		};
	
	
	
		var Materials = Object.freeze({
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MultiMaterial: MultiMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshToonMaterial: MeshToonMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			Material: Material
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var Cache = {
	
			enabled: false,
	
			files: {},
	
			add: function ( key, file ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Adding key:', key );
	
				this.files[ key ] = file;
	
			},
	
			get: function ( key ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Checking key:', key );
	
				return this.files[ key ];
	
			},
	
			remove: function ( key ) {
	
				delete this.files[ key ];
	
			},
	
			clear: function () {
	
				this.files = {};
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LoadingManager( onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;
	
			this.itemStart = function ( url ) {
	
				itemsTotal ++;
	
				if ( isLoading === false ) {
	
					if ( scope.onStart !== undefined ) {
	
						scope.onStart( url, itemsLoaded, itemsTotal );
	
					}
	
				}
	
				isLoading = true;
	
			};
	
			this.itemEnd = function ( url ) {
	
				itemsLoaded ++;
	
				if ( scope.onProgress !== undefined ) {
	
					scope.onProgress( url, itemsLoaded, itemsTotal );
	
				}
	
				if ( itemsLoaded === itemsTotal ) {
	
					isLoading = false;
	
					if ( scope.onLoad !== undefined ) {
	
						scope.onLoad();
	
					}
	
				}
	
			};
	
			this.itemError = function ( url ) {
	
				if ( scope.onError !== undefined ) {
	
					scope.onError( url );
	
				}
	
			};
	
		}
	
		var DefaultLoadingManager = new LoadingManager();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function FileLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( FileLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( url === undefined ) url = '';
	
				if ( this.path !== undefined ) url = this.path + url;
	
				var scope = this;
	
				var cached = Cache.get( url );
	
				if ( cached !== undefined ) {
	
					scope.manager.itemStart( url );
	
					setTimeout( function () {
	
						if ( onLoad ) onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
					return cached;
	
				}
	
				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );
	
				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {
	
					var mimeType = dataUriRegexResult[ 1 ];
					var isBase64 = !! dataUriRegexResult[ 2 ];
					var data = dataUriRegexResult[ 3 ];
	
					data = window.decodeURIComponent( data );
	
					if ( isBase64 ) data = window.atob( data );
	
					try {
	
						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();
	
						switch ( responseType ) {
	
							case 'arraybuffer':
							case 'blob':
	
							 	response = new ArrayBuffer( data.length );
	
								var view = new Uint8Array( response );
	
								for ( var i = 0; i < data.length; i ++ ) {
	
									view[ i ] = data.charCodeAt( i );
	
								}
	
								if ( responseType === 'blob' ) {
	
									response = new Blob( [ response ], { type: mimeType } );
	
								}
	
								break;
	
							case 'document':
	
								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );
	
								break;
	
							case 'json':
	
								response = JSON.parse( data );
	
								break;
	
							default: // 'text' or other
	
								response = data;
	
								break;
	
						}
	
						// Wait for next browser tick
						window.setTimeout( function () {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						}, 0 );
	
					} catch ( error ) {
	
						// Wait for next browser tick
						window.setTimeout( function () {
	
							if ( onError ) onError( error );
	
							scope.manager.itemError( url );
	
						}, 0 );
	
					}
	
				} else {
	
					var request = new XMLHttpRequest();
					request.open( 'GET', url, true );
	
					request.addEventListener( 'load', function ( event ) {
	
						var response = event.target.response;
	
						Cache.add( url, response );
	
						if ( this.status === 200 ) {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else if ( this.status === 0 ) {
	
							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.
	
							console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else {
	
							if ( onError ) onError( event );
	
							scope.manager.itemError( url );
	
						}
	
					}, false );
	
					if ( onProgress !== undefined ) {
	
						request.addEventListener( 'progress', function ( event ) {
	
							onProgress( event );
	
						}, false );
	
					}
	
					request.addEventListener( 'error', function ( event ) {
	
						if ( onError ) onError( event );
	
						scope.manager.itemError( url );
	
					}, false );
	
					if ( this.responseType !== undefined ) request.responseType = this.responseType;
					if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
					if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );
	
					request.send( null );
	
				}
	
				scope.manager.itemStart( url );
	
				return request;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			},
	
			setResponseType: function ( value ) {
	
				this.responseType = value;
				return this;
	
			},
	
			setWithCredentials: function ( value ) {
	
				this.withCredentials = value;
				return this;
	
			},
	
			setMimeType: function ( value ) {
	
				this.mimeType = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 */
	
		function CompressedTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( CompressedTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var images = [];
	
				var texture = new CompressedTexture();
				texture.image = images;
	
				var loader = new FileLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );
	
				function loadTexture( i ) {
	
					loader.load( url[ i ], function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};
	
						loaded += 1;
	
						if ( loaded === 6 ) {
	
							if ( texDatas.mipmapCount === 1 )
								texture.minFilter = LinearFilter;
	
							texture.format = texDatas.format;
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, onProgress, onError );
	
				}
	
				if ( Array.isArray( url ) ) {
	
					var loaded = 0;
	
					for ( var i = 0, il = url.length; i < il; ++ i ) {
	
						loadTexture( i );
	
					}
	
				} else {
	
					// compressed cubemap texture stored in a single DDS file
	
					loader.load( url, function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						if ( texDatas.isCubemap ) {
	
							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
							for ( var f = 0; f < faces; f ++ ) {
	
								images[ f ] = { mipmaps : [] };
	
								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;
	
								}
	
							}
	
						} else {
	
							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;
	
						}
	
						if ( texDatas.mipmapCount === 1 ) {
	
							texture.minFilter = LinearFilter;
	
						}
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}, onProgress, onError );
	
				}
	
				return texture;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 */
	
		function DataTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( DataTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texture = new DataTexture();
	
				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
	
				loader.load( url, function ( buffer ) {
	
					var texData = scope._parser( buffer );
	
					if ( ! texData ) return;
	
					if ( undefined !== texData.image ) {
	
						texture.image = texData.image;
	
					} else if ( undefined !== texData.data ) {
	
						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;
	
					}
	
					texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
	
					texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
					texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
	
					texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
					if ( undefined !== texData.format ) {
	
						texture.format = texData.format;
	
					}
					if ( undefined !== texData.type ) {
	
						texture.type = texData.type;
	
					}
	
					if ( undefined !== texData.mipmaps ) {
	
						texture.mipmaps = texData.mipmaps;
	
					}
	
					if ( 1 === texData.mipmapCount ) {
	
						texture.minFilter = LinearFilter;
	
					}
	
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture, texData );
	
				}, onProgress, onError );
	
	
				return texture;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ImageLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( ImageLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( url === undefined ) url = '';
	
				if ( this.path !== undefined ) url = this.path + url;
	
				var scope = this;
	
				var cached = Cache.get( url );
	
				if ( cached !== undefined ) {
	
					scope.manager.itemStart( url );
	
					setTimeout( function () {
	
						if ( onLoad ) onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
					return cached;
	
				}
	
				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
	
				image.addEventListener( 'load', function () {
	
					Cache.add( url, this );
	
					if ( onLoad ) onLoad( this );
	
					scope.manager.itemEnd( url );
	
				}, false );
	
				/*
				image.addEventListener( 'progress', function ( event ) {
	
					if ( onProgress ) onProgress( event );
	
				}, false );
				*/
	
				image.addEventListener( 'error', function ( event ) {
	
					if ( onError ) onError( event );
	
					scope.manager.itemError( url );
	
				}, false );
	
				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
				scope.manager.itemStart( url );
	
				image.src = url;
	
				return image;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( CubeTextureLoader.prototype, {
	
			load: function ( urls, onLoad, onProgress, onError ) {
	
				var texture = new CubeTexture();
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
	
				var loaded = 0;
	
				function loadTexture( i ) {
	
					loader.load( urls[ i ], function ( image ) {
	
						texture.images[ i ] = image;
	
						loaded ++;
	
						if ( loaded === 6 ) {
	
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, undefined, onError );
	
				}
	
				for ( var i = 0; i < urls.length; ++ i ) {
	
					loadTexture( i );
	
				}
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function TextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( TextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var texture = new Texture();
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
				loader.load( url, function ( image ) {
	
					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
	
					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.image = image;
					texture.needsUpdate = true;
	
					if ( onLoad !== undefined ) {
	
						onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Light( color, intensity ) {
	
			Object3D.call( this );
	
			this.type = 'Light';
	
			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;
	
			this.receiveShadow = undefined;
	
		}
	
		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Light,
	
			isLight: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.color.copy( source.color );
				this.intensity = source.intensity;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;
	
				if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
				if ( this.distance !== undefined ) data.object.distance = this.distance;
				if ( this.angle !== undefined ) data.object.angle = this.angle;
				if ( this.decay !== undefined ) data.object.decay = this.decay;
				if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
	
				if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function HemisphereLight( skyColor, groundColor, intensity ) {
	
			Light.call( this, skyColor, intensity );
	
			this.type = 'HemisphereLight';
	
			this.castShadow = undefined;
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.groundColor = new Color( groundColor );
	
		}
	
		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: HemisphereLight,
	
			isHemisphereLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.groundColor.copy( source.groundColor );
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LightShadow( camera ) {
	
			this.camera = camera;
	
			this.bias = 0;
			this.radius = 1;
	
			this.mapSize = new Vector2( 512, 512 );
	
			this.map = null;
			this.matrix = new Matrix4();
	
		}
	
		Object.assign( LightShadow.prototype, {
	
			copy: function ( source ) {
	
				this.camera = source.camera.clone();
	
				this.bias = source.bias;
				this.radius = source.radius;
	
				this.mapSize.copy( source.mapSize );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			toJSON: function () {
	
				var object = {};
	
				if ( this.bias !== 0 ) object.bias = this.bias;
				if ( this.radius !== 1 ) object.radius = this.radius;
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
	
				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;
	
				return object;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function SpotLightShadow() {
	
			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
	
		}
	
		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: SpotLightShadow,
	
			isSpotLightShadow: true,
	
			update: function ( light ) {
	
				var fov = _Math.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || 500;
	
				var camera = this.camera;
	
				if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
	
					camera.fov = fov;
					camera.aspect = aspect;
					camera.far = far;
					camera.updateProjectionMatrix();
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'SpotLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * Math.PI;
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / Math.PI;
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new SpotLightShadow();
	
		}
	
		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: SpotLight,
	
			isSpotLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
	
		function PointLight( color, intensity, distance, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'PointLight';
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * 4 * Math.PI;
	
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / ( 4 * Math.PI );
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
		}
	
		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: PointLight,
	
			isPointLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.decay = source.decay;
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectionalLightShadow( ) {
	
			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
	
		}
	
		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: DirectionalLightShadow
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DirectionalLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'DirectionalLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			this.shadow = new DirectionalLightShadow();
	
		}
	
		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: DirectionalLight,
	
			isDirectionalLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AmbientLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'AmbientLight';
	
			this.castShadow = undefined;
	
		}
	
		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: AmbientLight,
	
			isAmbientLight: true
	
		} );
	
		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		var AnimationUtils = {
	
			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function( array, from, to ) {
	
				if ( AnimationUtils.isTypedArray( array ) ) {
	
					return new array.constructor( array.subarray( from, to ) );
	
				}
	
				return array.slice( from, to );
	
			},
	
			// converts an array to a specific type
			convertArray: function( array, type, forceClone ) {
	
				if ( ! array || // let 'undefined' and 'null' pass
						! forceClone && array.constructor === type ) return array;
	
				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
					return new type( array ); // create typed array
	
				}
	
				return Array.prototype.slice.call( array ); // create Array
	
			},
	
			isTypedArray: function( object ) {
	
				return ArrayBuffer.isView( object ) &&
						! ( object instanceof DataView );
	
			},
	
			// returns an array by which times and values can be sorted
			getKeyframeOrder: function( times ) {
	
				function compareTime( i, j ) {
	
					return times[ i ] - times[ j ];
	
				}
	
				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
				result.sort( compareTime );
	
				return result;
	
			},
	
			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function( values, stride, order ) {
	
				var nValues = values.length;
				var result = new values.constructor( nValues );
	
				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
					var srcOffset = order[ i ] * stride;
	
					for ( var j = 0; j !== stride; ++ j ) {
	
						result[ dstOffset ++ ] = values[ srcOffset + j ];
	
					}
	
				}
	
				return result;
	
			},
	
			// function for parsing AOS keyframe formats
			flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {
	
				var i = 1, key = jsonKeys[ 0 ];
	
				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
					key = jsonKeys[ i ++ ];
	
				}
	
				if ( key === undefined ) return; // no data
	
				var value = key[ valuePropertyName ];
				if ( value === undefined ) return; // no data
	
				if ( Array.isArray( value ) ) {
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push.apply( values, value ); // push all elements
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else if ( value.toArray !== undefined ) {
					// ...assume THREE.Math-ish
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							value.toArray( values, values.length );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else {
					// otherwise push as-is
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push( value );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				}
	
			}
	
		};
	
		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */
	
		function Interpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
	
			this.resultBuffer = resultBuffer !== undefined ?
					resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
	
		}
	
		Interpolant.prototype = {
	
			constructor: Interpolant,
	
			evaluate: function( t ) {
	
				var pp = this.parameterPositions,
					i1 = this._cachedIndex,
	
					t1 = pp[   i1   ],
					t0 = pp[ i1 - 1 ];
	
				validate_interval: {
	
					seek: {
	
						var right;
	
						linear_scan: {
		//- See http://jsperf.com/comparison-to-undefined/3
		//- slower code:
		//-
		//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {
	
								for ( var giveUpAt = i1 + 2; ;) {
	
									if ( t1 === undefined ) {
	
										if ( t < t0 ) break forward_scan;
	
										// after end
	
										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t0 = t1;
									t1 = pp[ ++ i1 ];
	
									if ( t < t1 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;
	
							}
	
		//- slower code:
		//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {
	
								// looping?
	
								var t1global = pp[ 1 ];
	
								if ( t < t1global ) {
	
									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;
	
								}
	
								// linear reverse scan
	
								for ( var giveUpAt = i1 - 2; ;) {
	
									if ( t0 === undefined ) {
	
										// before start
	
										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t1 = t0;
									t0 = pp[ -- i1 - 1 ];
	
									if ( t >= t0 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;
	
							}
	
							// the interval is valid
	
							break validate_interval;
	
						} // linear scan
	
						// binary search
	
						while ( i1 < right ) {
	
							var mid = ( i1 + right ) >>> 1;
	
							if ( t < pp[ mid ] ) {
	
								right = mid;
	
							} else {
	
								i1 = mid + 1;
	
							}
	
						}
	
						t1 = pp[   i1   ];
						t0 = pp[ i1 - 1 ];
	
						// check boundary cases, again
	
						if ( t0 === undefined ) {
	
							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );
	
						}
	
						if ( t1 === undefined ) {
	
							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );
	
						}
	
					} // seek
	
					this._cachedIndex = i1;
	
					this.intervalChanged_( i1, t0, t1 );
	
				} // validate_interval
	
				return this.interpolate_( i1, t0, t, t1 );
	
			},
	
			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.
	
			// --- Protected interface
	
			DefaultSettings_: {},
	
			getSettings_: function() {
	
				return this.settings || this.DefaultSettings_;
	
			},
	
			copySampleValue_: function( index ) {
	
				// copies a sample value to the result buffer
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] = values[ offset + i ];
	
				}
	
				return result;
	
			},
	
			// Template methods for derived classes:
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				throw new Error( "call to abstract method" );
				// implementations shall return this.resultBuffer
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				// empty
	
			}
	
		};
	
		Object.assign( Interpolant.prototype, {
	
			beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_,
	
			afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_
	
		} );
	
		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */
	
		function CubicInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
	
		}
	
		CubicInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: CubicInterpolant,
	
			DefaultSettings_: {
	
				endingStart: 	ZeroCurvatureEnding,
				endingEnd:		ZeroCurvatureEnding
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,
	
					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];
	
				if ( tPrev === undefined ) {
	
					switch ( this.getSettings_().endingStart ) {
	
						case ZeroSlopeEnding:
	
							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;
	
					}
	
				}
	
				if ( tNext === undefined ) {
	
					switch ( this.getSettings_().endingEnd ) {
	
						case ZeroSlopeEnding:
	
							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;
	
					}
	
				}
	
				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;
	
				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;
	
			},
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,
	
					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;
	
				// evaluate polynomials
	
				var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
				var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
				var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
				var sN =       wN   * ppp   -           wN      * pp;
	
				// combine data linearly
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 */
	
		function LinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		LinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: LinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset1 = i1 * stride,
					offset0 = offset1 - stride,
	
					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */
	
		function DiscreteInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		DiscreteInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: DiscreteInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				return this.copySampleValue_( i1 - 1 );
	
			}
	
		} );
	
		var KeyframeTrackPrototype;
	
		KeyframeTrackPrototype = {
	
			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodDiscrete: function ( result ) {
	
				return new DiscreteInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodLinear: function ( result ) {
	
				return new LinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: function ( result ) {
	
				return new CubicInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			setInterpolation: function ( interpolation ) {
	
				var factoryMethod;
	
				switch ( interpolation ) {
	
					case InterpolateDiscrete:
	
						factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
						break;
	
					case InterpolateLinear:
	
						factoryMethod = this.InterpolantFactoryMethodLinear;
	
						break;
	
					case InterpolateSmooth:
	
						factoryMethod = this.InterpolantFactoryMethodSmooth;
	
						break;
	
				}
	
				if ( factoryMethod === undefined ) {
	
					var message = "unsupported interpolation for " +
							this.ValueTypeName + " keyframe track named " + this.name;
	
					if ( this.createInterpolant === undefined ) {
	
						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {
	
							this.setInterpolation( this.DefaultInterpolation );
	
						} else {
	
							throw new Error( message ); // fatal, in this case
	
						}
	
					}
	
					console.warn( message );
					return;
	
				}
	
				this.createInterpolant = factoryMethod;
	
			},
	
			getInterpolation: function () {
	
				switch ( this.createInterpolant ) {
	
					case this.InterpolantFactoryMethodDiscrete:
	
						return InterpolateDiscrete;
	
					case this.InterpolantFactoryMethodLinear:
	
						return InterpolateLinear;
	
					case this.InterpolantFactoryMethodSmooth:
	
						return InterpolateSmooth;
	
				}
	
			},
	
			getValueSize: function () {
	
				return this.values.length / this.times.length;
	
			},
	
			// move all keyframes either forwards or backwards in time
			shift: function ( timeOffset ) {
	
				if ( timeOffset !== 0.0 ) {
	
					var times = this.times;
	
					for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] += timeOffset;
	
					}
	
				}
	
				return this;
	
			},
	
			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function ( timeScale ) {
	
				if ( timeScale !== 1.0 ) {
	
					var times = this.times;
	
					for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] *= timeScale;
	
					}
	
				}
	
				return this;
	
			},
	
			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function ( startTime, endTime ) {
	
				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;
	
				while ( from !== nKeys && times[ from ] < startTime ) ++ from;
				while ( to !== - 1 && times[ to ] > endTime ) -- to;
	
				++ to; // inclusive -> exclusive bound
	
				if ( from !== 0 || to !== nKeys ) {
	
					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;
	
					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.
							arraySlice( this.values, from * stride, to * stride );
	
				}
	
				return this;
	
			},
	
			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function () {
	
				var valid = true;
	
				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
					console.error( "invalid value size in track", this );
					valid = false;
	
				}
	
				var times = this.times,
					values = this.values,
	
					nKeys = times.length;
	
				if ( nKeys === 0 ) {
	
					console.error( "track is empty", this );
					valid = false;
	
				}
	
				var prevTime = null;
	
				for ( var i = 0; i !== nKeys; i ++ ) {
	
					var currTime = times[ i ];
	
					if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
						console.error( "time is not a valid number", this, i, currTime );
						valid = false;
						break;
	
					}
	
					if ( prevTime !== null && prevTime > currTime ) {
	
						console.error( "out of order keys", this, i, currTime, prevTime );
						valid = false;
						break;
	
					}
	
					prevTime = currTime;
	
				}
	
				if ( values !== undefined ) {
	
					if ( AnimationUtils.isTypedArray( values ) ) {
	
						for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
							var value = values[ i ];
	
							if ( isNaN( value ) ) {
	
								console.error( "value is not a valid number", this, i, value );
								valid = false;
								break;
	
							}
	
						}
	
					}
	
				}
	
				return valid;
	
			},
	
			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function () {
	
				var times = this.times,
					values = this.values,
					stride = this.getValueSize(),
	
					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
	
					writeIndex = 1,
					lastIndex = times.length - 1;
	
				for ( var i = 1; i < lastIndex; ++ i ) {
	
					var keep = false;
	
					var time = times[ i ];
					var timeNext = times[ i + 1 ];
	
					// remove adjacent keyframes scheduled at the same time
	
					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
						if ( ! smoothInterpolation ) {
	
							// remove unnecessary keyframes same as their neighbors
	
							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;
	
							for ( var j = 0; j !== stride; ++ j ) {
	
								var value = values[ offset + j ];
	
								if ( value !== values[ offsetP + j ] ||
										value !== values[ offsetN + j ] ) {
	
									keep = true;
									break;
	
								}
	
							}
	
						} else keep = true;
	
					}
	
					// in-place compaction
	
					if ( keep ) {
	
						if ( i !== writeIndex ) {
	
							times[ writeIndex ] = times[ i ];
	
							var readOffset = i * stride,
								writeOffset = writeIndex * stride;
	
							for ( var j = 0; j !== stride; ++ j )
	
								values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
						++ writeIndex;
	
					}
	
				}
	
				// flush last keyframe (compaction looks ahead)
	
				if ( lastIndex > 0 ) {
	
					times[ writeIndex ] = times[ lastIndex ];
	
					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )
	
						values[ writeOffset + j ] = values[ readOffset + j ];
	
					++ writeIndex;
	
				}
	
				if ( writeIndex !== times.length ) {
	
					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
				}
	
				return this;
	
			}
	
		};
	
		function KeyframeTrackConstructor( name, times, values, interpolation ) {
	
			if( name === undefined ) throw new Error( "track name is undefined" );
	
			if( times === undefined || times.length === 0 ) {
	
				throw new Error( "no keyframes in track named " + name );
	
			}
	
			this.name = name;
	
			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
	
			this.setInterpolation( interpolation || this.DefaultInterpolation );
	
			this.validate();
			this.optimize();
	
		}
	
		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function VectorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		VectorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: VectorKeyframeTrack,
	
			ValueTypeName: 'vector'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */
	
		function QuaternionLinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		QuaternionLinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: QuaternionLinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset = i1 * stride,
	
					alpha = ( t - t0 ) / ( t1 - t0 );
	
				for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
					Quaternion.slerpFlat( result, 0,
							values, offset - stride, values, offset, alpha );
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function QuaternionKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		QuaternionKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: QuaternionKeyframeTrack,
	
			ValueTypeName: 'quaternion',
	
			// ValueBufferType is inherited
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodLinear: function( result ) {
	
				return new QuaternionLinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
		} );
	
		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function NumberKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		NumberKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: NumberKeyframeTrack,
	
			ValueTypeName: 'number'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function StringKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		StringKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: StringKeyframeTrack,
	
			ValueTypeName: 'string',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
	
			InterpolantFactoryMethodSmooth: undefined
	
		} );
	
		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function BooleanKeyframeTrack( name, times, values ) {
	
			KeyframeTrackConstructor.call( this, name, times, values );
	
		}
	
		BooleanKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: BooleanKeyframeTrack,
	
			ValueTypeName: 'bool',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined
	
			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".
	
		} );
	
		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function ColorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		ColorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: ColorKeyframeTrack,
	
			ValueTypeName: 'color'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
	
			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.
	
		} );
	
		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function KeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.apply( this, arguments );
	
		}
	
		KeyframeTrack.prototype = KeyframeTrackPrototype;
		KeyframeTrackPrototype.constructor = KeyframeTrack;
	
		// Static methods:
	
		Object.assign( KeyframeTrack, {
	
			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):
	
			parse: function( json ) {
	
				if( json.type === undefined ) {
	
					throw new Error( "track type undefined, can not parse" );
	
				}
	
				var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );
	
				if ( json.times === undefined ) {
	
					var times = [], values = [];
	
					AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
					json.times = times;
					json.values = values;
	
				}
	
				// derived classes can define a static parse method
				if ( trackType.parse !== undefined ) {
	
					return trackType.parse( json );
	
				} else {
	
					// by default, we asssume a constructor compatible with the base
					return new trackType(
							json.name, json.times, json.values, json.interpolation );
	
				}
	
			},
	
			toJSON: function( track ) {
	
				var trackType = track.constructor;
	
				var json;
	
				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {
	
					json = trackType.toJSON( track );
	
				} else {
	
					// by default, we assume the data can be serialized as-is
					json = {
	
						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )
	
					};
	
					var interpolation = track.getInterpolation();
	
					if ( interpolation !== track.DefaultInterpolation ) {
	
						json.interpolation = interpolation;
	
					}
	
				}
	
				json.type = track.ValueTypeName; // mandatory
	
				return json;
	
			},
	
			_getTrackTypeForValueTypeName: function( typeName ) {
	
				switch( typeName.toLowerCase() ) {
	
					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":
	
						return NumberKeyframeTrack;
	
					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":
	
						return VectorKeyframeTrack;
	
					case "color":
	
						return ColorKeyframeTrack;
	
					case "quaternion":
	
						return QuaternionKeyframeTrack;
	
					case "bool":
					case "boolean":
	
						return BooleanKeyframeTrack;
	
					case "string":
	
						return StringKeyframeTrack;
	
				}
	
				throw new Error( "Unsupported typeName: " + typeName );
	
			}
	
		} );
	
		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		function AnimationClip( name, duration, tracks ) {
	
			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : -1;
	
			this.uuid = _Math.generateUUID();
	
			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {
	
				this.resetDuration();
	
			}
	
			this.optimize();
	
		}
	
		AnimationClip.prototype = {
	
			constructor: AnimationClip,
	
			resetDuration: function() {
	
				var tracks = this.tracks,
					duration = 0;
	
				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
					var track = this.tracks[ i ];
	
					duration = Math.max( duration, track.times[ track.times.length - 1 ] );
	
				}
	
				this.duration = duration;
	
			},
	
			trim: function() {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].trim( 0, this.duration );
	
				}
	
				return this;
	
			},
	
			optimize: function() {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].optimize();
	
				}
	
				return this;
	
			}
	
		};
	
		// Static methods:
	
		Object.assign( AnimationClip, {
	
			parse: function( json ) {
	
				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );
	
				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
	
				}
	
				return new AnimationClip( json.name, json.duration, tracks );
	
			},
	
	
			toJSON: function( clip ) {
	
				var tracks = [],
					clipTracks = clip.tracks;
	
				var json = {
	
					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks
	
				};
	
				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
				}
	
				return json;
	
			},
	
	
			CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {
	
				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];
	
				for ( var i = 0; i < numMorphTargets; i ++ ) {
	
					var times = [];
					var values = [];
	
					times.push(
							( i + numMorphTargets - 1 ) % numMorphTargets,
							i,
							( i + 1 ) % numMorphTargets );
	
					values.push( 0, 1, 0 );
	
					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );
	
					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {
	
						times.push( numMorphTargets );
						values.push( values[ 0 ] );
	
					}
	
					tracks.push(
							new NumberKeyframeTrack(
								'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
								times, values
							).scale( 1.0 / fps ) );
				}
	
				return new AnimationClip( name, -1, tracks );
	
			},
	
			findByName: function( objectOrClipArray, name ) {
	
				var clipArray = objectOrClipArray;
	
				if ( ! Array.isArray( objectOrClipArray ) ) {
	
					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;
	
				}
	
				for ( var i = 0; i < clipArray.length; i ++ ) {
	
					if ( clipArray[ i ].name === name ) {
	
						return clipArray[ i ];
	
					}
				}
	
				return null;
	
			},
	
			CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {
	
				var animationToMorphTargets = {};
	
				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;
	
				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );
	
					if ( parts && parts.length > 1 ) {
	
						var name = parts[ 1 ];
	
						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {
	
							animationToMorphTargets[ name ] = animationMorphTargets = [];
	
						}
	
						animationMorphTargets.push( morphTarget );
	
					}
	
				}
	
				var clips = [];
	
				for ( var name in animationToMorphTargets ) {
	
					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
	
				}
	
				return clips;
	
			},
	
			// parse the animation.hierarchy format
			parseAnimation: function( animation, bones ) {
	
				if ( ! animation ) {
	
					console.error( "  no animation in JSONLoader data" );
					return null;
	
				}
	
				var addNonemptyTrack = function(
						trackType, trackName, animationKeys, propertyName, destTracks ) {
	
					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {
	
						var times = [];
						var values = [];
	
						AnimationUtils.flattenJSON(
								animationKeys, times, values, propertyName );
	
						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {
	
							destTracks.push( new trackType( trackName, times, values ) );
	
						}
	
					}
	
				};
	
				var tracks = [];
	
				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || -1;
				var fps = animation.fps || 30;
	
				var hierarchyTracks = animation.hierarchy || [];
	
				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
					var animationKeys = hierarchyTracks[ h ].keys;
	
					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) continue;
	
					// process morph targets in a way exactly compatible
					// with AnimationHandler.init( animation )
					if ( animationKeys[0].morphTargets ) {
	
						// figure out all morph targets used in this track
						var morphTargetNames = {};
						for ( var k = 0; k < animationKeys.length; k ++ ) {
	
							if ( animationKeys[k].morphTargets ) {
	
								for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
									morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
								}
	
							}
	
						}
	
						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {
	
							var times = [];
							var values = [];
	
							for ( var m = 0; m !== animationKeys[k].morphTargets.length; ++ m ) {
	
								var animationKey = animationKeys[k];
	
								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
	
							}
	
							tracks.push( new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
						}
	
						duration = morphTargetNames.length * ( fps || 1.0 );
	
					} else {
						// ...assume skeletal animation
	
						var boneName = '.bones[' + bones[ h ].name + ']';
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.position',
								animationKeys, 'pos', tracks );
	
						addNonemptyTrack(
								QuaternionKeyframeTrack, boneName + '.quaternion',
								animationKeys, 'rot', tracks );
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.scale',
								animationKeys, 'scl', tracks );
	
					}
	
				}
	
				if ( tracks.length === 0 ) {
	
					return null;
	
				}
	
				var clip = new AnimationClip( clipName, duration, tracks );
	
				return clip;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function MaterialLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.textures = {};
	
		}
	
		Object.assign( MaterialLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			setTextures: function ( value ) {
	
				this.textures = value;
	
			},
	
			parse: function ( json ) {
	
				var textures = this.textures;
	
				function getTexture( name ) {
	
					if ( textures[ name ] === undefined ) {
	
						console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
					}
	
					return textures[ name ];
	
				}
	
				var material = new Materials[ json.type ]();
	
				if ( json.uuid !== undefined ) material.uuid = json.uuid;
				if ( json.name !== undefined ) material.name = json.name;
				if ( json.color !== undefined ) material.color.setHex( json.color );
				if ( json.roughness !== undefined ) material.roughness = json.roughness;
				if ( json.metalness !== undefined ) material.metalness = json.metalness;
				if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
				if ( json.specular !== undefined ) material.specular.setHex( json.specular );
				if ( json.shininess !== undefined ) material.shininess = json.shininess;
				if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
				if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
				if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
				if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
				if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
				if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
				if ( json.fog !== undefined ) material.fog = json.fog;
				if ( json.shading !== undefined ) material.shading = json.shading;
				if ( json.blending !== undefined ) material.blending = json.blending;
				if ( json.side !== undefined ) material.side = json.side;
				if ( json.opacity !== undefined ) material.opacity = json.opacity;
				if ( json.transparent !== undefined ) material.transparent = json.transparent;
				if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
				if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
				if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
				if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
				if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
				if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
				if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
				if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
				if ( json.skinning !== undefined ) material.skinning = json.skinning;
				if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
	
				// for PointsMaterial
	
				if ( json.size !== undefined ) material.size = json.size;
				if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
				// maps
	
				if ( json.map !== undefined ) material.map = getTexture( json.map );
	
				if ( json.alphaMap !== undefined ) {
	
					material.alphaMap = getTexture( json.alphaMap );
					material.transparent = true;
	
				}
	
				if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
				if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
				if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
				if ( json.normalScale !== undefined ) {
	
					var normalScale = json.normalScale;
	
					if ( Array.isArray( normalScale ) === false ) {
	
						// Blender exporter used to export a scalar. See #7459
	
						normalScale = [ normalScale, normalScale ];
	
					}
	
					material.normalScale = new Vector2().fromArray( normalScale );
	
				}
	
				if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
				if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
				if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
				if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
				if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
	
				if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
				if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
				if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
	
				if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
	
				if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
	
				if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
				if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
				if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
				if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
				if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );
	
				// MultiMaterial
	
				if ( json.materials !== undefined ) {
	
					for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
						material.materials.push( this.parse( json.materials[ i ] ) );
	
					}
	
				}
	
				return material;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometryLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( BufferGeometryLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				var geometry = new BufferGeometry();
	
				var index = json.data.index;
	
				var TYPED_ARRAYS = {
					'Int8Array': Int8Array,
					'Uint8Array': Uint8Array,
					'Uint8ClampedArray': Uint8ClampedArray,
					'Int16Array': Int16Array,
					'Uint16Array': Uint16Array,
					'Int32Array': Int32Array,
					'Uint32Array': Uint32Array,
					'Float32Array': Float32Array,
					'Float64Array': Float64Array
				};
	
				if ( index !== undefined ) {
	
					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
	
				}
	
				var attributes = json.data.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
					geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
	
				}
	
				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
				if ( groups !== undefined ) {
	
					for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
						var group = groups[ i ];
	
						geometry.addGroup( group.start, group.count, group.materialIndex );
	
					}
	
				}
	
				var boundingSphere = json.data.boundingSphere;
	
				if ( boundingSphere !== undefined ) {
	
					var center = new Vector3();
	
					if ( boundingSphere.center !== undefined ) {
	
						center.fromArray( boundingSphere.center );
	
					}
	
					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Loader() {
	
			this.onLoadStart = function () {};
			this.onLoadProgress = function () {};
			this.onLoadComplete = function () {};
	
		}
	
		Loader.prototype = {
	
			constructor: Loader,
	
			crossOrigin: undefined,
	
			extractUrlBase: function ( url ) {
	
				var parts = url.split( '/' );
	
				if ( parts.length === 1 ) return './';
	
				parts.pop();
	
				return parts.join( '/' ) + '/';
	
			},
	
			initMaterials: function ( materials, texturePath, crossOrigin ) {
	
				var array = [];
	
				for ( var i = 0; i < materials.length; ++ i ) {
	
					array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
				}
	
				return array;
	
			},
	
			createMaterial: ( function () {
	
				var BlendingMode = {
					NoBlending: NoBlending,
					NormalBlending: NormalBlending,
					AdditiveBlending: AdditiveBlending,
					SubtractiveBlending: SubtractiveBlending,
					MultiplyBlending: MultiplyBlending,
					CustomBlending: CustomBlending
				};
	
				var color, textureLoader, materialLoader;
	
				return function createMaterial( m, texturePath, crossOrigin ) {
	
					if ( color === undefined ) color = new Color();
					if ( textureLoader === undefined ) textureLoader = new TextureLoader();
					if ( materialLoader === undefined ) materialLoader = new MaterialLoader();
	
					// convert from old material format
	
					var textures = {};
	
					function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
						var fullPath = texturePath + path;
						var loader = Loader.Handlers.get( fullPath );
	
						var texture;
	
						if ( loader !== null ) {
	
							texture = loader.load( fullPath );
	
						} else {
	
							textureLoader.setCrossOrigin( crossOrigin );
							texture = textureLoader.load( fullPath );
	
						}
	
						if ( repeat !== undefined ) {
	
							texture.repeat.fromArray( repeat );
	
							if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
							if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;
	
						}
	
						if ( offset !== undefined ) {
	
							texture.offset.fromArray( offset );
	
						}
	
						if ( wrap !== undefined ) {
	
							if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
							if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;
	
							if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
							if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;
	
						}
	
						if ( anisotropy !== undefined ) {
	
							texture.anisotropy = anisotropy;
	
						}
	
						var uuid = _Math.generateUUID();
	
						textures[ uuid ] = texture;
	
						return uuid;
	
					}
	
					//
	
					var json = {
						uuid: _Math.generateUUID(),
						type: 'MeshLambertMaterial'
					};
	
					for ( var name in m ) {
	
						var value = m[ name ];
	
						switch ( name ) {
	
							case 'DbgColor':
							case 'DbgIndex':
							case 'opticalDensity':
							case 'illumination':
								break;
							case 'DbgName':
								json.name = value;
								break;
							case 'blending':
								json.blending = BlendingMode[ value ];
								break;
							case 'colorAmbient':
							case 'mapAmbient':
								console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
								break;
							case 'colorDiffuse':
								json.color = color.fromArray( value ).getHex();
								break;
							case 'colorSpecular':
								json.specular = color.fromArray( value ).getHex();
								break;
							case 'colorEmissive':
								json.emissive = color.fromArray( value ).getHex();
								break;
							case 'specularCoef':
								json.shininess = value;
								break;
							case 'shading':
								if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
								if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
								if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
								break;
							case 'mapDiffuse':
								json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
								break;
							case 'mapDiffuseRepeat':
							case 'mapDiffuseOffset':
							case 'mapDiffuseWrap':
							case 'mapDiffuseAnisotropy':
								break;
							case 'mapEmissive':
								json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
								break;
							case 'mapEmissiveRepeat':
							case 'mapEmissiveOffset':
							case 'mapEmissiveWrap':
							case 'mapEmissiveAnisotropy':
								break;
							case 'mapLight':
								json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
								break;
							case 'mapLightRepeat':
							case 'mapLightOffset':
							case 'mapLightWrap':
							case 'mapLightAnisotropy':
								break;
							case 'mapAO':
								json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
								break;
							case 'mapAORepeat':
							case 'mapAOOffset':
							case 'mapAOWrap':
							case 'mapAOAnisotropy':
								break;
							case 'mapBump':
								json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
								break;
							case 'mapBumpScale':
								json.bumpScale = value;
								break;
							case 'mapBumpRepeat':
							case 'mapBumpOffset':
							case 'mapBumpWrap':
							case 'mapBumpAnisotropy':
								break;
							case 'mapNormal':
								json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
								break;
							case 'mapNormalFactor':
								json.normalScale = [ value, value ];
								break;
							case 'mapNormalRepeat':
							case 'mapNormalOffset':
							case 'mapNormalWrap':
							case 'mapNormalAnisotropy':
								break;
							case 'mapSpecular':
								json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
								break;
							case 'mapSpecularRepeat':
							case 'mapSpecularOffset':
							case 'mapSpecularWrap':
							case 'mapSpecularAnisotropy':
								break;
							case 'mapMetalness':
								json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
								break;
							case 'mapMetalnessRepeat':
							case 'mapMetalnessOffset':
							case 'mapMetalnessWrap':
							case 'mapMetalnessAnisotropy':
								break;
							case 'mapRoughness':
								json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
								break;
							case 'mapRoughnessRepeat':
							case 'mapRoughnessOffset':
							case 'mapRoughnessWrap':
							case 'mapRoughnessAnisotropy':
								break;
							case 'mapAlpha':
								json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
								break;
							case 'mapAlphaRepeat':
							case 'mapAlphaOffset':
							case 'mapAlphaWrap':
							case 'mapAlphaAnisotropy':
								break;
							case 'flipSided':
								json.side = BackSide;
								break;
							case 'doubleSided':
								json.side = DoubleSide;
								break;
							case 'transparency':
								console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
								json.opacity = value;
								break;
							case 'depthTest':
							case 'depthWrite':
							case 'colorWrite':
							case 'opacity':
							case 'reflectivity':
							case 'transparent':
							case 'visible':
							case 'wireframe':
								json[ name ] = value;
								break;
							case 'vertexColors':
								if ( value === true ) json.vertexColors = VertexColors;
								if ( value === 'face' ) json.vertexColors = FaceColors;
								break;
							default:
								console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
								break;
	
						}
	
					}
	
					if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
					if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
					if ( json.opacity < 1 ) json.transparent = true;
	
					materialLoader.setTextures( textures );
	
					return materialLoader.parse( json );
	
				};
	
			} )()
	
		};
	
		Loader.Handlers = {
	
			handlers: [],
	
			add: function ( regex, loader ) {
	
				this.handlers.push( regex, loader );
	
			},
	
			get: function ( file ) {
	
				var handlers = this.handlers;
	
				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
					var regex = handlers[ i ];
					var loader = handlers[ i + 1 ];
	
					if ( regex.test( file ) ) {
	
						return loader;
	
					}
	
				}
	
				return null;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function JSONLoader( manager ) {
	
			if ( typeof manager === 'boolean' ) {
	
				console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
				manager = undefined;
	
			}
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			this.withCredentials = false;
	
		}
	
		Object.assign( JSONLoader.prototype, {
	
			load: function( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );
	
				var loader = new FileLoader( this.manager );
				loader.setWithCredentials( this.withCredentials );
				loader.load( url, function ( text ) {
	
					var json = JSON.parse( text );
					var metadata = json.metadata;
	
					if ( metadata !== undefined ) {
	
						var type = metadata.type;
	
						if ( type !== undefined ) {
	
							if ( type.toLowerCase() === 'object' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;
	
							}
	
							if ( type.toLowerCase() === 'scene' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
								return;
	
							}
	
						}
	
					}
	
					var object = scope.parse( json, texturePath );
					onLoad( object.geometry, object.materials );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			parse: function ( json, texturePath ) {
	
				var geometry = new Geometry(),
				scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
				parseModel( scale );
	
				parseSkin();
				parseMorphing( scale );
				parseAnimations();
	
				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();
	
				function parseModel( scale ) {
	
					function isBitSet( value, position ) {
	
						return value & ( 1 << position );
	
					}
	
					var i, j, fi,
	
					offset, zLength,
	
				colorIndex, normalIndex, uvIndex, materialIndex,
	
					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,
	
				vertex, face, faceA, faceB, hex, normal,
	
					uvLayer, uv, u, v,
	
					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,
	
					nUvLayers = 0;
	
					if ( json.uvs !== undefined ) {
	
						// disregard empty arrays
	
						for ( i = 0; i < json.uvs.length; i ++ ) {
	
							if ( json.uvs[ i ].length ) nUvLayers ++;
	
						}
	
						for ( i = 0; i < nUvLayers; i ++ ) {
	
							geometry.faceVertexUvs[ i ] = [];
	
						}
	
					}
	
					offset = 0;
					zLength = vertices.length;
	
					while ( offset < zLength ) {
	
						vertex = new Vector3();
	
						vertex.x = vertices[ offset ++ ] * scale;
						vertex.y = vertices[ offset ++ ] * scale;
						vertex.z = vertices[ offset ++ ] * scale;
	
						geometry.vertices.push( vertex );
	
					}
	
					offset = 0;
					zLength = faces.length;
	
					while ( offset < zLength ) {
	
						type = faces[ offset ++ ];
	
	
						isQuad              = isBitSet( type, 0 );
						hasMaterial         = isBitSet( type, 1 );
						hasFaceVertexUv     = isBitSet( type, 3 );
						hasFaceNormal       = isBitSet( type, 4 );
						hasFaceVertexNormal = isBitSet( type, 5 );
						hasFaceColor	     = isBitSet( type, 6 );
						hasFaceVertexColor  = isBitSet( type, 7 );
	
						// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
						if ( isQuad ) {
	
							faceA = new Face3();
							faceA.a = faces[ offset ];
							faceA.b = faces[ offset + 1 ];
							faceA.c = faces[ offset + 3 ];
	
							faceB = new Face3();
							faceB.a = faces[ offset + 1 ];
							faceB.b = faces[ offset + 2 ];
							faceB.c = faces[ offset + 3 ];
	
							offset += 4;
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								faceA.materialIndex = materialIndex;
								faceB.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
									geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
									for ( j = 0; j < 4; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
										if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								faceA.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								faceB.normal.copy( faceA.normal );
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
	
									if ( i !== 2 ) faceA.vertexNormals.push( normal );
									if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								faceA.color.setHex( hex );
								faceB.color.setHex( hex );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									hex = colors[ colorIndex ];
	
									if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
									if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );
	
								}
	
							}
	
							geometry.faces.push( faceA );
							geometry.faces.push( faceB );
	
						} else {
	
							face = new Face3();
							face.a = faces[ offset ++ ];
							face.b = faces[ offset ++ ];
							face.c = faces[ offset ++ ];
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								face.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
	
									for ( j = 0; j < 3; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								face.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
									face.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								face.color.setHex( colors[ colorIndex ] );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									face.vertexColors.push( new Color( colors[ colorIndex ] ) );
	
								}
	
							}
	
							geometry.faces.push( face );
	
						}
	
					}
	
				}
	
				function parseSkin() {
	
					var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
					if ( json.skinWeights ) {
	
						for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
							var x =                               json.skinWeights[ i ];
							var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
							var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
							var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
							geometry.skinWeights.push( new Vector4( x, y, z, w ) );
	
						}
	
					}
	
					if ( json.skinIndices ) {
	
						for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
							var a =                               json.skinIndices[ i ];
							var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
							geometry.skinIndices.push( new Vector4( a, b, c, d ) );
	
						}
	
					}
	
					geometry.bones = json.bones;
	
					if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
						console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
							geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
					}
	
				}
	
				function parseMorphing( scale ) {
	
					if ( json.morphTargets !== undefined ) {
	
						for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
							geometry.morphTargets[ i ] = {};
							geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
							geometry.morphTargets[ i ].vertices = [];
	
							var dstVertices = geometry.morphTargets[ i ].vertices;
							var srcVertices = json.morphTargets[ i ].vertices;
	
							for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
								var vertex = new Vector3();
								vertex.x = srcVertices[ v ] * scale;
								vertex.y = srcVertices[ v + 1 ] * scale;
								vertex.z = srcVertices[ v + 2 ] * scale;
	
								dstVertices.push( vertex );
	
							}
	
						}
	
					}
	
					if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
						console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
						var faces = geometry.faces;
						var morphColors = json.morphColors[ 0 ].colors;
	
						for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
							faces[ i ].color.fromArray( morphColors, i * 3 );
	
						}
	
					}
	
				}
	
				function parseAnimations() {
	
					var outputAnimations = [];
	
					// parse old style Bone/Hierarchy animations
					var animations = [];
	
					if ( json.animation !== undefined ) {
	
						animations.push( json.animation );
	
					}
	
					if ( json.animations !== undefined ) {
	
						if ( json.animations.length ) {
	
							animations = animations.concat( json.animations );
	
						} else {
	
							animations.push( json.animations );
	
						}
	
					}
	
					for ( var i = 0; i < animations.length; i ++ ) {
	
						var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
						if ( clip ) outputAnimations.push( clip );
	
					}
	
					// parse implicit morph animations
					if ( geometry.morphTargets ) {
	
						// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
						var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
						outputAnimations = outputAnimations.concat( morphAnimationClips );
	
					}
	
					if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
				}
	
				if ( json.materials === undefined || json.materials.length === 0 ) {
	
					return { geometry: geometry };
	
				} else {
	
					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
					return { geometry: geometry, materials: materials };
	
				}
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ObjectLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.texturePath = '';
	
		}
	
		Object.assign( ObjectLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( this.texturePath === '' ) {
	
					this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
				}
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					var json = null;
	
					try {
	
						json = JSON.parse( text );
	
					} catch ( error ) {
	
						if ( onError !== undefined ) onError( error );
	
						console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
	
						return;
	
					}
	
					var metadata = json.metadata;
	
					if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {
	
						console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
						return;
	
					}
	
					scope.parse( json, onLoad );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
	
			},
	
			parse: function ( json, onLoad ) {
	
				var geometries = this.parseGeometries( json.geometries );
	
				var images = this.parseImages( json.images, function () {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				} );
	
				var textures = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );
	
				var object = this.parseObject( json.object, geometries, materials );
	
				if ( json.animations ) {
	
					object.animations = this.parseAnimations( json.animations );
	
				}
	
				if ( json.images === undefined || json.images.length === 0 ) {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				}
	
				return object;
	
			},
	
			parseGeometries: function ( json ) {
	
				var geometries = {};
	
				if ( json !== undefined ) {
	
					var geometryLoader = new JSONLoader();
					var bufferGeometryLoader = new BufferGeometryLoader();
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var geometry;
						var data = json[ i ];
	
						switch ( data.type ) {
	
							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);
	
								break;
	
							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);
	
								break;
	
							case 'CircleGeometry':
							case 'CircleBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'ConeGeometry':
							case 'ConeBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'SphereGeometry':
							case 'SphereBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'DodecahedronGeometry':
							case 'IcosahedronGeometry':
							case 'OctahedronGeometry':
							case 'TetrahedronGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);
	
								break;
	
							case 'RingGeometry':
							case 'RingBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'TorusGeometry':
							case 'TorusBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);
	
								break;
	
							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);
	
								break;
	
							case 'LatheGeometry':
							case 'LatheBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);
	
								break;
	
							case 'BufferGeometry':
	
								geometry = bufferGeometryLoader.parse( data );
	
								break;
	
							case 'Geometry':
	
								geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;
	
								break;
	
							default:
	
								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
								continue;
	
						}
	
						geometry.uuid = data.uuid;
	
						if ( data.name !== undefined ) geometry.name = data.name;
	
						geometries[ data.uuid ] = geometry;
	
					}
	
				}
	
				return geometries;
	
			},
	
			parseMaterials: function ( json, textures ) {
	
				var materials = {};
	
				if ( json !== undefined ) {
	
					var loader = new MaterialLoader();
					loader.setTextures( textures );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var material = loader.parse( json[ i ] );
						materials[ material.uuid ] = material;
	
					}
	
				}
	
				return materials;
	
			},
	
			parseAnimations: function ( json ) {
	
				var animations = [];
	
				for ( var i = 0; i < json.length; i ++ ) {
	
					var clip = AnimationClip.parse( json[ i ] );
	
					animations.push( clip );
	
				}
	
				return animations;
	
			},
	
			parseImages: function ( json, onLoad ) {
	
				var scope = this;
				var images = {};
	
				function loadImage( url ) {
	
					scope.manager.itemStart( url );
	
					return loader.load( url, function () {
	
						scope.manager.itemEnd( url );
	
					}, undefined, function () {
	
						scope.manager.itemError( url );
	
					} );
	
				}
	
				if ( json !== undefined && json.length > 0 ) {
	
					var manager = new LoadingManager( onLoad );
	
					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var image = json[ i ];
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
						images[ image.uuid ] = loadImage( path );
	
					}
	
				}
	
				return images;
	
			},
	
			parseTextures: function ( json, images ) {
	
				var TextureMapping = {
					UVMapping: UVMapping,
					CubeReflectionMapping: CubeReflectionMapping,
					CubeRefractionMapping: CubeRefractionMapping,
					EquirectangularReflectionMapping: EquirectangularReflectionMapping,
					EquirectangularRefractionMapping: EquirectangularRefractionMapping,
					SphericalReflectionMapping: SphericalReflectionMapping,
					CubeUVReflectionMapping: CubeUVReflectionMapping,
					CubeUVRefractionMapping: CubeUVRefractionMapping
				};
	
				var TextureWrapping = {
					RepeatWrapping: RepeatWrapping,
					ClampToEdgeWrapping: ClampToEdgeWrapping,
					MirroredRepeatWrapping: MirroredRepeatWrapping
				};
	
				var TextureFilter = {
					NearestFilter: NearestFilter,
					NearestMipMapNearestFilter: NearestMipMapNearestFilter,
					NearestMipMapLinearFilter: NearestMipMapLinearFilter,
					LinearFilter: LinearFilter,
					LinearMipMapNearestFilter: LinearMipMapNearestFilter,
					LinearMipMapLinearFilter: LinearMipMapLinearFilter
				};
	
				function parseConstant( value, type ) {
	
					if ( typeof( value ) === 'number' ) return value;
	
					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
					return type[ value ];
	
				}
	
				var textures = {};
	
				if ( json !== undefined ) {
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var data = json[ i ];
	
						if ( data.image === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
						}
	
						if ( images[ data.image ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
						}
	
						var texture = new Texture( images[ data.image ] );
						texture.needsUpdate = true;
	
						texture.uuid = data.uuid;
	
						if ( data.name !== undefined ) texture.name = data.name;
	
						if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );
	
						if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
						if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
						if ( data.wrap !== undefined ) {
	
							texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );
	
						}
	
						if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
						if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
						if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
	
						if ( data.flipY !== undefined ) texture.flipY = data.flipY;
	
						textures[ data.uuid ] = texture;
	
					}
	
				}
	
				return textures;
	
			},
	
			parseObject: function () {
	
				var matrix = new Matrix4();
	
				return function parseObject( data, geometries, materials ) {
	
					var object;
	
					function getGeometry( name ) {
	
						if ( geometries[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
						}
	
						return geometries[ name ];
	
					}
	
					function getMaterial( name ) {
	
						if ( name === undefined ) return undefined;
	
						if ( materials[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
						}
	
						return materials[ name ];
	
					}
	
					switch ( data.type ) {
	
						case 'Scene':
	
							object = new Scene();
	
							if ( data.background !== undefined ) {
	
								if ( Number.isInteger( data.background ) ) {
	
									object.background = new Color( data.background );
	
								}
	
							}
	
							if ( data.fog !== undefined ) {
	
								if ( data.fog.type === 'Fog' ) {
	
									object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
	
								} else if ( data.fog.type === 'FogExp2' ) {
	
									object.fog = new FogExp2( data.fog.color, data.fog.density );
	
								}
	
							}
	
							break;
	
						case 'PerspectiveCamera':
	
							object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
							if ( data.focus !== undefined ) object.focus = data.focus;
							if ( data.zoom !== undefined ) object.zoom = data.zoom;
							if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
							if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
							if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
	
							break;
	
						case 'OrthographicCamera':
	
							object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
							break;
	
						case 'AmbientLight':
	
							object = new AmbientLight( data.color, data.intensity );
	
							break;
	
						case 'DirectionalLight':
	
							object = new DirectionalLight( data.color, data.intensity );
	
							break;
	
						case 'PointLight':
	
							object = new PointLight( data.color, data.intensity, data.distance, data.decay );
	
							break;
	
						case 'SpotLight':
	
							object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
	
							break;
	
						case 'HemisphereLight':
	
							object = new HemisphereLight( data.color, data.groundColor, data.intensity );
	
							break;
	
						case 'Mesh':
	
							var geometry = getGeometry( data.geometry );
							var material = getMaterial( data.material );
	
							if ( geometry.bones && geometry.bones.length > 0 ) {
	
								object = new SkinnedMesh( geometry, material );
	
							} else {
	
								object = new Mesh( geometry, material );
	
							}
	
							break;
	
						case 'LOD':
	
							object = new LOD();
	
							break;
	
						case 'Line':
	
							object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
							break;
	
						case 'LineSegments':
	
							object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'PointCloud':
						case 'Points':
	
							object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'Sprite':
	
							object = new Sprite( getMaterial( data.material ) );
	
							break;
	
						case 'Group':
	
							object = new Group();
	
							break;
	
						case 'SkinnedMesh':
	
							console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.' );
	
						default:
	
							object = new Object3D();
	
					}
	
					object.uuid = data.uuid;
	
					if ( data.name !== undefined ) object.name = data.name;
					if ( data.matrix !== undefined ) {
	
						matrix.fromArray( data.matrix );
						matrix.decompose( object.position, object.quaternion, object.scale );
	
					} else {
	
						if ( data.position !== undefined ) object.position.fromArray( data.position );
						if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
						if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
						if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
					}
	
					if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
					if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
					if ( data.shadow ) {
	
						if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
						if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
						if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
						if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
	
					}
	
					if ( data.visible !== undefined ) object.visible = data.visible;
					if ( data.userData !== undefined ) object.userData = data.userData;
	
					if ( data.children !== undefined ) {
	
						for ( var child in data.children ) {
	
							object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
						}
	
					}
	
					if ( data.type === 'LOD' ) {
	
						var levels = data.levels;
	
						for ( var l = 0; l < levels.length; l ++ ) {
	
							var level = levels[ l ];
							var child = object.getObjectByProperty( 'uuid', level.object );
	
							if ( child !== undefined ) {
	
								object.addLevel( child, level.distance );
	
							}
	
						}
	
					}
	
					return object;
	
				};
	
			}()
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Bezier Curves formulas obtained from
		 * http://en.wikipedia.org/wiki/Bzier_curve
		 */
	
		function CatmullRom( t, p0, p1, p2, p3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
		//
	
		function QuadraticBezierP0( t, p ) {
	
			var k = 1 - t;
			return k * k * p;
	
		}
	
		function QuadraticBezierP1( t, p ) {
	
			return 2 * ( 1 - t ) * t * p;
	
		}
	
		function QuadraticBezierP2( t, p ) {
	
			return t * t * p;
	
		}
	
		function QuadraticBezier( t, p0, p1, p2 ) {
	
			return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
				QuadraticBezierP2( t, p2 );
	
		}
	
		//
	
		function CubicBezierP0( t, p ) {
	
			var k = 1 - t;
			return k * k * k * p;
	
		}
	
		function CubicBezierP1( t, p ) {
	
			var k = 1 - t;
			return 3 * k * k * t * p;
	
		}
	
		function CubicBezierP2( t, p ) {
	
			return 3 * ( 1 - t ) * t * t * p;
	
		}
	
		function CubicBezierP3( t, p ) {
	
			return t * t * t * p;
	
		}
	
		function CubicBezier( t, p0, p1, p2, p3 ) {
	
			return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
				CubicBezierP3( t, p3 );
	
		}
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of Curve methods
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following classes subclasses THREE.Curve:
		 *
		 * -- 2d classes --
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.CubicBezierCurve
		 * THREE.SplineCurve
		 * THREE.ArcCurve
		 * THREE.EllipseCurve
		 *
		 * -- 3d classes --
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.CatmullRomCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath
		 *
		 **/
	
		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/
	
		function Curve() {}
	
		Curve.prototype = {
	
			constructor: Curve,
	
			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]
	
			getPoint: function ( t ) {
	
				console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
				return null;
	
			},
	
			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]
	
			getPointAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getPoint( t );
	
			},
	
			// Get sequence of points using getPoint( t )
	
			getPoints: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPoint( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get sequence of points using getPointAt( u )
	
			getSpacedPoints: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPointAt( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get total curve arc length
	
			getLength: function () {
	
				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];
	
			},
	
			// Get list of cumulative segment lengths
	
			getLengths: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;
	
				if ( this.cacheArcLengths
					&& ( this.cacheArcLengths.length === divisions + 1 )
					&& ! this.needsUpdate ) {
	
					//console.log( "cached", this.cacheArcLengths );
					return this.cacheArcLengths;
	
				}
	
				this.needsUpdate = false;
	
				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;
	
				cache.push( 0 );
	
				for ( p = 1; p <= divisions; p ++ ) {
	
					current = this.getPoint ( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;
	
				}
	
				this.cacheArcLengths = cache;
	
				return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
			},
	
			updateArcLengths: function() {
	
				this.needsUpdate = true;
				this.getLengths();
	
			},
	
			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
			getUtoTmapping: function ( u, distance ) {
	
				var arcLengths = this.getLengths();
	
				var i = 0, il = arcLengths.length;
	
				var targetArcLength; // The targeted u distance value to get
	
				if ( distance ) {
	
					targetArcLength = distance;
	
				} else {
	
					targetArcLength = u * arcLengths[ il - 1 ];
	
				}
	
				//var time = Date.now();
	
				// binary search for the index with largest value smaller than target u distance
	
				var low = 0, high = il - 1, comparison;
	
				while ( low <= high ) {
	
					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
					comparison = arcLengths[ i ] - targetArcLength;
	
					if ( comparison < 0 ) {
	
						low = i + 1;
	
					} else if ( comparison > 0 ) {
	
						high = i - 1;
	
					} else {
	
						high = i;
						break;
	
						// DONE
	
					}
	
				}
	
				i = high;
	
				//console.log('b' , i, low, high, Date.now()- time);
	
				if ( arcLengths[ i ] === targetArcLength ) {
	
					var t = i / ( il - 1 );
					return t;
	
				}
	
				// we could get finer grain at lengths, or use simple interpolation between two points
	
				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];
	
				var segmentLength = lengthAfter - lengthBefore;
	
				// determine where we are between the 'before' and 'after' points
	
				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
				// add that fractional amount to t
	
				var t = ( i + segmentFraction ) / ( il - 1 );
	
				return t;
	
			},
	
			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation
	
			getTangent: function( t ) {
	
				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;
	
				// Capping in case of danger
	
				if ( t1 < 0 ) t1 = 0;
				if ( t2 > 1 ) t2 = 1;
	
				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );
	
				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();
	
			},
	
			getTangentAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getTangent( t );
	
			},
	
			computeFrenetFrames: function ( segments, closed ) {
	
				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	
				var normal = new Vector3();
	
				var tangents = [];
				var normals = [];
				var binormals = [];
	
				var vec = new Vector3();
				var mat = new Matrix4();
	
				var i, u, theta;
	
				// compute the tangent vectors for each segment on the curve
	
				for ( i = 0; i <= segments; i ++ ) {
	
					u = i / segments;
	
					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();
	
				}
	
				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component
	
				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );
	
				if ( tx <= min ) {
	
					min = tx;
					normal.set( 1, 0, 0 );
	
				}
	
				if ( ty <= min ) {
	
					min = ty;
					normal.set( 0, 1, 0 );
	
				}
	
				if ( tz <= min ) {
	
					normal.set( 0, 0, 1 );
	
				}
	
				vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
	
				// compute the slowly-varying normal and binormal vectors for each segment on the curve
	
				for ( i = 1; i <= segments; i ++ ) {
	
					normals[ i ] = normals[ i - 1 ].clone();
	
					binormals[ i ] = binormals[ i - 1 ].clone();
	
					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
					if ( vec.length() > Number.EPSILON ) {
	
						vec.normalize();
	
						theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
					}
	
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
				}
	
				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
				if ( closed === true ) {
	
					theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;
	
					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
	
						theta = - theta;
	
					}
	
					for ( i = 1; i <= segments; i ++ ) {
	
						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
					}
	
				}
	
				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};
	
			}
	
		};
	
		function LineCurve( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;
	
		LineCurve.prototype.isLineCurve = true;
	
		LineCurve.prototype.getPoint = function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var point = this.v2.clone().sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
	
			return point;
	
		};
	
		// Line curve is linear, so we can overwrite default getPointAt
	
		LineCurve.prototype.getPointAt = function ( u ) {
	
			return this.getPoint( u );
	
		};
	
		LineCurve.prototype.getTangent = function ( t ) {
	
			var tangent = this.v2.clone().sub( this.v1 );
	
			return tangent.normalize();
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/
	
		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/
	
		function CurvePath() {
	
			this.curves = [];
	
			this.autoClose = false; // Automatically closes the path
	
		}
	
		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
	
			constructor: CurvePath,
	
			add: function ( curve ) {
	
				this.curves.push( curve );
	
			},
	
			closePath: function () {
	
				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
				if ( ! startPoint.equals( endPoint ) ) {
	
					this.curves.push( new LineCurve( endPoint, startPoint ) );
	
				}
	
			},
	
			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:
	
			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')
	
			getPoint: function ( t ) {
	
				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;
	
				// To think about boundaries points.
	
				while ( i < curveLengths.length ) {
	
					if ( curveLengths[ i ] >= d ) {
	
						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];
	
						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	
						return curve.getPointAt( u );
	
					}
	
					i ++;
	
				}
	
				return null;
	
				// loop where sum != 0, sum > d , sum+1 <d
	
			},
	
			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength
	
			getLength: function () {
	
				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];
	
			},
	
			// cacheLengths must be recalculated.
			updateArcLengths: function () {
	
				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getLengths();
	
			},
	
			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.
	
			getCurveLengths: function () {
	
				// We use cache values if curves and cache array are same length
	
				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
					return this.cacheLengths;
	
				}
	
				// Get length of sub-curve
				// Push sums into cached array
	
				var lengths = [], sums = 0;
	
				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
					sums += this.curves[ i ].getLength();
					lengths.push( sums );
	
				}
	
				this.cacheLengths = lengths;
	
				return lengths;
	
			},
	
			getSpacedPoints: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = 40;
	
				var points = [];
	
				for ( var i = 0; i <= divisions; i ++ ) {
	
					points.push( this.getPoint( i / divisions ) );
	
				}
	
				if ( this.autoClose ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			getPoints: function ( divisions ) {
	
				divisions = divisions || 12;
	
				var points = [], last;
	
				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
	
					var curve = curves[ i ];
					var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
						: (curve && curve.isLineCurve) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
						: divisions;
	
					var pts = curve.getPoints( resolution );
	
					for ( var j = 0; j < pts.length; j++ ) {
	
						var point = pts[ j ];
	
						if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates
	
						points.push( point );
						last = point;
	
					}
	
				}
	
				if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************/
	
			/// Generate geometry from path points (for Line or Points objects)
	
			createPointsGeometry: function ( divisions ) {
	
				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			// Generate geometry from equidistant sampling along the path
	
			createSpacedPointsGeometry: function ( divisions ) {
	
				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			createGeometry: function ( points ) {
	
				var geometry = new Geometry();
	
				for ( var i = 0, l = points.length; i < l; i ++ ) {
	
					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			this.aX = aX;
			this.aY = aY;
	
			this.xRadius = xRadius;
			this.yRadius = yRadius;
	
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
	
			this.aClockwise = aClockwise;
	
			this.aRotation = aRotation || 0;
	
		}
	
		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;
	
		EllipseCurve.prototype.isEllipseCurve = true;
	
		EllipseCurve.prototype.getPoint = function ( t ) {
	
			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
	
			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
	
			if ( deltaAngle < Number.EPSILON ) {
	
				if ( samePoints ) {
	
					deltaAngle = 0;
	
				} else {
	
					deltaAngle = twoPi;
	
				}
	
			}
	
			if ( this.aClockwise === true && ! samePoints ) {
	
				if ( deltaAngle === twoPi ) {
	
					deltaAngle = - twoPi;
	
				} else {
	
					deltaAngle = deltaAngle - twoPi;
	
				}
	
			}
	
			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );
	
			if ( this.aRotation !== 0 ) {
	
				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );
	
				var tx = x - this.aX;
				var ty = y - this.aY;
	
				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
	
			}
	
			return new Vector2( x, y );
	
		};
	
		function SplineCurve( points /* array of Vector2 */ ) {
	
			this.points = ( points === undefined ) ? [] : points;
	
		}
	
		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;
	
		SplineCurve.prototype.isSplineCurve = true;
	
		SplineCurve.prototype.getPoint = function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			return new Vector2(
				CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
				CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
			);
	
		};
	
		function CubicBezierCurve( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		}
	
		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;
	
		CubicBezierCurve.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
			return new Vector2(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);
	
		};
	
		function QuadraticBezierCurve( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
	
		QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
			return new Vector2(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);
	
		};
	
		var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {
	
			fromPoints: function ( vectors ) {
	
				this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
				for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
					this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
				}
	
			},
	
			moveTo: function ( x, y ) {
	
				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
	
			},
	
			lineTo: function ( x, y ) {
	
				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );
	
				this.currentPoint.set( x, y );
	
			},
	
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			splineThru: function ( pts /*Array of Vector*/ ) {
	
				var npts = [ this.currentPoint.clone() ].concat( pts );
	
				var curve = new SplineCurve( npts );
				this.curves.push( curve );
	
				this.currentPoint.copy( pts[ pts.length - 1 ] );
	
			},
	
			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );
	
			},
	
			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
			},
	
			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
			},
	
			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
				if ( this.curves.length > 0 ) {
	
					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );
	
					if ( ! firstPoint.equals( this.currentPoint ) ) {
	
						this.lineTo( firstPoint.x, firstPoint.y );
	
					}
	
				}
	
				this.curves.push( curve );
	
				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 **/
	
		function Path( points ) {
	
			CurvePath.call( this );
			this.currentPoint = new Vector2();
	
			if ( points ) {
	
				this.fromPoints( points );
	
			}
	
		}
	
		Path.prototype = PathPrototype;
		PathPrototype.constructor = Path;
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/
	
		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.
	
		function Shape() {
	
			Path.apply( this, arguments );
	
			this.holes = [];
	
		}
	
		Shape.prototype = Object.assign( Object.create( PathPrototype ), {
	
			constructor: Shape,
	
			getPointsHoles: function ( divisions ) {
	
				var holesPts = [];
	
				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
					holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
				}
	
				return holesPts;
	
			},
	
			// Get points of shape and holes (keypoints based on segments parameter)
	
			extractAllPoints: function ( divisions ) {
	
				return {
	
					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )
	
				};
	
			},
	
			extractPoints: function ( divisions ) {
	
				return this.extractAllPoints( divisions );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		 **/
	
		function ShapePath() {
	
			this.subPaths = [];
			this.currentPath = null;
	
		}
	
		ShapePath.prototype = {
	
			moveTo: function ( x, y ) {
	
				this.currentPath = new Path();
				this.subPaths.push( this.currentPath );
				this.currentPath.moveTo( x, y );
	
			},
	
			lineTo: function ( x, y ) {
	
				this.currentPath.lineTo( x, y );
	
			},
	
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
	
			},
	
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
	
			},
	
			splineThru: function ( pts ) {
	
				this.currentPath.splineThru( pts );
	
			},
	
			toShapes: function ( isCCW, noHoles ) {
	
				function toShapesNoHoles( inSubpaths ) {
	
					var shapes = [];
	
					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
						var tmpPath = inSubpaths[ i ];
	
						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;
	
						shapes.push( tmpShape );
	
					}
	
					return shapes;
	
				}
	
				function isPointInsidePolygon( inPt, inPolygon ) {
	
					var polyLen = inPolygon.length;
	
					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
						var edgeLowPt  = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];
	
						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
						if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
							// not parallel
							if ( edgeDy < 0 ) {
	
								edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
							if ( inPt.y === edgeLowPt.y ) {
	
								if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
							} else {
	
								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
								if ( perpEdge < 0 ) 				continue;
								inside = ! inside;		// true intersection left of inPt
	
							}
	
						} else {
	
							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
							// continue;
	
						}
	
					}
	
					return	inside;
	
				}
	
				var isClockWise = ShapeUtils.isClockWise;
	
				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) return [];
	
				if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
				var solid, tmpPath, tmpShape, shapes = [];
	
				if ( subPaths.length === 1 ) {
	
					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;
	
				}
	
				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;
	
				// console.log("Holes first", holesFirst);
	
				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;
	
				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];
	
				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;
	
					if ( solid ) {
	
						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
						if ( holesFirst )	mainIdx ++;
						newShapeHoles[ mainIdx ] = [];
	
						//console.log('cw', i);
	
					} else {
	
						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
						//console.log('ccw', i);
	
					}
	
				}
	
				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
				if ( newShapes.length > 1 ) {
	
					var ambiguous = false;
					var toChange = [];
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						betterShapeHoles[ sIdx ] = [];
	
					}
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						var sho = newShapeHoles[ sIdx ];
	
						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
							var ho = sho[ hIdx ];
							var hole_unassigned = true;
	
							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
									if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
									if ( hole_unassigned ) {
	
										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );
	
									} else {
	
										ambiguous = true;
	
									}
	
								}
	
							}
							if ( hole_unassigned ) {
	
								betterShapeHoles[ sIdx ].push( ho );
	
							}
	
						}
	
					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {
	
						// console.log("to change: ", toChange);
						if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
					}
	
				}
	
				var tmpHoles;
	
				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];
	
					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
						tmpShape.holes.push( tmpHoles[ j ].h );
	
					}
	
				}
	
				//console.log("shape", shapes);
	
				return shapes;
	
			}
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Font( data ) {
	
			this.data = data;
	
		}
	
		Object.assign( Font.prototype, {
	
			isFont: true,
	
			generateShapes: function ( text, size, divisions ) {
	
				function createPaths( text ) {
	
					var chars = String( text ).split( '' );
					var scale = size / data.resolution;
					var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
	
					var offsetX = 0, offsetY = 0;
	
					var paths = [];
	
					for ( var i = 0; i < chars.length; i ++ ) {
	
						var char = chars[ i ];
	
						if ( char === '\n' ) {
	
							offsetX = 0;
							offsetY -= line_height;
	
						} else {
	
							var ret = createPath( char, scale, offsetX, offsetY );
							offsetX += ret.offsetX;
							paths.push( ret.path );
	
						}
	
					}
	
					return paths;
	
				}
	
				function createPath( c, scale, offsetX, offsetY ) {
	
					var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
	
					if ( ! glyph ) return;
	
					var path = new ShapePath();
	
					var pts = [];
					var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	
					if ( glyph.o ) {
	
						var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
						for ( var i = 0, l = outline.length; i < l; ) {
	
							var action = outline[ i ++ ];
	
							switch ( action ) {
	
								case 'm': // moveTo
	
									x = outline[ i ++ ] * scale + offsetX;
									y = outline[ i ++ ] * scale + offsetY;
	
									path.moveTo( x, y );
	
									break;
	
								case 'l': // lineTo
	
									x = outline[ i ++ ] * scale + offsetX;
									y = outline[ i ++ ] * scale + offsetY;
	
									path.lineTo( x, y );
	
									break;
	
								case 'q': // quadraticCurveTo
	
									cpx  = outline[ i ++ ] * scale + offsetX;
									cpy  = outline[ i ++ ] * scale + offsetY;
									cpx1 = outline[ i ++ ] * scale + offsetX;
									cpy1 = outline[ i ++ ] * scale + offsetY;
	
									path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											QuadraticBezier( t, cpx0, cpx1, cpx );
											QuadraticBezier( t, cpy0, cpy1, cpy );
	
										}
	
									}
	
									break;
	
								case 'b': // bezierCurveTo
	
									cpx  = outline[ i ++ ] * scale + offsetX;
									cpy  = outline[ i ++ ] * scale + offsetY;
									cpx1 = outline[ i ++ ] * scale + offsetX;
									cpy1 = outline[ i ++ ] * scale + offsetY;
									cpx2 = outline[ i ++ ] * scale + offsetX;
									cpy2 = outline[ i ++ ] * scale + offsetY;
	
									path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											CubicBezier( t, cpx0, cpx1, cpx2, cpx );
											CubicBezier( t, cpy0, cpy1, cpy2, cpy );
	
										}
	
									}
	
									break;
	
							}
	
						}
	
					}
	
					return { offsetX: glyph.ha * scale, path: path };
	
				}
	
				//
	
				if ( size === undefined ) size = 100;
				if ( divisions === undefined ) divisions = 4;
	
				var data = this.data;
	
				var paths = createPaths( text );
				var shapes = [];
	
				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
				}
	
				return shapes;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function FontLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( FontLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( this.manager );
				loader.load( url, function ( text ) {
	
					var json;
	
					try {
	
						json = JSON.parse( text );
	
					} catch ( e ) {
	
						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );
	
					}
	
					var font = scope.parse( json );
	
					if ( onLoad ) onLoad( font );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				return new Font( json );
	
			}
	
		} );
	
		var context;
	
		var AudioContext = {
	
			getContext: function () {
	
				if ( context === undefined ) {
	
					context = new ( window.AudioContext || window.webkitAudioContext )();
	
				}
	
				return context;
	
			},
	
			setContext: function ( value ) {
	
				context = value;
	
			}
	
		};
	
		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function AudioLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( AudioLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.load( url, function ( buffer ) {
	
					var context = AudioContext.getContext();
	
					context.decodeAudioData( buffer, function ( audioBuffer ) {
	
						onLoad( audioBuffer );
	
					} );
	
				}, onProgress, onError );
	
			}
	
		} );
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 */
	
		function RectAreaLight ( color, intensity, width, height ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'RectAreaLight';
	
			this.position.set( 0, 1, 0 );
			this.updateMatrix();
	
			this.width = ( width !== undefined ) ? width : 10;
			this.height = ( height !== undefined ) ? height : 10;
	
			// TODO (abelnation): distance/decay
	
			// TODO (abelnation): update method for RectAreaLight to update transform to lookat target
	
			// TODO (abelnation): shadows
			// this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
		}
	
		// TODO (abelnation): RectAreaLight update when light shape is changed
		RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: RectAreaLight,
	
			isRectAreaLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.width = source.width;
				this.height = source.height;
	
				// this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function StereoCamera() {
	
			this.type = 'StereoCamera';
	
			this.aspect = 1;
	
			this.eyeSep = 0.064;
	
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;
	
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;
	
		}
	
		Object.assign( StereoCamera.prototype, {
	
			update: ( function () {
	
				var instance, focus, fov, aspect, near, far, zoom;
	
				var eyeRight = new Matrix4();
				var eyeLeft = new Matrix4();
	
				return function update( camera ) {
	
					var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
														aspect !== camera.aspect * this.aspect || near !== camera.near ||
														far !== camera.far || zoom !== camera.zoom;
	
					if ( needsUpdate ) {
	
						instance = this;
						focus = camera.focus;
						fov = camera.fov;
						aspect = camera.aspect * this.aspect;
						near = camera.near;
						far = camera.far;
						zoom = camera.zoom;
	
						// Off-axis stereoscopic effect based on
						// http://paulbourke.net/stereographics/stereorender/
	
						var projectionMatrix = camera.projectionMatrix.clone();
						var eyeSep = this.eyeSep / 2;
						var eyeSepOnProjection = eyeSep * near / focus;
						var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
						var xmin, xmax;
	
						// translate xOffset
	
						eyeLeft.elements[ 12 ] = - eyeSep;
						eyeRight.elements[ 12 ] = eyeSep;
	
						// for left eye
	
						xmin = - ymax * aspect + eyeSepOnProjection;
						xmax = ymax * aspect + eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraL.projectionMatrix.copy( projectionMatrix );
	
						// for right eye
	
						xmin = - ymax * aspect - eyeSepOnProjection;
						xmax = ymax * aspect - eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraR.projectionMatrix.copy( projectionMatrix );
	
					}
	
					this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
					this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
				};
	
			} )()
	
		} );
	
		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CubeCamera( near, far, cubeResolution ) {
	
			Object3D.call( this );
	
			this.type = 'CubeCamera';
	
			var fov = 90, aspect = 1;
	
			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );
	
			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );
	
			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );
	
			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );
	
			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );
	
			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );
	
			var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
	
			this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	
			this.updateCubeMap = function ( renderer, scene ) {
	
				if ( this.parent === null ) this.updateMatrixWorld();
	
				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;
	
				renderTarget.texture.generateMipmaps = false;
	
				renderTarget.activeCubeFace = 0;
				renderer.render( scene, cameraPX, renderTarget );
	
				renderTarget.activeCubeFace = 1;
				renderer.render( scene, cameraNX, renderTarget );
	
				renderTarget.activeCubeFace = 2;
				renderer.render( scene, cameraPY, renderTarget );
	
				renderTarget.activeCubeFace = 3;
				renderer.render( scene, cameraNY, renderTarget );
	
				renderTarget.activeCubeFace = 4;
				renderer.render( scene, cameraPZ, renderTarget );
	
				renderTarget.texture.generateMipmaps = generateMipmaps;
	
				renderTarget.activeCubeFace = 5;
				renderer.render( scene, cameraNZ, renderTarget );
	
				renderer.setRenderTarget( null );
	
			};
	
		}
	
		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioListener() {
	
			Object3D.call( this );
	
			this.type = 'AudioListener';
	
			this.context = AudioContext.getContext();
	
			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );
	
			this.filter = null;
	
		}
	
		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: AudioListener,
	
			getInput: function () {
	
				return this.gain;
	
			},
	
			removeFilter: function ( ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;
	
				}
	
			},
	
			getFilter: function () {
	
				return this.filter;
	
			},
	
			setFilter: function ( value ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
	
				} else {
	
					this.gain.disconnect( this.context.destination );
	
				}
	
				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );
	
			},
	
			getMasterVolume: function () {
	
				return this.gain.gain.value;
	
			},
	
			setMasterVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
				var scale = new Vector3();
	
				var orientation = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					var listener = this.context.listener;
					var up = this.up;
	
					this.matrixWorld.decompose( position, quaternion, scale );
	
					orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
					if ( listener.positionX ) {
	
						listener.positionX.setValueAtTime( position.x, this.context.currentTime );
						listener.positionY.setValueAtTime( position.y, this.context.currentTime );
						listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
						listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
						listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
						listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
						listener.upX.setValueAtTime( up.x, this.context.currentTime );
						listener.upY.setValueAtTime( up.y, this.context.currentTime );
						listener.upZ.setValueAtTime( up.z, this.context.currentTime );
	
					} else {
	
						listener.setPosition( position.x, position.y, position.z );
						listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
					}
	
				};
	
			} )()
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function Audio( listener ) {
	
			Object3D.call( this );
	
			this.type = 'Audio';
	
			this.context = listener.context;
	
			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );
	
			this.autoplay = false;
	
			this.buffer = null;
			this.loop = false;
			this.startTime = 0;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';
	
			this.filters = [];
	
		}
	
		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Audio,
	
			getOutput: function () {
	
				return this.gain;
	
			},
	
			setNodeSource: function ( audioNode ) {
	
				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();
	
				return this;
	
			},
	
			setBuffer: function ( audioBuffer ) {
	
				this.buffer = audioBuffer;
				this.sourceType = 'buffer';
	
				if ( this.autoplay ) this.play();
	
				return this;
	
			},
	
			play: function () {
	
				if ( this.isPlaying === true ) {
	
					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;
	
				}
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				var source = this.context.createBufferSource();
	
				source.buffer = this.buffer;
				source.loop = this.loop;
				source.onended = this.onEnded.bind( this );
				source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
				source.start( 0, this.startTime );
	
				this.isPlaying = true;
	
				this.source = source;
	
				return this.connect();
	
			},
	
			pause: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = this.context.currentTime;
				this.isPlaying = false;
	
				return this;
	
			},
	
			stop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = 0;
				this.isPlaying = false;
	
				return this;
	
			},
	
			connect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.connect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].connect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
	
				} else {
	
					this.source.connect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			disconnect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.disconnect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].disconnect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
	
				} else {
	
					this.source.disconnect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			getFilters: function () {
	
				return this.filters;
	
			},
	
			setFilters: function ( value ) {
	
				if ( ! value ) value = [];
	
				if ( this.isPlaying === true ) {
	
					this.disconnect();
					this.filters = value;
					this.connect();
	
				} else {
	
					this.filters = value;
	
				}
	
				return this;
	
			},
	
			getFilter: function () {
	
				return this.getFilters()[ 0 ];
	
			},
	
			setFilter: function ( filter ) {
	
				return this.setFilters( filter ? [ filter ] : [] );
	
			},
	
			setPlaybackRate: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.playbackRate = value;
	
				if ( this.isPlaying === true ) {
	
					this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );
	
				}
	
				return this;
	
			},
	
			getPlaybackRate: function () {
	
				return this.playbackRate;
	
			},
	
			onEnded: function () {
	
				this.isPlaying = false;
	
			},
	
			getLoop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;
	
				}
	
				return this.loop;
	
			},
	
			setLoop: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.loop = value;
	
				if ( this.isPlaying === true ) {
	
					this.source.loop = this.loop;
	
				}
	
				return this;
	
			},
	
			getVolume: function () {
	
				return this.gain.gain.value;
	
			},
	
	
			setVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PositionalAudio( listener ) {
	
			Audio.call( this, listener );
	
			this.panner = this.context.createPanner();
			this.panner.connect( this.gain );
	
		}
	
		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
	
			constructor: PositionalAudio,
	
			getOutput: function () {
	
				return this.panner;
	
			},
	
			getRefDistance: function () {
	
				return this.panner.refDistance;
	
			},
	
			setRefDistance: function ( value ) {
	
				this.panner.refDistance = value;
	
			},
	
			getRolloffFactor: function () {
	
				return this.panner.rolloffFactor;
	
			},
	
			setRolloffFactor: function ( value ) {
	
				this.panner.rolloffFactor = value;
	
			},
	
			getDistanceModel: function () {
	
				return this.panner.distanceModel;
	
			},
	
			setDistanceModel: function ( value ) {
	
				this.panner.distanceModel = value;
	
			},
	
			getMaxDistance: function () {
	
				return this.panner.maxDistance;
	
			},
	
			setMaxDistance: function ( value ) {
	
				this.panner.maxDistance = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					position.setFromMatrixPosition( this.matrixWorld );
	
					this.panner.setPosition( position.x, position.y, position.z );
	
				};
	
			} )()
	
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioAnalyser( audio, fftSize ) {
	
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
			this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
			audio.getOutput().connect( this.analyser );
	
		}
	
		Object.assign( AudioAnalyser.prototype, {
	
			getFrequencyData: function () {
	
				this.analyser.getByteFrequencyData( this.data );
	
				return this.data;
	
			},
	
			getAverageFrequency: function () {
	
				var value = 0, data = this.getFrequencyData();
	
				for ( var i = 0; i < data.length; i ++ ) {
	
					value += data[ i ];
	
				}
	
				return value / data.length;
	
			}
	
		} );
	
		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function PropertyMixer( binding, typeName, valueSize ) {
	
			this.binding = binding;
			this.valueSize = valueSize;
	
			var bufferType = Float64Array,
				mixFunction;
	
			switch ( typeName ) {
	
				case 'quaternion':
					mixFunction = this._slerp;
					break;
	
				case 'string':
				case 'bool':
					bufferType = Array;
					mixFunction = this._select;
					break;
	
				default:
					mixFunction = this._lerp;
	
			}
	
			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
	
			this._mixBufferRegion = mixFunction;
	
			this.cumulativeWeight = 0;
	
			this.useCount = 0;
			this.referenceCount = 0;
	
		}
	
		PropertyMixer.prototype = {
	
			constructor: PropertyMixer,
	
			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function( accuIndex, weight ) {
	
				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place
	
				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,
	
					currentWeight = this.cumulativeWeight;
	
				if ( currentWeight === 0 ) {
	
					// accuN := incoming * weight
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ offset + i ] = buffer[ i ];
	
					}
	
					currentWeight = weight;
	
				} else {
	
					// accuN := accuN + incoming * weight
	
					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
				}
	
				this.cumulativeWeight = currentWeight;
	
			},
	
			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function( accuIndex ) {
	
				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,
	
					weight = this.cumulativeWeight,
	
					binding = this.binding;
	
				this.cumulativeWeight = 0;
	
				if ( weight < 1 ) {
	
					// accuN := accuN + original * ( 1 - cumulativeWeight )
	
					var originalValueOffset = stride * 3;
	
					this._mixBufferRegion(
							buffer, offset, originalValueOffset, 1 - weight, stride );
	
				}
	
				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
					if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
						// value has changed -> update scene graph
	
						binding.setValue( buffer, offset );
						break;
	
					}
	
				}
	
			},
	
			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function() {
	
				var binding = this.binding;
	
				var buffer = this.buffer,
					stride = this.valueSize,
	
					originalValueOffset = stride * 3;
	
				binding.getValue( buffer, originalValueOffset );
	
				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
				}
	
				this.cumulativeWeight = 0;
	
			},
	
			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function() {
	
				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );
	
			},
	
	
			// mix functions
	
			_select: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				if ( t >= 0.5 ) {
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
					}
	
				}
	
			},
	
			_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				Quaternion.slerpFlat( buffer, dstOffset,
						buffer, dstOffset, buffer, srcOffset, t );
	
			},
	
			_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				var s = 1 - t;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					var j = dstOffset + i;
	
					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
				}
	
			}
	
		};
	
		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function PropertyBinding( rootNode, path, parsedPath ) {
	
			this.path = path;
			this.parsedPath = parsedPath ||
					PropertyBinding.parseTrackName( path );
	
			this.node = PropertyBinding.findNode(
					rootNode, this.parsedPath.nodeName ) || rootNode;
	
			this.rootNode = rootNode;
	
		}
	
		PropertyBinding.prototype = {
	
			constructor: PropertyBinding,
	
			getValue: function getValue_unbound( targetArray, offset ) {
	
				this.bind();
				this.getValue( targetArray, offset );
	
				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.
	
			},
	
			setValue: function getValue_unbound( sourceArray, offset ) {
	
				this.bind();
				this.setValue( sourceArray, offset );
	
			},
	
			// create getter / setter pair for a property in the scene graph
			bind: function() {
	
				var targetObject = this.node,
					parsedPath = this.parsedPath,
	
					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;
	
				if ( ! targetObject ) {
	
					targetObject = PropertyBinding.findNode(
							this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
					this.node = targetObject;
	
				}
	
				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;
	
		 		// ensure there is a value node
				if ( ! targetObject ) {
	
					console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
					return;
	
				}
	
				if ( objectName ) {
	
					var objectIndex = parsedPath.objectIndex;
	
					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {
	
						case 'materials':
	
							if ( ! targetObject.material ) {
	
								console.error( '  can not bind to material as node does not have a material', this );
								return;
	
							}
	
							if ( ! targetObject.material.materials ) {
	
								console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
								return;
	
							}
	
							targetObject = targetObject.material.materials;
	
							break;
	
						case 'bones':
	
							if ( ! targetObject.skeleton ) {
	
								console.error( '  can not bind to bones as node does not have a skeleton', this );
								return;
	
							}
	
							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.
	
							targetObject = targetObject.skeleton.bones;
	
							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {
	
								if ( targetObject[ i ].name === objectIndex ) {
	
									objectIndex = i;
									break;
	
								}
	
							}
	
							break;
	
						default:
	
							if ( targetObject[ objectName ] === undefined ) {
	
								console.error( '  can not bind to objectName of node, undefined', this );
								return;
	
							}
	
							targetObject = targetObject[ objectName ];
	
					}
	
	
					if ( objectIndex !== undefined ) {
	
						if ( targetObject[ objectIndex ] === undefined ) {
	
							console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
							return;
	
						}
	
						targetObject = targetObject[ objectIndex ];
	
					}
	
				}
	
				// resolve property
				var nodeProperty = targetObject[ propertyName ];
	
				if ( nodeProperty === undefined ) {
	
					var nodeName = parsedPath.nodeName;
	
					console.error( "  trying to update property for track: " + nodeName +
							'.' + propertyName + " but it wasn't found.", targetObject );
					return;
	
				}
	
				// determine versioning scheme
				var versioning = this.Versioning.None;
	
				if ( targetObject.needsUpdate !== undefined ) { // material
	
					versioning = this.Versioning.NeedsUpdate;
					this.targetObject = targetObject;
	
				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
					versioning = this.Versioning.MatrixWorldNeedsUpdate;
					this.targetObject = targetObject;
	
				}
	
				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;
	
				if ( propertyIndex !== undefined ) {
					// access a sub element of the property array (only primitives are supported right now)
	
					if ( propertyName === "morphTargetInfluences" ) {
						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {
	
							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
							return;
	
						}
	
						if ( ! targetObject.geometry.morphTargets ) {
	
							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
							return;
	
						}
	
						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
	
								propertyIndex = i;
								break;
	
							}
	
						}
	
					}
	
					bindingType = this.BindingType.ArrayElement;
	
					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;
	
				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
					// must use copy for Object3D.Euler/Quaternion
	
					bindingType = this.BindingType.HasFromToArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else if ( nodeProperty.length !== undefined ) {
	
					bindingType = this.BindingType.EntireArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else {
	
					this.propertyName = propertyName;
	
				}
	
				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
			},
	
			unbind: function() {
	
				this.node = null;
	
				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;
	
			}
	
		};
	
		Object.assign( PropertyBinding.prototype, { // prototype, continued
	
			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function() {},
			_setValue_unavailable: function() {},
	
			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,
	
			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},
	
			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},
	
			GetterByBindingType: [
	
				function getValue_direct( buffer, offset ) {
	
					buffer[ offset ] = this.node[ this.propertyName ];
	
				},
	
				function getValue_array( buffer, offset ) {
	
					var source = this.resolvedProperty;
	
					for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
						buffer[ offset ++ ] = source[ i ];
	
					}
	
				},
	
				function getValue_arrayElement( buffer, offset ) {
	
					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
				},
	
				function getValue_toArray( buffer, offset ) {
	
					this.resolvedProperty.toArray( buffer, offset );
	
				}
	
			],
	
			SetterByBindingTypeAndVersioning: [
	
				[
					// Direct
	
					function setValue_direct( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
	
					},
	
					function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// EntireArray
	
					function setValue_array( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
					},
	
					function setValue_array_setNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// ArrayElement
	
					function setValue_arrayElement( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
					},
	
					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// HasToFromArray
	
					function setValue_fromArray( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
	
					},
	
					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				]
	
			]
	
		} );
	
		PropertyBinding.Composite =
				function( targetGroup, path, optionalParsedPath ) {
	
			var parsedPath = optionalParsedPath ||
					PropertyBinding.parseTrackName( path );
	
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );
	
		};
	
		PropertyBinding.Composite.prototype = {
	
			constructor: PropertyBinding.Composite,
	
			getValue: function( array, offset ) {
	
				this.bind(); // bind all binding
	
				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];
	
				// and only call .getValue on the first
				if ( binding !== undefined ) binding.getValue( array, offset );
	
			},
	
			setValue: function( array, offset ) {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].setValue( array, offset );
	
				}
	
			},
	
			bind: function() {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].bind();
	
				}
	
			},
	
			unbind: function() {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].unbind();
	
				}
	
			}
	
		};
	
		PropertyBinding.create = function( root, path, parsedPath ) {
	
			if ( ! ( root && root.isAnimationObjectGroup ) ) {
	
				return new PropertyBinding( root, path, parsedPath );
	
			} else {
	
				return new PropertyBinding.Composite( root, path, parsedPath );
	
			}
	
		};
	
		PropertyBinding.parseTrackName = function( trackName ) {
	
			// matches strings in the form of:
			//    nodeName.property
			//    nodeName.property[accessor]
			//    nodeName.material.property[accessor]
			//    uuid.property[accessor]
			//    uuid.objectName[objectIndex].propertyName[propertyIndex]
			//    parentName/nodeName.property
			//    parentName/parentName/nodeName.property[index]
			//    .bone[Armature.DEF_cog].position
			//    scene:helium_balloon_model:helium_balloon_model.position
			// created and tested via https://regex101.com/#javascript
	
			var re = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/;
			var matches = re.exec( trackName );
	
			if ( ! matches ) {
	
				throw new Error( "cannot parse trackName at all: " + trackName );
	
			}
	
			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ],
				propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
			};
	
			if ( results.propertyName === null || results.propertyName.length === 0 ) {
	
				throw new Error( "can not parse propertyName from trackName: " + trackName );
	
			}
	
			return results;
	
		};
	
		PropertyBinding.findNode = function( root, nodeName ) {
	
			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
	
				return root;
	
			}
	
			// search into skeleton bones.
			if ( root.skeleton ) {
	
				var searchSkeleton = function( skeleton ) {
	
					for( var i = 0; i < skeleton.bones.length; i ++ ) {
	
						var bone = skeleton.bones[ i ];
	
						if ( bone.name === nodeName ) {
	
							return bone;
	
						}
					}
	
					return null;
	
				};
	
				var bone = searchSkeleton( root.skeleton );
	
				if ( bone ) {
	
					return bone;
	
				}
			}
	
			// search into node subtree.
			if ( root.children ) {
	
				var searchNodeSubtree = function( children ) {
	
					for( var i = 0; i < children.length; i ++ ) {
	
						var childNode = children[ i ];
	
						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
							return childNode;
	
						}
	
						var result = searchNodeSubtree( childNode.children );
	
						if ( result ) return result;
	
					}
	
					return null;
	
				};
	
				var subTreeNode = searchNodeSubtree( root.children );
	
				if ( subTreeNode ) {
	
					return subTreeNode;
	
				}
	
			}
	
			return null;
	
		};
	
		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 * 	-	Add objects you would otherwise pass as 'root' to the
		 * 		constructor or the .clipAction method of AnimationMixer.
		 *
		 * 	-	Instead pass this object as 'root'.
		 *
		 * 	-	You can also add and remove objects later when the mixer
		 * 		is running.
		 *
		 * Note:
		 *
		 *  	Objects of this class appear as one object to the mixer,
		 *  	so cache control of the individual objects must be done
		 *  	on the group.
		 *
		 * Limitation:
		 *
		 * 	- 	The animated properties must be compatible among the
		 * 		all objects in the group.
		 *
		 *  -	A single property can either be controlled through a
		 *  	target group or directly, but not both.
		 *
		 * @author tschw
		 */
	
		function AnimationObjectGroup( var_args ) {
	
			this.uuid = _Math.generateUUID();
	
			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );
	
			this.nCachedObjects_ = 0;			// threshold
			// note: read by PropertyBinding.Composite
	
			var indices = {};
			this._indicesByUUID = indices;		// for bookkeeping
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				indices[ arguments[ i ].uuid ] = i;
	
			}
	
			this._paths = [];					// inside: string
			this._parsedPaths = [];				// inside: { we don't care, here }
			this._bindings = []; 				// inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
	
			var scope = this;
	
			this.stats = {
	
				objects: {
					get total() { return scope._objects.length; },
					get inUse() { return this.total - scope.nCachedObjects_;  }
				},
	
				get bindingsPerObject() { return scope._bindings.length; }
	
			};
	
		}
	
		AnimationObjectGroup.prototype = {
	
			constructor: AnimationObjectGroup,
	
			isAnimationObjectGroup: true,
	
			add: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ],
						knownObject = undefined;
	
					if ( index === undefined ) {
	
						// unknown object -> add it to the ACTIVE region
	
						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							bindings[ j ].push(
									new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] ) );
	
						}
	
					} else if ( index < nCachedObjects ) {
	
						knownObject = objects[ index ];
	
						// move existing object to the ACTIVE region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];
	
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = lastCached;
	
							if ( binding === undefined ) {
	
								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist
	
								binding = new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] );
	
							}
	
							bindingsForPath[ firstActiveIndex ] = binding;
	
						}
	
					} else if ( objects[ index ] !== knownObject) {
	
						console.error( "Different objects with the same UUID " +
								"detected. Clean the caches or recreate your " +
								"infrastructure when reloading scenes..." );
	
					} // else the object is already where we want it to be
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			remove: function( var_args ) {
	
				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined && index >= nCachedObjects ) {
	
						// move existing object into the CACHED region
	
						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];
	
						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;
	
						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;
	
						}
	
					}
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// remove & forget
			uncache: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined ) {
	
						delete indicesByUUID[ uuid ];
	
						if ( index < nCachedObjects ) {
	
							// object is cached, shrink the CACHED region
	
							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;
	
							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];
	
								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();
	
							}
	
						} else {
	
							// object is active, just swap with the last and pop
	
							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ];
	
								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();
	
							}
	
						} // cached or active
	
					} // if object is known
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// Internal interface used by befriended PropertyBinding.Composite:
	
			subscribe_: function( path, parsedPath ) {
				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;
	
				if ( index !== undefined ) return bindings[ index ];
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );
	
				index = bindings.length;
	
				indicesByPath[ path ] = index;
	
				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );
	
				for ( var i = nCachedObjects,
						n = objects.length; i !== n; ++ i ) {
	
					var object = objects[ i ];
	
					bindingsForPath[ i ] =
							new PropertyBinding( object, path, parsedPath );
	
				}
	
				return bindingsForPath;
	
			},
	
			unsubscribe_: function( path ) {
				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];
	
				if ( index !== undefined ) {
	
					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];
	
					indicesByPath[ lastBindingsPath ] = index;
	
					bindings[ index ] = lastBindings;
					bindings.pop();
	
					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();
	
					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();
	
				}
	
			}
	
		};
	
		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */
	
		function AnimationAction( mixer, clip, localRoot ) {
	
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;
	
			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );
	
			var interpolantSettings = {
					endingStart: 	ZeroCurvatureEnding,
					endingEnd:		ZeroCurvatureEnding
			};
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;
	
			}
	
			this._interpolantSettings = interpolantSettings;
	
			this._interpolants = interpolants;	// bound by the mixer
	
			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );
	
			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager
	
			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
	
			this.loop = LoopRepeat;
			this._loopCount = -1;
	
			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;
	
			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;
	
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
	
			this.weight = 1;
			this._effectiveWeight = 1;
	
			this.repetitions = Infinity; 		// no. of repetitions when looping
	
			this.paused = false;				// false -> zero effective time scale
			this.enabled = true;				// true -> zero effective weight
	
			this.clampWhenFinished 	= false;	// keep feeding the last frame?
	
			this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
	
		}
	
		AnimationAction.prototype = {
	
			constructor: AnimationAction,
	
			// State & Scheduling
	
			play: function() {
	
				this._mixer._activateAction( this );
	
				return this;
	
			},
	
			stop: function() {
	
				this._mixer._deactivateAction( this );
	
				return this.reset();
	
			},
	
			reset: function() {
	
				this.paused = false;
				this.enabled = true;
	
				this.time = 0;			// restart clip
				this._loopCount = -1;	// forget previous loops
				this._startTime = null;	// forget scheduling
	
				return this.stopFading().stopWarping();
	
			},
	
			isRunning: function() {
	
				return this.enabled && ! this.paused && this.timeScale !== 0 &&
						this._startTime === null && this._mixer._isActiveAction( this );
	
			},
	
			// return true when play has been called
			isScheduled: function() {
	
				return this._mixer._isActiveAction( this );
	
			},
	
			startAt: function( time ) {
	
				this._startTime = time;
	
				return this;
	
			},
	
			setLoop: function( mode, repetitions ) {
	
				this.loop = mode;
				this.repetitions = repetitions;
	
				return this;
	
			},
	
			// Weight
	
			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function( weight ) {
	
				this.weight = weight;
	
				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;
	
				return this.stopFading();
	
			},
	
			// return the weight considering fading and .enabled
			getEffectiveWeight: function() {
	
				return this._effectiveWeight;
	
			},
	
			fadeIn: function( duration ) {
	
				return this._scheduleFading( duration, 0, 1 );
	
			},
	
			fadeOut: function( duration ) {
	
				return this._scheduleFading( duration, 1, 0 );
	
			},
	
			crossFadeFrom: function( fadeOutAction, duration, warp ) {
	
				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );
	
				if( warp ) {
	
					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,
	
						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;
	
					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );
	
				}
	
				return this;
	
			},
	
			crossFadeTo: function( fadeInAction, duration, warp ) {
	
				return fadeInAction.crossFadeFrom( this, duration, warp );
	
			},
	
			stopFading: function() {
	
				var weightInterpolant = this._weightInterpolant;
	
				if ( weightInterpolant !== null ) {
	
					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );
	
				}
	
				return this;
	
			},
	
			// Time Scale Control
	
			// set the weight stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function( timeScale ) {
	
				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 :timeScale;
	
				return this.stopWarping();
	
			},
	
			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function() {
	
				return this._effectiveTimeScale;
	
			},
	
			setDuration: function( duration ) {
	
				this.timeScale = this._clip.duration / duration;
	
				return this.stopWarping();
	
			},
	
			syncWith: function( action ) {
	
				this.time = action.time;
				this.timeScale = action.timeScale;
	
				return this.stopWarping();
	
			},
	
			halt: function( duration ) {
	
				return this.warp( this._effectiveTimeScale, 0, duration );
	
			},
	
			warp: function( startTimeScale, endTimeScale, duration ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,
	
					timeScale = this.timeScale;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant();
					this._timeScaleInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now;
				times[ 1 ] = now + duration;
	
				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;
	
				return this;
	
			},
	
			stopWarping: function() {
	
				var timeScaleInterpolant = this._timeScaleInterpolant;
	
				if ( timeScaleInterpolant !== null ) {
	
					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
				}
	
				return this;
	
			},
	
			// Object Accessors
	
			getMixer: function() {
	
				return this._mixer;
	
			},
	
			getClip: function() {
	
				return this._clip;
	
			},
	
			getRoot: function() {
	
				return this._localRoot || this._mixer._root;
	
			},
	
			// Interna
	
			_update: function( time, deltaTime, timeDirection, accuIndex ) {
				// called by the mixer
	
				var startTime = this._startTime;
	
				if ( startTime !== null ) {
	
					// check for scheduled start of action
	
					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {
	
						return; // yet to come / don't decide when delta = 0
	
					}
	
					// start
	
					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;
	
				}
	
				// apply time scale and advance time
	
				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );
	
				// note: _updateTime may disable the action resulting in
				// an effective weight of 0
	
				var weight = this._updateWeight( time );
	
				if ( weight > 0 ) {
	
					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;
	
					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );
	
					}
	
				}
	
			},
	
			_updateWeight: function( time ) {
	
				var weight = 0;
	
				if ( this.enabled ) {
	
					weight = this.weight;
					var interpolant = this._weightInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						weight *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopFading();
	
							if ( interpolantValue === 0 ) {
	
								// faded out, disable
								this.enabled = false;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveWeight = weight;
				return weight;
	
			},
	
			_updateTimeScale: function( time ) {
	
				var timeScale = 0;
	
				if ( ! this.paused ) {
	
					timeScale = this.timeScale;
	
					var interpolant = this._timeScaleInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						timeScale *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopWarping();
	
							if ( timeScale === 0 ) {
	
								// motion has halted, pause
								this.paused = true;
	
							} else {
	
								// warp done - apply final time scale
								this.timeScale = timeScale;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveTimeScale = timeScale;
				return timeScale;
	
			},
	
			_updateTime: function( deltaTime ) {
	
				var time = this.time + deltaTime;
	
				if ( deltaTime === 0 ) return time;
	
				var duration = this._clip.duration,
	
					loop = this.loop,
					loopCount = this._loopCount;
	
				if ( loop === LoopOnce ) {
	
					if ( loopCount === -1 ) {
						// just started
	
						this._loopCount = 0;
						this._setEndings( true, true, false );
	
					}
	
					handle_stop: {
	
						if ( time >= duration ) {
	
							time = duration;
	
						} else if ( time < 0 ) {
	
							time = 0;
	
						} else break handle_stop;
	
						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;
	
						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? -1 : 1
						} );
	
					}
	
				} else { // repetitive Repeat or PingPong
	
					var pingPong = ( loop === LoopPingPong );
	
					if ( loopCount === -1 ) {
						// just started
	
						if ( deltaTime >= 0 ) {
	
							loopCount = 0;
	
							this._setEndings(
									true, this.repetitions === 0, pingPong );
	
						} else {
	
							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1
	
							this._setEndings(
									this.repetitions === 0, true, pingPong );
	
						}
	
					}
	
					if ( time >= duration || time < 0 ) {
						// wrap around
	
						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;
	
						loopCount += Math.abs( loopDelta );
	
						var pending = this.repetitions - loopCount;
	
						if ( pending < 0 ) {
							// have to stop (switch state, clamp time, fire event)
	
							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;
	
							time = deltaTime > 0 ? duration : 0;
	
							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );
	
						} else {
							// keep running
	
							if ( pending === 0 ) {
								// entering the last round
	
								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );
	
							} else {
	
								this._setEndings( false, false, pingPong );
	
							}
	
							this._loopCount = loopCount;
	
							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );
	
						}
	
					}
	
					if ( pingPong && ( loopCount & 1 ) === 1 ) {
						// invert time for the "pong round"
	
						this.time = time;
						return duration - time;
	
					}
	
				}
	
				this.time = time;
				return time;
	
			},
	
			_setEndings: function( atStart, atEnd, pingPong ) {
	
				var settings = this._interpolantSettings;
	
				if ( pingPong ) {
	
					settings.endingStart 	= ZeroSlopeEnding;
					settings.endingEnd		= ZeroSlopeEnding;
	
				} else {
	
					// assuming for LoopOnce atStart == atEnd == true
	
					if ( atStart ) {
	
						settings.endingStart = this.zeroSlopeAtStart ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingStart = WrapAroundEnding;
	
					}
	
					if ( atEnd ) {
	
						settings.endingEnd = this.zeroSlopeAtEnd ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingEnd 	 = WrapAroundEnding;
	
					}
	
				}
	
			},
	
			_scheduleFading: function( duration, weightNow, weightThen ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant();
					this._weightInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now; 				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
	
				return this;
	
			}
	
		};
	
		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function AnimationMixer( root ) {
	
			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
	
			this.time = 0;
	
			this.timeScale = 1.0;
	
		}
	
		AnimationMixer.prototype = {
	
			constructor: AnimationMixer,
	
			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function ( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject !== null ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;
	
				if ( actionsForClip !== undefined ) {
	
					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];
	
					if ( existingAction !== undefined ) {
	
						return existingAction;
	
					}
	
					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];
	
					// also, take the clip from the prototype action
					if ( clipObject === null )
						clipObject = prototypeAction._clip;
	
				}
	
				// clip must be known when specified via string
				if ( clipObject === null ) return null;
	
				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );
	
				this._bindAction( newAction, prototypeAction );
	
				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );
	
				return newAction;
	
			},
	
			// get an existing action
			existingAction: function ( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					return actionsForClip.actionByRoot[ rootUuid ] || null;
	
				}
	
				return null;
	
			},
	
			// deactivates all previously scheduled actions
			stopAllAction: function () {
	
				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				this._nActiveActions = 0;
				this._nActiveBindings = 0;
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					actions[ i ].reset();
	
				}
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].useCount = 0;
	
				}
	
				return this;
	
			},
	
			// advance the time and update apply the animation
			update: function ( deltaTime ) {
	
				deltaTime *= this.timeScale;
	
				var actions = this._actions,
					nActions = this._nActiveActions,
	
					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),
	
					accuIndex = this._accuIndex ^= 1;
	
				// run active actions
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					var action = actions[ i ];
	
					if ( action.enabled ) {
	
						action._update( time, deltaTime, timeDirection, accuIndex );
	
					}
	
				}
	
				// update scene graph
	
				var bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].apply( accuIndex );
	
				}
	
				return this;
	
			},
	
			// return this mixer's root target object
			getRoot: function () {
	
				return this._root;
	
			},
	
			// free all resources specific to a particular clip
			uncacheClip: function ( clip ) {
	
				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away
	
					var actionsToRemove = actionsForClip.knownActions;
	
					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
						var action = actionsToRemove[ i ];
	
						this._deactivateAction( action );
	
						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];
	
						action._cacheIndex = null;
						action._byClipCacheIndex = null;
	
						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();
	
						this._removeInactiveBindingsForAction( action );
	
					}
	
					delete actionsByClip[ clipUuid ];
	
				}
	
			},
	
			// free all resources specific to a particular root target object
			uncacheRoot: function ( root ) {
	
				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;
	
				for ( var clipUuid in actionsByClip ) {
	
					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];
	
					if ( action !== undefined ) {
	
						this._deactivateAction( action );
						this._removeInactiveAction( action );
	
					}
	
				}
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingByName !== undefined ) {
	
					for ( var trackName in bindingByName ) {
	
						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			// remove a targeted clip from the cache
			uncacheAction: function ( clip, optionalRoot ) {
	
				var action = this.existingAction( clip, optionalRoot );
	
				if ( action !== null ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
		};
	
		// Implementation details:
	
		Object.assign( AnimationMixer.prototype, {
	
			_bindAction: function ( action, prototypeAction ) {
	
				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingsByName === undefined ) {
	
					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;
	
				}
	
				for ( var i = 0; i !== nTracks; ++ i ) {
	
					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];
	
					if ( binding !== undefined ) {
	
						bindings[ i ] = binding;
	
					} else {
	
						binding = bindings[ i ];
	
						if ( binding !== undefined ) {
	
							// existing binding, make sure the cache knows
	
							if ( binding._cacheIndex === null ) {
	
								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );
	
							}
	
							continue;
	
						}
	
						var path = prototypeAction && prototypeAction.
								_propertyBindings[ i ].binding.parsedPath;
	
						binding = new PropertyMixer(
								PropertyBinding.create( root, trackName, path ),
								track.ValueTypeName, track.getValueSize() );
	
						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );
	
						bindings[ i ] = binding;
	
					}
	
					interpolants[ i ].resultBuffer = binding.buffer;
	
				}
	
			},
	
			_activateAction: function ( action ) {
	
				if ( ! this._isActiveAction( action ) ) {
	
					if ( action._cacheIndex === null ) {
	
						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind
	
						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];
	
						this._bindAction( action,
								actionsForClip && actionsForClip.knownActions[ 0 ] );
	
						this._addInactiveAction( action, clipUuid, rootUuid );
	
					}
	
					var bindings = action._propertyBindings;
	
					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( binding.useCount ++ === 0 ) {
	
							this._lendBinding( binding );
							binding.saveOriginalState();
	
						}
	
					}
	
					this._lendAction( action );
	
				}
	
			},
	
			_deactivateAction: function ( action ) {
	
				if ( this._isActiveAction( action ) ) {
	
					var bindings = action._propertyBindings;
	
					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( -- binding.useCount === 0 ) {
	
							binding.restoreOriginalState();
							this._takeBackBinding( binding );
	
						}
	
					}
	
					this._takeBackAction( action );
	
				}
	
			},
	
			// Memory manager
	
			_initMemoryManager: function () {
	
				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;
	
				this._actionsByClip = {};
				// inside:
				// {
				// 		knownActions: Array< AnimationAction >	- used as prototypes
				// 		actionByRoot: AnimationAction			- lookup
				// }
	
	
				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;
	
				this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;
	
				var scope = this;
	
				this.stats = {
	
					actions: {
						get total() { return scope._actions.length; },
						get inUse() { return scope._nActiveActions; }
					},
					bindings: {
						get total() { return scope._bindings.length; },
						get inUse() { return scope._nActiveBindings; }
					},
					controlInterpolants: {
						get total() { return scope._controlInterpolants.length; },
						get inUse() { return scope._nActiveControlInterpolants; }
					}
	
				};
	
			},
	
			// Memory management for AnimationAction objects
	
			_isActiveAction: function ( action ) {
	
				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;
	
			},
	
			_addInactiveAction: function ( action, clipUuid, rootUuid ) {
	
				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip === undefined ) {
	
					actionsForClip = {
	
						knownActions: [ action ],
						actionByRoot: {}
	
					};
	
					action._byClipCacheIndex = 0;
	
					actionsByClip[ clipUuid ] = actionsForClip;
	
				} else {
	
					var knownActions = actionsForClip.knownActions;
	
					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );
	
				}
	
				action._cacheIndex = actions.length;
				actions.push( action );
	
				actionsForClip.actionByRoot[ rootUuid ] = action;
	
			},
	
			_removeInactiveAction: function ( action ) {
	
				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;
	
				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();
	
				action._cacheIndex = null;
	
	
				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,
	
					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],
	
					byClipCacheIndex = action._byClipCacheIndex;
	
				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();
	
				action._byClipCacheIndex = null;
	
	
				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( actions._localRoot || this._root ).uuid;
	
				delete actionByRoot[ rootUuid ];
	
				if ( knownActionsForClip.length === 0 ) {
	
					delete actionsByClip[ clipUuid ];
	
				}
	
				this._removeInactiveBindingsForAction( action );
	
			},
	
			_removeInactiveBindingsForAction: function ( action ) {
	
				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.referenceCount === 0 ) {
	
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			_lendAction: function ( action ) {
	
				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					lastActiveIndex = this._nActiveActions ++,
	
					firstInactiveAction = actions[ lastActiveIndex ];
	
				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;
	
				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;
	
			},
	
			_takeBackAction: function ( action ) {
	
				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveActions,
	
					lastActiveAction = actions[ firstInactiveIndex ];
	
				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;
	
				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;
	
			},
	
			// Memory management for PropertyMixer objects
	
			_addInactiveBinding: function ( binding, rootUuid, trackName ) {
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					bindings = this._bindings;
	
				if ( bindingByName === undefined ) {
	
					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;
	
				}
	
				bindingByName[ trackName ] = binding;
	
				binding._cacheIndex = bindings.length;
				bindings.push( binding );
	
			},
	
			_removeInactiveBinding: function ( binding ) {
	
				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;
	
				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();
	
				delete bindingByName[ trackName ];
	
				remove_empty_map: {
	
					for ( var _ in bindingByName ) break remove_empty_map;
	
					delete bindingsByRoot[ rootUuid ];
	
				}
	
			},
	
			_lendBinding: function ( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					lastActiveIndex = this._nActiveBindings ++,
	
					firstInactiveBinding = bindings[ lastActiveIndex ];
	
				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;
	
				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;
	
			},
	
			_takeBackBinding: function ( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveBindings,
	
					lastActiveBinding = bindings[ firstInactiveIndex ];
	
				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;
	
				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;
	
			},
	
	
			// Memory management of Interpolants for weight and time scale
	
			_lendControlInterpolant: function () {
	
				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];
	
				if ( interpolant === undefined ) {
	
					interpolant = new LinearInterpolant(
							new Float32Array( 2 ), new Float32Array( 2 ),
								1, this._controlInterpolantsResultBuffer );
	
					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;
	
				}
	
				return interpolant;
	
			},
	
			_takeBackControlInterpolant: function ( interpolant ) {
	
				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,
	
					firstInactiveIndex = -- this._nActiveControlInterpolants,
	
					lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;
	
				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;
	
			},
	
			_controlInterpolantsResultBuffer: new Float32Array( 1 )
	
		} );
	
		Object.assign( AnimationMixer.prototype, EventDispatcher.prototype );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Uniform( value ) {
	
			if ( typeof value === 'string' ) {
	
				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];
	
			}
	
			this.value = value;
	
		}
	
		Uniform.prototype.clone = function () {
	
			return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferGeometry() {
	
			BufferGeometry.call( this );
	
			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;
	
		}
	
		InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;
	
		InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
	
		InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex
	
			} );
	
		};
	
		InstancedBufferGeometry.prototype.copy = function ( source ) {
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			var attributes = source.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			var groups = source.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );
	
			}
	
			return this;
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
	
			this.uuid = _Math.generateUUID();
	
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
	
			this.normalized = normalized === true;
	
		}
	
	
		InterleavedBufferAttribute.prototype = {
	
			constructor: InterleavedBufferAttribute,
	
			isInterleavedBufferAttribute: true,
	
			get count() {
	
				return this.data.count;
	
			},
	
			get array() {
	
				return this.data.array;
	
			},
	
			setX: function ( index, x ) {
	
				this.data.array[ index * this.data.stride + this.offset ] = x;
	
				return this;
	
			},
	
			setY: function ( index, y ) {
	
				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
				return this;
	
			},
	
			setZ: function ( index, z ) {
	
				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
				return this;
	
			},
	
			setW: function ( index, w ) {
	
				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset ];
	
			},
	
			getY: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
			},
	
			getZ: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
			},
	
			getW: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
			},
	
			setXY: function ( index, x, y ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBuffer( array, stride ) {
	
			this.uuid = _Math.generateUUID();
	
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.onUploadCallback = function () {};
	
			this.version = 0;
	
		}
	
		InterleavedBuffer.prototype = {
	
			constructor: InterleavedBuffer,
	
			isInterleavedBuffer: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.stride : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.stride;
				index2 *= attribute.stride;
	
				for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			onUpload: function ( callback ) {
	
				this.onUploadCallback = callback;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
	
			InterleavedBuffer.call( this, array, stride );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
		InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;
	
		InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
	
		InstancedInterleavedBuffer.prototype.copy = function ( source ) {
	
			InterleavedBuffer.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {
	
			BufferAttribute.call( this, array, itemSize );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;
	
		InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
	
		InstancedBufferAttribute.prototype.copy = function ( source ) {
	
			BufferAttribute.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */
	
		function Raycaster( origin, direction, near, far ) {
	
			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		}
	
		function ascSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		//
	
		Raycaster.prototype = {
	
			constructor: Raycaster,
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( (camera && camera.isPerspectiveCamera) ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( (camera && camera.isOrthographicCamera) ) {
	
					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( ascSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( ascSort );
	
				return intersects;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Clock( autoStart ) {
	
			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
	
			this.running = false;
	
		}
	
		Clock.prototype = {
	
			constructor: Clock,
	
			start: function () {
	
				this.startTime = ( performance || Date ).now();
	
				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;
	
			},
	
			stop: function () {
	
				this.getElapsedTime();
				this.running = false;
	
			},
	
			getElapsedTime: function () {
	
				this.getDelta();
				return this.elapsedTime;
	
			},
	
			getDelta: function () {
	
				var diff = 0;
	
				if ( this.autoStart && ! this.running ) {
	
					this.start();
	
				}
	
				if ( this.running ) {
	
					var newTime = ( performance || Date ).now();
	
					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;
	
					this.elapsedTime += diff;
	
				}
	
				return diff;
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */
	
		function Spherical( radius, phi, theta ) {
	
			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
			this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere
	
			return this;
	
		}
	
		Spherical.prototype = {
	
			constructor: Spherical,
	
			set: function ( radius, phi, theta ) {
	
				this.radius = radius;
				this.phi = phi;
				this.theta = theta;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( other ) {
	
				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;
	
				return this;
	
			},
	
			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function() {
	
				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
	
				return this;
	
			},
	
			setFromVector3: function( vec3 ) {
	
				this.radius = vec3.length();
	
				if ( this.radius === 0 ) {
	
					this.theta = 0;
					this.phi = 0;
	
				} else {
	
					this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
					this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle
	
				}
	
				return this;
	
			}
	
		};
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
		 *
		 */
	
		function Cylindrical( radius, theta, y ) {
	
			this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
			this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane
	
			return this;
	
		}
	
		Cylindrical.prototype = {
	
			constructor: Cylindrical,
	
			set: function ( radius, theta, y ) {
	
				this.radius = radius;
				this.theta = theta;
				this.y = y;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( other ) {
	
				this.radius = other.radius;
				this.theta = other.theta;
				this.y = other.y;
	
				return this;
	
			},
	
			setFromVector3: function( vec3 ) {
	
				this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
				this.theta = Math.atan2( vec3.x, vec3.z );
				this.y = vec3.y;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function MorphBlendMesh( geometry, material ) {
	
			Mesh.call( this, geometry, material );
	
			this.animationsMap = {};
			this.animationsList = [];
	
			// prepare default animation
			// (all frames played together in 1 second)
	
			var numFrames = this.geometry.morphTargets.length;
	
			var name = "__default";
	
			var startFrame = 0;
			var endFrame = numFrames - 1;
	
			var fps = numFrames / 1;
	
			this.createAnimation( name, startFrame, endFrame, fps );
			this.setAnimationWeight( name, 1 );
	
		}
	
		MorphBlendMesh.prototype = Object.create( Mesh.prototype );
		MorphBlendMesh.prototype.constructor = MorphBlendMesh;
	
		MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
			var animation = {
	
				start: start,
				end: end,
	
				length: end - start + 1,
	
				fps: fps,
				duration: ( end - start ) / fps,
	
				lastFrame: 0,
				currentFrame: 0,
	
				active: false,
	
				time: 0,
				direction: 1,
				weight: 1,
	
				directionBackwards: false,
				mirroredLoop: false
	
			};
	
			this.animationsMap[ name ] = animation;
			this.animationsList.push( animation );
	
		};
	
		MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
			var pattern = /([a-z]+)_?(\d+)/i;
	
			var firstAnimation, frameRanges = {};
	
			var geometry = this.geometry;
	
			for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
				var morph = geometry.morphTargets[ i ];
				var chunks = morph.name.match( pattern );
	
				if ( chunks && chunks.length > 1 ) {
	
					var name = chunks[ 1 ];
	
					if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
					var range = frameRanges[ name ];
	
					if ( i < range.start ) range.start = i;
					if ( i > range.end ) range.end = i;
	
					if ( ! firstAnimation ) firstAnimation = name;
	
				}
	
			}
	
			for ( var name in frameRanges ) {
	
				var range = frameRanges[ name ];
				this.createAnimation( name, range.start, range.end, fps );
	
			}
	
			this.firstAnimation = firstAnimation;
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = 1;
				animation.directionBackwards = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = - 1;
				animation.directionBackwards = true;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.fps = fps;
				animation.duration = ( animation.end - animation.start ) / animation.fps;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.duration = duration;
				animation.fps = ( animation.end - animation.start ) / animation.duration;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.weight = weight;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = time;
	
			}
	
		};
	
		MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
			var time = 0;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				time = animation.time;
	
			}
	
			return time;
	
		};
	
		MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
			var duration = - 1;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				duration = animation.duration;
	
			}
	
			return duration;
	
		};
	
		MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = 0;
				animation.active = true;
	
			} else {
	
				console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
			}
	
		};
	
		MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.active = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.update = function ( delta ) {
	
			for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
				var animation = this.animationsList[ i ];
	
				if ( ! animation.active ) continue;
	
				var frameTime = animation.duration / animation.length;
	
				animation.time += animation.direction * delta;
	
				if ( animation.mirroredLoop ) {
	
					if ( animation.time > animation.duration || animation.time < 0 ) {
	
						animation.direction *= - 1;
	
						if ( animation.time > animation.duration ) {
	
							animation.time = animation.duration;
							animation.directionBackwards = true;
	
						}
	
						if ( animation.time < 0 ) {
	
							animation.time = 0;
							animation.directionBackwards = false;
	
						}
	
					}
	
				} else {
	
					animation.time = animation.time % animation.duration;
	
					if ( animation.time < 0 ) animation.time += animation.duration;
	
				}
	
				var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
				var weight = animation.weight;
	
				if ( keyframe !== animation.currentFrame ) {
	
					this.morphTargetInfluences[ animation.lastFrame ] = 0;
					this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
					this.morphTargetInfluences[ keyframe ] = 0;
	
					animation.lastFrame = animation.currentFrame;
					animation.currentFrame = keyframe;
	
				}
	
				var mix = ( animation.time % frameTime ) / frameTime;
	
				if ( animation.directionBackwards ) mix = 1 - mix;
	
				if ( animation.currentFrame !== animation.lastFrame ) {
	
					this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
					this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
				} else {
	
					this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
				}
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function ImmediateRenderObject( material ) {
	
			Object3D.call( this );
	
			this.material = material;
			this.render = function ( renderCallback ) {};
	
		}
	
		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
	
		ImmediateRenderObject.prototype.isImmediateRenderObject = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function VertexNormalsHelper( object, size, hex, linewidth ) {
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xff0000;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry && objGeometry.isGeometry ) {
	
				nNormals = objGeometry.faces.length * 3;
	
			} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
				nNormals = objGeometry.attributes.normal.count;
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
		VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
		VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
	
		VertexNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				var keys = [ 'a', 'b', 'c' ];
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				if ( objGeometry && objGeometry.isGeometry ) {
	
					var vertices = objGeometry.vertices;
	
					var faces = objGeometry.faces;
	
					var idx = 0;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						var face = faces[ i ];
	
						for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
							var vertex = vertices[ face[ keys[ j ] ] ];
	
							var normal = face.vertexNormals[ j ];
	
							v1.copy( vertex ).applyMatrix4( matrixWorld );
	
							v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
							position.setXYZ( idx, v1.x, v1.y, v1.z );
	
							idx = idx + 1;
	
							position.setXYZ( idx, v2.x, v2.y, v2.z );
	
							idx = idx + 1;
	
						}
	
					}
	
				} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
					var objPos = objGeometry.attributes.position;
	
					var objNorm = objGeometry.attributes.normal;
	
					var idx = 0;
	
					// for simplicity, ignore index and drawcalls, and render every normal
	
					for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
						v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
						v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
						v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
				position.needsUpdate = true;
	
				return this;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function SpotLightHelper( light ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var geometry = new BufferGeometry();
	
			var positions = [
				0, 0, 0,   0,   0,   1,
				0, 0, 0,   1,   0,   1,
				0, 0, 0, - 1,   0,   1,
				0, 0, 0,   0,   1,   1,
				0, 0, 0,   0, - 1,   1
			];
	
			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
	
				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;
	
				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );
	
			this.update();
	
		}
	
		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;
	
		SpotLightHelper.prototype.dispose = function () {
	
			this.cone.geometry.dispose();
			this.cone.material.dispose();
	
		};
	
		SpotLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
			var vector2 = new Vector3();
	
			return function update() {
	
				var coneLength = this.light.distance ? this.light.distance : 1000;
				var coneWidth = coneLength * Math.tan( this.light.angle );
	
				this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
				vector.setFromMatrixPosition( this.light.matrixWorld );
				vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
				this.cone.lookAt( vector2.sub( vector ) );
	
				this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			};
	
		}();
	
		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function SkeletonHelper( object ) {
	
			this.bones = this.getBoneList( object );
	
			var geometry = new BufferGeometry();
	
			var vertices = [];
			var colors = [];
	
			var color1 = new Color( 0, 0, 1 );
			var color2 = new Color( 0, 1, 0 );
	
			for ( var i = 0; i < this.bones.length; i ++ ) {
	
				var bone = this.bones[ i ];
	
				if ( bone.parent && bone.parent.isBone ) {
	
					vertices.push( 0, 0, 0 );
					vertices.push( 0, 0, 0 );
					colors.push( color1.r, color1.g, color1.b );
					colors.push( color2.r, color2.g, color2.b );
	
				}
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
			LineSegments.call( this, geometry, material );
	
			this.root = object;
	
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
	
		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;
	
		SkeletonHelper.prototype.getBoneList = function( object ) {
	
			var boneList = [];
	
			if ( object && object.isBone ) {
	
				boneList.push( object );
	
			}
	
			for ( var i = 0; i < object.children.length; i ++ ) {
	
				boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
			}
	
			return boneList;
	
		};
	
		SkeletonHelper.prototype.update = function () {
	
			var vector = new Vector3();
	
			var boneMatrix = new Matrix4();
			var matrixWorldInv = new Matrix4();
	
			return function update() {
	
				var geometry = this.geometry;
				var position = geometry.getAttribute( 'position' );
	
				matrixWorldInv.getInverse( this.root.matrixWorld );
	
				for ( var i = 0, j = 0; i < this.bones.length; i ++ ) {
	
					var bone = this.bones[ i ];
	
					if ( bone.parent && bone.parent.isBone ) {
	
						boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j, vector.x, vector.y, vector.z );
	
						boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j + 1, vector.x, vector.y, vector.z );
	
						j += 2;
	
					}
	
				}
	
				geometry.getAttribute( 'position' ).needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PointLightHelper( light, sphereSize ) {
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
			material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			Mesh.call( this, geometry, material );
	
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			/*
			var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
			var d = light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.scale.set( d, d, d );
	
			}
	
			this.add( this.lightDistance );
			*/
	
		}
	
		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;
	
		PointLightHelper.prototype.dispose = function () {
	
			this.geometry.dispose();
			this.material.dispose();
	
		};
	
		PointLightHelper.prototype.update = function () {
	
			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			/*
			var d = this.light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
	
			}
			*/
	
		};
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 * @author Mugen87 / http://github.com/Mugen87
		 */
	
		function RectAreaLightHelper( light ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			var materialFront = new MeshBasicMaterial( {
				color: light.color,
				fog: false
			} );
	
			var materialBack = new MeshBasicMaterial( {
				color: light.color,
				fog: false,
				wireframe: true
			} );
	
			var geometry = new BufferGeometry();
	
			geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 6 * 3 ), 3 ) );
	
			// shows the "front" of the light, e.g. where light comes from
	
			this.add( new Mesh( geometry, materialFront ) );
	
			// shows the "back" of the light, which does not emit light
	
			this.add( new Mesh( geometry, materialBack ) );
	
			this.update();
	
		}
	
		RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
		RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
	
		RectAreaLightHelper.prototype.dispose = function () {
	
			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();
			this.children[ 1 ].geometry.dispose();
			this.children[ 1 ].material.dispose();
	
		};
	
		RectAreaLightHelper.prototype.update = function () {
	
			var vector1 = new Vector3();
			var vector2 = new Vector3();
	
			return function update() {
	
				var mesh1 = this.children[ 0 ];
				var mesh2 = this.children[ 1 ];
	
				if ( this.light.target ) {
	
					vector1.setFromMatrixPosition( this.light.matrixWorld );
					vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
					var lookVec = vector2.clone().sub( vector1 );
					mesh1.lookAt( lookVec );
					mesh2.lookAt( lookVec );
	
				}
	
				// update materials
	
				mesh1.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
				mesh2.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
				// calculate new dimensions of the helper
	
				var hx = this.light.width * 0.5;
				var hy = this.light.height * 0.5;
	
				// because the buffer attribute is shared over both geometries, we only have to update once
	
				var position = mesh1.geometry.getAttribute( 'position' );
				var array = position.array;
	
				// first face
	
				array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
				array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
				array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;
	
				// second face
	
				array[  9 ] = - hx; array[ 10 ] =   hy; array[ 11 ] = 0;
				array[ 12 ] = - hx; array[ 13 ] = - hy; array[ 14 ] = 0;
				array[ 15 ] =   hx; array[ 16 ] = - hy; array[ 17 ] = 0;
	
				position.needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function HemisphereLightHelper( light, size ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var geometry = new OctahedronBufferGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );
	
			var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );
	
			var position = geometry.getAttribute( 'position' );
			var colors = new Float32Array( position.count * 3 );
	
			geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );
	
			this.add( new Mesh( geometry, material ) );
	
			this.update();
	
		}
	
		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
	
		HemisphereLightHelper.prototype.dispose = function () {
	
			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();
	
		};
	
		HemisphereLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
	
			var color1 = new Color();
			var color2 = new Color();
	
			return function update() {
	
				var mesh = this.children[ 0 ];
	
				var colors = mesh.geometry.getAttribute( 'color' );
	
				color1.copy( this.light.color ).multiplyScalar( this.light.intensity );
				color2.copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
				for ( var i = 0, l = colors.count; i < l; i ++ ) {
	
					var color = ( i < ( l / 2 ) ) ? color1 : color2;
	
					colors.setXYZ( i, color.r, color.g, color.b );
	
				}
	
				mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
	
				colors.needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function GridHelper( size, divisions, color1, color2 ) {
	
			size = size || 10;
			divisions = divisions || 10;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
			var center = divisions / 2;
			var step = size / divisions;
			var halfSize = size / 2;
	
			var vertices = [], colors = [];
	
			for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {
	
				vertices.push( - halfSize, 0, k, halfSize, 0, k );
				vertices.push( k, 0, - halfSize, k, 0, halfSize );
	
				var color = i === center ? color1 : color2;
	
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
	
			}
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		GridHelper.prototype = Object.create( LineSegments.prototype );
		GridHelper.prototype.constructor = GridHelper;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / http://github.com/Mugen87
		 * @author Hectate / http://www.github.com/Hectate
		 */
	
		function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {
	
			radius = radius || 10;
			radials = radials || 16;
			circles = circles || 8;
			divisions = divisions || 64;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
			var vertices = [];
			var colors = [];
	
			var x, z;
			var v, i, j, r, color;
	
			// create the radials
	
			for ( i = 0; i <= radials; i ++ ) {
	
				v = ( i / radials ) * ( Math.PI * 2 );
	
				x = Math.sin( v ) * radius;
				z = Math.cos( v ) * radius;
	
				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );
	
				color = ( i & 1 ) ? color1 : color2;
	
				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );
	
			}
	
			// create the circles
	
			for ( i = 0; i <= circles; i ++ ) {
	
				color = ( i & 1 ) ? color1 : color2;
	
				r = radius - ( radius / circles * i );
	
				for ( j = 0; j < divisions; j ++ ) {
	
					// first vertex
	
					v = ( j / divisions ) * ( Math.PI * 2 );
	
					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;
	
					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );
	
					// second vertex
	
					v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );
	
					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;
	
					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );
	
				}
	
			}
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		PolarGridHelper.prototype = Object.create( LineSegments.prototype );
		PolarGridHelper.prototype.constructor = PolarGridHelper;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function FaceNormalsHelper( object, size, hex, linewidth ) {
	
			// FaceNormalsHelper only supports THREE.Geometry
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xffff00;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry && objGeometry.isGeometry ) {
	
				nNormals = objGeometry.faces.length;
	
			} else {
	
				console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
			this.update();
	
		}
	
		FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
		FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
	
		FaceNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					var normal = face.normal;
	
					v1.copy( vertices[ face.a ] )
						.add( vertices[ face.b ] )
						.add( vertices[ face.c ] )
						.divideScalar( 3 )
						.applyMatrix4( matrixWorld );
	
					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
				position.needsUpdate = true;
	
				return this;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function DirectionalLightHelper( light, size ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			if ( size === undefined ) size = 1;
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [
				- size,   size, 0,
				  size,   size, 0,
				  size, - size, 0,
				- size, - size, 0,
				- size,   size, 0
			], 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.add( new Line( geometry, material ) );
	
			geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
	
			this.add( new Line( geometry, material ));
	
			this.update();
	
		}
	
		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
	
		DirectionalLightHelper.prototype.dispose = function () {
	
			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];
	
			lightPlane.geometry.dispose();
			lightPlane.material.dispose();
			targetLine.geometry.dispose();
			targetLine.material.dispose();
	
		};
	
		DirectionalLightHelper.prototype.update = function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var v3 = new Vector3();
	
			return function update() {
	
				v1.setFromMatrixPosition( this.light.matrixWorld );
				v2.setFromMatrixPosition( this.light.target.matrixWorld );
				v3.subVectors( v2, v1 );
	
				var lightPlane = this.children[ 0 ];
				var targetLine = this.children[ 1 ];
	
				lightPlane.lookAt( v3 );
				lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
				targetLine.lookAt( v3 );
				targetLine.scale.z = v3.length();
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */
	
		function CameraHelper( camera ) {
	
			var geometry = new BufferGeometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );
	
			var vertices = [];
			var colors = [];
	
			var pointMap = {};
	
			// colors
	
			var colorFrustum = new Color( 0xffaa00 );
			var colorCone = new Color( 0xff0000 );
			var colorUp = new Color( 0x00aaff );
			var colorTarget = new Color( 0xffffff );
			var colorCross = new Color( 0x333333 );
	
			// near
	
			addLine( "n1", "n2", colorFrustum );
			addLine( "n2", "n4", colorFrustum );
			addLine( "n4", "n3", colorFrustum );
			addLine( "n3", "n1", colorFrustum );
	
			// far
	
			addLine( "f1", "f2", colorFrustum );
			addLine( "f2", "f4", colorFrustum );
			addLine( "f4", "f3", colorFrustum );
			addLine( "f3", "f1", colorFrustum );
	
			// sides
	
			addLine( "n1", "f1", colorFrustum );
			addLine( "n2", "f2", colorFrustum );
			addLine( "n3", "f3", colorFrustum );
			addLine( "n4", "f4", colorFrustum );
	
			// cone
	
			addLine( "p", "n1", colorCone );
			addLine( "p", "n2", colorCone );
			addLine( "p", "n3", colorCone );
			addLine( "p", "n4", colorCone );
	
			// up
	
			addLine( "u1", "u2", colorUp );
			addLine( "u2", "u3", colorUp );
			addLine( "u3", "u1", colorUp );
	
			// target
	
			addLine( "c", "t", colorTarget );
			addLine( "p", "c", colorCross );
	
			// cross
	
			addLine( "cn1", "cn2", colorCross );
			addLine( "cn3", "cn4", colorCross );
	
			addLine( "cf1", "cf2", colorCross );
			addLine( "cf3", "cf4", colorCross );
	
			function addLine( a, b, color ) {
	
				addPoint( a, color );
				addPoint( b, color );
	
			}
	
			function addPoint( id, color ) {
	
				vertices.push( 0, 0, 0 );
				colors.push( color.r, color.g, color.b );
	
				if ( pointMap[ id ] === undefined ) {
	
					pointMap[ id ] = [];
	
				}
	
				pointMap[ id ].push( ( vertices.length / 3 ) - 1 );
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			LineSegments.call( this, geometry, material );
	
			this.camera = camera;
			if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
	
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.pointMap = pointMap;
	
			this.update();
	
		}
	
		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;
	
		CameraHelper.prototype.update = function () {
	
			var geometry, pointMap;
	
			var vector = new Vector3();
			var camera = new Camera();
	
			function setPoint( point, x, y, z ) {
	
				vector.set( x, y, z ).unproject( camera );
	
				var points = pointMap[ point ];
	
				if ( points !== undefined ) {
	
					var position = geometry.getAttribute( 'position' );
	
					for ( var i = 0, l = points.length; i < l; i ++ ) {
	
						position.setXYZ( points[ i ], vector.x, vector.y, vector.z );
	
					}
	
				}
	
			}
	
			return function update() {
	
				geometry = this.geometry;
				pointMap = this.pointMap;
	
				var w = 1, h = 1;
	
				// we need just camera projection matrix
				// world matrix must be identity
	
				camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
				// center / target
	
				setPoint( "c", 0, 0, - 1 );
				setPoint( "t", 0, 0,  1 );
	
				// near
	
				setPoint( "n1", - w, - h, - 1 );
				setPoint( "n2",   w, - h, - 1 );
				setPoint( "n3", - w,   h, - 1 );
				setPoint( "n4",   w,   h, - 1 );
	
				// far
	
				setPoint( "f1", - w, - h, 1 );
				setPoint( "f2",   w, - h, 1 );
				setPoint( "f3", - w,   h, 1 );
				setPoint( "f4",   w,   h, 1 );
	
				// up
	
				setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
				setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
				setPoint( "u3",         0, h * 2,   - 1 );
	
				// cross
	
				setPoint( "cf1", - w,   0, 1 );
				setPoint( "cf2",   w,   0, 1 );
				setPoint( "cf3",   0, - h, 1 );
				setPoint( "cf4",   0,   h, 1 );
	
				setPoint( "cn1", - w,   0, - 1 );
				setPoint( "cn2",   w,   0, - 1 );
				setPoint( "cn3",   0, - h, - 1 );
				setPoint( "cn4",   0,   h, - 1 );
	
				geometry.getAttribute( 'position' ).needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BoxHelper( object, color ) {
	
			if ( color === undefined ) color = 0xffff00;
	
			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );
	
			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	
			if ( object !== undefined ) {
	
				this.update( object );
	
			}
	
		}
	
		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;
	
		BoxHelper.prototype.update = ( function () {
	
			var box = new Box3();
	
			return function update( object ) {
	
				if ( object && object.isBox3 ) {
	
					box.copy( object );
	
				} else {
	
					box.setFromObject( object );
	
				}
	
				if ( box.isEmpty() ) return;
	
				var min = box.min;
				var max = box.max;
	
				/*
				  5____4
				1/___0/|
				| 6__|_7
				2/___3/
	
				0: max.x, max.y, max.z
				1: min.x, max.y, max.z
				2: min.x, min.y, max.z
				3: max.x, min.y, max.z
				4: max.x, max.y, min.z
				5: min.x, max.y, min.z
				6: min.x, min.y, min.z
				7: max.x, min.y, min.z
				*/
	
				var position = this.geometry.attributes.position;
				var array = position.array;
	
				array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
				array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
				array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
				array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
				array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
				array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
				array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
				array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
				position.needsUpdate = true;
	
				this.geometry.computeBoundingSphere();
	
			};
	
		} )();
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */
	
		var lineGeometry;
		var coneGeometry;
	
		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			if ( lineGeometry === undefined ) {
	
				lineGeometry = new BufferGeometry();
				lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
	
				coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
				coneGeometry.translate( 0, - 0.5, 0 );
	
			}
	
			this.position.copy( origin );
	
			this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;
	
		ArrowHelper.prototype.setDirection = ( function () {
	
			var axis = new Vector3();
			var radians;
	
			return function setDirection( dir ) {
	
				// dir is assumed to be normalized
	
				if ( dir.y > 0.99999 ) {
	
					this.quaternion.set( 0, 0, 0, 1 );
	
				} else if ( dir.y < - 0.99999 ) {
	
					this.quaternion.set( 1, 0, 0, 0 );
	
				} else {
	
					axis.set( dir.z, 0, - dir.x ).normalize();
	
					radians = Math.acos( dir.y );
	
					this.quaternion.setFromAxisAngle( axis, radians );
	
				}
	
			};
	
		}() );
	
		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
			this.line.updateMatrix();
	
			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();
	
		};
	
		ArrowHelper.prototype.setColor = function ( color ) {
	
			this.line.material.color.copy( color );
			this.cone.material.color.copy( color );
	
		};
	
		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AxisHelper( size ) {
	
			size = size || 1;
	
			var vertices = [
				0, 0, 0,  size, 0, 0,
				0, 0, 0,  0, size, 0,
				0, 0, 0,  0, 0, size
			];
	
			var colors = [
				1, 0, 0,  1, 0.6, 0,
				0, 1, 0,  0.6, 1, 0,
				0, 0, 1,  0, 0.6, 1
			];
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		AxisHelper.prototype = Object.create( LineSegments.prototype );
		AxisHelper.prototype.constructor = AxisHelper;
	
		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */
	
	
		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/
	
		function CubicPoly() {
	
			var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
	
			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			function init( x0, x1, t0, t1 ) {
	
				c0 = x0;
				c1 = t0;
				c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
			}
	
			return {
	
				initCatmullRom: function ( x0, x1, x2, x3, tension ) {
	
					init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
				},
	
				initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
					// compute tangents when parameterized in [t1,t2]
					var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
					var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
					// rescale tangents for parametrization in [0,1]
					t1 *= dt1;
					t2 *= dt1;
	
					init( x1, x2, t1, t2 );
	
				},
	
				calc: function ( t ) {
	
					var t2 = t * t;
					var t3 = t2 * t;
					return c0 + c1 * t + c2 * t2 + c3 * t3;
	
				}
	
			};
	
		}
	
		//
	
		var tmp = new Vector3();
		var px = new CubicPoly();
		var py = new CubicPoly();
		var pz = new CubicPoly();
	
		function CatmullRomCurve3( p /* array of Vector3 */ ) {
	
			this.points = p || [];
			this.closed = false;
	
		}
	
		CatmullRomCurve3.prototype = Object.create( Curve.prototype );
		CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
	
		CatmullRomCurve3.prototype.getPoint = function ( t ) {
	
			var points = this.points;
			var l = points.length;
	
			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );
	
			var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			if ( this.closed ) {
	
				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
			} else if ( weight === 0 && intPoint === l - 1 ) {
	
				intPoint = l - 2;
				weight = 1;
	
			}
	
			var p0, p1, p2, p3; // 4 points
	
			if ( this.closed || intPoint > 0 ) {
	
				p0 = points[ ( intPoint - 1 ) % l ];
	
			} else {
	
				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;
	
			}
	
			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];
	
			if ( this.closed || intPoint + 2 < l ) {
	
				p3 = points[ ( intPoint + 2 ) % l ];
	
			} else {
	
				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;
	
			}
	
			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;
	
				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
			} else if ( this.type === 'catmullrom' ) {
	
				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
			}
	
			return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );
	
		};
	
		function CubicBezierCurve3( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		}
	
		CubicBezierCurve3.prototype = Object.create( Curve.prototype );
		CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
	
		CubicBezierCurve3.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
			return new Vector3(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);
	
		};
	
		function QuadraticBezierCurve3( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
	
		QuadraticBezierCurve3.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
			return new Vector3(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);
	
		};
	
		function LineCurve3( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		LineCurve3.prototype = Object.create( Curve.prototype );
		LineCurve3.prototype.constructor = LineCurve3;
	
		LineCurve3.prototype.getPoint = function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var vector = new Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		};
	
		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
		}
	
		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		var SceneUtils = {
	
			createMultiMaterialObject: function ( geometry, materials ) {
	
				var group = new Group();
	
				for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
					group.add( new Mesh( geometry, materials[ i ] ) );
	
				}
	
				return group;
	
			},
	
			detach: function ( child, parent, scene ) {
	
				child.applyMatrix( parent.matrixWorld );
				parent.remove( child );
				scene.add( child );
	
			},
	
			attach: function ( child, scene, parent ) {
	
				var matrixWorldInverse = new Matrix4();
				matrixWorldInverse.getInverse( parent.matrixWorld );
				child.applyMatrix( matrixWorldInverse );
	
				scene.remove( child );
				parent.add( child );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Face4( a, b, c, d, normal, color, materialIndex ) {
	
			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );
	
		}
	
		var LineStrip = 0;
	
		var LinePieces = 1;
	
		function MeshFaceMaterial( materials ) {
	
			console.warn( 'THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.' );
			return new MultiMaterial( materials );
	
		}
	
		function PointCloud( geometry, material ) {
	
			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );
	
		}
	
		function Particle( material ) {
	
			console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
			return new Sprite( material );
	
		}
	
		function ParticleSystem( geometry, material ) {
	
			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );
	
		}
	
		function PointCloudMaterial( parameters ) {
	
			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function ParticleBasicMaterial( parameters ) {
	
			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function ParticleSystemMaterial( parameters ) {
	
			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function Vertex( x, y, z ) {
	
			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );
	
		}
	
		//
	
		function DynamicBufferAttribute( array, itemSize ) {
	
			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
			return new BufferAttribute( array, itemSize ).setDynamic( true );
	
		}
	
		function Int8Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
			return new Int8BufferAttribute( array, itemSize );
	
		}
	
		function Uint8Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
			return new Uint8BufferAttribute( array, itemSize );
	
		}
	
		function Uint8ClampedAttribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
			return new Uint8ClampedBufferAttribute( array, itemSize );
	
		}
	
		function Int16Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
			return new Int16BufferAttribute( array, itemSize );
	
		}
	
		function Uint16Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
			return new Uint16BufferAttribute( array, itemSize );
	
		}
	
		function Int32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
			return new Int32BufferAttribute( array, itemSize );
	
		}
	
		function Uint32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
			return new Uint32BufferAttribute( array, itemSize );
	
		}
	
		function Float32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
			return new Float32BufferAttribute( array, itemSize );
	
		}
	
		function Float64Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
			return new Float64BufferAttribute( array, itemSize );
	
		}
	
		//
	
		Curve.create = function ( construct, getPoint ) {
	
			console.log( 'THREE.Curve.create() has been deprecated' );
	
			construct.prototype = Object.create( Curve.prototype );
			construct.prototype.constructor = construct;
			construct.prototype.getPoint = getPoint;
	
			return construct;
	
		};
	
		//
	
		function ClosedSplineCurve3( points ) {
	
			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;
	
		}
	
		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
		//
	
		function SplineCurve3( points ) {
	
			console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
	
		}
	
		SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
		//
	
		function Spline( points ) {
	
			console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
	
		}
	
		Spline.prototype = Object.create( CatmullRomCurve3.prototype );
	
		Object.assign( Spline.prototype, {
	
			initFromArray: function ( a ) {
	
				console.error( 'THREE.Spline: .initFromArray() has been removed.' );
	
			},
			getControlPointsArray: function ( optionalTarget ) {
	
				console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );
	
			},
			reparametrizeByArcLength: function ( samplingCoef ) {
	
				console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );
	
			}
	
		} );
	
		//
		function BoundingBoxHelper( object, color ) {
	
			console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
			return new BoxHelper( object, color );
	
		}
	
		function EdgesHelper( object, hex ) {
	
			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
		}
	
		GridHelper.prototype.setColors = function () {
	
			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
	
		};
	
		function WireframeHelper( object, hex ) {
	
			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
		}
	
		//
	
		function XHRLoader( manager ) {
	
			console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
			return new FileLoader( manager );
	
		}
	
		function BinaryTextureLoader( manager ) {
	
			console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
			return new DataTextureLoader( manager );
	
		}
	
		//
	
		Object.assign( Box2.prototype, {
	
			center: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
	
			},
			empty: function () {
	
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
	
			},
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			size: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
	
			}
		} );
	
		Object.assign( Box3.prototype, {
	
			center: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
	
			},
			empty: function () {
	
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
	
			},
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			isIntersectionSphere: function ( sphere ) {
	
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
	
			},
			size: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
	
			}
		} );
	
		Line3.prototype.center = function ( optionalTarget ) {
	
			console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );
	
		};
	
		_Math.random16 = function () {
	
			console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
	
		};
	
		Object.assign( Matrix3.prototype, {
	
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );
	
			},
			multiplyVector3: function ( vector ) {
	
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
	
			},
			multiplyVector3Array: function ( a ) {
	
				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
	
			},
			applyToBuffer: function( buffer, offset, length ) {
	
				console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );
	
			},
			applyToVector3Array: function( array, offset, length ) {
	
				console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );
	
			}
	
		} );
	
		Object.assign( Matrix4.prototype, {
	
			extractPosition: function ( m ) {
	
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
	
			},
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );
	
			},
			getPosition: function () {
	
				var v1;
	
				return function getPosition() {
	
					if ( v1 === undefined ) v1 = new Vector3();
					console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
					return v1.setFromMatrixColumn( this, 3 );
	
				};
	
			}(),
			setRotationFromQuaternion: function ( q ) {
	
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
	
			},
			multiplyVector3: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			multiplyVector4: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			multiplyVector3Array: function ( a ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
	
			},
			rotateAxis: function ( v ) {
	
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
	
			},
			crossVector: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			translate: function () {
	
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
	
			},
			rotateX: function () {
	
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	
			},
			rotateY: function () {
	
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	
			},
			rotateZ: function () {
	
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	
			},
			rotateByAxis: function () {
	
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	
			},
			applyToBuffer: function( buffer, offset, length ) {
	
				console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );
	
			},
			applyToVector3Array: function( array, offset, length ) {
	
				console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );
	
			},
			makeFrustum: function( left, right, bottom, top, near, far ) {
	
				console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
				return this.makePerspective( left, right, top, bottom, near, far );
	
			}
	
		} );
	
		Plane.prototype.isIntersectionLine = function ( line ) {
	
			console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine( line );
	
		};
	
		Quaternion.prototype.multiplyVector3 = function ( vector ) {
	
			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		};
	
		Object.assign( Ray.prototype, {
	
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			isIntersectionPlane: function ( plane ) {
	
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
	
			},
			isIntersectionSphere: function ( sphere ) {
	
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
	
			}
	
		} );
	
		Object.assign( Shape.prototype, {
	
			extrude: function ( options ) {
	
				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );
	
			},
			makeGeometry: function ( options ) {
	
				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );
	
			}
	
		} );
	
		Object.assign( Vector2.prototype, {
	
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		Object.assign( Vector3.prototype, {
	
			setEulerFromRotationMatrix: function () {
	
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	
			},
			setEulerFromQuaternion: function () {
	
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	
			},
			getPositionFromMatrix: function ( m ) {
	
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
	
			},
			getScaleFromMatrix: function ( m ) {
	
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
	
			},
			getColumnFromMatrix: function ( index, matrix ) {
	
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );
	
			},
			applyProjection: function ( m ) {
	
				console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
				return this.applyMatrix4( m );
	
			},
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		Object.assign( Vector4.prototype, {
	
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		//
	
		Geometry.prototype.computeTangents = function () {
	
			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		};
	
		Object.assign( Object3D.prototype, {
	
			getChildByName: function ( name ) {
	
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
	
			},
			renderDepth: function () {
	
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
	
			},
			translate: function ( distance, axis ) {
	
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
	
			}
	
		} );
	
		Object.defineProperties( Object3D.prototype, {
	
			eulerOrder: {
				get: function () {
	
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;
	
				}
			},
			useQuaternion: {
				get: function () {
	
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
				},
				set: function () {
	
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
				}
			}
	
		} );
	
		Object.defineProperties( LOD.prototype, {
	
			objects: {
				get: function () {
	
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
	
				}
			}
	
		} );
	
		//
	
		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
	
			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );
	
			if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
			this.setFocalLength( focalLength );
	
		};
	
		//
	
		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function () {
	
					console.warn( 'THREE.Light: .onlyShadow has been removed.' );
	
				}
			},
			shadowCameraFov: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;
	
				}
			},
			shadowCameraLeft: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;
	
				}
			},
			shadowCameraRight: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;
	
				}
			},
			shadowCameraTop: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;
	
				}
			},
			shadowCameraBottom: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;
	
				}
			},
			shadowCameraNear: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;
	
				}
			},
			shadowCameraFar: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;
	
				}
			},
			shadowCameraVisible: {
				set: function () {
	
					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
	
				}
			},
			shadowBias: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;
	
				}
			},
			shadowDarkness: {
				set: function () {
	
					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
	
				}
			},
			shadowMapWidth: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;
	
				}
			},
			shadowMapHeight: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;
	
				}
			}
		} );
	
		//
	
		Object.defineProperties( BufferAttribute.prototype, {
	
			length: {
				get: function () {
	
					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
					return this.array.length;
	
				}
			}
	
		} );
	
		Object.assign( BufferGeometry.prototype, {
	
			addIndex: function ( index ) {
	
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
	
			},
			addDrawCall: function ( start, count, indexOffset ) {
	
				if ( indexOffset !== undefined ) {
	
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
	
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
	
			},
			clearDrawCalls: function () {
	
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
	
			},
			computeTangents: function () {
	
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
	
			},
			computeOffsets: function () {
	
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
	
			}
	
		} );
	
		Object.defineProperties( BufferGeometry.prototype, {
	
			drawcalls: {
				get: function () {
	
					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;
	
				}
			},
			offsets: {
				get: function () {
	
					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( Uniform.prototype, {
	
			dynamic: {
				set: function () {
	
					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
	
				}
			},
			onUpdate: {
				value: function () {
	
					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( Material.prototype, {
	
			wrapAround: {
				get: function () {
	
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
	
				},
				set: function () {
	
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
	
				}
			},
			wrapRGB: {
				get: function () {
	
					console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
					return new Color();
	
				}
			}
	
		} );
	
		Object.defineProperties( MeshPhongMaterial.prototype, {
	
			metal: {
				get: function () {
	
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;
	
				},
				set: function () {
	
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
	
				}
			}
	
		} );
	
		Object.defineProperties( ShaderMaterial.prototype, {
	
			derivatives: {
				get: function () {
	
					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;
	
				}
			}
	
		} );
	
		//
	
		Object.assign( WebGLRenderer.prototype, {
	
			supportsFloatTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
	
			},
			supportsHalfFloatTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
	
			},
			supportsStandardDerivatives: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
	
			},
			supportsCompressedTextureS3TC: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			},
			supportsCompressedTexturePVRTC: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			},
			supportsBlendMinMax: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
	
			},
			supportsVertexTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
				return this.capabilities.vertexTextures;
	
			},
			supportsInstancedArrays: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
	
			},
			enableScissorTest: function ( boolean ) {
	
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
	
			},
			initMaterial: function () {
	
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	
			},
			addPrePlugin: function () {
	
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	
			},
			addPostPlugin: function () {
	
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	
			},
			updateShadowMap: function () {
	
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	
			}
	
		} );
	
		Object.defineProperties( WebGLRenderer.prototype, {
	
			shadowMapEnabled: {
				get: function () {
	
					return this.shadowMap.enabled;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;
	
				}
			},
			shadowMapType: {
				get: function () {
	
					return this.shadowMap.type;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;
	
				}
			},
			shadowMapCullFace: {
				get: function () {
	
					return this.shadowMap.cullFace;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					this.shadowMap.cullFace = value;
	
				}
			}
		} );
	
		Object.defineProperties( WebGLShadowMap.prototype, {
	
			cullFace: {
				get: function () {
	
					return this.renderReverseSided ? CullFaceFront : CullFaceBack;
	
				},
				set: function ( cullFace ) {
	
					var value = ( cullFace !== CullFaceBack );
					console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
					this.renderReverseSided = value;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( WebGLRenderTarget.prototype, {
	
			wrapS: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;
	
				}
			},
			wrapT: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;
	
				}
			},
			magFilter: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;
	
				}
			},
			minFilter: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;
	
				}
			},
			anisotropy: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;
	
				}
			},
			offset: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;
	
				}
			},
			repeat: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;
	
				}
			},
			format: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;
	
				}
			},
			type: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;
	
				}
			},
			generateMipmaps: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;
	
				}
			}
	
		} );
	
		//
	
		Audio.prototype.load = function ( file ) {
	
			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			var scope = this;
			var audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {
	
				scope.setBuffer( buffer );
	
			} );
			return this;
	
		};
	
		AudioAnalyser.prototype.getData = function () {
	
			console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
			return this.getFrequencyData();
	
		};
	
		//
	
		var GeometryUtils = {
	
			merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
				var matrix;
	
				if ( geometry2.isMesh ) {
	
					geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;
	
				}
	
				geometry1.merge( geometry2, matrix, materialIndexOffset );
	
			},
	
			center: function ( geometry ) {
	
				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();
	
			}
	
		};
	
		var ImageUtils = {
	
			crossOrigin: undefined,
	
			loadTexture: function ( url, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
				var loader = new TextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( url, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
				var loader = new CubeTextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( urls, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadCompressedTexture: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
			},
	
			loadCompressedTextureCube: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
			}
	
		};
	
		//
	
		function Projector() {
	
			console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
			this.projectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
				vector.project( camera );
	
			};
	
			this.unprojectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
				vector.unproject( camera );
	
			};
	
			this.pickingRay = function () {
	
				console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
			};
	
		}
	
		//
	
		function CanvasRenderer() {
	
			console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
			this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			this.clear = function () {};
			this.render = function () {};
			this.setClearColor = function () {};
			this.setSize = function () {};
	
		}
	
		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderer = WebGLRenderer;
		exports.ShaderLib = ShaderLib;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.FogExp2 = FogExp2;
		exports.Fog = Fog;
		exports.Scene = Scene;
		exports.LensFlare = LensFlare;
		exports.Sprite = Sprite;
		exports.LOD = LOD;
		exports.SkinnedMesh = SkinnedMesh;
		exports.Skeleton = Skeleton;
		exports.Bone = Bone;
		exports.Mesh = Mesh;
		exports.LineSegments = LineSegments;
		exports.Line = Line;
		exports.Points = Points;
		exports.Group = Group;
		exports.VideoTexture = VideoTexture;
		exports.DataTexture = DataTexture;
		exports.CompressedTexture = CompressedTexture;
		exports.CubeTexture = CubeTexture;
		exports.CanvasTexture = CanvasTexture;
		exports.DepthTexture = DepthTexture;
		exports.Texture = Texture;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.DataTextureLoader = DataTextureLoader;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.TextureLoader = TextureLoader;
		exports.ObjectLoader = ObjectLoader;
		exports.MaterialLoader = MaterialLoader;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.LoadingManager = LoadingManager;
		exports.JSONLoader = JSONLoader;
		exports.ImageLoader = ImageLoader;
		exports.FontLoader = FontLoader;
		exports.FileLoader = FileLoader;
		exports.Loader = Loader;
		exports.Cache = Cache;
		exports.AudioLoader = AudioLoader;
		exports.SpotLightShadow = SpotLightShadow;
		exports.SpotLight = SpotLight;
		exports.PointLight = PointLight;
		exports.RectAreaLight = RectAreaLight;
		exports.HemisphereLight = HemisphereLight;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DirectionalLight = DirectionalLight;
		exports.AmbientLight = AmbientLight;
		exports.LightShadow = LightShadow;
		exports.Light = Light;
		exports.StereoCamera = StereoCamera;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.OrthographicCamera = OrthographicCamera;
		exports.CubeCamera = CubeCamera;
		exports.Camera = Camera;
		exports.AudioListener = AudioListener;
		exports.PositionalAudio = PositionalAudio;
		exports.AudioContext = AudioContext;
		exports.AudioAnalyser = AudioAnalyser;
		exports.Audio = Audio;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.PropertyMixer = PropertyMixer;
		exports.PropertyBinding = PropertyBinding;
		exports.KeyframeTrack = KeyframeTrack;
		exports.AnimationUtils = AnimationUtils;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationClip = AnimationClip;
		exports.Uniform = Uniform;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.BufferGeometry = BufferGeometry;
		exports.GeometryIdCount = GeometryIdCount;
		exports.Geometry = Geometry;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.Face3 = Face3;
		exports.Object3D = Object3D;
		exports.Raycaster = Raycaster;
		exports.Layers = Layers;
		exports.EventDispatcher = EventDispatcher;
		exports.Clock = Clock;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.LinearInterpolant = LinearInterpolant;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.CubicInterpolant = CubicInterpolant;
		exports.Interpolant = Interpolant;
		exports.Triangle = Triangle;
		exports.Math = _Math;
		exports.Spherical = Spherical;
		exports.Cylindrical = Cylindrical;
		exports.Plane = Plane;
		exports.Frustum = Frustum;
		exports.Sphere = Sphere;
		exports.Ray = Ray;
		exports.Matrix4 = Matrix4;
		exports.Matrix3 = Matrix3;
		exports.Box3 = Box3;
		exports.Box2 = Box2;
		exports.Line3 = Line3;
		exports.Euler = Euler;
		exports.Vector4 = Vector4;
		exports.Vector3 = Vector3;
		exports.Vector2 = Vector2;
		exports.Quaternion = Quaternion;
		exports.Color = Color;
		exports.MorphBlendMesh = MorphBlendMesh;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.VertexNormalsHelper = VertexNormalsHelper;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SkeletonHelper = SkeletonHelper;
		exports.PointLightHelper = PointLightHelper;
		exports.RectAreaLightHelper = RectAreaLightHelper;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.GridHelper = GridHelper;
		exports.PolarGridHelper = PolarGridHelper;
		exports.FaceNormalsHelper = FaceNormalsHelper;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.CameraHelper = CameraHelper;
		exports.BoxHelper = BoxHelper;
		exports.ArrowHelper = ArrowHelper;
		exports.AxisHelper = AxisHelper;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.LineCurve3 = LineCurve3;
		exports.ArcCurve = ArcCurve;
		exports.EllipseCurve = EllipseCurve;
		exports.SplineCurve = SplineCurve;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.LineCurve = LineCurve;
		exports.Shape = Shape;
		exports.Path = Path;
		exports.ShapePath = ShapePath;
		exports.Font = Font;
		exports.CurvePath = CurvePath;
		exports.Curve = Curve;
		exports.ShapeUtils = ShapeUtils;
		exports.SceneUtils = SceneUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.RingGeometry = RingGeometry;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ShapeBufferGeometry = ShapeBufferGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.EdgesGeometry = EdgesGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.ShadowMaterial = ShadowMaterial;
		exports.SpriteMaterial = SpriteMaterial;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.ShaderMaterial = ShaderMaterial;
		exports.PointsMaterial = PointsMaterial;
		exports.MultiMaterial = MultiMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshToonMaterial = MeshToonMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.Material = Material;
		exports.Float64BufferAttribute = Float64BufferAttribute;
		exports.Float32BufferAttribute = Float32BufferAttribute;
		exports.Uint32BufferAttribute = Uint32BufferAttribute;
		exports.Int32BufferAttribute = Int32BufferAttribute;
		exports.Uint16BufferAttribute = Uint16BufferAttribute;
		exports.Int16BufferAttribute = Int16BufferAttribute;
		exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
		exports.Uint8BufferAttribute = Uint8BufferAttribute;
		exports.Int8BufferAttribute = Int8BufferAttribute;
		exports.BufferAttribute = BufferAttribute;
		exports.REVISION = REVISION;
		exports.MOUSE = MOUSE;
		exports.CullFaceNone = CullFaceNone;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.BasicShadowMap = BasicShadowMap;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.FrontSide = FrontSide;
		exports.BackSide = BackSide;
		exports.DoubleSide = DoubleSide;
		exports.FlatShading = FlatShading;
		exports.SmoothShading = SmoothShading;
		exports.NoColors = NoColors;
		exports.FaceColors = FaceColors;
		exports.VertexColors = VertexColors;
		exports.NoBlending = NoBlending;
		exports.NormalBlending = NormalBlending;
		exports.AdditiveBlending = AdditiveBlending;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.MultiplyBlending = MultiplyBlending;
		exports.CustomBlending = CustomBlending;
		exports.AddEquation = AddEquation;
		exports.SubtractEquation = SubtractEquation;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.MinEquation = MinEquation;
		exports.MaxEquation = MaxEquation;
		exports.ZeroFactor = ZeroFactor;
		exports.OneFactor = OneFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.NeverDepth = NeverDepth;
		exports.AlwaysDepth = AlwaysDepth;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.EqualDepth = EqualDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterDepth = GreaterDepth;
		exports.NotEqualDepth = NotEqualDepth;
		exports.MultiplyOperation = MultiplyOperation;
		exports.MixOperation = MixOperation;
		exports.AddOperation = AddOperation;
		exports.NoToneMapping = NoToneMapping;
		exports.LinearToneMapping = LinearToneMapping;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.CineonToneMapping = CineonToneMapping;
		exports.UVMapping = UVMapping;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.LinearFilter = LinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.UnsignedByteType = UnsignedByteType;
		exports.ByteType = ByteType;
		exports.ShortType = ShortType;
		exports.UnsignedShortType = UnsignedShortType;
		exports.IntType = IntType;
		exports.UnsignedIntType = UnsignedIntType;
		exports.FloatType = FloatType;
		exports.HalfFloatType = HalfFloatType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.AlphaFormat = AlphaFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBAFormat = RGBAFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.RGBEFormat = RGBEFormat;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.LoopOnce = LoopOnce;
		exports.LoopRepeat = LoopRepeat;
		exports.LoopPingPong = LoopPingPong;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.LinearEncoding = LinearEncoding;
		exports.sRGBEncoding = sRGBEncoding;
		exports.GammaEncoding = GammaEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBDEncoding = RGBDEncoding;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.CubeGeometry = BoxGeometry;
		exports.Face4 = Face4;
		exports.LineStrip = LineStrip;
		exports.LinePieces = LinePieces;
		exports.MeshFaceMaterial = MeshFaceMaterial;
		exports.PointCloud = PointCloud;
		exports.Particle = Particle;
		exports.ParticleSystem = ParticleSystem;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Vertex = Vertex;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.Int8Attribute = Int8Attribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Int16Attribute = Int16Attribute;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Float32Attribute = Float32Attribute;
		exports.Float64Attribute = Float64Attribute;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.SplineCurve3 = SplineCurve3;
		exports.Spline = Spline;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.EdgesHelper = EdgesHelper;
		exports.WireframeHelper = WireframeHelper;
		exports.XHRLoader = XHRLoader;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.GeometryUtils = GeometryUtils;
		exports.ImageUtils = ImageUtils;
		exports.Projector = Projector;
		exports.CanvasRenderer = CanvasRenderer;
	
		Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.proj4 = factory());
	}(this, (function () { 'use strict';
	
		var globals = function(defs) {
		  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
		  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
		  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
	
		  defs.WGS84 = defs['EPSG:4326'];
		  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
		  defs.GOOGLE = defs['EPSG:3857'];
		  defs['EPSG:900913'] = defs['EPSG:3857'];
		  defs['EPSG:102113'] = defs['EPSG:3857'];
		};
	
		var PJD_3PARAM = 1;
		var PJD_7PARAM = 2;
		var PJD_WGS84 = 4; // WGS84 or equivalent
		var PJD_NODATUM = 5; // WGS84 or equivalent
		var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
		var HALF_PI = Math.PI/2;
		// ellipoid pj_set_ell.c
		var SIXTH = 0.1666666666666666667;
		/* 1/6 */
		var RA4 = 0.04722222222222222222;
		/* 17/360 */
		var RA6 = 0.02215608465608465608;
		var EPSLN = (typeof Number.EPSILON === 'undefined') ? 1.0e-10 : Number.EPSILON;
		var D2R = 0.01745329251994329577;
		var R2D = 57.29577951308232088;
		var FORTPI = Math.PI/4;
		var TWO_PI = Math.PI * 2;
		// SPI is slightly greater than Math.PI, so values that exceed the -180..180
		// degree range by a tiny amount don't get wrapped. This prevents points that
		// have drifted from their original location along the 180th meridian (due to
		// floating point error) from changing their sign.
		var SPI = 3.14159265359;
	
		var exports$1 = {};
		exports$1.greenwich = 0.0; //"0dE",
		exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
		exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
		exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
		exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
		exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
		exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
		exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
		exports$1.ferro = -17.666666666667; //"17d40'W",
		exports$1.brussels = 4.367975; //"4d22'4.71\"E",
		exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
		exports$1.athens = 23.7163375; //"23d42'58.815\"E",
		exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"
	
		var units = {
		  ft: {to_meter: 0.3048},
		  'us-ft': {to_meter: 1200 / 3937}
		};
	
		var ignoredChar = /[\s_\-\/\(\)]/g;
		function match(obj, key) {
		  if (obj[key]) {
		    return obj[key];
		  }
		  var keys = Object.keys(obj);
		  var lkey = key.toLowerCase().replace(ignoredChar, '');
		  var i = -1;
		  var testkey, processedKey;
		  while (++i < keys.length) {
		    testkey = keys[i];
		    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
		    if (processedKey === lkey) {
		      return obj[testkey];
		    }
		  }
		}
	
		var parseProj = function(defData) {
		  var self = {};
		  var paramObj = defData.split('+').map(function(v) {
		    return v.trim();
		  }).filter(function(a) {
		    return a;
		  }).reduce(function(p, a) {
		    var split = a.split('=');
		    split.push(true);
		    p[split[0].toLowerCase()] = split[1];
		    return p;
		  }, {});
		  var paramName, paramVal, paramOutname;
		  var params = {
		    proj: 'projName',
		    datum: 'datumCode',
		    rf: function(v) {
		      self.rf = parseFloat(v);
		    },
		    lat_0: function(v) {
		      self.lat0 = v * D2R;
		    },
		    lat_1: function(v) {
		      self.lat1 = v * D2R;
		    },
		    lat_2: function(v) {
		      self.lat2 = v * D2R;
		    },
		    lat_ts: function(v) {
		      self.lat_ts = v * D2R;
		    },
		    lon_0: function(v) {
		      self.long0 = v * D2R;
		    },
		    lon_1: function(v) {
		      self.long1 = v * D2R;
		    },
		    lon_2: function(v) {
		      self.long2 = v * D2R;
		    },
		    alpha: function(v) {
		      self.alpha = parseFloat(v) * D2R;
		    },
		    lonc: function(v) {
		      self.longc = v * D2R;
		    },
		    x_0: function(v) {
		      self.x0 = parseFloat(v);
		    },
		    y_0: function(v) {
		      self.y0 = parseFloat(v);
		    },
		    k_0: function(v) {
		      self.k0 = parseFloat(v);
		    },
		    k: function(v) {
		      self.k0 = parseFloat(v);
		    },
		    a: function(v) {
		      self.a = parseFloat(v);
		    },
		    b: function(v) {
		      self.b = parseFloat(v);
		    },
		    r_a: function() {
		      self.R_A = true;
		    },
		    zone: function(v) {
		      self.zone = parseInt(v, 10);
		    },
		    south: function() {
		      self.utmSouth = true;
		    },
		    towgs84: function(v) {
		      self.datum_params = v.split(",").map(function(a) {
		        return parseFloat(a);
		      });
		    },
		    to_meter: function(v) {
		      self.to_meter = parseFloat(v);
		    },
		    units: function(v) {
		      self.units = v;
		      var unit = match(units, v);
		      if (unit) {
		        self.to_meter = unit.to_meter;
		      }
		    },
		    from_greenwich: function(v) {
		      self.from_greenwich = v * D2R;
		    },
		    pm: function(v) {
		      var pm = match(exports$1, v);
		      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
		    },
		    nadgrids: function(v) {
		      if (v === '@null') {
		        self.datumCode = 'none';
		      }
		      else {
		        self.nadgrids = v;
		      }
		    },
		    axis: function(v) {
		      var legalAxis = "ewnsud";
		      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
		        self.axis = v;
		      }
		    }
		  };
		  for (paramName in paramObj) {
		    paramVal = paramObj[paramName];
		    if (paramName in params) {
		      paramOutname = params[paramName];
		      if (typeof paramOutname === 'function') {
		        paramOutname(paramVal);
		      }
		      else {
		        self[paramOutname] = paramVal;
		      }
		    }
		    else {
		      self[paramName] = paramVal;
		    }
		  }
		  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
		    self.datumCode = self.datumCode.toLowerCase();
		  }
		  return self;
		};
	
		var NEUTRAL = 1;
		var KEYWORD = 2;
		var NUMBER = 3;
		var QUOTED = 4;
		var AFTERQUOTE = 5;
		var ENDED = -1;
		var whitespace = /\s/;
		var latin = /[A-Za-z]/;
		var keyword = /[A-Za-z84]/;
		var endThings = /[,\]]/;
		var digets = /[\d\.E\-\+]/;
		// const ignoredChar = /[\s_\-\/\(\)]/g;
		function Parser(text) {
		  if (typeof text !== 'string') {
		    throw new Error('not a string');
		  }
		  this.text = text.trim();
		  this.level = 0;
		  this.place = 0;
		  this.root = null;
		  this.stack = [];
		  this.currentObject = null;
		  this.state = NEUTRAL;
		}
		Parser.prototype.readCharicter = function() {
		  var char = this.text[this.place++];
		  if (this.state !== QUOTED) {
		    while (whitespace.test(char)) {
		      if (this.place >= this.text.length) {
		        return;
		      }
		      char = this.text[this.place++];
		    }
		  }
		  switch (this.state) {
		    case NEUTRAL:
		      return this.neutral(char);
		    case KEYWORD:
		      return this.keyword(char)
		    case QUOTED:
		      return this.quoted(char);
		    case AFTERQUOTE:
		      return this.afterquote(char);
		    case NUMBER:
		      return this.number(char);
		    case ENDED:
		      return;
		  }
		};
		Parser.prototype.afterquote = function(char) {
		  if (char === '"') {
		    this.word += '"';
		    this.state = QUOTED;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.word = this.word.trim();
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
		};
		Parser.prototype.afterItem = function(char) {
		  if (char === ',') {
		    if (this.word !== null) {
		      this.currentObject.push(this.word);
		    }
		    this.word = null;
		    this.state = NEUTRAL;
		    return;
		  }
		  if (char === ']') {
		    this.level--;
		    if (this.word !== null) {
		      this.currentObject.push(this.word);
		      this.word = null;
		    }
		    this.state = NEUTRAL;
		    this.currentObject = this.stack.pop();
		    if (!this.currentObject) {
		      this.state = ENDED;
		    }
	
		    return;
		  }
		};
		Parser.prototype.number = function(char) {
		  if (digets.test(char)) {
		    this.word += char;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.word = parseFloat(this.word);
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
		};
		Parser.prototype.quoted = function(char) {
		  if (char === '"') {
		    this.state = AFTERQUOTE;
		    return;
		  }
		  this.word += char;
		  return;
		};
		Parser.prototype.keyword = function(char) {
		  if (keyword.test(char)) {
		    this.word += char;
		    return;
		  }
		  if (char === '[') {
		    var newObjects = [];
		    newObjects.push(this.word);
		    this.level++;
		    if (this.root === null) {
		      this.root = newObjects;
		    } else {
		      this.currentObject.push(newObjects);
		    }
		    this.stack.push(this.currentObject);
		    this.currentObject = newObjects;
		    this.state = NEUTRAL;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
		};
		Parser.prototype.neutral = function(char) {
		  if (latin.test(char)) {
		    this.word = char;
		    this.state = KEYWORD;
		    return;
		  }
		  if (char === '"') {
		    this.word = '';
		    this.state = QUOTED;
		    return;
		  }
		  if (digets.test(char)) {
		    this.word = char;
		    this.state = NUMBER;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
		};
		Parser.prototype.output = function() {
		  while (this.place < this.text.length) {
		    this.readCharicter();
		  }
		  if (this.state === ENDED) {
		    return this.root;
		  }
		  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
		};
	
		function parseString(txt) {
		  var parser = new Parser(txt);
		  return parser.output();
		}
	
		function mapit(obj, key, value) {
		  if (Array.isArray(key)) {
		    value.unshift(key);
		    key = null;
		  }
		  var thing = key ? {} : obj;
	
		  var out = value.reduce(function(newObj, item) {
		    sExpr(item, newObj);
		    return newObj
		  }, thing);
		  if (key) {
		    obj[key] = out;
		  }
		}
	
		function sExpr(v, obj) {
		  if (!Array.isArray(v)) {
		    obj[v] = true;
		    return;
		  }
		  var key = v.shift();
		  if (key === 'PARAMETER') {
		    key = v.shift();
		  }
		  if (v.length === 1) {
		    if (Array.isArray(v[0])) {
		      obj[key] = {};
		      sExpr(v[0], obj[key]);
		      return;
		    }
		    obj[key] = v[0];
		    return;
		  }
		  if (!v.length) {
		    obj[key] = true;
		    return;
		  }
		  if (key === 'TOWGS84') {
		    obj[key] = v;
		    return;
		  }
		  if (!Array.isArray(key)) {
		    obj[key] = {};
		  }
	
		  var i;
		  switch (key) {
		    case 'UNIT':
		    case 'PRIMEM':
		    case 'VERT_DATUM':
		      obj[key] = {
		        name: v[0].toLowerCase(),
		        convert: v[1]
		      };
		      if (v.length === 3) {
		        sExpr(v[2], obj[key]);
		      }
		      return;
		    case 'SPHEROID':
		    case 'ELLIPSOID':
		      obj[key] = {
		        name: v[0],
		        a: v[1],
		        rf: v[2]
		      };
		      if (v.length === 4) {
		        sExpr(v[3], obj[key]);
		      }
		      return;
		    case 'PROJECTEDCRS':
		    case 'PROJCRS':
		    case 'GEOGCS':
		    case 'GEOCCS':
		    case 'PROJCS':
		    case 'LOCAL_CS':
		    case 'GEODCRS':
		    case 'GEODETICCRS':
		    case 'GEODETICDATUM':
		    case 'EDATUM':
		    case 'ENGINEERINGDATUM':
		    case 'VERT_CS':
		    case 'VERTCRS':
		    case 'VERTICALCRS':
		    case 'COMPD_CS':
		    case 'COMPOUNDCRS':
		    case 'ENGINEERINGCRS':
		    case 'ENGCRS':
		    case 'FITTED_CS':
		    case 'LOCAL_DATUM':
		    case 'DATUM':
		      v[0] = ['name', v[0]];
		      mapit(obj, key, v);
		      return;
		    default:
		      i = -1;
		      while (++i < v.length) {
		        if (!Array.isArray(v[i])) {
		          return sExpr(v, obj[key]);
		        }
		      }
		      return mapit(obj, key, v);
		  }
		}
	
		var D2R$1 = 0.01745329251994329577;
		function rename(obj, params) {
		  var outName = params[0];
		  var inName = params[1];
		  if (!(outName in obj) && (inName in obj)) {
		    obj[outName] = obj[inName];
		    if (params.length === 3) {
		      obj[outName] = params[2](obj[outName]);
		    }
		  }
		}
	
		function d2r(input) {
		  return input * D2R$1;
		}
	
		function cleanWKT(wkt) {
		  if (wkt.type === 'GEOGCS') {
		    wkt.projName = 'longlat';
		  } else if (wkt.type === 'LOCAL_CS') {
		    wkt.projName = 'identity';
		    wkt.local = true;
		  } else {
		    if (typeof wkt.PROJECTION === 'object') {
		      wkt.projName = Object.keys(wkt.PROJECTION)[0];
		    } else {
		      wkt.projName = wkt.PROJECTION;
		    }
		  }
		  if (wkt.UNIT) {
		    wkt.units = wkt.UNIT.name.toLowerCase();
		    if (wkt.units === 'metre') {
		      wkt.units = 'meter';
		    }
		    if (wkt.UNIT.convert) {
		      if (wkt.type === 'GEOGCS') {
		        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
		          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
		        }
		      } else {
		        wkt.to_meter = wkt.UNIT.convert, 10;
		      }
		    }
		  }
		  var geogcs = wkt.GEOGCS;
		  if (wkt.type === 'GEOGCS') {
		    geogcs = wkt;
		  }
		  if (geogcs) {
		    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
		    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
		    //}
		    if (geogcs.DATUM) {
		      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
		    } else {
		      wkt.datumCode = geogcs.name.toLowerCase();
		    }
		    if (wkt.datumCode.slice(0, 2) === 'd_') {
		      wkt.datumCode = wkt.datumCode.slice(2);
		    }
		    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
		      wkt.datumCode = 'nzgd49';
		    }
		    if (wkt.datumCode === 'wgs_1984') {
		      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
		        wkt.sphere = true;
		      }
		      wkt.datumCode = 'wgs84';
		    }
		    if (wkt.datumCode.slice(-6) === '_ferro') {
		      wkt.datumCode = wkt.datumCode.slice(0, - 6);
		    }
		    if (wkt.datumCode.slice(-8) === '_jakarta') {
		      wkt.datumCode = wkt.datumCode.slice(0, - 8);
		    }
		    if (~wkt.datumCode.indexOf('belge')) {
		      wkt.datumCode = 'rnb72';
		    }
		    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
		      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
		      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
		        wkt.ellps = 'intl';
		      }
	
		      wkt.a = geogcs.DATUM.SPHEROID.a;
		      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
		    }
		    if (~wkt.datumCode.indexOf('osgb_1936')) {
		      wkt.datumCode = 'osgb36';
		    }
		  }
		  if (wkt.b && !isFinite(wkt.b)) {
		    wkt.b = wkt.a;
		  }
	
		  function toMeter(input) {
		    var ratio = wkt.to_meter || 1;
		    return input * ratio;
		  }
		  var renamer = function(a) {
		    return rename(wkt, a);
		  };
		  var list = [
		    ['standard_parallel_1', 'Standard_Parallel_1'],
		    ['standard_parallel_2', 'Standard_Parallel_2'],
		    ['false_easting', 'False_Easting'],
		    ['false_northing', 'False_Northing'],
		    ['central_meridian', 'Central_Meridian'],
		    ['latitude_of_origin', 'Latitude_Of_Origin'],
		    ['latitude_of_origin', 'Central_Parallel'],
		    ['scale_factor', 'Scale_Factor'],
		    ['k0', 'scale_factor'],
		    ['latitude_of_center', 'Latitude_of_center'],
		    ['lat0', 'latitude_of_center', d2r],
		    ['longitude_of_center', 'Longitude_Of_Center'],
		    ['longc', 'longitude_of_center', d2r],
		    ['x0', 'false_easting', toMeter],
		    ['y0', 'false_northing', toMeter],
		    ['long0', 'central_meridian', d2r],
		    ['lat0', 'latitude_of_origin', d2r],
		    ['lat0', 'standard_parallel_1', d2r],
		    ['lat1', 'standard_parallel_1', d2r],
		    ['lat2', 'standard_parallel_2', d2r],
		    ['alpha', 'azimuth', d2r],
		    ['srsCode', 'name']
		  ];
		  list.forEach(renamer);
		  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
		    wkt.long0 = wkt.longc;
		  }
		  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
		    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
		    wkt.lat_ts = wkt.lat1;
		  }
		}
		var wkt = function(wkt) {
		  var lisp = parseString(wkt);
		  var type = lisp.shift();
		  var name = lisp.shift();
		  lisp.unshift(['name', name]);
		  lisp.unshift(['type', type]);
		  var obj = {};
		  sExpr(lisp, obj);
		  cleanWKT(obj);
		  return obj;
		};
	
		function defs(name) {
		  /*global console*/
		  var that = this;
		  if (arguments.length === 2) {
		    var def = arguments[1];
		    if (typeof def === 'string') {
		      if (def.charAt(0) === '+') {
		        defs[name] = parseProj(arguments[1]);
		      }
		      else {
		        defs[name] = wkt(arguments[1]);
		      }
		    } else {
		      defs[name] = def;
		    }
		  }
		  else if (arguments.length === 1) {
		    if (Array.isArray(name)) {
		      return name.map(function(v) {
		        if (Array.isArray(v)) {
		          defs.apply(that, v);
		        }
		        else {
		          defs(v);
		        }
		      });
		    }
		    else if (typeof name === 'string') {
		      if (name in defs) {
		        return defs[name];
		      }
		    }
		    else if ('EPSG' in name) {
		      defs['EPSG:' + name.EPSG] = name;
		    }
		    else if ('ESRI' in name) {
		      defs['ESRI:' + name.ESRI] = name;
		    }
		    else if ('IAU2000' in name) {
		      defs['IAU2000:' + name.IAU2000] = name;
		    }
		    else {
		      console.log(name);
		    }
		    return;
		  }
	
	
		}
		globals(defs);
	
		function testObj(code){
		  return typeof code === 'string';
		}
		function testDef(code){
		  return code in defs;
		}
		 var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; 
		function testWKT(code){
		  return codeWords.some(function (word) {
		    return code.indexOf(word) > -1;
		  });
		}
		function testProj(code){
		  return code[0] === '+';
		}
		function parse(code){
		  if (testObj(code)) {
		    //check to see if this is a WKT string
		    if (testDef(code)) {
		      return defs[code];
		    }
		    if (testWKT(code)) {
		      return wkt(code);
		    }
		    if (testProj(code)) {
		      return parseProj(code);
		    }
		  }else{
		    return code;
		  }
		}
	
		var extend = function(destination, source) {
		  destination = destination || {};
		  var value, property;
		  if (!source) {
		    return destination;
		  }
		  for (property in source) {
		    value = source[property];
		    if (value !== undefined) {
		      destination[property] = value;
		    }
		  }
		  return destination;
		};
	
		var msfnz = function(eccent, sinphi, cosphi) {
		  var con = eccent * sinphi;
		  return cosphi / (Math.sqrt(1 - con * con));
		};
	
		var sign = function(x) {
		  return x<0 ? -1 : 1;
		};
	
		var adjust_lon = function(x) {
		  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
		};
	
		var tsfnz = function(eccent, phi, sinphi) {
		  var con = eccent * sinphi;
		  var com = 0.5 * eccent;
		  con = Math.pow(((1 - con) / (1 + con)), com);
		  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
		};
	
		var phi2z = function(eccent, ts) {
		  var eccnth = 0.5 * eccent;
		  var con, dphi;
		  var phi = HALF_PI - 2 * Math.atan(ts);
		  for (var i = 0; i <= 15; i++) {
		    con = eccent * Math.sin(phi);
		    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }
		  //console.log("phi2z has NoConvergence");
		  return -9999;
		};
	
		function init() {
		  var con = this.b / this.a;
		  this.es = 1 - con * con;
		  if(!('x0' in this)){
		    this.x0 = 0;
		  }
		  if(!('y0' in this)){
		    this.y0 = 0;
		  }
		  this.e = Math.sqrt(this.es);
		  if (this.lat_ts) {
		    if (this.sphere) {
		      this.k0 = Math.cos(this.lat_ts);
		    }
		    else {
		      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
		    }
		  }
		  else {
		    if (!this.k0) {
		      if (this.k) {
		        this.k0 = this.k;
		      }
		      else {
		        this.k0 = 1;
		      }
		    }
		  }
		}
	
		/* Mercator forward equations--mapping lat,long to x,y
		  --------------------------------------------------*/
	
		function forward(p) {
		  var lon = p.x;
		  var lat = p.y;
		  // convert to radians
		  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
		    return null;
		  }
	
		  var x, y;
		  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
		    return null;
		  }
		  else {
		    if (this.sphere) {
		      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
		      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
		    }
		    else {
		      var sinphi = Math.sin(lat);
		      var ts = tsfnz(this.e, lat, sinphi);
		      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
		      y = this.y0 - this.a * this.k0 * Math.log(ts);
		    }
		    p.x = x;
		    p.y = y;
		    return p;
		  }
		}
	
		/* Mercator inverse equations--mapping x,y to lat/long
		  --------------------------------------------------*/
		function inverse(p) {
	
		  var x = p.x - this.x0;
		  var y = p.y - this.y0;
		  var lon, lat;
	
		  if (this.sphere) {
		    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
		  }
		  else {
		    var ts = Math.exp(-y / (this.a * this.k0));
		    lat = phi2z(this.e, ts);
		    if (lat === -9999) {
		      return null;
		    }
		  }
		  lon = adjust_lon(this.long0 + x / (this.a * this.k0));
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
		var merc = {
		  init: init,
		  forward: forward,
		  inverse: inverse,
		  names: names$1
		};
	
		function init$1() {
		  //no-op for longlat
		}
	
		function identity(pt) {
		  return pt;
		}
		var names$2 = ["longlat", "identity"];
		var longlat = {
		  init: init$1,
		  forward: identity,
		  inverse: identity,
		  names: names$2
		};
	
		var projs = [merc, longlat];
		var names$$1 = {};
		var projStore = [];
	
		function add(proj, i) {
		  var len = projStore.length;
		  if (!proj.names) {
		    console.log(i);
		    return true;
		  }
		  projStore[len] = proj;
		  proj.names.forEach(function(n) {
		    names$$1[n.toLowerCase()] = len;
		  });
		  return this;
		}
	
		function get(name) {
		  if (!name) {
		    return false;
		  }
		  var n = name.toLowerCase();
		  if (typeof names$$1[n] !== 'undefined' && projStore[names$$1[n]]) {
		    return projStore[names$$1[n]];
		  }
		}
	
		function start() {
		  projs.forEach(add);
		}
		var projections = {
		  start: start,
		  add: add,
		  get: get
		};
	
		var exports$2 = {};
		exports$2.MERIT = {
		  a: 6378137.0,
		  rf: 298.257,
		  ellipseName: "MERIT 1983"
		};
	
		exports$2.SGS85 = {
		  a: 6378136.0,
		  rf: 298.257,
		  ellipseName: "Soviet Geodetic System 85"
		};
	
		exports$2.GRS80 = {
		  a: 6378137.0,
		  rf: 298.257222101,
		  ellipseName: "GRS 1980(IUGG, 1980)"
		};
	
		exports$2.IAU76 = {
		  a: 6378140.0,
		  rf: 298.257,
		  ellipseName: "IAU 1976"
		};
	
		exports$2.airy = {
		  a: 6377563.396,
		  b: 6356256.910,
		  ellipseName: "Airy 1830"
		};
	
		exports$2.APL4 = {
		  a: 6378137,
		  rf: 298.25,
		  ellipseName: "Appl. Physics. 1965"
		};
	
		exports$2.NWL9D = {
		  a: 6378145.0,
		  rf: 298.25,
		  ellipseName: "Naval Weapons Lab., 1965"
		};
	
		exports$2.mod_airy = {
		  a: 6377340.189,
		  b: 6356034.446,
		  ellipseName: "Modified Airy"
		};
	
		exports$2.andrae = {
		  a: 6377104.43,
		  rf: 300.0,
		  ellipseName: "Andrae 1876 (Den., Iclnd.)"
		};
	
		exports$2.aust_SA = {
		  a: 6378160.0,
		  rf: 298.25,
		  ellipseName: "Australian Natl & S. Amer. 1969"
		};
	
		exports$2.GRS67 = {
		  a: 6378160.0,
		  rf: 298.2471674270,
		  ellipseName: "GRS 67(IUGG 1967)"
		};
	
		exports$2.bessel = {
		  a: 6377397.155,
		  rf: 299.1528128,
		  ellipseName: "Bessel 1841"
		};
	
		exports$2.bess_nam = {
		  a: 6377483.865,
		  rf: 299.1528128,
		  ellipseName: "Bessel 1841 (Namibia)"
		};
	
		exports$2.clrk66 = {
		  a: 6378206.4,
		  b: 6356583.8,
		  ellipseName: "Clarke 1866"
		};
	
		exports$2.clrk80 = {
		  a: 6378249.145,
		  rf: 293.4663,
		  ellipseName: "Clarke 1880 mod."
		};
	
		exports$2.clrk58 = {
		  a: 6378293.645208759,
		  rf: 294.2606763692654,
		  ellipseName: "Clarke 1858"
		};
	
		exports$2.CPM = {
		  a: 6375738.7,
		  rf: 334.29,
		  ellipseName: "Comm. des Poids et Mesures 1799"
		};
	
		exports$2.delmbr = {
		  a: 6376428.0,
		  rf: 311.5,
		  ellipseName: "Delambre 1810 (Belgium)"
		};
	
		exports$2.engelis = {
		  a: 6378136.05,
		  rf: 298.2566,
		  ellipseName: "Engelis 1985"
		};
	
		exports$2.evrst30 = {
		  a: 6377276.345,
		  rf: 300.8017,
		  ellipseName: "Everest 1830"
		};
	
		exports$2.evrst48 = {
		  a: 6377304.063,
		  rf: 300.8017,
		  ellipseName: "Everest 1948"
		};
	
		exports$2.evrst56 = {
		  a: 6377301.243,
		  rf: 300.8017,
		  ellipseName: "Everest 1956"
		};
	
		exports$2.evrst69 = {
		  a: 6377295.664,
		  rf: 300.8017,
		  ellipseName: "Everest 1969"
		};
	
		exports$2.evrstSS = {
		  a: 6377298.556,
		  rf: 300.8017,
		  ellipseName: "Everest (Sabah & Sarawak)"
		};
	
		exports$2.fschr60 = {
		  a: 6378166.0,
		  rf: 298.3,
		  ellipseName: "Fischer (Mercury Datum) 1960"
		};
	
		exports$2.fschr60m = {
		  a: 6378155.0,
		  rf: 298.3,
		  ellipseName: "Fischer 1960"
		};
	
		exports$2.fschr68 = {
		  a: 6378150.0,
		  rf: 298.3,
		  ellipseName: "Fischer 1968"
		};
	
		exports$2.helmert = {
		  a: 6378200.0,
		  rf: 298.3,
		  ellipseName: "Helmert 1906"
		};
	
		exports$2.hough = {
		  a: 6378270.0,
		  rf: 297.0,
		  ellipseName: "Hough"
		};
	
		exports$2.intl = {
		  a: 6378388.0,
		  rf: 297.0,
		  ellipseName: "International 1909 (Hayford)"
		};
	
		exports$2.kaula = {
		  a: 6378163.0,
		  rf: 298.24,
		  ellipseName: "Kaula 1961"
		};
	
		exports$2.lerch = {
		  a: 6378139.0,
		  rf: 298.257,
		  ellipseName: "Lerch 1979"
		};
	
		exports$2.mprts = {
		  a: 6397300.0,
		  rf: 191.0,
		  ellipseName: "Maupertius 1738"
		};
	
		exports$2.new_intl = {
		  a: 6378157.5,
		  b: 6356772.2,
		  ellipseName: "New International 1967"
		};
	
		exports$2.plessis = {
		  a: 6376523.0,
		  rf: 6355863.0,
		  ellipseName: "Plessis 1817 (France)"
		};
	
		exports$2.krass = {
		  a: 6378245.0,
		  rf: 298.3,
		  ellipseName: "Krassovsky, 1942"
		};
	
		exports$2.SEasia = {
		  a: 6378155.0,
		  b: 6356773.3205,
		  ellipseName: "Southeast Asia"
		};
	
		exports$2.walbeck = {
		  a: 6376896.0,
		  b: 6355834.8467,
		  ellipseName: "Walbeck"
		};
	
		exports$2.WGS60 = {
		  a: 6378165.0,
		  rf: 298.3,
		  ellipseName: "WGS 60"
		};
	
		exports$2.WGS66 = {
		  a: 6378145.0,
		  rf: 298.25,
		  ellipseName: "WGS 66"
		};
	
		exports$2.WGS7 = {
		  a: 6378135.0,
		  rf: 298.26,
		  ellipseName: "WGS 72"
		};
	
		var WGS84 = exports$2.WGS84 = {
		  a: 6378137.0,
		  rf: 298.257223563,
		  ellipseName: "WGS 84"
		};
	
		exports$2.sphere = {
		  a: 6370997.0,
		  b: 6370997.0,
		  ellipseName: "Normal Sphere (r=6370997)"
		};
	
		function eccentricity(a, b, rf, R_A) {
		  var a2 = a * a; // used in geocentric
		  var b2 = b * b; // used in geocentric
		  var es = (a2 - b2) / a2; // e ^ 2
		  var e = 0;
		  if (R_A) {
		    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
		    a2 = a * a;
		    es = 0;
		  } else {
		    e = Math.sqrt(es); // eccentricity
		  }
		  var ep2 = (a2 - b2) / b2; // used in geocentric
		  return {
		    es: es,
		    e: e,
		    ep2: ep2
		  };
		}
		function sphere(a, b, rf, ellps, sphere) {
		  if (!a) { // do we have an ellipsoid?
		    var ellipse = match(exports$2, ellps);
		    if (!ellipse) {
		      ellipse = WGS84;
		    }
		    a = ellipse.a;
		    b = ellipse.b;
		    rf = ellipse.rf;
		  }
	
		  if (rf && !b) {
		    b = (1.0 - 1.0 / rf) * a;
		  }
		  if (rf === 0 || Math.abs(a - b) < EPSLN) {
		    sphere = true;
		    b = a;
		  }
		  return {
		    a: a,
		    b: b,
		    rf: rf,
		    sphere: sphere
		  };
		}
	
		var exports$3 = {};
		exports$3.wgs84 = {
		  towgs84: "0,0,0",
		  ellipse: "WGS84",
		  datumName: "WGS84"
		};
	
		exports$3.ch1903 = {
		  towgs84: "674.374,15.056,405.346",
		  ellipse: "bessel",
		  datumName: "swiss"
		};
	
		exports$3.ggrs87 = {
		  towgs84: "-199.87,74.79,246.62",
		  ellipse: "GRS80",
		  datumName: "Greek_Geodetic_Reference_System_1987"
		};
	
		exports$3.nad83 = {
		  towgs84: "0,0,0",
		  ellipse: "GRS80",
		  datumName: "North_American_Datum_1983"
		};
	
		exports$3.nad27 = {
		  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
		  ellipse: "clrk66",
		  datumName: "North_American_Datum_1927"
		};
	
		exports$3.potsdam = {
		  towgs84: "606.0,23.0,413.0",
		  ellipse: "bessel",
		  datumName: "Potsdam Rauenberg 1950 DHDN"
		};
	
		exports$3.carthage = {
		  towgs84: "-263.0,6.0,431.0",
		  ellipse: "clark80",
		  datumName: "Carthage 1934 Tunisia"
		};
	
		exports$3.hermannskogel = {
		  towgs84: "653.0,-212.0,449.0",
		  ellipse: "bessel",
		  datumName: "Hermannskogel"
		};
	
		exports$3.ire65 = {
		  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
		  ellipse: "mod_airy",
		  datumName: "Ireland 1965"
		};
	
		exports$3.rassadiran = {
		  towgs84: "-133.63,-157.5,-158.62",
		  ellipse: "intl",
		  datumName: "Rassadiran"
		};
	
		exports$3.nzgd49 = {
		  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
		  ellipse: "intl",
		  datumName: "New Zealand Geodetic Datum 1949"
		};
	
		exports$3.osgb36 = {
		  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
		  ellipse: "airy",
		  datumName: "Airy 1830"
		};
	
		exports$3.s_jtsk = {
		  towgs84: "589,76,480",
		  ellipse: 'bessel',
		  datumName: 'S-JTSK (Ferro)'
		};
	
		exports$3.beduaram = {
		  towgs84: '-106,-87,188',
		  ellipse: 'clrk80',
		  datumName: 'Beduaram'
		};
	
		exports$3.gunung_segara = {
		  towgs84: '-403,684,41',
		  ellipse: 'bessel',
		  datumName: 'Gunung Segara Jakarta'
		};
	
		exports$3.rnb72 = {
		  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
		  ellipse: "intl",
		  datumName: "Reseau National Belge 1972"
		};
	
		function datum(datumCode, datum_params, a, b, es, ep2) {
		  var out = {};
	
		  if (datumCode === undefined || datumCode === 'none') {
		    out.datum_type = PJD_NODATUM;
		  } else {
		    out.datum_type = PJD_WGS84;
		  }
	
		  if (datum_params) {
		    out.datum_params = datum_params.map(parseFloat);
		    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
		      out.datum_type = PJD_3PARAM;
		    }
		    if (out.datum_params.length > 3) {
		      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
		        out.datum_type = PJD_7PARAM;
		        out.datum_params[3] *= SEC_TO_RAD;
		        out.datum_params[4] *= SEC_TO_RAD;
		        out.datum_params[5] *= SEC_TO_RAD;
		        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
		      }
		    }
		  }
	
		  out.a = a; //datum object also uses these values
		  out.b = b;
		  out.es = es;
		  out.ep2 = ep2;
		  return out;
		}
	
		function Projection$1(srsCode,callback) {
		  if (!(this instanceof Projection$1)) {
		    return new Projection$1(srsCode);
		  }
		  callback = callback || function(error){
		    if(error){
		      throw error;
		    }
		  };
		  var json = parse(srsCode);
		  if(typeof json !== 'object'){
		    callback(srsCode);
		    return;
		  }
		  var ourProj = Projection$1.projections.get(json.projName);
		  if(!ourProj){
		    callback(srsCode);
		    return;
		  }
		  if (json.datumCode && json.datumCode !== 'none') {
		    var datumDef = match(exports$3, json.datumCode);
		    if (datumDef) {
		      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
		      json.ellps = datumDef.ellipse;
		      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
		    }
		  }
		  json.k0 = json.k0 || 1.0;
		  json.axis = json.axis || 'enu';
		  json.ellps = json.ellps || 'wgs84';
		  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
		  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
		  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);
	
		  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
		  extend(this, ourProj); // transfer all the methods from the projection
	
		  // copy the 4 things over we calulated in deriveConstants.sphere
		  this.a = sphere_.a;
		  this.b = sphere_.b;
		  this.rf = sphere_.rf;
		  this.sphere = sphere_.sphere;
	
		  // copy the 3 things we calculated in deriveConstants.eccentricity
		  this.es = ecc.es;
		  this.e = ecc.e;
		  this.ep2 = ecc.ep2;
	
		  // add in the datum object
		  this.datum = datumObj;
	
		  // init the projection
		  this.init();
	
		  // legecy callback from back in the day when it went to spatialreference.org
		  callback(null, this);
	
		}
		Projection$1.projections = projections;
		Projection$1.projections.start();
	
		function compareDatums(source, dest) {
		  if (source.datum_type !== dest.datum_type) {
		    return false; // false, datums are not equal
		  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
		    // the tolerance for es is to ensure that GRS80 and WGS84
		    // are considered identical
		    return false;
		  } else if (source.datum_type === PJD_3PARAM) {
		    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
		  } else if (source.datum_type === PJD_7PARAM) {
		    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
		  } else {
		    return true; // datums are equal
		  }
		} // cs_compare_datums()
	
		/*
		 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
		 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
		 * according to the current ellipsoid parameters.
		 *
		 *    Latitude  : Geodetic latitude in radians                     (input)
		 *    Longitude : Geodetic longitude in radians                    (input)
		 *    Height    : Geodetic height, in meters                       (input)
		 *    X         : Calculated Geocentric X coordinate, in meters    (output)
		 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
		 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
		 *
		 */
		function geodeticToGeocentric(p, es, a) {
		  var Longitude = p.x;
		  var Latitude = p.y;
		  var Height = p.z ? p.z : 0; //Z value not always supplied
	
		  var Rn; /*  Earth radius at location  */
		  var Sin_Lat; /*  Math.sin(Latitude)  */
		  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
		  var Cos_Lat; /*  Math.cos(Latitude)  */
	
		  /*
		   ** Don't blow up if Latitude is just a little out of the value
		   ** range as it may just be a rounding issue.  Also removed longitude
		   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
		   */
		  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
		    Latitude = -HALF_PI;
		  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
		    Latitude = HALF_PI;
		  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
		    /* Latitude out of range */
		    //..reportError('geocent:lat out of range:' + Latitude);
		    return null;
		  }
	
		  if (Longitude > Math.PI) {
		    Longitude -= (2 * Math.PI);
		  }
		  Sin_Lat = Math.sin(Latitude);
		  Cos_Lat = Math.cos(Latitude);
		  Sin2_Lat = Sin_Lat * Sin_Lat;
		  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
		  return {
		    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
		    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
		    z: ((Rn * (1 - es)) + Height) * Sin_Lat
		  };
		} // cs_geodetic_to_geocentric()
	
		function geocentricToGeodetic(p, es, a, b) {
		  /* local defintions and variables */
		  /* end-criterium of loop, accuracy of sin(Latitude) */
		  var genau = 1e-12;
		  var genau2 = (genau * genau);
		  var maxiter = 30;
	
		  var P; /* distance between semi-minor axis and location */
		  var RR; /* distance between center and location */
		  var CT; /* sin of geocentric latitude */
		  var ST; /* cos of geocentric latitude */
		  var RX;
		  var RK;
		  var RN; /* Earth radius at location */
		  var CPHI0; /* cos of start or old geodetic latitude in iterations */
		  var SPHI0; /* sin of start or old geodetic latitude in iterations */
		  var CPHI; /* cos of searched geodetic latitude */
		  var SPHI; /* sin of searched geodetic latitude */
		  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
		  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */
	
		  var X = p.x;
		  var Y = p.y;
		  var Z = p.z ? p.z : 0.0; //Z value not always supplied
		  var Longitude;
		  var Latitude;
		  var Height;
	
		  P = Math.sqrt(X * X + Y * Y);
		  RR = Math.sqrt(X * X + Y * Y + Z * Z);
	
		  /*      special cases for latitude and longitude */
		  if (P / a < genau) {
	
		    /*  special case, if P=0. (X=0., Y=0.) */
		    Longitude = 0.0;
	
		    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
		     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
		    if (RR / a < genau) {
		      Latitude = HALF_PI;
		      Height = -b;
		      return {
		        x: p.x,
		        y: p.y,
		        z: p.z
		      };
		    }
		  } else {
		    /*  ellipsoidal (geodetic) longitude
		     *  interval: -PI < Longitude <= +PI */
		    Longitude = Math.atan2(Y, X);
		  }
	
		  /* --------------------------------------------------------------
		   * Following iterative algorithm was developped by
		   * "Institut for Erdmessung", University of Hannover, July 1988.
		   * Internet: www.ife.uni-hannover.de
		   * Iterative computation of CPHI,SPHI and Height.
		   * Iteration of CPHI and SPHI to 10**-12 radian resp.
		   * 2*10**-7 arcsec.
		   * --------------------------------------------------------------
		   */
		  CT = Z / RR;
		  ST = P / RR;
		  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
		  CPHI0 = ST * (1.0 - es) * RX;
		  SPHI0 = CT * RX;
		  iter = 0;
	
		  /* loop to find sin(Latitude) resp. Latitude
		   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
		  do {
		    iter++;
		    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);
	
		    /*  ellipsoidal (geodetic) height */
		    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);
	
		    RK = es * RN / (RN + Height);
		    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
		    CPHI = ST * (1.0 - RK) * RX;
		    SPHI = CT * RX;
		    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
		    CPHI0 = CPHI;
		    SPHI0 = SPHI;
		  }
		  while (SDPHI * SDPHI > genau2 && iter < maxiter);
	
		  /*      ellipsoidal (geodetic) latitude */
		  Latitude = Math.atan(SPHI / Math.abs(CPHI));
		  return {
		    x: Longitude,
		    y: Latitude,
		    z: Height
		  };
		} // cs_geocentric_to_geodetic()
	
		/****************************************************************/
		// pj_geocentic_to_wgs84( p )
		//  p = point to transform in geocentric coordinates (x,y,z)
	
	
		/** point object, nothing fancy, just allows values to be
		    passed back and forth by reference rather than by value.
		    Other point classes may be used as long as they have
		    x and y properties, which will get modified in the transform method.
		*/
		function geocentricToWgs84(p, datum_type, datum_params) {
	
		  if (datum_type === PJD_3PARAM) {
		    // if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: p.x + datum_params[0],
		      y: p.y + datum_params[1],
		      z: p.z + datum_params[2],
		    };
		  } else if (datum_type === PJD_7PARAM) {
		    var Dx_BF = datum_params[0];
		    var Dy_BF = datum_params[1];
		    var Dz_BF = datum_params[2];
		    var Rx_BF = datum_params[3];
		    var Ry_BF = datum_params[4];
		    var Rz_BF = datum_params[5];
		    var M_BF = datum_params[6];
		    // if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
		      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
		      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
		    };
		  }
		} // cs_geocentric_to_wgs84
	
		/****************************************************************/
		// pj_geocentic_from_wgs84()
		//  coordinate system definition,
		//  point to transform in geocentric coordinates (x,y,z)
		function geocentricFromWgs84(p, datum_type, datum_params) {
	
		  if (datum_type === PJD_3PARAM) {
		    //if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: p.x - datum_params[0],
		      y: p.y - datum_params[1],
		      z: p.z - datum_params[2],
		    };
	
		  } else if (datum_type === PJD_7PARAM) {
		    var Dx_BF = datum_params[0];
		    var Dy_BF = datum_params[1];
		    var Dz_BF = datum_params[2];
		    var Rx_BF = datum_params[3];
		    var Ry_BF = datum_params[4];
		    var Rz_BF = datum_params[5];
		    var M_BF = datum_params[6];
		    var x_tmp = (p.x - Dx_BF) / M_BF;
		    var y_tmp = (p.y - Dy_BF) / M_BF;
		    var z_tmp = (p.z - Dz_BF) / M_BF;
		    //if( x[io] === HUGE_VAL )
		    //    continue;
	
		    return {
		      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
		      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
		      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
		    };
		  } //cs_geocentric_from_wgs84()
		}
	
		function checkParams(type) {
		  return (type === PJD_3PARAM || type === PJD_7PARAM);
		}
	
		var datum_transform = function(source, dest, point) {
		  // Short cut if the datums are identical.
		  if (compareDatums(source, dest)) {
		    return point; // in this case, zero is sucess,
		    // whereas cs_compare_datums returns 1 to indicate TRUE
		    // confusing, should fix this
		  }
	
		  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
		  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
		    return point;
		  }
	
		  // If this datum requires grid shifts, then apply it to geodetic coordinates.
	
		  // Do we need to go through geocentric coordinates?
		  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
		    return point;
		  }
	
		  // Convert to geocentric coordinates.
		  point = geodeticToGeocentric(point, source.es, source.a);
		  // Convert between datums
		  if (checkParams(source.datum_type)) {
		    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
		  }
		  if (checkParams(dest.datum_type)) {
		    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
		  }
		  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);
	
		};
	
		var adjust_axis = function(crs, denorm, point) {
		  var xin = point.x,
		    yin = point.y,
		    zin = point.z || 0.0;
		  var v, t, i;
		  var out = {};
		  for (i = 0; i < 3; i++) {
		    if (denorm && i === 2 && point.z === undefined) {
		      continue;
		    }
		    if (i === 0) {
		      v = xin;
		      t = 'x';
		    }
		    else if (i === 1) {
		      v = yin;
		      t = 'y';
		    }
		    else {
		      v = zin;
		      t = 'z';
		    }
		    switch (crs.axis[i]) {
		    case 'e':
		      out[t] = v;
		      break;
		    case 'w':
		      out[t] = -v;
		      break;
		    case 'n':
		      out[t] = v;
		      break;
		    case 's':
		      out[t] = -v;
		      break;
		    case 'u':
		      if (point[t] !== undefined) {
		        out.z = v;
		      }
		      break;
		    case 'd':
		      if (point[t] !== undefined) {
		        out.z = -v;
		      }
		      break;
		    default:
		      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
		      return null;
		    }
		  }
		  return out;
		};
	
		var toPoint = function (array){
		  var out = {
		    x: array[0],
		    y: array[1]
		  };
		  if (array.length>2) {
		    out.z = array[2];
		  }
		  if (array.length>3) {
		    out.m = array[3];
		  }
		  return out;
		};
	
		function checkNotWGS(source, dest) {
		  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
		}
	
		function transform(source, dest, point) {
		  var wgs84;
		  if (Array.isArray(point)) {
		    point = toPoint(point);
		  }
	
		  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
		  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
		    wgs84 = new Projection$1('WGS84');
		    point = transform(source, wgs84, point);
		    source = wgs84;
		  }
		  // DGR, 2010/11/12
		  if (source.axis !== 'enu') {
		    point = adjust_axis(source, false, point);
		  }
		  // Transform source points to long/lat, if they aren't already.
		  if (source.projName === 'longlat') {
		    point = {
		      x: point.x * D2R,
		      y: point.y * D2R
		    };
		  }
		  else {
		    if (source.to_meter) {
		      point = {
		        x: point.x * source.to_meter,
		        y: point.y * source.to_meter
		      };
		    }
		    point = source.inverse(point); // Convert Cartesian to longlat
		  }
		  // Adjust for the prime meridian if necessary
		  if (source.from_greenwich) {
		    point.x += source.from_greenwich;
		  }
	
		  // Convert datums if needed, and if possible.
		  point = datum_transform(source.datum, dest.datum, point);
	
		  // Adjust for the prime meridian if necessary
		  if (dest.from_greenwich) {
		    point = {
		      x: point.x - dest.from_greenwich,
		      y: point.y
		    };
		  }
	
		  if (dest.projName === 'longlat') {
		    // convert radians to decimal degrees
		    point = {
		      x: point.x * R2D,
		      y: point.y * R2D
		    };
		  } else { // else project
		    point = dest.forward(point);
		    if (dest.to_meter) {
		      point = {
		        x: point.x / dest.to_meter,
		        y: point.y / dest.to_meter
		      };
		    }
		  }
	
		  // DGR, 2010/11/12
		  if (dest.axis !== 'enu') {
		    return adjust_axis(dest, true, point);
		  }
	
		  return point;
		}
	
		var wgs84 = Projection$1('WGS84');
	
		function transformer(from, to, coords) {
		  var transformedArray;
		  if (Array.isArray(coords)) {
		    transformedArray = transform(from, to, coords);
		    if (coords.length === 3) {
		      return [transformedArray.x, transformedArray.y, transformedArray.z];
		    }
		    else {
		      return [transformedArray.x, transformedArray.y];
		    }
		  }
		  else {
		    return transform(from, to, coords);
		  }
		}
	
		function checkProj(item) {
		  if (item instanceof Projection$1) {
		    return item;
		  }
		  if (item.oProj) {
		    return item.oProj;
		  }
		  return Projection$1(item);
		}
		function proj4$1(fromProj, toProj, coord) {
		  fromProj = checkProj(fromProj);
		  var single = false;
		  var obj;
		  if (typeof toProj === 'undefined') {
		    toProj = fromProj;
		    fromProj = wgs84;
		    single = true;
		  }
		  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
		    coord = toProj;
		    toProj = fromProj;
		    fromProj = wgs84;
		    single = true;
		  }
		  toProj = checkProj(toProj);
		  if (coord) {
		    return transformer(fromProj, toProj, coord);
		  }
		  else {
		    obj = {
		      forward: function(coords) {
		        return transformer(fromProj, toProj, coords);
		      },
		      inverse: function(coords) {
		        return transformer(toProj, fromProj, coords);
		      }
		    };
		    if (single) {
		      obj.oProj = toProj;
		    }
		    return obj;
		  }
		}
	
		/**
		 * UTM zones are grouped, and assigned to one of a group of 6
		 * sets.
		 *
		 * {int} @private
		 */
		var NUM_100K_SETS = 6;
	
		/**
		 * The column letters (for easting) of the lower left value, per
		 * set.
		 *
		 * {string} @private
		 */
		var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
	
		/**
		 * The row letters (for northing) of the lower left value, per
		 * set.
		 *
		 * {string} @private
		 */
		var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
	
		var A = 65; // A
		var I = 73; // I
		var O = 79; // O
		var V = 86; // V
		var Z = 90; // Z
		var mgrs = {
		  forward: forward$1,
		  inverse: inverse$1,
		  toPoint: toPoint$1
		};
		/**
		 * Conversion of lat/lon to MGRS.
		 *
		 * @param {object} ll Object literal with lat and lon properties on a
		 *     WGS84 ellipsoid.
		 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
		 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
		 * @return {string} the MGRS string for the given location and accuracy.
		 */
		function forward$1(ll, accuracy) {
		  accuracy = accuracy || 5; // default accuracy 1m
		  return encode(LLtoUTM({
		    lat: ll[1],
		    lon: ll[0]
		  }), accuracy);
		}
	
		/**
		 * Conversion of MGRS to lat/lon.
		 *
		 * @param {string} mgrs MGRS string.
		 * @return {array} An array with left (longitude), bottom (latitude), right
		 *     (longitude) and top (latitude) values in WGS84, representing the
		 *     bounding box for the provided MGRS reference.
		 */
		function inverse$1(mgrs) {
		  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
		  if (bbox.lat && bbox.lon) {
		    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
		  }
		  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
		}
	
		function toPoint$1(mgrs) {
		  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
		  if (bbox.lat && bbox.lon) {
		    return [bbox.lon, bbox.lat];
		  }
		  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
		}
		/**
		 * Conversion from degrees to radians.
		 *
		 * @private
		 * @param {number} deg the angle in degrees.
		 * @return {number} the angle in radians.
		 */
		function degToRad(deg) {
		  return (deg * (Math.PI / 180.0));
		}
	
		/**
		 * Conversion from radians to degrees.
		 *
		 * @private
		 * @param {number} rad the angle in radians.
		 * @return {number} the angle in degrees.
		 */
		function radToDeg(rad) {
		  return (180.0 * (rad / Math.PI));
		}
	
		/**
		 * Converts a set of Longitude and Latitude co-ordinates to UTM
		 * using the WGS84 ellipsoid.
		 *
		 * @private
		 * @param {object} ll Object literal with lat and lon properties
		 *     representing the WGS84 coordinate to be converted.
		 * @return {object} Object literal containing the UTM value with easting,
		 *     northing, zoneNumber and zoneLetter properties, and an optional
		 *     accuracy property in digits. Returns null if the conversion failed.
		 */
		function LLtoUTM(ll) {
		  var Lat = ll.lat;
		  var Long = ll.lon;
		  var a = 6378137.0; //ellip.radius;
		  var eccSquared = 0.00669438; //ellip.eccsq;
		  var k0 = 0.9996;
		  var LongOrigin;
		  var eccPrimeSquared;
		  var N, T, C, A, M;
		  var LatRad = degToRad(Lat);
		  var LongRad = degToRad(Long);
		  var LongOriginRad;
		  var ZoneNumber;
		  // (int)
		  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
	
		  //Make sure the longitude 180.00 is in Zone 60
		  if (Long === 180) {
		    ZoneNumber = 60;
		  }
	
		  // Special zone for Norway
		  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
		    ZoneNumber = 32;
		  }
	
		  // Special zones for Svalbard
		  if (Lat >= 72.0 && Lat < 84.0) {
		    if (Long >= 0.0 && Long < 9.0) {
		      ZoneNumber = 31;
		    }
		    else if (Long >= 9.0 && Long < 21.0) {
		      ZoneNumber = 33;
		    }
		    else if (Long >= 21.0 && Long < 33.0) {
		      ZoneNumber = 35;
		    }
		    else if (Long >= 33.0 && Long < 42.0) {
		      ZoneNumber = 37;
		    }
		  }
	
		  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
		  // in middle of
		  // zone
		  LongOriginRad = degToRad(LongOrigin);
	
		  eccPrimeSquared = (eccSquared) / (1 - eccSquared);
	
		  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
		  T = Math.tan(LatRad) * Math.tan(LatRad);
		  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
		  A = Math.cos(LatRad) * (LongRad - LongOriginRad);
	
		  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));
	
		  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);
	
		  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
		  if (Lat < 0.0) {
		    UTMNorthing += 10000000.0; //10000000 meter offset for
		    // southern hemisphere
		  }
	
		  return {
		    northing: Math.round(UTMNorthing),
		    easting: Math.round(UTMEasting),
		    zoneNumber: ZoneNumber,
		    zoneLetter: getLetterDesignator(Lat)
		  };
		}
	
		/**
		 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
		 * class where the Zone can be specified as a single string eg."60N" which
		 * is then broken down into the ZoneNumber and ZoneLetter.
		 *
		 * @private
		 * @param {object} utm An object literal with northing, easting, zoneNumber
		 *     and zoneLetter properties. If an optional accuracy property is
		 *     provided (in meters), a bounding box will be returned instead of
		 *     latitude and longitude.
		 * @return {object} An object literal containing either lat and lon values
		 *     (if no accuracy was provided), or top, right, bottom and left values
		 *     for the bounding box calculated according to the provided accuracy.
		 *     Returns null if the conversion failed.
		 */
		function UTMtoLL(utm) {
	
		  var UTMNorthing = utm.northing;
		  var UTMEasting = utm.easting;
		  var zoneLetter = utm.zoneLetter;
		  var zoneNumber = utm.zoneNumber;
		  // check the ZoneNummber is valid
		  if (zoneNumber < 0 || zoneNumber > 60) {
		    return null;
		  }
	
		  var k0 = 0.9996;
		  var a = 6378137.0; //ellip.radius;
		  var eccSquared = 0.00669438; //ellip.eccsq;
		  var eccPrimeSquared;
		  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
		  var N1, T1, C1, R1, D, M;
		  var LongOrigin;
		  var mu, phi1Rad;
	
		  // remove 500,000 meter offset for longitude
		  var x = UTMEasting - 500000.0;
		  var y = UTMNorthing;
	
		  // We must know somehow if we are in the Northern or Southern
		  // hemisphere, this is the only time we use the letter So even
		  // if the Zone letter isn't exactly correct it should indicate
		  // the hemisphere correctly
		  if (zoneLetter < 'N') {
		    y -= 10000000.0; // remove 10,000,000 meter offset used
		    // for southern hemisphere
		  }
	
		  // There are 60 zones with zone 1 being at West -180 to -174
		  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
		  // in middle of
		  // zone
	
		  eccPrimeSquared = (eccSquared) / (1 - eccSquared);
	
		  M = y / k0;
		  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
	
		  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
		  // double phi1 = ProjMath.radToDeg(phi1Rad);
	
		  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
		  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
		  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
		  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
		  D = x / (N1 * k0);
	
		  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
		  lat = radToDeg(lat);
	
		  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
		  lon = LongOrigin + radToDeg(lon);
	
		  var result;
		  if (utm.accuracy) {
		    var topRight = UTMtoLL({
		      northing: utm.northing + utm.accuracy,
		      easting: utm.easting + utm.accuracy,
		      zoneLetter: utm.zoneLetter,
		      zoneNumber: utm.zoneNumber
		    });
		    result = {
		      top: topRight.lat,
		      right: topRight.lon,
		      bottom: lat,
		      left: lon
		    };
		  }
		  else {
		    result = {
		      lat: lat,
		      lon: lon
		    };
		  }
		  return result;
		}
	
		/**
		 * Calculates the MGRS letter designator for the given latitude.
		 *
		 * @private
		 * @param {number} lat The latitude in WGS84 to get the letter designator
		 *     for.
		 * @return {char} The letter designator.
		 */
		function getLetterDesignator(lat) {
		  //This is here as an error flag to show that the Latitude is
		  //outside MGRS limits
		  var LetterDesignator = 'Z';
	
		  if ((84 >= lat) && (lat >= 72)) {
		    LetterDesignator = 'X';
		  }
		  else if ((72 > lat) && (lat >= 64)) {
		    LetterDesignator = 'W';
		  }
		  else if ((64 > lat) && (lat >= 56)) {
		    LetterDesignator = 'V';
		  }
		  else if ((56 > lat) && (lat >= 48)) {
		    LetterDesignator = 'U';
		  }
		  else if ((48 > lat) && (lat >= 40)) {
		    LetterDesignator = 'T';
		  }
		  else if ((40 > lat) && (lat >= 32)) {
		    LetterDesignator = 'S';
		  }
		  else if ((32 > lat) && (lat >= 24)) {
		    LetterDesignator = 'R';
		  }
		  else if ((24 > lat) && (lat >= 16)) {
		    LetterDesignator = 'Q';
		  }
		  else if ((16 > lat) && (lat >= 8)) {
		    LetterDesignator = 'P';
		  }
		  else if ((8 > lat) && (lat >= 0)) {
		    LetterDesignator = 'N';
		  }
		  else if ((0 > lat) && (lat >= -8)) {
		    LetterDesignator = 'M';
		  }
		  else if ((-8 > lat) && (lat >= -16)) {
		    LetterDesignator = 'L';
		  }
		  else if ((-16 > lat) && (lat >= -24)) {
		    LetterDesignator = 'K';
		  }
		  else if ((-24 > lat) && (lat >= -32)) {
		    LetterDesignator = 'J';
		  }
		  else if ((-32 > lat) && (lat >= -40)) {
		    LetterDesignator = 'H';
		  }
		  else if ((-40 > lat) && (lat >= -48)) {
		    LetterDesignator = 'G';
		  }
		  else if ((-48 > lat) && (lat >= -56)) {
		    LetterDesignator = 'F';
		  }
		  else if ((-56 > lat) && (lat >= -64)) {
		    LetterDesignator = 'E';
		  }
		  else if ((-64 > lat) && (lat >= -72)) {
		    LetterDesignator = 'D';
		  }
		  else if ((-72 > lat) && (lat >= -80)) {
		    LetterDesignator = 'C';
		  }
		  return LetterDesignator;
		}
	
		/**
		 * Encodes a UTM location as MGRS string.
		 *
		 * @private
		 * @param {object} utm An object literal with easting, northing,
		 *     zoneLetter, zoneNumber
		 * @param {number} accuracy Accuracy in digits (1-5).
		 * @return {string} MGRS string for the given UTM location.
		 */
		function encode(utm, accuracy) {
		  // prepend with leading zeroes
		  var seasting = "00000" + utm.easting,
		    snorthing = "00000" + utm.northing;
	
		  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
		}
	
		/**
		 * Get the two letter 100k designator for a given UTM easting,
		 * northing and zone number value.
		 *
		 * @private
		 * @param {number} easting
		 * @param {number} northing
		 * @param {number} zoneNumber
		 * @return the two letter 100k designator for the given UTM location.
		 */
		function get100kID(easting, northing, zoneNumber) {
		  var setParm = get100kSetForZone(zoneNumber);
		  var setColumn = Math.floor(easting / 100000);
		  var setRow = Math.floor(northing / 100000) % 20;
		  return getLetter100kID(setColumn, setRow, setParm);
		}
	
		/**
		 * Given a UTM zone number, figure out the MGRS 100K set it is in.
		 *
		 * @private
		 * @param {number} i An UTM zone number.
		 * @return {number} the 100k set the UTM zone is in.
		 */
		function get100kSetForZone(i) {
		  var setParm = i % NUM_100K_SETS;
		  if (setParm === 0) {
		    setParm = NUM_100K_SETS;
		  }
	
		  return setParm;
		}
	
		/**
		 * Get the two-letter MGRS 100k designator given information
		 * translated from the UTM northing, easting and zone number.
		 *
		 * @private
		 * @param {number} column the column index as it relates to the MGRS
		 *        100k set spreadsheet, created from the UTM easting.
		 *        Values are 1-8.
		 * @param {number} row the row index as it relates to the MGRS 100k set
		 *        spreadsheet, created from the UTM northing value. Values
		 *        are from 0-19.
		 * @param {number} parm the set block, as it relates to the MGRS 100k set
		 *        spreadsheet, created from the UTM zone. Values are from
		 *        1-60.
		 * @return two letter MGRS 100k code.
		 */
		function getLetter100kID(column, row, parm) {
		  // colOrigin and rowOrigin are the letters at the origin of the set
		  var index = parm - 1;
		  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
		  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
	
		  // colInt and rowInt are the letters to build to return
		  var colInt = colOrigin + column - 1;
		  var rowInt = rowOrigin + row;
		  var rollover = false;
	
		  if (colInt > Z) {
		    colInt = colInt - Z + A - 1;
		    rollover = true;
		  }
	
		  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
		    colInt++;
		  }
	
		  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
		    colInt++;
	
		    if (colInt === I) {
		      colInt++;
		    }
		  }
	
		  if (colInt > Z) {
		    colInt = colInt - Z + A - 1;
		  }
	
		  if (rowInt > V) {
		    rowInt = rowInt - V + A - 1;
		    rollover = true;
		  }
		  else {
		    rollover = false;
		  }
	
		  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
		    rowInt++;
		  }
	
		  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
		    rowInt++;
	
		    if (rowInt === I) {
		      rowInt++;
		    }
		  }
	
		  if (rowInt > V) {
		    rowInt = rowInt - V + A - 1;
		  }
	
		  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
		  return twoLetter;
		}
	
		/**
		 * Decode the UTM parameters from a MGRS string.
		 *
		 * @private
		 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
		 * @return {object} An object literal with easting, northing, zoneLetter,
		 *     zoneNumber and accuracy (in meters) properties.
		 */
		function decode(mgrsString) {
	
		  if (mgrsString && mgrsString.length === 0) {
		    throw ("MGRSPoint coverting from nothing");
		  }
	
		  var length = mgrsString.length;
	
		  var hunK = null;
		  var sb = "";
		  var testChar;
		  var i = 0;
	
		  // get Zone number
		  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
		    if (i >= 2) {
		      throw ("MGRSPoint bad conversion from: " + mgrsString);
		    }
		    sb += testChar;
		    i++;
		  }
	
		  var zoneNumber = parseInt(sb, 10);
	
		  if (i === 0 || i + 3 > length) {
		    // A good MGRS string has to be 4-5 digits long,
		    // ##AAA/#AAA at least.
		    throw ("MGRSPoint bad conversion from: " + mgrsString);
		  }
	
		  var zoneLetter = mgrsString.charAt(i++);
	
		  // Should we check the zone letter here? Why not.
		  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
		    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
		  }
	
		  hunK = mgrsString.substring(i, i += 2);
	
		  var set = get100kSetForZone(zoneNumber);
	
		  var east100k = getEastingFromChar(hunK.charAt(0), set);
		  var north100k = getNorthingFromChar(hunK.charAt(1), set);
	
		  // We have a bug where the northing may be 2000000 too low.
		  // How
		  // do we know when to roll over?
	
		  while (north100k < getMinNorthing(zoneLetter)) {
		    north100k += 2000000;
		  }
	
		  // calculate the char index for easting/northing separator
		  var remainder = length - i;
	
		  if (remainder % 2 !== 0) {
		    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
		  }
	
		  var sep = remainder / 2;
	
		  var sepEasting = 0.0;
		  var sepNorthing = 0.0;
		  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
		  if (sep > 0) {
		    accuracyBonus = 100000.0 / Math.pow(10, sep);
		    sepEastingString = mgrsString.substring(i, i + sep);
		    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
		    sepNorthingString = mgrsString.substring(i + sep);
		    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
		  }
	
		  easting = sepEasting + east100k;
		  northing = sepNorthing + north100k;
	
		  return {
		    easting: easting,
		    northing: northing,
		    zoneLetter: zoneLetter,
		    zoneNumber: zoneNumber,
		    accuracy: accuracyBonus
		  };
		}
	
		/**
		 * Given the first letter from a two-letter MGRS 100k zone, and given the
		 * MGRS table set for the zone number, figure out the easting value that
		 * should be added to the other, secondary easting value.
		 *
		 * @private
		 * @param {char} e The first letter from a two-letter MGRS 100k zone.
		 * @param {number} set The MGRS table set for the zone number.
		 * @return {number} The easting value for the given letter and set.
		 */
		function getEastingFromChar(e, set) {
		  // colOrigin is the letter at the origin of the set for the
		  // column
		  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
		  var eastingValue = 100000.0;
		  var rewindMarker = false;
	
		  while (curCol !== e.charCodeAt(0)) {
		    curCol++;
		    if (curCol === I) {
		      curCol++;
		    }
		    if (curCol === O) {
		      curCol++;
		    }
		    if (curCol > Z) {
		      if (rewindMarker) {
		        throw ("Bad character: " + e);
		      }
		      curCol = A;
		      rewindMarker = true;
		    }
		    eastingValue += 100000.0;
		  }
	
		  return eastingValue;
		}
	
		/**
		 * Given the second letter from a two-letter MGRS 100k zone, and given the
		 * MGRS table set for the zone number, figure out the northing value that
		 * should be added to the other, secondary northing value. You have to
		 * remember that Northings are determined from the equator, and the vertical
		 * cycle of letters mean a 2000000 additional northing meters. This happens
		 * approx. every 18 degrees of latitude. This method does *NOT* count any
		 * additional northings. You have to figure out how many 2000000 meters need
		 * to be added for the zone letter of the MGRS coordinate.
		 *
		 * @private
		 * @param {char} n Second letter of the MGRS 100k zone
		 * @param {number} set The MGRS table set number, which is dependent on the
		 *     UTM zone number.
		 * @return {number} The northing value for the given letter and set.
		 */
		function getNorthingFromChar(n, set) {
	
		  if (n > 'V') {
		    throw ("MGRSPoint given invalid Northing " + n);
		  }
	
		  // rowOrigin is the letter at the origin of the set for the
		  // column
		  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
		  var northingValue = 0.0;
		  var rewindMarker = false;
	
		  while (curRow !== n.charCodeAt(0)) {
		    curRow++;
		    if (curRow === I) {
		      curRow++;
		    }
		    if (curRow === O) {
		      curRow++;
		    }
		    // fixing a bug making whole application hang in this loop
		    // when 'n' is a wrong character
		    if (curRow > V) {
		      if (rewindMarker) { // making sure that this loop ends
		        throw ("Bad character: " + n);
		      }
		      curRow = A;
		      rewindMarker = true;
		    }
		    northingValue += 100000.0;
		  }
	
		  return northingValue;
		}
	
		/**
		 * The function getMinNorthing returns the minimum northing value of a MGRS
		 * zone.
		 *
		 * Ported from Geotrans' c Lattitude_Band_Value structure table.
		 *
		 * @private
		 * @param {char} zoneLetter The MGRS zone to get the min northing for.
		 * @return {number}
		 */
		function getMinNorthing(zoneLetter) {
		  var northing;
		  switch (zoneLetter) {
		  case 'C':
		    northing = 1100000.0;
		    break;
		  case 'D':
		    northing = 2000000.0;
		    break;
		  case 'E':
		    northing = 2800000.0;
		    break;
		  case 'F':
		    northing = 3700000.0;
		    break;
		  case 'G':
		    northing = 4600000.0;
		    break;
		  case 'H':
		    northing = 5500000.0;
		    break;
		  case 'J':
		    northing = 6400000.0;
		    break;
		  case 'K':
		    northing = 7300000.0;
		    break;
		  case 'L':
		    northing = 8200000.0;
		    break;
		  case 'M':
		    northing = 9100000.0;
		    break;
		  case 'N':
		    northing = 0.0;
		    break;
		  case 'P':
		    northing = 800000.0;
		    break;
		  case 'Q':
		    northing = 1700000.0;
		    break;
		  case 'R':
		    northing = 2600000.0;
		    break;
		  case 'S':
		    northing = 3500000.0;
		    break;
		  case 'T':
		    northing = 4400000.0;
		    break;
		  case 'U':
		    northing = 5300000.0;
		    break;
		  case 'V':
		    northing = 6200000.0;
		    break;
		  case 'W':
		    northing = 7000000.0;
		    break;
		  case 'X':
		    northing = 7900000.0;
		    break;
		  default:
		    northing = -1.0;
		  }
		  if (northing >= 0.0) {
		    return northing;
		  }
		  else {
		    throw ("Invalid zone letter: " + zoneLetter);
		  }
	
		}
	
		function Point(x, y, z) {
		  if (!(this instanceof Point)) {
		    return new Point(x, y, z);
		  }
		  if (Array.isArray(x)) {
		    this.x = x[0];
		    this.y = x[1];
		    this.z = x[2] || 0.0;
		  } else if(typeof x === 'object') {
		    this.x = x.x;
		    this.y = x.y;
		    this.z = x.z || 0.0;
		  } else if (typeof x === 'string' && typeof y === 'undefined') {
		    var coords = x.split(',');
		    this.x = parseFloat(coords[0], 10);
		    this.y = parseFloat(coords[1], 10);
		    this.z = parseFloat(coords[2], 10) || 0.0;
		  } else {
		    this.x = x;
		    this.y = y;
		    this.z = z || 0.0;
		  }
		  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
		}
	
		Point.fromMGRS = function(mgrsStr) {
		  return new Point(toPoint$1(mgrsStr));
		};
		Point.prototype.toMGRS = function(accuracy) {
		  return forward$1([this.x, this.y], accuracy);
		};
	
		var version = "2.4.3";
	
		var C00 = 1;
		var C02 = 0.25;
		var C04 = 0.046875;
		var C06 = 0.01953125;
		var C08 = 0.01068115234375;
		var C22 = 0.75;
		var C44 = 0.46875;
		var C46 = 0.01302083333333333333;
		var C48 = 0.00712076822916666666;
		var C66 = 0.36458333333333333333;
		var C68 = 0.00569661458333333333;
		var C88 = 0.3076171875;
	
		var pj_enfn = function(es) {
		  var en = [];
		  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
		  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
		  var t = es * es;
		  en[2] = t * (C44 - es * (C46 + es * C48));
		  t *= es;
		  en[3] = t * (C66 - es * C68);
		  en[4] = t * es * C88;
		  return en;
		};
	
		var pj_mlfn = function(phi, sphi, cphi, en) {
		  cphi *= sphi;
		  sphi *= sphi;
		  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
		};
	
		var MAX_ITER = 20;
	
		var pj_inv_mlfn = function(arg, es, en) {
		  var k = 1 / (1 - es);
		  var phi = arg;
		  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
		    var s = Math.sin(phi);
		    var t = 1 - es * s * s;
		    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
		    //phi -= t * (t * Math.sqrt(t)) * k;
		    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
		    phi -= t;
		    if (Math.abs(t) < EPSLN) {
		      return phi;
		    }
		  }
		  //..reportError("cass:pj_inv_mlfn: Convergence error");
		  return phi;
		};
	
		// Heavily based on this tmerc projection implementation
		// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js
	
		function init$2() {
		  this.x0 = this.x0 !== undefined ? this.x0 : 0;
		  this.y0 = this.y0 !== undefined ? this.y0 : 0;
		  this.long0 = this.long0 !== undefined ? this.long0 : 0;
		  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
	
		  if (this.es) {
		    this.en = pj_enfn(this.es);
		    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
		  }
		}
	
		/**
		    Transverse Mercator Forward  - long/lat to x/y
		    long/lat in radians
		  */
		function forward$2(p) {
		  var lon = p.x;
		  var lat = p.y;
	
		  var delta_lon = adjust_lon(lon - this.long0);
		  var con;
		  var x, y;
		  var sin_phi = Math.sin(lat);
		  var cos_phi = Math.cos(lat);
	
		  if (!this.es) {
		    var b = cos_phi * Math.sin(delta_lon);
	
		    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
		      return (93);
		    }
		    else {
		      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
		      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
		      b = Math.abs(y);
	
		      if (b >= 1) {
		        if ((b - 1) > EPSLN) {
		          return (93);
		        }
		        else {
		          y = 0;
		        }
		      }
		      else {
		        y = Math.acos(y);
		      }
	
		      if (lat < 0) {
		        y = -y;
		      }
	
		      y = this.a * this.k0 * (y - this.lat0) + this.y0;
		    }
		  }
		  else {
		    var al = cos_phi * delta_lon;
		    var als = Math.pow(al, 2);
		    var c = this.ep2 * Math.pow(cos_phi, 2);
		    var cs = Math.pow(c, 2);
		    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
		    var t = Math.pow(tq, 2);
		    var ts = Math.pow(t, 2);
		    con = 1 - this.es * Math.pow(sin_phi, 2);
		    al = al / Math.sqrt(con);
		    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
	
		    x = this.a * (this.k0 * al * (1 +
		      als / 6 * (1 - t + c +
		      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
		      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
		      this.x0;
	
		    y = this.a * (this.k0 * (ml - this.ml0 +
		      sin_phi * delta_lon * al / 2 * (1 +
		      als / 12 * (5 - t + 9 * c + 4 * cs +
		      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
		      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
		      this.y0;
		  }
	
		  p.x = x;
		  p.y = y;
	
		  return p;
		}
	
		/**
		    Transverse Mercator Inverse  -  x/y to long/lat
		  */
		function inverse$2(p) {
		  var con, phi;
		  var lat, lon;
		  var x = (p.x - this.x0) * (1 / this.a);
		  var y = (p.y - this.y0) * (1 / this.a);
	
		  if (!this.es) {
		    var f = Math.exp(x / this.k0);
		    var g = 0.5 * (f - 1 / f);
		    var temp = this.lat0 + y / this.k0;
		    var h = Math.cos(temp);
		    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
		    lat = Math.asin(con);
	
		    if (y < 0) {
		      lat = -lat;
		    }
	
		    if ((g === 0) && (h === 0)) {
		      lon = 0;
		    }
		    else {
		      lon = adjust_lon(Math.atan2(g, h) + this.long0);
		    }
		  }
		  else { // ellipsoidal form
		    con = this.ml0 + y / this.k0;
		    phi = pj_inv_mlfn(con, this.es, this.en);
	
		    if (Math.abs(phi) < HALF_PI) {
		      var sin_phi = Math.sin(phi);
		      var cos_phi = Math.cos(phi);
		      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
		      var c = this.ep2 * Math.pow(cos_phi, 2);
		      var cs = Math.pow(c, 2);
		      var t = Math.pow(tan_phi, 2);
		      var ts = Math.pow(t, 2);
		      con = 1 - this.es * Math.pow(sin_phi, 2);
		      var d = x * Math.sqrt(con) / this.k0;
		      var ds = Math.pow(d, 2);
		      con = con * tan_phi;
	
		      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
		        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
		        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
		        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
	
		      lon = adjust_lon(this.long0 + (d * (1 -
		        ds / 6 * (1 + 2 * t + c -
		        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
		        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
		    }
		    else {
		      lat = HALF_PI * sign(y);
		      lon = 0;
		    }
		  }
	
		  p.x = lon;
		  p.y = lat;
	
		  return p;
		}
	
		var names$3 = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
		var tmerc = {
		  init: init$2,
		  forward: forward$2,
		  inverse: inverse$2,
		  names: names$3
		};
	
		var sinh = function(x) {
		  var r = Math.exp(x);
		  r = (r - 1 / r) / 2;
		  return r;
		};
	
		var hypot = function(x, y) {
		  x = Math.abs(x);
		  y = Math.abs(y);
		  var a = Math.max(x, y);
		  var b = Math.min(x, y) / (a ? a : 1);
	
		  return a * Math.sqrt(1 + Math.pow(b, 2));
		};
	
		var log1py = function(x) {
		  var y = 1 + x;
		  var z = y - 1;
	
		  return z === 0 ? x : x * Math.log(y) / z;
		};
	
		var asinhy = function(x) {
		  var y = Math.abs(x);
		  y = log1py(y * (1 + y / (hypot(1, y) + 1)));
	
		  return x < 0 ? -y : y;
		};
	
		var gatg = function(pp, B) {
		  var cos_2B = 2 * Math.cos(2 * B);
		  var i = pp.length - 1;
		  var h1 = pp[i];
		  var h2 = 0;
		  var h;
	
		  while (--i >= 0) {
		    h = -h2 + cos_2B * h1 + pp[i];
		    h2 = h1;
		    h1 = h;
		  }
	
		  return (B + h * Math.sin(2 * B));
		};
	
		var clens = function(pp, arg_r) {
		  var r = 2 * Math.cos(arg_r);
		  var i = pp.length - 1;
		  var hr1 = pp[i];
		  var hr2 = 0;
		  var hr;
	
		  while (--i >= 0) {
		    hr = -hr2 + r * hr1 + pp[i];
		    hr2 = hr1;
		    hr1 = hr;
		  }
	
		  return Math.sin(arg_r) * hr;
		};
	
		var cosh = function(x) {
		  var r = Math.exp(x);
		  r = (r + 1 / r) / 2;
		  return r;
		};
	
		var clens_cmplx = function(pp, arg_r, arg_i) {
		  var sin_arg_r = Math.sin(arg_r);
		  var cos_arg_r = Math.cos(arg_r);
		  var sinh_arg_i = sinh(arg_i);
		  var cosh_arg_i = cosh(arg_i);
		  var r = 2 * cos_arg_r * cosh_arg_i;
		  var i = -2 * sin_arg_r * sinh_arg_i;
		  var j = pp.length - 1;
		  var hr = pp[j];
		  var hi1 = 0;
		  var hr1 = 0;
		  var hi = 0;
		  var hr2;
		  var hi2;
	
		  while (--j >= 0) {
		    hr2 = hr1;
		    hi2 = hi1;
		    hr1 = hr;
		    hi1 = hi;
		    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
		    hi = -hi2 + i * hr1 + r * hi1;
		  }
	
		  r = sin_arg_r * cosh_arg_i;
		  i = cos_arg_r * sinh_arg_i;
	
		  return [r * hr - i * hi, r * hi + i * hr];
		};
	
		// Heavily based on this etmerc projection implementation
		// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js
	
		function init$3() {
		  if (this.es === undefined || this.es <= 0) {
		    throw new Error('incorrect elliptical usage');
		  }
	
		  this.x0 = this.x0 !== undefined ? this.x0 : 0;
		  this.y0 = this.y0 !== undefined ? this.y0 : 0;
		  this.long0 = this.long0 !== undefined ? this.long0 : 0;
		  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
	
		  this.cgb = [];
		  this.cbg = [];
		  this.utg = [];
		  this.gtu = [];
	
		  var f = this.es / (1 + Math.sqrt(1 - this.es));
		  var n = f / (2 - f);
		  var np = n;
	
		  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
		  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
	
		  np = np * n;
		  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
		  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
	
		  np = np * n;
		  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
		  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
	
		  np = np * n;
		  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
		  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));
	
		  np = np * n;
		  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
		  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
	
		  np = np * n;
		  this.cgb[5] = np * (601676 / 22275);
		  this.cbg[5] = np * (444337 / 155925);
	
		  np = Math.pow(n, 2);
		  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
	
		  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
		  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
	
		  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
		  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
	
		  np = np * n;
		  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
		  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
	
		  np = np * n;
		  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
		  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
	
		  np = np * n;
		  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
		  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
	
		  np = np * n;
		  this.utg[5] = np * (-20648693 / 638668800);
		  this.gtu[5] = np * (212378941 / 319334400);
	
		  var Z = gatg(this.cbg, this.lat0);
		  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
		}
	
		function forward$3(p) {
		  var Ce = adjust_lon(p.x - this.long0);
		  var Cn = p.y;
	
		  Cn = gatg(this.cbg, Cn);
		  var sin_Cn = Math.sin(Cn);
		  var cos_Cn = Math.cos(Cn);
		  var sin_Ce = Math.sin(Ce);
		  var cos_Ce = Math.cos(Ce);
	
		  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
		  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
		  Ce = asinhy(Math.tan(Ce));
	
		  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
	
		  Cn = Cn + tmp[0];
		  Ce = Ce + tmp[1];
	
		  var x;
		  var y;
	
		  if (Math.abs(Ce) <= 2.623395162778) {
		    x = this.a * (this.Qn * Ce) + this.x0;
		    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
		  }
		  else {
		    x = Infinity;
		    y = Infinity;
		  }
	
		  p.x = x;
		  p.y = y;
	
		  return p;
		}
	
		function inverse$3(p) {
		  var Ce = (p.x - this.x0) * (1 / this.a);
		  var Cn = (p.y - this.y0) * (1 / this.a);
	
		  Cn = (Cn - this.Zb) / this.Qn;
		  Ce = Ce / this.Qn;
	
		  var lon;
		  var lat;
	
		  if (Math.abs(Ce) <= 2.623395162778) {
		    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
	
		    Cn = Cn + tmp[0];
		    Ce = Ce + tmp[1];
		    Ce = Math.atan(sinh(Ce));
	
		    var sin_Cn = Math.sin(Cn);
		    var cos_Cn = Math.cos(Cn);
		    var sin_Ce = Math.sin(Ce);
		    var cos_Ce = Math.cos(Ce);
	
		    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
		    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
	
		    lon = adjust_lon(Ce + this.long0);
		    lat = gatg(this.cgb, Cn);
		  }
		  else {
		    lon = Infinity;
		    lat = Infinity;
		  }
	
		  p.x = lon;
		  p.y = lat;
	
		  return p;
		}
	
		var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
		var etmerc = {
		  init: init$3,
		  forward: forward$3,
		  inverse: inverse$3,
		  names: names$4
		};
	
		var adjust_zone = function(zone, lon) {
		  if (zone === undefined) {
		    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
	
		    if (zone < 0) {
		      return 0;
		    } else if (zone > 60) {
		      return 60;
		    }
		  }
		  return zone;
		};
	
		var dependsOn = 'etmerc';
		function init$4() {
		  var zone = adjust_zone(this.zone, this.long0);
		  if (zone === undefined) {
		    throw new Error('unknown utm zone');
		  }
		  this.lat0 = 0;
		  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
		  this.x0 = 500000;
		  this.y0 = this.utmSouth ? 10000000 : 0;
		  this.k0 = 0.9996;
	
		  etmerc.init.apply(this);
		  this.forward = etmerc.forward;
		  this.inverse = etmerc.inverse;
		}
	
		var names$5 = ["Universal Transverse Mercator System", "utm"];
		var utm = {
		  init: init$4,
		  names: names$5,
		  dependsOn: dependsOn
		};
	
		var srat = function(esinp, exp) {
		  return (Math.pow((1 - esinp) / (1 + esinp), exp));
		};
	
		var MAX_ITER$1 = 20;
		function init$6() {
		  var sphi = Math.sin(this.lat0);
		  var cphi = Math.cos(this.lat0);
		  cphi *= cphi;
		  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
		  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
		  this.phic0 = Math.asin(sphi / this.C);
		  this.ratexp = 0.5 * this.C * this.e;
		  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
		}
	
		function forward$5(p) {
		  var lon = p.x;
		  var lat = p.y;
	
		  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
		  p.x = this.C * lon;
		  return p;
		}
	
		function inverse$5(p) {
		  var DEL_TOL = 1e-14;
		  var lon = p.x / this.C;
		  var lat = p.y;
		  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
		  for (var i = MAX_ITER$1; i > 0; --i) {
		    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
		    if (Math.abs(lat - p.y) < DEL_TOL) {
		      break;
		    }
		    p.y = lat;
		  }
		  /* convergence failed */
		  if (!i) {
		    return null;
		  }
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$7 = ["gauss"];
		var gauss = {
		  init: init$6,
		  forward: forward$5,
		  inverse: inverse$5,
		  names: names$7
		};
	
		function init$5() {
		  gauss.init.apply(this);
		  if (!this.rc) {
		    return;
		  }
		  this.sinc0 = Math.sin(this.phic0);
		  this.cosc0 = Math.cos(this.phic0);
		  this.R2 = 2 * this.rc;
		  if (!this.title) {
		    this.title = "Oblique Stereographic Alternative";
		  }
		}
	
		function forward$4(p) {
		  var sinc, cosc, cosl, k;
		  p.x = adjust_lon(p.x - this.long0);
		  gauss.forward.apply(this, [p]);
		  sinc = Math.sin(p.y);
		  cosc = Math.cos(p.y);
		  cosl = Math.cos(p.x);
		  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
		  p.x = k * cosc * Math.sin(p.x);
		  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
		  p.x = this.a * p.x + this.x0;
		  p.y = this.a * p.y + this.y0;
		  return p;
		}
	
		function inverse$4(p) {
		  var sinc, cosc, lon, lat, rho;
		  p.x = (p.x - this.x0) / this.a;
		  p.y = (p.y - this.y0) / this.a;
	
		  p.x /= this.k0;
		  p.y /= this.k0;
		  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
		    var c = 2 * Math.atan2(rho, this.R2);
		    sinc = Math.sin(c);
		    cosc = Math.cos(c);
		    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
		    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
		  }
		  else {
		    lat = this.phic0;
		    lon = 0;
		  }
	
		  p.x = lon;
		  p.y = lat;
		  gauss.inverse.apply(this, [p]);
		  p.x = adjust_lon(p.x + this.long0);
		  return p;
		}
	
		var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];
		var sterea = {
		  init: init$5,
		  forward: forward$4,
		  inverse: inverse$4,
		  names: names$6
		};
	
		function ssfn_(phit, sinphi, eccen) {
		  sinphi *= eccen;
		  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
		}
	
		function init$7() {
		  this.coslat0 = Math.cos(this.lat0);
		  this.sinlat0 = Math.sin(this.lat0);
		  if (this.sphere) {
		    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
		      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
		    }
		  }
		  else {
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      if (this.lat0 > 0) {
		        //North pole
		        //trace('stere:north pole');
		        this.con = 1;
		      }
		      else {
		        //South pole
		        //trace('stere:south pole');
		        this.con = -1;
		      }
		    }
		    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
		    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
		      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
		    }
		    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
		    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
		    this.cosX0 = Math.cos(this.X0);
		    this.sinX0 = Math.sin(this.X0);
		  }
		}
	
		// Stereographic forward equations--mapping lat,long to x,y
		function forward$6(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var sinlat = Math.sin(lat);
		  var coslat = Math.cos(lat);
		  var A, X, sinX, cosX, ts, rh;
		  var dlon = adjust_lon(lon - this.long0);
	
		  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
		    //case of the origine point
		    //trace('stere:this is the origin point');
		    p.x = NaN;
		    p.y = NaN;
		    return p;
		  }
		  if (this.sphere) {
		    //trace('stere:sphere case');
		    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
		    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
		    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
		    return p;
		  }
		  else {
		    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
		    cosX = Math.cos(X);
		    sinX = Math.sin(X);
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
		      rh = 2 * this.a * this.k0 * ts / this.cons;
		      p.x = this.x0 + rh * Math.sin(lon - this.long0);
		      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
		      //trace(p.toString());
		      return p;
		    }
		    else if (Math.abs(this.sinlat0) < EPSLN) {
		      //Eq
		      //trace('stere:equateur');
		      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
		      p.y = A * sinX;
		    }
		    else {
		      //other case
		      //trace('stere:normal case');
		      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
		      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
		    }
		    p.x = A * cosX * Math.sin(dlon) + this.x0;
		  }
		  //trace(p.toString());
		  return p;
		}
	
		//* Stereographic inverse equations--mapping x,y to lat/long
		function inverse$6(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var lon, lat, ts, ce, Chi;
		  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
		  if (this.sphere) {
		    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
		    lon = this.long0;
		    lat = this.lat0;
		    if (rh <= EPSLN) {
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
		    if (Math.abs(this.coslat0) < EPSLN) {
		      if (this.lat0 > 0) {
		        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
		      }
		      else {
		        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
		      }
		    }
		    else {
		      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
		    }
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      if (rh <= EPSLN) {
		        lat = this.lat0;
		        lon = this.long0;
		        p.x = lon;
		        p.y = lat;
		        //trace(p.toString());
		        return p;
		      }
		      p.x *= this.con;
		      p.y *= this.con;
		      ts = rh * this.cons / (2 * this.a * this.k0);
		      lat = this.con * phi2z(this.e, ts);
		      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
		    }
		    else {
		      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
		      lon = this.long0;
		      if (rh <= EPSLN) {
		        Chi = this.X0;
		      }
		      else {
		        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
		        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
		      }
		      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
		    }
		  }
		  p.x = lon;
		  p.y = lat;
	
		  //trace(p.toString());
		  return p;
	
		}
	
		var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
		var stere = {
		  init: init$7,
		  forward: forward$6,
		  inverse: inverse$6,
		  names: names$8,
		  ssfn_: ssfn_
		};
	
		/*
		  references:
		    Formules et constantes pour le Calcul pour la
		    projection cylindrique conforme  axe oblique et pour la transformation entre
		    des systmes de rfrence.
		    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
		  */
	
		function init$8() {
		  var phy0 = this.lat0;
		  this.lambda0 = this.long0;
		  var sinPhy0 = Math.sin(phy0);
		  var semiMajorAxis = this.a;
		  var invF = this.rf;
		  var flattening = 1 / invF;
		  var e2 = 2 * flattening - Math.pow(flattening, 2);
		  var e = this.e = Math.sqrt(e2);
		  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
		  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
		  this.b0 = Math.asin(sinPhy0 / this.alpha);
		  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
		  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
		  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
		  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
		}
	
		function forward$7(p) {
		  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
		  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
		  var S = -this.alpha * (Sa1 + Sa2) + this.K;
	
		  // spheric latitude
		  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
	
		  // spheric longitude
		  var I = this.alpha * (p.x - this.lambda0);
	
		  // psoeudo equatorial rotation
		  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
	
		  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
	
		  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
		  p.x = this.R * rotI + this.x0;
		  return p;
		}
	
		function inverse$7(p) {
		  var Y = p.x - this.x0;
		  var X = p.y - this.y0;
	
		  var rotI = Y / this.R;
		  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
	
		  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
		  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
	
		  var lambda = this.lambda0 + I / this.alpha;
	
		  var S = 0;
		  var phy = b;
		  var prevPhy = -1000;
		  var iteration = 0;
		  while (Math.abs(phy - prevPhy) > 0.0000001) {
		    if (++iteration > 20) {
		      //...reportError("omercFwdInfinity");
		      return;
		    }
		    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
		    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
		    prevPhy = phy;
		    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
		  }
	
		  p.x = lambda;
		  p.y = phy;
		  return p;
		}
	
		var names$9 = ["somerc"];
		var somerc = {
		  init: init$8,
		  forward: forward$7,
		  inverse: inverse$7,
		  names: names$9
		};
	
		/* Initialize the Oblique Mercator  projection
		    ------------------------------------------*/
		function init$9() {
		  this.no_off = this.no_off || false;
		  this.no_rot = this.no_rot || false;
	
		  if (isNaN(this.k0)) {
		    this.k0 = 1;
		  }
		  var sinlat = Math.sin(this.lat0);
		  var coslat = Math.cos(this.lat0);
		  var con = this.e * sinlat;
	
		  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
		  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
		  var t0 = tsfnz(this.e, this.lat0, sinlat);
		  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
		  if (dl * dl < 1) {
		    dl = 1;
		  }
		  var fl;
		  var gl;
		  if (!isNaN(this.longc)) {
		    //Central point and azimuth method
	
		    if (this.lat0 >= 0) {
		      fl = dl + Math.sqrt(dl * dl - 1);
		    }
		    else {
		      fl = dl - Math.sqrt(dl * dl - 1);
		    }
		    this.el = fl * Math.pow(t0, this.bl);
		    gl = 0.5 * (fl - 1 / fl);
		    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
		    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;
	
		  }
		  else {
		    //2 points method
		    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
		    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
		    if (this.lat0 >= 0) {
		      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
		    }
		    else {
		      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
		    }
		    var hl = Math.pow(t1, this.bl);
		    var ll = Math.pow(t2, this.bl);
		    fl = this.el / hl;
		    gl = 0.5 * (fl - 1 / fl);
		    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
		    var pl = (ll - hl) / (ll + hl);
		    var dlon12 = adjust_lon(this.long1 - this.long2);
		    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
		    this.long0 = adjust_lon(this.long0);
		    var dlon10 = adjust_lon(this.long1 - this.long0);
		    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
		    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
		  }
	
		  if (this.no_off) {
		    this.uc = 0;
		  }
		  else {
		    if (this.lat0 >= 0) {
		      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
		    }
		    else {
		      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
		    }
		  }
	
		}
	
		/* Oblique Mercator forward equations--mapping lat,long to x,y
		    ----------------------------------------------------------*/
		function forward$8(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var dlon = adjust_lon(lon - this.long0);
		  var us, vs;
		  var con;
		  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
		    if (lat > 0) {
		      con = -1;
		    }
		    else {
		      con = 1;
		    }
		    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
		    us = -1 * con * HALF_PI * this.al / this.bl;
		  }
		  else {
		    var t = tsfnz(this.e, lat, Math.sin(lat));
		    var ql = this.el / Math.pow(t, this.bl);
		    var sl = 0.5 * (ql - 1 / ql);
		    var tl = 0.5 * (ql + 1 / ql);
		    var vl = Math.sin(this.bl * (dlon));
		    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
		    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
		      vs = Number.POSITIVE_INFINITY;
		    }
		    else {
		      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
		    }
		    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
		      us = this.al * this.bl * (dlon);
		    }
		    else {
		      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
		    }
		  }
	
		  if (this.no_rot) {
		    p.x = this.x0 + us;
		    p.y = this.y0 + vs;
		  }
		  else {
	
		    us -= this.uc;
		    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
		    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
		  }
		  return p;
		}
	
		function inverse$8(p) {
		  var us, vs;
		  if (this.no_rot) {
		    vs = p.y - this.y0;
		    us = p.x - this.x0;
		  }
		  else {
		    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
		    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
		    us += this.uc;
		  }
		  var qp = Math.exp(-1 * this.bl * vs / this.al);
		  var sp = 0.5 * (qp - 1 / qp);
		  var tp = 0.5 * (qp + 1 / qp);
		  var vp = Math.sin(this.bl * us / this.al);
		  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
		  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
		  if (Math.abs(up - 1) < EPSLN) {
		    p.x = this.long0;
		    p.y = HALF_PI;
		  }
		  else if (Math.abs(up + 1) < EPSLN) {
		    p.x = this.long0;
		    p.y = -1 * HALF_PI;
		  }
		  else {
		    p.y = phi2z(this.e, ts);
		    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
		  }
		  return p;
		}
	
		var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
		var omerc = {
		  init: init$9,
		  forward: forward$8,
		  inverse: inverse$8,
		  names: names$10
		};
	
		function init$10() {
	
		  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
		  //double c_lat;                   /* center latitude                      */
		  //double c_lon;                   /* center longitude                     */
		  //double lat1;                    /* first standard parallel              */
		  //double lat2;                    /* second standard parallel             */
		  //double r_maj;                   /* major axis                           */
		  //double r_min;                   /* minor axis                           */
		  //double false_east;              /* x offset in meters                   */
		  //double false_north;             /* y offset in meters                   */
	
		  if (!this.lat2) {
		    this.lat2 = this.lat1;
		  } //if lat2 is not defined
		  if (!this.k0) {
		    this.k0 = 1;
		  }
		  this.x0 = this.x0 || 0;
		  this.y0 = this.y0 || 0;
		  // Standard Parallels cannot be equal and on opposite sides of the equator
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
	
		  var temp = this.b / this.a;
		  this.e = Math.sqrt(1 - temp * temp);
	
		  var sin1 = Math.sin(this.lat1);
		  var cos1 = Math.cos(this.lat1);
		  var ms1 = msfnz(this.e, sin1, cos1);
		  var ts1 = tsfnz(this.e, this.lat1, sin1);
	
		  var sin2 = Math.sin(this.lat2);
		  var cos2 = Math.cos(this.lat2);
		  var ms2 = msfnz(this.e, sin2, cos2);
		  var ts2 = tsfnz(this.e, this.lat2, sin2);
	
		  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
	
		  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
		    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
		  }
		  else {
		    this.ns = sin1;
		  }
		  if (isNaN(this.ns)) {
		    this.ns = sin1;
		  }
		  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
		  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
		  if (!this.title) {
		    this.title = "Lambert Conformal Conic";
		  }
		}
	
		// Lambert Conformal conic forward equations--mapping lat,long to x,y
		// -----------------------------------------------------------------
		function forward$9(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  // singular cases :
		  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
		    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
		  }
	
		  var con = Math.abs(Math.abs(lat) - HALF_PI);
		  var ts, rh1;
		  if (con > EPSLN) {
		    ts = tsfnz(this.e, lat, Math.sin(lat));
		    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
		  }
		  else {
		    con = lat * this.ns;
		    if (con <= 0) {
		      return null;
		    }
		    rh1 = 0;
		  }
		  var theta = this.ns * adjust_lon(lon - this.long0);
		  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
		  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
	
		  return p;
		}
	
		// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
		// -----------------------------------------------------------------
		function inverse$9(p) {
	
		  var rh1, con, ts;
		  var lat, lon;
		  var x = (p.x - this.x0) / this.k0;
		  var y = (this.rh - (p.y - this.y0) / this.k0);
		  if (this.ns > 0) {
		    rh1 = Math.sqrt(x * x + y * y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(x * x + y * y);
		    con = -1;
		  }
		  var theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2((con * x), (con * y));
		  }
		  if ((rh1 !== 0) || (this.ns > 0)) {
		    con = 1 / this.ns;
		    ts = Math.pow((rh1 / (this.a * this.f0)), con);
		    lat = phi2z(this.e, ts);
		    if (lat === -9999) {
		      return null;
		    }
		  }
		  else {
		    lat = -HALF_PI;
		  }
		  lon = adjust_lon(theta / this.ns + this.long0);
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$11 = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
		var lcc = {
		  init: init$10,
		  forward: forward$9,
		  inverse: inverse$9,
		  names: names$11
		};
	
		function init$11() {
		  this.a = 6377397.155;
		  this.es = 0.006674372230614;
		  this.e = Math.sqrt(this.es);
		  if (!this.lat0) {
		    this.lat0 = 0.863937979737193;
		  }
		  if (!this.long0) {
		    this.long0 = 0.7417649320975901 - 0.308341501185665;
		  }
		  /* if scale not set default to 0.9999 */
		  if (!this.k0) {
		    this.k0 = 0.9999;
		  }
		  this.s45 = 0.785398163397448; /* 45 */
		  this.s90 = 2 * this.s45;
		  this.fi0 = this.lat0;
		  this.e2 = this.es;
		  this.e = Math.sqrt(this.e2);
		  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
		  this.uq = 1.04216856380474;
		  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
		  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
		  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
		  this.k1 = this.k0;
		  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
		  this.s0 = 1.37008346281555;
		  this.n = Math.sin(this.s0);
		  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
		  this.ad = this.s90 - this.uq;
		}
	
		/* ellipsoid */
		/* calculate xy from lat/lon */
		/* Constants, identical to inverse transform function */
		function forward$10(p) {
		  var gfi, u, deltav, s, d, eps, ro;
		  var lon = p.x;
		  var lat = p.y;
		  var delta_lon = adjust_lon(lon - this.long0);
		  /* Transformation */
		  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
		  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
		  deltav = -delta_lon * this.alfa;
		  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
		  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
		  eps = this.n * d;
		  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
		  p.y = ro * Math.cos(eps) / 1;
		  p.x = ro * Math.sin(eps) / 1;
	
		  if (!this.czech) {
		    p.y *= -1;
		    p.x *= -1;
		  }
		  return (p);
		}
	
		/* calculate lat/lon from xy */
		function inverse$10(p) {
		  var u, deltav, s, d, eps, ro, fi1;
		  var ok;
	
		  /* Transformation */
		  /* revert y, x*/
		  var tmp = p.x;
		  p.x = p.y;
		  p.y = tmp;
		  if (!this.czech) {
		    p.y *= -1;
		    p.x *= -1;
		  }
		  ro = Math.sqrt(p.x * p.x + p.y * p.y);
		  eps = Math.atan2(p.y, p.x);
		  d = eps / Math.sin(this.s0);
		  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
		  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
		  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
		  p.x = this.long0 - deltav / this.alfa;
		  fi1 = u;
		  ok = 0;
		  var iter = 0;
		  do {
		    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
		    if (Math.abs(fi1 - p.y) < 0.0000000001) {
		      ok = 1;
		    }
		    fi1 = p.y;
		    iter += 1;
		  } while (ok === 0 && iter < 15);
		  if (iter >= 15) {
		    return null;
		  }
	
		  return (p);
		}
	
		var names$12 = ["Krovak", "krovak"];
		var krovak = {
		  init: init$11,
		  forward: forward$10,
		  inverse: inverse$10,
		  names: names$12
		};
	
		var mlfn = function(e0, e1, e2, e3, phi) {
		  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
		};
	
		var e0fn = function(x) {
		  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
		};
	
		var e1fn = function(x) {
		  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
		};
	
		var e2fn = function(x) {
		  return (0.05859375 * x * x * (1 + 0.75 * x));
		};
	
		var e3fn = function(x) {
		  return (x * x * x * (35 / 3072));
		};
	
		var gN = function(a, e, sinphi) {
		  var temp = e * sinphi;
		  return a / Math.sqrt(1 - temp * temp);
		};
	
		var adjust_lat = function(x) {
		  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
		};
	
		var imlfn = function(ml, e0, e1, e2, e3) {
		  var phi;
		  var dphi;
	
		  phi = ml / e0;
		  for (var i = 0; i < 15; i++) {
		    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }
	
		  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
		  return NaN;
		};
	
		function init$12() {
		  if (!this.sphere) {
		    this.e0 = e0fn(this.es);
		    this.e1 = e1fn(this.es);
		    this.e2 = e2fn(this.es);
		    this.e3 = e3fn(this.es);
		    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
		  }
		}
	
		/* Cassini forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------------------*/
		function forward$11(p) {
	
		  /* Forward equations
		      -----------------*/
		  var x, y;
		  var lam = p.x;
		  var phi = p.y;
		  lam = adjust_lon(lam - this.long0);
	
		  if (this.sphere) {
		    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
		    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
		  }
		  else {
		    //ellipsoid
		    var sinphi = Math.sin(phi);
		    var cosphi = Math.cos(phi);
		    var nl = gN(this.a, this.e, sinphi);
		    var tl = Math.tan(phi) * Math.tan(phi);
		    var al = lam * Math.cos(phi);
		    var asq = al * al;
		    var cl = this.es * cosphi * cosphi / (1 - this.es);
		    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
	
		    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
		    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
	
	
		  }
	
		  p.x = x + this.x0;
		  p.y = y + this.y0;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$11(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var x = p.x / this.a;
		  var y = p.y / this.a;
		  var phi, lam;
	
		  if (this.sphere) {
		    var dd = y + this.lat0;
		    phi = Math.asin(Math.sin(dd) * Math.cos(x));
		    lam = Math.atan2(Math.tan(x), Math.cos(dd));
		  }
		  else {
		    /* ellipsoid */
		    var ml1 = this.ml0 / this.a + y;
		    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
		    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
		      p.x = this.long0;
		      p.y = HALF_PI;
		      if (y < 0) {
		        p.y *= -1;
		      }
		      return p;
		    }
		    var nl1 = gN(this.a, this.e, Math.sin(phi1));
	
		    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
		    var tl1 = Math.pow(Math.tan(phi1), 2);
		    var dl = x * this.a / nl1;
		    var dsq = dl * dl;
		    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
		    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
	
		  }
	
		  p.x = adjust_lon(lam + this.long0);
		  p.y = adjust_lat(phi);
		  return p;
	
		}
	
		var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
		var cass = {
		  init: init$12,
		  forward: forward$11,
		  inverse: inverse$11,
		  names: names$13
		};
	
		var qsfnz = function(eccent, sinphi) {
		  var con;
		  if (eccent > 1.0e-7) {
		    con = eccent * sinphi;
		    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
		  }
		  else {
		    return (2 * sinphi);
		  }
		};
	
		/*
		  reference
		    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
		    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
		  */
	
		var S_POLE = 1;
	
		var N_POLE = 2;
		var EQUIT = 3;
		var OBLIQ = 4;
	
		/* Initialize the Lambert Azimuthal Equal Area projection
		  ------------------------------------------------------*/
		function init$13() {
		  var t = Math.abs(this.lat0);
		  if (Math.abs(t - HALF_PI) < EPSLN) {
		    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
		  }
		  else if (Math.abs(t) < EPSLN) {
		    this.mode = this.EQUIT;
		  }
		  else {
		    this.mode = this.OBLIQ;
		  }
		  if (this.es > 0) {
		    var sinphi;
	
		    this.qp = qsfnz(this.e, 1);
		    this.mmf = 0.5 / (1 - this.es);
		    this.apa = authset(this.es);
		    switch (this.mode) {
		    case this.N_POLE:
		      this.dd = 1;
		      break;
		    case this.S_POLE:
		      this.dd = 1;
		      break;
		    case this.EQUIT:
		      this.rq = Math.sqrt(0.5 * this.qp);
		      this.dd = 1 / this.rq;
		      this.xmf = 1;
		      this.ymf = 0.5 * this.qp;
		      break;
		    case this.OBLIQ:
		      this.rq = Math.sqrt(0.5 * this.qp);
		      sinphi = Math.sin(this.lat0);
		      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
		      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
		      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
		      this.ymf = (this.xmf = this.rq) / this.dd;
		      this.xmf *= this.dd;
		      break;
		    }
		  }
		  else {
		    if (this.mode === this.OBLIQ) {
		      this.sinph0 = Math.sin(this.lat0);
		      this.cosph0 = Math.cos(this.lat0);
		    }
		  }
		}
	
		/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------------------*/
		function forward$12(p) {
	
		  /* Forward equations
		      -----------------*/
		  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
		  var lam = p.x;
		  var phi = p.y;
	
		  lam = adjust_lon(lam - this.long0);
		  if (this.sphere) {
		    sinphi = Math.sin(phi);
		    cosphi = Math.cos(phi);
		    coslam = Math.cos(lam);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
		      if (y <= EPSLN) {
		        return null;
		      }
		      y = Math.sqrt(2 / y);
		      x = y * cosphi * Math.sin(lam);
		      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
		    }
		    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
		      if (this.mode === this.N_POLE) {
		        coslam = -coslam;
		      }
		      if (Math.abs(phi + this.phi0) < EPSLN) {
		        return null;
		      }
		      y = FORTPI - phi * 0.5;
		      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
		      x = y * Math.sin(lam);
		      y *= coslam;
		    }
		  }
		  else {
		    sinb = 0;
		    cosb = 0;
		    b = 0;
		    coslam = Math.cos(lam);
		    sinlam = Math.sin(lam);
		    sinphi = Math.sin(phi);
		    q = qsfnz(this.e, sinphi);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      sinb = q / this.qp;
		      cosb = Math.sqrt(1 - sinb * sinb);
		    }
		    switch (this.mode) {
		    case this.OBLIQ:
		      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
		      break;
		    case this.EQUIT:
		      b = 1 + cosb * coslam;
		      break;
		    case this.N_POLE:
		      b = HALF_PI + phi;
		      q = this.qp - q;
		      break;
		    case this.S_POLE:
		      b = phi - HALF_PI;
		      q = this.qp + q;
		      break;
		    }
		    if (Math.abs(b) < EPSLN) {
		      return null;
		    }
		    switch (this.mode) {
		    case this.OBLIQ:
		    case this.EQUIT:
		      b = Math.sqrt(2 / b);
		      if (this.mode === this.OBLIQ) {
		        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
		      }
		      else {
		        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
		      }
		      x = this.xmf * b * cosb * sinlam;
		      break;
		    case this.N_POLE:
		    case this.S_POLE:
		      if (q >= 0) {
		        x = (b = Math.sqrt(q)) * sinlam;
		        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
		      }
		      else {
		        x = y = 0;
		      }
		      break;
		    }
		  }
	
		  p.x = this.a * x + this.x0;
		  p.y = this.a * y + this.y0;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$12(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var x = p.x / this.a;
		  var y = p.y / this.a;
		  var lam, phi, cCe, sCe, q, rho, ab;
		  if (this.sphere) {
		    var cosz = 0,
		      rh, sinz = 0;
	
		    rh = Math.sqrt(x * x + y * y);
		    phi = rh * 0.5;
		    if (phi > 1) {
		      return null;
		    }
		    phi = 2 * Math.asin(phi);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      sinz = Math.sin(phi);
		      cosz = Math.cos(phi);
		    }
		    switch (this.mode) {
		    case this.EQUIT:
		      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
		      x *= sinz;
		      y = cosz * rh;
		      break;
		    case this.OBLIQ:
		      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
		      x *= sinz * this.cosph0;
		      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
		      break;
		    case this.N_POLE:
		      y = -y;
		      phi = HALF_PI - phi;
		      break;
		    case this.S_POLE:
		      phi -= HALF_PI;
		      break;
		    }
		    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
		  }
		  else {
		    ab = 0;
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      x /= this.dd;
		      y *= this.dd;
		      rho = Math.sqrt(x * x + y * y);
		      if (rho < EPSLN) {
		        p.x = 0;
		        p.y = this.phi0;
		        return p;
		      }
		      sCe = 2 * Math.asin(0.5 * rho / this.rq);
		      cCe = Math.cos(sCe);
		      x *= (sCe = Math.sin(sCe));
		      if (this.mode === this.OBLIQ) {
		        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
		        q = this.qp * ab;
		        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
		      }
		      else {
		        ab = y * sCe / rho;
		        q = this.qp * ab;
		        y = rho * cCe;
		      }
		    }
		    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
		      if (this.mode === this.N_POLE) {
		        y = -y;
		      }
		      q = (x * x + y * y);
		      if (!q) {
		        p.x = 0;
		        p.y = this.phi0;
		        return p;
		      }
		      ab = 1 - q / this.qp;
		      if (this.mode === this.S_POLE) {
		        ab = -ab;
		      }
		    }
		    lam = Math.atan2(x, y);
		    phi = authlat(Math.asin(ab), this.apa);
		  }
	
		  p.x = adjust_lon(this.long0 + lam);
		  p.y = phi;
		  return p;
		}
	
		/* determine latitude from authalic latitude */
		var P00 = 0.33333333333333333333;
	
		var P01 = 0.17222222222222222222;
		var P02 = 0.10257936507936507936;
		var P10 = 0.06388888888888888888;
		var P11 = 0.06640211640211640211;
		var P20 = 0.01641501294219154443;
	
		function authset(es) {
		  var t;
		  var APA = [];
		  APA[0] = es * P00;
		  t = es * es;
		  APA[0] += t * P01;
		  APA[1] = t * P10;
		  t *= es;
		  APA[0] += t * P02;
		  APA[1] += t * P11;
		  APA[2] = t * P20;
		  return APA;
		}
	
		function authlat(beta, APA) {
		  var t = beta + beta;
		  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
		}
	
		var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
		var laea = {
		  init: init$13,
		  forward: forward$12,
		  inverse: inverse$12,
		  names: names$14,
		  S_POLE: S_POLE,
		  N_POLE: N_POLE,
		  EQUIT: EQUIT,
		  OBLIQ: OBLIQ
		};
	
		var asinz = function(x) {
		  if (Math.abs(x) > 1) {
		    x = (x > 1) ? 1 : -1;
		  }
		  return Math.asin(x);
		};
	
		function init$14() {
	
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2);
		  this.e3 = Math.sqrt(this.es);
	
		  this.sin_po = Math.sin(this.lat1);
		  this.cos_po = Math.cos(this.lat1);
		  this.t1 = this.sin_po;
		  this.con = this.sin_po;
		  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
		  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
	
		  this.sin_po = Math.sin(this.lat2);
		  this.cos_po = Math.cos(this.lat2);
		  this.t2 = this.sin_po;
		  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
		  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
	
		  this.sin_po = Math.sin(this.lat0);
		  this.cos_po = Math.cos(this.lat0);
		  this.t3 = this.sin_po;
		  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
	
		  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
		    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
		  }
		  else {
		    this.ns0 = this.con;
		  }
		  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
		  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
		}
	
		/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
		  -------------------------------------------------------------------*/
		function forward$13(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  this.sin_phi = Math.sin(lat);
		  this.cos_phi = Math.cos(lat);
	
		  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
		  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
		  var theta = this.ns0 * adjust_lon(lon - this.long0);
		  var x = rh1 * Math.sin(theta) + this.x0;
		  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$13(p) {
		  var rh1, qs, con, theta, lon, lat;
	
		  p.x -= this.x0;
		  p.y = this.rh - p.y + this.y0;
		  if (this.ns0 >= 0) {
		    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
		    con = -1;
		  }
		  theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2(con * p.x, con * p.y);
		  }
		  con = rh1 * this.ns0 / this.a;
		  if (this.sphere) {
		    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
		  }
		  else {
		    qs = (this.c - con * con) / this.ns0;
		    lat = this.phi1z(this.e3, qs);
		  }
	
		  lon = adjust_lon(theta / this.ns0 + this.long0);
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		/* Function to compute phi1, the latitude for the inverse of the
		   Albers Conical Equal-Area projection.
		-------------------------------------------*/
		function phi1z(eccent, qs) {
		  var sinphi, cosphi, con, com, dphi;
		  var phi = asinz(0.5 * qs);
		  if (eccent < EPSLN) {
		    return phi;
		  }
	
		  var eccnts = eccent * eccent;
		  for (var i = 1; i <= 25; i++) {
		    sinphi = Math.sin(phi);
		    cosphi = Math.cos(phi);
		    con = eccent * sinphi;
		    com = 1 - con * con;
		    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
		    phi = phi + dphi;
		    if (Math.abs(dphi) <= 1e-7) {
		      return phi;
		    }
		  }
		  return null;
		}
	
		var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
		var aea = {
		  init: init$14,
		  forward: forward$13,
		  inverse: inverse$13,
		  names: names$15,
		  phi1z: phi1z
		};
	
		/*
		  reference:
		    Wolfram Mathworld "Gnomonic Projection"
		    http://mathworld.wolfram.com/GnomonicProjection.html
		    Accessed: 12th November 2009
		  */
		function init$15() {
	
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.sin_p14 = Math.sin(this.lat0);
		  this.cos_p14 = Math.cos(this.lat0);
		  // Approximation for projecting points to the horizon (infinity)
		  this.infinity_dist = 1000 * this.a;
		  this.rc = 1;
		}
	
		/* Gnomonic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$14(p) {
		  var sinphi, cosphi; /* sin and cos value        */
		  var dlon; /* delta longitude value      */
		  var coslon; /* cos of longitude        */
		  var ksp; /* scale factor          */
		  var g;
		  var x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  dlon = adjust_lon(lon - this.long0);
	
		  sinphi = Math.sin(lat);
		  cosphi = Math.cos(lat);
	
		  coslon = Math.cos(dlon);
		  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
		  ksp = 1;
		  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
		    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
		    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
		  }
		  else {
	
		    // Point is in the opposing hemisphere and is unprojectable
		    // We still need to return a reasonable point, so we project
		    // to infinity, on a bearing
		    // equivalent to the northern hemisphere equivalent
		    // This is a reasonable approximation for short shapes and lines that
		    // straddle the horizon.
	
		    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
		    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
	
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$14(p) {
		  var rh; /* Rho */
		  var sinc, cosc;
		  var c;
		  var lon, lat;
	
		  /* Inverse equations
		      -----------------*/
		  p.x = (p.x - this.x0) / this.a;
		  p.y = (p.y - this.y0) / this.a;
	
		  p.x /= this.k0;
		  p.y /= this.k0;
	
		  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
		    c = Math.atan2(rh, this.rc);
		    sinc = Math.sin(c);
		    cosc = Math.cos(c);
	
		    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
		    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
		    lon = adjust_lon(this.long0 + lon);
		  }
		  else {
		    lat = this.phic0;
		    lon = 0;
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$16 = ["gnom"];
		var gnom = {
		  init: init$15,
		  forward: forward$14,
		  inverse: inverse$14,
		  names: names$16
		};
	
		var iqsfnz = function(eccent, q) {
		  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
		  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
		    if (q < 0) {
		      return (-1 * HALF_PI);
		    }
		    else {
		      return HALF_PI;
		    }
		  }
		  //var phi = 0.5* q/(1-eccent*eccent);
		  var phi = Math.asin(0.5 * q);
		  var dphi;
		  var sin_phi;
		  var cos_phi;
		  var con;
		  for (var i = 0; i < 30; i++) {
		    sin_phi = Math.sin(phi);
		    cos_phi = Math.cos(phi);
		    con = eccent * sin_phi;
		    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }
	
		  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
		  return NaN;
		};
	
		/*
		  reference:
		    "Cartographic Projection Procedures for the UNIX Environment-
		    A User's Manual" by Gerald I. Evenden,
		    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
		*/
		function init$16() {
		  //no-op
		  if (!this.sphere) {
		    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
		  }
		}
	
		/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
		    ------------------------------------------------------------*/
		function forward$15(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var x, y;
		  /* Forward equations
		      -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  if (this.sphere) {
		    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
		    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
		  }
		  else {
		    var qs = qsfnz(this.e, Math.sin(lat));
		    x = this.x0 + this.a * this.k0 * dlon;
		    y = this.y0 + this.a * qs * 0.5 / this.k0;
		  }
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
		    ------------------------------------------------------------*/
		function inverse$15(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var lon, lat;
	
		  if (this.sphere) {
		    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
		    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
		  }
		  else {
		    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
		    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$17 = ["cea"];
		var cea = {
		  init: init$16,
		  forward: forward$15,
		  inverse: inverse$15,
		  names: names$17
		};
	
		function init$17() {
	
		  this.x0 = this.x0 || 0;
		  this.y0 = this.y0 || 0;
		  this.lat0 = this.lat0 || 0;
		  this.long0 = this.long0 || 0;
		  this.lat_ts = this.lat_ts || 0;
		  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
	
		  this.rc = Math.cos(this.lat_ts);
		}
	
		// forward equations--mapping lat,long to x,y
		// -----------------------------------------------------------------
		function forward$16(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  var dlon = adjust_lon(lon - this.long0);
		  var dlat = adjust_lat(lat - this.lat0);
		  p.x = this.x0 + (this.a * dlon * this.rc);
		  p.y = this.y0 + (this.a * dlat);
		  return p;
		}
	
		// inverse equations--mapping x,y to lat/long
		// -----------------------------------------------------------------
		function inverse$16(p) {
	
		  var x = p.x;
		  var y = p.y;
	
		  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
		  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
		  return p;
		}
	
		var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
		var eqc = {
		  init: init$17,
		  forward: forward$16,
		  inverse: inverse$16,
		  names: names$18
		};
	
		var MAX_ITER$2 = 20;
	
		function init$18() {
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
		  this.e = Math.sqrt(this.es);
		  this.e0 = e0fn(this.es);
		  this.e1 = e1fn(this.es);
		  this.e2 = e2fn(this.es);
		  this.e3 = e3fn(this.es);
		  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
		}
	
		/* Polyconic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$17(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var x, y, el;
		  var dlon = adjust_lon(lon - this.long0);
		  el = dlon * Math.sin(lat);
		  if (this.sphere) {
		    if (Math.abs(lat) <= EPSLN) {
		      x = this.a * dlon;
		      y = -1 * this.a * this.lat0;
		    }
		    else {
		      x = this.a * Math.sin(el) / Math.tan(lat);
		      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
		    }
		  }
		  else {
		    if (Math.abs(lat) <= EPSLN) {
		      x = this.a * dlon;
		      y = -1 * this.ml0;
		    }
		    else {
		      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
		      x = nl * Math.sin(el);
		      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
		    }
	
		  }
		  p.x = x + this.x0;
		  p.y = y + this.y0;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$17(p) {
		  var lon, lat, x, y, i;
		  var al, bl;
		  var phi, dphi;
		  x = p.x - this.x0;
		  y = p.y - this.y0;
	
		  if (this.sphere) {
		    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
		      lon = adjust_lon(x / this.a + this.long0);
		      lat = 0;
		    }
		    else {
		      al = this.lat0 + y / this.a;
		      bl = x * x / this.a / this.a + al * al;
		      phi = al;
		      var tanphi;
		      for (i = MAX_ITER$2; i; --i) {
		        tanphi = Math.tan(phi);
		        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
		        phi += dphi;
		        if (Math.abs(dphi) <= EPSLN) {
		          lat = phi;
		          break;
		        }
		      }
		      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
		    }
		  }
		  else {
		    if (Math.abs(y + this.ml0) <= EPSLN) {
		      lat = 0;
		      lon = adjust_lon(this.long0 + x / this.a);
		    }
		    else {
	
		      al = (this.ml0 + y) / this.a;
		      bl = x * x / this.a / this.a + al * al;
		      phi = al;
		      var cl, mln, mlnp, ma;
		      var con;
		      for (i = MAX_ITER$2; i; --i) {
		        con = this.e * Math.sin(phi);
		        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
		        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
		        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
		        ma = mln / this.a;
		        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
		        phi -= dphi;
		        if (Math.abs(dphi) <= EPSLN) {
		          lat = phi;
		          break;
		        }
		      }
	
		      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
		      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
		      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
		    }
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$19 = ["Polyconic", "poly"];
		var poly = {
		  init: init$18,
		  forward: forward$17,
		  inverse: inverse$17,
		  names: names$19
		};
	
		/*
		  reference
		    Department of Land and Survey Technical Circular 1973/32
		      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
		    OSG Technical Report 4.1
		      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
		  */
	
		/**
		 * iterations: Number of iterations to refine inverse transform.
		 *     0 -> km accuracy
		 *     1 -> m accuracy -- suitable for most mapping applications
		 *     2 -> mm accuracy
		 */
	
	
		function init$19() {
		  this.A = [];
		  this.A[1] = 0.6399175073;
		  this.A[2] = -0.1358797613;
		  this.A[3] = 0.063294409;
		  this.A[4] = -0.02526853;
		  this.A[5] = 0.0117879;
		  this.A[6] = -0.0055161;
		  this.A[7] = 0.0026906;
		  this.A[8] = -0.001333;
		  this.A[9] = 0.00067;
		  this.A[10] = -0.00034;
	
		  this.B_re = [];
		  this.B_im = [];
		  this.B_re[1] = 0.7557853228;
		  this.B_im[1] = 0;
		  this.B_re[2] = 0.249204646;
		  this.B_im[2] = 0.003371507;
		  this.B_re[3] = -0.001541739;
		  this.B_im[3] = 0.041058560;
		  this.B_re[4] = -0.10162907;
		  this.B_im[4] = 0.01727609;
		  this.B_re[5] = -0.26623489;
		  this.B_im[5] = -0.36249218;
		  this.B_re[6] = -0.6870983;
		  this.B_im[6] = -1.1651967;
	
		  this.C_re = [];
		  this.C_im = [];
		  this.C_re[1] = 1.3231270439;
		  this.C_im[1] = 0;
		  this.C_re[2] = -0.577245789;
		  this.C_im[2] = -0.007809598;
		  this.C_re[3] = 0.508307513;
		  this.C_im[3] = -0.112208952;
		  this.C_re[4] = -0.15094762;
		  this.C_im[4] = 0.18200602;
		  this.C_re[5] = 1.01418179;
		  this.C_im[5] = 1.64497696;
		  this.C_re[6] = 1.9660549;
		  this.C_im[6] = 2.5127645;
	
		  this.D = [];
		  this.D[1] = 1.5627014243;
		  this.D[2] = 0.5185406398;
		  this.D[3] = -0.03333098;
		  this.D[4] = -0.1052906;
		  this.D[5] = -0.0368594;
		  this.D[6] = 0.007317;
		  this.D[7] = 0.01220;
		  this.D[8] = 0.00394;
		  this.D[9] = -0.0013;
		}
	
		/**
		    New Zealand Map Grid Forward  - long/lat to x/y
		    long/lat in radians
		  */
		function forward$18(p) {
		  var n;
		  var lon = p.x;
		  var lat = p.y;
	
		  var delta_lat = lat - this.lat0;
		  var delta_lon = lon - this.long0;
	
		  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
		  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
		  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
		  var d_lambda = delta_lon;
		  var d_phi_n = 1; // d_phi^0
	
		  var d_psi = 0;
		  for (n = 1; n <= 10; n++) {
		    d_phi_n = d_phi_n * d_phi;
		    d_psi = d_psi + this.A[n] * d_phi_n;
		  }
	
		  // 2. Calculate theta
		  var th_re = d_psi;
		  var th_im = d_lambda;
	
		  // 3. Calculate z
		  var th_n_re = 1;
		  var th_n_im = 0; // theta^0
		  var th_n_re1;
		  var th_n_im1;
	
		  var z_re = 0;
		  var z_im = 0;
		  for (n = 1; n <= 6; n++) {
		    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		    th_n_re = th_n_re1;
		    th_n_im = th_n_im1;
		    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
		    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
		  }
	
		  // 4. Calculate easting and northing
		  p.x = (z_im * this.a) + this.x0;
		  p.y = (z_re * this.a) + this.y0;
	
		  return p;
		}
	
		/**
		    New Zealand Map Grid Inverse  -  x/y to long/lat
		  */
		function inverse$18(p) {
		  var n;
		  var x = p.x;
		  var y = p.y;
	
		  var delta_x = x - this.x0;
		  var delta_y = y - this.y0;
	
		  // 1. Calculate z
		  var z_re = delta_y / this.a;
		  var z_im = delta_x / this.a;
	
		  // 2a. Calculate theta - first approximation gives km accuracy
		  var z_n_re = 1;
		  var z_n_im = 0; // z^0
		  var z_n_re1;
		  var z_n_im1;
	
		  var th_re = 0;
		  var th_im = 0;
		  for (n = 1; n <= 6; n++) {
		    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
		    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
		    z_n_re = z_n_re1;
		    z_n_im = z_n_im1;
		    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
		    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
		  }
	
		  // 2b. Iterate to refine the accuracy of the calculation
		  //        0 iterations gives km accuracy
		  //        1 iteration gives m accuracy -- good enough for most mapping applications
		  //        2 iterations bives mm accuracy
		  for (var i = 0; i < this.iterations; i++) {
		    var th_n_re = th_re;
		    var th_n_im = th_im;
		    var th_n_re1;
		    var th_n_im1;
	
		    var num_re = z_re;
		    var num_im = z_im;
		    for (n = 2; n <= 6; n++) {
		      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		      th_n_re = th_n_re1;
		      th_n_im = th_n_im1;
		      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
		      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
		    }
	
		    th_n_re = 1;
		    th_n_im = 0;
		    var den_re = this.B_re[1];
		    var den_im = this.B_im[1];
		    for (n = 2; n <= 6; n++) {
		      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		      th_n_re = th_n_re1;
		      th_n_im = th_n_im1;
		      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
		      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
		    }
	
		    // Complex division
		    var den2 = den_re * den_re + den_im * den_im;
		    th_re = (num_re * den_re + num_im * den_im) / den2;
		    th_im = (num_im * den_re - num_re * den_im) / den2;
		  }
	
		  // 3. Calculate d_phi              ...                                    // and d_lambda
		  var d_psi = th_re;
		  var d_lambda = th_im;
		  var d_psi_n = 1; // d_psi^0
	
		  var d_phi = 0;
		  for (n = 1; n <= 9; n++) {
		    d_psi_n = d_psi_n * d_psi;
		    d_phi = d_phi + this.D[n] * d_psi_n;
		  }
	
		  // 4. Calculate latitude and longitude
		  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
		  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
		  var lon = this.long0 + d_lambda;
	
		  p.x = lon;
		  p.y = lat;
	
		  return p;
		}
	
		var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
		var nzmg = {
		  init: init$19,
		  forward: forward$18,
		  inverse: inverse$18,
		  names: names$20
		};
	
		/*
		  reference
		    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
		    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
		  */
	
	
		/* Initialize the Miller Cylindrical projection
		  -------------------------------------------*/
		function init$20() {
		  //no-op
		}
	
		/* Miller Cylindrical forward equations--mapping lat,long to x,y
		    ------------------------------------------------------------*/
		function forward$19(p) {
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  var x = this.x0 + this.a * dlon;
		  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Miller Cylindrical inverse equations--mapping x,y to lat/long
		    ------------------------------------------------------------*/
		function inverse$19(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
	
		  var lon = adjust_lon(this.long0 + p.x / this.a);
		  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$21 = ["Miller_Cylindrical", "mill"];
		var mill = {
		  init: init$20,
		  forward: forward$19,
		  inverse: inverse$19,
		  names: names$21
		};
	
		var MAX_ITER$3 = 20;
		function init$21() {
		  /* Place parameters in static storage for common use
		    -------------------------------------------------*/
	
	
		  if (!this.sphere) {
		    this.en = pj_enfn(this.es);
		  }
		  else {
		    this.n = 1;
		    this.m = 0;
		    this.es = 0;
		    this.C_y = Math.sqrt((this.m + 1) / this.n);
		    this.C_x = this.C_y / (this.m + 1);
		  }
	
		}
	
		/* Sinusoidal forward equations--mapping lat,long to x,y
		  -----------------------------------------------------*/
		function forward$20(p) {
		  var x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		    -----------------*/
		  lon = adjust_lon(lon - this.long0);
	
		  if (this.sphere) {
		    if (!this.m) {
		      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
		    }
		    else {
		      var k = this.n * Math.sin(lat);
		      for (var i = MAX_ITER$3; i; --i) {
		        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
		        lat -= V;
		        if (Math.abs(V) < EPSLN) {
		          break;
		        }
		      }
		    }
		    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
		    y = this.a * this.C_y * lat;
	
		  }
		  else {
	
		    var s = Math.sin(lat);
		    var c = Math.cos(lat);
		    y = this.a * pj_mlfn(lat, s, c, this.en);
		    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
		  }
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$20(p) {
		  var lat, temp, lon, s;
	
		  p.x -= this.x0;
		  lon = p.x / this.a;
		  p.y -= this.y0;
		  lat = p.y / this.a;
	
		  if (this.sphere) {
		    lat /= this.C_y;
		    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
		    if (this.m) {
		      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
		    }
		    else if (this.n !== 1) {
		      lat = asinz(Math.sin(lat) / this.n);
		    }
		    lon = adjust_lon(lon + this.long0);
		    lat = adjust_lat(lat);
		  }
		  else {
		    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
		    s = Math.abs(lat);
		    if (s < HALF_PI) {
		      s = Math.sin(lat);
		      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
		      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
		      lon = adjust_lon(temp);
		    }
		    else if ((s - EPSLN) < HALF_PI) {
		      lon = this.long0;
		    }
		  }
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$22 = ["Sinusoidal", "sinu"];
		var sinu = {
		  init: init$21,
		  forward: forward$20,
		  inverse: inverse$20,
		  names: names$22
		};
	
		function init$22() {}
		/* Mollweide forward equations--mapping lat,long to x,y
		    ----------------------------------------------------*/
		function forward$21(p) {
	
		  /* Forward equations
		      -----------------*/
		  var lon = p.x;
		  var lat = p.y;
	
		  var delta_lon = adjust_lon(lon - this.long0);
		  var theta = lat;
		  var con = Math.PI * Math.sin(lat);
	
		  /* Iterate using the Newton-Raphson method to find theta
		      -----------------------------------------------------*/
		  for (var i = 0; true; i++) {
		    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
		    theta += delta_theta;
		    if (Math.abs(delta_theta) < EPSLN) {
		      break;
		    }
		  }
		  theta /= 2;
	
		  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
		       this is done here because of precision problems with "cos(theta)"
		       --------------------------------------------------------------------------*/
		  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
		    delta_lon = 0;
		  }
		  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
		  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$21(p) {
		  var theta;
		  var arg;
	
		  /* Inverse equations
		      -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  arg = p.y / (1.4142135623731 * this.a);
	
		  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
		       a number very close to one is used instead.
		       -------------------------------------------------------------------*/
		  if (Math.abs(arg) > 0.999999999999) {
		    arg = 0.999999999999;
		  }
		  theta = Math.asin(arg);
		  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
		  if (lon < (-Math.PI)) {
		    lon = -Math.PI;
		  }
		  if (lon > Math.PI) {
		    lon = Math.PI;
		  }
		  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
		  if (Math.abs(arg) > 1) {
		    arg = 1;
		  }
		  var lat = Math.asin(arg);
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$23 = ["Mollweide", "moll"];
		var moll = {
		  init: init$22,
		  forward: forward$21,
		  inverse: inverse$21,
		  names: names$23
		};
	
		function init$23() {
	
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  // Standard Parallels cannot be equal and on opposite sides of the equator
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
		  this.lat2 = this.lat2 || this.lat1;
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2);
		  this.e = Math.sqrt(this.es);
		  this.e0 = e0fn(this.es);
		  this.e1 = e1fn(this.es);
		  this.e2 = e2fn(this.es);
		  this.e3 = e3fn(this.es);
	
		  this.sinphi = Math.sin(this.lat1);
		  this.cosphi = Math.cos(this.lat1);
	
		  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
		  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
	
		  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
		    this.ns = this.sinphi;
		  }
		  else {
		    this.sinphi = Math.sin(this.lat2);
		    this.cosphi = Math.cos(this.lat2);
		    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
		    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
		    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
		  }
		  this.g = this.ml1 + this.ms1 / this.ns;
		  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
		  this.rh = this.a * (this.g - this.ml0);
		}
	
		/* Equidistant Conic forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------*/
		function forward$22(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var rh1;
	
		  /* Forward equations
		      -----------------*/
		  if (this.sphere) {
		    rh1 = this.a * (this.g - lat);
		  }
		  else {
		    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
		    rh1 = this.a * (this.g - ml);
		  }
		  var theta = this.ns * adjust_lon(lon - this.long0);
		  var x = this.x0 + rh1 * Math.sin(theta);
		  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$22(p) {
		  p.x -= this.x0;
		  p.y = this.rh - p.y + this.y0;
		  var con, rh1, lat, lon;
		  if (this.ns >= 0) {
		    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
		    con = -1;
		  }
		  var theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2(con * p.x, con * p.y);
		  }
	
		  if (this.sphere) {
		    lon = adjust_lon(this.long0 + theta / this.ns);
		    lat = adjust_lat(this.g - rh1 / this.a);
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    var ml = this.g - rh1 / this.a;
		    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
		    lon = adjust_lon(this.long0 + theta / this.ns);
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
	
		}
	
		var names$24 = ["Equidistant_Conic", "eqdc"];
		var eqdc = {
		  init: init$23,
		  forward: forward$22,
		  inverse: inverse$22,
		  names: names$24
		};
	
		/* Initialize the Van Der Grinten projection
		  ----------------------------------------*/
		function init$24() {
		  //this.R = 6370997; //Radius of earth
		  this.R = this.a;
		}
	
		function forward$23(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  /* Forward equations
		    -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  var x, y;
	
		  if (Math.abs(lat) <= EPSLN) {
		    x = this.x0 + this.R * dlon;
		    y = this.y0;
		  }
		  var theta = asinz(2 * Math.abs(lat / Math.PI));
		  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
		    x = this.x0;
		    if (lat >= 0) {
		      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
		    }
		    else {
		      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
		    }
		    //  return(OK);
		  }
		  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
		  var asq = al * al;
		  var sinth = Math.sin(theta);
		  var costh = Math.cos(theta);
	
		  var g = costh / (sinth + costh - 1);
		  var gsq = g * g;
		  var m = g * (2 / sinth - 1);
		  var msq = m * m;
		  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
		  if (dlon < 0) {
		    con = -con;
		  }
		  x = this.x0 + con;
		  //con = Math.abs(con / (Math.PI * this.R));
		  var q = asq + g;
		  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
		  if (lat >= 0) {
		    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
		    y = this.y0 + con;
		  }
		  else {
		    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
		    y = this.y0 - con;
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Van Der Grinten inverse equations--mapping x,y to lat/long
		  ---------------------------------------------------------*/
		function inverse$23(p) {
		  var lon, lat;
		  var xx, yy, xys, c1, c2, c3;
		  var a1;
		  var m1;
		  var con;
		  var th1;
		  var d;
	
		  /* inverse equations
		    -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  con = Math.PI * this.R;
		  xx = p.x / con;
		  yy = p.y / con;
		  xys = xx * xx + yy * yy;
		  c1 = -Math.abs(yy) * (1 + xys);
		  c2 = c1 - 2 * yy * yy + xx * xx;
		  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
		  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
		  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
		  m1 = 2 * Math.sqrt(-a1 / 3);
		  con = ((3 * d) / a1) / m1;
		  if (Math.abs(con) > 1) {
		    if (con >= 0) {
		      con = 1;
		    }
		    else {
		      con = -1;
		    }
		  }
		  th1 = Math.acos(con) / 3;
		  if (p.y >= 0) {
		    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
		  }
		  else {
		    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
		  }
	
		  if (Math.abs(xx) < EPSLN) {
		    lon = this.long0;
		  }
		  else {
		    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
		var vandg = {
		  init: init$24,
		  forward: forward$23,
		  inverse: inverse$23,
		  names: names$25
		};
	
		function init$25() {
		  this.sin_p12 = Math.sin(this.lat0);
		  this.cos_p12 = Math.cos(this.lat0);
		}
	
		function forward$24(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var sinphi = Math.sin(p.y);
		  var cosphi = Math.cos(p.y);
		  var dlon = adjust_lon(lon - this.long0);
		  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
		  if (this.sphere) {
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North Pole case
		      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
		      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South Pole case
		      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
		      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
		      return p;
		    }
		    else {
		      //default case
		      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
		      c = Math.acos(cos_c);
		      kp = c / Math.sin(c);
		      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
		      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
		      return p;
		    }
		  }
		  else {
		    e0 = e0fn(this.es);
		    e1 = e1fn(this.es);
		    e2 = e2fn(this.es);
		    e3 = e3fn(this.es);
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North Pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
		      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
		      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South Pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
		      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
		      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
		      return p;
		    }
		    else {
		      //Default case
		      tanphi = sinphi / cosphi;
		      Nl1 = gN(this.a, this.e, this.sin_p12);
		      Nl = gN(this.a, this.e, sinphi);
		      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
		      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
		      if (Az === 0) {
		        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
		      }
		      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
		        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
		      }
		      else {
		        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
		      }
		      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
		      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
		      GH = G * H;
		      Hs = H * H;
		      s2 = s * s;
		      s3 = s2 * s;
		      s4 = s3 * s;
		      s5 = s4 * s;
		      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
		      p.x = this.x0 + c * Math.sin(Az);
		      p.y = this.y0 + c * Math.cos(Az);
		      return p;
		    }
		  }
	
	
		}
	
		function inverse$24(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
		  if (this.sphere) {
		    rh = Math.sqrt(p.x * p.x + p.y * p.y);
		    if (rh > (2 * HALF_PI * this.a)) {
		      return;
		    }
		    z = rh / this.a;
	
		    sinz = Math.sin(z);
		    cosz = Math.cos(z);
	
		    lon = this.long0;
		    if (Math.abs(rh) <= EPSLN) {
		      lat = this.lat0;
		    }
		    else {
		      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
		      con = Math.abs(this.lat0) - HALF_PI;
		      if (Math.abs(con) <= EPSLN) {
		        if (this.lat0 >= 0) {
		          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
		        }
		        else {
		          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
		        }
		      }
		      else {
		        /*con = cosz - this.sin_p12 * Math.sin(lat);
		        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
		          //no-op, just keep the lon value as is
		        } else {
		          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
		          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
		        }*/
		        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
		      }
		    }
	
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    e0 = e0fn(this.es);
		    e1 = e1fn(this.es);
		    e2 = e2fn(this.es);
		    e3 = e3fn(this.es);
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      M = Mlp - rh;
		      lat = imlfn(M / this.a, e0, e1, e2, e3);
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      M = rh - Mlp;
	
		      lat = imlfn(M / this.a, e0, e1, e2, e3);
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    else {
		      //default case
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      Az = Math.atan2(p.x, p.y);
		      N1 = gN(this.a, this.e, this.sin_p12);
		      cosAz = Math.cos(Az);
		      tmp = this.e * this.cos_p12 * cosAz;
		      A = -tmp * tmp / (1 - this.es);
		      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
		      D = rh / N1;
		      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
		      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
		      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
		      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
		      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		  }
	
		}
	
		var names$26 = ["Azimuthal_Equidistant", "aeqd"];
		var aeqd = {
		  init: init$25,
		  forward: forward$24,
		  inverse: inverse$24,
		  names: names$26
		};
	
		function init$26() {
		  //double temp;      /* temporary variable    */
	
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.sin_p14 = Math.sin(this.lat0);
		  this.cos_p14 = Math.cos(this.lat0);
		}
	
		/* Orthographic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$25(p) {
		  var sinphi, cosphi; /* sin and cos value        */
		  var dlon; /* delta longitude value      */
		  var coslon; /* cos of longitude        */
		  var ksp; /* scale factor          */
		  var g, x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  dlon = adjust_lon(lon - this.long0);
	
		  sinphi = Math.sin(lat);
		  cosphi = Math.cos(lat);
	
		  coslon = Math.cos(dlon);
		  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
		  ksp = 1;
		  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
		    x = this.a * ksp * cosphi * Math.sin(dlon);
		    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$25(p) {
		  var rh; /* height above ellipsoid      */
		  var z; /* angle          */
		  var sinz, cosz; /* sin of z and cos of z      */
		  var con;
		  var lon, lat;
		  /* Inverse equations
		      -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  rh = Math.sqrt(p.x * p.x + p.y * p.y);
		  z = asinz(rh / this.a);
	
		  sinz = Math.sin(z);
		  cosz = Math.cos(z);
	
		  lon = this.long0;
		  if (Math.abs(rh) <= EPSLN) {
		    lat = this.lat0;
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
		  con = Math.abs(this.lat0) - HALF_PI;
		  if (Math.abs(con) <= EPSLN) {
		    if (this.lat0 >= 0) {
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
		    }
		    else {
		      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
		    }
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$27 = ["ortho"];
		var ortho = {
		  init: init$26,
		  forward: forward$25,
		  inverse: inverse$25,
		  names: names$27
		};
	
		var includedProjections = function(proj4){
		  proj4.Proj.projections.add(tmerc);
		  proj4.Proj.projections.add(etmerc);
		  proj4.Proj.projections.add(utm);
		  proj4.Proj.projections.add(sterea);
		  proj4.Proj.projections.add(stere);
		  proj4.Proj.projections.add(somerc);
		  proj4.Proj.projections.add(omerc);
		  proj4.Proj.projections.add(lcc);
		  proj4.Proj.projections.add(krovak);
		  proj4.Proj.projections.add(cass);
		  proj4.Proj.projections.add(laea);
		  proj4.Proj.projections.add(aea);
		  proj4.Proj.projections.add(gnom);
		  proj4.Proj.projections.add(cea);
		  proj4.Proj.projections.add(eqc);
		  proj4.Proj.projections.add(poly);
		  proj4.Proj.projections.add(nzmg);
		  proj4.Proj.projections.add(mill);
		  proj4.Proj.projections.add(sinu);
		  proj4.Proj.projections.add(moll);
		  proj4.Proj.projections.add(eqdc);
		  proj4.Proj.projections.add(vandg);
		  proj4.Proj.projections.add(aeqd);
		  proj4.Proj.projections.add(ortho);
		};
	
		proj4$1.defaultDatum = 'WGS84'; //default datum
		proj4$1.Proj = Projection$1;
		proj4$1.WGS84 = new proj4$1.Proj('WGS84');
		proj4$1.Point = Point;
		proj4$1.toPoint = toPoint;
		proj4$1.defs = defs;
		proj4$1.transform = transform;
		proj4$1.mgrs = mgrs;
		proj4$1.version = version;
		includedProjections(proj4$1);
	
		return proj4$1;
	
	})));


/***/ },
/* 228 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	/**
	 * Math functions.
	 *
	 * @namespace
	 * @alias MathExt
	 */
	var MathExt = {};
	
	/**
	 * pi
	 *
	 * @type {Number}
	 * @constant
	 */
	MathExt.PI = Math.PI;
	
	/**
	 * pi/2
	 *
	 * @type {Number}
	 * @constant
	 */
	MathExt.PI_OV_TWO = Math.PI * 0.5;
	
	MathExt.PI_OV_FOUR = Math.PI * 0.25;
	
	/**
	 * pi*2
	 *
	 * @type {Number}
	 * @constant
	 */
	MathExt.TWO_PI = Math.PI * 2.0;
	
	MathExt.INV_TWO_PI = 1.0 / MathExt.TWO_PI;
	
	MathExt.LOG_TWO = Math.log(2.0);
	
	MathExt.RADTODEG = 180.0 / MathExt.PI;
	
	MathExt.DEGTORAD = MathExt.PI / 180.0;
	
	MathExt.radToDeg = function radToDeg(rad) {
	    return rad * MathExt.RADTODEG;
	};
	
	MathExt.degToRad = function degToRad(deg) {
	    return deg * MathExt.DEGTORAD;
	};
	
	MathExt.arrayDegToRad = function arrayDegToRad(arrayDeg) {
	    if (arrayDeg) {
	        for (var i = 0; i < arrayDeg.length; i++) {
	            arrayDeg[i] = MathExt.degToRad(arrayDeg[i]);
	        }
	    }
	};
	
	MathExt.arrayRadToDeg = function arrayRadToDeg(arrayDeg) {
	    if (arrayDeg) {
	        for (var i = 0; i < arrayDeg.length; i++) {
	            arrayDeg[i] = MathExt.radToDeg(arrayDeg[i]);
	        }
	    }
	};
	
	// TODO: Function in test :
	MathExt.step = function step(val, stepVal) {
	    if (val < stepVal) {
	        return 0.0;
	    } else {
	        return 1.0;
	    }
	};
	
	MathExt.exp2 = function exp2(expo) {
	    return Math.pow(2, expo);
	};
	
	exports.default = MathExt;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Coordinates = __webpack_require__(217);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Ellipsoid
	 * Description: Classe mathmatique de  l'ellispoide
	 */
	
	function Ellipsoid(size) {
	    // Constructor
	
	
	    this.rayon_1 = size.x;
	    this.rayon_2 = size.y;
	    this.rayon_3 = size.z;
	
	    this.size = new THREE.Vector3(size.x, size.y, size.z);
	
	    this._radiiSquared = new THREE.Vector3(size.x * size.x, size.y * size.y, size.z * size.z);
	}
	
	Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function geodeticSurfaceNormalCartographic(coordCarto) {
	    var longitude = coordCarto.longitude(_Coordinates.UNIT.RADIAN);
	    var latitude = coordCarto.latitude(_Coordinates.UNIT.RADIAN);
	    var cosLatitude = Math.cos(latitude);
	
	    var x = cosLatitude * Math.cos(longitude);
	    var y = cosLatitude * Math.sin(longitude);
	    var z = Math.sin(latitude);
	
	    var result = new THREE.Vector3(x, y, z);
	
	    return result.normalize();
	};
	
	Ellipsoid.prototype.setSize = function setSize(size) {
	    this.rayon_1 = size.x;
	    this.rayon_2 = size.y;
	    this.rayon_3 = size.z;
	
	    this._radiiSquared = new THREE.Vector3(size.x * size.x, size.y * size.y, size.z * size.z);
	};
	
	Ellipsoid.prototype.cartographicToCartesian = function cartographicToCartesian(coordCarto) {
	    // var n;
	    var k = new THREE.Vector3();
	    var n = this.geodeticSurfaceNormalCartographic(coordCarto);
	
	    k.multiplyVectors(this._radiiSquared, n);
	
	    var gamma = Math.sqrt(n.dot(k));
	
	    k.divideScalar(gamma);
	
	    n.multiplyScalar(coordCarto.altitude());
	
	    // n.multiplyScalar(0.0);
	
	    return k.add(n);
	};
	
	/**
	 * @typedef {Object} EllipsoidCoordinate
	 * @property {number} latitude
	 * @property {number} longitude
	 * @property {number} h - height
	 */
	/**
	 * Convert cartesian coordinates to geographic according to the current ellipsoid of revolution.
	 *
	 * @param {Object} position - The coordinate to convert
	 * @param {number} position.x
	 * @param {number} position.y
	 * @param {number} position.z
	 * @returns {EllipsoidCoordinate} an object describing the coordinates on the reference ellipsoid, angles are in degree
	 */
	Ellipsoid.prototype.cartesianToCartographic = function cartesianToCartographic(position) {
	    // for details, see for example http://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
	    // TODO the following is only valable for oblate ellipsoid of revolution. do we want to support triaxial ellipsoid?
	    var R = Math.sqrt(position.x * position.x + position.y * position.y + position.z * position.z);
	    var a = this.rayon_1; // x
	    var b = this.rayon_3; // z
	    var e = Math.abs((a * a - b * b) / (a * a));
	    var f = 1 - Math.sqrt(1 - e);
	    var rsqXY = Math.sqrt(position.x * position.x + position.y * position.y);
	
	    var theta = Math.atan2(position.y, position.x);
	    var nu = Math.atan(position.z / rsqXY * (1 - f + e * a / R));
	
	    var sinu = Math.sin(nu);
	    var cosu = Math.cos(nu);
	
	    var phi = Math.atan((position.z * (1 - f) + e * a * sinu * sinu * sinu) / ((1 - f) * (rsqXY - e * a * cosu * cosu * cosu)));
	
	    var h = rsqXY * Math.cos(phi) + position.z * Math.sin(phi) - a * Math.sqrt(1 - e * Math.sin(phi) * Math.sin(phi));
	
	    return { longitude: theta * 180 / Math.PI, latitude: phi * 180 / Math.PI, h: h };
	};
	
	Ellipsoid.prototype.cartographicToCartesianArray = function cartographicToCartesianArray(coordCartoArray) {
	    var cartesianArray = [];
	    for (var i = 0; i < coordCartoArray.length; i++) {
	        cartesianArray.push(this.cartographicToCartesian(coordCartoArray[i]));
	    }
	
	    return cartesianArray;
	};
	
	Ellipsoid.prototype.intersection = function intersection(ray) {
	    var EPSILON = 0.0001;
	    var O_C = ray.origin;
	    var dir = ray.direction;
	    // normalizeVector( dir );
	
	    var a = dir.x * dir.x / (this.size.x * this.size.x) + dir.y * dir.y / (this.size.y * this.size.y) + dir.z * dir.z / (this.size.z * this.size.z);
	
	    var b = 2 * O_C.x * dir.x / (this.size.x * this.size.x) + 2 * O_C.y * dir.y / (this.size.y * this.size.y) + 2 * O_C.z * dir.z / (this.size.z * this.size.z);
	    var c = O_C.x * O_C.x / (this.size.x * this.size.x) + O_C.y * O_C.y / (this.size.y * this.size.y) + O_C.z * O_C.z / (this.size.z * this.size.z) - 1;
	
	    var d = b * b - 4 * a * c;
	    if (d < 0 || a === 0 || b === 0 || c === 0) {
	        return false;
	    }
	
	    d = Math.sqrt(d);
	
	    var t1 = (-b + d) / (2 * a);
	    var t2 = (-b - d) / (2 * a);
	
	    if (t1 <= EPSILON && t2 <= EPSILON) return false; // both intersections are behind the ray origin
	    // var back = (t1 <= EPSILON || t2 <= EPSILON); // If only one intersection (t>0) then we are inside the ellipsoid and the intersection is at the back of the ellipsoid
	    var t = 0;
	    if (t1 <= EPSILON) {
	        t = t2;
	    } else if (t2 <= EPSILON) {
	        t = t1;
	    } else {
	        t = t1 < t2 ? t1 : t2;
	    }
	
	    if (t < EPSILON) return false; // Too close to intersection
	
	    var inter = new THREE.Vector3();
	
	    inter.addVectors(ray.origin, dir.clone().setLength(t));
	
	    return inter;
	    /*
	    var normal = intersection.clone();//-ellipsoid.center;
	    normal.x = 2*normal.x/(this.size.x*this.size.x);
	    normal.y = 2*normal.y/(this.size.y*this.size.y);
	    normal.z = 2*normal.z/(this.size.z*this.size.z);
	     //normal.w = 0.f;
	    normal *= (back) ? -1.f : 1.f;
	    normalizeVector(normal);
	    */
	};
	
	Ellipsoid.prototype.computeDistance = function computeDistance(coordCarto1, coordCarto2) {
	    var longitude1 = coordCarto1.longitude() * Math.PI / 180;
	    var latitude1 = coordCarto1.latitude() * Math.PI / 180;
	    var longitude2 = coordCarto2.longitude() * Math.PI / 180;
	    var latitude2 = coordCarto2.latitude() * Math.PI / 180;
	
	    var distRad = Math.acos(Math.sin(latitude1) * Math.sin(latitude2) + Math.cos(latitude1) * Math.cos(latitude2) * Math.cos(longitude2 - longitude1));
	
	    var a = this.rayon_1;
	    var b = this.rayon_3;
	    var e = Math.sqrt((a * a - b * b) / (a * a));
	    var latMoy = (latitude1 + latitude2) / 2;
	    var rho = a * (1 - e * e) / Math.sqrt(1 - e * e * Math.sin(latMoy) * Math.sin(latMoy));
	    var N = a / Math.sqrt(1 - e * e * Math.sin(latMoy) * Math.sin(latMoy));
	
	    var distMeter = distRad * Math.sqrt(rho * N);
	    return distMeter;
	};
	
	exports.default = Ellipsoid;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _optimer_regular = __webpack_require__(234);
	
	var _optimer_regular2 = _interopRequireDefault(_optimer_regular);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	/* global Uint16Array Float32Array*/
	
	var font = new THREE.Font(JSON.parse(_optimer_regular2.default));
	
	// TODO regler le probleme glsl
	
	
	function OBBHelper(OBB, text) {
	    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
	    var positions = new Float32Array(8 * 3);
	
	    var geometry = new THREE.BufferGeometry();
	    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
	    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
	
	    var color = new THREE.Color(Math.random(), Math.random(), Math.random());
	
	    THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
	        color: color.getHex(),
	        linewidth: 3
	    }));
	
	    this.frustumCulled = false;
	
	    var size = OBB.box3D.getSize();
	
	    var geometryText = new THREE.TextGeometry(text, {
	
	        font: font,
	        size: size.x * 0.0666,
	        height: size.z * 0.001,
	        curveSegments: 1
	
	    });
	
	    this.textMesh = new THREE.Mesh(geometryText, new THREE.MeshBasicMaterial({
	        color: new THREE.Color(1, 0, 0),
	        side: THREE.DoubleSide
	    }));
	
	    this.add(this.textMesh);
	    this.textMesh.frustumCulled = false;
	
	    if (OBB !== undefined) {
	        this.update(OBB);
	    }
	}
	
	OBBHelper.prototype = (0, _create2.default)(THREE.LineSegments.prototype);
	OBBHelper.prototype.constructor = OBBHelper;
	
	OBBHelper.prototype.setMaterialVisibility = function setMaterialVisibility(show) {
	    this.material.visible = show;
	    this.textMesh.material.visible = show;
	};
	
	OBBHelper.prototype.update = function update(OBB) {
	    var position = this.geometry.attributes.position;
	    var array = position.array;
	
	    var pts = OBB._points();
	    for (var i = 0; i < pts.length; i++) {
	        array[i * 3] = pts[i].x;
	        array[i * 3 + 1] = pts[i].y;
	        array[i * 3 + 2] = pts[i].z;
	    }
	
	    position.needsUpdate = true;
	
	    this.position.copy(OBB.position);
	    this.rotation.copy(OBB.rotation);
	    this.updateMatrix();
	    this.updateMatrixWorld(true);
	
	    var size = OBB.box3D.getSize();
	
	    if (this.textMesh) {
	        this.textMesh.position.set(0, 0, 0);
	        this.textMesh.translateX(-size.x * 0.45);
	        this.textMesh.translateY(-size.y * 0.45);
	        this.textMesh.translateZ(size.z * 0.5);
	    }
	};
	
	exports.default = OBBHelper;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(232), __esModule: true };

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(233);
	var $Object = __webpack_require__(15).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(14)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(42)});

/***/ },
/* 234 */
/***/ function(module, exports) {

	module.exports = "{\"glyphs\":{\"\":{\"x_min\":41,\"x_max\":710,\"ha\":753,\"o\":\"m 371 -15 q 131 78 222 -15 q 41 322 41 172 q 133 573 41 474 q 378 672 225 672 q 619 574 528 672 q 710 326 710 477 q 617 80 710 175 q 371 -15 525 -15 m 377 619 q 226 530 272 619 q 180 327 180 441 q 227 125 180 216 q 375 35 274 35 q 524 123 478 35 q 570 326 570 211 q 524 529 570 440 q 377 619 479 619 \"},\"S\":{\"x_min\":50,\"x_max\":639,\"ha\":699,\"o\":\"m 88 208 q 179 88 122 131 q 318 46 237 46 q 457 98 397 46 q 518 227 518 150 q 401 400 518 336 q 184 498 293 448 q 68 688 68 566 q 156 880 68 811 q 370 950 244 950 q 480 936 430 950 q 597 891 530 922 q 570 822 583 858 q 553 756 558 786 l 539 756 q 354 897 502 897 q 231 855 282 897 q 181 742 181 813 q 298 580 181 640 q 519 483 408 531 q 639 286 639 413 q 538 68 639 152 q 301 -15 438 -15 q 166 2 229 -15 q 50 59 104 19 q 68 135 62 104 q 75 205 75 166 l 88 208 \"},\"/\":{\"x_min\":-36.03125,\"x_max\":404.15625,\"ha\":383,\"o\":\"m -36 -125 l 340 1025 l 404 1024 l 28 -126 l -36 -125 \"},\"\":{\"x_min\":11,\"x_max\":713,\"ha\":725,\"o\":\"m 11 839 l 15 884 l 11 932 q 194 927 72 932 q 361 922 316 922 q 544 927 421 922 q 713 932 668 932 q 707 883 707 911 q 707 861 707 870 q 713 834 707 852 q 609 850 666 843 q 504 857 552 857 l 428 857 q 426 767 428 830 q 424 701 424 704 l 428 220 q 442 0 428 122 q 362 8 401 3 q 323 5 344 8 q 282 0 301 2 q 289 132 282 40 q 296 259 296 225 l 296 683 l 296 857 q 11 839 164 857 \"},\"\":{\"x_min\":41,\"x_max\":960,\"ha\":1006,\"o\":\"m 441 -10 q 162 76 283 -10 q 41 316 41 163 q 162 562 41 470 q 441 654 283 654 q 434 838 441 719 q 427 971 427 957 q 464 965 443 968 q 503 962 485 962 q 540 965 519 962 q 578 970 560 968 q 563 654 563 824 q 839 567 719 654 q 960 324 960 481 q 841 79 960 169 q 563 -10 722 -10 q 570 -201 563 -68 q 578 -371 578 -334 q 505 -362 539 -362 q 465 -365 483 -362 q 427 -372 446 -368 q 434 -161 427 -297 q 441 -10 441 -26 m 563 39 q 757 118 690 39 q 824 330 824 198 q 750 523 824 445 q 564 601 677 601 l 563 319 l 563 39 m 441 319 l 441 601 q 253 523 326 601 q 180 330 180 446 q 245 117 180 195 q 439 39 310 39 l 441 319 \"},\"y\":{\"x_min\":4.171875,\"x_max\":665.28125,\"ha\":664,\"o\":\"m 4 654 l 86 647 l 165 654 q 202 536 188 577 q 241 431 215 495 l 363 129 l 473 413 q 552 654 519 537 q 606 647 583 647 q 665 654 633 647 q 416 125 531 388 q 223 -372 301 -137 l 187 -366 q 141 -366 163 -366 q 112 -372 122 -370 l 290 -22 q 4 654 170 294 \"},\"\":{\"x_min\":118.0625,\"x_max\":1019.453125,\"ha\":1139,\"o\":\"m 765 442 q 564 487 700 442 q 376 533 429 533 q 250 506 298 533 q 118 427 202 480 l 118 501 q 245 572 180 545 q 376 600 311 600 q 574 553 438 600 q 765 507 709 507 q 888 534 829 507 q 1019 614 947 562 l 1019 538 q 892 467 954 493 q 765 442 830 442 m 759 214 q 568 260 702 214 q 376 307 433 307 q 236 272 300 307 q 118 202 173 238 l 118 277 q 247 346 181 320 q 380 372 312 372 q 570 326 445 372 q 765 281 695 281 q 883 306 830 281 q 1019 388 936 331 l 1019 313 q 894 240 959 266 q 759 214 829 214 \"},\"\":{\"x_min\":108,\"x_max\":927.453125,\"ha\":1036,\"o\":\"m 432 846 l 263 846 q 260 634 263 781 q 257 475 257 486 q 262 236 257 395 q 268 0 268 77 q 229 3 255 0 q 188 8 202 8 q 149 3 177 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 711 126 620 q 108 932 119 803 q 285 926 166 932 q 464 921 405 921 q 695 926 541 921 q 927 932 849 932 q 915 793 921 871 q 909 659 909 716 l 909 504 q 917 245 909 427 q 926 0 926 62 q 887 4 913 0 q 847 8 860 8 q 810 5 827 8 q 768 0 792 2 q 773 259 768 94 q 778 469 778 423 l 778 731 l 773 846 l 432 846 \"},\"\":{\"x_min\":-41,\"x_max\":384,\"ha\":342,\"o\":\"m 105 333 l 105 520 q 104 566 105 544 q 97 654 103 588 q 141 647 131 648 q 166 647 152 647 q 234 654 196 647 q 225 555 226 599 q 224 437 224 510 l 224 406 q 229 194 224 337 q 234 0 234 51 q 202 3 217 1 q 166 5 186 5 q 128 3 149 5 q 97 0 108 1 q 101 165 97 51 q 105 333 105 279 m 18 865 q 61 846 43 865 q 80 804 80 828 q 61 761 80 779 q 18 743 43 743 q -22 761 -4 743 q -41 804 -41 779 q -22 846 -41 828 q 18 865 -4 865 m 172 929 q 189 969 179 956 q 225 982 199 982 q 256 971 243 982 q 270 941 270 961 q 257 904 270 919 l 149 743 l 117 743 l 172 929 m 324 865 q 366 846 348 865 q 384 804 384 828 q 366 761 384 779 q 324 743 348 743 q 281 761 298 743 q 265 804 265 779 q 281 846 265 828 q 324 865 298 865 \"},\"g\":{\"x_min\":32,\"x_max\":672,\"ha\":688,\"o\":\"m 81 123 q 112 201 81 169 q 193 252 144 233 l 193 262 q 97 329 130 277 q 64 447 64 380 q 141 610 64 549 q 323 672 218 672 q 421 661 357 672 q 500 650 486 651 l 672 654 l 672 582 q 599 592 635 587 q 537 597 563 597 q 607 458 607 548 q 527 294 607 356 q 342 232 447 232 q 291 235 319 232 q 255 239 262 239 q 208 220 228 239 q 188 173 188 201 q 221 120 188 136 q 296 104 254 104 l 427 104 q 603 56 534 104 q 672 -93 672 9 q 560 -299 672 -226 q 309 -372 448 -372 q 115 -327 199 -372 q 32 -183 32 -283 q 76 -62 32 -110 q 193 8 121 -13 q 112 51 143 25 q 81 123 81 77 m 332 278 q 439 332 401 278 q 478 457 478 386 q 441 575 478 525 q 338 625 404 625 q 232 570 271 625 q 194 447 194 515 q 230 328 194 379 q 332 278 266 278 m 337 -316 q 491 -270 423 -316 q 559 -141 559 -224 q 500 -29 559 -62 q 353 3 441 3 q 199 -36 263 3 q 136 -162 136 -76 q 195 -277 136 -238 q 337 -316 255 -316 \"},\"\":{\"x_min\":15.28125,\"x_max\":412.5,\"ha\":496,\"o\":\"m 297 744 q 270 830 297 795 q 197 866 244 866 q 120 837 149 866 q 83 761 90 808 l 76 759 q 54 802 68 780 q 31 837 40 824 q 210 901 108 901 q 334 862 278 901 q 390 758 390 824 q 282 568 390 656 q 111 428 174 479 l 293 428 q 350 431 316 428 q 412 439 384 434 l 406 397 l 412 356 l 304 361 l 111 361 l 15 355 l 15 378 q 220 567 144 484 q 297 744 297 651 \"},\"\":{\"x_min\":108,\"x_max\":856.625,\"ha\":821,\"o\":\"m 255 314 q 261 132 255 250 q 268 0 268 13 q 229 4 255 0 q 188 8 202 8 q 148 4 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 712 126 621 q 108 932 119 803 q 153 928 124 932 q 188 925 183 925 q 231 928 203 925 q 267 932 259 932 l 255 671 l 255 499 q 480 693 375 586 q 687 932 585 800 q 732 932 710 932 q 777 932 753 932 l 837 932 q 606 727 720 830 q 389 522 493 623 q 525 358 465 426 q 666 202 586 290 q 856 0 747 115 l 746 0 q 692 -1 716 0 q 644 -8 669 -2 q 571 92 610 44 q 477 204 532 140 l 255 459 l 255 314 \"},\"\":{\"x_min\":40,\"x_max\":646.9375,\"ha\":681,\"o\":\"m 406 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 313 335 315 335 l 179 331 q 235 127 179 212 q 406 42 291 42 m 219 929 q 271 906 249 929 q 294 854 294 884 q 273 800 294 822 q 221 778 252 778 q 166 800 190 778 q 143 854 143 822 q 165 906 143 884 q 219 929 187 929 m 460 929 q 513 906 492 929 q 534 854 534 884 q 513 799 534 820 q 461 778 493 778 q 407 800 429 778 q 385 854 385 822 q 407 906 385 884 q 460 929 429 929 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 \"},\"e\":{\"x_min\":41,\"x_max\":645.15625,\"ha\":681,\"o\":\"m 406 42 q 602 130 523 42 l 618 125 q 611 86 614 104 q 609 44 609 67 q 497 0 561 14 q 370 -15 434 -15 q 130 73 220 -15 q 41 311 41 161 q 127 563 41 455 q 356 672 214 672 q 563 592 482 672 q 645 385 645 512 l 643 331 l 313 335 l 179 331 q 235 126 179 210 q 406 42 291 42 m 511 392 l 513 436 q 470 563 513 509 q 356 618 427 618 q 230 553 268 618 q 179 388 191 488 l 511 392 \"},\"\":{\"x_min\":41,\"x_max\":710,\"ha\":753,\"o\":\"m 371 -15 q 131 78 222 -15 q 41 322 41 172 q 133 573 41 474 q 378 672 225 672 q 619 574 528 672 q 710 326 710 477 q 617 80 710 175 q 371 -15 525 -15 m 524 943 q 558 974 542 964 q 595 985 574 985 q 632 969 618 985 q 646 932 646 954 q 632 897 646 911 q 591 866 618 883 l 390 743 l 341 743 l 524 943 m 377 619 q 226 530 272 619 q 180 327 180 441 q 227 125 180 216 q 375 35 274 35 q 524 123 478 35 q 570 326 570 211 q 524 529 570 440 q 377 619 479 619 \"},\"J\":{\"x_min\":-71,\"x_max\":277,\"ha\":385,\"o\":\"m 118 -40 q 131 62 128 9 q 135 184 135 115 q 132 462 135 325 q 127 690 130 598 q 111 932 123 782 q 159 928 129 932 q 193 925 189 925 q 238 927 221 925 q 277 932 256 929 q 268 665 277 843 q 260 457 260 487 l 260 165 q 260 107 260 147 q 260 48 260 68 q 169 -155 260 -88 q -62 -222 79 -222 l -71 -180 q 50 -134 1 -166 q 118 -40 100 -102 \"},\"\":{\"x_min\":43,\"x_max\":543,\"ha\":607,\"o\":\"m 196 322 l 43 607 l 81 645 l 303 322 l 81 0 l 43 37 l 196 322 m 436 322 l 283 607 l 322 645 l 543 322 l 322 0 l 283 37 l 436 322 \"},\"\":{\"x_min\":80,\"x_max\":1058,\"ha\":1139,\"o\":\"m 816 905 q 992 726 927 841 q 1058 481 1058 611 q 912 138 1058 283 q 567 -6 766 -6 q 225 139 370 -6 q 80 481 80 284 q 224 826 80 681 q 569 971 368 971 q 816 905 698 971 m 569 918 q 263 788 392 918 q 134 481 134 659 q 261 175 134 306 q 566 45 389 45 q 872 174 741 45 q 1004 478 1004 304 q 947 699 1004 596 q 787 859 890 801 q 569 918 684 918 m 570 724 q 441 652 483 724 q 399 490 399 581 q 438 320 399 396 q 560 245 478 245 q 664 278 621 245 q 723 370 707 311 l 798 370 q 720 232 788 283 q 561 181 653 181 q 379 268 446 181 q 313 476 313 355 q 380 694 313 604 q 571 785 447 785 q 717 738 656 785 q 793 610 779 691 l 715 610 q 664 692 705 660 q 570 724 624 724 \"},\"\":{\"x_min\":39.71875,\"x_max\":1028.9375,\"ha\":1068,\"o\":\"m 534 528 l 596 528 l 594 305 q 616 117 594 193 q 722 42 638 42 q 850 118 811 42 q 888 293 888 194 q 829 502 888 409 q 664 654 769 594 l 717 648 q 805 654 766 648 q 967 510 905 606 q 1028 304 1028 413 q 948 81 1028 177 q 744 -15 867 -15 q 622 16 678 -15 q 534 104 566 47 q 445 16 500 48 q 323 -15 389 -15 q 118 83 196 -15 q 39 311 39 182 q 100 511 39 419 q 262 654 161 604 q 303 650 278 651 q 349 648 327 648 l 402 654 q 238 501 296 593 q 179 291 179 409 q 218 116 179 191 q 348 42 257 42 q 419 68 390 42 q 461 138 448 94 q 472 216 469 175 q 475 303 475 257 q 472 420 475 353 q 469 529 470 486 l 534 528 m 681 943 q 714 974 699 964 q 751 985 730 985 q 788 969 774 985 q 802 932 802 954 q 787 896 802 912 q 746 866 773 880 l 547 743 l 498 743 l 681 943 \"},\"\":{\"x_min\":176.1875,\"x_max\":963,\"ha\":1139,\"o\":\"m 963 462 l 176 196 l 176 266 l 850 491 l 176 718 l 176 788 l 963 522 l 963 462 m 963 26 l 176 26 l 176 93 l 963 93 l 963 26 \"},\"^\":{\"x_min\":0,\"x_max\":390,\"ha\":403,\"o\":\"m 150 978 l 239 978 l 390 743 l 344 743 l 195 875 l 49 743 l 0 743 l 150 978 \"},\"\":{\"x_min\":48,\"x_max\":549.390625,\"ha\":607,\"o\":\"m 152 326 l 309 42 l 268 3 l 48 326 l 268 649 l 309 611 l 152 326 m 394 326 l 549 42 l 509 3 l 288 326 l 509 649 l 549 611 l 394 326 \"},\"D\":{\"x_min\":108,\"x_max\":991,\"ha\":1043,\"o\":\"m 126 465 q 117 704 126 536 q 108 931 108 872 l 210 929 q 350 934 251 929 q 477 939 449 939 q 579 936 553 939 q 709 917 605 934 q 902 775 814 900 q 991 483 991 650 q 852 130 991 261 q 491 0 713 0 l 378 0 l 228 7 l 203 7 q 148 4 173 7 q 108 0 123 1 q 117 239 108 70 q 126 465 126 408 m 402 64 q 724 168 609 64 q 840 479 840 273 q 730 774 840 671 q 428 878 621 878 q 345 873 400 878 q 262 869 289 869 l 255 497 l 255 376 l 262 76 q 332 68 292 72 q 402 64 373 64 \"},\"w\":{\"x_min\":4.171875,\"x_max\":1052.78125,\"ha\":1047,\"o\":\"m 4 655 q 55 648 41 648 q 86 647 69 647 q 165 654 120 647 q 190 540 176 587 q 238 394 204 492 l 329 141 q 498 654 419 386 q 551 647 526 647 q 609 654 577 647 q 637 544 620 601 q 677 420 654 487 l 770 135 l 872 413 q 911 532 893 472 q 944 654 930 592 q 979 647 970 648 q 1000 647 988 647 q 1052 654 1022 647 q 961 457 1002 555 q 871 235 919 359 q 782 0 824 110 q 755 3 772 0 q 733 6 738 6 q 708 3 724 6 q 686 0 692 0 q 650 127 667 72 q 611 239 632 183 l 518 494 q 432 258 475 382 q 348 0 390 134 q 325 3 336 1 q 297 5 313 5 q 269 3 284 5 q 245 0 254 1 q 162 244 200 140 q 86 447 125 347 q 4 655 47 546 \"},\"$\":{\"x_min\":89,\"x_max\":666,\"ha\":749,\"o\":\"m 139 186 l 146 186 q 213 91 165 119 q 342 50 261 63 l 342 416 q 142 515 196 458 q 89 648 89 573 q 164 819 89 752 q 342 886 239 886 q 330 985 342 936 l 359 979 l 404 984 q 400 924 401 945 q 399 886 399 904 q 510 874 457 886 q 605 834 562 862 q 582 788 592 808 q 555 729 572 768 l 547 729 q 495 810 535 783 q 399 837 455 837 l 399 520 q 610 419 554 479 q 666 277 666 359 q 588 87 666 164 q 399 0 511 9 l 399 -32 q 399 -63 399 -48 q 405 -125 400 -78 l 368 -121 l 329 -125 l 342 0 q 210 13 273 0 q 98 58 147 27 l 139 186 m 342 836 q 237 787 278 826 q 196 686 196 748 q 237 588 196 626 q 342 537 279 551 l 342 836 m 553 231 q 513 337 553 300 q 399 402 473 375 l 399 51 q 512 113 471 66 q 553 231 553 159 \"},\"\":{\"x_min\":134,\"x_max\":309,\"ha\":446,\"o\":\"m 222 636 q 284 611 259 636 q 309 548 309 586 q 284 486 309 512 q 222 461 260 461 q 160 486 186 461 q 134 548 134 511 q 159 610 134 584 q 222 636 185 636 \"},\"\\\\\":{\"x_min\":-36,\"x_max\":403.140625,\"ha\":383,\"o\":\"m -36 1025 l 28 1025 l 403 -125 l 340 -125 l -36 1025 \"},\"\":{\"x_min\":109,\"x_max\":271,\"ha\":385,\"o\":\"m 127 465 q 123 711 127 620 q 109 932 120 803 q 154 927 129 929 q 190 925 179 925 q 238 928 209 925 q 271 931 266 931 q 263 788 271 887 q 256 659 256 690 l 256 448 l 256 283 q 263 135 256 238 q 271 0 271 31 q 231 3 258 0 q 190 8 204 8 q 151 5 172 8 q 109 0 129 2 q 118 239 109 70 q 127 465 127 408 \"},\"\":{\"x_min\":-1,\"x_max\":1204.5625,\"ha\":1165,\"o\":\"m 758 177 l 758 386 q 651 570 717 458 q 543 750 585 681 q 431 931 501 819 q 483 928 449 931 q 522 925 518 925 q 572 927 550 925 q 606 931 593 930 q 666 800 633 866 q 735 676 699 734 l 849 475 q 968 688 910 575 q 1086 931 1027 801 l 1142 926 q 1174 927 1160 926 q 1204 931 1187 929 q 1014 627 1099 769 l 891 415 l 891 240 q 894 101 891 198 q 897 0 897 5 q 860 4 885 1 q 820 6 835 6 q 778 4 793 6 q 743 0 763 2 q 753 88 748 36 q 758 177 758 140 m 182 943 q 215 974 200 964 q 252 985 231 985 q 289 969 274 985 q 305 932 305 954 q 290 896 305 911 q 248 866 275 882 l 48 743 l -1 743 l 182 943 \"},\"\":{\"x_min\":90.28125,\"x_max\":305.5625,\"ha\":374,\"o\":\"m 169 859 q 197 923 177 894 q 250 953 218 953 q 288 939 272 953 q 305 902 305 925 q 295 857 305 882 q 269 811 284 833 l 120 568 l 90 576 l 169 859 \"},\"\":{\"x_min\":98,\"x_max\":911.890625,\"ha\":1011,\"o\":\"m 112 230 q 114 486 112 315 q 117 741 117 656 l 117 950 l 166 950 q 326 766 239 865 q 468 606 413 667 q 610 451 524 544 l 821 227 l 821 604 q 816 765 821 685 q 803 931 812 845 l 855 927 l 911 931 q 901 831 906 884 q 897 741 897 779 q 894 413 897 619 q 892 165 892 207 l 892 -15 l 849 -15 q 730 125 796 50 q 589 281 664 201 l 193 702 l 193 330 q 212 -1 193 169 l 149 2 l 98 -1 q 108 125 105 79 q 112 230 112 170 \"},\"-\":{\"x_min\":58.328125,\"x_max\":388.890625,\"ha\":449,\"o\":\"m 58 390 l 388 390 l 388 273 l 58 273 l 58 390 \"},\"Q\":{\"x_min\":51,\"x_max\":1074.609375,\"ha\":1119,\"o\":\"m 566 -14 q 194 113 338 -14 q 51 465 51 241 q 192 820 51 690 q 559 950 333 950 q 892 853 754 950 q 1047 654 1031 756 q 1065 525 1062 551 q 1068 462 1068 499 q 1065 405 1068 429 q 1050 305 1062 381 q 960 144 1038 229 q 748 6 881 59 l 930 -112 q 1004 -161 963 -136 q 1074 -200 1045 -186 q 1008 -228 1035 -214 q 951 -267 980 -243 q 876 -208 912 -234 q 803 -154 841 -182 l 606 -14 l 566 -14 m 202 468 q 290 163 202 283 q 559 43 379 43 q 826 163 738 43 q 915 468 915 284 q 825 770 915 651 q 559 889 735 889 q 348 826 429 889 q 225 638 267 763 q 202 468 202 552 \"},\"\":{\"x_min\":44,\"x_max\":613.453125,\"ha\":644,\"o\":\"m 305 -206 q 350 -218 325 -218 q 447 -177 407 -218 q 487 -79 487 -136 q 376 55 487 4 q 159 156 266 106 q 44 365 44 231 q 143 585 44 499 q 380 672 242 672 q 506 658 448 672 q 613 616 564 645 q 587 500 595 559 l 562 500 q 501 586 549 557 q 391 616 453 616 q 233 551 296 616 q 170 393 170 486 q 216 271 170 320 q 339 196 263 223 l 467 149 q 569 76 531 119 q 608 -27 608 34 q 522 -206 608 -136 q 321 -293 437 -276 l 305 -206 \"},\"M\":{\"x_min\":55,\"x_max\":1165,\"ha\":1238,\"o\":\"m 190 950 l 243 950 q 331 772 291 851 q 412 612 370 693 q 504 436 454 532 l 626 214 q 742 435 671 298 q 882 711 813 572 q 1001 950 952 850 l 1052 950 q 1082 649 1067 791 q 1118 341 1098 508 q 1165 0 1139 174 q 1121 8 1139 5 q 1088 11 1103 11 q 1049 6 1071 11 q 1008 0 1027 2 q 998 226 1008 109 q 974 461 989 343 q 944 695 959 579 l 748 312 q 610 0 665 152 l 594 1 l 576 0 q 227 685 402 364 l 188 307 q 172 128 175 179 q 168 0 168 77 q 138 4 157 1 q 110 6 118 6 q 81 4 93 6 q 55 0 68 2 q 121 333 89 168 q 171 652 152 498 q 190 950 190 805 \"},\"\":{\"x_min\":73,\"x_max\":995.609375,\"ha\":1071,\"o\":\"m 609 0 q 561 5 585 2 q 532 8 536 8 q 494 5 515 8 q 456 0 474 2 q 463 151 456 45 q 470 297 470 258 q 180 383 287 297 q 73 650 73 469 l 73 817 l 73 932 q 139 925 110 925 q 180 928 155 925 q 212 931 206 931 q 200 818 204 861 q 197 723 197 774 l 197 688 l 197 638 q 268 438 197 508 q 472 368 340 368 l 473 481 q 464 736 473 566 q 456 932 456 905 q 499 927 481 929 q 532 925 518 925 q 577 927 557 925 q 609 931 596 930 q 601 635 609 841 q 594 368 594 429 l 645 372 q 816 465 765 372 q 868 691 868 559 q 861 829 868 740 q 855 932 855 919 q 896 927 878 929 q 924 925 913 925 q 971 927 955 925 q 995 931 987 930 l 994 839 l 994 675 q 894 388 994 480 q 594 297 794 297 q 601 142 594 249 q 609 0 609 35 \"},\"C\":{\"x_min\":51,\"x_max\":881.5625,\"ha\":913,\"o\":\"m 828 737 q 552 889 733 889 q 295 768 383 889 q 207 469 207 647 q 299 177 207 305 q 551 50 391 50 q 710 86 637 50 q 855 189 783 122 l 870 183 q 858 122 862 147 q 855 69 855 97 q 521 -15 699 -15 q 180 116 309 -15 q 51 462 51 248 q 189 820 51 690 q 556 950 327 950 q 719 930 638 950 q 881 875 799 911 q 857 809 867 843 q 845 737 847 775 l 828 737 \"},\"\":{\"x_min\":39,\"x_max\":1195.9375,\"ha\":1226,\"o\":\"m 359 -15 q 125 76 212 -15 q 39 318 39 167 q 125 571 39 470 q 362 672 212 672 q 514 640 441 672 q 641 551 588 608 q 897 672 741 672 q 1110 593 1024 672 q 1195 390 1195 515 l 1193 331 q 1022 332 1108 331 q 851 334 935 333 l 708 331 q 765 124 708 206 q 944 42 822 42 q 1145 130 1068 42 l 1162 130 q 1155 85 1158 110 q 1151 47 1152 60 q 1036 0 1100 14 q 904 -15 973 -15 q 754 12 819 -15 q 641 106 689 40 q 514 14 584 44 q 359 -15 444 -15 m 376 625 q 224 534 270 625 q 179 328 179 443 q 224 124 179 215 q 369 34 269 34 q 521 127 470 34 q 573 328 573 221 q 526 534 573 443 q 376 625 480 625 m 1061 392 l 1061 423 q 1017 561 1061 504 q 894 618 973 618 q 756 549 805 618 q 708 390 708 480 l 1061 392 \"},\"!\":{\"x_min\":136,\"x_max\":312,\"ha\":449,\"o\":\"m 223 156 q 285 130 259 156 q 312 68 312 105 q 285 8 312 32 q 223 -15 259 -15 q 161 9 187 -15 q 136 68 136 33 q 160 130 136 105 q 223 156 185 156 m 150 752 l 144 841 q 161 919 144 888 q 223 950 178 950 q 282 925 260 950 q 304 863 304 901 q 299 808 304 845 q 295 752 295 770 l 246 250 q 223 250 238 250 q 199 250 206 250 l 150 752 \"},\"\":{\"x_min\":34,\"x_max\":614.5625,\"ha\":644,\"o\":\"m 607 119 l 592 41 q 490 -2 549 10 q 363 -15 431 -15 q 130 80 227 -15 q 34 313 34 175 q 132 576 34 480 q 397 672 231 672 q 511 659 456 672 q 614 617 565 647 q 597 558 604 587 q 584 492 589 528 l 570 492 q 507 587 547 553 q 406 622 467 622 q 234 534 293 622 q 176 329 176 447 q 238 126 176 211 q 414 42 300 42 q 592 124 521 42 l 607 119 m 202 -212 q 350 -246 273 -246 q 414 -232 388 -246 q 440 -186 440 -219 q 421 -142 440 -158 q 373 -126 402 -126 l 323 -126 l 323 0 l 367 0 l 367 -77 l 404 -73 q 495 -102 457 -73 q 533 -183 533 -132 q 494 -270 533 -237 q 402 -303 456 -303 q 286 -294 335 -303 q 184 -261 238 -286 l 202 -212 \"},\"{\":{\"x_min\":116,\"x_max\":567.390625,\"ha\":683,\"o\":\"m 491 909 q 421 874 445 909 q 397 792 397 839 l 397 744 l 397 583 q 368 434 397 493 q 263 354 339 376 q 367 272 338 332 q 397 125 397 212 l 397 -35 q 414 -149 397 -108 q 471 -197 431 -191 q 529 -204 511 -204 q 567 -204 548 -204 l 567 -276 q 387 -239 459 -276 q 315 -105 315 -203 l 315 -28 l 315 132 q 296 244 315 194 q 240 303 277 294 q 176 314 204 312 q 116 317 148 317 l 116 389 q 270 429 225 389 q 315 576 315 469 l 315 737 q 348 918 315 870 q 450 977 381 966 q 567 983 503 983 l 567 912 l 491 909 \"},\"X\":{\"x_min\":0,\"x_max\":739,\"ha\":739,\"o\":\"m 200 285 l 318 456 q 18 932 159 718 q 63 929 33 932 q 109 926 94 926 q 168 929 147 926 q 198 932 188 932 q 296 743 244 841 q 391 568 348 644 l 489 726 q 597 932 548 825 q 627 927 614 929 q 661 926 641 926 q 693 929 671 926 q 728 932 715 932 q 616 781 673 862 q 524 652 558 700 l 427 512 q 523 347 480 419 q 614 197 566 275 q 739 0 662 119 q 686 3 719 0 q 647 6 652 6 q 595 4 618 6 q 558 0 572 1 q 459 197 512 97 q 353 398 405 298 l 265 249 q 174 96 193 130 q 127 0 155 62 q 89 3 113 0 q 62 6 65 6 q 26 4 43 6 q 0 0 9 1 l 200 285 \"},\"\":{\"x_min\":40,\"x_max\":712,\"ha\":753,\"o\":\"m 371 -15 q 131 79 223 -15 q 40 322 40 173 q 133 572 40 473 q 380 672 227 672 q 621 575 530 672 q 712 327 712 479 q 619 80 712 175 q 371 -15 527 -15 m 332 978 l 421 978 l 572 743 l 525 743 l 376 875 l 229 743 l 180 743 l 332 978 m 377 622 q 227 532 274 622 q 180 327 180 442 q 227 125 180 216 q 375 35 274 35 q 524 124 478 35 q 570 327 570 214 q 524 531 570 441 q 377 622 479 622 \"},\"#\":{\"x_min\":78,\"x_max\":972.4375,\"ha\":1050,\"o\":\"m 497 647 l 675 647 l 791 969 l 877 968 l 761 647 l 972 647 l 948 576 l 736 576 l 671 390 l 896 390 l 873 319 l 644 319 l 531 0 l 446 0 l 559 319 l 382 319 l 266 0 l 182 0 l 294 319 l 78 319 l 102 390 l 320 390 l 386 576 l 151 576 l 176 647 l 410 647 l 526 969 l 610 969 l 497 647 m 472 576 l 407 390 l 587 390 l 650 576 l 472 576 \"},\"\":{\"x_min\":96,\"x_max\":233.5,\"ha\":342,\"o\":\"m 104 333 l 104 521 q 103 567 104 545 q 96 655 102 589 q 141 648 130 648 q 165 647 151 647 q 233 654 196 647 q 224 555 226 599 q 223 437 223 511 l 223 406 q 228 194 223 337 q 233 0 233 51 q 201 3 216 1 q 165 5 185 5 q 127 3 148 5 q 96 0 107 1 q 100 165 96 51 q 104 333 104 279 \"},\"\":{\"x_min\":12,\"x_max\":910.609375,\"ha\":896,\"o\":\"m 328 639 l 458 950 q 489 944 464 947 q 522 950 507 944 q 655 613 602 745 q 770 331 709 480 q 910 0 832 181 q 859 3 891 0 q 823 6 827 6 q 772 4 795 6 q 735 0 749 1 q 672 195 692 135 q 613 353 652 255 l 449 358 l 285 353 l 233 205 q 173 0 194 94 l 116 5 q 76 2 91 5 q 55 0 62 0 q 146 211 101 105 q 229 404 192 317 q 328 639 266 490 m 195 943 q 228 974 213 964 q 265 985 244 985 q 302 969 287 985 q 318 932 318 954 q 303 896 318 911 q 261 866 288 882 l 61 743 l 12 743 l 195 943 m 450 419 l 585 425 l 451 761 l 318 425 l 450 419 \"},\")\":{\"x_min\":65.671875,\"x_max\":332,\"ha\":449,\"o\":\"m 332 376 q 271 81 332 217 q 96 -183 211 -54 q 65 -151 83 -164 q 193 104 155 -16 q 232 386 232 226 q 191 661 232 533 q 65 918 150 789 q 96 950 87 933 q 273 681 215 816 q 332 376 332 545 \"},\"\":{\"x_min\":53,\"x_max\":567,\"ha\":628,\"o\":\"m 506 516 q 433 591 467 566 q 353 616 400 616 q 261 580 298 616 q 225 492 225 545 q 268 406 225 437 q 372 375 311 375 l 418 375 l 417 349 l 417 310 l 343 317 q 236 282 280 317 q 193 183 193 247 q 238 77 193 117 q 352 38 284 38 q 460 66 410 38 q 543 144 510 94 q 553 99 547 121 q 567 54 558 76 q 452 2 515 19 q 321 -15 388 -15 q 134 31 216 -15 q 53 175 53 78 q 95 286 53 246 q 214 355 137 326 q 127 408 162 370 q 93 497 93 445 q 165 625 93 579 q 323 672 237 672 q 430 654 378 672 q 541 604 481 637 q 522 564 529 584 q 506 516 514 545 \"},\"\":{\"x_min\":0,\"x_max\":899,\"ha\":899,\"o\":\"m 899 0 q 701 5 833 0 q 501 11 569 11 q 251 5 418 11 q 0 0 84 0 q 225 473 126 251 q 407 932 323 696 q 432 929 415 932 q 457 926 448 926 q 482 927 471 926 q 505 932 493 929 q 691 449 601 664 q 899 0 782 234 m 281 429 q 158 90 212 259 q 290 84 201 90 q 423 79 379 79 l 456 79 q 587 81 550 79 q 692 90 625 83 l 651 188 l 576 383 l 422 778 l 281 429 \"},\"\":{\"x_min\":43,\"x_max\":655.5,\"ha\":649,\"o\":\"m 234 -15 q 98 33 153 -15 q 43 162 43 82 q 106 303 43 273 q 303 364 169 333 q 444 448 437 395 q 403 568 444 521 q 288 616 362 616 q 191 587 233 616 q 124 507 149 559 l 95 520 l 104 591 q 202 651 144 631 q 323 672 261 672 q 500 622 444 672 q 557 455 557 573 l 557 133 q 567 69 557 84 q 618 54 577 54 q 655 58 643 54 l 655 26 q 594 5 626 14 q 537 -6 562 -3 q 438 85 453 -6 q 342 10 388 35 q 234 -15 296 -15 m 279 978 l 368 978 l 522 743 l 471 743 l 323 875 l 176 743 l 126 743 l 279 978 m 176 186 q 204 98 176 133 q 284 64 232 64 q 390 107 342 64 q 438 212 438 151 l 438 345 q 239 293 303 319 q 176 186 176 268 \"},\"}\":{\"x_min\":114,\"x_max\":567,\"ha\":683,\"o\":\"m 369 576 q 405 438 369 487 q 527 389 441 389 l 567 389 l 567 317 q 415 278 461 317 q 369 132 369 239 l 369 -28 q 319 -229 369 -182 q 114 -276 270 -276 l 114 -204 q 252 -172 218 -204 q 286 -83 286 -141 l 286 -35 l 286 125 q 314 271 286 212 q 418 354 342 329 q 311 435 337 382 q 286 584 286 488 l 286 745 q 268 860 286 818 q 191 913 251 903 l 114 913 l 114 983 l 186 982 q 287 960 242 982 q 346 900 331 938 q 365 822 362 862 q 369 737 369 783 l 369 576 \"},\"\":{\"x_min\":28,\"x_max\":1511,\"ha\":1536,\"o\":\"m 799 0 q 647 62 708 0 q 586 218 586 124 q 647 372 586 309 q 799 436 709 436 q 949 373 888 436 q 1011 223 1011 311 q 995 130 1011 176 q 918 35 972 70 q 799 0 865 0 m 1298 0 q 1146 62 1206 0 q 1087 218 1087 124 q 1148 372 1087 308 q 1299 436 1209 436 q 1449 373 1388 436 q 1511 223 1511 311 q 1494 130 1511 169 q 1418 34 1472 69 q 1298 0 1365 0 m 241 448 q 89 510 150 448 q 28 663 28 573 q 89 820 28 755 q 241 885 151 885 q 391 823 329 885 q 453 672 453 761 q 434 580 453 620 q 359 483 412 518 q 241 448 307 448 m 863 1015 l 227 -125 l 158 -125 l 793 1015 l 863 1015 m 897 260 q 872 353 897 310 q 798 397 847 397 q 718 340 737 397 q 700 202 700 283 q 719 86 700 133 q 798 40 738 40 q 866 73 840 40 q 892 149 892 106 q 895 206 894 169 q 897 260 897 242 m 339 684 q 319 797 339 750 q 244 845 300 845 q 161 784 182 845 q 141 645 141 723 q 165 540 141 590 q 237 490 189 490 q 303 524 278 490 q 334 598 329 558 q 339 684 339 638 m 1397 260 q 1373 356 1397 315 q 1297 397 1349 397 q 1218 340 1237 397 q 1200 202 1200 283 q 1219 87 1200 134 q 1297 40 1238 40 q 1366 73 1340 40 q 1392 149 1392 106 q 1395 206 1394 169 q 1397 260 1397 242 \"},\"\":{\"x_min\":-16,\"x_max\":839.5625,\"ha\":826,\"o\":\"m 258 638 l 389 951 q 420 945 395 948 q 453 951 438 945 q 570 651 500 826 q 688 360 640 477 q 839 0 736 242 q 788 3 820 0 q 752 6 756 6 q 702 3 728 6 q 665 0 675 0 q 599 204 615 158 q 542 357 584 251 l 378 357 l 214 357 l 161 207 q 130 109 147 170 q 102 0 113 47 l 45 5 q 20 4 29 5 q -16 0 10 4 q 72 203 29 105 q 169 427 115 301 q 258 638 222 552 m 293 1208 q 345 1186 325 1208 q 366 1133 366 1164 q 345 1080 366 1102 q 293 1058 324 1058 q 239 1080 261 1058 q 217 1133 217 1102 q 239 1185 217 1163 q 293 1208 261 1208 m 535 1208 q 587 1186 565 1208 q 609 1133 609 1164 q 587 1080 609 1103 q 535 1058 565 1058 q 481 1080 503 1058 q 459 1133 459 1102 q 481 1185 459 1163 q 535 1208 503 1208 m 378 421 l 515 425 l 381 762 l 247 425 l 378 421 \"},\"a\":{\"x_min\":44,\"x_max\":653.734375,\"ha\":647,\"o\":\"m 233 -15 q 99 33 154 -15 q 44 162 44 82 q 105 302 44 273 q 302 363 167 331 q 444 448 437 395 q 401 567 444 519 q 287 615 359 615 q 190 587 231 615 q 124 508 149 560 l 95 519 l 103 591 q 204 651 148 631 q 323 672 260 672 q 499 623 443 672 q 555 457 555 574 l 555 132 q 566 70 555 86 q 616 55 578 55 l 653 55 l 653 26 q 594 4 624 15 q 536 -6 564 -6 q 468 15 492 -6 q 436 83 445 38 q 341 9 387 34 q 233 -15 294 -15 m 175 185 q 204 99 175 135 q 282 63 234 63 q 389 106 343 63 q 436 211 436 150 l 436 344 q 239 294 304 320 q 175 185 175 268 \"},\"\":{\"x_min\":226.390625,\"x_max\":1138.890625,\"ha\":1367,\"o\":\"m 226 375 l 1138 375 l 1138 292 l 226 292 l 226 375 \"},\"=\":{\"x_min\":169.4375,\"x_max\":969.453125,\"ha\":1139,\"o\":\"m 969 499 l 169 499 l 169 564 l 969 564 l 969 499 m 969 248 l 169 248 l 169 315 l 969 315 l 969 248 \"},\"N\":{\"x_min\":98,\"x_max\":911.890625,\"ha\":1011,\"o\":\"m 112 230 q 114 486 112 315 q 117 741 117 656 l 117 950 l 166 950 q 326 766 239 865 q 468 606 413 667 q 610 451 524 544 l 821 227 l 821 604 q 816 765 821 685 q 803 931 812 845 l 855 927 l 911 931 q 901 831 906 884 q 897 741 897 779 q 894 413 897 619 q 892 165 892 207 l 892 -15 l 849 -15 q 730 125 796 50 q 589 281 664 201 l 193 702 l 193 330 q 212 -1 193 169 l 149 2 l 98 -1 q 108 125 105 79 q 112 230 112 170 \"},\"\":{\"x_min\":65,\"x_max\":711,\"ha\":758,\"o\":\"m 191 -99 q 195 -235 191 -145 q 199 -371 199 -325 q 161 -367 169 -367 q 134 -366 153 -366 q 96 -368 116 -366 q 65 -372 76 -370 q 70 -190 65 -311 q 76 -8 76 -69 q 73 166 76 67 q 70 329 71 265 q 148 578 70 484 q 380 672 226 672 q 617 573 524 672 q 711 329 711 474 q 625 84 711 184 q 396 -15 539 -15 q 285 7 334 -15 q 191 78 236 30 l 191 -99 m 377 619 q 231 533 271 619 q 191 327 191 447 q 241 103 191 169 q 376 38 292 38 q 525 125 479 38 q 571 326 571 212 q 525 529 571 440 q 377 619 480 619 \"},\"2\":{\"x_min\":22,\"x_max\":622,\"ha\":749,\"o\":\"m 449 648 q 410 789 449 727 q 298 851 371 851 q 173 802 219 851 q 128 676 128 753 l 118 673 q 84 740 100 712 q 47 799 69 768 q 313 911 158 911 q 507 844 426 911 q 589 667 589 777 q 527 479 589 555 q 315 258 466 404 l 169 118 l 442 118 q 531 123 485 118 q 622 136 576 129 q 617 102 619 117 q 616 68 616 87 q 617 37 616 54 q 622 0 619 20 q 438 4 562 0 q 252 8 315 8 q 142 7 195 8 q 22 0 88 6 l 22 40 q 234 238 155 158 q 380 430 312 319 q 449 648 449 541 \"},\"\":{\"x_min\":90,\"x_max\":664,\"ha\":754,\"o\":\"m 653 498 q 653 329 653 443 q 653 158 653 215 q 664 0 653 82 q 631 3 647 1 q 598 5 616 5 q 563 3 583 5 q 533 0 544 1 l 538 118 q 440 18 494 52 q 312 -15 385 -15 q 148 50 201 -15 q 96 229 96 115 l 96 354 l 96 516 l 90 655 q 120 650 103 651 q 158 648 136 648 q 192 650 175 648 q 227 656 210 651 q 220 446 227 592 q 213 247 213 300 q 247 115 213 163 q 362 68 281 68 q 477 113 428 68 q 531 217 525 159 q 538 340 538 274 q 533 520 538 394 q 528 655 528 647 q 558 650 542 651 q 596 648 574 648 q 629 650 612 648 q 663 656 646 651 q 653 498 653 574 m 253 929 q 307 906 285 929 q 330 854 330 884 q 309 800 330 822 q 257 778 288 778 q 202 800 225 778 q 180 854 180 823 q 200 906 180 884 q 253 929 221 929 m 498 929 q 549 906 527 929 q 572 854 572 884 q 551 799 572 820 q 499 778 531 778 q 444 800 466 778 q 422 854 422 822 q 444 906 422 884 q 498 929 466 929 \"},\"Z\":{\"x_min\":6.9375,\"x_max\":801.390625,\"ha\":828,\"o\":\"m 6 36 q 222 324 112 176 q 425 605 333 473 l 597 857 l 433 857 q 59 836 247 857 l 65 883 l 59 932 q 262 927 134 932 q 427 922 390 922 q 622 927 491 922 q 801 932 754 932 l 801 904 q 594 629 709 785 q 399 361 479 473 q 201 77 319 249 l 427 77 q 581 82 520 77 q 801 103 643 87 l 797 68 l 795 54 l 797 34 l 801 0 q 504 4 683 0 q 325 8 326 8 q 166 4 272 8 q 6 0 61 0 l 6 36 \"},\"u\":{\"x_min\":90,\"x_max\":662.21875,\"ha\":754,\"o\":\"m 653 497 l 653 156 q 654 83 653 122 q 661 -1 656 44 q 623 3 632 2 q 596 4 615 4 q 572 3 581 4 q 533 -1 563 2 l 536 117 q 439 18 491 51 q 313 -15 386 -15 q 147 48 199 -15 q 96 227 96 112 l 96 352 l 96 516 l 90 654 q 158 647 125 647 q 189 648 178 647 q 226 654 200 650 q 220 450 226 586 q 215 246 215 314 q 248 114 215 163 q 361 66 281 66 q 473 112 426 66 q 527 225 520 158 q 536 340 536 282 q 531 497 536 393 q 527 654 527 601 q 572 647 563 647 q 595 647 581 647 q 626 648 616 647 q 662 654 637 650 l 653 497 \"},\"k\":{\"x_min\":97,\"x_max\":677.5625,\"ha\":683,\"o\":\"m 104 656 q 100 873 104 741 q 97 1025 97 1005 q 164 1018 134 1018 q 231 1025 196 1018 q 227 825 231 962 q 223 622 223 687 l 223 377 l 245 377 q 507 654 391 506 q 563 647 538 647 q 616 647 589 647 q 648 652 638 651 l 349 398 l 548 165 q 608 93 577 127 q 677 19 638 59 l 677 0 q 628 3 659 0 q 591 6 597 6 q 544 3 567 6 q 510 0 520 0 q 438 101 473 54 q 360 197 402 148 l 269 308 l 252 324 l 223 326 q 227 164 223 272 q 231 0 231 55 q 200 4 215 2 q 164 5 185 5 q 127 3 146 5 q 97 0 108 1 q 100 386 97 151 q 104 656 104 620 \"},\"\":{\"x_min\":109,\"x_max\":928.453125,\"ha\":1039,\"o\":\"m 257 317 q 262 142 257 253 q 267 0 267 30 q 226 3 253 0 q 188 8 200 8 q 147 3 174 8 q 109 0 121 0 q 116 243 109 72 q 124 465 124 415 q 116 710 124 540 q 109 932 109 880 q 152 929 121 932 q 188 926 183 926 q 231 929 200 926 q 267 932 262 932 q 262 719 267 854 q 257 547 257 584 q 406 544 301 547 q 517 541 511 541 q 666 544 562 541 q 777 547 770 547 q 773 786 777 641 q 769 932 769 930 q 813 929 781 932 q 849 926 845 926 q 893 929 861 926 q 928 932 924 932 q 914 795 920 866 q 909 659 909 723 l 909 505 q 918 252 909 420 q 927 0 927 84 q 887 4 913 0 q 848 8 861 8 q 811 5 829 8 q 769 0 793 2 q 773 103 769 41 q 777 176 777 166 l 777 317 l 777 465 q 604 466 692 465 q 430 469 517 467 l 257 465 l 257 317 \"},\"\":{\"x_min\":-15.28125,\"x_max\":838.890625,\"ha\":825,\"o\":\"m 257 639 l 387 950 q 402 945 395 947 q 417 944 409 944 q 452 950 437 944 q 576 629 536 733 q 686 359 617 526 q 838 0 755 192 q 789 3 820 0 q 751 6 758 6 q 700 4 723 6 q 663 0 677 1 q 600 199 622 137 q 543 353 579 260 l 377 358 l 215 353 l 162 205 q 130 110 145 160 q 101 0 115 59 l 44 5 q 6 2 20 5 q -15 0 -8 0 q 76 211 30 105 q 158 404 121 318 q 257 639 195 490 m 378 419 l 513 425 l 379 761 l 246 425 l 378 419 \"},\"\":{\"x_min\":94,\"x_max\":726,\"ha\":765,\"o\":\"m 107 431 l 107 611 l 107 761 q 200 948 118 872 q 395 1025 283 1025 q 543 979 478 1025 q 608 852 608 933 q 530 709 608 783 q 453 586 453 636 q 589 457 453 547 q 726 259 726 368 q 648 64 726 143 q 453 -15 570 -15 q 379 -6 418 -15 q 309 15 339 1 l 334 128 l 348 127 q 405 70 368 91 q 485 49 442 49 q 583 92 544 49 q 622 193 622 135 q 484 365 622 280 q 347 525 347 450 q 433 667 347 561 q 520 838 520 773 q 483 939 520 899 q 386 979 446 979 q 269 924 313 979 q 226 795 226 870 l 226 629 l 226 344 q 229 141 226 265 q 233 1 233 18 q 196 4 219 1 q 166 8 173 8 q 123 5 142 8 q 94 1 105 2 q 100 250 94 91 q 107 431 107 409 \"},\"\":{\"x_min\":40,\"x_max\":646.9375,\"ha\":681,\"o\":\"m 406 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 313 335 315 335 l 179 331 q 235 127 179 212 q 406 42 291 42 m 406 945 q 440 976 424 966 q 477 986 455 986 q 528 934 528 986 q 513 895 528 912 q 471 866 498 879 l 272 743 l 222 743 l 406 945 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 \"},\"s\":{\"x_min\":68,\"x_max\":531,\"ha\":593,\"o\":\"m 117 161 q 172 69 130 102 q 276 36 214 36 q 378 67 333 36 q 424 152 424 98 q 334 260 424 224 q 168 320 251 290 q 79 460 79 366 q 147 612 79 552 q 310 672 216 672 q 400 660 355 672 q 500 627 446 649 l 461 508 l 448 508 q 401 587 433 561 q 314 614 369 614 q 223 584 262 614 q 185 505 185 555 q 358 375 185 427 q 531 197 531 322 q 450 39 531 93 q 259 -15 369 -15 q 68 23 162 -15 l 103 161 l 117 161 \"},\"B\":{\"x_min\":109,\"x_max\":751,\"ha\":801,\"o\":\"m 127 559 q 109 931 127 759 l 203 929 q 338 932 244 929 q 438 935 432 935 q 629 883 549 935 q 709 726 709 832 q 638 579 709 633 q 464 504 567 524 q 673 438 595 490 q 751 268 751 387 q 639 66 751 133 q 382 0 528 0 l 232 6 q 162 3 211 6 q 109 0 113 0 q 118 287 109 86 q 127 559 127 488 m 256 257 l 256 149 l 261 61 l 337 57 q 526 108 450 57 q 602 266 602 159 q 523 428 602 386 q 312 471 444 471 l 256 471 l 256 257 m 569 706 q 507 834 569 788 q 361 879 446 879 l 261 875 q 252 709 252 798 l 252 522 q 476 558 384 522 q 569 706 569 595 \"},\"\":{\"x_min\":119,\"x_max\":1005,\"ha\":1160,\"o\":\"m 191 130 q 244 108 223 130 q 266 55 266 87 q 244 5 266 25 q 191 -15 223 -15 q 139 4 160 -15 q 119 55 119 23 q 139 108 119 87 q 191 130 159 130 m 560 130 q 612 108 591 130 q 634 55 634 87 q 612 5 634 25 q 560 -15 591 -15 q 507 4 528 -15 q 487 55 487 23 q 507 109 487 88 q 560 130 528 130 m 930 130 q 983 108 962 130 q 1005 55 1005 87 q 983 5 1005 25 q 930 -15 962 -15 q 878 4 899 -15 q 858 55 858 23 q 878 108 858 87 q 930 130 898 130 \"},\"?\":{\"x_min\":128,\"x_max\":520,\"ha\":601,\"o\":\"m 307 156 q 367 130 342 156 q 392 68 392 105 q 367 7 392 30 q 307 -15 343 -15 q 244 8 269 -15 q 220 68 220 32 q 244 130 220 105 q 307 156 269 156 m 329 250 q 214 290 261 250 q 168 399 168 331 q 287 595 168 479 q 406 776 406 712 q 371 858 406 823 q 292 894 337 894 q 207 867 243 894 q 162 794 171 840 l 150 794 q 142 835 146 822 q 128 894 139 849 q 210 936 165 922 q 305 950 255 950 q 457 893 394 950 q 520 748 520 837 q 398 550 520 657 q 276 370 276 443 q 293 316 276 337 q 343 296 310 296 q 397 302 372 296 l 383 256 q 357 251 365 252 q 329 250 348 250 \"},\"H\":{\"x_min\":108,\"x_max\":927.453125,\"ha\":1036,\"o\":\"m 258 318 q 263 143 258 255 q 268 0 268 30 q 229 3 255 0 q 188 8 202 8 q 148 3 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 711 126 620 q 108 932 119 803 q 153 928 124 932 q 188 925 183 925 q 231 928 204 925 q 268 932 259 932 q 263 719 268 854 q 258 547 258 584 l 517 543 l 777 547 q 773 786 777 641 q 769 932 769 930 q 814 928 785 932 q 848 925 842 925 q 894 928 864 925 q 927 932 923 932 q 914 798 919 868 q 909 659 909 729 l 909 448 l 909 283 q 916 135 909 238 q 924 0 924 31 q 885 4 911 0 q 846 8 860 8 q 807 4 832 8 q 769 0 781 0 q 773 101 769 37 q 777 177 777 164 l 777 318 l 777 468 q 604 468 720 468 q 431 468 489 468 l 258 468 l 258 318 \"},\"\":{\"x_min\":0,\"x_max\":632,\"ha\":654,\"o\":\"m 319 8 q 296 5 309 8 q 272 0 283 2 q 200 206 234 120 q 0 654 165 291 q 84 647 45 647 q 113 647 98 647 q 168 654 127 648 q 252 402 204 529 l 360 131 q 469 358 440 267 q 499 520 499 448 q 492 579 499 543 q 477 641 486 615 q 552 649 527 645 q 613 661 576 652 q 628 611 625 623 q 632 576 632 598 q 621 501 632 536 q 560 373 611 466 q 461 190 509 280 q 372 0 412 99 q 345 3 363 0 q 319 8 327 8 \"},\"\":{\"x_min\":-25,\"x_max\":365.328125,\"ha\":340,\"o\":\"m 104 144 l 104 522 l 97 655 q 138 650 113 651 q 167 649 162 649 q 233 655 206 649 q 225 506 225 581 q 229 254 225 423 q 233 0 233 84 q 201 3 216 1 q 164 5 186 5 q 127 3 146 5 q 97 0 108 1 l 104 144 m 125 978 l 214 978 l 365 743 l 319 743 l 170 875 l 24 743 l -25 743 l 125 978 \"},\"c\":{\"x_min\":36,\"x_max\":613.78125,\"ha\":644,\"o\":\"m 606 119 l 594 41 q 493 -3 548 7 q 365 -15 438 -15 q 131 79 227 -15 q 36 312 36 173 q 134 576 36 480 q 399 672 233 672 q 513 658 459 672 q 613 616 566 645 q 586 492 597 563 l 571 492 q 510 586 550 553 q 406 619 470 619 q 235 532 294 619 q 176 327 176 445 q 237 125 176 209 q 415 42 299 42 q 594 122 520 42 l 606 119 \"},\"\":{\"x_min\":18,\"x_max\":531,\"ha\":590,\"o\":\"m 298 968 l 531 968 l 531 910 l 473 910 l 473 4 l 415 4 l 415 910 l 305 910 l 305 4 l 247 4 l 247 558 q 99 602 163 558 q 27 690 36 645 q 18 744 18 734 q 90 896 18 824 q 298 968 163 968 \"},\"\":{\"x_min\":96,\"x_max\":737.671875,\"ha\":779,\"o\":\"m 160 -365 q 129 -367 151 -365 q 96 -369 107 -369 q 100 -253 96 -325 q 104 -169 104 -182 l 104 101 l 104 565 q 168 898 104 771 q 419 1025 232 1025 q 605 960 525 1025 q 686 787 686 895 q 641 641 686 705 q 522 548 597 577 q 682 454 626 515 q 737 290 737 394 q 648 73 737 162 q 431 -15 559 -15 q 324 3 372 -15 q 226 61 276 22 q 224 -44 226 19 q 223 -110 223 -107 l 230 -369 q 193 -367 220 -369 q 160 -365 166 -365 m 356 564 q 507 618 458 564 q 557 779 557 673 q 520 917 557 859 q 407 975 483 975 q 279 906 323 975 q 234 752 234 838 q 232 613 234 701 q 230 506 230 524 l 226 355 l 230 230 q 275 94 230 147 q 406 41 321 41 q 552 116 504 41 q 600 297 600 192 q 550 443 600 386 q 412 499 500 499 q 361 497 384 499 q 327 493 337 494 l 329 516 l 329 565 l 356 564 \"},\"\":{\"x_min\":55,\"x_max\":1165,\"ha\":1238,\"o\":\"m 190 950 l 243 950 q 331 772 291 851 q 412 612 370 693 q 504 436 454 532 l 626 214 q 742 435 671 298 q 882 711 813 572 q 1001 950 952 850 l 1052 950 q 1082 649 1067 791 q 1118 341 1098 508 q 1165 0 1139 174 q 1121 8 1139 5 q 1088 11 1103 11 q 1049 6 1071 11 q 1008 0 1027 2 q 998 226 1008 109 q 974 461 989 343 q 944 695 959 579 l 748 312 q 610 0 665 152 l 594 1 l 576 0 q 227 685 402 364 l 188 307 q 172 128 175 179 q 168 0 168 77 q 138 4 157 1 q 110 6 118 6 q 81 4 93 6 q 55 0 68 2 q 121 333 89 168 q 171 652 152 498 q 190 950 190 805 \"},\"\":{\"x_min\":-1,\"x_max\":1305,\"ha\":1356,\"o\":\"m 288 465 q 429 820 288 690 q 796 950 570 950 q 1129 853 991 950 q 1284 654 1268 757 q 1302 525 1299 551 q 1305 462 1305 500 q 1302 402 1305 426 q 1284 277 1299 379 q 1131 80 1268 175 q 797 -15 993 -15 q 684 -10 733 -15 q 541 29 635 -5 q 367 186 447 64 q 288 465 288 308 m 182 943 q 215 974 200 964 q 251 985 230 985 q 289 969 274 985 q 304 932 304 954 q 290 896 304 911 q 247 866 275 882 l 48 743 l -1 743 l 182 943 m 439 468 q 527 162 439 282 q 796 42 616 42 q 1063 162 975 42 q 1152 468 1152 283 q 1062 770 1152 651 q 796 889 972 889 q 585 826 666 889 q 462 639 504 764 q 439 468 439 552 \"},\"\":{\"x_min\":-1.390625,\"x_max\":1233.046875,\"ha\":1341,\"o\":\"m 564 316 q 569 142 564 254 q 574 0 574 30 q 535 4 561 0 q 494 8 508 8 q 454 4 480 8 q 414 0 427 0 q 423 239 414 70 q 432 465 432 408 q 428 711 432 620 q 414 931 425 802 q 459 928 430 931 q 494 924 489 924 q 537 928 510 924 q 574 931 565 931 q 569 719 574 854 q 564 547 564 584 l 823 543 l 1083 547 q 1078 786 1083 641 q 1074 931 1074 930 q 1119 928 1091 931 q 1153 924 1148 924 q 1199 928 1170 924 q 1233 931 1228 931 q 1221 798 1226 868 q 1217 659 1217 729 l 1215 448 l 1217 283 q 1225 135 1217 238 q 1233 0 1233 31 q 1194 4 1220 0 q 1154 8 1167 8 q 1113 4 1140 8 q 1075 0 1087 0 q 1078 100 1075 37 q 1082 176 1082 163 l 1083 316 l 1083 465 q 910 466 1026 465 q 737 468 795 468 l 564 465 l 564 316 m 181 943 q 215 974 200 964 q 251 985 230 985 q 288 969 273 985 q 304 932 304 954 q 289 896 304 911 q 247 866 275 882 l 47 743 l -1 743 l 181 943 \"},\"\":{\"x_min\":204.171875,\"x_max\":795.828125,\"ha\":1003,\"o\":\"m 501 789 q 709 702 622 789 q 795 493 795 615 q 709 286 795 372 q 501 201 623 201 q 290 286 377 201 q 204 493 204 371 q 226 605 204 550 q 312 725 248 661 q 501 789 376 789 \"},\"\":{\"x_min\":32,\"x_max\":699,\"ha\":750,\"o\":\"m 313 278 q 176 273 268 278 q 50 268 83 268 l 50 335 q 147 332 82 335 q 246 329 213 329 l 313 329 l 313 436 l 176 436 l 50 432 l 50 495 q 182 492 90 495 q 281 490 275 490 l 126 743 l 32 888 l 91 883 l 191 887 q 225 814 208 845 q 287 699 241 783 l 397 512 q 477 653 433 570 q 592 887 521 736 l 643 883 l 699 887 l 625 773 l 554 655 l 454 490 q 593 492 496 490 q 697 495 690 495 l 697 431 l 434 436 l 434 330 l 572 329 q 636 332 595 329 q 697 335 678 335 l 697 268 l 568 278 l 434 278 q 434 143 434 208 q 442 0 435 77 l 365 5 l 299 0 q 310 131 307 54 q 313 278 313 208 \"},\"(\":{\"x_min\":114,\"x_max\":380.5625,\"ha\":449,\"o\":\"m 114 388 q 175 684 114 545 q 351 950 237 822 q 380 918 361 933 q 253 660 291 782 q 215 379 215 538 q 256 103 215 231 q 380 -151 297 -25 q 351 -183 361 -167 q 173 84 232 -50 q 114 388 114 219 \"},\"U\":{\"x_min\":101,\"x_max\":919.0625,\"ha\":1015,\"o\":\"m 181 926 q 228 929 195 926 q 263 932 262 932 q 251 804 255 853 q 248 697 248 755 l 248 457 q 315 134 248 212 q 515 57 382 57 q 733 129 654 57 q 813 334 813 201 l 813 458 l 813 655 q 810 797 813 733 q 798 931 807 862 q 827 927 813 929 q 859 926 841 926 q 888 929 868 926 q 919 932 907 932 q 905 779 909 853 q 902 600 902 705 l 902 366 q 793 81 902 178 q 492 -15 685 -15 q 211 66 307 -15 q 116 323 116 147 l 116 425 l 116 698 q 109 826 116 759 q 101 931 103 893 q 138 927 120 929 q 181 926 156 926 \"},\"\":{\"x_min\":-12,\"x_max\":701,\"ha\":681,\"o\":\"m 642 647 q 701 654 669 647 q 593 440 633 520 q 502 247 553 359 l 411 48 l 411 -90 q 415 -238 411 -138 q 419 -372 419 -337 l 372 -366 q 282 -372 325 -366 q 287 -195 282 -313 q 292 -33 292 -76 q 260 192 292 47 q 170 460 229 338 q 39 583 111 583 l -12 579 l -10 608 l -12 638 q 43 662 14 653 q 101 672 71 672 q 279 554 234 672 q 398 143 324 437 q 496 393 439 244 q 590 654 553 541 q 615 648 607 650 q 642 647 623 647 \"},\"\":{\"x_min\":41,\"x_max\":827.109375,\"ha\":846,\"o\":\"m 705 352 q 803 -1 763 155 l 739 1 l 673 -1 l 632 172 q 521 36 593 87 q 356 -15 448 -15 q 129 81 217 -15 q 41 316 41 177 q 130 569 41 467 q 368 672 220 672 q 537 622 464 672 q 659 486 610 573 q 711 654 691 569 l 770 650 l 827 654 q 763 505 792 576 q 705 352 734 434 m 377 619 q 226 530 272 619 q 181 326 181 442 q 223 124 181 214 q 367 34 265 34 q 528 137 480 34 q 601 323 577 240 q 527 531 578 444 q 377 619 475 619 \"},\"F\":{\"x_min\":108,\"x_max\":613.5625,\"ha\":671,\"o\":\"m 258 316 q 263 142 258 254 q 268 0 268 30 q 229 3 255 0 q 188 8 202 8 q 148 3 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 711 126 620 q 108 932 119 802 l 358 928 l 613 931 l 610 886 l 613 836 q 505 855 549 851 q 388 860 460 860 l 260 860 l 258 671 l 258 528 l 398 528 q 587 541 480 528 l 584 497 l 587 451 l 394 463 l 258 463 l 258 316 \"},\"\":{\"x_min\":0,\"x_max\":683.328125,\"ha\":683,\"o\":\"m 0 374 l 683 374 l 683 289 l 0 289 l 0 374 \"},\":\":{\"x_min\":134,\"x_max\":309,\"ha\":446,\"o\":\"m 222 636 q 284 611 259 636 q 309 548 309 586 q 284 486 309 512 q 222 461 260 461 q 160 486 186 461 q 134 548 134 511 q 159 610 134 584 q 222 636 185 636 m 221 156 q 283 131 257 156 q 309 69 309 107 q 284 8 309 32 q 221 -15 259 -15 q 159 9 185 -15 q 134 69 134 33 q 159 131 134 107 q 221 156 185 156 \"},\"\":{\"x_min\":0,\"x_max\":739,\"ha\":739,\"o\":\"m 200 285 l 318 456 q 18 932 159 718 q 63 929 33 932 q 109 926 94 926 q 168 929 147 926 q 198 932 188 932 q 296 743 244 841 q 391 568 348 644 l 489 726 q 597 932 548 825 q 627 927 614 929 q 661 926 641 926 q 693 929 671 926 q 728 932 715 932 q 616 781 673 862 q 524 652 558 700 l 427 512 q 523 347 480 419 q 614 197 566 275 q 739 0 662 119 q 686 3 719 0 q 647 6 652 6 q 595 4 618 6 q 558 0 572 1 q 459 197 512 97 q 353 398 405 298 l 265 249 q 174 96 193 130 q 127 0 155 62 q 89 3 113 0 q 62 6 65 6 q 26 4 43 6 q 0 0 9 1 l 200 285 \"},\"*\":{\"x_min\":94,\"x_max\":580,\"ha\":675,\"o\":\"m 336 940 q 367 944 349 940 q 389 948 385 948 q 368 850 375 902 q 362 747 362 799 q 522 873 442 800 q 548 812 539 829 q 580 778 556 796 q 386 702 485 750 q 476 661 427 680 q 575 629 524 643 q 521 535 539 587 q 441 604 478 573 q 362 661 403 634 q 369 564 362 615 q 391 459 377 513 q 360 463 379 459 q 336 467 340 467 q 306 463 325 467 q 282 459 288 459 q 304 568 296 522 q 313 661 313 615 q 152 535 221 602 q 128 589 138 569 q 97 630 117 608 q 185 661 140 643 q 287 704 231 679 q 189 746 234 728 q 94 777 145 763 q 125 818 113 795 q 150 873 137 841 q 227 805 184 839 q 313 747 269 771 q 309 810 313 784 q 282 950 305 836 q 310 942 297 945 q 336 940 324 940 \"},\"\":{\"x_min\":176,\"x_max\":508,\"ha\":683,\"o\":\"m 176 889 q 228 1010 176 961 q 355 1060 280 1060 q 460 1011 413 1060 q 508 904 508 962 q 455 785 508 839 q 337 731 402 731 q 222 776 269 731 q 176 889 176 821 m 241 880 q 266 805 241 836 q 336 775 292 775 q 413 811 386 775 q 441 899 441 847 q 417 985 441 952 q 343 1018 393 1018 q 281 995 307 1018 q 247 940 254 973 q 241 880 241 906 \"},\"V\":{\"x_min\":0,\"x_max\":852.78125,\"ha\":853,\"o\":\"m 190 477 l 74 759 l 0 932 l 83 926 q 134 929 98 926 q 173 931 170 931 q 206 829 187 884 q 248 704 224 773 l 308 548 l 454 153 l 586 502 q 729 931 666 713 l 790 927 l 852 931 q 643 467 748 720 q 470 0 538 215 q 445 4 457 1 q 418 6 432 6 q 384 3 399 6 q 366 0 368 0 q 279 256 331 123 q 190 477 226 389 \"},\"\":{\"x_min\":58.328125,\"x_max\":818.0625,\"ha\":878,\"o\":\"m 437 821 q 258 817 377 821 q 77 813 138 813 q 84 851 83 838 q 84 872 84 864 q 77 932 84 900 q 256 928 137 932 q 437 924 376 924 q 618 928 497 924 q 797 932 738 932 l 791 872 q 794 842 791 861 q 797 813 797 822 q 619 817 738 813 q 437 821 500 821 m 470 430 q 335 425 440 430 q 183 421 230 421 q 187 456 186 433 q 188 481 188 480 q 183 543 188 515 q 304 538 215 543 q 437 533 394 533 q 572 538 481 533 q 694 543 662 543 l 687 482 l 694 421 q 572 425 650 421 q 470 430 494 430 m 437 8 q 250 4 376 8 q 58 0 123 0 l 63 63 l 58 129 q 268 124 134 129 q 437 119 401 119 q 636 124 502 119 q 818 129 769 129 l 813 63 l 818 0 q 627 4 754 0 q 437 8 501 8 \"},\"\":{\"x_min\":0,\"x_max\":0,\"ha\":375},\"\":{\"x_min\":-26,\"x_max\":746,\"ha\":708,\"o\":\"m 299 177 l 299 387 q 190 577 235 501 q 87 747 146 652 q -26 931 29 841 q 23 929 -13 931 q 65 926 61 926 q 110 929 78 926 q 146 931 143 931 q 208 800 175 866 q 278 676 241 734 l 391 475 q 627 931 519 693 l 683 927 q 721 929 701 927 q 746 931 741 931 q 652 786 702 866 q 557 627 602 705 l 432 415 l 432 241 q 435 97 432 184 q 439 0 439 10 q 395 4 414 2 q 361 6 376 6 q 320 4 336 6 q 286 0 304 2 q 294 88 290 36 q 299 177 299 141 m 233 1208 q 286 1187 265 1208 q 307 1133 307 1166 q 285 1080 307 1103 q 233 1058 263 1058 q 179 1080 202 1058 q 157 1133 157 1103 q 179 1186 157 1164 q 233 1208 202 1208 m 475 1208 q 528 1186 506 1208 q 550 1133 550 1164 q 528 1080 550 1103 q 475 1058 506 1058 q 422 1080 444 1058 q 400 1133 400 1102 q 421 1186 400 1164 q 475 1208 443 1208 \"},\"0\":{\"x_min\":48,\"x_max\":699,\"ha\":749,\"o\":\"m 372 909 q 621 773 544 909 q 699 451 699 637 q 627 116 699 252 q 372 -19 556 -19 q 120 114 193 -19 q 48 444 48 247 q 120 774 48 639 q 372 909 193 909 m 187 365 q 226 137 187 238 q 373 37 266 37 q 457 62 421 37 q 519 142 494 88 q 552 271 545 196 q 559 455 559 346 q 526 736 559 622 q 371 851 493 851 q 245 783 280 851 q 198 647 210 716 q 187 444 187 577 l 187 365 \"},\"\":{\"x_min\":104.171875,\"x_max\":570.828125,\"ha\":625,\"o\":\"m 184 858 q 211 924 193 898 q 265 951 230 951 q 320 903 316 951 q 310 856 320 881 q 283 812 300 831 l 136 568 l 104 576 l 184 858 m 433 858 q 468 928 452 905 q 516 951 483 951 q 555 938 540 951 q 570 903 570 926 q 561 859 570 881 q 536 812 552 837 l 387 568 l 355 576 l 433 858 \"},\"@\":{\"x_min\":78,\"x_max\":1289,\"ha\":1367,\"o\":\"m 906 640 l 970 640 l 876 266 l 864 203 q 886 157 864 172 q 940 142 908 142 q 1136 262 1062 142 q 1211 513 1211 383 q 1067 801 1211 693 q 735 909 923 909 q 324 753 495 909 q 154 362 154 598 q 301 1 154 135 q 679 -132 448 -132 q 904 -99 791 -132 q 1105 -6 1016 -67 l 1129 -43 q 923 -150 1033 -113 q 694 -188 812 -188 q 258 -43 439 -188 q 78 350 78 100 q 273 791 78 614 q 737 969 469 969 q 1122 843 955 969 q 1289 507 1289 717 q 1187 214 1289 346 q 930 82 1086 82 q 835 103 879 82 q 792 170 792 124 l 792 203 q 709 116 762 150 q 595 82 655 82 q 439 139 493 82 q 386 302 386 197 q 471 553 386 441 q 692 665 556 665 q 797 639 754 665 q 864 556 840 613 l 906 640 m 849 477 q 796 572 835 535 q 701 609 758 609 q 529 511 592 609 q 467 297 467 413 q 503 184 467 230 q 605 139 540 139 q 733 188 679 139 q 807 313 787 238 l 849 477 \"},\"\":{\"x_min\":-1.390625,\"x_max\":580.0625,\"ha\":690,\"o\":\"m 433 465 q 429 711 433 620 q 414 931 426 802 q 461 927 435 929 q 498 925 487 925 q 546 928 517 925 q 580 931 575 931 q 572 788 580 887 q 564 659 564 690 l 562 448 l 564 283 q 572 135 564 238 q 580 0 580 31 q 539 4 567 0 q 498 8 512 8 q 457 5 480 8 q 414 0 435 2 q 423 239 414 70 q 433 465 433 408 m 181 943 q 215 974 200 964 q 251 985 230 985 q 288 969 273 985 q 304 932 304 954 q 289 896 304 911 q 247 866 275 882 l 47 743 l -1 743 l 181 943 \"},\"\":{\"x_min\":40,\"x_max\":712,\"ha\":753,\"o\":\"m 371 -15 q 131 79 223 -15 q 40 322 40 173 q 133 572 40 473 q 380 672 227 672 q 621 575 530 672 q 712 327 712 479 q 619 80 712 175 q 371 -15 527 -15 m 253 929 q 307 906 285 929 q 330 854 330 884 q 309 800 330 822 q 257 778 288 778 q 202 800 225 778 q 180 854 180 823 q 200 906 180 884 q 253 929 221 929 m 498 929 q 549 906 527 929 q 572 854 572 884 q 551 799 572 820 q 499 778 531 778 q 444 800 466 778 q 422 854 422 822 q 444 906 422 884 q 498 929 466 929 m 377 622 q 227 532 274 622 q 180 327 180 442 q 227 125 180 216 q 375 35 274 35 q 524 124 478 35 q 570 327 570 214 q 524 531 570 441 q 377 622 479 622 \"},\"i\":{\"x_min\":91.765625,\"x_max\":244,\"ha\":342,\"o\":\"m 100 144 l 100 520 l 93 654 q 161 648 130 648 q 194 649 182 648 q 229 654 207 650 q 221 579 224 616 q 219 505 219 543 q 224 240 219 417 q 229 0 229 63 q 197 3 212 1 q 161 5 181 5 q 116 2 131 5 q 91 0 100 0 l 100 144 m 168 963 q 223 940 202 963 q 244 881 244 917 q 222 831 244 849 q 168 813 200 813 q 115 833 137 813 q 93 885 93 853 q 113 941 93 919 q 168 963 134 963 \"},\"\":{\"x_min\":109,\"x_max\":751,\"ha\":801,\"o\":\"m 127 559 q 109 931 127 759 l 203 929 q 338 932 244 929 q 438 935 432 935 q 629 883 549 935 q 709 726 709 832 q 638 579 709 633 q 464 504 567 524 q 673 438 595 490 q 751 268 751 387 q 639 66 751 133 q 382 0 528 0 l 232 6 q 162 3 211 6 q 109 0 113 0 q 118 287 109 86 q 127 559 127 488 m 256 257 l 256 149 l 261 61 l 337 57 q 526 108 450 57 q 602 266 602 159 q 523 428 602 386 q 312 471 444 471 l 256 471 l 256 257 m 569 706 q 507 834 569 788 q 361 879 446 879 l 261 875 q 252 709 252 798 l 252 522 q 476 558 384 522 q 569 706 569 595 \"},\"\":{\"x_min\":176,\"x_max\":962.703125,\"ha\":1139,\"o\":\"m 288 491 l 962 266 l 962 196 l 176 462 l 176 521 l 962 788 l 962 718 l 288 491 m 962 26 l 176 26 l 176 93 l 962 93 l 962 26 \"},\"\":{\"x_min\":79,\"x_max\":703,\"ha\":774,\"o\":\"m 703 397 q 596 110 703 236 q 332 -15 489 -15 q 145 54 211 -15 q 79 244 79 123 l 83 430 q 81 542 83 486 q 79 654 80 598 l 146 650 l 217 654 q 209 503 217 608 q 202 366 202 398 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 133 476 43 q 571 341 571 223 q 548 493 571 418 q 488 645 526 568 q 550 648 529 645 q 627 659 571 650 q 703 397 703 538 \"},\"]\":{\"x_min\":83,\"x_max\":332,\"ha\":449,\"o\":\"m 209 -154 l 83 -158 l 85 -129 l 85 -98 q 183 -104 128 -104 l 229 -104 l 232 386 l 232 880 l 185 880 q 134 877 162 880 q 83 872 107 874 l 85 903 l 85 932 l 205 929 l 332 929 q 326 852 332 909 q 321 766 321 794 l 321 455 l 321 2 l 332 -158 l 209 -154 \"},\"m\":{\"x_min\":91,\"x_max\":1075,\"ha\":1167,\"o\":\"m 101 155 l 101 494 q 98 568 101 529 q 91 654 96 606 q 155 647 123 647 l 221 654 l 216 537 q 317 638 261 604 q 450 672 373 672 q 629 547 581 672 q 733 639 677 606 q 860 672 789 672 q 1018 606 968 672 q 1069 429 1069 540 l 1069 298 l 1069 136 l 1075 0 q 1038 3 1063 0 q 1006 6 1013 6 q 968 3 992 6 q 938 0 943 0 q 944 203 938 68 q 950 406 950 338 q 918 536 950 486 q 810 587 887 587 q 699 540 745 587 q 648 452 653 493 q 642 376 643 410 q 641 326 641 342 l 641 314 q 644 132 641 258 q 647 0 647 6 q 607 4 621 2 q 581 5 593 5 q 542 2 570 5 q 514 0 515 0 q 519 168 514 55 q 524 321 524 280 l 524 406 q 490 534 524 482 q 383 587 457 587 q 273 541 314 587 q 223 436 231 496 q 216 314 216 376 q 219 133 216 244 q 222 0 222 22 q 183 3 207 0 q 154 6 159 6 q 117 4 134 6 q 91 0 100 1 l 101 155 \"},\"\":{\"x_min\":-1,\"x_max\":725.390625,\"ha\":713,\"o\":\"m 500 426 q 554 536 528 476 q 607 654 580 595 l 675 650 l 725 652 q 623 507 672 586 q 519 330 573 427 l 444 197 q 575 -85 507 55 q 719 -371 643 -227 q 665 -371 701 -371 q 611 -371 629 -371 l 560 -371 q 444 -115 497 -230 q 358 72 392 -1 l 255 -95 q 178 -237 208 -174 q 125 -371 147 -299 l 62 -371 l 0 -371 q 125 -192 68 -278 q 240 -5 182 -106 l 324 136 l 201 402 q 146 519 174 460 q 43 587 103 587 l -1 584 l -1 638 q 128 672 57 672 q 222 627 181 672 q 292 522 264 583 l 359 374 l 411 260 l 500 426 \"},\"8\":{\"x_min\":59,\"x_max\":689,\"ha\":749,\"o\":\"m 110 696 q 187 853 110 797 q 370 909 264 909 q 558 854 480 909 q 636 694 636 800 q 589 575 636 621 q 467 510 543 529 l 467 499 q 630 413 572 475 q 689 247 689 351 q 597 51 689 120 q 374 -18 505 -18 q 149 48 239 -18 q 59 247 59 115 q 118 414 59 347 q 281 499 178 480 l 281 510 q 157 570 205 521 q 110 696 110 619 m 371 531 q 472 577 437 531 q 507 693 507 624 q 470 810 507 764 q 366 856 433 856 q 271 807 305 856 q 238 693 238 758 q 271 578 238 625 q 371 531 305 531 m 373 31 q 505 97 461 31 q 550 255 550 164 q 506 415 550 348 q 373 482 462 482 q 239 416 283 482 q 195 255 195 351 q 240 96 195 162 q 373 31 285 31 \"},\"\":{\"x_min\":96,\"x_max\":429.34375,\"ha\":342,\"o\":\"m 104 333 l 104 520 q 103 566 104 544 q 96 654 102 588 q 141 647 130 648 q 165 647 151 647 q 233 654 196 647 q 224 555 226 599 q 223 437 223 511 l 223 406 q 228 194 223 337 q 233 0 233 51 q 201 3 216 1 q 165 5 185 5 q 127 3 148 5 q 96 0 107 1 q 100 165 96 51 q 104 333 104 279 m 308 943 q 341 974 326 964 q 377 985 357 985 q 415 969 401 985 q 429 932 429 954 q 414 896 429 912 q 373 866 400 880 l 174 743 l 125 743 l 308 943 \"},\"\":{\"x_min\":6.9375,\"x_max\":801.390625,\"ha\":828,\"o\":\"m 6 36 q 222 324 112 176 q 425 605 333 473 l 597 857 l 433 857 q 59 836 247 857 l 65 883 l 59 932 q 262 927 134 932 q 427 922 390 922 q 622 927 491 922 q 801 932 754 932 l 801 904 q 594 629 709 785 q 399 361 479 473 q 201 77 319 249 l 427 77 q 581 82 520 77 q 801 103 643 87 l 797 68 l 795 54 l 797 34 l 801 0 q 504 4 683 0 q 325 8 326 8 q 166 4 272 8 q 6 0 61 0 l 6 36 \"},\"R\":{\"x_min\":109,\"x_max\":806.234375,\"ha\":785,\"o\":\"m 261 0 q 223 3 248 0 q 185 8 198 8 q 148 5 168 8 q 109 0 127 2 q 118 306 109 90 q 127 598 127 523 q 122 761 127 672 q 109 931 117 849 l 203 929 l 409 935 q 618 882 529 935 q 708 719 708 830 q 634 559 708 615 q 442 473 560 503 q 620 240 533 355 q 806 0 708 124 l 732 5 l 610 0 q 449 240 529 127 q 283 455 369 353 l 251 455 l 251 307 q 256 138 251 245 q 261 0 261 31 m 570 699 q 504 835 570 791 q 344 879 439 879 l 261 875 q 253 772 255 834 q 251 701 251 709 l 251 504 q 479 542 388 504 q 570 699 570 581 \"},\"\":{\"x_min\":203.984375,\"x_max\":938.015625,\"ha\":1139,\"o\":\"m 892 775 l 938 729 l 616 406 l 938 86 l 892 38 l 571 361 l 247 38 l 203 86 l 525 407 l 204 729 l 247 775 l 570 453 l 892 775 \"},\"o\":{\"x_min\":41,\"x_max\":710,\"ha\":753,\"o\":\"m 371 -15 q 131 78 222 -15 q 41 322 41 172 q 133 573 41 474 q 378 672 225 672 q 619 574 528 672 q 710 326 710 477 q 617 80 710 175 q 371 -15 525 -15 m 377 619 q 226 530 272 619 q 180 327 180 441 q 227 125 180 216 q 375 35 274 35 q 524 123 478 35 q 570 326 570 211 q 524 529 570 440 q 377 619 479 619 \"},\"5\":{\"x_min\":75,\"x_max\":654,\"ha\":749,\"o\":\"m 116 201 q 176 77 131 120 q 303 35 221 35 q 454 98 396 35 q 512 255 512 161 q 457 407 512 346 q 313 469 403 469 q 170 417 227 469 l 150 428 l 158 526 q 158 662 158 570 q 158 801 158 754 l 147 888 l 383 879 l 412 879 q 628 887 520 879 q 624 848 626 870 q 622 818 622 826 l 626 760 l 425 761 l 227 761 q 221 631 227 717 q 216 500 216 544 q 375 536 296 536 q 572 465 491 536 q 654 279 654 394 q 550 60 654 139 q 304 -18 447 -18 q 179 -6 231 -18 q 75 34 127 4 q 101 201 87 118 l 116 201 \"},\"7\":{\"x_min\":122.609375,\"x_max\":729.5625,\"ha\":749,\"o\":\"m 461 553 l 586 770 l 362 770 q 129 755 232 770 q 133 786 132 769 q 135 820 135 804 q 128 888 135 853 l 408 883 l 729 887 l 729 871 q 463 429 582 641 q 251 0 344 216 l 194 8 q 153 5 169 8 q 122 0 137 2 q 214 146 179 91 q 333 339 249 201 q 461 553 417 477 \"},\"K\":{\"x_min\":108,\"x_max\":856.625,\"ha\":821,\"o\":\"m 255 314 q 261 132 255 250 q 268 0 268 13 q 229 4 255 0 q 188 8 202 8 q 148 4 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 712 126 621 q 108 932 119 803 q 153 928 124 932 q 188 925 183 925 q 231 928 203 925 q 267 932 259 932 l 255 671 l 255 499 q 480 693 375 586 q 687 932 585 800 q 732 932 710 932 q 777 932 753 932 l 837 932 q 606 727 720 830 q 389 522 493 623 q 525 358 465 426 q 666 202 586 290 q 856 0 747 115 l 746 0 q 692 -1 716 0 q 644 -8 669 -2 q 571 92 610 44 q 477 204 532 140 l 255 459 l 255 314 \"},\",\":{\"x_min\":40.28125,\"x_max\":272.21875,\"ha\":374,\"o\":\"m 131 75 q 160 147 144 120 q 213 175 176 175 q 272 119 272 175 q 259 67 272 91 q 231 18 245 43 l 73 -243 l 40 -231 l 131 75 \"},\"d\":{\"x_min\":55,\"x_max\":676,\"ha\":758,\"o\":\"m 668 762 l 672 137 l 676 -1 q 638 3 653 1 q 611 5 623 5 q 574 2 597 5 q 547 -1 551 -1 l 557 119 q 336 -15 484 -15 q 127 86 200 -15 q 55 330 55 187 q 127 569 55 467 q 332 672 199 672 q 457 643 402 672 q 551 556 513 615 l 551 756 l 551 789 l 551 818 q 542 1025 551 927 q 609 1018 576 1018 q 639 1019 628 1018 q 675 1025 651 1020 l 668 762 m 374 57 q 515 139 473 57 q 557 332 557 222 q 513 522 557 437 q 374 607 470 607 q 236 522 278 607 q 194 332 194 438 q 235 141 194 225 q 374 57 277 57 \"},\"\":{\"x_min\":83.71875,\"x_max\":550.390625,\"ha\":625,\"o\":\"m 471 659 q 441 593 458 618 q 389 568 424 568 q 350 579 365 568 q 335 613 335 591 q 346 660 335 633 q 371 706 358 687 l 519 950 l 550 940 l 471 659 m 221 659 q 192 593 211 618 q 137 568 174 568 q 83 613 83 568 q 93 658 83 637 q 119 706 103 680 l 268 950 l 300 940 l 221 659 \"},\"E\":{\"x_min\":108,\"x_max\":613.5625,\"ha\":686,\"o\":\"m 126 465 q 122 711 126 620 q 108 932 119 802 l 353 928 l 610 931 l 606 884 l 610 836 q 508 853 562 847 q 408 860 453 860 l 260 860 l 258 671 l 258 528 l 398 528 q 587 541 480 528 l 584 497 l 587 451 l 394 463 l 258 463 l 258 316 l 264 73 q 456 76 380 73 q 613 94 531 80 l 610 47 l 613 0 l 358 4 l 108 0 q 117 239 108 70 q 126 465 126 408 \"},\"Y\":{\"x_min\":-28,\"x_max\":746,\"ha\":707,\"o\":\"m 297 177 l 297 386 q 191 570 256 458 q 84 750 125 682 q -28 932 42 819 q 24 928 -9 932 q 63 925 59 925 q 112 927 91 925 q 146 932 134 930 q 207 800 174 866 q 275 676 239 735 l 389 475 q 509 688 451 575 q 627 932 567 801 l 683 926 q 715 927 701 926 q 746 932 729 929 q 555 627 640 769 l 432 415 l 432 240 q 435 101 432 198 q 438 0 438 5 q 401 4 426 1 q 361 6 376 6 q 319 4 334 6 q 284 0 304 2 q 292 88 288 36 q 297 177 297 140 \"},\"\\\"\":{\"x_min\":64,\"x_max\":315,\"ha\":379,\"o\":\"m 133 587 l 64 587 l 64 957 l 133 957 l 133 587 m 315 587 l 247 587 l 247 957 l 315 957 l 315 587 \"},\"\":{\"x_min\":40,\"x_max\":646.9375,\"ha\":681,\"o\":\"m 406 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 314 335 315 335 l 179 331 q 235 127 179 212 q 406 42 291 42 m 296 978 l 386 978 l 537 743 l 488 743 l 340 875 l 193 743 l 143 743 l 296 978 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 \"},\"\":{\"x_min\":41,\"x_max\":670,\"ha\":710,\"o\":\"m 102 840 q 185 981 102 937 q 375 1025 268 1025 q 497 1010 436 1025 q 621 968 559 995 q 595 876 604 923 q 500 947 547 923 q 393 972 453 972 q 280 937 328 972 q 233 840 233 902 q 272 742 233 794 q 434 627 312 691 q 613 504 556 563 q 670 305 670 445 q 581 75 670 165 q 350 -15 492 -15 q 125 73 210 -15 q 41 305 41 162 q 113 526 41 430 q 306 622 186 622 q 145 726 189 674 q 102 840 102 779 m 356 576 q 221 492 261 576 q 181 302 181 409 q 223 118 181 203 q 356 34 265 34 q 490 116 450 34 q 530 307 530 198 q 489 492 530 409 q 356 576 449 576 \"},\"\":{\"x_min\":53,\"x_max\":598.828125,\"ha\":628,\"o\":\"m 506 516 q 433 591 467 566 q 353 616 400 616 q 261 580 298 616 q 225 492 225 545 q 268 406 225 437 q 372 375 311 375 l 418 375 l 417 352 l 417 313 l 343 317 q 237 282 281 317 q 193 185 193 247 q 238 78 193 118 q 352 38 284 38 q 460 66 410 38 q 543 144 510 94 q 553 99 547 121 q 567 54 558 76 q 452 2 515 19 q 321 -15 388 -15 q 134 31 216 -15 q 53 176 53 78 q 96 286 53 246 q 214 355 139 326 q 127 408 162 370 q 93 497 93 445 q 165 625 93 579 q 323 672 237 672 q 430 654 378 672 q 541 604 481 637 q 522 564 529 584 q 506 516 514 545 m 476 944 q 510 975 494 965 q 547 986 526 986 q 584 970 569 986 q 598 933 598 954 q 584 898 598 912 q 541 867 569 884 l 342 744 l 293 744 l 476 944 \"},\"\":{\"x_min\":39.71875,\"x_max\":1028.9375,\"ha\":1068,\"o\":\"m 535 526 l 596 528 l 594 305 q 616 117 594 193 q 722 42 638 42 q 850 118 811 42 q 888 293 888 194 q 829 502 888 409 q 664 654 769 594 l 717 648 q 805 654 766 648 q 967 510 905 606 q 1028 304 1028 413 q 948 81 1028 177 q 744 -15 867 -15 q 622 16 678 -15 q 534 104 566 47 q 445 16 500 48 q 323 -15 389 -15 q 118 83 196 -15 q 39 311 39 182 q 100 511 39 419 q 262 654 161 604 q 303 650 278 651 q 349 648 327 648 l 402 654 q 238 501 296 593 q 179 291 179 409 q 218 116 179 191 q 348 42 257 42 q 419 68 390 42 q 461 137 448 94 q 472 216 469 175 q 475 303 475 257 q 472 419 475 353 q 469 528 470 485 l 535 526 \"},\"\":{\"x_min\":90.28125,\"x_max\":305.5625,\"ha\":374,\"o\":\"m 169 859 q 197 923 177 894 q 250 953 218 953 q 288 939 272 953 q 305 902 305 925 q 295 857 305 882 q 269 811 284 833 l 120 568 l 90 576 l 169 859 \"},\"\":{\"x_min\":169,\"x_max\":969,\"ha\":1139,\"o\":\"m 602 549 l 969 549 l 969 482 l 602 482 l 602 247 l 534 247 l 534 482 l 169 482 l 169 549 l 534 549 l 534 779 l 602 779 l 602 549 m 969 33 l 169 33 l 169 100 l 969 100 l 969 33 \"},\"|\":{\"x_min\":305,\"x_max\":376,\"ha\":683,\"o\":\"m 376 448 l 305 448 l 305 956 l 376 956 l 376 448 m 376 -233 l 305 -233 l 305 272 l 376 272 l 376 -233 \"},\"\":{\"x_min\":79,\"x_max\":703,\"ha\":774,\"o\":\"m 703 395 q 595 110 703 236 q 332 -15 488 -15 q 145 54 211 -15 q 79 244 79 123 l 83 429 q 81 542 83 486 q 79 654 80 598 l 146 650 l 217 654 q 209 502 217 608 q 202 365 202 397 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 132 476 43 q 571 340 571 222 q 548 493 571 418 q 488 645 526 568 q 550 647 529 645 q 627 658 571 650 q 703 395 703 537 m 227 928 q 281 907 259 928 q 304 853 304 886 q 283 800 304 822 q 230 778 262 778 q 175 800 197 778 q 153 853 153 822 q 174 906 153 884 q 227 928 195 928 m 469 928 q 523 906 501 928 q 545 853 545 884 q 524 799 545 821 q 472 778 504 778 q 418 800 440 778 q 396 853 396 822 q 416 905 396 883 q 469 928 437 928 \"},\"\":{\"x_min\":64,\"x_max\":620,\"ha\":675,\"o\":\"m 114 36 l 128 36 q 198 -76 148 -33 q 319 -120 247 -120 q 430 -78 384 -120 q 476 27 476 -37 q 369 169 476 116 q 170 252 269 210 q 64 419 64 312 q 91 522 64 476 q 171 609 119 568 q 122 739 122 669 q 195 896 122 837 q 369 956 268 956 q 473 940 422 956 q 576 894 523 925 q 559 864 568 882 q 521 775 551 846 l 508 775 q 445 871 483 839 q 343 903 407 903 q 251 867 289 903 q 213 777 213 832 q 318 644 213 694 q 514 563 415 604 q 620 408 620 507 q 592 299 620 348 q 515 213 565 251 q 560 143 544 179 q 576 65 576 108 q 494 -112 576 -46 q 298 -178 412 -178 q 179 -163 239 -178 q 76 -119 120 -148 q 97 -42 86 -89 q 114 36 108 4 m 138 479 q 257 340 138 396 q 478 238 376 285 q 524 285 508 261 q 541 342 541 310 q 384 490 541 423 q 197 587 228 556 q 156 532 175 563 q 138 479 138 501 \"},\"b\":{\"x_min\":78,\"x_max\":703,\"ha\":758,\"o\":\"m 152 1018 q 219 1025 181 1018 q 212 916 214 966 q 210 788 210 866 l 210 755 l 210 555 q 419 672 283 672 q 629 569 555 672 q 703 322 703 466 q 630 79 703 173 q 414 -15 558 -15 q 296 8 350 -15 q 193 79 242 31 q 160 49 175 64 q 120 -1 145 33 l 78 -1 q 87 106 82 43 q 92 213 92 169 l 92 545 q 88 784 92 625 q 85 1025 85 944 q 152 1018 119 1018 m 383 605 q 243 520 285 605 q 202 323 202 435 q 245 133 202 218 q 383 48 288 48 q 522 132 480 48 q 564 326 564 217 q 522 519 564 434 q 383 605 480 605 \"},\"q\":{\"x_min\":54,\"x_max\":675,\"ha\":758,\"o\":\"m 608 -368 q 579 -368 591 -368 q 540 -373 567 -369 q 549 -213 548 -312 q 551 -101 551 -115 l 551 99 q 339 -15 476 -15 q 130 82 207 -15 q 54 316 54 180 q 125 564 54 456 q 333 672 197 672 q 464 636 407 672 q 557 535 520 601 q 546 655 557 594 q 586 649 576 650 q 611 648 597 648 q 674 655 640 648 l 671 433 q 669 163 671 298 q 666 -106 668 27 l 675 -373 q 643 -369 658 -370 q 608 -368 627 -368 m 373 48 q 515 134 473 48 q 557 331 557 220 q 511 514 557 433 q 372 596 466 596 q 234 512 276 596 q 193 322 193 429 q 236 133 193 218 q 373 48 279 48 \"},\"\":{\"x_min\":8,\"x_max\":1119.125,\"ha\":1129,\"o\":\"m 449 0 q 318 4 410 0 q 223 8 227 8 l 10 0 l 13 47 q 11 74 13 59 q 8 95 9 88 q 119 88 69 90 q 249 86 169 86 q 103 261 152 170 q 55 473 55 352 q 200 822 55 694 q 567 950 345 950 q 931 823 791 950 q 1072 473 1072 697 q 1025 261 1072 350 q 878 86 978 173 q 992 91 902 86 q 1119 96 1083 96 l 1114 33 l 1117 0 l 906 8 q 778 4 867 8 q 682 0 688 0 l 682 72 q 864 215 807 122 q 921 451 921 309 q 834 764 921 639 q 565 889 747 889 q 296 767 384 889 q 209 454 209 645 q 268 217 209 319 q 449 72 327 115 l 449 0 \"},\"\":{\"x_min\":79,\"x_max\":703,\"ha\":774,\"o\":\"m 703 395 q 595 110 703 236 q 332 -15 488 -15 q 145 54 211 -15 q 79 244 79 123 l 83 429 q 81 541 83 484 q 79 652 80 597 l 146 648 l 217 652 q 209 502 217 606 q 202 365 202 397 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 132 476 43 q 571 340 571 222 q 548 491 571 416 q 488 644 526 566 q 550 646 529 644 q 627 656 571 648 q 703 395 703 536 m 499 941 q 532 972 517 962 q 568 983 547 983 q 606 967 592 983 q 620 930 620 952 q 605 894 620 910 q 564 865 590 878 l 365 741 l 316 741 l 499 941 \"},\"\":{\"x_min\":51,\"x_max\":1069,\"ha\":1121,\"o\":\"m 51 465 q 191 819 51 688 q 559 950 332 950 q 891 852 750 950 q 1046 659 1031 755 q 1065 535 1062 562 q 1069 462 1069 508 q 1066 395 1069 416 q 1047 275 1063 373 q 894 80 1031 176 q 562 -15 756 -15 q 451 -8 503 -15 q 304 31 399 -2 q 130 187 209 65 q 51 465 51 308 m 439 1208 q 491 1186 470 1208 q 513 1133 513 1164 q 491 1080 513 1103 q 439 1058 470 1058 q 385 1080 409 1058 q 362 1133 362 1102 q 384 1186 362 1164 q 439 1208 407 1208 m 682 1208 q 735 1186 713 1208 q 757 1133 757 1164 q 735 1080 757 1103 q 682 1058 713 1058 q 628 1079 650 1058 q 607 1133 607 1101 q 628 1186 607 1164 q 682 1208 650 1208 m 204 469 q 292 162 204 283 q 559 42 380 42 q 827 162 739 42 q 916 469 916 283 q 825 767 916 648 q 559 887 735 887 q 349 825 430 887 q 226 638 267 763 q 204 469 204 558 \"},\"z\":{\"x_min\":15.28125,\"x_max\":606.9375,\"ha\":647,\"o\":\"m 15 29 q 164 224 88 124 q 302 416 240 323 l 418 586 l 270 586 q 181 581 218 586 q 62 565 145 577 l 68 609 l 62 654 q 181 648 115 650 q 330 646 248 646 l 363 646 l 393 646 q 606 654 500 646 l 606 626 q 453 428 545 549 q 317 246 361 306 q 194 68 273 185 l 343 68 q 456 72 400 68 q 594 86 513 77 l 588 42 l 594 0 l 280 8 q 148 4 237 8 q 15 0 59 0 l 15 29 \"},\"\":{\"x_min\":176,\"x_max\":918,\"ha\":1139,\"o\":\"m 463 930 l 346 930 l 346 614 l 293 614 l 293 930 l 176 930 l 176 969 l 463 969 l 463 930 m 736 690 l 840 968 l 918 969 l 918 614 l 871 614 l 871 927 l 752 614 l 719 614 l 594 930 l 594 614 l 548 614 l 548 969 l 625 969 l 736 690 \"},\"\":{\"x_min\":91,\"x_max\":662,\"ha\":754,\"o\":\"m 594 -365 q 557 -366 577 -365 q 526 -369 537 -368 q 531 -189 526 -310 q 537 -7 537 -68 l 537 406 q 503 536 537 485 q 391 587 469 587 q 255 508 290 587 q 220 315 220 430 q 222 133 220 259 q 224 1 224 8 l 158 6 l 91 1 l 101 156 l 101 495 q 97 584 101 527 q 93 655 93 640 q 119 650 105 652 q 155 648 134 648 q 185 650 175 648 q 221 655 195 651 l 220 538 q 321 637 265 602 q 452 672 378 672 q 604 603 552 672 q 656 430 656 535 l 656 329 l 656 -186 q 659 -293 656 -227 q 662 -370 662 -359 q 630 -366 645 -368 q 594 -365 614 -365 m 481 944 q 515 975 499 965 q 552 986 531 986 q 589 970 575 986 q 603 933 603 955 q 589 898 603 912 q 547 868 575 884 l 348 744 l 298 744 l 481 944 \"},\"\":{\"x_min\":51,\"x_max\":1068,\"ha\":1119,\"o\":\"m 51 465 q 193 820 51 690 q 562 950 335 950 q 893 852 755 950 q 1047 653 1031 755 q 1065 525 1062 551 q 1068 462 1068 500 q 1065 402 1068 426 q 1047 280 1062 379 q 892 83 1033 182 q 560 -15 751 -15 q 435 -7 480 -15 q 299 32 390 0 q 130 187 209 65 q 51 465 51 308 m 202 468 q 290 163 202 283 q 559 43 379 43 q 826 163 738 43 q 915 468 915 283 q 826 770 915 652 q 559 889 738 889 q 254 720 306 889 q 202 468 202 552 m 560 507 q 683 510 608 507 q 768 514 758 514 l 765 465 l 765 429 q 648 432 730 429 q 558 435 566 435 q 440 432 523 435 q 351 429 357 429 l 353 470 l 353 514 q 474 510 400 514 q 560 507 549 507 \"},\"\":{\"x_min\":80,\"x_max\":1058,\"ha\":1139,\"o\":\"m 816 905 q 992 726 927 841 q 1058 481 1058 611 q 912 138 1058 283 q 567 -6 766 -6 q 225 139 370 -6 q 80 481 80 284 q 224 826 80 681 q 569 971 368 971 q 816 905 698 971 m 569 918 q 263 788 392 918 q 134 481 134 659 q 261 175 134 306 q 566 45 389 45 q 872 174 741 45 q 1004 478 1004 304 q 947 699 1004 596 q 787 859 890 801 q 569 918 684 918 m 815 619 q 776 521 815 562 q 681 468 738 480 l 809 209 l 709 208 l 592 456 l 462 457 l 462 209 l 376 209 l 376 771 l 581 771 q 745 737 676 771 q 815 619 815 704 m 462 714 l 462 513 l 566 513 q 682 532 635 513 q 729 611 729 551 q 681 692 729 671 q 564 714 634 714 l 462 714 \"},\"\":{\"x_min\":109,\"x_max\":614.5625,\"ha\":685,\"o\":\"m 124 465 q 116 710 124 540 q 109 932 109 880 l 353 929 l 610 929 q 607 904 607 918 q 607 884 607 891 l 610 838 q 407 860 506 860 l 259 860 l 257 670 l 257 530 l 397 530 q 586 542 492 530 q 584 518 584 530 q 584 499 584 506 q 586 450 584 465 q 487 458 542 454 q 393 463 432 463 l 257 463 l 257 318 l 262 74 q 452 77 381 74 q 614 94 524 80 l 613 47 l 614 0 l 356 0 l 109 0 q 116 243 109 72 q 124 465 124 415 m 426 1225 q 461 1255 445 1244 q 499 1267 478 1267 q 536 1251 522 1267 q 549 1212 549 1236 q 533 1176 549 1192 q 492 1147 517 1160 l 292 1024 l 242 1024 l 426 1225 \"},\"~\":{\"x_min\":284,\"x_max\":1080,\"ha\":1368,\"o\":\"m 850 650 q 667 750 761 650 q 511 850 573 850 q 396 793 431 850 q 362 650 362 737 l 284 650 q 339 846 284 768 q 508 924 395 924 q 697 824 606 924 q 853 725 788 725 q 969 779 936 725 q 1002 924 1002 834 l 1080 924 q 1023 727 1080 805 q 850 650 966 650 \"},\"\":{\"x_min\":108,\"x_max\":613.5625,\"ha\":686,\"o\":\"m 126 465 q 122 711 126 620 q 108 932 119 802 l 353 928 l 610 931 l 606 884 l 610 836 q 508 853 562 847 q 408 860 453 860 l 260 860 l 258 671 l 258 528 l 398 528 q 587 541 480 528 l 584 497 l 587 451 l 394 463 l 258 463 l 258 316 l 264 73 q 456 76 380 73 q 613 94 531 80 l 610 47 l 613 0 l 358 4 l 108 0 q 117 239 108 70 q 126 465 126 408 \"},\"\":{\"x_min\":48,\"x_max\":424,\"ha\":496,\"o\":\"m 159 636 l 156 663 q 178 661 167 661 q 200 661 189 661 q 280 690 248 661 q 312 767 312 719 q 212 869 312 869 q 143 846 168 869 q 107 781 117 823 l 102 779 q 84 812 93 795 q 66 845 75 830 q 134 886 98 871 q 212 901 171 901 q 341 873 284 901 q 398 778 398 845 q 355 691 398 724 q 252 643 313 658 q 373 610 322 643 q 424 509 424 577 q 353 385 424 427 q 196 343 283 343 q 48 373 117 343 q 57 422 52 391 q 66 469 63 454 l 75 469 q 120 399 88 425 q 199 374 153 374 q 294 409 254 374 q 334 499 334 444 q 299 588 334 553 q 207 623 264 623 q 179 620 193 623 q 156 617 166 618 l 159 636 \"},\"[\":{\"x_min\":116,\"x_max\":364.609375,\"ha\":449,\"o\":\"m 127 2 l 127 386 l 127 769 l 116 932 l 235 929 l 364 929 l 363 908 l 363 872 q 263 880 313 880 l 216 880 l 216 387 l 216 -105 l 264 -105 q 329 -102 308 -105 q 364 -98 351 -99 l 363 -123 l 363 -158 l 237 -154 l 116 -158 q 121 -81 116 -138 q 127 2 127 -24 \"},\"L\":{\"x_min\":108,\"x_max\":627.453125,\"ha\":629,\"o\":\"m 126 465 q 122 712 126 621 q 108 932 119 803 q 149 930 126 932 q 188 926 173 927 q 233 929 202 926 q 268 932 265 932 q 263 797 268 883 q 258 684 258 711 q 261 332 258 577 q 264 73 264 86 l 402 73 q 512 78 458 73 q 627 94 566 84 l 624 47 l 627 0 l 358 4 l 108 0 q 117 239 108 70 q 126 465 126 408 \"},\"\":{\"x_min\":41,\"x_max\":802.109375,\"ha\":806,\"o\":\"m 625 644 l 802 651 l 797 611 l 802 566 l 626 573 q 690 464 671 527 q 710 327 710 402 q 616 81 710 177 q 371 -15 522 -15 q 131 78 222 -15 q 41 322 41 172 q 131 572 41 472 q 371 672 221 672 q 439 665 403 672 q 508 653 475 659 q 569 645 541 646 q 625 644 597 644 m 376 619 q 226 530 272 619 q 181 326 181 442 q 224 124 181 213 q 369 35 268 35 q 522 123 474 35 q 570 326 570 211 q 524 529 570 440 q 376 619 479 619 \"},\"\":{\"x_min\":75,\"x_max\":675,\"ha\":683,\"o\":\"m 642 987 l 642 949 q 425 760 524 860 q 260 545 326 661 q 194 303 194 428 q 194 278 194 289 q 202 215 194 267 q 335 141 210 163 q 558 116 447 128 q 675 -7 675 91 q 643 -109 675 -65 q 544 -232 612 -154 l 500 -205 q 565 -113 555 -131 q 576 -66 576 -94 q 552 -20 576 -37 q 292 22 509 2 q 75 240 75 41 q 143 487 75 357 q 297 719 212 616 q 508 949 383 821 l 359 949 q 252 945 301 949 q 130 933 204 941 l 134 977 l 130 1025 q 272 1021 186 1025 q 372 1018 358 1018 q 526 1021 429 1018 q 643 1025 623 1025 l 642 987 \"},\"\":{\"x_min\":48,\"x_max\":699,\"ha\":749,\"o\":\"m 375 909 q 621 773 544 909 q 699 456 699 638 q 627 118 699 255 q 372 -19 556 -19 q 120 114 193 -19 q 48 444 48 247 q 122 773 48 638 q 375 909 196 909 m 184 383 q 221 136 184 242 q 374 31 259 31 q 534 137 505 31 q 564 424 564 244 l 408 428 l 184 423 l 184 383 m 371 858 q 257 804 300 858 q 196 673 214 751 q 186 581 189 630 q 184 483 184 532 l 322 478 q 461 480 364 478 q 564 483 558 483 q 528 747 564 637 q 371 858 493 858 \"},\"\":{\"x_min\":51,\"x_max\":1068,\"ha\":1119,\"o\":\"m 51 465 q 192 820 51 690 q 559 950 333 950 q 892 853 754 950 q 1047 654 1031 757 q 1065 525 1062 551 q 1068 462 1068 500 q 1065 402 1068 426 q 1047 277 1062 379 q 894 80 1031 175 q 560 -15 756 -15 q 447 -10 496 -15 q 304 29 398 -5 q 130 186 210 64 q 51 465 51 308 m 202 468 q 290 162 202 282 q 559 42 379 42 q 826 162 738 42 q 915 468 915 283 q 825 770 915 651 q 559 889 735 889 q 348 826 429 889 q 225 639 267 764 q 202 468 202 552 \"},\"\":{\"x_min\":108,\"x_max\":627.453125,\"ha\":629,\"o\":\"m 448 932 l 627 932 q 623 902 624 921 q 621 874 621 883 l 627 836 q 402 863 512 863 l 264 863 q 261 586 264 779 q 258 379 258 393 q 263 181 258 313 q 268 0 268 48 l 187 5 l 108 0 q 121 209 117 106 q 126 427 126 311 q 117 686 126 504 q 108 932 108 869 l 448 932 \"},\" \":{\"x_min\":0,\"x_max\":0,\"ha\":375},\"%\":{\"x_min\":28,\"x_max\":1011,\"ha\":1032,\"o\":\"m 799 0 q 647 62 708 0 q 586 218 586 124 q 647 372 586 309 q 799 436 709 436 q 949 373 888 436 q 1011 223 1011 311 q 995 130 1011 176 q 918 35 972 70 q 799 0 865 0 m 863 1015 l 227 -125 l 158 -125 l 793 1015 l 863 1015 m 241 451 q 89 513 150 451 q 28 668 28 576 q 89 823 28 759 q 241 888 150 888 q 391 825 330 888 q 453 673 453 762 q 434 581 453 623 q 359 486 412 521 q 241 451 307 451 m 897 260 q 872 353 897 310 q 798 397 847 397 q 718 340 737 397 q 700 202 700 283 q 719 86 700 133 q 798 40 738 40 q 866 73 840 40 q 892 149 892 106 q 895 206 894 169 q 897 260 897 242 m 339 689 q 312 812 339 775 q 240 849 285 849 q 160 788 179 849 q 141 648 141 728 q 164 541 141 590 q 240 493 188 493 q 307 527 281 493 q 334 602 334 561 q 339 689 339 641 \"},\"P\":{\"x_min\":109,\"x_max\":722,\"ha\":736,\"o\":\"m 127 559 q 109 931 127 759 l 231 927 q 337 931 270 927 q 416 935 403 935 q 632 874 543 935 q 722 694 722 814 q 616 493 722 564 q 371 422 510 422 l 252 422 q 257 200 252 348 q 262 0 262 52 q 224 3 249 0 q 185 8 199 8 q 147 5 168 8 q 109 0 127 2 q 118 287 109 85 q 127 559 127 488 m 576 684 q 515 826 576 773 q 364 879 455 879 l 262 875 q 254 781 257 827 q 252 688 252 735 l 252 476 q 507 530 439 476 q 576 684 576 584 \"},\"\":{\"x_min\":-1,\"x_max\":1355.953125,\"ha\":1365,\"o\":\"m 685 0 q 555 4 646 0 q 460 8 464 8 l 247 0 l 250 47 q 248 74 250 59 q 244 95 246 88 q 355 88 305 90 q 486 86 405 86 q 340 261 389 170 q 292 473 292 352 q 437 822 292 694 q 804 950 582 950 q 1168 823 1028 950 q 1309 473 1309 697 q 1262 261 1309 350 q 1115 86 1215 173 q 1229 91 1139 86 q 1355 96 1319 96 l 1351 33 l 1354 0 l 1143 8 q 1014 4 1104 8 q 918 0 924 0 l 918 72 q 1100 215 1043 122 q 1158 451 1158 309 q 1071 764 1158 639 q 802 889 984 889 q 533 767 621 889 q 446 454 446 645 q 505 217 446 319 q 685 72 564 115 l 685 0 m 182 943 q 215 974 200 964 q 251 985 230 985 q 289 969 274 985 q 304 932 304 954 q 290 896 304 911 q 247 866 275 882 l 48 743 l -1 743 l 182 943 \"},\"\":{\"x_min\":-1.390625,\"x_max\":920.015625,\"ha\":992,\"o\":\"m 432 465 q 428 711 432 620 q 414 932 425 802 l 660 928 l 917 932 l 912 884 l 917 836 q 814 853 868 847 q 714 860 760 860 l 567 860 l 564 671 l 564 528 l 704 528 q 893 541 786 528 l 890 497 l 893 451 l 700 462 l 564 462 l 564 317 l 570 74 q 762 77 686 74 q 920 94 838 80 l 917 47 l 920 0 l 664 4 l 414 0 q 423 239 414 70 q 432 465 432 408 m 181 943 q 215 974 200 964 q 251 985 230 985 q 288 969 273 985 q 304 932 304 954 q 289 896 304 911 q 247 866 275 882 l 47 743 l -1 743 l 181 943 \"},\"_\":{\"x_min\":0,\"x_max\":683.328125,\"ha\":683,\"o\":\"m 683 -322 l 0 -322 l 0 -256 l 683 -256 l 683 -322 \"},\"\":{\"x_min\":-3,\"x_max\":388,\"ha\":386,\"o\":\"m 126 465 q 118 710 126 540 q 111 932 111 880 q 156 929 123 932 q 192 926 190 926 q 238 929 205 926 q 276 932 271 932 q 265 697 276 863 q 255 465 255 530 q 265 230 255 397 q 276 0 276 63 q 233 3 260 0 q 192 8 205 8 q 153 5 176 8 q 111 0 131 2 q 118 243 111 72 q 126 465 126 415 m 73 1208 q 124 1186 102 1208 q 146 1133 146 1164 q 123 1081 146 1105 q 73 1058 101 1058 q 19 1080 42 1058 q -3 1133 -3 1103 q 19 1185 -3 1163 q 73 1208 41 1208 m 313 1208 q 366 1186 344 1208 q 388 1133 388 1164 q 365 1080 388 1103 q 313 1058 342 1058 q 260 1080 283 1058 q 238 1133 238 1103 q 260 1185 238 1163 q 313 1208 282 1208 \"},\"+\":{\"x_min\":169,\"x_max\":970,\"ha\":1139,\"o\":\"m 603 441 l 970 441 l 970 374 l 603 374 l 603 0 l 536 0 l 536 374 l 169 374 l 169 441 l 536 441 l 536 816 l 603 816 l 603 441 \"},\"\":{\"x_min\":83,\"x_max\":1094.125,\"ha\":1172,\"o\":\"m 250 743 l 245 836 q 181 804 205 818 q 120 768 156 791 q 104 788 117 775 q 83 808 91 801 q 200 851 141 825 q 327 913 259 877 l 336 911 q 331 724 336 850 q 326 551 326 598 l 326 391 q 301 394 319 391 q 280 397 283 397 q 254 394 271 397 q 233 391 238 391 q 246 551 242 473 q 250 743 250 629 m 859 1015 l 929 1015 l 312 -124 l 243 -124 l 859 1015 m 982 363 q 959 443 982 413 q 887 478 936 473 q 821 458 852 478 q 784 407 790 439 l 778 377 l 773 376 q 728 448 753 416 q 899 513 801 513 q 1019 476 967 513 q 1072 374 1072 439 q 955 189 1072 285 q 806 67 838 93 l 978 67 q 1094 79 1039 67 q 1090 63 1092 76 q 1088 41 1088 49 q 1094 3 1088 18 q 981 3 1056 3 q 867 3 906 3 q 791 3 842 3 q 714 3 739 3 l 714 25 q 913 198 844 125 q 982 363 982 270 \"},\"\":{\"x_min\":109,\"x_max\":722,\"ha\":736,\"o\":\"m 127 559 q 109 931 127 759 l 231 927 q 337 931 270 927 q 416 935 403 935 q 632 874 543 935 q 722 694 722 814 q 616 493 722 564 q 371 422 510 422 l 252 422 q 257 200 252 348 q 262 0 262 52 q 224 3 249 0 q 185 8 199 8 q 147 5 168 8 q 109 0 127 2 q 118 287 109 85 q 127 559 127 488 m 576 684 q 515 826 576 773 q 364 879 455 879 l 262 875 q 254 781 257 827 q 252 688 252 735 l 252 476 q 507 530 439 476 q 576 684 576 584 \"},\"'\":{\"x_min\":88.890625,\"x_max\":306.9375,\"ha\":374,\"o\":\"m 169 858 q 196 923 177 896 q 250 951 215 951 q 289 937 272 951 q 306 903 306 923 q 295 858 306 883 q 269 812 284 833 l 122 568 l 88 576 l 169 858 \"},\"T\":{\"x_min\":11,\"x_max\":713,\"ha\":725,\"o\":\"m 11 839 l 15 884 l 11 932 q 194 927 72 932 q 361 922 316 922 q 544 927 421 922 q 713 932 668 932 q 707 883 707 911 q 707 861 707 870 q 713 834 707 852 q 609 850 666 843 q 504 857 552 857 l 428 857 q 426 767 428 830 q 424 701 424 704 l 428 220 q 442 0 428 122 q 362 8 401 3 q 323 5 344 8 q 282 0 301 2 q 289 132 282 40 q 296 259 296 225 l 296 683 l 296 857 q 11 839 164 857 \"},\"\":{\"x_min\":50,\"x_max\":1068,\"ha\":1119,\"o\":\"m 637 -25 q 559 -15 591 -15 q 527 -17 544 -15 q 483 -25 509 -19 l 487 68 q 181 179 313 68 q 50 465 50 291 q 172 744 50 647 q 487 865 295 842 l 483 958 q 522 952 502 955 q 559 950 543 950 q 596 952 576 950 q 637 958 616 955 l 631 865 q 942 758 816 865 q 1068 465 1068 651 q 944 184 1068 286 q 631 68 820 83 l 637 -25 m 501 502 q 497 677 501 570 q 494 800 494 784 q 278 698 354 786 q 203 466 203 611 q 282 231 203 331 q 494 132 361 132 q 497 363 494 225 q 501 502 501 501 m 915 466 q 839 706 915 612 q 626 800 764 800 q 622 636 626 738 q 618 470 618 533 q 622 301 618 408 q 626 132 626 194 q 839 226 764 132 q 915 466 915 320 \"},\"j\":{\"x_min\":-55,\"x_max\":248,\"ha\":342,\"o\":\"m 113 391 q 106 543 113 444 q 100 654 100 641 q 144 648 135 648 q 167 648 153 648 q 202 649 189 648 q 241 654 214 650 q 237 507 241 595 q 234 405 234 419 l 234 -13 l 234 -109 q 154 -303 234 -234 q -55 -372 74 -372 l -55 -333 q 78 -267 44 -323 q 113 -103 113 -212 l 113 -26 l 113 391 m 171 963 q 226 940 205 963 q 248 881 248 917 q 226 831 248 849 q 171 813 204 813 q 116 833 139 813 q 94 885 94 853 q 115 941 94 919 q 171 963 136 963 \"},\"\":{\"x_min\":44.4375,\"x_max\":790.28125,\"ha\":825,\"o\":\"m 729 883 l 733 835 q 272 855 519 855 q 544 500 391 691 q 372 312 446 399 q 219 119 297 224 l 455 119 q 638 124 522 119 q 790 129 755 129 l 784 86 l 783 68 l 784 42 q 785 25 784 33 q 790 0 786 17 q 558 4 694 0 q 416 8 422 8 q 230 4 350 8 q 44 0 111 0 l 44 50 q 169 182 105 109 q 307 344 232 255 l 406 468 q 242 689 314 594 q 76 899 170 785 l 76 932 q 231 929 123 932 q 345 926 340 926 q 568 929 412 926 q 733 932 723 932 l 729 883 \"},\"1\":{\"x_min\":72,\"x_max\":472,\"ha\":749,\"o\":\"m 334 626 q 331 722 334 655 q 329 793 329 788 q 228 737 278 765 q 133 673 177 709 q 102 713 124 688 q 72 743 80 737 q 274 827 177 780 q 458 935 372 875 l 472 929 q 463 552 472 804 q 455 259 455 300 l 459 0 q 421 5 441 2 q 384 8 401 8 q 349 5 367 8 q 312 0 330 2 q 329 289 324 133 q 334 626 334 445 \"},\"\":{\"x_min\":43,\"x_max\":655.5,\"ha\":649,\"o\":\"m 234 -15 q 98 33 153 -15 q 43 162 43 82 q 106 303 43 273 q 303 364 169 333 q 444 448 437 395 q 403 568 444 521 q 288 616 362 616 q 191 587 233 616 q 124 507 149 559 l 95 520 l 104 591 q 202 651 144 631 q 323 672 261 672 q 500 622 444 672 q 557 455 557 573 l 557 133 q 567 69 557 84 q 618 54 577 54 q 655 58 643 54 l 655 26 q 594 5 626 14 q 537 -6 562 -3 q 438 85 453 -6 q 342 10 388 35 q 234 -15 296 -15 m 203 929 q 254 906 232 929 q 277 854 277 884 q 256 799 277 820 q 204 778 236 778 q 149 800 173 778 q 126 854 126 822 q 148 906 126 884 q 203 929 170 929 m 444 929 q 498 906 476 929 q 521 854 521 884 q 500 800 521 822 q 447 778 479 778 q 392 800 415 778 q 370 854 370 823 q 392 906 370 884 q 444 929 414 929 m 176 186 q 204 98 176 133 q 284 64 232 64 q 390 107 342 64 q 438 212 438 151 l 438 345 q 239 293 303 319 q 176 186 176 268 \"},\"<\":{\"x_min\":176,\"x_max\":961.109375,\"ha\":1139,\"o\":\"m 279 406 l 960 130 l 961 56 l 176 379 l 176 432 l 960 756 l 960 682 l 279 406 \"},\"\":{\"x_min\":65,\"x_max\":728.890625,\"ha\":749,\"o\":\"m 67 47 l 65 98 l 116 101 q 203 168 176 112 q 231 292 231 224 q 227 375 231 330 q 221 444 223 420 q 139 441 171 444 q 76 432 107 439 l 78 479 l 76 503 q 105 495 92 498 q 134 493 117 493 l 219 493 q 212 550 214 522 q 209 609 209 578 q 304 825 209 742 q 537 909 399 909 q 633 896 592 909 q 723 864 673 884 q 666 731 694 809 l 656 731 q 605 825 641 791 q 512 859 570 859 q 383 796 427 859 q 340 646 340 734 l 345 493 l 366 493 q 523 502 450 493 l 521 466 l 526 434 q 438 441 493 439 q 345 444 383 444 l 345 378 q 310 238 345 302 q 213 107 275 173 q 527 113 421 107 q 728 134 633 119 l 721 66 q 728 0 721 34 q 542 3 666 0 q 358 8 419 8 q 176 3 285 8 q 65 0 67 0 l 67 47 \"},\"\":{\"x_min\":82,\"x_max\":347,\"ha\":496,\"o\":\"m 255 731 l 255 833 l 123 759 q 104 780 120 763 q 82 801 87 797 q 208 850 148 822 q 337 917 269 878 l 347 912 q 341 721 347 848 q 336 529 336 593 l 336 356 q 311 358 327 356 q 289 361 295 361 q 264 358 280 361 q 242 356 248 356 q 251 498 247 407 q 255 731 255 590 \"},\"t\":{\"x_min\":18,\"x_max\":415.21875,\"ha\":425,\"o\":\"m 18 586 l 22 630 l 18 654 q 133 643 80 643 q 131 732 133 669 q 129 799 129 796 q 199 827 163 811 q 263 863 234 843 q 252 758 255 811 q 250 643 250 705 q 334 645 310 643 q 401 654 358 647 l 398 618 l 401 586 q 248 594 323 594 l 243 258 l 243 162 q 272 76 243 109 q 353 43 301 43 q 387 44 369 43 q 415 48 405 46 l 415 4 q 349 -10 378 -5 q 290 -15 319 -15 q 174 18 221 -15 q 123 118 128 51 l 123 200 l 129 387 l 133 594 q 84 592 113 594 q 18 586 55 590 \"},\"\":{\"x_min\":2.78125,\"x_max\":652.78125,\"ha\":657,\"o\":\"m 302 670 q 227 871 262 803 q 111 940 193 940 q 78 937 94 940 q 20 924 62 934 l 20 978 q 96 1012 59 1000 q 170 1025 133 1025 q 329 947 287 1025 q 427 692 372 869 q 538 340 481 515 q 652 1 594 166 l 579 5 l 504 0 q 336 573 423 305 q 218 301 272 438 q 111 0 163 163 l 61 6 q 27 3 48 6 q 2 0 5 0 q 302 670 165 329 \"},\"\":{\"x_min\":90,\"x_max\":664,\"ha\":754,\"o\":\"m 653 498 q 653 329 653 443 q 653 158 653 215 q 664 0 653 81 q 631 3 647 1 q 598 5 616 5 q 563 3 583 5 q 533 0 544 1 l 538 118 q 440 18 494 52 q 312 -15 385 -15 q 148 50 201 -15 q 96 229 96 115 l 96 354 l 96 516 l 90 655 q 120 650 103 651 q 158 648 136 648 q 192 650 175 648 q 227 655 210 651 q 220 445 227 591 q 213 247 213 299 q 247 115 213 163 q 362 68 281 68 q 477 113 428 68 q 531 217 525 159 q 538 340 538 274 q 533 520 538 394 q 528 655 528 647 q 561 650 548 651 q 596 648 574 648 q 663 655 628 648 q 653 498 653 573 m 445 743 l 244 866 q 205 896 223 877 q 187 934 187 915 q 202 970 187 955 q 238 986 217 986 q 277 973 256 986 q 309 945 298 961 l 496 743 l 445 743 \"},\"W\":{\"x_min\":0,\"x_max\":1306.953125,\"ha\":1307,\"o\":\"m 0 932 q 47 927 31 929 q 76 926 62 926 q 121 929 88 926 q 155 931 154 931 q 262 547 200 750 l 380 171 q 470 437 415 272 q 552 693 525 602 q 619 931 580 784 l 672 926 q 700 928 684 926 q 726 931 716 930 q 825 604 787 727 q 883 419 862 482 q 969 171 904 357 l 1087 522 q 1143 720 1120 623 q 1187 931 1166 816 q 1221 929 1197 931 q 1247 926 1245 926 q 1280 928 1262 926 q 1306 931 1298 930 q 1131 467 1218 716 q 990 0 1045 217 q 963 4 980 1 q 937 7 947 7 q 904 3 925 7 q 880 0 883 0 q 761 385 831 184 l 641 733 l 491 287 q 402 0 438 133 q 370 3 391 0 q 344 7 350 7 q 315 4 327 7 q 287 0 302 2 q 206 296 252 142 q 122 568 161 450 q 0 932 83 686 \"},\"\":{\"x_min\":-25,\"x_max\":365.328125,\"ha\":340,\"o\":\"m 104 144 l 104 522 l 97 655 q 138 650 113 651 q 167 648 162 648 q 233 655 206 648 q 225 506 225 581 q 229 254 225 423 q 233 0 233 84 q 201 3 216 1 q 164 5 186 5 q 128 3 143 5 q 97 0 113 1 l 104 144 m 50 929 q 102 906 80 929 q 125 854 125 884 q 104 799 125 820 q 52 778 84 778 q -2 800 19 778 q -25 854 -25 822 q -4 906 -25 884 q 50 929 16 929 m 290 929 q 343 906 320 929 q 365 854 365 884 q 345 799 365 820 q 294 778 324 778 q 238 800 260 778 q 216 854 216 822 q 237 906 216 884 q 290 929 258 929 \"},\">\":{\"x_min\":176.390625,\"x_max\":963,\"ha\":1139,\"o\":\"m 963 379 l 176 56 l 176 130 l 858 406 l 176 682 l 176 756 l 962 432 l 963 379 \"},\"v\":{\"x_min\":0,\"x_max\":658.328125,\"ha\":654,\"o\":\"m 0 655 q 54 648 38 648 q 86 647 69 647 q 113 647 100 647 q 168 654 127 648 q 252 402 204 529 l 358 134 l 470 436 q 543 654 508 533 q 570 650 554 651 q 600 648 586 648 q 636 648 618 648 q 658 654 652 652 q 506 340 577 502 q 372 0 436 177 q 347 5 362 2 q 319 8 333 8 q 296 5 309 8 q 272 0 283 2 q 200 206 234 120 q 0 655 165 292 \"},\"\":{\"x_min\":30,\"x_max\":677,\"ha\":701,\"o\":\"m 423 573 l 419 303 q 423 146 419 250 q 428 0 428 42 q 394 4 410 2 q 359 5 378 5 q 333 4 343 5 q 289 0 323 4 l 298 194 l 294 573 q 156 553 207 573 q 57 472 105 534 q 30 559 49 522 q 149 626 82 609 q 307 644 216 644 l 510 644 q 604 647 545 644 q 677 651 664 651 l 671 610 q 677 566 671 586 q 527 569 618 566 q 423 573 436 573 \"},\"\":{\"x_min\":90,\"x_max\":664,\"ha\":754,\"o\":\"m 653 498 q 653 328 653 442 q 653 158 653 215 q 664 0 653 81 q 631 3 647 1 q 598 5 616 5 q 563 3 583 5 q 533 0 544 1 l 538 118 q 440 18 494 52 q 312 -15 385 -15 q 148 50 201 -15 q 96 229 96 115 l 96 354 l 96 516 l 90 655 q 120 650 103 651 q 158 648 136 648 q 192 649 175 648 q 227 655 210 651 q 220 445 227 591 q 213 247 213 299 q 247 115 213 163 q 362 68 281 68 q 477 113 428 68 q 531 217 525 159 q 538 340 538 274 q 533 520 538 394 q 528 655 528 647 q 558 650 542 651 q 596 648 574 648 q 629 649 612 648 q 663 655 646 651 q 653 498 653 573 m 332 978 l 421 978 l 572 743 l 525 743 l 376 875 l 227 743 l 180 743 l 332 978 \"},\"\":{\"x_min\":64,\"x_max\":654,\"ha\":656,\"o\":\"m 562 861 q 502 941 539 911 q 414 972 465 972 q 299 917 342 972 q 256 788 256 862 q 312 650 256 701 q 458 599 369 599 l 526 599 l 524 563 l 524 528 q 480 533 503 532 q 427 535 457 535 q 271 494 337 535 q 197 408 205 454 q 187 347 188 361 q 186 326 186 333 q 186 294 186 300 q 190 282 187 287 q 238 200 201 229 q 335 153 276 171 l 494 118 q 610 73 567 100 q 654 -13 654 46 q 628 -103 654 -60 q 511 -238 602 -146 l 466 -210 q 541 -121 530 -139 q 553 -75 553 -103 q 393 16 553 -18 q 149 92 234 50 q 64 276 64 133 q 130 462 64 379 q 299 575 197 544 q 175 652 222 600 q 128 780 128 704 q 213 954 128 883 q 405 1025 298 1025 q 507 1009 458 1025 q 609 965 555 994 q 585 914 600 945 q 562 861 571 883 \"},\"&\":{\"x_min\":76,\"x_max\":917.671875,\"ha\":975,\"o\":\"m 360 -18 q 160 41 245 -18 q 76 211 76 101 q 137 382 76 315 q 314 515 199 448 q 249 618 273 569 q 225 722 225 668 q 287 872 225 812 q 441 932 349 932 q 581 891 520 932 q 643 777 643 851 q 588 640 643 701 q 453 532 533 579 q 568 390 509 459 q 690 253 627 321 q 815 530 792 379 l 829 530 l 887 466 q 814 327 856 396 q 727 209 772 259 q 807 115 760 169 q 917 0 853 61 q 855 1 896 0 q 791 2 813 2 l 739 0 l 649 110 q 515 15 586 48 q 360 -18 445 -18 m 341 475 q 234 380 267 419 q 201 273 201 340 q 258 125 201 190 q 401 61 316 61 q 508 86 458 61 q 606 154 559 111 l 341 475 m 547 770 q 524 854 547 823 q 454 886 502 886 q 363 851 402 886 q 325 769 325 817 q 344 685 325 718 q 422 575 363 652 q 514 661 481 615 q 547 770 547 708 \"},\"\":{\"x_min\":0,\"x_max\":852.78125,\"ha\":853,\"o\":\"m 662 452 l 778 172 l 852 0 l 769 5 q 734 4 747 5 q 679 0 722 4 q 647 102 661 55 q 605 226 633 148 l 547 383 l 401 777 l 266 429 q 191 213 226 319 q 125 0 157 108 l 62 2 l 0 0 q 205 459 95 191 q 380 932 315 726 q 404 927 393 929 q 431 926 416 926 q 459 929 441 926 q 487 932 477 932 q 548 743 511 850 q 662 452 586 637 \"},\"I\":{\"x_min\":109,\"x_max\":271,\"ha\":385,\"o\":\"m 127 465 q 123 711 127 620 q 109 932 120 803 q 154 927 129 929 q 190 925 179 925 q 238 928 209 925 q 271 931 266 931 q 263 788 271 887 q 256 659 256 690 l 256 448 l 256 283 q 263 135 256 238 q 271 0 271 31 q 231 3 258 0 q 190 8 204 8 q 151 5 172 8 q 109 0 129 2 q 118 239 109 70 q 127 465 127 408 \"},\"G\":{\"x_min\":51,\"x_max\":942,\"ha\":1001,\"o\":\"m 581 -15 q 198 107 345 -15 q 51 459 51 229 q 196 815 51 680 q 566 950 342 950 q 755 929 659 950 q 930 869 852 909 q 906 802 916 836 q 895 737 897 769 l 874 737 q 739 855 808 818 q 571 893 670 893 q 305 770 406 893 q 204 479 204 647 q 298 168 204 291 q 577 46 393 46 q 689 56 640 46 q 790 94 738 66 q 794 184 790 123 q 798 251 798 246 q 794 337 798 280 q 790 423 790 394 q 830 417 821 418 q 863 416 838 416 q 901 419 880 416 q 941 425 923 422 l 936 236 q 939 121 936 201 q 942 37 942 41 q 757 -1 843 11 q 581 -15 672 -15 \"},\"\":{\"x_min\":79,\"x_max\":703,\"ha\":774,\"o\":\"m 703 395 q 595 110 703 236 q 332 -15 488 -15 q 145 54 211 -15 q 79 244 79 123 l 83 430 q 81 542 83 486 q 79 654 80 598 l 146 650 l 217 654 q 209 502 217 608 q 202 365 202 397 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 132 476 43 q 571 340 571 222 q 548 493 571 418 q 488 645 526 568 q 550 647 529 645 q 627 658 571 650 q 703 395 703 537 m 209 865 q 250 846 232 865 q 269 804 269 828 q 251 761 269 780 q 209 743 234 743 q 166 761 184 743 q 148 804 148 779 q 166 846 148 828 q 209 865 184 865 m 361 929 q 378 969 368 956 q 414 982 388 982 q 458 941 458 982 q 446 904 458 919 l 338 743 l 306 743 l 361 929 m 513 865 q 555 846 537 865 q 573 804 573 828 q 555 761 573 779 q 513 743 537 743 q 470 761 487 743 q 454 804 454 779 q 470 846 454 828 q 513 865 487 865 \"},\"`\":{\"x_min\":86.5,\"x_max\":303.171875,\"ha\":374,\"o\":\"m 222 659 q 194 595 214 622 q 140 568 175 568 q 86 613 86 568 q 96 660 86 636 q 122 706 107 684 l 271 950 l 303 940 l 222 659 \"},\"\":{\"x_min\":-28,\"x_max\":746,\"ha\":707,\"o\":\"m 297 177 l 297 386 q 191 570 256 458 q 84 750 125 682 q -28 932 42 819 q 24 928 -9 932 q 63 925 59 925 q 112 927 91 925 q 146 932 134 930 q 207 800 174 866 q 275 676 239 735 l 389 475 q 509 688 451 575 q 627 932 567 801 l 683 926 q 715 927 701 926 q 746 932 729 929 q 555 627 640 769 l 432 415 l 432 240 q 435 101 432 198 q 438 0 438 5 q 401 4 426 1 q 361 6 376 6 q 319 4 334 6 q 284 0 304 2 q 292 88 288 36 q 297 177 297 140 \"},\"r\":{\"x_min\":89,\"x_max\":465.390625,\"ha\":488,\"o\":\"m 99 120 l 99 400 l 99 433 q 91 654 99 548 q 125 648 114 650 q 162 647 136 647 q 232 654 195 647 q 223 588 226 626 q 220 516 220 550 q 313 628 264 589 q 437 668 362 668 l 465 668 l 459 604 l 465 537 q 427 544 448 541 q 383 551 407 548 q 256 482 292 551 q 220 312 220 413 q 222 131 220 256 q 225 0 225 6 l 157 6 l 89 0 l 99 120 \"},\"x\":{\"x_min\":1,\"x_max\":635,\"ha\":632,\"o\":\"m 264 316 l 158 461 q 78 563 120 508 q 5 655 36 619 q 97 647 51 647 q 141 649 120 647 q 177 654 162 651 q 249 538 214 592 q 334 415 284 484 q 420 533 377 473 q 501 654 464 592 q 523 650 508 652 q 550 647 539 648 q 616 654 582 647 l 371 365 q 477 210 434 267 q 635 0 519 152 q 587 3 616 0 q 551 6 558 6 q 501 4 523 6 q 465 0 479 1 q 380 140 407 98 q 295 264 352 183 q 172 84 194 117 q 123 0 151 51 l 66 5 q 33 2 55 5 q 1 0 10 0 q 131 154 63 72 q 264 316 199 236 \"},\"\":{\"x_min\":40,\"x_max\":646.9375,\"ha\":681,\"o\":\"m 407 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 313 335 315 335 l 179 331 q 235 127 179 212 q 407 42 291 42 m 407 743 l 208 866 q 166 895 183 880 q 149 934 149 911 q 167 967 149 949 q 202 986 185 986 q 243 969 220 986 q 273 945 266 952 l 457 743 l 407 743 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 \"},\"\":{\"x_min\":84,\"x_max\":669.109375,\"ha\":754,\"o\":\"m 331 -15 q 265 -7 292 -15 q 210 19 238 0 l 208 -128 q 211 -266 208 -178 q 214 -373 214 -354 q 183 -369 198 -370 q 150 -368 168 -368 q 114 -370 133 -368 q 84 -373 95 -372 q 89 -165 84 -304 q 94 43 94 -26 q 89 363 94 149 q 84 655 84 578 q 150 647 118 647 q 219 654 180 647 q 213 495 219 601 q 208 334 208 390 q 232 155 208 227 q 339 75 256 83 q 471 112 419 75 q 531 212 523 150 q 539 332 539 273 q 536 518 539 388 q 533 655 533 648 q 600 647 568 647 q 669 654 629 647 q 660 477 662 566 q 658 257 658 389 q 660 113 658 171 q 669 -1 662 55 l 602 4 l 537 -1 l 539 106 q 449 17 502 50 q 331 -15 397 -15 \"},\"\":{\"x_min\":169,\"x_max\":969,\"ha\":1139,\"o\":\"m 641 643 q 618 593 641 615 q 566 571 596 571 q 518 592 538 571 q 498 643 498 613 q 518 692 498 670 q 567 715 539 715 q 610 703 579 715 q 641 643 641 691 m 969 374 l 169 374 l 169 441 l 969 441 l 969 374 m 641 170 q 619 120 641 141 q 570 100 598 100 q 519 120 540 100 q 498 170 498 141 q 518 221 498 199 q 568 243 538 243 q 604 235 584 243 q 632 214 624 227 q 641 170 641 201 \"},\"h\":{\"x_min\":92,\"x_max\":665,\"ha\":758,\"o\":\"m 102 136 l 102 859 q 100 934 102 894 q 94 1025 98 975 q 136 1018 126 1019 q 158 1018 146 1018 q 226 1025 188 1018 q 222 957 223 1001 q 221 888 221 913 l 221 868 l 221 543 q 322 637 264 602 q 450 672 380 672 q 608 606 558 672 q 659 429 659 541 l 659 298 l 659 136 l 665 0 q 633 3 648 1 q 597 5 617 5 q 560 3 580 5 q 529 0 540 1 q 534 202 529 68 q 540 405 540 337 q 503 533 540 481 q 394 586 467 586 q 256 508 291 586 q 221 313 221 430 q 224 133 221 244 q 227 0 227 22 q 188 3 211 0 q 161 6 164 6 q 123 4 137 6 q 92 0 108 2 l 102 136 \"},\".\":{\"x_min\":100,\"x_max\":274,\"ha\":374,\"o\":\"m 187 156 q 248 130 223 156 q 274 68 274 105 q 248 8 274 32 q 187 -15 223 -15 q 125 8 150 -15 q 100 68 100 32 q 125 130 100 105 q 187 156 150 156 \"},\"\":{\"x_min\":39,\"x_max\":965,\"ha\":1006,\"o\":\"m 578 -371 q 505 -362 539 -362 q 465 -365 483 -362 q 427 -372 446 -368 q 433 -163 427 -298 q 440 -11 440 -29 q 156 76 274 -11 q 39 327 39 163 q 145 571 39 486 q 410 656 252 656 q 412 635 411 645 q 413 615 413 625 q 235 516 292 580 q 179 327 179 451 q 247 118 179 197 q 442 39 316 39 l 444 197 l 444 311 q 444 400 444 340 q 444 491 444 461 q 514 619 452 570 q 657 668 577 668 q 879 568 794 668 q 965 332 965 469 q 850 84 965 169 q 563 -14 735 0 q 570 -203 563 -71 q 578 -371 578 -334 m 826 347 q 794 534 826 451 q 677 617 763 617 q 592 572 621 617 q 563 470 563 527 l 559 350 l 563 39 q 759 126 693 39 q 826 347 826 213 \"},\";\":{\"x_min\":72.609375,\"x_max\":312,\"ha\":446,\"o\":\"m 224 636 q 287 611 262 636 q 312 548 312 586 q 287 486 312 511 q 224 461 262 461 q 162 486 188 461 q 137 548 137 512 q 162 611 137 586 q 224 636 187 636 m 164 75 q 198 157 182 140 q 244 175 214 175 q 304 119 304 175 q 296 75 304 93 q 262 18 287 56 l 103 -243 l 72 -231 l 164 75 \"},\"f\":{\"x_min\":12,\"x_max\":432.546875,\"ha\":397,\"o\":\"m 127 324 l 127 597 q 66 595 92 597 q 12 588 39 594 l 14 626 l 12 654 q 79 648 38 649 q 127 647 121 647 q 192 901 127 777 q 378 1025 257 1025 q 409 1022 400 1025 q 432 1015 418 1019 l 415 896 q 371 911 395 905 q 325 918 347 918 q 252 886 278 918 q 227 805 227 855 q 235 713 227 760 q 246 647 243 665 q 330 650 276 647 q 396 654 384 654 q 391 642 393 647 q 389 633 389 637 l 388 622 l 389 610 q 396 589 389 609 q 323 595 357 594 q 246 597 289 597 l 246 366 q 250 183 246 305 q 254 0 254 60 q 213 3 238 0 q 183 6 187 6 q 144 4 161 6 q 116 0 127 1 q 121 160 116 52 q 127 324 127 269 \"},\"\":{\"x_min\":83.71875,\"x_max\":550.390625,\"ha\":625,\"o\":\"m 471 659 q 441 593 458 618 q 389 568 424 568 q 350 579 365 568 q 335 613 335 591 q 346 660 335 633 q 371 706 358 687 l 519 950 l 550 940 l 471 659 m 221 659 q 192 593 211 618 q 137 568 174 568 q 83 613 83 568 q 93 658 83 637 q 119 706 103 680 l 268 950 l 300 940 l 221 659 \"},\"A\":{\"x_min\":-15.28125,\"x_max\":838.890625,\"ha\":825,\"o\":\"m 257 639 l 387 950 q 402 945 395 947 q 417 944 409 944 q 452 950 437 944 q 576 629 536 733 q 686 359 617 526 q 838 0 755 192 q 789 3 820 0 q 751 6 758 6 q 700 4 723 6 q 663 0 677 1 q 600 199 622 137 q 543 353 579 260 l 377 358 l 215 353 l 162 205 q 130 110 145 160 q 101 0 115 59 l 44 5 q 6 2 20 5 q -15 0 -8 0 q 76 211 30 105 q 158 404 121 318 q 257 639 195 490 m 378 419 l 513 425 l 379 761 l 246 425 l 378 419 \"},\"6\":{\"x_min\":64,\"x_max\":692,\"ha\":749,\"o\":\"m 464 859 q 267 730 324 859 q 210 442 210 602 q 315 514 262 488 q 431 540 367 540 q 618 462 545 540 q 692 270 692 385 q 604 65 692 145 q 390 -15 516 -15 q 142 93 221 -15 q 64 377 64 201 q 167 745 64 581 q 462 909 270 909 q 524 905 501 909 q 579 890 547 902 l 574 827 q 521 851 547 844 q 464 859 495 859 m 554 258 q 510 409 554 347 q 380 471 466 471 q 255 409 300 471 q 210 264 210 348 q 253 105 210 172 q 384 39 297 39 q 485 73 441 39 q 540 148 529 108 q 552 206 551 187 q 554 258 554 225 \"},\"\":{\"x_min\":86.5,\"x_max\":303.171875,\"ha\":374,\"o\":\"m 224 659 q 193 594 212 620 q 140 568 174 568 q 86 615 86 568 q 98 660 86 633 q 122 708 110 687 l 271 951 l 303 942 l 224 659 \"},\"\":{\"x_min\":-29,\"x_max\":362,\"ha\":342,\"o\":\"m 104 333 l 104 520 q 103 566 104 544 q 96 654 102 588 q 140 647 130 648 q 165 647 151 647 q 232 654 195 647 q 224 555 225 599 q 223 437 223 511 l 223 406 q 228 194 223 337 q 233 0 233 51 q 201 3 216 1 q 165 5 185 5 q 127 3 148 5 q 96 0 107 1 q 100 165 96 51 q 104 333 104 279 m 45 928 q 99 907 77 928 q 122 853 122 886 q 101 800 122 822 q 48 778 80 778 q -6 800 15 778 q -29 853 -29 822 q -7 906 -29 884 q 45 928 13 928 m 286 928 q 340 906 318 928 q 362 853 362 884 q 341 799 362 821 q 289 778 321 778 q 235 800 257 778 q 213 853 213 822 q 233 905 213 883 q 286 928 254 928 \"},\"\":{\"x_min\":19,\"x_max\":957,\"ha\":989,\"o\":\"m 702 5 l 635 0 q 639 114 635 44 q 643 196 643 185 l 643 575 l 508 575 l 373 575 l 369 284 q 373 143 369 236 q 377 0 377 50 q 345 3 360 1 q 309 5 329 5 q 271 3 292 5 q 239 0 250 1 l 248 196 l 243 575 q 130 553 171 575 q 43 472 89 532 q 19 559 35 519 q 139 627 71 611 q 305 644 207 644 l 658 644 l 852 644 l 957 651 l 951 610 l 957 566 l 769 575 l 765 310 q 769 154 765 257 q 773 0 773 51 q 739 3 755 1 q 702 5 724 5 \"},\"\":{\"x_min\":41,\"x_max\":827.109375,\"ha\":846,\"o\":\"m 705 352 q 803 -1 763 155 l 739 1 l 673 -1 l 632 172 q 521 36 593 87 q 356 -15 448 -15 q 129 81 217 -15 q 41 316 41 177 q 130 569 41 467 q 368 672 220 672 q 537 622 464 672 q 659 486 610 573 q 711 654 691 569 l 770 650 l 827 654 q 763 505 792 576 q 705 352 734 434 m 518 943 q 552 974 536 964 q 589 985 568 985 q 626 969 611 985 q 641 932 641 953 q 627 897 641 911 q 585 866 613 883 l 384 743 l 335 743 l 518 943 m 377 619 q 226 530 272 619 q 181 326 181 442 q 223 124 181 214 q 367 34 265 34 q 528 137 480 34 q 601 323 577 240 q 527 531 578 444 q 377 619 475 619 \"},\"O\":{\"x_min\":51,\"x_max\":1068,\"ha\":1119,\"o\":\"m 51 465 q 192 820 51 690 q 559 950 333 950 q 892 853 754 950 q 1047 654 1031 757 q 1065 525 1062 551 q 1068 462 1068 500 q 1065 402 1068 426 q 1047 277 1062 379 q 894 80 1031 175 q 560 -15 756 -15 q 447 -10 496 -15 q 304 29 398 -5 q 130 186 210 64 q 51 465 51 308 m 202 468 q 290 162 202 282 q 559 42 379 42 q 826 162 738 42 q 915 468 915 283 q 825 770 915 651 q 559 889 735 889 q 348 826 429 889 q 225 639 267 764 q 202 468 202 552 \"},\"n\":{\"x_min\":89,\"x_max\":661,\"ha\":754,\"o\":\"m 99 155 l 99 495 q 97 569 99 530 q 91 655 95 608 q 153 648 122 648 l 219 656 l 218 539 q 319 635 260 599 q 451 672 378 672 q 591 624 528 672 q 654 501 654 576 l 654 299 l 654 136 l 661 0 q 629 3 644 1 q 593 5 613 5 q 556 3 576 5 q 525 0 536 1 q 530 222 525 80 q 535 406 535 364 q 501 536 535 485 q 389 587 467 587 q 253 508 288 587 q 218 313 218 430 q 220 132 218 258 q 222 0 222 6 q 184 3 208 0 q 155 6 159 6 q 117 3 141 6 q 89 0 93 0 l 99 155 \"},\"3\":{\"x_min\":75,\"x_max\":644,\"ha\":749,\"o\":\"m 241 465 l 238 512 l 294 510 q 424 554 375 510 q 474 680 474 599 q 434 805 474 754 q 322 856 394 856 q 220 818 257 856 q 164 711 183 780 l 153 706 q 127 767 136 747 q 99 819 118 788 q 220 886 162 863 q 348 909 278 909 q 526 857 450 909 q 603 706 603 805 q 542 564 603 617 q 383 479 482 511 q 567 423 490 479 q 644 262 644 366 q 542 55 644 129 q 302 -18 441 -18 q 183 -6 240 -18 q 75 32 127 5 q 99 189 91 116 l 113 188 q 182 73 136 115 q 302 31 229 31 q 448 92 392 31 q 505 246 505 154 q 451 389 505 333 q 312 446 398 446 q 238 435 279 446 l 241 465 \"},\"9\":{\"x_min\":57,\"x_max\":688,\"ha\":749,\"o\":\"m 261 38 q 475 166 405 38 q 546 451 546 295 q 442 378 494 403 q 325 354 389 354 q 132 428 208 354 q 57 617 57 502 q 148 828 57 748 q 372 909 240 909 q 612 801 536 909 q 688 520 688 693 q 574 143 688 305 q 252 -18 461 -18 q 186 -14 211 -18 q 127 0 161 -11 l 113 90 q 180 51 143 64 q 261 38 218 38 m 372 419 q 501 482 457 419 q 546 634 546 545 q 504 790 546 725 q 373 855 462 855 q 238 791 284 855 q 193 637 193 727 q 238 482 193 545 q 372 419 284 419 \"},\"l\":{\"x_min\":100,\"x_max\":237.5,\"ha\":342,\"o\":\"m 107 118 l 107 881 q 104 965 107 915 q 101 1025 101 1016 q 169 1018 138 1018 q 237 1025 203 1018 q 228 872 230 948 q 226 684 226 797 l 226 512 l 232 111 l 237 0 q 205 3 220 1 q 169 5 189 5 q 131 3 152 5 q 100 0 111 1 l 107 118 \"},\"\":{\"x_min\":97,\"x_max\":677.5625,\"ha\":683,\"o\":\"m 104 365 q 100 531 104 428 q 97 655 97 634 q 164 647 134 647 q 231 654 196 647 q 227 516 231 608 q 223 377 223 425 l 258 377 q 386 498 323 431 q 528 654 449 565 q 588 647 563 647 q 640 647 613 647 q 672 652 662 651 l 358 387 l 548 165 q 608 93 577 127 q 677 19 638 59 l 677 0 q 628 3 659 0 q 591 6 596 6 q 544 3 567 6 q 510 0 520 0 q 437 100 477 47 q 360 196 398 153 l 269 308 l 252 323 l 223 326 q 227 163 223 274 q 231 0 231 52 l 164 5 l 97 0 q 100 208 97 77 q 104 365 104 339 \"},\"4\":{\"x_min\":39,\"x_max\":691.78125,\"ha\":749,\"o\":\"m 453 252 l 177 257 l 39 253 l 39 291 q 204 522 111 392 q 345 721 297 653 q 475 906 394 789 l 527 906 l 581 906 q 575 805 581 872 q 569 705 569 739 l 569 343 l 598 343 q 644 344 620 343 q 690 350 667 345 l 683 297 q 686 270 683 287 q 691 244 689 254 q 568 253 629 253 l 568 137 l 569 0 l 505 6 l 437 0 q 450 120 447 51 q 453 252 453 190 m 453 767 l 344 626 q 230 465 298 562 q 144 343 162 368 l 453 343 l 453 767 \"},\"p\":{\"x_min\":83,\"x_max\":702,\"ha\":758,\"o\":\"m 91 -106 q 89 202 91 47 q 87 513 88 358 l 83 655 q 109 650 95 652 q 146 648 124 648 q 177 650 165 648 q 213 655 188 651 q 202 535 202 591 q 297 637 246 602 q 425 672 349 672 q 630 567 558 672 q 702 322 702 463 q 629 84 702 183 q 423 -15 556 -15 q 210 99 287 -15 l 210 -101 q 214 -244 210 -148 q 219 -373 219 -340 q 185 -369 201 -370 q 151 -368 170 -368 q 130 -368 138 -368 q 83 -373 123 -368 q 87 -240 83 -329 q 91 -106 91 -151 m 384 596 q 245 514 289 596 q 202 328 202 433 q 244 134 202 220 q 383 48 286 48 q 520 131 478 48 q 563 322 563 215 q 519 509 563 423 q 384 596 475 596 \"},\"\":{\"x_min\":78,\"x_max\":1002,\"ha\":1038,\"o\":\"m 78 294 l 82 477 l 82 654 l 145 650 l 215 654 q 209 517 215 605 q 203 421 203 430 l 203 341 q 264 117 203 197 q 465 38 325 38 l 468 260 q 461 535 468 342 q 455 786 455 729 q 496 779 479 782 q 526 776 513 776 q 566 780 545 776 q 600 786 587 784 q 591 496 600 690 q 583 270 583 302 l 587 38 q 791 132 715 38 q 867 357 867 227 q 824 641 867 506 q 885 645 857 641 q 960 656 912 648 q 1002 419 1002 544 q 891 118 1002 231 q 587 -13 780 5 l 591 -221 l 600 -372 q 561 -365 578 -367 q 526 -363 543 -363 q 491 -366 511 -363 q 455 -372 471 -369 q 461 -162 455 -302 q 468 -13 468 -22 q 194 64 310 -13 q 78 294 78 142 \"},\"\":{\"x_min\":101,\"x_max\":919.0625,\"ha\":1015,\"o\":\"m 182 927 l 262 931 q 250 805 253 854 q 247 697 247 757 l 247 457 q 314 136 247 212 q 516 60 381 60 q 733 130 654 60 q 813 336 813 201 l 813 458 l 813 657 q 799 931 813 802 l 859 927 l 919 931 q 905 770 909 863 q 901 600 901 677 l 901 366 q 792 82 901 179 q 491 -15 684 -15 q 211 66 307 -15 q 116 325 116 148 l 116 426 l 116 698 q 112 805 116 757 q 101 931 109 854 l 182 927 m 410 1208 q 462 1186 442 1208 q 483 1133 483 1164 q 460 1081 483 1105 q 410 1058 438 1058 q 356 1080 379 1058 q 334 1133 334 1103 q 356 1185 334 1163 q 410 1208 378 1208 m 650 1208 q 704 1187 682 1208 q 727 1133 727 1166 q 704 1080 727 1103 q 650 1058 681 1058 q 598 1078 620 1058 q 576 1133 576 1099 q 598 1185 576 1163 q 650 1208 620 1208 \"},\"\":{\"x_min\":43,\"x_max\":655.5,\"ha\":649,\"o\":\"m 234 -15 q 98 33 153 -15 q 43 162 43 82 q 106 303 43 273 q 303 364 169 333 q 444 448 437 395 q 403 568 444 521 q 288 616 362 616 q 191 587 233 616 q 124 507 149 559 l 95 520 l 104 591 q 202 651 144 631 q 323 672 261 672 q 500 622 444 672 q 557 455 557 573 l 557 133 q 567 69 557 84 q 618 54 577 54 q 655 58 643 54 l 655 26 q 594 5 626 14 q 537 -6 562 -3 q 438 85 453 -6 q 342 10 388 35 q 234 -15 296 -15 m 392 743 l 191 866 q 152 896 170 877 q 133 934 133 915 q 148 970 133 955 q 186 986 163 986 q 222 972 200 986 q 254 945 245 958 l 442 743 l 392 743 m 176 186 q 204 98 176 133 q 284 64 232 64 q 390 107 342 64 q 438 212 438 151 l 438 345 q 239 293 303 319 q 176 186 176 268 \"},\"\":{\"x_min\":91,\"x_max\":662,\"ha\":754,\"o\":\"m 594 -365 q 557 -366 577 -365 q 526 -369 537 -368 q 531 -189 526 -310 q 537 -7 537 -68 l 537 406 q 503 536 537 485 q 391 587 469 587 q 255 508 290 587 q 220 315 220 430 q 222 133 220 259 q 224 1 224 8 l 158 6 l 91 1 l 101 156 l 101 495 q 97 584 101 527 q 93 655 93 640 q 119 650 105 652 q 155 648 134 648 q 185 650 175 648 q 221 655 195 651 l 220 538 q 321 637 265 602 q 452 672 378 672 q 604 603 552 672 q 656 430 656 535 l 656 329 l 656 -186 q 659 -293 656 -227 q 662 -370 662 -359 q 630 -366 645 -368 q 594 -365 614 -365 \"}},\"cssFontWeight\":\"normal\",\"ascender\":1267,\"underlinePosition\":-133,\"cssFontStyle\":\"normal\",\"boundingBox\":{\"yMin\":-373.75,\"xMin\":-71,\"yMax\":1267,\"xMax\":1511},\"resolution\":1000,\"original_font_information\":{\"postscript_name\":\"Optimer-Regular\",\"version_string\":\"Version 1.00 2004 initial release\",\"vendor_url\":\"http://www.magenta.gr/\",\"full_font_name\":\"Optimer\",\"font_family_name\":\"Optimer\",\"copyright\":\"Copyright (c) Magenta Ltd., 2004\",\"description\":\"\",\"trademark\":\"\",\"designer\":\"\",\"designer_url\":\"\",\"unique_font_identifier\":\"Magenta Ltd.:Optimer:22-10-104\",\"license_url\":\"http://www.ellak.gr/fonts/MgOpen/license.html\",\"license_description\":\"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\\\"Fonts\\\") and associated documentation files (the \\\"Font Software\\\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \\r\\n\\r\\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\\r\\n\\r\\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \\\"MgOpen\\\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\\r\\n\\r\\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \\\"MgOpen\\\" name.\\r\\n\\r\\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \\r\\n\\r\\nTHE FONT SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.\",\"manufacturer_name\":\"Magenta Ltd.\",\"font_sub_family_name\":\"Regular\"},\"descender\":-374,\"familyName\":\"Optimer\",\"lineHeight\":1640,\"underlineThickness\":20}"

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _assign = __webpack_require__(236);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _set = __webpack_require__(242);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _three = __webpack_require__(226);
	
	var _Camera = __webpack_require__(260);
	
	var _Camera2 = _interopRequireDefault(_Camera);
	
	var _MainLoop = __webpack_require__(261);
	
	var _MainLoop2 = _interopRequireDefault(_MainLoop);
	
	var _c3DEngine = __webpack_require__(262);
	
	var _c3DEngine2 = _interopRequireDefault(_c3DEngine);
	
	var _LayerUpdateStrategy = __webpack_require__(264);
	
	var _Layer = __webpack_require__(265);
	
	var _Scheduler = __webpack_require__(269);
	
	var _Scheduler2 = _interopRequireDefault(_Scheduler);
	
	var _Debug = __webpack_require__(1);
	
	var _Debug2 = _interopRequireDefault(_Debug);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Constructs an Itowns Scene instance
	 *
	 * @param {string} crs - The default CRS of Three.js coordinates. Should be a cartesian CRS.
	 * @param {DOMElement} viewerDiv - Where to instanciate the Three.js scene in the DOM
	 * @param {boolean} options - Optional properties. May contain:
	 *    - mainLoop: {MainLoop} instance to use, otherwise a default one will be constructed
	 *    - renderer: {WebGLRenderer} instance to use, otherwise a default one will be constructed. If
	 *    not present, a new <canvas> will be created and added to viewerDiv (mutually exclusive with mainLoop)
	 *    - scene3D: {Scene} instance to use, otherwise a default one will be constructed
	 * @param {boolean} glDebug - debug gl code
	 * @constructor
	 * @example
	 * // How add gpx object
	 * itowns.loadGpx(url).then((gpx) => {
	 *      if (gpx) {
	 *         viewer.scene.add(gpx);
	 *      }
	 * });
	 *
	 * viewer.notifyChange(0, true);
	 */
	/* TODO:
	* - remove debug boolean, replace by if __DEBUG__ and checkboxes in debug UI
	* - Scene (and subobjects) should be instanciable several times.
	*/
	/**
	 * Generated On: 2015-10-5
	 * Class: Scene
	 * Description: La Scene est l'instance principale du client. Elle est le chef orchestre de l'application.
	 */
	
	/* global window, requestAnimationFrame */
	function View(crs, viewerDiv) {
	    var _this = this;
	
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	    this.referenceCrs = crs;
	
	    this.mainLoop = options.mainLoop || new _MainLoop2.default(new _Scheduler2.default(), new _c3DEngine2.default(viewerDiv, options.renderer));
	
	    this.scene = options.scene3D || new _three.Scene();
	    if (!options.scene3D) {
	        this.scene.autoUpdate = false;
	    }
	
	    this.camera = new _Camera2.default(viewerDiv.clientWidth, viewerDiv.clientHeight);
	
	    this._layers = [];
	
	    if (false) {
	        (0, _Debug2.default)(this, viewerDiv);
	    }
	
	    this.viewerDiv = viewerDiv;
	    window.addEventListener('resize', function () {
	        _this.mainLoop.gfxEngine.onWindowResize();
	        _this.camera.resize(_this.viewerDiv.clientWidth, _this.viewerDiv.clientHeight);
	        _this.camera.update();
	        _this.notifyChange(0, true);
	    }, false);
	
	    this.onAfterRender = function () {};
	
	    this._changeSources = new _set2.default();
	}
	
	View.prototype = (0, _create2.default)(_three.EventDispatcher.prototype);
	View.prototype.constructor = View;
	
	var _syncThreejsLayer = function _syncThreejsLayer(layer, view) {
	    if (layer.visible) {
	        view.camera.camera3D.layers.enable(layer.threejsLayer);
	    } else {
	        view.camera.camera3D.layers.disable(layer.threejsLayer);
	    }
	};
	
	function _preprocessLayer(view, layer, provider) {
	    if (!(layer instanceof _Layer.Layer) && !(layer instanceof _Layer.GeometryLayer)) {
	        var nlayer = new _Layer.Layer(layer.id);
	        delete layer.id;
	        layer = (0, _assign2.default)(nlayer, layer);
	    }
	
	    if (!layer.updateStrategy) {
	        layer.updateStrategy = {
	            type: _LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC
	        };
	    }
	
	    if (provider) {
	        if (provider.tileInsideLimit) {
	            layer.tileInsideLimit = provider.tileInsideLimit.bind(provider);
	        }
	
	        if (provider.tileTextureCount) {
	            layer.tileTextureCount = provider.tileTextureCount.bind(provider);
	        }
	
	        if (provider.preprocessDataLayer) {
	            provider.preprocessDataLayer(layer);
	        }
	    }
	
	    // probably not the best place to do this
	    if (layer.type == 'color') {
	        (0, _Layer.defineLayerProperty)(layer, 'frozen', false);
	        (0, _Layer.defineLayerProperty)(layer, 'visible', true);
	        (0, _Layer.defineLayerProperty)(layer, 'opacity', 1.0);
	        (0, _Layer.defineLayerProperty)(layer, 'sequence', 0);
	    } else if (layer.type == 'elevation') {
	        (0, _Layer.defineLayerProperty)(layer, 'frozen', false);
	    } else if (layer.type == 'geometry' || layer.type == 'debug') {
	        layer.threejsLayer = view.mainLoop.gfxEngine.getUniqueThreejsLayer();
	        (0, _Layer.defineLayerProperty)(layer, 'visible', true, function () {
	            return _syncThreejsLayer(layer, view);
	        });
	        _syncThreejsLayer(layer, view);
	    }
	    return layer;
	}
	
	/**
	 * Options to wms protocol
	 * @typedef {Object} OptionsWms
	 * @property {Attribution} attribution The intellectual property rights for the layer
	 * @property {string} name
	 * @property {string} mimetype
	 */
	
	/**
	 * Options to wtms protocol
	 * @typedef {Object} OptionsWmts
	 * @property {Attribution} attribution The intellectual property rights for the layer
	 * @property {string} name
	 * @property {string} mimetype
	 * @property {string} tileMatrixSet
	 * @property {Array.<Object>} tileMatrixSetLimits The limits for the tile matrix set
	 * @property {number} tileMatrixSetLimits.minTileRow Minimum row for tiles at the level
	 * @property {number} tileMatrixSetLimits.maxTileRow Maximum row for tiles at the level
	 * @property {number} tileMatrixSetLimits.minTileCol Minimum col for tiles at the level
	 * @property {number} tileMatrixSetLimits.maxTileCol Maximum col for tiles at the level
	 * @property {Object} [zoom]
	 * @property {Object} [zoom.min] layer's zoom minimum
	 * @property {Object} [zoom.max] layer's zoom maximum
	 */
	
	/**
	 * LayerOptions
	 * @typedef {Object} LayerOptions
	 * @property {string} id Unique layer's id
	 * @property {string} type the layer's type : 'color', 'elevation', 'geometry'
	 * @property {string} layer.protocol wmts and wms (wmtsc for custom deprecated)
	 * @property {string} layer.url Base URL of the repository or of the file(s) to load
	 * @property {Object} layer.updateStrategy strategy to load imagery files
	 * @property {OptionsWmts|OptionsWms} layer.options WMTS or WMS options
	 */
	
	/**
	 * Add layer in viewer.
	 * The layer id must be unique.
	 *
	 * @example
	 * // Add Color Layer
	 * view.addLayer({
	 *      type: 'color',
	 *      id: 'iColor',
	 * });
	 * // Add Elevation Layer
	 * view.addLayer({
	 *      type: 'elevation',
	 *      id: 'iElevation',
	 * });
	 * @param {LayerOptions} layer option
	 */
	View.prototype.addLayer = function addLayer(layer, parentLayer) {
	    layer = _preprocessLayer(this, layer, this.mainLoop.scheduler.getProtocolProvider(layer.protocol));
	    if (parentLayer) {
	        parentLayer.attach(layer);
	    } else {
	        if (typeof layer.update !== 'function') {
	            throw new Error('Cant add GeometryLayer: missing a update function');
	        }
	        if (typeof layer.preUpdate !== 'function') {
	            throw new Error('Cant add GeometryLayer: missing a preUpdate function');
	        }
	
	        this._layers.push(layer);
	    }
	
	    return layer;
	};
	
	/**
	 * Notifies the scene it needs to be updated due to changes exterior to the
	 * scene itself (e.g. camera movement).
	 * @param {Number} delay Using a non-0 delay allows to delay update - useful to reduce CPU load for
	 * non-interactive events (e.g: texture loaded)
	 * @param {Boolean} needsRedraw indicates if notified change requires a full scene redraw.
	 */
	View.prototype.notifyChange = function notifyChange(delay, needsRedraw, changeSource) {
	    var _this2 = this;
	
	    if (delay) {
	        window.setTimeout(function () {
	            _this2._changeSources.add(changeSource);
	            _this2.mainLoop.scheduleViewUpdate(_this2, needsRedraw);
	        }, delay);
	    } else {
	        this._changeSources.add(changeSource);
	        this.mainLoop.scheduleViewUpdate(this, needsRedraw);
	    }
	};
	
	/**
	 * Get all layers, with an optionnal filter applied.
	 * The filter method will be called with 2 args:
	 *   - 1st: current layer
	 *   - 2nd: (optional) the geometry layer to which the current layer is attached
	 * @example
	 * // get all color layers
	 * view.getLayers(layer => layer.type === 'color')
	 * // get one layer with id
	 * view.getLayers(layer => layer.id === 'itt')
	 * @param {function} filter
	 * @returns {Array}  array of Layer
	 */
	View.prototype.getLayers = function getLayers(filter) {
	    var result = [];
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(this._layers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var geometryLayer = _step.value;
	
	            if (!filter || filter(geometryLayer)) {
	                result.push(geometryLayer);
	            }
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = (0, _getIterator3.default)(geometryLayer._attachedLayers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var attached = _step2.value;
	
	                    if (!filter || filter(attached, geometryLayer)) {
	                        result.push(attached);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return result;
	};
	
	exports.default = View;

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(237), __esModule: true };

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(238);
	module.exports = __webpack_require__(15).Object.assign;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(14);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(239)});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(44)
	  , gOPS     = __webpack_require__(240)
	  , pIE      = __webpack_require__(241)
	  , toObject = __webpack_require__(5)
	  , IObject  = __webpack_require__(36)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(24)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 240 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 241 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(243), __esModule: true };

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(244);
	__webpack_require__(54);
	__webpack_require__(30);
	__webpack_require__(245);
	__webpack_require__(257);
	module.exports = __webpack_require__(15).Set;

/***/ },
/* 244 */
/***/ function(module, exports) {



/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(246);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(252)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(19).f
	  , create      = __webpack_require__(42)
	  , redefineAll = __webpack_require__(247)
	  , ctx         = __webpack_require__(16)
	  , anInstance  = __webpack_require__(248)
	  , defined     = __webpack_require__(6)
	  , forOf       = __webpack_require__(249)
	  , $iterDefine = __webpack_require__(38)
	  , step        = __webpack_require__(33)
	  , setSpecies  = __webpack_require__(250)
	  , DESCRIPTORS = __webpack_require__(23)
	  , fastKey     = __webpack_require__(251).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(18);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 248 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(16)
	  , call        = __webpack_require__(222)
	  , isArrayIter = __webpack_require__(223)
	  , anObject    = __webpack_require__(20)
	  , toLength    = __webpack_require__(47)
	  , getIterFn   = __webpack_require__(57)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(11)
	  , core        = __webpack_require__(15)
	  , dP          = __webpack_require__(19)
	  , DESCRIPTORS = __webpack_require__(23)
	  , SPECIES     = __webpack_require__(53)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(12)('meta')
	  , isObject = __webpack_require__(21)
	  , has      = __webpack_require__(8)
	  , setDesc  = __webpack_require__(19).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(24)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(11)
	  , $export        = __webpack_require__(14)
	  , meta           = __webpack_require__(251)
	  , fails          = __webpack_require__(24)
	  , hide           = __webpack_require__(18)
	  , redefineAll    = __webpack_require__(247)
	  , forOf          = __webpack_require__(249)
	  , anInstance     = __webpack_require__(248)
	  , isObject       = __webpack_require__(21)
	  , setToStringTag = __webpack_require__(52)
	  , dP             = __webpack_require__(19).f
	  , each           = __webpack_require__(253)(0)
	  , DESCRIPTORS    = __webpack_require__(23);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(16)
	  , IObject  = __webpack_require__(36)
	  , toObject = __webpack_require__(5)
	  , toLength = __webpack_require__(47)
	  , asc      = __webpack_require__(254);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(255);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21)
	  , isArray  = __webpack_require__(256)
	  , SPECIES  = __webpack_require__(53)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(37);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(14);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(258)('Set')});

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(58)
	  , from    = __webpack_require__(259);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(249);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function Camera(width, height) {
	    this.ratio = width / height;
	    this.FOV = 30;
	
	    this.camera3D = new THREE.PerspectiveCamera(this.FOV, this.ratio);
	
	    // /!\ WARNING Matrix JS are in Float32Array
	    this.camera3D.matrixWorld.elements = new Float64Array(16);
	
	    this.camera3D.matrixAutoUpdate = false;
	    this.camera3D.rotationAutoUpdate = false;
	
	    this._viewMatrix = new THREE.Matrix4();
	    this._visibilityTestingOffset = new THREE.Vector3();
	    this.width = width;
	    this.height = height;
	}
	
	/**
	 */
	/**
	 * Generated On: 2015-10-5
	 * Class: Camera
	 * Description: La camera scene, interface avec la camera du 3DEngine.
	 */
	
	/* global Float64Array*/
	
	Camera.prototype.position = function position() {
	    return this.camera3D.position;
	};
	
	Camera.prototype.resize = function resize(width, height) {
	    this.width = width;
	    this.height = height;
	    this.ratio = width / height;
	
	    this.camera3D.aspect = this.ratio;
	    this.camera3D.updateProjectionMatrix();
	
	    if (this.cameraHelper) {
	        var dir = new THREE.Vector3(0, 0, -1);
	        var quaternion = new THREE.Quaternion();
	        quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.HFOV / 2);
	        dir.applyQuaternion(quaternion);
	
	        this.arrowHelper.setDirection(dir);
	        this.cameraHelper.update();
	    }
	};
	
	Camera.prototype.update = function update() {
	    // update matrix
	    this.camera3D.updateMatrix();
	    this.camera3D.updateMatrixWorld();
	
	    // keep our visibility testing matrix ready
	    this._visibilityTestingOffset.setFromMatrixPosition(this.camera3D.matrixWorld);
	    var c = this.camera3D.matrixWorld;
	    // cancel out translation
	    c.setPosition({ x: 0, y: 0, z: 0 });
	    this._viewMatrix.getInverse(c);
	    this._viewMatrix.premultiply(this.camera3D.projectionMatrix);
	    // restore translation
	    c.setPosition(this._visibilityTestingOffset);
	};
	
	Camera.prototype.getDistanceFromOrigin = function getDistanceFromOrigin() {
	    return this.camera3D.position.length();
	};
	
	Camera.prototype.setPosition = function setPosition(position) {
	    this.camera3D.position.copy(position);
	};
	
	Camera.prototype.setRotation = function setRotation(rotation) {
	    this.camera3D.quaternion.copy(rotation);
	};
	
	var temp = new THREE.Vector3();
	var frustum = new THREE.Frustum();
	var obbViewMatrix = new THREE.Matrix4();
	Camera.prototype.isBox3DVisible = function isBox3DVisible(box3d, matrixWorld) {
	    temp.setFromMatrixPosition(matrixWorld);
	    matrixWorld.elements[12] -= this._visibilityTestingOffset.x;
	    matrixWorld.elements[13] -= this._visibilityTestingOffset.y;
	    matrixWorld.elements[14] -= this._visibilityTestingOffset.z;
	
	    obbViewMatrix.multiplyMatrices(this._viewMatrix, matrixWorld);
	
	    matrixWorld.setPosition(temp);
	
	    frustum.setFromMatrix(obbViewMatrix);
	    return frustum.intersectsBox(box3d);
	};
	
	Camera.prototype.box3DSizeOnScreen = function box3DSizeOnScreen(box3d, matrixWorld) {
	    var c = box3d.clone();
	    var m = matrixWorld ? matrixWorld.clone() : new THREE.Matrix4();
	    m.elements[12] -= this._visibilityTestingOffset.x;
	    m.elements[13] -= this._visibilityTestingOffset.y;
	    m.elements[14] -= this._visibilityTestingOffset.z;
	    m.premultiply(this._viewMatrix);
	
	    return c.applyMatrix4(m);
	};
	
	exports.default = Camera;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RENDERING_PAUSED = 0;
	var RENDERING_ACTIVE = 1;
	
	function MainLoop(scheduler, engine) {
	    this.renderingState = RENDERING_PAUSED;
	    this.needsRedraw = false;
	    this.scheduler = scheduler;
	    this.gfxEngine = engine; // TODO: remove me
	}
	
	MainLoop.prototype = (0, _create2.default)(_three.EventDispatcher.prototype);
	MainLoop.prototype.constructor = MainLoop;
	
	MainLoop.prototype.scheduleViewUpdate = function scheduleViewUpdate(view, forceRedraw) {
	    var _this = this;
	
	    this.needsRedraw |= forceRedraw;
	
	    if (this.renderingState !== RENDERING_ACTIVE) {
	        this.renderingState = RENDERING_ACTIVE;
	        if (false) {
	            document.title += ' ';
	        }
	
	        requestAnimationFrame(function () {
	            _this._step(view);
	        });
	    }
	};
	
	function updateElements(context, geometryLayer, elements) {
	    if (!elements) {
	        return;
	    }
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(elements), _step2; !(_iteratorNormalCompletion = (_step2 = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var element = _step2.value;
	
	            // update element
	            var newElementsToUpdate = geometryLayer.update(context, geometryLayer, element);
	
	            // update attached layers
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = (0, _getIterator3.default)(geometryLayer._attachedLayers), _step3; !(_iteratorNormalCompletion2 = (_step3 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var attachedLayer = _step3.value;
	
	                    attachedLayer.update(context, attachedLayer, element);
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            updateElements(context, geometryLayer, newElementsToUpdate);
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	}
	
	MainLoop.prototype._update = function _update(view) {
	    var context = {
	        camera: view.camera,
	        engine: this.gfxEngine,
	        scheduler: this.scheduler,
	        view: view
	    };
	
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	        for (var _iterator3 = (0, _getIterator3.default)(view.getLayers(function (x, y) {
	            return !y;
	        })), _step4; !(_iteratorNormalCompletion3 = (_step4 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var geometryLayer = _step4.value;
	
	            context.geometryLayer = geometryLayer;
	            var elementsToUpdate = geometryLayer.preUpdate(context, geometryLayer, view._changeSources);
	            updateElements(context, geometryLayer, elementsToUpdate);
	        }
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	};
	
	MainLoop.prototype._step = function _step(view) {
	    // update data-structure
	    this._update(view);
	
	    if (this.scheduler.commandsWaitingExecutionCount() == 0) {
	        this.dispatchEvent({ type: 'command-queue-empty' });
	    }
	
	    // Redraw *only* if needed.
	    // (redraws only happen when this.needsRedraw is true, which in turn only happens when
	    // view.notifyChange() is called with redraw=true)
	    // As such there's no continuous update-loop, instead we use a ad-hoc update/render
	    // mechanism.
	    if (this.needsRedraw) {
	        this._renderView(view);
	        this.needsRedraw = false;
	    }
	
	    if (false) {
	        document.title = document.title.substr(0, document.title.length - 2);
	    }
	    this.renderingState = RENDERING_PAUSED;
	    view._changeSources.clear();
	};
	
	/**
	 */
	MainLoop.prototype._renderView = function _renderView(view) {
	    var dim = this.gfxEngine.getWindowSize();
	    view.camera.resize(dim.x, dim.y);
	    view.camera.update();
	
	    if (view.preRender) {
	        view.preRender();
	    }
	
	    if (view.render) {
	        view.render();
	    } else {
	        // use default rendering method
	        this.gfxEngine.renderView(view);
	    }
	    this.needsRedraw = false;
	
	    // Mimic three Object3D.onAfterRender (which sadly doesn't work on Scene)
	    view.onAfterRender();
	};
	
	exports.default = MainLoop;

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Capabilities = __webpack_require__(263);
	
	var _Capabilities2 = _interopRequireDefault(_Capabilities);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: c3DEngine
	 * Description: 3DEngine est l'interface avec le framework webGL.
	 */
	
	/* global Uint8Array, Float64Array, document, window, Image */
	
	function c3DEngine(viewerDiv) {
	    var NOIE = !_Capabilities2.default.isInternetExplorer();
	    this.viewerDiv = viewerDiv;
	
	    this.width = viewerDiv.clientWidth;
	    this.height = viewerDiv.clientHeight;
	
	    this.positionBuffer = null;
	    this._nextThreejsLayer = 0;
	
	    this.fullSizeRenderTarget = new THREE.WebGLRenderTarget(this.width, this.height);
	    this.fullSizeRenderTarget.texture.minFilter = THREE.LinearFilter;
	    this.fullSizeRenderTarget.texture.generateMipmaps = false;
	
	    this.renderView = function renderScene(view) {
	        this.renderer.setViewport(0, 0, this.width, this.height);
	        this.renderer.clear();
	        this.renderer.render(view.scene, view.camera.camera3D);
	    }.bind(this);
	
	    this.onWindowResize = function onWindowResize() {
	        this.width = this.viewerDiv.clientWidth;
	        this.height = this.viewerDiv.clientHeight;
	        this.fullSizeRenderTarget.setSize(this.width, this.height);
	        this.renderer.setSize(this.viewerDiv.clientWidth, this.height);
	    }.bind(this);
	
	    //
	    // Create canvas
	    //
	    var canvas = document.createElement('canvas');
	
	    //
	    // Create renderer
	    //
	    this.renderer = new THREE.WebGLRenderer({
	        canvas: canvas,
	        antialias: true,
	        alpha: true,
	        logarithmicDepthBuffer: this.gLDebug || NOIE
	    });
	
	    _Capabilities2.default.updateCapabilities(this.renderer);
	
	    this.renderer.setPixelRatio(viewerDiv.devicePixelRatio);
	    this.renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);
	    this.renderer.setClearColor(0x030508);
	    this.renderer.autoClear = false;
	    this.renderer.sortObjects = false;
	
	    // this.viewerDiv.appendChild(canvas);
	    viewerDiv.appendChild(this.renderer.domElement);
	}
	
	/*
	 * return
	 */
	c3DEngine.prototype.getWindowSize = function getWindowSize() {
	    return new THREE.Vector2(this.width, this.height);
	};
	
	/**
	 * return renderer THREE.js
	 * @returns {undefined|c3DEngine_L7.THREE.WebGLRenderer}
	 */
	c3DEngine.prototype.getRenderer = function getRenderer() {
	    return this.renderer;
	};
	
	c3DEngine.prototype.renderViewTobuffer = function renderViewTobuffer(view, buffer, x, y, width, height) {
	    // TODO Deallocate render texture
	    var current = this.renderer.getCurrentRenderTarget();
	    this.renderer.setRenderTarget(buffer);
	    this.renderer.setViewport(x, y, width, height);
	    this.renderer.clear();
	    this.renderer.render(view.scene, view.camera.camera3D, buffer);
	    var pixelBuffer = new Uint8Array(4 * width * height);
	    this.renderer.readRenderTargetPixels(buffer, x, y, width, height, pixelBuffer);
	    this.renderer.setRenderTarget(current);
	
	    return pixelBuffer;
	};
	
	c3DEngine.prototype.bufferToImage = function bufferToImage(pixelBuffer, width, height) {
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	
	    // size the canvas to your desired image
	    canvas.width = width;
	    canvas.height = height;
	
	    var imgData = ctx.getImageData(0, 0, width, height);
	    imgData.data.set(pixelBuffer);
	
	    ctx.putImageData(imgData, 0, 0);
	
	    // create a new img object
	    var image = new Image();
	
	    // set the img.src to the canvas data url
	    image.src = canvas.toDataURL();
	
	    return image;
	};
	
	c3DEngine.prototype.getRTCMatrixFromCenter = function getRTCMatrixFromCenterFn() {
	    var position = new THREE.Vector3();
	    var matrix = new THREE.Matrix4();
	    return function getRTCMatrixFromCenter(center, camera) {
	        position.subVectors(camera.camera3D.position, center);
	        matrix.copy(camera.camera3D.matrixWorld);
	        matrix.setPosition(position);
	        matrix.getInverse(matrix);
	        return new THREE.Matrix4().multiplyMatrices(camera.camera3D.projectionMatrix, matrix);
	    };
	}();
	
	c3DEngine.prototype.getRTCMatrixFromNode = function getRTCMatrixFromNode(node, camera) {
	    // TODO: Simplify this function like getRTCMatrixFromCenter()
	    var camera3D = camera.camera3D;
	    var positionWorld = new THREE.Vector3().setFromMatrixPosition(node.matrixWorld);
	    var position = new THREE.Vector3().subVectors(camera3D.position, positionWorld);
	    var quaternion = new THREE.Quaternion().copy(camera3D.quaternion);
	    var matrix = new THREE.Matrix4().compose(position, quaternion, new THREE.Vector3(1, 1, 1));
	    var matrixInv = new THREE.Matrix4().getInverse(matrix);
	    var model = node.matrixWorld.clone().setPosition(new THREE.Vector3());
	    matrixInv.multiply(model);
	
	    var centerEye = new THREE.Vector4().applyMatrix4(matrixInv);
	    var mvc = matrixInv.setPosition(centerEye);
	    return new THREE.Matrix4().multiplyMatrices(camera3D.projectionMatrix, mvc);
	};
	
	c3DEngine.prototype.getUniqueThreejsLayer = function getUniqueThreejsLayer() {
	    // We use three.js Object3D.layers feature to manage visibility of
	    // geometry layers; so we need an internal counter to assign a new
	    // one to each new geometry layer.
	    // Warning: only 32 ([0, 31]) different layers can exist.
	    if (this._nextThreejsLayer > 31) {
	        // eslint-disable-next-line no-console
	        console.warn('Too much three.js layers. Starting from now all of them will use layerMask = 31');
	        this._nextThreejsLayer = 31;
	    }
	
	    var result = this._nextThreejsLayer++;
	
	    return result;
	};
	
	exports.default = c3DEngine;

/***/ },
/* 263 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// default values
	var logDepthBufferSupported = false;
	var maxTexturesUnits = 8;
	var internetExplorer = false || !!document.documentMode;
	
	exports.default = {
	    isLogDepthBufferSupported: function isLogDepthBufferSupported() {
	        return logDepthBufferSupported;
	    },
	    isInternetExplorer: function isInternetExplorer() {
	        return internetExplorer;
	    },
	    getMaxTextureUnitsCount: function getMaxTextureUnitsCount() {
	        return maxTexturesUnits;
	    },
	    updateCapabilities: function updateCapabilities(renderer) {
	        var gl = renderer.context;
	        maxTexturesUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	
	        var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
	        if (debugInfo !== null) {
	            var vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
	            if (vendor.indexOf('mesa') > -1 || vendor.indexOf('Mesa') > -1) {
	                maxTexturesUnits = Math.min(16, maxTexturesUnits);
	            }
	        } else {
	            maxTexturesUnits = Math.min(16, maxTexturesUnits);
	        }
	
	        logDepthBufferSupported = renderer.capabilities.logarithmicDepthBuffer;
	    }
	};

/***/ },
/* 264 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.chooseNextLevelToFetch = chooseNextLevelToFetch;
	/**
	 * This modules implements various layer update strategies.
	 *
	 * Default strategy is STRATEGY_MIN_NETWORK_TRAFFIC which aims
	 * to reduce the amount of network traffic.
	 */
	
	var STRATEGY_MIN_NETWORK_TRAFFIC = exports.STRATEGY_MIN_NETWORK_TRAFFIC = 0;
	var STRATEGY_GROUP = exports.STRATEGY_GROUP = 1;
	var STRATEGY_PROGRESSIVE = exports.STRATEGY_PROGRESSIVE = 2;
	var STRATEGY_DICHOTOMY = exports.STRATEGY_DICHOTOMY = 3;
	
	function _minimizeNetworkTraffic(nodeLevel /* , currentLevel, options */) {
	    return nodeLevel;
	}
	
	// Maps nodeLevel to groups defined in layer's options
	// eg with groups = [3, 7, 12]:
	//     * nodeLevel = 2 -> 3
	//     * nodeLevel = 4 -> 3
	//     * nodeLevel = 7 -> 7
	//     * nodeLevel = 15 -> 12
	function _group(nodeLevel, currentLevel, options) {
	    var f = options.groups.filter(function (val) {
	        return val <= nodeLevel;
	    });
	    return f.length ? f[f.length - 1] : options.groups[0];
	}
	
	function _progressive(nodeLevel, currentLevel, options) {
	    return Math.min(nodeLevel, currentLevel + (options.increment || 1));
	}
	
	// Load textures at mid-point between current level and node's level.
	// This produces smoother transitions and a single fetch updates multiple
	// tiles thanks to caching.
	function _dichotomy(nodeLevel, currentLevel /* , options */) {
	    return Math.min(nodeLevel, Math.ceil((currentLevel + nodeLevel) / 2));
	}
	
	function chooseNextLevelToFetch(strategy, nodeLevel, currentLevel, options) {
	    switch (strategy) {
	        case STRATEGY_GROUP:
	            return _group(nodeLevel, currentLevel, options);
	        case STRATEGY_PROGRESSIVE:
	            return _progressive(nodeLevel, currentLevel, options);
	        case STRATEGY_DICHOTOMY:
	            return _dichotomy(nodeLevel, currentLevel, options);
	        // default strategy
	        case STRATEGY_MIN_NETWORK_TRAFFIC:
	        default:
	            return _minimizeNetworkTraffic(nodeLevel, currentLevel, options);
	    }
	}

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ImageryLayers = exports.Layer = exports.GeometryLayer = exports.defineLayerProperty = undefined;
	
	var _from = __webpack_require__(219);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _defineProperty = __webpack_require__(266);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _three = __webpack_require__(226);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defineLayerProperty = exports.defineLayerProperty = function defineLayerProperty(layer, propertyName, defaultValue, onChange) {
	    var property = layer[propertyName] == undefined ? defaultValue : layer[propertyName];
	    (0, _defineProperty2.default)(layer, propertyName, { get: function get() {
	            return property;
	        },
	        set: function set(newValue) {
	            if (property !== newValue) {
	                var event = { type: propertyName + '-property-changed', previous: {}, new: {} };
	                event.previous[propertyName] = property;
	                event.new[propertyName] = newValue;
	                property = newValue;
	                if (onChange) {
	                    onChange(layer, propertyName);
	                }
	                layer.dispatchEvent(event);
	            }
	        } });
	};
	
	function GeometryLayer(i) {
	    this._attachedLayers = [];
	
	    Object.defineProperty(this, 'id', {
	        value: i,
	        writable: false
	    });
	}
	
	GeometryLayer.prototype = (0, _create2.default)(_three.EventDispatcher.prototype);
	GeometryLayer.prototype.constructor = GeometryLayer;
	
	GeometryLayer.prototype.attach = function attach(layer) {
	    if (!layer.update) {
	        throw new Error('Missing \'update\' function -> can\'t attach layer ' + layer.id);
	    }
	    this._attachedLayers.push(layer);
	};
	
	GeometryLayer.prototype.detach = function detach(layer) {
	    var count = this._attachedLayers.length;
	    this._attachedLayers = this._attachedLayers.filter(function (attached) {
	        return attached.id != layer.id;
	    });
	    return this._attachedLayers.length < count;
	};
	
	/**
	 * @class      Layer (name)
	 * Don't use directly constructor to instance a new Layer
	 * use addLayer in {@link View}
	 * @example
	 * // add and create a new Layer
	 * const newLayer = view.addLayer({options});
	 *
	 * // Change layer's visibilty
	 * const layerToChange = view.getLayers(layer => layer.id == 'idLayerToChange')[0];
	 * layerToChange.visible = false;
	 * view.notifyChange(0,true); // update viewer
	 *
	 * // Change layer's opacity
	 * const layerToChange = view.getLayers(layer => layer.id == 'idLayerToChange')[0];
	 * layerToChange.opacity = 0.5;
	 * view.notifyChange(0,true); // update viewer
	 *
	 * // Listen properties
	 * const layerToListen = view.getLayers(layer => layer.id == 'idLayerToListen')[0];
	 * layerToListen.addEventListener('visible-property-changed', (event) => console.log(event));
	 * layerToListen.addEventListener('opacity-property-changed', (event) => console.log(event));
	 * @protected
	 * @param      {String}  id
	 */
	function Layer(i) {
	    Object.defineProperty(this, 'id', {
	        value: i,
	        writable: false
	    });
	}
	
	Layer.prototype = (0, _create2.default)(_three.EventDispatcher.prototype);
	Layer.prototype.constructor = Layer;
	
	var ImageryLayers = {
	    moveLayerToIndex: function moveLayerToIndex(layer, newIndex, imageryLayers) {
	        var oldIndex = layer.sequence;
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = (0, _getIterator3.default)(imageryLayers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var imagery = _step.value;
	
	                if (imagery.sequence === newIndex) {
	                    imagery.sequence = oldIndex;
	                    layer.sequence = newIndex;
	                    break;
	                }
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	    },
	
	    moveLayerDown: function moveLayerDown(layer, imageryLayers) {
	        if (layer.sequence > 0) {
	            this.moveLayerToIndex(layer, layer.sequence - 1, imageryLayers);
	        }
	    },
	
	    moveLayerUp: function moveLayerUp(layer, imageryLayers) {
	        var m = imageryLayers.length - 1;
	        if (layer.sequence < m) {
	            this.moveLayerToIndex(layer, layer.sequence + 1, imageryLayers);
	        }
	    },
	
	    getColorLayersIdOrderedBySequence: function getColorLayersIdOrderedBySequence(imageryLayers) {
	        var copy = (0, _from2.default)(imageryLayers);
	        copy.sort(function (a, b) {
	            return a.sequence - b.sequence;
	        });
	        return copy.map(function (l) {
	            return l.id;
	        });
	    }
	};
	
	exports.GeometryLayer = GeometryLayer;
	exports.Layer = Layer;
	exports.ImageryLayers = ImageryLayers;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(267), __esModule: true };

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(268);
	var $Object = __webpack_require__(15).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(14);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(23), 'Object', {defineProperty: __webpack_require__(19).f});

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.CancelledCommandException = undefined;
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = __webpack_require__(270);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _jsPriorityQueue = __webpack_require__(281);
	
	var _jsPriorityQueue2 = _interopRequireDefault(_jsPriorityQueue);
	
	var _WMTS_Provider = __webpack_require__(282);
	
	var _WMTS_Provider2 = _interopRequireDefault(_WMTS_Provider);
	
	var _WMS_Provider = __webpack_require__(297);
	
	var _WMS_Provider2 = _interopRequireDefault(_WMS_Provider);
	
	var _TileProvider = __webpack_require__(298);
	
	var _TileProvider2 = _interopRequireDefault(_TileProvider);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Scheduler
	 * Description: Cette classe singleton gre les requetes/Commandes  de la scne. Ces commandes peuvent etre synchrone ou asynchrone. Elle permet d'executer, de prioriser  et d'annuler les commandes de la pile. Les commandes executes sont places dans une autre file d'attente.
	 */
	
	var instanceScheduler = null;
	
	function _instanciateQueue() {
	    return {
	        storage: new _jsPriorityQueue2.default({
	            comparator: function comparator(a, b) {
	                var cmp = b.priority - a.priority;
	                // Prioritize recent commands
	                if (cmp === 0) {
	                    return b.timestamp - a.timestamp;
	                }
	                return cmp;
	            }
	        }),
	        counters: {
	            // commands in progress
	            executing: 0,
	            // commands successfully executed
	            executed: 0,
	            // commands failed
	            failed: 0,
	            // commands cancelled
	            cancelled: 0
	        },
	        execute: function execute(cmd, provider, executingCounterUpToDate) {
	            var _this = this;
	
	            if (!executingCounterUpToDate) {
	                this.counters.executing++;
	            }
	
	            // If the provider returns a Promise, use it to handle counters
	            // Otherwise use a resolved Promise.
	            var p = provider.executeCommand(cmd) || _promise2.default.resolve();
	
	            return p.then(function (result) {
	                _this.counters.executing--;
	                cmd.resolve(result);
	                // only count successul commands
	                _this.counters.executed++;
	            }, function (err) {
	                _this.counters.executing--;
	                cmd.reject(err);
	                _this.counters.failed++;
	            });
	        }
	    };
	}
	
	function Scheduler() {
	    // Constructor
	    if (instanceScheduler !== null) {
	        throw new Error('Cannot instantiate more than one Scheduler');
	    }
	
	    this.defaultQueue = _instanciateQueue();
	    this.hostQueues = new _map2.default();
	
	    this.providers = {};
	
	    this.maxConcurrentCommands = 16;
	    this.maxCommandsPerHost = 6;
	
	    // TODO: add an options to not instanciate default providers
	    this.initDefaultProviders();
	}
	
	Scheduler.prototype.constructor = Scheduler;
	
	Scheduler.prototype.initDefaultProviders = function initDefaultProviders() {
	    // Register all providers
	    var wmtsProvider = new _WMTS_Provider2.default();
	    this.addProtocolProvider('wmts', wmtsProvider);
	    this.addProtocolProvider('wmtsc', wmtsProvider);
	    this.addProtocolProvider('tile', new _TileProvider2.default());
	    this.addProtocolProvider('wms', new _WMS_Provider2.default());
	};
	
	Scheduler.prototype.runCommand = function runCommand(command, queue, executingCounterUpToDate) {
	    var _this2 = this;
	
	    var provider = this.providers[command.layer.protocol];
	
	    if (!provider) {
	        throw new Error('No known provider for layer', command.layer.id);
	    }
	
	    queue.execute(command, provider, executingCounterUpToDate).then(function () {
	        // notify view that one command ended.
	        // We allow the view to delay the update/repaint up to 100ms
	        // to reduce CPU load (no need to perform an update on completion if we
	        // know there's another one ending soon)
	        command.view.notifyChange(100, 'redraw' in command ? command.redraw : true, command.requester);
	
	        // try to execute next command
	        if (queue.counters.executing < _this2.maxCommandsPerHost) {
	            var cmd = _this2.deQueue(queue);
	            if (cmd) {
	                return _this2.runCommand(cmd, queue);
	            }
	        }
	    });
	};
	
	Scheduler.prototype.execute = function execute(command) {
	    // TODO: check for mandatory commands fields
	
	
	    // parse host
	    var layer = command.layer;
	
	    var host = layer.url ? new URL(layer.url).host : undefined;
	
	    command.promise = new _promise2.default(function (resolve, reject) {
	        command.resolve = resolve;
	        command.reject = reject;
	    });
	
	    // init queue if needed
	    if (host && !this.hostQueues.has(host)) {
	        this.hostQueues.set(host, _instanciateQueue());
	    }
	
	    var q = host ? this.hostQueues.get(host) : this.defaultQueue;
	
	    // execute command now if possible
	    if (q.counters.executing < this.maxCommandsPerHost) {
	        // increment before
	        q.counters.executing++;
	
	        var runNow = function runNow() {
	            this.runCommand(command, q, true);
	        }.bind(this);
	
	        // We use a setTimeout to defer processing but we avoid the
	        // queue mechanism (why setTimeout and not Promise? see tasks vs microtasks priorities)
	        window.setTimeout(runNow, 0);
	    } else {
	        command.timestamp = Date.now();
	        q.storage.queue(command);
	    }
	
	    return command.promise;
	};
	
	Scheduler.prototype.addProtocolProvider = function addProtocolProvider(protocol, provider) {
	    this.providers[protocol] = provider;
	};
	
	Scheduler.prototype.getProtocolProvider = function getProtocolProvider(protocol) {
	    return this.providers[protocol];
	};
	
	Scheduler.prototype.commandsWaitingExecutionCount = function commandsWaitingExecutionCount() {
	    var sum = this.defaultQueue.storage.length + this.defaultQueue.counters.executing;
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(this.hostQueues), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var q = _step.value;
	
	            sum += q[1].storage.length + q[1].counters.executing;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return sum;
	};
	
	Scheduler.prototype.commandsRunningCount = function commandsRunningCount() {
	    var sum = this.defaultQueue.counters.executing;
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = (0, _getIterator3.default)(this.hostQueues), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var q = _step2.value;
	
	            sum += q[1].counters.executing;
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    return sum;
	};
	
	Scheduler.prototype.resetCommandsCount = function resetCommandsCount(type) {
	    var sum = this.defaultQueue.counters[type];
	    this.defaultQueue.counters[type] = 0;
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	        for (var _iterator3 = (0, _getIterator3.default)(this.hostQueues), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var q = _step3.value;
	
	            sum += q[1].counters[type];
	            q[1].counters[type] = 0;
	        }
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	
	    return sum;
	};
	
	Scheduler.prototype.getProviders = function getProviders() {
	    return this.providers.slice();
	};
	
	/**
	 * Custom error thrown when cancelling commands. Allows the caller to act differently if needed.
	 */
	function CancelledCommandException(command) {
	    this.command = command;
	}
	
	CancelledCommandException.prototype.toString = function toString() {
	    return 'Cancelled command ' + this.command.requester.id + '/' + this.command.layer.id;
	};
	
	/**
	 */
	Scheduler.prototype.deQueue = function deQueue(queue) {
	    var st = queue.storage;
	    while (st.length > 0) {
	        var cmd = st.dequeue();
	
	        if (cmd.earlyDropFunction && cmd.earlyDropFunction(cmd)) {
	            queue.counters.cancelled++;
	            cmd.reject(new CancelledCommandException(cmd));
	        } else {
	            return cmd;
	        }
	    }
	
	    return undefined;
	};
	
	exports.CancelledCommandException = CancelledCommandException;
	exports.default = Scheduler;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(271), __esModule: true };

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(244);
	__webpack_require__(54);
	__webpack_require__(30);
	__webpack_require__(272);
	__webpack_require__(273);
	module.exports = __webpack_require__(15).Map;

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(246);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(252)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(14);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(258)('Map')});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(275), __esModule: true };

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(244);
	__webpack_require__(54);
	__webpack_require__(30);
	__webpack_require__(276);
	module.exports = __webpack_require__(15).Promise;

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(39)
	  , global             = __webpack_require__(11)
	  , ctx                = __webpack_require__(16)
	  , classof            = __webpack_require__(58)
	  , $export            = __webpack_require__(14)
	  , isObject           = __webpack_require__(21)
	  , aFunction          = __webpack_require__(17)
	  , anInstance         = __webpack_require__(248)
	  , forOf              = __webpack_require__(249)
	  , speciesConstructor = __webpack_require__(277)
	  , task               = __webpack_require__(278).set
	  , microtask          = __webpack_require__(280)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(53)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(247)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(52)($Promise, PROMISE);
	__webpack_require__(250)(PROMISE);
	Wrapper = __webpack_require__(15)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(225)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(20)
	  , aFunction = __webpack_require__(17)
	  , SPECIES   = __webpack_require__(53)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(16)
	  , invoke             = __webpack_require__(279)
	  , html               = __webpack_require__(51)
	  , cel                = __webpack_require__(25)
	  , global             = __webpack_require__(11)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(37)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 279 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(11)
	  , macrotask = __webpack_require__(278).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(37)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 281 */
/***/ function(module, exports) {

	(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PriorityQueue = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	var AbstractPriorityQueue, ArrayStrategy, BHeapStrategy, BinaryHeapStrategy, PriorityQueue,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractPriorityQueue = _dereq_('./PriorityQueue/AbstractPriorityQueue');
	
	ArrayStrategy = _dereq_('./PriorityQueue/ArrayStrategy');
	
	BinaryHeapStrategy = _dereq_('./PriorityQueue/BinaryHeapStrategy');
	
	BHeapStrategy = _dereq_('./PriorityQueue/BHeapStrategy');
	
	PriorityQueue = (function(superClass) {
	  extend(PriorityQueue, superClass);
	
	  function PriorityQueue(options) {
	    options || (options = {});
	    options.strategy || (options.strategy = BinaryHeapStrategy);
	    options.comparator || (options.comparator = function(a, b) {
	      return (a || 0) - (b || 0);
	    });
	    PriorityQueue.__super__.constructor.call(this, options);
	  }
	
	  return PriorityQueue;
	
	})(AbstractPriorityQueue);
	
	PriorityQueue.ArrayStrategy = ArrayStrategy;
	
	PriorityQueue.BinaryHeapStrategy = BinaryHeapStrategy;
	
	PriorityQueue.BHeapStrategy = BHeapStrategy;
	
	module.exports = PriorityQueue;
	
	
	},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(_dereq_,module,exports){
	var AbstractPriorityQueue;
	
	module.exports = AbstractPriorityQueue = (function() {
	  function AbstractPriorityQueue(options) {
	    var ref;
	    if ((options != null ? options.strategy : void 0) == null) {
	      throw 'Must pass options.strategy, a strategy';
	    }
	    if ((options != null ? options.comparator : void 0) == null) {
	      throw 'Must pass options.comparator, a comparator';
	    }
	    this.priv = new options.strategy(options);
	    this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;
	  }
	
	  AbstractPriorityQueue.prototype.queue = function(value) {
	    this.length++;
	    this.priv.queue(value);
	    return void 0;
	  };
	
	  AbstractPriorityQueue.prototype.dequeue = function(value) {
	    if (!this.length) {
	      throw 'Empty queue';
	    }
	    this.length--;
	    return this.priv.dequeue();
	  };
	
	  AbstractPriorityQueue.prototype.peek = function(value) {
	    if (!this.length) {
	      throw 'Empty queue';
	    }
	    return this.priv.peek();
	  };
	
	  AbstractPriorityQueue.prototype.clear = function() {
	    this.length = 0;
	    return this.priv.clear();
	  };
	
	  return AbstractPriorityQueue;
	
	})();
	
	
	},{}],3:[function(_dereq_,module,exports){
	var ArrayStrategy, binarySearchForIndexReversed;
	
	binarySearchForIndexReversed = function(array, value, comparator) {
	  var high, low, mid;
	  low = 0;
	  high = array.length;
	  while (low < high) {
	    mid = (low + high) >>> 1;
	    if (comparator(array[mid], value) >= 0) {
	      low = mid + 1;
	    } else {
	      high = mid;
	    }
	  }
	  return low;
	};
	
	module.exports = ArrayStrategy = (function() {
	  function ArrayStrategy(options) {
	    var ref;
	    this.options = options;
	    this.comparator = this.options.comparator;
	    this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];
	    this.data.sort(this.comparator).reverse();
	  }
	
	  ArrayStrategy.prototype.queue = function(value) {
	    var pos;
	    pos = binarySearchForIndexReversed(this.data, value, this.comparator);
	    this.data.splice(pos, 0, value);
	    return void 0;
	  };
	
	  ArrayStrategy.prototype.dequeue = function() {
	    return this.data.pop();
	  };
	
	  ArrayStrategy.prototype.peek = function() {
	    return this.data[this.data.length - 1];
	  };
	
	  ArrayStrategy.prototype.clear = function() {
	    this.data.length = 0;
	    return void 0;
	  };
	
	  return ArrayStrategy;
	
	})();
	
	
	},{}],4:[function(_dereq_,module,exports){
	var BHeapStrategy;
	
	module.exports = BHeapStrategy = (function() {
	  function BHeapStrategy(options) {
	    var arr, i, j, k, len, ref, ref1, shift, value;
	    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
	      return a - b;
	    };
	    this.pageSize = (options != null ? options.pageSize : void 0) || 512;
	    this.length = 0;
	    shift = 0;
	    while ((1 << shift) < this.pageSize) {
	      shift += 1;
	    }
	    if (1 << shift !== this.pageSize) {
	      throw 'pageSize must be a power of two';
	    }
	    this._shift = shift;
	    this._emptyMemoryPageTemplate = arr = [];
	    for (i = j = 0, ref = this.pageSize; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      arr.push(null);
	    }
	    this._memory = [];
	    this._mask = this.pageSize - 1;
	    if (options.initialValues) {
	      ref1 = options.initialValues;
	      for (k = 0, len = ref1.length; k < len; k++) {
	        value = ref1[k];
	        this.queue(value);
	      }
	    }
	  }
	
	  BHeapStrategy.prototype.queue = function(value) {
	    this.length += 1;
	    this._write(this.length, value);
	    this._bubbleUp(this.length, value);
	    return void 0;
	  };
	
	  BHeapStrategy.prototype.dequeue = function() {
	    var ret, val;
	    ret = this._read(1);
	    val = this._read(this.length);
	    this.length -= 1;
	    if (this.length > 0) {
	      this._write(1, val);
	      this._bubbleDown(1, val);
	    }
	    return ret;
	  };
	
	  BHeapStrategy.prototype.peek = function() {
	    return this._read(1);
	  };
	
	  BHeapStrategy.prototype.clear = function() {
	    this.length = 0;
	    this._memory.length = 0;
	    return void 0;
	  };
	
	  BHeapStrategy.prototype._write = function(index, value) {
	    var page;
	    page = index >> this._shift;
	    while (page >= this._memory.length) {
	      this._memory.push(this._emptyMemoryPageTemplate.slice(0));
	    }
	    return this._memory[page][index & this._mask] = value;
	  };
	
	  BHeapStrategy.prototype._read = function(index) {
	    return this._memory[index >> this._shift][index & this._mask];
	  };
	
	  BHeapStrategy.prototype._bubbleUp = function(index, value) {
	    var compare, indexInPage, parentIndex, parentValue;
	    compare = this.comparator;
	    while (index > 1) {
	      indexInPage = index & this._mask;
	      if (index < this.pageSize || indexInPage > 3) {
	        parentIndex = (index & ~this._mask) | (indexInPage >> 1);
	      } else if (indexInPage < 2) {
	        parentIndex = (index - this.pageSize) >> this._shift;
	        parentIndex += parentIndex & ~(this._mask >> 1);
	        parentIndex |= this.pageSize >> 1;
	      } else {
	        parentIndex = index - 2;
	      }
	      parentValue = this._read(parentIndex);
	      if (compare(parentValue, value) < 0) {
	        break;
	      }
	      this._write(parentIndex, value);
	      this._write(index, parentValue);
	      index = parentIndex;
	    }
	    return void 0;
	  };
	
	  BHeapStrategy.prototype._bubbleDown = function(index, value) {
	    var childIndex1, childIndex2, childValue1, childValue2, compare;
	    compare = this.comparator;
	    while (index < this.length) {
	      if (index > this._mask && !(index & (this._mask - 1))) {
	        childIndex1 = childIndex2 = index + 2;
	      } else if (index & (this.pageSize >> 1)) {
	        childIndex1 = (index & ~this._mask) >> 1;
	        childIndex1 |= index & (this._mask >> 1);
	        childIndex1 = (childIndex1 + 1) << this._shift;
	        childIndex2 = childIndex1 + 1;
	      } else {
	        childIndex1 = index + (index & this._mask);
	        childIndex2 = childIndex1 + 1;
	      }
	      if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {
	        childValue1 = this._read(childIndex1);
	        childValue2 = this._read(childIndex2);
	        if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {
	          this._write(childIndex1, value);
	          this._write(index, childValue1);
	          index = childIndex1;
	        } else if (compare(childValue2, value) < 0) {
	          this._write(childIndex2, value);
	          this._write(index, childValue2);
	          index = childIndex2;
	        } else {
	          break;
	        }
	      } else if (childIndex1 <= this.length) {
	        childValue1 = this._read(childIndex1);
	        if (compare(childValue1, value) < 0) {
	          this._write(childIndex1, value);
	          this._write(index, childValue1);
	          index = childIndex1;
	        } else {
	          break;
	        }
	      } else {
	        break;
	      }
	    }
	    return void 0;
	  };
	
	  return BHeapStrategy;
	
	})();
	
	
	},{}],5:[function(_dereq_,module,exports){
	var BinaryHeapStrategy;
	
	module.exports = BinaryHeapStrategy = (function() {
	  function BinaryHeapStrategy(options) {
	    var ref;
	    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
	      return a - b;
	    };
	    this.length = 0;
	    this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];
	    this._heapify();
	  }
	
	  BinaryHeapStrategy.prototype._heapify = function() {
	    var i, j, ref;
	    if (this.data.length > 0) {
	      for (i = j = 1, ref = this.data.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
	        this._bubbleUp(i);
	      }
	    }
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype.queue = function(value) {
	    this.data.push(value);
	    this._bubbleUp(this.data.length - 1);
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype.dequeue = function() {
	    var last, ret;
	    ret = this.data[0];
	    last = this.data.pop();
	    if (this.data.length > 0) {
	      this.data[0] = last;
	      this._bubbleDown(0);
	    }
	    return ret;
	  };
	
	  BinaryHeapStrategy.prototype.peek = function() {
	    return this.data[0];
	  };
	
	  BinaryHeapStrategy.prototype.clear = function() {
	    this.length = 0;
	    this.data.length = 0;
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype._bubbleUp = function(pos) {
	    var parent, x;
	    while (pos > 0) {
	      parent = (pos - 1) >>> 1;
	      if (this.comparator(this.data[pos], this.data[parent]) < 0) {
	        x = this.data[parent];
	        this.data[parent] = this.data[pos];
	        this.data[pos] = x;
	        pos = parent;
	      } else {
	        break;
	      }
	    }
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype._bubbleDown = function(pos) {
	    var last, left, minIndex, right, x;
	    last = this.data.length - 1;
	    while (true) {
	      left = (pos << 1) + 1;
	      right = left + 1;
	      minIndex = pos;
	      if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {
	        minIndex = left;
	      }
	      if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {
	        minIndex = right;
	      }
	      if (minIndex !== pos) {
	        x = this.data[minIndex];
	        this.data[minIndex] = this.data[pos];
	        this.data[pos] = x;
	        pos = minIndex;
	      } else {
	        break;
	      }
	    }
	    return void 0;
	  };
	
	  return BinaryHeapStrategy;
	
	})();
	
	
	},{}]},{},[1])(1)
	});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _keys = __webpack_require__(283);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _OGCWebServiceHelper = __webpack_require__(286);
	
	var _OGCWebServiceHelper2 = _interopRequireDefault(_OGCWebServiceHelper);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: WMTS_Provider
	 * Description: Fournisseur de donnes  travers un flux WMTS
	 */
	
	function WMTS_Provider() {}
	
	WMTS_Provider.prototype.customUrl = function customUrl(layer, url, tilematrix, row, col) {
	    var urld = url.replace('%TILEMATRIX', tilematrix.toString());
	    urld = urld.replace('%ROW', row.toString());
	    urld = urld.replace('%COL', col.toString());
	
	    return urld;
	};
	
	WMTS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {
	    layer.fx = layer.fx || 0.0;
	    if (layer.protocol === 'wmtsc') {
	        layer.options.zoom = {
	            min: 2,
	            max: 20
	        };
	    } else {
	        var options = layer.options;
	        options.version = options.version || '1.0.0';
	        options.tileMatrixSet = options.tileMatrixSet || 'WGS84';
	        options.mimetype = options.mimetype || 'image/png';
	        options.style = options.style || 'normal';
	        options.projection = options.projection || 'EPSG:3857';
	        var newBaseUrl = layer.url + '?LAYER=' + options.name + '&FORMAT=' + options.mimetype + '&SERVICE=WMTS' + '&VERSION=1.0.0' + ('&REQUEST=GetTile&STYLE=normal&TILEMATRIXSET=' + options.tileMatrixSet);
	
	        newBaseUrl += '&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL';
	
	        if (!layer.options.zoom) {
	            var arrayLimits = (0, _keys2.default)(options.tileMatrixSetLimits);
	            var size = arrayLimits.length;
	            var maxZoom = Number(arrayLimits[size - 1]);
	            var minZoom = maxZoom - size + 1;
	
	            layer.options.zoom = {
	                min: minZoom,
	                max: maxZoom
	            };
	        }
	        layer.customUrl = newBaseUrl;
	    }
	};
	
	/**
	 * Return url wmts orthophoto
	 * @param {type} coWMTS
	 * @returns {Object@call;create.urlOrtho.url|String}
	 */
	WMTS_Provider.prototype.url = function url(coWMTS, layer) {
	    return this.customUrl(layer, layer.customUrl, coWMTS.zoom, coWMTS.row, coWMTS.col);
	};
	
	/**
	 * return texture float alpha THREE.js of MNT
	 * @param {type} coWMTS : coord WMTS
	 * @returns {WMTS_Provider_L15.WMTS_Provider.prototype@pro;_IoDriver@call;read@call;then}
	 */
	WMTS_Provider.prototype.getXbilTexture = function getXbilTexture(tile, layer, targetZoom) {
	    var pitch = new THREE.Vector3(0.0, 0.0, 1.0);
	    var coordWMTS = tile.getCoordsForLayer(layer)[0];
	
	    if (targetZoom && targetZoom !== coordWMTS.zoom) {
	        coordWMTS = _OGCWebServiceHelper2.default.WMTS_WGS84Parent(coordWMTS, targetZoom, pitch);
	    }
	
	    var url = this.url(coordWMTS, layer);
	
	    return _OGCWebServiceHelper2.default.getXBilTextureByUrl(url).then(function (result) {
	        var _OGCWebServiceHelper$ = _OGCWebServiceHelper2.default.ioDXBIL.computeMinMaxElevation(result.texture.image.data, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, pitch),
	            min = _OGCWebServiceHelper$.min,
	            max = _OGCWebServiceHelper$.max;
	
	        result.min = min === undefined ? 0 : min;
	        result.max = max === undefined ? 0 : max;
	        result.texture.coords = coordWMTS;
	        result.pitch = pitch;
	        return result;
	    });
	};
	
	/**
	 * Return texture RGBA THREE.js of orthophoto
	 * TODO : RGBA --> RGB remove alpha canal
	 * @param {type} coordWMTS
	 * @param {type} id
	 * @returns {WMTS_Provider_L15.WMTS_Provider.prototype@pro;ioDriverImage@call;read@call;then}
	 */
	WMTS_Provider.prototype.getColorTexture = function getColorTexture(coordWMTS, layer) {
	    var url = this.url(coordWMTS, layer);
	    return _OGCWebServiceHelper2.default.getColorTextureByUrl(url).then(function (texture) {
	        var result = {};
	        result.texture = texture;
	        result.texture.coords = coordWMTS;
	        result.pitch = new THREE.Vector3(0, 0, 1);
	
	        return result;
	    });
	};
	
	WMTS_Provider.prototype.executeCommand = function executeCommand(command) {
	    var layer = command.layer;
	    var tile = command.requester;
	
	    var supportedFormats = {
	        'image/png': this.getColorTextures.bind(this),
	        'image/jpg': this.getColorTextures.bind(this),
	        'image/jpeg': this.getColorTextures.bind(this),
	        'image/x-bil;bits=32': this.getXbilTexture.bind(this)
	    };
	
	    var func = supportedFormats[layer.options.mimetype];
	    if (func) {
	        return func(tile, layer, command.targetLevel);
	    } else {
	        return _promise2.default.reject(new Error('Unsupported mimetype ' + layer.options.mimetype));
	    }
	};
	
	WMTS_Provider.prototype.tileTextureCount = function tileTextureCount(tile, layer) {
	    var tileMatrixSet = layer.options.tileMatrixSet;
	    _OGCWebServiceHelper2.default.computeTileMatrixSetCoordinates(tile, tileMatrixSet);
	    return tile.getCoordsForLayer(layer).length;
	};
	
	WMTS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer, targetLevel) {
	    // This layer provides data starting at level = layer.options.zoom.min
	    // (the zoom.max property is used when building the url to make
	    //  sure we don't use invalid levels)
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(tile.getCoordsForLayer(layer)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var coord = _step.value;
	
	            if (layer.options.tileMatrixSetLimits) {
	                var c = coord;
	                // override
	                if (targetLevel < c.zoom) {
	                    c = _OGCWebServiceHelper2.default.WMTS_WGS84Parent(coord, targetLevel);
	                }
	
	                if (!(c.zoom in layer.options.tileMatrixSetLimits)) {
	                    return false;
	                }
	                if (c.row < layer.options.tileMatrixSetLimits[c.zoom].minTileRow || c.row > layer.options.tileMatrixSetLimits[c.zoom].maxTileRow || c.col < layer.options.tileMatrixSetLimits[c.zoom].minTileCol || c.col > layer.options.tileMatrixSetLimits[c.zoom].maxTileCol) {
	                    return false;
	                }
	            }
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return true;
	};
	
	WMTS_Provider.prototype.getColorTextures = function getColorTextures(tile, layer) {
	    if (tile.material === null) {
	        return _promise2.default.resolve();
	    }
	    var promises = [];
	    var bcoord = tile.getCoordsForLayer(layer);
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = (0, _getIterator3.default)(bcoord), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var coordWMTS = _step2.value;
	
	            promises.push(this.getColorTexture(coordWMTS, layer));
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    return _promise2.default.all(promises);
	};
	
	exports.default = WMTS_Provider;

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(284), __esModule: true };

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(285);
	module.exports = __webpack_require__(15).Object.keys;

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(5)
	  , $keys    = __webpack_require__(44);
	
	__webpack_require__(13)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.SIZE_TEXTURE_TILE = undefined;
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _map = __webpack_require__(270);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Fetcher = __webpack_require__(287);
	
	var _Fetcher2 = _interopRequireDefault(_Fetcher);
	
	var _CacheRessource = __webpack_require__(288);
	
	var _CacheRessource2 = _interopRequireDefault(_CacheRessource);
	
	var _IoDriver_XBIL = __webpack_require__(289);
	
	var _IoDriver_XBIL2 = _interopRequireDefault(_IoDriver_XBIL);
	
	var _Projection = __webpack_require__(291);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _Extent = __webpack_require__(296);
	
	var _Extent2 = _interopRequireDefault(_Extent);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SIZE_TEXTURE_TILE = exports.SIZE_TEXTURE_TILE = 256;
	
	// CacheRessource is necessary for neighboring PM textures
	// The PM textures overlap several tiles WGS84, it is to avoid net requests
	// Info : THREE.js have cache image https://github.com/mrdoob/three.js/blob/master/src/loaders/ImageLoader.js#L25
	var cache = (0, _CacheRessource2.default)();
	var cachePending = new _map2.default();
	var ioDXBIL = new _IoDriver_XBIL2.default();
	var projection = new _Projection2.default();
	
	var getTextureFloat = function getTextureFloat(buffer) {
	    var texture = new THREE.DataTexture(buffer, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, THREE.AlphaFormat, THREE.FloatType);
	    texture.needsUpdate = true;
	    return texture;
	};
	
	exports.default = {
	    ioDXBIL: ioDXBIL,
	    getColorTextureByUrl: function getColorTextureByUrl(url) {
	        var cachedTexture = cache.getRessource(url);
	
	        if (cachedTexture) {
	            return _promise2.default.resolve(cachedTexture);
	        }
	
	        var _Fetcher$texture = _Fetcher2.default.texture(url),
	            texture = _Fetcher$texture.texture,
	            promise = _Fetcher$texture.promise;
	
	        texture.generateMipmaps = false;
	        texture.magFilter = THREE.LinearFilter;
	        texture.minFilter = THREE.LinearFilter;
	        texture.anisotropy = 16;
	
	        return promise.then(function () {
	            if (!cache.getRessource(url)) {
	                cache.addRessource(url, texture);
	            }
	            return texture;
	        });
	    },
	    getXBilTextureByUrl: function getXBilTextureByUrl(url) {
	        var textureCache = cache.getRessource(url);
	
	        if (textureCache !== undefined) {
	            return _promise2.default.resolve({ texture: textureCache });
	        }
	
	        var promiseXBil = (cachePending.get(url) || ioDXBIL.read(url)).then(function (result) {
	            // TODO  RGBA is needed for navigator with no support in texture float
	            // In RGBA elevation texture LinearFilter give some errors with nodata value.
	            // need to rewrite sample function in shader
	
	            // loading concurrence
	            var textureConcurrence = cache.getRessource(url);
	            if (textureConcurrence) {
	                cachePending.delete(url);
	                return textureConcurrence;
	            }
	
	            result.texture = getTextureFloat(result.floatArray);
	            result.texture.generateMipmaps = false;
	            result.texture.magFilter = THREE.LinearFilter;
	            result.texture.minFilter = THREE.LinearFilter;
	            cache.addRessource(url, result.texture);
	            cachePending.delete(url);
	
	            return result;
	        });
	
	        cachePending.set(url, promiseXBil);
	
	        return promiseXBil;
	    },
	    computeTileMatrixSetCoordinates: function computeTileMatrixSetCoordinates(tile, tileMatrixSet) {
	        // Are WMTS coordinates ready?
	        if (!tile.wmtsCoords) {
	            tile.wmtsCoords = {};
	        }
	
	        tileMatrixSet = tileMatrixSet || 'WGS84G';
	        if (!(tileMatrixSet in tile.wmtsCoords)) {
	            var tileCoord = projection.WGS84toWMTS(tile.extent);
	
	            tile.wmtsCoords[tileMatrixSet] = projection.getCoordWMTS_WGS84(tileCoord, tile.extent, tileMatrixSet);
	        }
	    },
	    WMTS_WGS84Parent: function WMTS_WGS84Parent(cWMTS, levelParent, pitch) {
	        var diffLevel = cWMTS.zoom - levelParent;
	        var diff = Math.pow(2, diffLevel);
	        var invDiff = 1 / diff;
	
	        var r = (cWMTS.row - cWMTS.row % diff) * invDiff;
	        var c = (cWMTS.col - cWMTS.col % diff) * invDiff;
	
	        if (pitch) {
	            pitch.x = cWMTS.col * invDiff - c;
	            pitch.y = cWMTS.row * invDiff - r;
	            pitch.z = invDiff;
	        }
	
	        return new _Extent2.default(cWMTS.crs(), levelParent, r, c);
	    }
	};

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _three = __webpack_require__(226);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var textureLoader = new _three.TextureLoader();
	
	textureLoader.setCrossOrigin('anonymous');
	
	function checkResponse(response) {
	    if (response.status < 200 || response.status >= 300) {
	        var error = new Error('Error loading ' + response.url + ': status ' + response.status);
	        error.status = response.status;
	        throw error;
	    }
	}
	
	exports.default = {
	    json: function json(url) {
	        return fetch(url).then(function (response) {
	            checkResponse(response);
	            return response.json();
	        });
	    },
	    xml: function xml(url) {
	        return fetch(url).then(function (response) {
	            checkResponse(response);
	            return response.text();
	        }).then(function (text) {
	            return new window.DOMParser().parseFromString(text, 'text/xml');
	        });
	    },
	    texture: function texture(url) {
	        var res = void 0;
	        var rej = void 0;
	        var promise = new _promise2.default(function (resolve, reject) {
	            res = resolve;
	            rej = reject;
	        });
	
	        var texture = textureLoader.load(url, res, function () {}, rej);
	        return { texture: texture, promise: promise };
	    }
	};

/***/ },
/* 288 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function () {
	    instanceCache = instanceCache || new CacheRessource();
	    return instanceCache;
	};
	
	/**
	 * Generated On: 2015-10-5
	 * Class: CacheRessource
	 * Description: Cette classe singleton est un cache des ressources et services
	 */
	
	var instanceCache = null;
	
	function CacheRessource() {
	    // Constructor
	
	    this.cacheObjects = [];
	    this._maximumSize = null;
	}
	
	/**
	 * @param url
	 */
	CacheRessource.prototype.getRessource = function getRessource(url) {
	    return this.cacheObjects[url];
	};
	
	CacheRessource.prototype.addRessource = function addRessource(url, ressource) {
	    this.cacheObjects[url] = ressource;
	};
	
	/**
	 * @param id
	 */
	CacheRessource.prototype.getRessourceByID = function getRessourceByID() /* id*/{
	    // TODO: Implement Me
	
	};

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _IoDriver = __webpack_require__(290);
	
	var _IoDriver2 = _interopRequireDefault(_IoDriver);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var portableXBIL = function portableXBIL(buffer) {
	    this.floatArray = new Float32Array(buffer);
	    this.max = undefined;
	    this.min = undefined;
	    this.texture = null;
	}; /**
	    * Generated On: 2015-10-5
	    * Class: IoDriver_XBIL
	    */
	/* global Float32Array*/
	
	function IoDriver_XBIL() {
	    // Constructor
	    _IoDriver2.default.call(this);
	}
	
	IoDriver_XBIL.prototype = (0, _create2.default)(_IoDriver2.default.prototype);
	
	IoDriver_XBIL.prototype.constructor = IoDriver_XBIL;
	
	IoDriver_XBIL.prototype.computeMinMaxElevation = function computeMinMaxElevation(buffer, width, height, offsetScale) {
	    var min = 1000000;
	    var max = -1000000;
	
	    if (!buffer) {
	        return { min: undefined, max: undefined };
	    }
	
	    var sizeX = offsetScale ? Math.floor(offsetScale.z * width) : buffer.length;
	    var sizeY = offsetScale ? Math.floor(offsetScale.z * height) : 1;
	    var xs = offsetScale ? Math.floor(offsetScale.x * width) : 0;
	    var ys = offsetScale ? Math.floor(offsetScale.y * height) : 0;
	
	    var inc = offsetScale ? Math.max(Math.floor(sizeX / 8), 2) : 16;
	
	    for (var y = ys; y < ys + sizeY; y += inc) {
	        var pit = y * (width || 0);
	        for (var x = xs; x < xs + sizeX; x += inc) {
	            var val = buffer[pit + x];
	            if (val > -10.0 && val !== undefined) {
	                max = Math.max(max, val);
	                min = Math.min(min, val);
	            }
	        }
	    }
	
	    if (max === -1000000 || min === 1000000) {
	        return { min: undefined, max: undefined };
	    }
	    return { min: min, max: max };
	};
	
	IoDriver_XBIL.prototype.parseXBil = function parseXBil(buffer, url) {
	    if (!buffer) {
	        throw new Error('Error processing XBIL');
	    }
	
	    var result = new portableXBIL(buffer);
	
	    var elevation = this.computeMinMaxElevation(result.floatArray);
	
	    result.min = elevation.min;
	    result.max = elevation.max;
	
	    result.url = url;
	
	    return result;
	};
	
	IoDriver_XBIL.prototype.read = function read(url) {
	    var _this = this;
	
	    return fetch(url).then(function (response) {
	        if (response.status < 200 || response.status >= 300) {
	            throw new Error('Error loading ' + url + ': status ' + response.status);
	        }
	        return response.arrayBuffer();
	    }).then(function (buffer) {
	        return _this.parseXBil(buffer, url);
	    });
	};
	
	exports.default = IoDriver_XBIL;

/***/ },
/* 290 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: IoDriver
	 * Description: Cette classe gnrique parcourt un fichier et retourne un object.
	 */
	
	function IoDriver() {
	  // Constructor
	
	
	}
	
	IoDriver.prototype.constructor = IoDriver;
	
	/**
	 * @param url
	 */
	IoDriver.prototype.load = function load() /* url*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * @param url
	 * @param inputObject {Object}
	 */
	IoDriver.prototype.write = function write() /* url, inputObject*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * @param url
	 */
	IoDriver.prototype.readAsync = function readAsync() /* url*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * @param url
	 */
	IoDriver.prototype.writeAsync = function writeAsync() /* url*/{
	  // TODO: Implement Me
	
	};
	
	exports.default = IoDriver;

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _isInteger = __webpack_require__(292);
	
	var _isInteger2 = _interopRequireDefault(_isInteger);
	
	var _MathExtended = __webpack_require__(228);
	
	var _MathExtended2 = _interopRequireDefault(_MathExtended);
	
	var _Coordinates = __webpack_require__(217);
	
	var _Extent = __webpack_require__(296);
	
	var _Extent2 = _interopRequireDefault(_Extent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Projection() {
	    // Constructor
	
	} /**
	   * Generated On: 2015-10-5
	   * Class: Projection
	   * Description: Outils de projections cartographiques et de convertion
	   */
	
	
	Projection.prototype.WGS84ToY = function WGS84ToY(latitude) {
	    return 0.5 - Math.log(Math.tan(_MathExtended2.default.PI_OV_FOUR + latitude * 0.5)) * _MathExtended2.default.INV_TWO_PI;
	};
	
	Projection.prototype.YToWGS84 = function YToWGS84(y) {
	    return 2 * (Math.atan(Math.exp(-(y - 0.5) / _MathExtended2.default.INV_TWO_PI)) - _MathExtended2.default.PI_OV_FOUR);
	};
	
	Projection.prototype.WGS84ToOneSubY = function WGS84ToOneSubY(latitude) {
	    // TODO remove me
	    return 0.5 + Math.log(Math.tan(_MathExtended2.default.PI_OV_FOUR + latitude * 0.5)) * _MathExtended2.default.INV_TWO_PI;
	};
	
	Projection.prototype.WGS84LatitudeClamp = function WGS84LatitudeClamp(latitude) {
	    // var min = -68.1389  / 180 * Math.PI;
	    var min = -86 / 180 * Math.PI;
	    var max = 84 / 180 * Math.PI;
	
	    latitude = Math.max(min, latitude);
	    latitude = Math.min(max, latitude);
	
	    return latitude;
	};
	
	Projection.prototype.getCoordWMTS_WGS84 = function getCoordWMTS_WGS84(tileCoord, bbox, tileMatrixSet) {
	    // TODO: PM, WGS84G are hard-coded reference to IGN's TileMatrixSet
	    if (tileMatrixSet === 'PM') {
	        return this.WMTS_WGS84ToWMTS_PM(tileCoord, bbox);
	    } else if (tileMatrixSet === 'WGS84G') {
	        return [tileCoord];
	    } else {
	        throw new Error('Unsupported TileMatrixSet \'' + tileMatrixSet + '\'');
	    }
	};
	
	Projection.prototype.getAllCoordsWMTS = function getAllCoordsWMTS(tileCoord, bbox, tileMatrixSets) {
	    var tilesMT = [];
	
	    for (var key in tileMatrixSets) {
	        if (Object.prototype.hasOwnProperty.call(tileMatrixSets, key)) {
	            tilesMT[key] = this.getCoordsWMTS(tileCoord, bbox, key);
	        }
	    }
	
	    return tilesMT;
	};
	
	Projection.prototype.getCoordsWMTS = function getCoordsWMTS(tileCoord, bbox, tileMatrixSet) {
	    var box = this.getCoordWMTS_WGS84(tileCoord, bbox, tileMatrixSet);
	    var tilesMT = [];
	
	    for (var row = box[0].row; row < box[1].row + 1; row++) {
	        tilesMT.push(new _Extent2.default('WMTS:' + tileMatrixSet, box[0].zoom, row, box[0].col));
	    }
	
	    return tilesMT;
	};
	
	/**
	 *
	 * @param {type} cWMTS
	 * @param {type} bbox
	 * @returns {Array} coord WMTS array in pseudo mercator
	 */
	Projection.prototype.WMTS_WGS84ToWMTS_PM = function WMTS_WGS84ToWMTS_PM(cWMTS, bbox) {
	    var wmtsBox = [];
	    var level = cWMTS.zoom + 1;
	    var nbRow = Math.pow(2, level);
	
	    // var sY      = this.WGS84ToY(this.WGS84LatitudeClamp(-Math.PI*0.5)) - this.WGS84ToY(this.WGS84LatitudeClamp(Math.PI*0.5));
	    var sizeRow = 1.0 / nbRow;
	
	    var yMin = this.WGS84ToY(this.WGS84LatitudeClamp(bbox.north(_Coordinates.UNIT.RADIAN)));
	    var yMax = this.WGS84ToY(this.WGS84LatitudeClamp(bbox.south(_Coordinates.UNIT.RADIAN)));
	
	    var maxRow = void 0;
	
	    var min = yMin / sizeRow;
	    var max = yMax / sizeRow;
	
	    var minRow = Math.floor(min);
	    maxRow = Math.floor(max);
	
	    if ((0, _isInteger2.default)(max)) {
	        maxRow--;
	    }
	
	    var minCol = cWMTS.col;
	    var maxCol = minCol;
	
	    for (var r = maxRow; r >= minRow; r--) {
	        for (var c = minCol; c <= maxCol; c++) {
	            wmtsBox.push(new _Extent2.default('WMTS:PM', level, r, c));
	        }
	    }
	
	    return wmtsBox;
	};
	
	Projection.prototype.WGS84toWMTS = function WGS84toWMTS(bbox) {
	    var dim = bbox.dimensions(_Coordinates.UNIT.RADIAN);
	
	    var zoom = Math.floor(Math.log(_MathExtended2.default.PI / dim.y) / _MathExtended2.default.LOG_TWO + 0.5);
	
	    var nY = Math.pow(2, zoom);
	    var nX = 2 * nY;
	
	    var uX = _MathExtended2.default.TWO_PI / nX;
	    var uY = _MathExtended2.default.PI / nY;
	
	    var center = bbox.center();
	    var col = Math.floor((_MathExtended2.default.PI + center.longitude(_Coordinates.UNIT.RADIAN)) / uX);
	    var row = Math.floor(nY - (_MathExtended2.default.PI_OV_TWO + center.latitude(_Coordinates.UNIT.RADIAN)) / uY);
	
	    return new _Extent2.default('WMTS:WGS84G', zoom, row, col);
	};
	
	Projection.prototype.UnitaryToLongitudeWGS84 = function UnitaryToLongitudeWGS84(u, bbox) {
	    var dim = bbox.dimensions(_Coordinates.UNIT.RADIAN);
	    return bbox.west(_Coordinates.UNIT.RADIAN) + u * dim.x;
	};
	
	Projection.prototype.UnitaryToLatitudeWGS84 = function UnitaryToLatitudeWGS84(v, bbox) {
	    var dim = bbox.dimensions(_Coordinates.UNIT.RADIAN);
	    return bbox.south(_Coordinates.UNIT.RADIAN) + v * dim.y;
	};
	
	Projection.prototype.wgs84_to_lambert93 = function wgs84_to_lambert93(latitude, longitude) // , x93, y93)
	{
	    /*
	    rfrences :
	    Mthode de calcul pour une projection de type lambert conique conforme scante (
	    NTG_71.pdf):
	    http://www.ign.fr/affiche_rubrique.asp?rbr_id=1700&lng_id=FR
	    */
	
	    // variables:
	
	    // systme WGS84
	    var a = 6378137; // demi grand axe de l'ellipsoide (m)
	    var e = 0.08181919106; // premire excentricit de l'ellipsoide
	
	
	    var deg2rad = function deg2rad() {};
	
	    // paramtres de projections
	    // var l0 =deg2rad(3);
	    var lc = deg2rad(3); // longitude de rfrence
	    var phi0 = deg2rad(46.5); // latitude d'origine en radian
	    var phi1 = deg2rad(44); // 1er parallele automcoque
	    var phi2 = deg2rad(49); // 2eme parallele automcoque
	
	    var x0 = 700000; // coordonnes l'origine
	    var y0 = 6600000; // coordonnes l'origine
	
	    // coordonnes du point traduire
	    var phi = deg2rad(latitude);
	    var l = deg2rad(longitude);
	
	    // calcul des grandes normales
	    var gN1 = a / Math.sqrt(1 - e * e * Math.sin(phi1) * Math.sin(phi1));
	    var gN2 = a / Math.sqrt(1 - e * e * Math.sin(phi2) * Math.sin(phi2));
	
	    // calculs de slatitudes isomtriques
	    var gl1 = Math.log(Math.tan(Math.PI / 4 + phi1 / 2) * Math.pow((1 - e * Math.sin(phi1)) / (1 + e * Math.sin(phi1)), e / 2));
	
	    var gl2 = Math.log(Math.tan(Math.PI / 4 + phi2 / 2) * Math.pow((1 - e * Math.sin(phi2)) / (1 + e * Math.sin(phi2)), e / 2));
	
	    var gl0 = Math.log(Math.tan(Math.PI / 4 + phi0 / 2) * Math.pow((1 - e * Math.sin(phi0)) / (1 + e * Math.sin(phi0)), e / 2));
	
	    var gl = Math.log(Math.tan(Math.PI / 4 + phi / 2) * Math.pow((1 - e * Math.sin(phi)) / (1 + e * Math.sin(phi)), e / 2));
	
	    // calcul de l'exposant de la projection
	    var n = Math.log(gN2 * Math.cos(phi2) / (gN1 * Math.cos(phi1))) / (gl1 - gl2); // ok
	
	    // calcul de la constante de projection
	    var c = gN1 * Math.cos(phi1) / n * Math.exp(n * gl1); // ok
	
	    // calcul des coordonnes
	    var ys = y0 + c * Math.exp(-1 * n * gl0);
	
	    // calcul des coordonnes lambert
	    var x93 = x0 + c * Math.exp(-1 * n * gl) * Math.sin(n * (l - lc));
	    var y93 = ys - c * Math.exp(-1 * n * gl) * Math.cos(n * (l - lc));
	
	    return {
	        x: x93,
	        y: y93
	    };
	};
	
	exports.default = Projection;

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(293), __esModule: true };

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(294);
	module.exports = __webpack_require__(15).Number.isInteger;

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(14);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(295)});

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(21)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _toConsumableArray2 = __webpack_require__(218);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _defineProperty = __webpack_require__(266);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Coordinates = __webpack_require__(217);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Extent is a SIG-area (so 2D)
	 * It can use explicit coordinates (e.g: lon/lat) or implicit (WMTS coordinates)
	 */
	
	function _crsIsWMTS(crs) {
	    return crs.indexOf('WMTS:') == 0;
	}
	
	function Extent(crs) {
	    var _this = this;
	
	    this._crs = crs;
	
	    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        values[_key - 1] = arguments[_key];
	    }
	
	    if (_crsIsWMTS(crs)) {
	        if (values.length == 3) {
	            this._zoom = values[0];
	            this._row = values[1];
	            this._col = values[2];
	
	            if (this._zoom < 0) {
	                throw new Error('invlid WTMS values ' + values);
	            }
	
	            (0, _defineProperty2.default)(this, 'zoom', { get: function get() {
	                    return _this._zoom;
	                } }, { set: function set(z) {
	                    _this._zoom = z;
	                } });
	            (0, _defineProperty2.default)(this, 'row', { get: function get() {
	                    return _this._row;
	                } }, { set: function set(r) {
	                    _this._row = r;
	                } });
	            (0, _defineProperty2.default)(this, 'col', { get: function get() {
	                    return _this._col;
	                } }, { set: function set(c) {
	                    _this._col = c;
	                } });
	        } else {
	            throw new Error('Unsupported constructor args \'' + values + '\'');
	        }
	    } else {
	        this._internalStorageUnit = (0, _Coordinates.crsToUnit)(crs);
	
	        if (values.length === 2 && values[0] instanceof _Coordinates2.default && values[1] instanceof _Coordinates2.default) {
	            this._values = new Float64Array(4);
	            for (var i = 0; i < values.length; i++) {
	                for (var j = 0; j < 2; j++) {
	                    this._values[2 * i + j] = values[i][j];
	                }
	            }
	        } else if (values.length == 1 && values[0].west != undefined) {
	            this._values = new Float64Array(4);
	            this._values[0] = values[0].west;
	            this._values[1] = values[0].east;
	            this._values[2] = values[0].south;
	            this._values[3] = values[0].north;
	        } else if (values.length == 4) {
	            this._values = new Float64Array(4);
	            for (var _i = 0; _i < 4; _i++) {
	                this._values[_i] = values[_i];
	            }
	        } else {
	            throw new Error('Unsupported constructor args \'' + values + '\'');
	        }
	    }
	}
	
	Extent.prototype.clone = function clone() {
	    if (_crsIsWMTS(this._crs)) {
	        return new Extent(this._crs, this.zoom, this.row, this.col);
	    } else {
	        var result = Extent.apply(undefined, [this._crs].concat((0, _toConsumableArray3.default)(this._values)));
	        result._internalStorageUnit = this._internalStorageUnit;
	        return result;
	    }
	};
	
	Extent.prototype.as = function as(crs) {
	    (0, _Coordinates.assertCrsIsValid)(crs);
	    if (this._crs != crs) {
	        throw new Error('Unsupported yet');
	    }
	    if (_crsIsWMTS(this._crs)) {
	        throw new Error('Unsupported yet');
	    }
	
	    return new Extent(crs, {
	        west: this.west((0, _Coordinates.crsToUnit)(crs)),
	        east: this.east((0, _Coordinates.crsToUnit)(crs)),
	        north: this.north((0, _Coordinates.crsToUnit)(crs)),
	        south: this.south((0, _Coordinates.crsToUnit)(crs))
	    });
	};
	
	Extent.prototype.offsetToParent = function offsetToParent(other) {
	    if (this.crs() != other.crs()) {
	        throw new Error('unsupported mix');
	    }
	    if (_crsIsWMTS(this.crs())) {
	        var diffLevel = this._zoom - other.zoom;
	        var diff = Math.pow(2, diffLevel);
	        var invDiff = 1 / diff;
	
	        var r = (this._row - this._row % diff) * invDiff;
	        var c = (this._col - this._col % diff) * invDiff;
	
	        return new THREE.Vector3(this._col * invDiff - c, this._row * invDiff - r, invDiff);
	    }
	
	    var dimension = {
	        x: Math.abs(other.east() - other.west()),
	        y: Math.abs(other.north() - other.south())
	    };
	
	    var originX = (this.west(other._internalStorageUnit) - other.west()) / dimension.x;
	    var originY = (other.north() - this.north(other._internalStorageUnit)) / dimension.y;
	
	    var scale = Math.abs(this.east(other._internalStorageUnit) - this.west(other._internalStorageUnit)) / dimension.x;
	    return new THREE.Vector3(originX, originY, scale);
	};
	
	Extent.prototype.west = function west(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return (0, _Coordinates.convertValueToUnit)(this._internalStorageUnit, unit, this._values[0]);
	    } else {
	        return this._values[0];
	    }
	};
	
	Extent.prototype.east = function east(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return (0, _Coordinates.convertValueToUnit)(this._internalStorageUnit, unit, this._values[1]);
	    } else {
	        return this._values[1];
	    }
	};
	
	Extent.prototype.north = function north(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return (0, _Coordinates.convertValueToUnit)(this._internalStorageUnit, unit, this._values[3]);
	    } else {
	        return this._values[3];
	    }
	};
	
	Extent.prototype.south = function south(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return (0, _Coordinates.convertValueToUnit)(this._internalStorageUnit, unit, this._values[2]);
	    } else {
	        return this._values[2];
	    }
	};
	
	Extent.prototype.crs = function crs() {
	    return this._crs;
	};
	
	Extent.prototype.center = function center() {
	    if (_crsIsWMTS(this._crs)) {
	        throw new Error('Invalid operation for WMTS bbox');
	    }
	    var c = new _Coordinates2.default(this._crs, this._values[0], this._values[2]);
	    c._internalStorageUnit = this._internalStorageUnit;
	    var dim = this.dimensions();
	    c._values[0] += dim.x * 0.5;
	    c._values[1] += dim.y * 0.5;
	    return c;
	};
	
	Extent.prototype.dimensions = function dimensions(unit) {
	    return {
	        x: Math.abs(this.east(unit) - this.west(unit)),
	        y: Math.abs(this.north(unit) - this.south(unit))
	    };
	};
	
	/**
	 * @documentation: Retourne True if point is inside the bounding box
	 *
	 * @param point {[object Object]}
	 */
	Extent.prototype.isInside = function isInside(coord) {
	    var c = this.crs() == coord.crs ? coord : coord.as(this.crs());
	
	    // TODO this ignores altitude
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return c.longitude(this._internalStorageUnit) <= this.east() && c.longitude(this._internalStorageUnit) >= this.west() && c.latitude(this._internalStorageUnit) <= this.north() && c.latitude(this._internalStorageUnit) >= this.south();
	    } else {
	        return c.x() <= this.east() && c.x() >= this.west() && c.y() <= this.north() && c.y() >= this.south();
	    }
	};
	
	Extent.prototype.isInside = function isInside(other, epsilon) {
	    if (_crsIsWMTS(this.crs())) {
	        if (this._zoom == other._zoom) {
	            return this._row == other._row && this._col == other._col;
	        } else if (this._zoom < other._zoom) {
	            return false;
	        } else {
	            var diffLevel = this._zoom - other._zoom;
	            var diff = Math.pow(2, diffLevel);
	            var invDiff = 1 / diff;
	
	            var r = (this._row - this._row % diff) * invDiff;
	            var c = (this._col - this._col % diff) * invDiff;
	            return r == other._row && c == other._col;
	        }
	    } else {
	        var o = other.as(this._crs);
	        epsilon = epsilon == undefined ? (0, _Coordinates.reasonnableEpsilonForUnit)(o._internalStorageUnit) : epsilon;
	        // compare use crs' default storage unit
	        return this.east(o._internalStorageUnit) - o.east() <= epsilon && o.west() - this.west(o._internalStorageUnit) <= epsilon && this.north(o._internalStorageUnit) - o.north() <= epsilon && o.south() - this.south(o._internalStorageUnit) <= epsilon;
	    }
	};
	
	Extent.prototype.offsetScale = function offsetScale(bbox) {
	    if (bbox.crs() != this.crs()) {
	        throw new Error('unsupported offscale between 2 diff crs');
	    }
	
	    var dimension = {
	        x: Math.abs(this.east() - this.west()),
	        y: Math.abs(this.north() - this.south())
	    };
	
	    var originX = (bbox.west(this._internalStorageUnit) - this.west()) / dimension.x;
	    var originY = (bbox.north(this._internalStorageUnit) - this.north()) / dimension.y;
	
	    var scale = Math.abs(bbox.east(this._internalStorageUnit) - bbox.west(this._internalStorageUnit)) / dimension.x;
	    return new THREE.Vector3(originX, originY, scale);
	};
	
	/**
	 * @documentation: Return true if this bounding box intersect with the bouding box parameter
	 * @param {type} bbox
	 * @returns {Boolean}
	 */
	Extent.prototype.intersect = function intersect(bbox) {
	    var other = bbox.as(this.crs());
	    return !(this.west() >= other.east(this._internalStorageUnit) || this.east() <= other.west(this._internalStorageUnit) || this.south() >= other.north(this._internalStorageUnit) || this.north() <= other.south(this._internalStorageUnit));
	};
	
	exports.default = Extent;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Extent = __webpack_require__(296);
	
	var _Extent2 = _interopRequireDefault(_Extent);
	
	var _OGCWebServiceHelper = __webpack_require__(286);
	
	var _OGCWebServiceHelper2 = _interopRequireDefault(_OGCWebServiceHelper);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Return url wmts MNT
	 * @param {String} options.url: service base url
	 * @param {String} options.layer: requested data layer
	 * @param {String} options.format: image format (default: format/jpeg)
	 * @returns {Object@call;create.url.url|String}
	 */
	function WMS_Provider() {} /**
	                            * Generated On: 2015-10-5
	                            * Class: WMS_Provider
	                            * Description: Provides data from a WMS stream
	                            */
	
	WMS_Provider.prototype.url = function url(bbox, layer) {
	    var box = bbox.as(layer.projection);
	    var v = [box.west(), box.south(), box.east(), box.north()];
	    var bboxInUnit = layer.bbox_url === 'swne' ? v[1] + ',' + v[0] + ',' + v[3] + ',' + v[2] : v[0] + ',' + v[1] + ',' + v[2] + ',' + v[3];
	
	    return layer.customUrl.replace('%bbox', bboxInUnit);
	};
	
	WMS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {
	    if (!layer.name) {
	        throw new Error('layerName is required.');
	    }
	    if (!layer.bbox) {
	        throw new Error('bbox is required');
	    }
	    if (!layer.projection) {
	        throw new Error('projection is required');
	    }
	
	    layer.extent = new _Extent2.default(layer.projection, layer.bbox[0], layer.bbox[1], layer.bbox[2], layer.bbox[3]);
	
	    layer.bbox_url = layer.bbox_url || 'swne';
	    layer.format = layer.options.mimetype || 'image/png';
	    layer.width = layer.heightMapWidth || 256;
	    layer.version = layer.version || '1.3.0';
	    layer.style = layer.style || '';
	    layer.transparent = layer.transparent || false;
	
	    layer.customUrl = layer.url + '?SERVICE=WMS&REQUEST=GetMap&LAYERS=' + layer.name + '&VERSION=' + layer.version + '&STYLES=' + layer.style + '&FORMAT=' + layer.format + '&TRANSPARENT=' + layer.transparent + '&BBOX=%bbox' + ('&CRS=' + layer.projection + '&WIDTH=' + layer.width + '&HEIGHT=' + layer.width);
	};
	
	WMS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer) {
	    return layer.extent.intersect(tile.extent);
	};
	
	WMS_Provider.prototype.getColorTexture = function getColorTexture(tile, layer) {
	    if (!this.tileInsideLimit(tile, layer)) {
	        return _promise2.default.reject('Tile \'' + tile + '\' is outside layer bbox ' + layer.extent);
	    }
	    if (tile.material === null) {
	        return _promise2.default.resolve();
	    }
	
	    var coords = tile.extent.as(layer.projection);
	    var url = this.url(coords, layer);
	    var pitch = new THREE.Vector3(0, 0, 1);
	    var result = { pitch: pitch };
	
	    return _OGCWebServiceHelper2.default.getColorTextureByUrl(url).then(function (texture) {
	        result.texture = texture;
	        result.texture.extent = tile.extent; // useless?
	        result.texture.coords = coords;
	        // LayeredMaterial expects coords.zoom to exist, and describe the
	        // precision of the texture (a la WMTS).
	        result.texture.coords.zoom = tile.level;
	        return result;
	    });
	};
	
	WMS_Provider.prototype.getXbilTexture = function getXbilTexture(tile, layer) {
	    var url = this.url(tile.extent.as(layer.projection), layer);
	    return this.getXBilTextureByUrl(url, new THREE.Vector3(0, 0, 1));
	};
	
	WMS_Provider.prototype.executeCommand = function executeCommand(command) {
	    var tile = command.requester;
	
	    var layer = command.layer;
	    var supportedFormats = {
	        'image/png': this.getColorTexture.bind(this),
	        'image/jpg': this.getColorTexture.bind(this),
	        'image/jpeg': this.getColorTexture.bind(this),
	        'image/x-bil;bits=32': this.getXbilTexture.bind(this)
	    };
	
	    var func = supportedFormats[layer.format];
	
	    if (func) {
	        return func(tile, layer);
	    } else {
	        return _promise2.default.reject(new Error('Unsupported mimetype ' + layer.format));
	    }
	};
	
	exports.default = WMS_Provider;

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _Provider = __webpack_require__(299);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _TileGeometry = __webpack_require__(300);
	
	var _TileGeometry2 = _interopRequireDefault(_TileGeometry);
	
	var _TileMesh = __webpack_require__(301);
	
	var _TileMesh2 = _interopRequireDefault(_TileMesh);
	
	var _Scheduler = __webpack_require__(269);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	/*
	 * A Faire
	 * Les tuiles de longitude identique ont le maillage et ne demande pas 1 seule calcul pour la gnration du maillage
	 *
	 *
	 *
	 *
	 */
	
	function TileProvider() {
	    _Provider2.default.call(this, null);
	}
	
	TileProvider.prototype = (0, _create2.default)(_Provider2.default.prototype);
	
	TileProvider.prototype.constructor = TileProvider;
	
	TileProvider.prototype.executeCommand = function executeCommand(command) {
	    var extent = command.extent;
	    if (command.requester && !command.requester.material) {
	        // request has been deleted
	        return _promise2.default.reject(new _Scheduler.CancelledCommandException(command));
	    }
	
	    var parent = command.requester;
	
	    // build tile
	    var params = {
	        extent: extent,
	        level: command.level === undefined ? parent.level + 1 : command.level,
	        segment: 16,
	        materialOptions: command.layer.materialOptions,
	        disableSkirt: command.layer.disableSkirt
	    };
	
	    var geometry = new _TileGeometry2.default(params, command.layer.builder);
	
	    var tile = new _TileMesh2.default(geometry, params);
	
	    tile.layer = command.layer.id;
	    tile.layers.set(command.threejsLayer);
	    tile.setUuid();
	
	    if (parent) {
	        parent.worldToLocal(params.center);
	    }
	
	    tile.position.copy(params.center);
	    tile.setVisibility(false);
	    tile.updateMatrix();
	    if (parent) {
	        tile.setBBoxZ(parent.OBB().z.min, parent.OBB().z.max);
	    } else if (command.layer.materialOptions && command.layer.materialOptions.useColorTextureElevation) {
	        tile.setBBoxZ(command.layer.materialOptions.colorTextureElevationMinZ, command.layer.materialOptions.colorTextureElevationMaxZ);
	    }
	
	    return _promise2.default.resolve(tile);
	};
	
	exports.default = TileProvider;

/***/ },
/* 299 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: Provider
	 * Description: Generic class to serve data, local or distant, nodes and services.
	 */
	
	function Provider(iodriver) {
	  // Constructor
	
	  this.type = null;
	  this._IoDriver = iodriver;
	}
	
	Provider.prototype.constructor = Provider;
	
	/**
	 * @param url
	 */
	Provider.prototype.get = function get() /* url*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * preprocessLayer will be called each time a layer is added.
	 * Allows the Provider to perform precomputations on the layer
	 */
	Provider.prototype.preprocessLayer = function preprocessLayer() /* layer*/{};
	
	/**
	 * @param url
	 */
	Provider.prototype.getInCache = function getInCache() /* url*/{
	  // TODO: Implement Me
	
	};
	
	exports.default = Provider;

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _CacheRessource = __webpack_require__(288);
	
	var _CacheRessource2 = _interopRequireDefault(_CacheRessource);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// TODO Why? it's not necessary
	
	/* global  Uint32Array */
	
	/**
	 * Generated On: 2015-10-5
	 * Class: TileGeometry
	 * Description: Tuile gomtrique. Buffer des vertex et des faces
	 */
	/* global Float32Array*/
	var cache = (0, _CacheRessource2.default)(); // TODO /!\ singleton
	
	
	function Buffers() {
	    this.index = null;
	    this.position = null;
	    this.normal = null;
	    // 2 UV set per tile: wgs84 and pm
	    //    - wgs84: 1 texture per tile because tiles are using wgs84 projection
	    //    - pm: use multiple textures per tile.
	    //      +-------------------------+
	    //      |                         |
	    //      |     Texture 0           |
	    //      +-------------------------+
	    //      |                         |
	    //      |     Texture 1           |
	    //      +-------------------------+
	    //      |                         |
	    //      |     Texture 2           |
	    //      +-------------------------+
	    //        * u = wgs84.u
	    //        * v = textureid + v in this texture
	    this.uv = {
	        wgs84: null,
	        pm: null
	    };
	}
	
	function TileGeometry(params, builder) {
	    // Constructor
	    THREE.BufferGeometry.call(this);
	
	    this.center = builder.Center(params);
	    this.OBB = builder.OBB(params);
	
	    // TODO : free array
	
	    var bufferAttribs = this.computeBuffers(params, builder);
	
	    this.setIndex(bufferAttribs.index);
	    this.addAttribute('position', bufferAttribs.position);
	    this.addAttribute('normal', bufferAttribs.normal);
	    this.addAttribute('uv_wgs84', bufferAttribs.uv.wgs84);
	    this.addAttribute('uv_pm', bufferAttribs.uv.pm);
	
	    bufferAttribs.position = null;
	    bufferAttribs.normal = null;
	    bufferAttribs.uv.pm = null;
	
	    // Update cache
	    if (!cache.getRessource(params.segment)) {
	        cache.addRessource(params.segment, bufferAttribs);
	    }
	
	    // ---> for SSE
	    this.computeBoundingSphere();
	}
	
	TileGeometry.prototype = (0, _create2.default)(THREE.BufferGeometry.prototype);
	
	TileGeometry.prototype.constructor = TileGeometry;
	
	TileGeometry.prototype.computeBuffers = function computeBuffers(params, builder) {
	    // Create output buffers.
	    var outBuffers = new Buffers();
	    // Create temp buffers
	    var scratchBuffers = new Buffers();
	
	    var nSeg = params.segment || 32;
	    // segments count :
	    // Tile : (nSeg + 1) * (nSeg + 1)
	    // Skirt : 8 * (nSeg - 1)
	    var nVertex = (nSeg + 1) * (nSeg + 1) + 8 * (nSeg - 1); // correct pour uniquement les vertex
	    var triangles = nSeg * nSeg + 16 * (nSeg - 1); // correct pour uniquement les vertex
	
	    scratchBuffers.position = new Float32Array(nVertex * 3);
	    scratchBuffers.normal = new Float32Array(nVertex * 3);
	    scratchBuffers.uv.pm = new Float32Array(nVertex);
	
	    // Read previously cached values
	    var cachedBuffers = cache.getRessource(params.segment);
	    if (cachedBuffers) {
	        outBuffers.index = cachedBuffers.index;
	        outBuffers.uv.wgs84 = cachedBuffers.uv.wgs84;
	    } else {
	        scratchBuffers.index = new Uint32Array(triangles * 3 * 2);
	        scratchBuffers.uv.wgs84 = new Float32Array(nVertex * 2);
	    }
	
	    var widthSegments = Math.max(2, Math.floor(nSeg) || 2);
	    var heightSegments = Math.max(2, Math.floor(nSeg) || 2);
	
	    var idVertex = 0;
	    var x = void 0;
	    var y = void 0;
	    var vertices = [];
	    var skirt = [];
	    var skirtEnd = [];
	    var u = void 0;
	    var v = void 0;
	
	    builder.Prepare(params);
	
	    var UV_WGS84 = function UV_WGS84() {};
	    var UV_PM = function UV_PM() {};
	
	    // Define UV computation functions if needed
	    if (outBuffers.uv.wgs84 === null) {
	        UV_WGS84 = function UV_WGS84(out, id, u, v) {
	            out.uv.wgs84[id * 2 + 0] = u;
	            out.uv.wgs84[id * 2 + 1] = v;
	        };
	    }
	    if (outBuffers.uv.pm === null && builder.getUV_PM) {
	        UV_PM = function UV_PM(out, id, u) {
	            out.uv.pm[id] = u;
	        };
	    }
	
	    var id_m3 = void 0;
	    var v1 = void 0;
	    var v2 = void 0;
	    var v3 = void 0;
	    var v4 = void 0;
	
	    for (y = 0; y <= heightSegments; y++) {
	        var verticesRow = [];
	
	        v = y / heightSegments;
	
	        builder.vProjecte(v, params);
	
	        var uv_pm = builder.getUV_PM ? builder.getUV_PM(params) : undefined;
	
	        for (x = 0; x <= widthSegments; x++) {
	            u = x / widthSegments;
	
	            builder.uProjecte(u, params);
	
	            var vertex = builder.VertexPosition(params, params.projected);
	
	            id_m3 = idVertex * 3;
	
	            scratchBuffers.position[id_m3 + 0] = vertex.x() - this.center.x;
	            scratchBuffers.position[id_m3 + 1] = vertex.y() - this.center.y;
	            scratchBuffers.position[id_m3 + 2] = vertex.z() - this.center.z;
	
	            var normal = builder.VertexNormal(params);
	
	            scratchBuffers.normal[id_m3 + 0] = normal.x;
	            scratchBuffers.normal[id_m3 + 1] = normal.y;
	            scratchBuffers.normal[id_m3 + 2] = normal.z;
	
	            UV_WGS84(scratchBuffers, idVertex, u, v);
	            UV_PM(scratchBuffers, idVertex, uv_pm);
	
	            if (!params.disableSkirt) {
	                if (y !== 0 && y !== heightSegments) {
	                    if (x === widthSegments) {
	                        skirt.push(idVertex);
	                    } else if (x === 0) {
	                        skirtEnd.push(idVertex);
	                    }
	                }
	            }
	
	            verticesRow.push(idVertex);
	
	            idVertex++;
	        }
	
	        vertices.push(verticesRow);
	
	        if (y === 0) {
	            skirt = skirt.concat(verticesRow);
	        } else if (y === heightSegments) {
	            skirt = skirt.concat(verticesRow.slice().reverse());
	        }
	    }
	
	    if (!params.disableSkirt) {
	        skirt = skirt.concat(skirtEnd.reverse());
	    }
	
	    function bufferize(va, vb, vc, idVertex) {
	        scratchBuffers.index[idVertex + 0] = va;
	        scratchBuffers.index[idVertex + 1] = vb;
	        scratchBuffers.index[idVertex + 2] = vc;
	        return idVertex + 3;
	    }
	
	    var idVertex2 = 0;
	
	    if (outBuffers.index === null) {
	        for (y = 0; y < heightSegments; y++) {
	            for (x = 0; x < widthSegments; x++) {
	                v1 = vertices[y][x + 1];
	                v2 = vertices[y][x];
	                v3 = vertices[y + 1][x];
	                v4 = vertices[y + 1][x + 1];
	
	                idVertex2 = bufferize(v4, v2, v1, idVertex2);
	                idVertex2 = bufferize(v4, v3, v2, idVertex2);
	            }
	        }
	    }
	
	    var iStart = idVertex;
	
	    // TODO: WARNING beware skirt's size influences performance
	    // Fix Me: Compute correct the skirt's size : minimize the size without crack between tiles
	    // This size must be take into account the bbox's size
	    // For the moment, I reduce the size to increase performance (pixel shader performance)
	
	    if (!params.disableSkirt) {
	        var r = 5 * (20 - params.level + 10);
	
	        var buildIndexSkirt = function buildIndexSkirt() {};
	        var buildUVSkirt = function buildUVSkirt() {};
	
	        if (outBuffers.index === null) {
	            buildIndexSkirt = function buildIndexSkirt(id, v1, v2, v3, v4) {
	                id = bufferize(v1, v2, v3, id);
	                id = bufferize(v1, v3, v4, id);
	                return id;
	            };
	
	            buildUVSkirt = function buildUVSkirt(id) {
	                scratchBuffers.uv.wgs84[idVertex * 2 + 0] = scratchBuffers.uv.wgs84[id * 2 + 0];
	                scratchBuffers.uv.wgs84[idVertex * 2 + 1] = scratchBuffers.uv.wgs84[id * 2 + 1];
	            };
	        }
	
	        for (var i = 0; i < skirt.length; i++) {
	            var id = skirt[i];
	            id_m3 = idVertex * 3;
	            var id2_m3 = id * 3;
	
	            scratchBuffers.position[id_m3 + 0] = scratchBuffers.position[id2_m3 + 0] - scratchBuffers.normal[id2_m3 + 0] * r;
	            scratchBuffers.position[id_m3 + 1] = scratchBuffers.position[id2_m3 + 1] - scratchBuffers.normal[id2_m3 + 1] * r;
	            scratchBuffers.position[id_m3 + 2] = scratchBuffers.position[id2_m3 + 2] - scratchBuffers.normal[id2_m3 + 2] * r;
	
	            scratchBuffers.normal[id_m3 + 0] = scratchBuffers.normal[id2_m3 + 0];
	            scratchBuffers.normal[id_m3 + 1] = scratchBuffers.normal[id2_m3 + 1];
	            scratchBuffers.normal[id_m3 + 2] = scratchBuffers.normal[id2_m3 + 2];
	
	            buildUVSkirt(id);
	
	            scratchBuffers.uv.pm[idVertex] = scratchBuffers.uv.pm[id];
	
	            var idf = (i + 1) % skirt.length;
	
	            v1 = id;
	            v2 = idVertex;
	            v3 = idVertex + 1;
	            v4 = skirt[idf];
	
	            if (idf === 0) {
	                v3 = iStart;
	            }
	
	            idVertex2 = buildIndexSkirt(idVertex2, v1, v2, v3, v4);
	
	            idVertex++;
	        }
	    }
	
	    // Copy missing buffer in outBuffers from scratchBuffers
	    // TODO : free array
	    if (outBuffers.index === null) {
	        outBuffers.index = new THREE.BufferAttribute(scratchBuffers.index, 1);
	    }
	    outBuffers.position = new THREE.BufferAttribute(scratchBuffers.position, 3);
	    outBuffers.normal = new THREE.BufferAttribute(scratchBuffers.normal, 3);
	    if (outBuffers.uv.wgs84 === null) {
	        outBuffers.uv.wgs84 = new THREE.BufferAttribute(scratchBuffers.uv.wgs84, 2);
	    }
	    outBuffers.uv.pm = new THREE.BufferAttribute(scratchBuffers.uv.pm, 1);
	
	    scratchBuffers.position = null;
	    scratchBuffers.bufferIndex = null;
	    scratchBuffers.normal = null;
	    scratchBuffers.uv.wgs84 = null;
	    scratchBuffers.uv.pm = null;
	
	    return outBuffers;
	};
	
	exports.default = TileGeometry;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _LayeredMaterial = __webpack_require__(302);
	
	var _LayeredMaterial2 = _interopRequireDefault(_LayeredMaterial);
	
	var _TileDepthMaterial = __webpack_require__(310);
	
	var _TileDepthMaterial2 = _interopRequireDefault(_TileDepthMaterial);
	
	var _MatteIdsMaterial = __webpack_require__(313);
	
	var _MatteIdsMaterial2 = _interopRequireDefault(_MatteIdsMaterial);
	
	var _RendererConstant = __webpack_require__(315);
	
	var _RendererConstant2 = _interopRequireDefault(_RendererConstant);
	
	var _OGCWebServiceHelper = __webpack_require__(286);
	
	var _OGCWebServiceHelper2 = _interopRequireDefault(_OGCWebServiceHelper);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: TileMesh
	 * Description: Tuile de maillage, noeud du quadtree MNT. Le Materiel est issus du QuadTree ORTHO.
	 */
	
	function TileMesh(geometry, params) {
	    // Constructor
	    THREE.Mesh.call(this);
	
	    this.matrixAutoUpdate = false;
	    this.rotationAutoUpdate = false;
	
	    if (!params.extent) {
	        throw new Error('params.extent is mandatory to build a TileMesh');
	    }
	
	    this.level = params.level;
	    this.extent = params.extent;
	
	    this.geometry = geometry;
	    this.normal = params.center.clone().normalize();
	
	    // TODO Why move sphere center
	    this.centerSphere = new THREE.Vector3().addVectors(this.geometry.boundingSphere.center, params.center);
	
	    this.oSphere = new THREE.Sphere(this.centerSphere.clone(), this.geometry.boundingSphere.radius);
	
	    this.materials = [];
	
	    // instantiations all state materials : final, depth, id
	    // Final rendering : return layered color + fog
	    this.materials[_RendererConstant2.default.FINAL] = new _LayeredMaterial2.default(params.materialOptions);
	
	    // Depth : return the distance between projection point and the node
	    this.materials[_RendererConstant2.default.DEPTH] = new _TileDepthMaterial2.default(this.materials[_RendererConstant2.default.FINAL]);
	    // ID : return id color in RGBA (float Pack in RGBA)
	    this.materials[_RendererConstant2.default.ID] = new _MatteIdsMaterial2.default(this.materials[_RendererConstant2.default.FINAL]);
	    // Set current material in Final Rendering
	    this.material = this.materials[_RendererConstant2.default.FINAL];
	
	    this.frustumCulled = false;
	
	    this.updateGeometricError();
	
	    // Layer
	    this.setDisplayed(false);
	
	    this.layerUpdateState = {};
	}
	
	TileMesh.prototype = (0, _create2.default)(THREE.Mesh.prototype);
	TileMesh.prototype.constructor = TileMesh;
	
	TileMesh.prototype.dispose = function dispose() {
	    this.material.dispose();
	    this.geometry.dispose();
	    this.geometry = null;
	    this.material = null;
	};
	
	TileMesh.prototype.setUuid = function setUuid() {
	    this.materials[_RendererConstant2.default.FINAL].setUuid(this.id);
	    this.materials[_RendererConstant2.default.ID].setUuid(this.id);
	};
	
	TileMesh.prototype.getUuid = function getUuid() {
	    return this.materials[_RendererConstant2.default.ID].getUuid();
	};
	
	TileMesh.prototype.isVisible = function isVisible() {
	    return this.visible;
	};
	
	TileMesh.prototype.setDisplayed = function setDisplayed(show) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(this.materials), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var material = _step.value;
	
	            material.visible = show;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	};
	
	TileMesh.prototype.setVisibility = function setVisibility(show) {
	    this.visible = show;
	};
	
	TileMesh.prototype.isDisplayed = function isDisplayed() {
	    return this.material.visible;
	};
	
	TileMesh.prototype.enableRTC = function enableRTC(enable) {
	    this.materials[_RendererConstant2.default.FINAL].enableRTC(enable);
	};
	
	// switch material in function of state
	TileMesh.prototype.changeState = function changeState(state) {
	    if (state !== _RendererConstant2.default.FINAL) {
	        this.materials[state].visible = this.materials[_RendererConstant2.default.FINAL].visible;
	    }
	
	    this.material = this.materials[state];
	};
	
	TileMesh.prototype.setFog = function setFog(fog) {
	    this.materials[_RendererConstant2.default.FINAL].setFogDistance(fog);
	};
	
	TileMesh.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = (0, _getIterator3.default)(this.materials), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var material = _step2.value;
	
	            material.setMatrixRTC(rtc);
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	};
	
	TileMesh.prototype.setDebug = function setDebug(enable) {
	    this.materials[_RendererConstant2.default.FINAL].setDebug(enable);
	};
	
	TileMesh.prototype.setSelected = function setSelected(select) {
	    this.materials[_RendererConstant2.default.FINAL].setSelected(select);
	};
	
	TileMesh.prototype.setTextureElevation = function setTextureElevation(elevation) {
	    if (this.materials[_RendererConstant2.default.FINAL] === null) {
	        return;
	    }
	
	    var offsetScale = elevation.pitch || new THREE.Vector3(0, 0, 1);
	    this.setBBoxZ(elevation.min, elevation.max);
	
	    this.materials[_RendererConstant2.default.FINAL].setTexture(elevation.texture, _LayeredMaterial.l_ELEVATION, 0, offsetScale);
	    this.materials[_RendererConstant2.default.DEPTH].uniforms.texturesCount.value = this.materials[_RendererConstant2.default.FINAL].loadedTexturesCount[0];
	    this.materials[_RendererConstant2.default.ID].uniforms.texturesCount.value = this.materials[_RendererConstant2.default.FINAL].loadedTexturesCount[0];
	};
	
	TileMesh.prototype.setBBoxZ = function setBBoxZ(min, max) {
	    if (min == undefined && max == undefined) {
	        return;
	    }
	    if (Math.floor(min) !== Math.floor(this.geometry.OBB.z.min) || Math.floor(max) !== Math.floor(this.geometry.OBB.z.max)) {
	        var delta = this.geometry.OBB.updateZ(min, max);
	        var trans = this.normal.clone().setLength(delta.y);
	
	        this.geometry.boundingSphere.radius = Math.sqrt(delta.x * delta.x + this.oSphere.radius * this.oSphere.radius);
	        this.updateGeometricError();
	        this.centerSphere = new THREE.Vector3().addVectors(this.oSphere.center, trans);
	    }
	};
	
	TileMesh.prototype.updateGeometricError = function updateGeometricError() {
	    // The geometric error is calculated to have a correct texture display.
	    // For the projection of a texture's texel to be less than or equal to one pixel
	    this.geometricError = this.geometry.boundingSphere.radius / _OGCWebServiceHelper.SIZE_TEXTURE_TILE;
	};
	
	TileMesh.prototype.setTexturesLayer = function setTexturesLayer(textures, layerType, layerId) {
	    if (this.material === null) {
	        return;
	    }
	    if (textures) {
	        this.material.setTexturesLayer(textures, layerType, layerId);
	    }
	};
	
	TileMesh.prototype.getLayerTextures = function getLayerTextures(layerType, layerId) {
	    var mat = this.materials[_RendererConstant2.default.FINAL];
	    return mat.getLayerTextures(layerType, layerId);
	};
	
	TileMesh.prototype.isColorLayerLoaded = function isColorLayerLoaded(layerId) {
	    var mat = this.materials[_RendererConstant2.default.FINAL];
	    return mat.getColorLayerLevelById(layerId) > -1;
	};
	
	TileMesh.prototype.isElevationLayerLoaded = function isElevationLayerLoaded() {
	    var mat = this.materials[_RendererConstant2.default.FINAL];
	    return mat.getElevationLayerLevel() > -1;
	};
	
	TileMesh.prototype.isColorLayerDownscaled = function isColorLayerDownscaled(layer) {
	    var mat = this.materials[_RendererConstant2.default.FINAL];
	    return mat.isColorLayerDownscaled(layer.id, this.getZoomForLayer(layer));
	};
	
	TileMesh.prototype.normals = function normals() {
	    return this.geometry.normals;
	};
	
	TileMesh.prototype.fourCorners = function fourCorners() {
	    return this.geometry.fourCorners;
	};
	
	TileMesh.prototype.normal = function normal() {
	    return this.geometry.normal;
	};
	
	TileMesh.prototype.center = function center() {
	    return this.geometry.center;
	};
	
	TileMesh.prototype.OBB = function OBB() {
	    return this.geometry.OBB;
	};
	
	TileMesh.prototype.getIndexLayerColor = function getIndexLayerColor(idLayer) {
	    return this.materials[_RendererConstant2.default.FINAL].indexOfColorLayer(idLayer);
	};
	
	TileMesh.prototype.removeColorLayer = function removeColorLayer(idLayer) {
	    this.materials[_RendererConstant2.default.FINAL].removeColorLayer(idLayer);
	};
	
	TileMesh.prototype.changeSequenceLayers = function changeSequenceLayers(sequence) {
	    var layerCount = this.materials[_RendererConstant2.default.FINAL].getColorLayersCount();
	
	    // Quit if there is only one layer
	    if (layerCount < 2) {
	        return;
	    }
	
	    this.materials[_RendererConstant2.default.FINAL].setSequence(sequence);
	};
	
	TileMesh.prototype.getCoordsForLayer = function getCoordsForLayer(layer) {
	    if (layer.protocol.indexOf('wmts') == 0) {
	        _OGCWebServiceHelper2.default.computeTileMatrixSetCoordinates(this, layer.options.tileMatrixSet);
	        return this.wmtsCoords[layer.options.tileMatrixSet];
	    } else {
	        return [this.extent];
	    }
	};
	
	TileMesh.prototype.getZoomForLayer = function getCoordsForLayer(layer) {
	    if (layer.protocol.indexOf('wmts') == 0) {
	        _OGCWebServiceHelper2.default.computeTileMatrixSetCoordinates(this, layer.options.tileMatrixSet);
	        return this.wmtsCoords[layer.options.tileMatrixSet][0].zoom;
	    } else {
	        return this.level;
	    }
	};
	
	exports.default = TileMesh;

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.l_COLOR = exports.l_ELEVATION = exports.EMPTY_TEXTURE_ZOOM = undefined;
	
	var _toConsumableArray2 = __webpack_require__(218);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(303);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _TileVS = __webpack_require__(307);
	
	var _TileVS2 = _interopRequireDefault(_TileVS);
	
	var _TileFS = __webpack_require__(308);
	
	var _TileFS2 = _interopRequireDefault(_TileFS);
	
	var _pitUV = __webpack_require__(309);
	
	var _pitUV2 = _interopRequireDefault(_pitUV);
	
	var _Capabilities = __webpack_require__(263);
	
	var _Capabilities2 = _interopRequireDefault(_Capabilities);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	var EMPTY_TEXTURE_ZOOM = exports.EMPTY_TEXTURE_ZOOM = -1;
	
	var emptyTexture = new THREE.Texture();
	emptyTexture.coords = { zoom: EMPTY_TEXTURE_ZOOM };
	
	var layerTypesCount = 2;
	var vector = new THREE.Vector3(0.0, 0.0, 0.0);
	var vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 0.0);
	var fooTexture;
	
	var l_ELEVATION = exports.l_ELEVATION = 0;
	var l_COLOR = exports.l_COLOR = 1;
	
	var getColorAtIdUv = function getColorAtIdUv(nbTex) {
	    if (!fooTexture) {
	        fooTexture = 'vec4 colorAtIdUv(sampler2D dTextures[TEX_UNITS],vec3 offsetScale[TEX_UNITS],int id, vec2 uv){\n';
	        fooTexture += ' if (id == 0) return texture2D(dTextures[0],  pitUV(uv,offsetScale[0]));\n';
	
	        for (var l = 1; l < nbTex; l++) {
	            var sL = l.toString();
	            fooTexture += '    else if (id == ' + sL + ') return texture2D(dTextures[' + sL + '],  pitUV(uv,offsetScale[' + sL + ']));\n';
	        }
	
	        fooTexture += 'else return vec4(0.0,0.0,0.0,0.0);}\n';
	    }
	
	    return fooTexture;
	};
	
	// Array not suported in IE
	var fillArray = function fillArray(array, remp) {
	    for (var i = 0; i < array.length; i++) {
	        array[i] = remp;
	    }
	};
	
	var moveElementArray = function moveElementArray(array, oldIndex, newIndex) {
	    array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
	};
	
	/* eslint-disable */
	var moveElementsArraySafe = function moveElementsArraySafe(array, index, howMany, toIndex) {
	    index = parseInt(index) || 0;
	    index = index < 0 ? array.length + index : index;
	    toIndex = parseInt(toIndex) || 0;
	    toIndex = toIndex < 0 ? array.length + toIndex : toIndex;
	    if (toIndex > index && toIndex <= index + howMany) {
	        toIndex = index + howMany;
	    }
	
	    var moved;
	    array.splice.apply(array, [toIndex, 0].concat(moved = array.splice(index, howMany)));
	    return moved;
	};
	/* eslint-enable */
	
	var LayeredMaterial = function LayeredMaterial(options) {
	    _BasicMaterial2.default.call(this);
	
	    var maxTexturesUnits = _Capabilities2.default.getMaxTextureUnitsCount();
	    var nbSamplers = Math.min(maxTexturesUnits - 1, 16 - 1);
	    this.vertexShader = _TileVS2.default;
	
	    this.fragmentShaderHeader += 'const int   TEX_UNITS   = ' + nbSamplers.toString() + ';\n';
	    this.fragmentShaderHeader += _pitUV2.default;
	
	    if (false) {
	        this.fragmentShaderHeader += '#define DEBUG\n';
	    }
	
	    options = options || {};
	    var vsOptions = '';
	    if (options.useRgbaTextureElevation) {
	        throw new Error('Restore this feature');
	    } else if (options.useColorTextureElevation) {
	        vsOptions = '\n#define COLOR_TEXTURE_ELEVATION\n';
	        vsOptions += '\nconst float _minElevation = ' + options.colorTextureElevationMinZ.toFixed(1) + ';\n';
	        vsOptions += '\nconst float _maxElevation = ' + options.colorTextureElevationMaxZ.toFixed(1) + ';\n';
	    } else {
	        // default
	        vsOptions = '\n#define DATA_TEXTURE_ELEVATION\n';
	    }
	
	    // see GLOBE FS
	    this.fragmentShaderHeader += getColorAtIdUv(nbSamplers);
	
	    this.fragmentShader = this.fragmentShaderHeader + _TileFS2.default;
	    this.vertexShader = this.vertexShaderHeader + vsOptions + _TileVS2.default;
	
	    // handle on textures uniforms
	    this.textures = [];
	    // handle on textures offsetScale uniforms
	    this.offsetScale = [];
	    // handle Loaded textures count by layer's type uniforms
	    this.loadedTexturesCount = [0, 0];
	
	    // Uniform three js needs no empty array
	    // WARNING TODO: prevent empty slot, but it's not the solution
	    this.offsetScale[l_COLOR] = Array(nbSamplers);
	    this.offsetScale[l_ELEVATION] = [vector];
	    fillArray(this.offsetScale[l_COLOR], vector);
	
	    this.textures[l_ELEVATION] = [emptyTexture];
	    this.textures[l_COLOR] = Array(nbSamplers);
	    var paramLayers = Array(8);
	    this.layerTexturesCount = Array(8);
	
	    fillArray(this.textures[l_COLOR], emptyTexture);
	    fillArray(paramLayers, vector4);
	    fillArray(this.layerTexturesCount, 0);
	
	    // Elevation texture
	    this.uniforms.dTextures_00 = new THREE.Uniform(this.textures[l_ELEVATION]);
	
	    // Color textures's layer
	    this.uniforms.dTextures_01 = new THREE.Uniform(this.textures[l_COLOR]);
	
	    // Visibility layer
	    this.uniforms.visibility = new THREE.Uniform([true, true, true, true, true, true, true, true]);
	
	    // Loaded textures count by layer's type
	    this.uniforms.loadedTexturesCount = new THREE.Uniform(this.loadedTexturesCount);
	
	    // Count color layers
	    this.uniforms.colorLayersCount = new THREE.Uniform(1);
	
	    // Layer setting
	    // Offset color texture slot | Projection | fx | Opacity
	    this.uniforms.paramLayers = new THREE.Uniform(paramLayers);
	
	    // Elevation texture cropping
	    this.uniforms.offsetScale_L00 = new THREE.Uniform(this.offsetScale[l_ELEVATION]);
	
	    // Color texture cropping
	    this.uniforms.offsetScale_L01 = new THREE.Uniform(this.offsetScale[l_COLOR]);
	
	    // Light position
	    this.uniforms.lightPosition = new THREE.Uniform(new THREE.Vector3(-0.5, 0.0, 1.0));
	
	    this.colorLayersId = [];
	    this.elevationLayersId = [];
	
	    if (false) {
	        this.checkLayersConsistency = function checkLayersConsistency(node, imageryLayers) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                for (var _iterator = (0, _getIterator3.default)(imageryLayers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var layer = _step.value;
	
	                    var index = this.indexOfColorLayer(layer.id);
	                    if (index < 0) {
	                        continue;
	                    }
	
	                    var offset = this.getTextureOffsetByLayerIndex(index);
	                    var count = this.getTextureCountByLayerIndex(index);
	                    var total = 0;
	                    for (var i = 0; i < this.loadedTexturesCount[1]; i++) {
	                        if (!this.uniforms.dTextures_01.value[i].image) {
	                            throw new Error(node.id + ' - Missing texture at index ' + i + ' for layer ' + layer.id);
	                        }
	
	                        var critere1 = offset <= i && i < offset + count;
	                        var search = layer.name ? 'LAYERS=' + layer.name + '&' : 'LAYER=' + layer.options.name + '&';
	                        var critere2 = this.uniforms.dTextures_01.value[i].image.currentSrc.indexOf(search) > 0;
	
	                        if (critere1 && !critere2) {
	                            throw new Error(node.id + ' - Texture should belong to ' + layer.id + ' but comes from ' + this.uniforms.dTextures_01.value[i].image.currentSrc);
	                        } else if (!critere1 && critere2) {
	                            throw new Error(node.id + ' - Texture shouldn\'t belong to ' + layer.id);
	                        } else if (critere1) {
	                            total++;
	                        }
	                    }
	                    if (total != count) {
	                        throw new Error(node.id + ' - Invalid total texture count. Found: ' + total + ', expected: ' + count + ' for ' + layer.id);
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        };
	    }
	};
	
	LayeredMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	LayeredMaterial.prototype.constructor = LayeredMaterial;
	
	LayeredMaterial.prototype.dispose = function dispose() {
	    // TODO: WARNING  verify if textures to dispose aren't attached with ancestor
	
	    this.dispatchEvent({
	        type: 'dispose'
	    });
	
	    for (var l = 0; l < layerTypesCount; l++) {
	        for (var i = 0, max = this.textures[l].length; i < max; i++) {
	            if (this.textures[l][i] instanceof THREE.Texture) {
	                this.textures[l][i].dispose();
	            }
	        }
	    }
	};
	
	LayeredMaterial.prototype.setSequence = function setSequence(sequenceLayer) {
	    var offsetLayer = 0;
	    var offsetTexture = 0;
	
	    var originalOffsets = new (Function.prototype.bind.apply(Array, [null].concat((0, _toConsumableArray3.default)(this.uniforms.offsetScale_L01.value))))();
	    var originalTextures = new (Function.prototype.bind.apply(Array, [null].concat((0, _toConsumableArray3.default)(this.uniforms.dTextures_01.value))))();
	
	    for (var l = 0; l < sequenceLayer.length; l++) {
	        var layer = sequenceLayer[l];
	        var oldIndex = this.indexOfColorLayer(layer);
	        if (oldIndex > -1) {
	            var newIndex = l - offsetLayer;
	            var texturesCount = this.layerTexturesCount[oldIndex];
	
	            // individual values are swapped in place
	            if (newIndex !== oldIndex) {
	                moveElementArray(this.colorLayersId, oldIndex, newIndex);
	                moveElementArray(this.layerTexturesCount, oldIndex, newIndex);
	                moveElementArray(this.uniforms.paramLayers.value, oldIndex, newIndex);
	                moveElementArray(this.uniforms.visibility.value, oldIndex, newIndex);
	            }
	            var oldOffset = this.getTextureOffsetByLayerIndex(newIndex);
	            // consecutive values are copied from original
	            for (var i = 0; i < texturesCount; i++) {
	                this.uniforms.offsetScale_L01.value[offsetTexture + i] = originalOffsets[oldOffset + i];
	                this.uniforms.dTextures_01.value[offsetTexture + i] = originalTextures[oldOffset + i];
	            }
	
	            this.setTextureOffsetByLayerIndex(newIndex, offsetTexture);
	            offsetTexture += texturesCount;
	        } else {
	            offsetLayer++;
	        }
	    }
	
	    this.uniforms.colorLayersCount.value = this.getColorLayersCount();
	};
	
	LayeredMaterial.prototype.removeColorLayer = function removeColorLayer(layer) {
	    var layerIndex = this.indexOfColorLayer(layer);
	
	    if (layerIndex === -1) {
	        return;
	    }
	
	    var offset = this.getTextureOffsetByLayerIndex(layerIndex);
	    var texturesCount = this.getTextureCountByLayerIndex(layerIndex);
	
	    // remove layer
	    this.colorLayersId.splice(layerIndex, 1);
	    this.uniforms.colorLayersCount.value = this.getColorLayersCount();
	
	    // remove nb textures
	    this.layerTexturesCount.splice(layerIndex, 1);
	    this.layerTexturesCount.push(0);
	
	    // Remove Layers Parameters
	    this.uniforms.paramLayers.value.splice(layerIndex, 1);
	    this.uniforms.paramLayers.value.push(vector4);
	
	    // Remove visibility Parameters
	    this.uniforms.visibility.value.splice(layerIndex, 1);
	    this.uniforms.visibility.value.push(true);
	
	    // Dispose Layers textures
	    for (var i = offset, max = offset + texturesCount; i < max; i++) {
	        if (this.textures[l_COLOR][i] instanceof THREE.Texture) {
	            this.textures[l_COLOR][i].dispose();
	        }
	    }
	
	    var removedTexturesLayer = this.textures[l_COLOR].splice(offset, texturesCount);
	    this.offsetScale[l_COLOR].splice(offset, texturesCount);
	
	    var loadedTexturesLayerCount = removedTexturesLayer.reduce(function (sum, texture) {
	        return sum + (texture.coords.zoom > EMPTY_TEXTURE_ZOOM);
	    }, 0);
	
	    // refill remove textures
	    for (var _i = 0, _max = texturesCount; _i < _max; _i++) {
	        this.textures[l_COLOR].push(emptyTexture);
	        this.offsetScale[l_COLOR].push(vector);
	    }
	
	    // Update slot start texture layer
	    for (var j = layerIndex, mx = this.getColorLayersCount(); j < mx; j++) {
	        this.uniforms.paramLayers.value[j].x -= texturesCount;
	    }
	
	    this.loadedTexturesCount[l_COLOR] -= loadedTexturesLayerCount;
	
	    this.uniforms.offsetScale_L01.value = this.offsetScale[l_COLOR];
	    this.uniforms.dTextures_01.value = this.textures[l_COLOR];
	};
	
	LayeredMaterial.prototype.setTexturesLayer = function setTexturesLayer(textures, layerType, layer) {
	    var index = this.indexOfColorLayer(layer);
	    var slotOffset = this.getTextureOffsetByLayerIndex(index);
	    for (var i = 0, max = textures.length; i < max; i++) {
	        if (textures[i]) {
	            if (textures[i].texture !== null) {
	                this.setTexture(textures[i].texture, layerType, i + (slotOffset || 0), textures[i].pitch);
	            } else {
	                this.setLayerVisibility(index, false);
	                break;
	            }
	        }
	    }
	};
	
	LayeredMaterial.prototype.setTexture = function setTexture(texture, layerType, slot, offsetScale) {
	    if (this.textures[layerType][slot] === undefined || this.textures[layerType][slot].image === undefined) {
	        this.loadedTexturesCount[layerType] += 1;
	    }
	
	    // BEWARE: array [] -> size: 0; array [10]="wao" -> size: 11
	    this.textures[layerType][slot] = texture || emptyTexture;
	    this.offsetScale[layerType][slot] = offsetScale || new THREE.Vector3(0.0, 0.0, 1.0);
	};
	
	LayeredMaterial.prototype.setColorLayerParameters = function setColorLayerParameters(params) {
	    if (this.getColorLayersCount() === 0) {
	        for (var l = 0; l < params.length; l++) {
	            this.pushLayer(params[l]);
	        }
	    }
	};
	
	LayeredMaterial.prototype.pushLayer = function pushLayer(param) {
	    var newIndex = this.getColorLayersCount();
	    var offset = newIndex === 0 ? 0 : this.getTextureOffsetByLayerIndex(newIndex - 1) + this.getTextureCountByLayerIndex(newIndex - 1);
	
	    this.uniforms.paramLayers.value[newIndex] = new THREE.Vector4();
	
	    this.setTextureOffsetByLayerIndex(newIndex, offset);
	    this.setLayerUV(newIndex, param.tileMT === 'PM' ? 1 : 0);
	    this.setLayerFx(newIndex, param.fx);
	    this.setLayerOpacity(newIndex, param.opacity);
	    this.setLayerVisibility(newIndex, param.visible);
	    this.setLayerTexturesCount(newIndex, param.texturesCount);
	    this.colorLayersId.push(param.idLayer);
	
	    this.uniforms.colorLayersCount.value = this.getColorLayersCount();
	};
	
	LayeredMaterial.prototype.indexOfColorLayer = function indexOfColorLayer(layerId) {
	    return this.colorLayersId.indexOf(layerId);
	};
	
	LayeredMaterial.prototype.getColorLayersCount = function getColorLayersCount() {
	    return this.colorLayersId.length;
	};
	
	LayeredMaterial.prototype.getTextureOffsetByLayerIndex = function getTextureOffsetByLayerIndex(index) {
	    return this.uniforms.paramLayers.value[index].x;
	};
	
	LayeredMaterial.prototype.getTextureCountByLayerIndex = function getTextureCountByLayerIndex(index) {
	    return this.layerTexturesCount[index];
	};
	
	LayeredMaterial.prototype.getLayerTextureOffset = function getLayerTextureOffset(layerId) {
	    var index = this.indexOfColorLayer(layerId);
	    return index > -1 ? this.getTextureOffsetByLayerIndex(index) : -1;
	};
	
	LayeredMaterial.prototype.setLightingOn = function setLightingOn(enable) {
	    this.uniforms.lightingEnabled.value = enable;
	};
	
	LayeredMaterial.prototype.setLayerFx = function setLayerFx(index, fx) {
	    this.uniforms.paramLayers.value[index].z = fx;
	};
	
	LayeredMaterial.prototype.setTextureOffsetByLayerIndex = function setTextureOffsetByLayerIndex(index, offset) {
	    this.uniforms.paramLayers.value[index].x = offset;
	};
	
	LayeredMaterial.prototype.setLayerUV = function setLayerUV(index, idUV) {
	    this.uniforms.paramLayers.value[index].y = idUV;
	};
	
	LayeredMaterial.prototype.getLayerUV = function setLayerUV(index) {
	    return this.uniforms.paramLayers.value[index].y;
	};
	
	LayeredMaterial.prototype.setLayerOpacity = function setLayerOpacity(index, opacity) {
	    if (this.uniforms.paramLayers.value[index]) {
	        this.uniforms.paramLayers.value[index].w = opacity;
	    }
	};
	
	LayeredMaterial.prototype.setLayerVisibility = function setLayerVisibility(index, visible) {
	    this.uniforms.visibility.value[index] = visible;
	};
	
	LayeredMaterial.prototype.setLayerTexturesCount = function setLayerTexturesCount(index, count) {
	    this.layerTexturesCount[index] = count;
	};
	
	LayeredMaterial.prototype.getLoadedTexturesCount = function getLoadedTexturesCount() {
	    return this.loadedTexturesCount[l_ELEVATION] + this.loadedTexturesCount[l_COLOR];
	};
	
	LayeredMaterial.prototype.isColorLayerDownscaled = function isColorLayerDownscaled(layerId, zoom) {
	    return this.textures[l_COLOR][this.getLayerTextureOffset(layerId)] && this.textures[l_COLOR][this.getLayerTextureOffset(layerId)].coords.zoom < zoom;
	};
	
	LayeredMaterial.prototype.getColorLayerLevelById = function getColorLayerLevelById(colorLayerId) {
	    var index = this.indexOfColorLayer(colorLayerId);
	    if (index === -1) {
	        return EMPTY_TEXTURE_ZOOM;
	    }
	    var slot = this.getTextureOffsetByLayerIndex(index);
	    var texture = this.textures[l_COLOR][slot];
	
	    return texture ? texture.coords.zoom : EMPTY_TEXTURE_ZOOM;
	};
	
	LayeredMaterial.prototype.getElevationLayerLevel = function getElevationLayerLevel() {
	    return this.textures[l_ELEVATION][0].coords.zoom;
	};
	
	LayeredMaterial.prototype.getLayerTextures = function getLayerTextures(layerType, layerId) {
	    if (layerType === l_ELEVATION) {
	        return this.textures[l_ELEVATION];
	    }
	
	    var index = this.indexOfColorLayer(layerId);
	
	    if (index !== -1) {
	        var count = this.getTextureCountByLayerIndex(index);
	        var textureIndex = this.getTextureOffsetByLayerIndex(index);
	        return this.textures[l_COLOR].slice(textureIndex, textureIndex + count);
	    } else {
	        throw new Error('Invalid layer id "' + layerId + '"');
	    }
	};
	
	exports.default = LayeredMaterial;

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _SimpleVS = __webpack_require__(304);
	
	var _SimpleVS2 = _interopRequireDefault(_SimpleVS);
	
	var _SimpleFS = __webpack_require__(305);
	
	var _SimpleFS2 = _interopRequireDefault(_SimpleFS);
	
	var _LogDepthBuffer = __webpack_require__(306);
	
	var _LogDepthBuffer2 = _interopRequireDefault(_LogDepthBuffer);
	
	var _Capabilities = __webpack_require__(263);
	
	var _Capabilities2 = _interopRequireDefault(_Capabilities);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function BasicMaterial(color) {
	    // Constructor
	
	    THREE.RawShaderMaterial.call(this);
	
	    this.vertexShaderHeader = '';
	    this.fragmentShaderHeader = '';
	
	    var logarithmicDepthBuffer = _Capabilities2.default.isLogDepthBufferSupported();
	
	    if (logarithmicDepthBuffer) {
	        this.fragmentShaderHeader += '#extension GL_EXT_frag_depth : enable\n';
	    }
	
	    this.fragmentShaderHeader += 'precision highp float;\n';
	    this.fragmentShaderHeader += 'precision highp int;\n';
	
	    if (logarithmicDepthBuffer) {
	        this.fragmentShaderHeader += '#define USE_LOGDEPTHBUF\n';
	        this.fragmentShaderHeader += '#define USE_LOGDEPTHBUF_EXT\n';
	        this.fragmentShaderHeader += _LogDepthBuffer2.default;
	    }
	
	    this.fragmentShaderHeader += '#define VERTEX_TEXTURES\n';
	    this.vertexShaderHeader = this.fragmentShaderHeader;
	
	    this.vertexShader = this.vertexShaderHeader + _SimpleVS2.default;
	    this.fragmentShader = this.fragmentShaderHeader + _SimpleFS2.default;
	
	    this.uniforms = {
	        diffuseColor: { value: color || new THREE.Color() },
	        useRTC: { value: true },
	        mVPMatRTC: { value: new THREE.Matrix4() },
	        distanceFog: { value: 1000000000.0 },
	        uuid: { value: 0 },
	        debug: { value: false },
	        selected: { value: false },
	        lightingEnabled: { value: false }
	    };
	} /*
	   * To change this license header, choose License Headers in Project Properties.
	   * To change this template file, choose Tools | Templates
	   * and open the template in the editor.
	   */
	
	BasicMaterial.prototype = (0, _create2.default)(THREE.RawShaderMaterial.prototype);
	BasicMaterial.prototype.constructor = BasicMaterial;
	
	BasicMaterial.prototype.enableRTC = function enableRTC(enable) {
	    this.uniforms.useRTC.value = enable;
	};
	
	BasicMaterial.prototype.setDebug = function setDebug(v) {
	    this.uniforms.debug.value = v;
	};
	
	BasicMaterial.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
	    this.uniforms.mVPMatRTC.value = rtc;
	};
	
	BasicMaterial.prototype.getMatrixRTC = function getMatrixRTC() {
	    return this.uniforms.mVPMatRTC.value;
	};
	
	BasicMaterial.prototype.setUuid = function setUuid(uuid) {
	    this.uniforms.uuid.value = uuid;
	};
	
	BasicMaterial.prototype.getUuid = function getUuid() {
	    return this.uniforms.uuid.value;
	};
	
	BasicMaterial.prototype.setFogDistance = function setFogDistance(df) {
	    this.uniforms.distanceFog.value = df;
	};
	
	BasicMaterial.prototype.setSelected = function setSelected(selected) {
	    this.uniforms.selected.value = selected;
	};
	
	exports.default = BasicMaterial;

/***/ },
/* 304 */
/***/ function(module, exports) {

	module.exports = "#version 100\n\nprecision highp float;\nprecision highp int;\n\n#define SHADER_NAME SimpleMaterial\n#define VERTEX_TEXTURES\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n\n//attribute vec2      uv;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform mat4        projectionMatrix;\nuniform mat4        modelViewMatrix;\n\nuniform mat4       mVPMatRTC;\nuniform bool       useRTC;\nvarying float      light;\n\n// IE error : Initializer for const variable must initialize to a constant value\n//const vec3 dir =  normalize(vec3(1.0,1.0,0.5));\n\nvoid main()\n{\n  vec3 dir =  normalize(vec3(1.0,1.0,0.5));\n\n  if(useRTC)\n        gl_Position = mVPMatRTC * vec4( position ,1.0 );\n  else\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n    float h  = max(0.05,(1.0 - min(position.y / 50.0,1.0)));\n\n    light    =   h / max(0.25,dot(dir,normal));\n\n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n\n}"

/***/ },
/* 305 */
/***/ function(module, exports) {

	module.exports = "#version 100\n\n#extension GL_EXT_frag_depth : enable\n\n#define SHADER_NAME simpleMaterial\n#define VERTEX_TEXTURES\n\nprecision highp float;\nprecision highp int;\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif\n\nuniform vec3 diffuseColor;\nuniform bool lightingEnabled;\nvarying float light;\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    vec4 color = lightingEnabled ? vec4( diffuseColor / light,1.0) : vec4( diffuseColor, 1.0);\n\n    gl_FragColor = color;\n}"

/***/ },
/* 306 */
/***/ function(module, exports) {

	module.exports = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n    #define EPSILON 1e-6\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n"

/***/ },
/* 307 */
/***/ function(module, exports) {

	module.exports = "const float PI          = 3.14159265359;\nconst float INV_TWO_PI  = 1.0 / (2.0*PI);\nconst float PI4         = 0.78539816339;\n\nattribute float     uv_pm;\nattribute vec2      uv_wgs84;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform sampler2D   dTextures_00[1];\nuniform vec3        offsetScale_L00[1];\nuniform int         loadedTexturesCount[8];\nuniform bool        useRTC;\nuniform mat4        mVPMatRTC;\n\nuniform mat4        projectionMatrix;\nuniform mat4        modelViewMatrix;\n\nvarying vec2        vUv_WGS84;\nvarying float       vUv_PM;\nvarying vec3        vNormal;\nvarying vec4        pos;\n\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n    return Result;\n}\n\nvoid main() {\n\n        vUv_WGS84 = uv_wgs84;\n        vUv_PM = uv_pm;\n\n        vec4 vPosition;\n\n        vNormal = normal;\n\n        if(loadedTexturesCount[0] > 0)\n        {\n            vec2    vVv = vec2(\n                vUv_WGS84.x * offsetScale_L00[0].z + offsetScale_L00[0].x,\n                (1.0 - vUv_WGS84.y) * offsetScale_L00[0].z + offsetScale_L00[0].y);\n\n\n            #if defined(RGBA_TEXTURE_ELEVATION)\n                vec4 rgba = texture2D( dTextures_00[0], vVv ) * 255.0;\n\n                rgba.rgba = rgba.abgr;\n\n                float dv = max(decode32(rgba),0.0);\n\n                // TODO In RGBA elevation texture LinearFilter give some errors with nodata value.\n                // need to rewrite sample function in shader\n                // simple solution\n                if(dv>5000.0)\n                    dv = 0.0;\n\n            #elif defined(DATA_TEXTURE_ELEVATION)\n                float   dv  = max(texture2D( dTextures_00[0], vVv ).w, 0.);\n            #elif defined(COLOR_TEXTURE_ELEVATION)\n                float   dv  = max(texture2D( dTextures_00[0], vVv ).r, 0.);\n                dv = _minElevation + dv * (_maxElevation - _minElevation);\n            #else\n\n            #error Must define either RGBA_TEXTURE_ELEVATION, DATA_TEXTURE_ELEVATION or COLOR_TEXTURE_ELEVATION\n            #endif\n\n            vPosition   = vec4( position +  vNormal  * dv ,1.0 );\n        } else {\n            vPosition = vec4( position ,1.0 );\n        }\n\n        mat4 projModelViewMatrix = useRTC ? mVPMatRTC : projectionMatrix * modelViewMatrix;\n\n        gl_Position = projModelViewMatrix * vPosition;\n\n        #ifdef USE_LOGDEPTHBUF\n\n            gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n            #ifdef USE_LOGDEPTHBUF_EXT\n\n                vFragDepth = 1.0 + gl_Position.w;\n\n            #else\n\n                gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n            #endif\n\n        #endif\n\n}\n"

/***/ },
/* 308 */
/***/ function(module, exports) {

	module.exports = "// BUG CHROME 50 UBUNTU 16.04\n// Lose context on compiling shader with too many IF STATEMENT\n// runconformance/glsl/bugs/conditional-discard-in-loop.html\n// conformance/glsl/bugs/nested-loops-with-break-and-continue.html\n// Resolve CHROME unstable 52\n\nconst vec4 CFog = vec4( 0.76, 0.85, 1.0, 1.0);\nconst vec4 CWhite = vec4(1.0,1.0,1.0,1.0);\nconst vec4 CBlueOcean = vec4( 0.04, 0.23, 0.35, 1.0);\nconst vec4 COrange = vec4( 1.0, 0.3, 0.0, 1.0);\nconst vec4 CRed = vec4( 1.0, 0.0, 0.0, 1.0);\n\n\nuniform sampler2D   dTextures_01[TEX_UNITS];\nuniform vec3        offsetScale_L01[TEX_UNITS];\n\n// offset texture | Projection | fx | Opacity\nuniform vec4        paramLayers[8];\nuniform int         loadedTexturesCount[8];\nuniform bool        visibility[8];\n\nuniform float       distanceFog;\nuniform int         colorLayersCount;\nuniform vec3        lightPosition;\n\n// Options global\nuniform bool        selected;\nuniform bool        lightingEnabled;\n\nvarying vec2        vUv_WGS84;\nvarying float       vUv_PM;\nvarying vec3        vNormal;\n\n#if defined(DEBUG)\n    uniform bool showOutline;\n    const float sLine = 0.008;\n#endif\n\n// Note see after in code\n// int textureIndex = 0;\n// int getTextureIndex() {\n//     return textureIndex;\n// }\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\t   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    #if defined(DEBUG)\n         if (showOutline && (vUv_WGS84.x < sLine || vUv_WGS84.x > 1.0 - sLine || vUv_WGS84.y < sLine || vUv_WGS84.y > 1.0 - sLine))\n             gl_FragColor = CRed;\n         else\n    #endif\n    {\n        // Reconstruct PM uv and PM subtexture id (see TileGeometry)\n        vec2 uvPM ;\n        uvPM.x             = vUv_WGS84.x;\n        float y            = vUv_PM;\n        int pmSubTextureIndex = int(floor(y));\n        uvPM.y             = y - float(pmSubTextureIndex);\n\n        #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n            float depth = gl_FragDepthEXT / gl_FragCoord.w;\n            float fogIntensity = 1.0/(exp(depth/distanceFog));\n        #else\n            float fogIntensity = 1.0;\n        #endif\n\n        vec4 diffuseColor = CWhite;\n        bool validTexture = false;\n\n        // TODO Optimisation des uv1 peuvent copier pas lignes!!\n        for (int layer = 0; layer < 8; layer++) {\n            if(layer == colorLayersCount) {\n                break;\n            }\n\n            if(visibility[layer]) {\n                vec4 paramsA = paramLayers[layer];\n\n                if(paramsA.w > 0.0) {\n                    bool projWGS84 = paramsA.y == 0.0;\n                    int textureIndex = int(paramsA.x) + (projWGS84 ? 0 : pmSubTextureIndex);\n\n                    /* if (0 <= textureIndex && textureIndex < loadedTexturesCount[1]) */ {\n\n                        // TODO: Try other OS before delete dead\n                        // get value in array, the index must be constant\n                        // Strangely it's work with function returning a global variable, doesn't work on Chrome Windows\n                        // vec4 layerColor = texture2D(dTextures_01[getTextureIndex()],  pitUV(projWGS84 ? vUv_WGS84 : uvPM,pitScale_L01[getTextureIndex()]));\n                        vec4 layerColor = colorAtIdUv(\n                            dTextures_01,\n                            offsetScale_L01,\n                            textureIndex,\n                            projWGS84 ? vUv_WGS84 : uvPM);\n\n                        if (layerColor.a > 0.0) {\n                            validTexture = true;\n                            float lum = 1.0;\n\n                            if(paramsA.z > 0.0) {\n                                float a = max(0.05,1.0 - length(layerColor.xyz-CWhite.xyz));\n                                if(paramsA.z > 2.0) {\n                                    a = (layerColor.r + layerColor.g + layerColor.b)*0.333333333;\n                                    layerColor*= layerColor*layerColor;\n                                }\n                                lum = 1.0-pow(abs(a),paramsA.z);\n                            }\n\n                            diffuseColor = mix( diffuseColor,layerColor, lum*paramsA.w * layerColor.a);\n\n                        }\n                    }\n                }\n    // #if defined(DEBUG)\n    //                 else {\n    //                     // Invalid texture -> error color\n    //                     diffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n    //                 }\n    // #endif\n\n            }\n        }\n\n        // No texture color\n        if (!validTexture) {\n\n            diffuseColor = CBlueOcean;\n        }\n\n        // Selected\n        if(selected) {\n            diffuseColor = mix(COrange, diffuseColor, 0.5 );\n        }\n\n        // Fog\n        gl_FragColor = mix(CFog, diffuseColor, fogIntensity);\n        gl_FragColor.a = 1.0;\n\n        if(lightingEnabled) {   // Add lighting\n            float light = min(2. * dot(vNormal, lightPosition),1.);\n            gl_FragColor.rgb *= light;\n        }\n    }\n}\n"

/***/ },
/* 309 */
/***/ function(module, exports) {

	module.exports = "vec2    pitUV(vec2 uvIn, vec3 pit)\n{\n    vec2  uv;\n    uv.x = uvIn.x* pit.z + pit.x;\n    uv.y = 1.0 -( (1.0 - uvIn.y) * pit.z + pit.y);\n\n    return uv;\n}\n\n"

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(303);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _TileDepthFS = __webpack_require__(311);
	
	var _TileDepthFS2 = _interopRequireDefault(_TileDepthFS);
	
	var _TileDepthVS = __webpack_require__(312);
	
	var _TileDepthVS2 = _interopRequireDefault(_TileDepthVS);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TileDepthMaterial = function TileDepthMaterial(otherMaterial) {
	    _BasicMaterial2.default.call(this);
	
	    this.vertexShader = this.vertexShaderHeader + _TileDepthVS2.default;
	    this.fragmentShader = this.fragmentShaderHeader + _TileDepthFS2.default;
	
	    // Why connect directily uniform doesn't work?
	    // Verify attributes's shaders
	
	    this.uniforms.dTextures_00 = new THREE.Uniform(otherMaterial.textures[0]);
	    this.uniforms.texturesCount = new THREE.Uniform(otherMaterial.loadedTexturesCount[0]);
	    this.uniforms.offsetScale_L00 = new THREE.Uniform(otherMaterial.offsetScale[0]);
	};
	
	TileDepthMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	TileDepthMaterial.prototype.constructor = TileDepthMaterial;
	
	exports.default = TileDepthMaterial;

/***/ },
/* 311 */
/***/ function(module, exports) {

	module.exports = "const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\nvec4 pack1K ( float depth ) {\n    depth /= 100000000.0;\n    vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n    res -= res.xxyz * bitMsk;\n    return res;\n}\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\t   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n        float z = 1.0/ gl_FragCoord.w ;\n        gl_FragColor = pack1K(z);\n    #else\n        float z = gl_FragCoord.z / gl_FragCoord.w;\n        gl_FragColor = pack1K(z);\n    #endif\n\n}\n"

/***/ },
/* 312 */
/***/ function(module, exports) {

	module.exports = "attribute vec2      uv_wgs84;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform sampler2D   dTextures_00[1];\nuniform vec3        offsetScale_L00[1];\nuniform int         texturesCount;\nuniform mat4        mVPMatRTC;\n\nvoid main() {\n\n        vec4 vPosition;\n\n        if(texturesCount > 0) {\n            vec2    vVv = vec2(uv_wgs84.x * offsetScale_L00[0].z + offsetScale_L00[0].x,(1.0 - uv_wgs84.y) * offsetScale_L00[0].z + offsetScale_L00[0].y);\n\n            float   dv  = max(texture2D( dTextures_00[0], vVv ).w, 0.);\n\n            vPosition   = vec4(position + normal * dv, 1.0 );\n        }\n        else {\n            vPosition = vec4(position, 1.0);\n        }\n\n        gl_Position = mVPMatRTC * vPosition;\n\n        #ifdef USE_LOGDEPTHBUF\n\n            gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n            #ifdef USE_LOGDEPTHBUF_EXT\n\n                vFragDepth = 1.0 + gl_Position.w;\n\n            #else\n\n                gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n            #endif\n\n        #endif\n\n}\n"

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	exports.unpack1K = unpack1K;
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(303);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _MatteIdsFS = __webpack_require__(314);
	
	var _MatteIdsFS2 = _interopRequireDefault(_MatteIdsFS);
	
	var _TileDepthVS = __webpack_require__(312);
	
	var _TileDepthVS2 = _interopRequireDefault(_TileDepthVS);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	function unpack1K(color, factor) {
	    var bitSh = new THREE.Vector4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	    return bitSh.dot(color) * factor;
	}
	
	// This material renders the id in RGBA Color
	// Warning the RGBA contains id in float pack in 4 unsigned char
	
	var MatteIdsMaterial = function MatteIdsMaterial(otherMaterial) {
	    _BasicMaterial2.default.call(this);
	
	    this.vertexShader = this.vertexShaderHeader + _TileDepthVS2.default;
	    this.fragmentShader = this.fragmentShaderHeader + _MatteIdsFS2.default;
	
	    this.uniforms.uuid.value = otherMaterial.uniforms.uuid.value;
	    this.uniforms.diffuseColor.value = new THREE.Color(Math.random() * 0xffffff); // .setHex( Math.random() * 0xffffff );
	
	    this.uniforms.dTextures_00 = new THREE.Uniform(otherMaterial.textures[0]);
	    this.uniforms.texturesCount = new THREE.Uniform(otherMaterial.loadedTexturesCount[0]);
	    this.uniforms.offsetScale_L00 = new THREE.Uniform(otherMaterial.offsetScale[0]);
	};
	
	MatteIdsMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	MatteIdsMaterial.prototype.constructor = MatteIdsMaterial;
	
	MatteIdsMaterial.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
	    this.uniforms.mVPMatRTC.value = rtc;
	};
	
	exports.default = MatteIdsMaterial;

/***/ },
/* 314 */
/***/ function(module, exports) {

	module.exports = "uniform int  uuid;\nuniform vec3 diffuseColor;\n\nconst vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\nvec4 pack1K ( float depth ) {\n\n    depth /= 10000.0;\n    vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n    res -= res.xxyz * bitMsk;\n    return res;\n}\n\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\t   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    gl_FragColor = pack1K(float(uuid));\n\n}\n"

/***/ },
/* 315 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// state to render
	// According to the state rendering, the material's object switches
	// to the correct state material
	exports.default = {
	    // final color
	    FINAL: 0,
	    // depth buffer
	    DEPTH: 1,
	    // id object
	    ID: 2
	};

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */
	
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';
	
	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}
	
	function isFunction(x) {
	  return typeof x === 'function';
	}
	
	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}
	
	var isArray = _isArray;
	
	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;
	
	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};
	
	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}
	
	function setAsap(asapFn) {
	  asap = asapFn;
	}
	
	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';
	
	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}
	
	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	
	  return useSetTimeout();
	}
	
	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });
	
	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}
	
	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}
	
	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}
	
	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];
	
	    callback(arg);
	
	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }
	
	  len = 0;
	}
	
	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(318);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}
	
	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}
	
	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;
	
	  var parent = this;
	
	  var child = new this.constructor(noop);
	
	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }
	
	  var _state = parent._state;
	
	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }
	
	  return child;
	}
	
	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.resolve(1);
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }
	
	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}
	
	var PROMISE_ID = Math.random().toString(36).substring(16);
	
	function noop() {}
	
	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	
	var GET_THEN_ERROR = new ErrorObject();
	
	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}
	
	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}
	
	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}
	
	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}
	
	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	
	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}
	
	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}
	
	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}
	
	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}
	
	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }
	
	  publish(promise);
	}
	
	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	
	  promise._result = value;
	  promise._state = FULFILLED;
	
	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}
	
	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	
	  asap(publishRejection, promise);
	}
	
	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;
	
	  parent._onerror = null;
	
	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;
	
	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}
	
	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;
	
	  if (subscribers.length === 0) {
	    return;
	  }
	
	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;
	
	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];
	
	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }
	
	  promise._subscribers.length = 0;
	}
	
	function ErrorObject() {
	  this.error = null;
	}
	
	var TRY_CATCH_ERROR = new ErrorObject();
	
	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}
	
	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;
	
	  if (hasCallback) {
	    value = tryCatch(callback, detail);
	
	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }
	
	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }
	
	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}
	
	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}
	
	var id = 0;
	function nextId() {
	  return id++;
	}
	
	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}
	
	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);
	
	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }
	
	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;
	
	    this._result = new Array(this.length);
	
	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}
	
	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};
	
	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;
	
	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};
	
	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;
	
	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);
	
	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};
	
	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;
	
	  if (promise._state === PENDING) {
	    this._remaining--;
	
	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }
	
	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};
	
	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;
	
	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};
	
	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```
	
	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```
	
	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}
	
	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.
	
	  Example:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```
	
	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```
	
	  An example real-world use case is implementing timeouts:
	
	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```
	
	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}
	
	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}
	
	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}
	
	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}
	
	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.
	
	  Terminology
	  -----------
	
	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.
	
	  A promise can be in one of three states: pending, fulfilled, or rejected.
	
	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.
	
	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.
	
	
	  Basic Usage:
	  ------------
	
	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);
	
	    // on failure
	    reject(reason);
	  });
	
	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Advanced Usage:
	  ---------------
	
	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.
	
	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();
	
	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();
	
	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }
	
	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Unlike callbacks, promises are great composable primitives.
	
	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON
	
	    return values;
	  });
	  ```
	
	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];
	
	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}
	
	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;
	
	Promise.prototype = {
	  constructor: Promise,
	
	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,
	
	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};
	
	function polyfill() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }
	
	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }
	
	    local.Promise = Promise;
	}
	
	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;
	
	return Promise;
	
	})));
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(317), (function() { return this; }())))

/***/ },
/* 317 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 318 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 319 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = String(input)
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 320 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;
	
	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}
	
	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */
	
	module.exports = useNative() ? NativeCustomEvent :
	
	// IE >= 9
	'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :
	
	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.proj4 = exports.THREE = exports.GeometryLayer = exports.updateLayeredMaterialNodeElevation = exports.updateLayeredMaterialNodeImagery = exports.initTiledGeometryLayer = exports.processTiledGeometryNode = exports.UNIT = exports.Fetcher = exports.Coordinates = exports.Extent = exports.PlanarView = exports.GlobeView = exports.View = exports.ColorLayersOrdering = exports.CONTROL_EVENTS = exports.GLOBE_VIEW_EVENTS = undefined;
	
	var _ColorLayersOrdering = __webpack_require__(322);
	
	Object.defineProperty(exports, 'ColorLayersOrdering', {
	  enumerable: true,
	  get: function get() {
	    return _ColorLayersOrdering.ColorLayersOrdering;
	  }
	});
	
	var _Coordinates = __webpack_require__(217);
	
	Object.defineProperty(exports, 'UNIT', {
	  enumerable: true,
	  get: function get() {
	    return _Coordinates.UNIT;
	  }
	});
	
	var _TiledNodeProcessing = __webpack_require__(323);
	
	Object.defineProperty(exports, 'processTiledGeometryNode', {
	  enumerable: true,
	  get: function get() {
	    return _TiledNodeProcessing.processTiledGeometryNode;
	  }
	});
	Object.defineProperty(exports, 'initTiledGeometryLayer', {
	  enumerable: true,
	  get: function get() {
	    return _TiledNodeProcessing.initTiledGeometryLayer;
	  }
	});
	
	var _LayeredMaterialNodeProcessing = __webpack_require__(324);
	
	Object.defineProperty(exports, 'updateLayeredMaterialNodeImagery', {
	  enumerable: true,
	  get: function get() {
	    return _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeImagery;
	  }
	});
	Object.defineProperty(exports, 'updateLayeredMaterialNodeElevation', {
	  enumerable: true,
	  get: function get() {
	    return _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeElevation;
	  }
	});
	
	var _Layer = __webpack_require__(265);
	
	Object.defineProperty(exports, 'GeometryLayer', {
	  enumerable: true,
	  get: function get() {
	    return _Layer.GeometryLayer;
	  }
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _proj = __webpack_require__(227);
	
	var _proj2 = _interopRequireDefault(_proj);
	
	var _GlobeControls = __webpack_require__(326);
	
	var _View = __webpack_require__(235);
	
	var _View2 = _interopRequireDefault(_View);
	
	var _GlobeView = __webpack_require__(354);
	
	var _GlobeView2 = _interopRequireDefault(_GlobeView);
	
	var _PlanarView = __webpack_require__(369);
	
	var _PlanarView2 = _interopRequireDefault(_PlanarView);
	
	var _Extent = __webpack_require__(296);
	
	var _Extent2 = _interopRequireDefault(_Extent);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	var _Fetcher = __webpack_require__(287);
	
	var _Fetcher2 = _interopRequireDefault(_Fetcher);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	// Then exported as non-default here.
	exports.GLOBE_VIEW_EVENTS = _GlobeView.GLOBE_VIEW_EVENTS;
	exports.CONTROL_EVENTS = _GlobeControls.CONTROL_EVENTS; // Modules using `default` export must be imported...
	
	exports.View = _View2.default;
	exports.GlobeView = _GlobeView2.default;
	exports.PlanarView = _PlanarView2.default;
	exports.Extent = _Extent2.default;
	exports.Coordinates = _Coordinates2.default;
	exports.Fetcher = _Fetcher2.default;
	
	// Others can be directly exported
	
	// This is temporary, until we're able to build a vendor.js
	// containing our dependencies.
	exports.THREE = THREE;
	exports.proj4 = _proj2.default;

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ColorLayersOrdering = exports.COLOR_LAYERS_ORDER_CHANGED = undefined;
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _Layer = __webpack_require__(265);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function updateLayersOrdering(geometryLayer, imageryLayers) {
	    var sequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);
	    var cO = function cO(object) {
	        if (object.changeSequenceLayers) {
	            object.changeSequenceLayers(sequence);
	        }
	    };
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(geometryLayer.level0Nodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var node = _step.value;
	
	            node.traverse(cO);
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	}
	
	var COLOR_LAYERS_ORDER_CHANGED = exports.COLOR_LAYERS_ORDER_CHANGED = 'layers-order-changed';
	
	var ColorLayersOrdering = exports.ColorLayersOrdering = {
	    /**
	     * Moves up in the layer list. This function has no effect if the layer is moved to its current index.
	     * @function moveLayerUp
	     * @param      {View}  view the viewer
	     * @param      {string}  layerId   The layer's idendifiant
	     * @example
	     * itowns.moveLayerUp(viewer, 'idLayerToUp');
	     */
	    moveLayerUp: function moveLayerUp(view, layerId) {
	        var imageryLayers = view.getLayers(function (l) {
	            return l.type === 'color';
	        });
	        var layer = view.getLayers(function (l) {
	            return l.id === layerId;
	        })[0];
	        if (layer) {
	            var previousSequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);
	            _Layer.ImageryLayers.moveLayerUp(layer, imageryLayers);
	            updateLayersOrdering(view.wgs84TileLayer, imageryLayers);
	            view.dispatchEvent({ type: COLOR_LAYERS_ORDER_CHANGED,
	                previous: { sequence: previousSequence },
	                new: { sequence: _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers) }
	            });
	            view.notifyChange(0, true);
	        } else {
	            throw new Error(layerId + ' isn\'t color layer');
	        }
	    },
	    /**
	     * Moves down in the layer list. This function has no effect if the layer is moved to its current index.
	     * @function moveLayerDown
	     * @param      {View}  view the viewer
	     * @param      {string}  layerId   The layer's idendifiant
	     * @example
	     * itowns.moveLayerDown(viewer, 'idLayerToDown');
	     */
	    moveLayerDown: function moveLayerDown(view, layerId) {
	        var imageryLayers = view.getLayers(function (l) {
	            return l.type === 'color';
	        });
	        var layer = view.getLayers(function (l) {
	            return l.id === layerId;
	        })[0];
	        if (layer) {
	            var previousSequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);
	            _Layer.ImageryLayers.moveLayerDown(layer, imageryLayers);
	            updateLayersOrdering(view.wgs84TileLayer, imageryLayers);
	            view.dispatchEvent({ type: COLOR_LAYERS_ORDER_CHANGED,
	                previous: { sequence: previousSequence },
	                new: { sequence: _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers) }
	            });
	            view.notifyChange(0, true);
	        } else {
	            throw new Error(layerId + ' isn\'t color layer');
	        }
	    },
	    /**
	     * Moves a specific layer to a specific index in the layer list. This function has no effect if the layer is moved to its current index.
	     * @function moveLayerToIndex
	     * @param      {View}  view the viewer
	     * @param      {string}  layerId   The layer's idendifiant
	     * @param      {number}  newIndex   The new index
	     * @example
	     * itowns.moveLayerToIndex(viewer, 'idLayerToChangeIndex', 2);
	     */
	    moveLayerToIndex: function moveLayerToIndex(view, layerId, newIndex) {
	        var imageryLayers = view.getLayers(function (l) {
	            return l.type === 'color';
	        });
	        var layer = view.getLayers(function (l) {
	            return l.id === layerId;
	        })[0];
	        if (layer) {
	            var previousSequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);
	            _Layer.ImageryLayers.moveLayerToIndex(layer, newIndex, imageryLayers);
	            updateLayersOrdering(view.wgs84TileLayer, imageryLayers);
	            view.dispatchEvent({ type: COLOR_LAYERS_ORDER_CHANGED,
	                previous: { sequence: previousSequence },
	                new: { sequence: _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers) }
	            });
	            view.notifyChange(0, true);
	        } else {
	            throw new Error(layerId + ' isn\'t color layer');
	        }
	    }
	};

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	exports.initTiledGeometryLayer = initTiledGeometryLayer;
	exports.processTiledGeometryNode = processTiledGeometryNode;
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Extent = __webpack_require__(296);
	
	var _Extent2 = _interopRequireDefault(_Extent);
	
	var _Scheduler = __webpack_require__(269);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function subdivisionExtents(bbox) {
	    var center = bbox.center();
	
	    var northWest = new _Extent2.default(bbox.crs(), bbox.west(), center._values[0], center._values[1], bbox.north());
	    var northEast = new _Extent2.default(bbox.crs(), center._values[0], bbox.east(), center._values[1], bbox.north());
	    var southWest = new _Extent2.default(bbox.crs(), bbox.west(), center._values[0], bbox.south(), center._values[1]);
	    var southEast = new _Extent2.default(bbox.crs(), center._values[0], bbox.east(), bbox.south(), center._values[1]);
	
	    // scheme tiles store their coordinates in radians internally,
	    // so we need to fix the new bboxes as well
	    var result = [northWest, northEast, southWest, southEast];
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(result), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var r = _step.value;
	
	            r._internalStorageUnit = bbox._internalStorageUnit;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return result;
	}
	
	function requestNewTile(view, scheduler, geometryLayer, extent, parent, level) {
	    var command = {
	        /* mandatory */
	        view: view,
	        requester: parent,
	        layer: geometryLayer,
	        priority: 10000,
	        /* specific params */
	        extent: extent,
	        level: level,
	        redraw: false,
	        threejsLayer: geometryLayer.threejsLayer
	    };
	
	    return scheduler.execute(command).then(function (node) {
	        node.add(node.OBB());
	        return node;
	    });
	}
	
	function subdivideNode(context, layer, node, initNewNode) {
	    if (!node.pendingSubdivision && !node.children.some(function (n) {
	        return n.layer == layer.id;
	    })) {
	        (function () {
	            var extents = subdivisionExtents(node.extent);
	            // TODO: pendingSubdivision mechanism is fragile, get rid of it
	            node.pendingSubdivision = true;
	
	            var promises = [];
	            var children = [];
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                for (var _iterator2 = (0, _getIterator3.default)(extents), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    var extent = _step2.value;
	
	                    promises.push(requestNewTile(context.view, context.scheduler, layer, extent, node).then(function (child) {
	                        children.push(child);
	                        initNewNode(context, layer, node, child);
	                        return node;
	                    }));
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            _promise2.default.all(promises).then(function () {
	                var _iteratorNormalCompletion3 = true;
	                var _didIteratorError3 = false;
	                var _iteratorError3 = undefined;
	
	                try {
	                    for (var _iterator3 = (0, _getIterator3.default)(children), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                        var child = _step3.value;
	
	                        node.add(child);
	                        child.updateMatrixWorld(true);
	                        child.OBB().update();
	
	                        child.material.uniforms.lightPosition.value = node.material.uniforms.lightPosition.value;
	                        child.material.uniforms.lightingEnabled.value = node.material.uniforms.lightingEnabled.value;
	                    }
	                    // TODO
	                    /*
	                      if (child.material.elevationLayersId.length) {
	                        // need to force update elevation when delta is important
	                        if (child.level - child.material.getElevationLayerLevel() > 6) {
	                            updateNodeElevation(_this.scene, params.tree, child, params.layersConfig, true);
	                        }
	                    }
	                    */
	                } catch (err) {
	                    _didIteratorError3 = true;
	                    _iteratorError3 = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                            _iterator3.return();
	                        }
	                    } finally {
	                        if (_didIteratorError3) {
	                            throw _iteratorError3;
	                        }
	                    }
	                }
	
	                node.pendingSubdivision = false;
	                context.view.notifyChange(0, false);
	            }, function (err) {
	                node.pendingSubdivision = false;
	                if (!(err instanceof _Scheduler.CancelledCommandException)) {
	                    throw new Error(err);
	                }
	            });
	        })();
	    }
	}
	
	function initTiledGeometryLayer(schemeTile) {
	    var _promises = [];
	    return function _initTiledGeometryLayer(context, layer) {
	        if (_promises.length > 0) {
	            return;
	        }
	
	        layer.level0Nodes = [];
	
	        for (var i = 0; i < schemeTile.rootCount(); i++) {
	            _promises.push(requestNewTile(context.view, context.scheduler, layer, schemeTile.getRoot(i), undefined, 0));
	        }
	        _promise2.default.all(_promises).then(function (level0s) {
	            layer.level0Nodes = level0s;
	            var _iteratorNormalCompletion4 = true;
	            var _didIteratorError4 = false;
	            var _iteratorError4 = undefined;
	
	            try {
	                for (var _iterator4 = (0, _getIterator3.default)(level0s), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                    var level0 = _step4.value;
	
	                    // TODO: support a layer.root attribute, to be able
	                    // to add a layer to a three.js node, e.g:
	                    // layer.root.add(level0);
	                    context.view.scene.add(level0);
	                    level0.updateMatrixWorld();
	                }
	            } catch (err) {
	                _didIteratorError4 = true;
	                _iteratorError4 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                        _iterator4.return();
	                    }
	                } finally {
	                    if (_didIteratorError4) {
	                        throw _iteratorError4;
	                    }
	                }
	            }
	        });
	    };
	}
	
	function _removeChildren(layer, node) {
	    // remove children
	    for (var i = 0; i < node.children.length;) {
	        if (node.children[i].layer === layer.id) {
	            // TODO: consider cancelling pending commands from this node
	            node.children[i].dispose();
	            node.children.splice(i, 1);
	        } else {
	            i++;
	        }
	    }
	}
	
	function processTiledGeometryNode(cullingTest, subdivisionTest, initNewNode) {
	    return function _processTiledGeometryNode(context, layer, node) {
	        // early exit if parent' subdivision is in progress
	        if (node.parent.pendingSubdivision) {
	            node.visible = false;
	            node.setDisplayed(false);
	            return undefined;
	        }
	
	        // do proper culling
	        var isVisible = cullingTest ? !cullingTest(node, context.camera) : true;
	        node.visible = isVisible;
	
	        if (isVisible) {
	            var requestChildrenUpdate = false;
	
	            if (node.pendingSubdivision || subdivisionTest(context, layer, node)) {
	                subdivideNode(context, layer, node, initNewNode);
	                // display iff children aren't ready
	                node.setDisplayed(node.pendingSubdivision);
	                requestChildrenUpdate = true;
	            } else {
	                node.setDisplayed(true);
	            }
	
	            if (node.material.visible) {
	                // update uniforms
	                var positionWorld = new THREE.Vector3();
	                positionWorld.setFromMatrixPosition(node.matrixWorld);
	                node.setMatrixRTC(context.engine.getRTCMatrixFromCenter(positionWorld, context.camera));
	                node.setFog(1000000000);
	
	                if (!requestChildrenUpdate) {
	                    _removeChildren(layer, node);
	                }
	            }
	
	            // TODO: use Array.slice()
	            return requestChildrenUpdate ? node.children.filter(function (n) {
	                return n.layer == layer.id;
	            }) : undefined;
	        }
	
	        node.setDisplayed(false);
	        _removeChildren(layer, node);
	
	        return undefined;
	    };
	}

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	exports.updateLayeredMaterialNodeImagery = updateLayeredMaterialNodeImagery;
	exports.updateLayeredMaterialNodeElevation = updateLayeredMaterialNodeElevation;
	
	var _RendererConstant = __webpack_require__(315);
	
	var _RendererConstant2 = _interopRequireDefault(_RendererConstant);
	
	var _LayeredMaterial = __webpack_require__(302);
	
	var _LayerUpdateStrategy = __webpack_require__(264);
	
	var _LayerUpdateState = __webpack_require__(325);
	
	var _LayerUpdateState2 = _interopRequireDefault(_LayerUpdateState);
	
	var _Layer = __webpack_require__(265);
	
	var _Scheduler = __webpack_require__(269);
	
	var _OGCWebServiceHelper = __webpack_require__(286);
	
	var _OGCWebServiceHelper2 = _interopRequireDefault(_OGCWebServiceHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function initNodeImageryTexturesFromParent(node, parent, layer) {
	    if (parent.material && parent.material.getColorLayerLevelById(layer.id) > _LayeredMaterial.EMPTY_TEXTURE_ZOOM) {
	        var coords = node.getCoordsForLayer(layer);
	        var offsetTextures = node.material.getLayerTextureOffset(layer.id);
	
	        var textureIndex = offsetTextures;
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = (0, _getIterator3.default)(coords), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var c = _step.value;
	                var _iteratorNormalCompletion2 = true;
	                var _didIteratorError2 = false;
	                var _iteratorError2 = undefined;
	
	                try {
	                    for (var _iterator2 = (0, _getIterator3.default)(parent.materials[0].getLayerTextures(_LayeredMaterial.l_COLOR, layer.id)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                        var texture = _step2.value;
	
	                        if (c.isInside(texture.coords)) {
	                            var result = c.offsetToParent(texture.coords);
	                            node.material.textures[_LayeredMaterial.l_COLOR][textureIndex] = texture;
	                            node.material.offsetScale[_LayeredMaterial.l_COLOR][textureIndex] = result;
	                            textureIndex++;
	                            break;
	                        }
	                    }
	                } catch (err) {
	                    _didIteratorError2 = true;
	                    _iteratorError2 = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                            _iterator2.return();
	                        }
	                    } finally {
	                        if (_didIteratorError2) {
	                            throw _iteratorError2;
	                        }
	                    }
	                }
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	
	        if (false) {
	            if (textureIndex - offsetTextures != coords.length) {
	                /* eslint-disable */
	                console.error('non-coherent result ' + textureIndex + ' ' + offsetTextures + ' vs ' + coords.length + '. ' + coords);
	                /* eslint-enable */
	            }
	        }
	        var index = node.material.indexOfColorLayer(layer.id);
	        node.material.layerTexturesCount[index] = coords.length;
	        node.material.loadedTexturesCount[_LayeredMaterial.l_COLOR] += coords.length;
	    }
	}
	
	function initNodeElevationTextureFromParent(node, parent, layer) {
	    // inherit parent's elevation texture
	    if (parent.material && parent.material.getElevationLayerLevel() > _LayeredMaterial.EMPTY_TEXTURE_ZOOM) {
	        var coords = node.getCoordsForLayer(layer);
	
	        var texture = parent.material.textures[_LayeredMaterial.l_ELEVATION][0];
	        var pitch = coords[0].offsetToParent(parent.material.textures[_LayeredMaterial.l_ELEVATION][0].coords);
	        var elevation = {
	            texture: texture,
	            pitch: pitch
	        };
	
	        // If the texture resolution has a poor precision for this node, we don't
	        // extract min-max from the texture (too few information), we instead chose
	        // to use parent's min-max.
	        var useMinMaxFromParent = node.level - texture.coords.zoom > 6;
	        if (!useMinMaxFromParent) {
	            var _OGCWebServiceHelper$ = _OGCWebServiceHelper2.default.ioDXBIL.computeMinMaxElevation(texture.image.data, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, _OGCWebServiceHelper.SIZE_TEXTURE_TILE, pitch),
	                min = _OGCWebServiceHelper$.min,
	                max = _OGCWebServiceHelper$.max;
	
	            elevation.min = min;
	            elevation.max = max;
	        }
	
	        node.setTextureElevation(elevation);
	        node.material.elevationLayersId = parent.material.elevationLayersId;
	    }
	}
	
	function nodeCommandQueuePriorityFunction(node) {
	    // We know that 'node' is visible because commands can only be
	    // issued for visible nodes.
	
	    // TODO: need priorization of displayed nodes
	    if (node.isDisplayed()) {
	        // Then prefer displayed() node over non-displayed one
	        return 100;
	    } else {
	        return 10;
	    }
	}
	
	function refinementCommandCancellationFn(cmd) {
	    if (!cmd.requester.parent || !cmd.requester.material) {
	        return true;
	    }
	    if (cmd.force) {
	        return false;
	    }
	
	    return !cmd.requester.isDisplayed();
	}
	
	function updateLayeredMaterialNodeImagery(context, layer, node) {
	    if (!layer.tileInsideLimit(node, layer)) {
	        // we also need to check that tile's parent doesn't have a texture for this layer,
	        // because even if this tile is outside of the layer, it could inherit it's
	        // parent texture
	        if (node.parent && node.parent.getIndexLayerColor && node.parent.getIndexLayerColor(layer.id) >= 0) {
	            // ok, we're going to inherint our parent's texture
	        } else {
	            return _promise2.default.resolve();
	        }
	    }
	
	    var material = node.materials[_RendererConstant2.default.FINAL];
	
	    if (material.indexOfColorLayer(layer.id) === -1) {
	        var texturesCount = layer.tileTextureCount ? layer.tileTextureCount(node, layer) : 1;
	
	        var paramMaterial = {
	            tileMT: layer.options.tileMatrixSet,
	            texturesCount: texturesCount,
	            visible: layer.visible,
	            opacity: layer.opacity,
	            fx: layer.fx,
	            idLayer: layer.id
	        };
	
	        material.pushLayer(paramMaterial);
	        var imageryLayers = context.view.getLayers(function (l) {
	            return l.type === 'color';
	        });
	        var sequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);
	        material.setSequence(sequence);
	
	        initNodeImageryTexturesFromParent(node, node.parent, layer);
	    }
	
	    if (!node.isDisplayed()) {
	        return;
	    }
	
	    if (!layer.tileInsideLimit(node, layer)) {
	        return _promise2.default.resolve();
	    }
	
	    // upate params
	    var layerIndex = material.indexOfColorLayer(layer.id);
	    material.setLayerVisibility(layerIndex, layer.visible);
	    material.setLayerOpacity(layerIndex, layer.opacity);
	
	    var ts = Date.now();
	
	    if (node.layerUpdateState[layer.id] === undefined) {
	        node.layerUpdateState[layer.id] = new _LayerUpdateState2.default();
	    }
	
	    if (!node.layerUpdateState[layer.id].canTryUpdate(ts)) {
	        return _promise2.default.resolve();
	    }
	
	    // does this tile needs a new texture?
	    if (!node.isColorLayerDownscaled(layer)) {
	        return _promise2.default.resolve();
	    }
	    // is fetching data from this layer disabled?
	    if (!layer.visible || layer.frozen) {
	        return _promise2.default.resolve();
	    }
	
	    var currentLevel = node.materials[_RendererConstant2.default.FINAL].getColorLayerLevelById(layer.id);
	
	    if (currentLevel > _LayeredMaterial.EMPTY_TEXTURE_ZOOM) {
	        var zoom = node.getCoordsForLayer(layer)[0].zoom || node.level;
	        var targetLevel = (0, _LayerUpdateStrategy.chooseNextLevelToFetch)(layer.updateStrategy.type, zoom, currentLevel, layer.updateStrategy.options);
	        if (targetLevel <= currentLevel) {
	            return _promise2.default.resolve();
	        }
	    }
	    // TODO: targetLevel shouldn't be ignored
	
	    node.layerUpdateState[layer.id].newTry();
	    var command = {
	        /* mandatory */
	        view: context.view,
	        layer: layer,
	        requester: node,
	        priority: nodeCommandQueuePriorityFunction(node),
	        earlyDropFunction: refinementCommandCancellationFn
	    };
	
	    return context.scheduler.execute(command).then(function (result) {
	        if (node.material === null) {
	            return;
	        }
	
	        if (Array.isArray(result)) {
	            node.setTexturesLayer(result, _LayeredMaterial.l_COLOR, layer.id);
	        } else if (result.texture) {
	            node.setTexturesLayer([result], _LayeredMaterial.l_COLOR, layer.id);
	        } else {
	            // TODO: null texture is probably an error
	            // Maybe add an error counter for the node/layer,
	            // and stop retrying after X attempts.
	        }
	
	        node.layerUpdateState[layer.id].success();
	
	        return result;
	    }, function (err) {
	        if (err instanceof _Scheduler.CancelledCommandException) {
	            node.layerUpdateState[layer.id].success();
	        } else {
	            node.layerUpdateState[layer.id].failure(Date.now());
	            context.view.notifyChange(node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000, false);
	        }
	    });
	}
	
	function updateLayeredMaterialNodeElevation(context, layer, node, force) {
	    // TODO: we need either
	    //  - compound or exclusive layers
	    //  - support for multiple elevation layers
	
	    // Elevation is currently handled differently from color layers.
	    // This is caused by a LayeredMaterial limitation: only 1 elevation texture
	    // can be used (where a tile can have N textures x M layers)
	    var ts = Date.now();
	
	    var material = node.materials[_RendererConstant2.default.FINAL];
	    var currentElevation = material.getElevationLayerLevel();
	
	    // If currentElevevation is EMPTY_TEXTURE_ZOOM but material.loadedTexturesCount[l_ELEVATION] is > 0
	    // means that we already tried and failed to download an elevation texture
	    if (currentElevation == _LayeredMaterial.EMPTY_TEXTURE_ZOOM && node.materials[0].loadedTexturesCount[_LayeredMaterial.l_ELEVATION] > 0) {
	        return _promise2.default.resolve();
	    }
	    if (layer.frozen && !force) {
	        return _promise2.default.resolve();
	    }
	
	    if (node.layerUpdateState[layer.id] === undefined) {
	        node.layerUpdateState[layer.id] = new _LayerUpdateState2.default();
	        initNodeElevationTextureFromParent(node, node.parent, layer);
	        currentElevation = material.getElevationLayerLevel();
	    }
	    if (!node.isDisplayed()) {
	        return;
	    }
	
	    if (!node.layerUpdateState[layer.id].canTryUpdate(ts)) {
	        return _promise2.default.resolve();
	    }
	
	    var c = node.getCoordsForLayer(layer)[0];
	    var zoom = c.zoom || node.level;
	    var targetLevel = (0, _LayerUpdateStrategy.chooseNextLevelToFetch)(layer.updateStrategy.type, zoom, currentElevation, layer.updateStrategy.options);
	
	    if (targetLevel <= currentElevation || !layer.tileInsideLimit(node, layer, targetLevel)) {
	        return _promise2.default.resolve();
	    }
	
	    // TODO
	    if (material.elevationLayersId.length === 0) {
	        material.elevationLayersId.push(layer.id);
	    }
	    node.layerUpdateState[layer.id].newTry();
	
	    var command = {
	        /* mandatory */
	        view: context.view,
	        layer: layer,
	        requester: node,
	        targetLevel: targetLevel,
	        priority: nodeCommandQueuePriorityFunction(node),
	        earlyDropFunction: refinementCommandCancellationFn,
	        force: force
	    };
	
	    return context.scheduler.execute(command).then(function (terrain) {
	        if (node.material === null) {
	            return;
	        }
	
	        node.layerUpdateState[layer.id].success();
	
	        if (terrain.texture && terrain.texture.flipY) {
	            // DataTexture default to false, so make sure other Texture types
	            // do the same (eg image texture)
	            // See UV construction for more details
	            terrain.texture.flipY = false;
	            terrain.texture.needsUpdate = true;
	        }
	        node.setTextureElevation(terrain);
	    }, function (err) {
	        if (err instanceof _Scheduler.CancelledCommandException) {
	            node.layerUpdateState[layer.id].success();
	        } else {
	            node.layerUpdateState[layer.id].failure(Date.now());
	            context.view.notifyChange(node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000, false);
	        }
	    });
	}

/***/ },
/* 325 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var UPDATE_STATE = {
	    IDLE: 0,
	    PENDING: 1,
	    ERROR: 2,
	    DEFINITIVE_ERROR: 3
	};
	var PAUSE_BETWEEN_ERRORS = [1.0, 3.0, 7.0, 60.0];
	
	/**
	 * LayerUpdateState is the update state of a layer, for a given object (e.g tile).
	 * It stores information to allow smart update decisions, and especially network
	 * error handling.
	 */
	function LayerUpdateState() {
	    this.state = UPDATE_STATE.IDLE;
	    this.lastErrorTimestamp = 0;
	    this.errorCount = 0;
	}
	
	LayerUpdateState.prototype.canTryUpdate = function canTryUpdate(timestamp) {
	    switch (this.state) {
	        case UPDATE_STATE.IDLE:
	            {
	                return true;
	            }
	        case UPDATE_STATE.DEFINITIVE_ERROR:
	        case UPDATE_STATE.PENDING:
	            {
	                return false;
	            }
	        case UPDATE_STATE.ERROR:
	        default:
	            {
	                var errorDuration = this.secondsUntilNextTry() * 1000;
	                return errorDuration <= timestamp - this.lastErrorTimestamp;
	            }
	    }
	};
	
	LayerUpdateState.prototype.secondsUntilNextTry = function secondsUntilNextTry() {
	    if (this.state !== UPDATE_STATE.ERROR) {
	        return 0;
	    }
	    var idx = Math.max(0, Math.min(this.errorCount, PAUSE_BETWEEN_ERRORS.length) - 1);
	
	    return PAUSE_BETWEEN_ERRORS[idx];
	};
	
	LayerUpdateState.prototype.newTry = function newTry() {
	    this.state = UPDATE_STATE.PENDING;
	};
	
	LayerUpdateState.prototype.success = function success() {
	    this.lastErrorTimestamp = 0;
	    this.state = UPDATE_STATE.IDLE;
	};
	
	LayerUpdateState.prototype.failure = function failure(timestamp, definitive) {
	    this.lastErrorTimestamp = timestamp;
	    this.state = definitive ? UPDATE_STATE.DEFINITIVE_ERROR : UPDATE_STATE.ERROR;
	    this.errorCount++;
	};
	
	exports.default = LayerUpdateState;

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.CONTROL_EVENTS = undefined;
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Sphere = __webpack_require__(327);
	
	var _Sphere2 = _interopRequireDefault(_Sphere);
	
	var _AnimationPlayer = __webpack_require__(328);
	
	var _AnimationPlayer2 = _interopRequireDefault(_AnimationPlayer);
	
	var _Coordinates = __webpack_require__(217);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	var _GlobeTileProcessing = __webpack_require__(352);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// TODO:
	// Recast touch for globe
	// Fix target problem with pan and panoramic (when target isn't on globe)
	// Fix problem with space
	// Add real collision
	
	// FIXME:
	// when move globe in damping orbit, there isn't move!!
	
	var CONTROL_STATE = {
	    NONE: -1,
	    ORBIT: 0,
	    DOLLY: 1,
	    PAN: 2,
	    TOUCH_ROTATE: 3,
	    TOUCH_DOLLY: 4,
	    TOUCH_PAN: 5,
	    MOVE_GLOBE: 6,
	    PANORAMIC: 7
	};
	
	// The control's keys
	// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
	// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
	// supported.
	//
	//    Orbit - left mouse / touch: one finger move
	//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	//    Pan - right mouse, or arrow keys / touch: three finter swipe
	
	var CONTROL_KEYS = {
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    BOTTOM: 40,
	    SPACE: 32,
	    SHIFT: 16,
	    CTRL: 17,
	    S: 83
	};
	
	// TODO: can be optimize for some uses
	var presiceSlerp = function presiceSlerp(qb, t) {
	    if (t === 0) {
	        return this;
	    }
	
	    if (t === 1) {
	        return this.copy(qb);
	    }
	
	    var x = this._x;
	    var y = this._y;
	    var z = this._z;
	    var w = this._w;
	
	    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
	    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
	    if (cosHalfTheta < 0) {
	        this._w = -qb._w;
	        this._x = -qb._x;
	        this._y = -qb._y;
	        this._z = -qb._z;
	
	        cosHalfTheta = -cosHalfTheta;
	    } else {
	        this.copy(qb);
	    }
	
	    if (cosHalfTheta >= 1.0) {
	        this._w = w;
	        this._x = x;
	        this._y = y;
	        this._z = z;
	
	        return this;
	    }
	
	    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
	    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
	    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
	    var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	
	    this._w = w * ratioA + this._w * ratioB;
	    this._x = x * ratioA + this._x * ratioB;
	    this._y = y * ratioA + this._y * ratioB;
	    this._z = z * ratioA + this._z * ratioB;
	
	    this.onChangeCallback();
	
	    return this;
	};
	
	// private members
	var space = false;
	var EPS = 0.000001;
	
	// Orbit
	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();
	var spherical = new THREE.Spherical(1.0, 0.01, Math.PI * 0.5);
	var snapShotSpherical = new THREE.Spherical(1.0, 0.01, Math.PI * 0.5);
	var sphericalDelta = new THREE.Spherical(1.0, 0, 0);
	var sphericalTo = new THREE.Spherical();
	var orbit = {
	    spherical: spherical,
	    sphericalDelta: sphericalDelta,
	    sphericalTo: sphericalTo,
	    scale: 1
	};
	
	// Pan
	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();
	var panOffset = new THREE.Vector3();
	
	var offset = new THREE.Vector3();
	
	// Dolly
	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();
	
	// Globe move
	var quatGlobe = new THREE.Quaternion();
	var cameraTargetOnGlobe = new THREE.Object3D();
	var movingCameraTargetOnGlobe = new THREE.Vector3();
	var animatedScale = 0.0;
	
	var ctrl = {
	    progress: 0,
	    quatGlobe: quatGlobe,
	    qDelta: new THREE.Quaternion(),
	    dampingFactor: 0.25
	};
	
	ctrl.qDelta.presiceSlerp = presiceSlerp;
	quatGlobe.presiceSlerp = presiceSlerp;
	
	// Animation
	
	var enableAnimation = true;
	
	// Animation player
	var player = null;
	// Save 2 last rotation globe for damping
	var lastRotation = [];
	
	// Expression used to damp camera's moves
	var dampingMoveAnimatedExpression = function getDampMoveAniExprFn() {
	    var damp = new THREE.Quaternion(0, 0, 0, 1);
	    return function dampingMoveAnimatedExpression(root) {
	        root.qDelta.presiceSlerp(damp, root.dampingFactor * 0.2);
	        root.quatGlobe.multiply(root.qDelta);
	    };
	}();
	
	// Expression used to animate camera's moves and zoom
	var zoomCenterAnimatedExpression = function zoomCenterAnimatedExpression(root, progress) {
	    root.quatGlobe.set(0, 0, 0, 1);
	    root.progress = 1 - Math.pow(1 - (Math.sin((progress - 0.5) * Math.PI) * 0.5 + 0.5), 2);
	    root.quatGlobe.presiceSlerp(root.qDelta, root.progress);
	};
	
	// Expression used to damp camera's moves
	var animationOrbitExpression = function animationOrbitExpression(root, progress) {
	    root.scale = 1.0 - (1.0 - root.sphericalTo.radius / root.spherical.radius) * progress;
	    root.sphericalDelta.theta = root.sphericalTo.theta;
	    root.sphericalDelta.phi = root.sphericalTo.phi;
	};
	
	// Animations
	var animationDampingMove = new _AnimationPlayer.AnimatedExpression({ duration: 120, root: ctrl, expression: dampingMoveAnimatedExpression, name: 'damping-move' });
	var animationZoomCenter = new _AnimationPlayer.AnimatedExpression({ duration: 45, root: ctrl, expression: zoomCenterAnimatedExpression, name: 'Zoom Center' });
	var animationOrbit = new _AnimationPlayer.AnimatedExpression({ duration: 30, root: orbit, expression: animationOrbitExpression, name: 'set Orbit' });
	var dampingOrbitalMvt = new _AnimationPlayer.Animation({ duration: 60, name: 'damping-orbit' });
	
	// Replace matrix float by matrix double
	cameraTargetOnGlobe.matrixWorld.elements = new Float64Array(16);
	cameraTargetOnGlobe.matrixWorldInverse = new THREE.Matrix4();
	cameraTargetOnGlobe.matrixWorldInverse.elements = new Float64Array(16);
	
	// Pan Move
	var panVector = new THREE.Vector3();
	
	// Save last transformation
	var lastPosition = new THREE.Vector3();
	var lastQuaternion = new THREE.Quaternion();
	
	// State control
	var state = CONTROL_STATE.NONE;
	
	// Initial transformation
	var initialTarget;
	var initialPosition;
	var initialZoom;
	
	// picking
	var ptScreenClick = new THREE.Vector2();
	var sizeRendering = new THREE.Vector2();
	
	// Tangent sphere to ellipsoid
	var tSphere = new _Sphere2.default();
	tSphere.picking = { position: new THREE.Vector3(), normal: new THREE.Vector3() };
	
	// Special key
	var keyCtrl = false;
	var keyShift = false;
	var keyS = false;
	
	// Set to true to enable target helper
	var enableTargetHelper = false;
	var pickingHelper = void 0;
	
	if (enableTargetHelper) {
	    pickingHelper = new THREE.AxisHelper(500000);
	}
	
	// Handle function
	var _handlerMouseMove;
	var _handlerMouseUp;
	
	var _getPickingPosition = void 0;
	
	// Pseudo collision
	var radiusCollision = 50;
	
	// Event
	var enableEventPositionChanged = true;
	
	/**
	 * globe controls events
	 * @property PAN_CHANGED {string} emit after camera pan
	 * @property ORIENTATION_CHANGED {string} emit when camera's orientation is changed
	 * @property RANGE_CHANGED {string} emit when camera's range to target is changed
	 * @property CAMERA_TARGET_CHANGED {string} emit when camera's target is changed
	 * @example
	 * viewer.controls.addEventListener(itowns.CONTROL_EVENTS.PAN_CHANGED, (event) => console.log(event));
	 */
	var CONTROL_EVENTS = exports.CONTROL_EVENTS = {
	    PAN_CHANGED: 'pan-changed',
	    ORIENTATION_CHANGED: 'orientation-changed',
	    RANGE_CHANGED: 'range-changed',
	    CAMERA_TARGET_CHANGED: 'camera-target-changed'
	};
	
	// SnapCamera saves transformation's camera
	// It's use to globe move
	function SnapCamera(camera) {
	    camera.updateMatrixWorld();
	
	    this.matrixWorld = new THREE.Matrix4();
	    this.projectionMatrix = new THREE.Matrix4();
	    this.invProjectionMatrix = new THREE.Matrix4();
	    this.position = new THREE.Vector3();
	
	    this.matrixWorld.elements = new Float64Array(16);
	    this.projectionMatrix.elements = new Float64Array(16);
	    this.invProjectionMatrix.elements = new Float64Array(16);
	
	    this.init = function init(camera) {
	        this.matrixWorld.elements.set(camera.matrixWorld.elements);
	        this.projectionMatrix.elements.set(camera.projectionMatrix.elements);
	        this.position.copy(camera.position);
	        this.invProjectionMatrix.getInverse(this.projectionMatrix);
	    };
	
	    this.init(camera);
	
	    this.shot = function shot(objectToSnap) {
	        objectToSnap.updateMatrixWorld();
	        this.matrixWorld.elements.set(objectToSnap.matrixWorld.elements);
	        this.position.copy(objectToSnap.position);
	    };
	
	    var matrix = new THREE.Matrix4();
	    matrix.elements = new Float64Array(16);
	
	    this.updateRay = function updateRay(ray, mouse) {
	        ray.origin.copy(this.position);
	        ray.direction.set(mouse.x, mouse.y, 0.5);
	        matrix.multiplyMatrices(this.matrixWorld, this.invProjectionMatrix);
	        ray.direction.applyMatrix4(matrix);
	        ray.direction.sub(ray.origin).normalize();
	    };
	}
	
	var snapShotCamera = null;
	
	function defer() {
	    var deferedPromise = {};
	    deferedPromise.promise = new _promise2.default(function (resolve, reject) {
	        deferedPromise.resolve = resolve;
	        deferedPromise.reject = reject;
	    });
	    return deferedPromise;
	}
	
	/* globals document,window */
	
	/** @class GlobeControls */
	function GlobeControls(view, target, domElement, viewerDiv, radius, getPickingPosition) {
	    var _this5 = this;
	
	    player = new _AnimationPlayer2.default();
	    this._view = view;
	    this.camera = view.camera.camera3D;
	
	    snapShotCamera = new SnapCamera(this.camera);
	    _getPickingPosition = getPickingPosition;
	
	    this.domElement = domElement !== undefined ? domElement : document;
	
	    this.waitSceneLoaded = function waitSceneLoaded() {
	        var deferedPromise = defer();
	        this._view.mainLoop.addEventListener('command-queue-empty', function () {
	            deferedPromise.resolve();
	        });
	        return deferedPromise.promise;
	    };
	
	    // Set to false to disable this control
	    this.enabled = true;
	
	    // This option actually enables dollying in and out; left as "zoom" for
	    // backwards compatibility
	    this.enableZoom = true;
	    this.zoomSpeed = 1.0;
	
	    // Limits to how far you can dolly in and out ( PerspectiveCamera only )
	    this.minDistance = radiusCollision;
	    this.maxDistance = Infinity;
	
	    // Limits to how far you can zoom in and out ( OrthographicCamera only )
	    this.minZoom = 0;
	    this.maxZoom = Infinity;
	
	    // Set to true to disable this control
	    this.enableRotate = true;
	    this.rotateSpeed = 1.0;
	
	    // Set to true to disable this control
	    this.enablePan = true;
	    this.keyPanSpeed = 7.0; // pixels moved per arrow key push
	
	    // Set to true to automatically rotate around the target
	    this.autoRotate = false;
	    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
	
	    // How far you can orbit vertically, upper and lower limits.
	    // Range is 0 to Math.PI radians.
	    // TODO Warning minPolarAngle = 0.01 -> it isn't possible to be perpendicular on Globe
	    this.minPolarAngle = 0.01; // radians
	    this.maxPolarAngle = Math.PI * 0.5; // radians
	
	    // How far you can orbit horizontally, upper and lower limits.
	    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	    this.minAzimuthAngle = -Infinity; // radians
	    this.maxAzimuthAngle = Infinity; // radians
	
	    // Set to true to disable use of the keys
	    this.enableKeys = true;
	
	    // Enable Damping
	    this.enableDamping = true;
	
	    if (enableTargetHelper) {
	        this.pickingHelper = new THREE.AxisHelper(500000);
	    }
	
	    // Mouse buttons
	    this.mouseButtons = {
	        PANORAMIC: THREE.MOUSE.LEFT,
	        ZOOM: THREE.MOUSE.MIDDLE,
	        PAN: THREE.MOUSE.RIGHT
	    };
	
	    // Radius tangent sphere
	    tSphere.setRadius(radius);
	    spherical.radius = tSphere.radius;
	
	    sizeRendering.copy(view.mainLoop.gfxEngine.getWindowSize());
	    sizeRendering.FOV = this.camera.fov;
	    // Note A
	    // TODO: test before remove test code
	    // so camera.up is the orbit axis
	    // var quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
	    // var quatInverse = quat.clone().inverse();
	
	    // events
	    this.changeEvent = {
	        type: 'change'
	    };
	    this.startEvent = {
	        type: 'start'
	    };
	    this.endEvent = {
	        type: 'end'
	    };
	
	    this.updateCamera = function updateCamera(camera, width, height) {
	        snapShotCamera.init(camera.camera3D);
	        sizeRendering.width = width;
	        sizeRendering.height = height;
	        sizeRendering.FOV = camera.fov;
	    };
	
	    this.getAutoRotationAngle = function getAutoRotationAngle() {
	        return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
	    };
	
	    this.getDollyScale = function getDollyScale() {
	        return Math.pow(0.95, this.zoomSpeed);
	    };
	
	    this.rotateLeft = function rotateLeft(angle) {
	        if (angle === undefined) {
	            angle = this.getAutoRotationAngle();
	        }
	        sphericalDelta.theta -= angle;
	    };
	
	    this.rotateUp = function rotateUp(angle) {
	        if (angle === undefined) {
	            angle = this.getAutoRotationAngle();
	        }
	
	        sphericalDelta.phi -= angle;
	    };
	
	    // pass in distance in world space to move left
	    this.panLeft = function panLeft(distance) {
	        var te = this.camera.matrix.elements;
	
	        // get X column of matrix
	        panOffset.set(te[0], te[1], te[2]);
	        panOffset.multiplyScalar(-distance);
	
	        panVector.add(panOffset);
	    };
	
	    // pass in distance in world space to move up
	    this.panUp = function panUp(distance) {
	        var te = this.camera.matrix.elements;
	
	        // get Y column of matrix
	        panOffset.set(te[4], te[5], te[6]);
	        panOffset.multiplyScalar(distance);
	
	        panVector.add(panOffset);
	    };
	
	    // pass in x,y of change desired in pixel space,
	    // right and down are positive
	    this.mouseToPan = function mouseToPan(deltaX, deltaY) {
	        var element = this.domElement === document ? this.domElement.body : this.domElement;
	
	        if (this.camera instanceof THREE.PerspectiveCamera) {
	            // perspective
	            var position = this.camera.position;
	
	            // var offset = position.clone().sub(this.target);
	            var offset = position.clone().sub(this.getCameraTargetPosition());
	
	            var targetDistance = offset.length();
	
	            // half of the fov is center to top of screen
	            targetDistance *= Math.tan(this.camera.fov / 2 * Math.PI / 180.0);
	
	            // we actually don't use screenWidth, since perspective camera is fixed to screen height
	            this.panLeft(2 * deltaX * targetDistance / element.clientHeight);
	            this.panUp(2 * deltaY * targetDistance / element.clientHeight);
	        } else if (this.camera instanceof THREE.OrthographicCamera) {
	            // orthographic
	            this.panLeft(deltaX * (this.camera.right - this.camera.left) / element.clientWidth);
	            this.panUp(deltaY * (this.camera.top - this.camera.bottom) / element.clientHeight);
	        } else {
	
	            // camera neither orthographic or perspective
	            // console.warn('WARNING: GlobeControls.js encountered an unknown camera type - this.mouseToPan disabled.');
	
	        }
	    };
	
	    this.dollyIn = function dollyIn(dollyScale) {
	        if (dollyScale === undefined) {
	            dollyScale = this.getDollyScale();
	        }
	
	        if (this.camera instanceof THREE.PerspectiveCamera) {
	            orbit.scale /= dollyScale;
	        } else if (this.camera instanceof THREE.OrthographicCamera) {
	            this.camera.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.camera.zoom * dollyScale));
	            this.camera.updateProjectionMatrix();
	            this.dispatchEvent(this.changeEvent);
	        } else {
	
	            // console.warn('WARNING: GlobeControls.js encountered an unknown camera type - dolly/zoom disabled.');
	
	        }
	    };
	
	    this.dollyOut = function dollyOut(dollyScale) {
	        if (dollyScale === undefined) {
	            dollyScale = this.getDollyScale();
	        }
	
	        if (this.camera instanceof THREE.PerspectiveCamera) {
	            orbit.scale *= dollyScale;
	        } else if (this.camera instanceof THREE.OrthographicCamera) {
	            this.camera.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.camera.zoom / dollyScale));
	            this.camera.updateProjectionMatrix();
	            this.dispatchEvent(this.changeEvent);
	        } else {
	
	            // console.warn('WARNING: GlobeControls.js encountered an unknown camera type - dolly/zoom disabled.');
	
	        }
	    };
	
	    var quaterPano = new THREE.Quaternion();
	    var quaterAxis = new THREE.Quaternion();
	    var axisX = new THREE.Vector3(1, 0, 0);
	
	    var update = function update() {
	        // MOVE_GLOBE
	        // Rotate globe with mouse
	        if (state === CONTROL_STATE.MOVE_GLOBE) {
	            movingCameraTargetOnGlobe.copy(this.getCameraTargetPosition()).applyQuaternion(quatGlobe);
	            this.camera.position.copy(snapShotCamera.position).applyQuaternion(quatGlobe);
	            // combine zoom with move globe
	            if (ctrl.progress > 0) {
	                this.camera.position.lerp(movingCameraTargetOnGlobe, ctrl.progress * animatedScale);
	            }
	            this.camera.up.copy(movingCameraTargetOnGlobe.clone().normalize());
	            // PAN
	            // Move camera in projection plan
	        } else if (state === CONTROL_STATE.PAN) {
	            this.camera.position.add(panVector);
	            movingCameraTargetOnGlobe.add(panVector);
	            this.camera.up.copy(movingCameraTargetOnGlobe.clone().normalize());
	            // PANORAMIC
	            // Move target camera
	        } else if (state === CONTROL_STATE.PANORAMIC) {
	            // TODO: this part must be reworked
	            this.camera.worldToLocal(movingCameraTargetOnGlobe);
	            var normal = this.camera.position.clone().normalize().applyQuaternion(this.camera.quaternion.clone().inverse());
	            quaterPano.setFromAxisAngle(normal, sphericalDelta.theta).multiply(quaterAxis.setFromAxisAngle(axisX, sphericalDelta.phi));
	            movingCameraTargetOnGlobe.applyQuaternion(quaterPano);
	            this.camera.localToWorld(movingCameraTargetOnGlobe);
	            this.camera.up.copy(movingCameraTargetOnGlobe.clone().normalize());
	        } else {
	            // ZOOM/ORBIT
	            // Move Camera around the target camera
	
	            // TODO: test before remove test code see (Note A)
	            // offset.applyQuaternion( quat );
	
	            // get camera position in local space of target
	            offset.copy(this.camera.position).applyMatrix4(cameraTargetOnGlobe.matrixWorldInverse);
	
	            // angle from z-axis around y-axis
	            if (sphericalDelta.theta || sphericalDelta.phi) {
	                spherical.setFromVector3(offset);
	            }
	
	            if (this.autoRotate && state === CONTROL_STATE.NONE) {
	                this.rotateLeft(this.getAutoRotationAngle());
	            }
	
	            spherical.theta += sphericalDelta.theta;
	            spherical.phi += sphericalDelta.phi;
	
	            // restrict spherical.theta to be between desired limits
	            spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, spherical.theta));
	
	            // restrict spherical.phi to be between desired limits
	            spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, spherical.phi));
	
	            spherical.radius = offset.length() * orbit.scale;
	
	            // restrict spherical.phi to be betwee EPS and PI-EPS
	            spherical.makeSafe();
	
	            // restrict radius to be between desired limits
	            spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, spherical.radius));
	
	            offset.setFromSpherical(spherical);
	
	            // rotate point back to "camera-up-vector-is-up" space
	            // offset.applyQuaternion( quatInverse );
	            this.camera.position.copy(cameraTargetOnGlobe.localToWorld(offset));
	        }
	
	        this.camera.lookAt(movingCameraTargetOnGlobe);
	
	        if (!this.enableDamping) {
	            sphericalDelta.theta = 0;
	            sphericalDelta.phi = 0;
	        } else {
	            sphericalDelta.theta *= 1 - ctrl.dampingFactor;
	            sphericalDelta.phi *= 1 - ctrl.dampingFactor;
	        }
	
	        orbit.scale = 1;
	        panVector.set(0, 0, 0);
	
	        // update condition is:
	        // min(camera displacement, camera rotation in radians)^2 > EPS
	        // using small-angle approximation cos(x/2) = 1 - x^2 / 8
	
	        if (lastPosition.distanceToSquared(this.camera.position) > EPS || 8 * (1 - lastQuaternion.dot(this.camera.quaternion)) > EPS) {
	            this.dispatchEvent(this.changeEvent);
	
	            lastPosition.copy(this.camera.position);
	            lastQuaternion.copy(this.camera.quaternion);
	        }
	        // Launch animationdamping if mouse stops these movements
	        if (this.enableDamping && state === CONTROL_STATE.ORBIT && player.isStopped() && (sphericalDelta.theta > EPS || sphericalDelta.phi > EPS)) {
	            player.playLater(dampingOrbitalMvt, 2);
	        }
	    }.bind(this);
	
	    this.getSpace = function getSpace() {
	        return space;
	    };
	
	    this.getSphericalDelta = function getSphericalDelta() {
	        return sphericalDelta;
	    };
	
	    // Position object on globe
	    var positionObject = function getPositionObjectFn() {
	        var quaterionX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
	        return function positionObject(newPosition, object) {
	            object.position.copy(newPosition);
	            object.lookAt(newPosition.clone().multiplyScalar(1.1));
	            object.quaternion.multiply(quaterionX);
	            object.updateMatrixWorld();
	        };
	    }();
	
	    // set new camera target on globe
	    var setCameraTargetObjectPosition = function setCameraTargetObjectPosition(newPosition) {
	        // Compute the new target position
	        positionObject(newPosition, cameraTargetOnGlobe);
	
	        cameraTargetOnGlobe.matrixWorldInverse.getInverse(cameraTargetOnGlobe.matrixWorld);
	    };
	
	    var cT = new THREE.Vector3();
	    var delta = 0.001;
	
	    var updateCameraTargetOnGlobe = function updateCameraTargetOnGlobe() {
	        var previousCameraTargetOnGlobe = cameraTargetOnGlobe.position.clone();
	
	        // Get distance camera DME
	        var pickingPosition = getPickingPosition();
	
	        if (!pickingPosition) {
	            return;
	        }
	
	        var distanceTarget = pickingPosition.distanceTo(this.camera.position);
	
	        // Position movingCameraTargetOnGlobe on DME
	        cT.subVectors(movingCameraTargetOnGlobe, this.camera.position);
	        cT.setLength(distanceTarget);
	        movingCameraTargetOnGlobe.addVectors(this.camera.position, cT);
	
	        setCameraTargetObjectPosition(movingCameraTargetOnGlobe);
	
	        // update spherical from target
	        offset.copy(this.camera.position);
	        offset.applyMatrix4(cameraTargetOnGlobe.matrixWorldInverse);
	        spherical.setFromVector3(offset);
	
	        if (enableEventPositionChanged) {
	            if (state === CONTROL_STATE.ORBIT && (Math.abs(snapShotSpherical.phi - spherical.phi) > delta || Math.abs(snapShotSpherical.theta - spherical.theta) > delta)) {
	                this.dispatchEvent({
	                    type: CONTROL_EVENTS.ORIENTATION_CHANGED,
	                    previous: {
	                        tilt: snapShotSpherical.phi * 180 / Math.PI,
	                        heading: snapShotSpherical.theta * 180 / Math.PI
	                    },
	                    new: {
	                        tilt: spherical.phi * 180 / Math.PI,
	                        heading: spherical.theta * 180 / Math.PI
	                    }
	                });
	            } else if (state === CONTROL_STATE.PAN) {
	                this.dispatchEvent({
	                    type: CONTROL_EVENTS.PAN_CHANGED
	                });
	            }
	
	            var previousRange = snapShotSpherical.radius;
	            var newRange = this.getRange();
	            if (Math.abs(newRange - previousRange) / previousRange > 0.001) {
	                this.dispatchEvent({
	                    type: CONTROL_EVENTS.RANGE_CHANGED,
	                    previous: { range: previousRange },
	                    new: { range: newRange }
	                });
	            }
	
	            if (cameraTargetOnGlobe.position.distanceTo(previousCameraTargetOnGlobe) / spherical.radius > delta) {
	                this.dispatchEvent({
	                    type: CONTROL_EVENTS.CAMERA_TARGET_CHANGED,
	                    previous: { cameraTarget: new _Coordinates2.default(this._view.referenceCrs, previousCameraTargetOnGlobe) },
	                    new: { cameraTarget: new _Coordinates2.default(this._view.referenceCrs, cameraTargetOnGlobe.position) }
	                });
	            }
	            snapShotSpherical.copy(spherical);
	        }
	
	        state = CONTROL_STATE.NONE;
	        lastRotation = [];
	        if (enableTargetHelper) {
	            this.dispatchEvent(this.changeEvent);
	        }
	    };
	
	    // Update helper
	    var updateHelper = enableTargetHelper ? function updateHelper(position, helper) {
	        positionObject(position, helper);
	        this.dispatchEvent(this.changeEvent);
	    } : function empty() {};
	
	    this.getPickingPositionOnSphere = function getPickingPositionOnSphere() {
	        return tSphere.picking.position;
	    };
	
	    // Update radius's sphere : the sphere must cross the point
	    // Return intersection with mouse and sphere
	    var updateSpherePicking = function getUpdateSpherePicking() {
	        var mouse = new THREE.Vector2();
	        var ray = new THREE.Ray();
	
	        return function updateSpherePicking(point, screenCoord) {
	            tSphere.setRadius(point.length());
	
	            mouse.x = screenCoord.x / sizeRendering.width * 2 - 1;
	            mouse.y = -(screenCoord.y / sizeRendering.height) * 2 + 1;
	
	            snapShotCamera.updateRay(ray, mouse);
	            // pick position on tSphere
	            var its = tSphere.intersectWithRay(ray);
	            if (its != undefined) {
	                tSphere.picking.position.copy(its);
	                tSphere.picking.normal = tSphere.picking.position.clone().normalize();
	
	                lastRotation.push(tSphere.picking.normal);
	                updateHelper.bind(this)(tSphere.picking.position, pickingHelper);
	            }
	        };
	    }();
	
	    var onMouseMove = function getOnMouseMoveFn() {
	        var ray = new THREE.Ray();
	        var mouse = new THREE.Vector2();
	
	        return function onMouseMove(event) {
	            if (player.isPlaying()) {
	                player.stop();
	            }
	            if (this.enabled === false) return;
	
	            event.preventDefault();
	
	            if (state === CONTROL_STATE.ORBIT || state === CONTROL_STATE.PANORAMIC) {
	                if (this.enableRotate === false) return;
	
	                rotateEnd.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	                rotateDelta.subVectors(rotateEnd, rotateStart);
	
	                // rotating across whole screen goes 360 degrees around
	                if (!space) {
	                    this.rotateLeft(2 * Math.PI * rotateDelta.x / sizeRendering.width * this.rotateSpeed);
	
	                    // rotating up and down along whole screen attempts to go 360, but limited to 180
	                    this.rotateUp(2 * Math.PI * rotateDelta.y / sizeRendering.height * this.rotateSpeed);
	                } else {
	                    this.rotateLeft(rotateDelta.x);
	
	                    // rotating up and down along whole screen attempts to go 360, but limited to 180
	                    this.rotateUp(rotateDelta.y);
	                }
	
	                rotateStart.copy(rotateEnd);
	            } else if (state === CONTROL_STATE.DOLLY) {
	                if (this.enableZoom === false) return;
	
	                dollyEnd.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	                dollyDelta.subVectors(dollyEnd, dollyStart);
	
	                if (dollyDelta.y > 0) {
	                    this.dollyIn();
	                } else if (dollyDelta.y < 0) {
	                    this.dollyOut();
	                }
	
	                dollyStart.copy(dollyEnd);
	            } else if (state === CONTROL_STATE.PAN) {
	                if (this.enablePan === false) return;
	
	                panEnd.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	                panDelta.subVectors(panEnd, panStart);
	
	                this.mouseToPan(panDelta.x, panDelta.y);
	
	                panStart.copy(panEnd);
	            } else if (state === CONTROL_STATE.MOVE_GLOBE) {
	                mouse.x = (event.clientX - event.target.offsetLeft) / sizeRendering.width * 2 - 1;
	                mouse.y = -((event.clientY - event.target.offsetTop) / sizeRendering.height) * 2 + 1;
	
	                snapShotCamera.updateRay(ray, mouse);
	
	                var intersection = tSphere.intersectWithRay(ray);
	
	                // If there's intersection then move globe else we stop the move
	                if (intersection) {
	                    var normalizedIntersection = intersection.normalize();
	                    quatGlobe.setFromUnitVectors(normalizedIntersection, tSphere.picking.normal);
	                    // backups last move globe for damping
	                    lastRotation.push(normalizedIntersection.clone());
	                    // Remove unnecessary movements backups
	                    if (lastRotation.length > 2) {
	                        lastRotation.splice(0, 1);
	                    }
	                } else {
	                    onMouseUp.bind(this)();
	                }
	            }
	
	            if (state !== CONTROL_STATE.NONE) {
	                update();
	            }
	        };
	    }();
	
	    var onMouseDown = function onMouseDown(event) {
	        var _this = this;
	
	        player.stop().then(function () {
	            if (_this.enabled === false) return;
	            event.preventDefault();
	
	            if (event.button === _this.mouseButtons.PANORAMIC) {
	                if (_this.enableRotate === false) return;
	
	                if (keyCtrl) {
	                    state = CONTROL_STATE.ORBIT;
	                } else if (keyShift) {
	                    state = CONTROL_STATE.PANORAMIC;
	                } else if (keyS) {
	                    // If the key 'S' is down, the engine selects node under mouse
	                    var selectClickEvent = {
	                        type: 'selectClick'
	                    };
	                    selectClickEvent.mouse = new THREE.Vector2(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	
	                    _this.dispatchEvent(selectClickEvent);
	                } else {
	                    snapShotCamera.shot(_this.camera);
	                    ptScreenClick.x = event.clientX - event.target.offsetLeft;
	                    ptScreenClick.y = event.clientY - event.target.offsetTop;
	
	                    var point = getPickingPosition(ptScreenClick);
	                    lastRotation = [];
	                    // update tangent sphere which passes through the point
	                    if (point) {
	                        ctrl.range = _this.getRange();
	                        updateSpherePicking.bind(_this)(point, ptScreenClick);
	                        state = CONTROL_STATE.MOVE_GLOBE;
	                    }
	                }
	
	                rotateStart.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	            } else if (event.button === _this.mouseButtons.ZOOM) {
	                if (_this.enableZoom === false) return;
	
	                state = CONTROL_STATE.DOLLY;
	
	                dollyStart.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	            } else if (event.button === _this.mouseButtons.PAN) {
	                if (_this.enablePan === false) return;
	
	                state = CONTROL_STATE.PAN;
	
	                panStart.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	            }
	
	            if (state !== CONTROL_STATE.NONE) {
	                _this.domElement.addEventListener('mousemove', _handlerMouseMove, false);
	                _this.domElement.addEventListener('mouseup', _handlerMouseUp, false);
	                _this.domElement.addEventListener('mouseleave', _handlerMouseUp, false);
	                _this.dispatchEvent(_this.startEvent);
	            }
	        });
	    };
	
	    var ondblclick = function ondblclick(event) {
	        if (this.enabled === false) return;
	
	        // Double click throws move camera's target with animation
	        if (!keyCtrl && !keyShift) {
	            ptScreenClick.x = event.clientX - event.target.offsetLeft;
	            ptScreenClick.y = event.clientY - event.target.offsetTop;
	
	            var point = getPickingPosition(ptScreenClick);
	
	            if (point) {
	                animatedScale = 0.6;
	                this.setCameraTargetPosition(point, this.isAnimationEnabled());
	            }
	        }
	    };
	
	    var onMouseUp = function onMouseUp() /* event */{
	        var _this2 = this;
	
	        if (this.enabled === false) return;
	
	        this.domElement.removeEventListener('mousemove', _handlerMouseMove, false);
	        this.domElement.removeEventListener('mouseup', _handlerMouseUp, false);
	        this.domElement.removeEventListener('mouseleave', _handlerMouseUp, false);
	        this.dispatchEvent(this.endEvent);
	
	        player.stop();
	
	        // Launch damping movement for :
	        //      * CONTROL_STATE.ORBIT
	        //      * CONTROL_STATE.MOVE_GLOBE
	        if (this.enableDamping) {
	            if (state === CONTROL_STATE.ORBIT && (sphericalDelta.theta > EPS || sphericalDelta.phi > EPS)) {
	                player.play(dampingOrbitalMvt).then(function () {
	                    return _this2.resetControls();
	                });
	            } else if (state === CONTROL_STATE.MOVE_GLOBE && lastRotation.length === 2 && !lastRotation[1].equals(lastRotation[0])) {
	                ctrl.qDelta.setFromUnitVectors(lastRotation[1], lastRotation[0]);
	                player.play(animationDampingMove).then(function () {
	                    return _this2.resetControls();
	                });
	            } else {
	                updateCameraTargetOnGlobe.bind(this)();
	            }
	        } else {
	            updateCameraTargetOnGlobe.bind(this)();
	        }
	    };
	
	    var onMouseWheel = function onMouseWheel(event) {
	        var _this3 = this;
	
	        player.stop().then(function () {
	            if (_this3.enabled === false || _this3.enableZoom === false /* || state !== CONTROL_STATE.NONE*/) return;
	
	            event.preventDefault();
	            event.stopPropagation();
	
	            var delta = 0;
	
	            // WebKit / Opera / Explorer 9
	            if (event.wheelDelta !== undefined) {
	                delta = event.wheelDelta;
	                // Firefox
	            } else if (event.detail !== undefined) {
	                delta = -event.detail;
	            }
	
	            if (delta > 0) {
	                _this3.dollyOut();
	            } else if (delta < 0) {
	                _this3.dollyIn();
	            }
	
	            var previousRange = _this3.getRange();
	            update();
	            var newRange = _this3.getRange();
	            if (Math.abs(newRange - previousRange) / previousRange > 0.001 && enableEventPositionChanged) {
	                _this3.dispatchEvent({
	                    type: CONTROL_EVENTS.RANGE_CHANGED,
	                    previous: { range: previousRange },
	                    new: { range: newRange }
	                });
	            }
	            snapShotSpherical.copy(spherical);
	
	            _this3.dispatchEvent(_this3.startEvent);
	            _this3.dispatchEvent(_this3.endEvent);
	        });
	    };
	
	    var onKeyUp = function onKeyUp() /* event*/{
	        if (this.enabled === false || this.enableKeys === false || this.enablePan === false) return;
	
	        if (state === CONTROL_STATE.PAN) {
	            updateCameraTargetOnGlobe.bind(this)();
	        }
	
	        keyCtrl = false;
	        keyShift = false;
	        keyS = false;
	    };
	
	    var onKeyDown = function onKeyDown(event) {
	        var _this4 = this;
	
	        player.stop().then(function () {
	            if (_this4.enabled === false || _this4.enableKeys === false || _this4.enablePan === false) return;
	            keyCtrl = false;
	            keyShift = false;
	
	            switch (event.keyCode) {
	                case CONTROL_KEYS.UP:
	                    _this4.mouseToPan(0, _this4.keyPanSpeed);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                case CONTROL_KEYS.BOTTOM:
	                    _this4.mouseToPan(0, -_this4.keyPanSpeed);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                case CONTROL_KEYS.LEFT:
	                    _this4.mouseToPan(_this4.keyPanSpeed, 0);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                case CONTROL_KEYS.RIGHT:
	                    _this4.mouseToPan(-_this4.keyPanSpeed, 0);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                // TODO Why space key, looking for movement
	                case CONTROL_KEYS.SPACE:
	                    space = !space;
	                    // this.updateTarget();
	                    update();
	                    break;
	                case CONTROL_KEYS.CTRL:
	                    // computeVectorUp();
	                    keyCtrl = true;
	                    break;
	                case CONTROL_KEYS.SHIFT:
	                    // computeVectorUp();
	                    keyShift = true;
	                    break;
	                case CONTROL_KEYS.S:
	                    // WARNING loop !!!
	                    keyS = true;
	                    break;
	                default:
	            }
	        });
	    };
	
	    var onTouchStart = function onTouchStart(event) {
	        if (this.enabled === false) return;
	
	        switch (event.touches.length) {
	
	            case 1:
	                // one-fingered touch: rotate
	
	                if (this.enableRotate === false) return;
	
	                state = CONTROL_STATE.TOUCH_ROTATE;
	
	                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	                break;
	
	            case 2:
	                // two-fingered touch: dolly
	
	                if (this.enableZoom === false) return;
	
	                state = CONTROL_STATE.TOUCH_DOLLY;
	
	                var dx = event.touches[0].pageX - event.touches[1].pageX;
	                var dy = event.touches[0].pageY - event.touches[1].pageY;
	                var distance = Math.sqrt(dx * dx + dy * dy);
	                dollyStart.set(0, distance);
	                break;
	
	            case 3:
	                // three-fingered touch: this.mouseToPan
	
	                if (this.enablePan === false) return;
	
	                state = CONTROL_STATE.TOUCH_PAN;
	
	                panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	                break;
	
	            default:
	
	                state = CONTROL_STATE.NONE;
	
	        }
	
	        if (state !== CONTROL_STATE.NONE) this.dispatchEvent(this.startEvent);
	    };
	
	    var onTouchMove = function onTouchMove(event) {
	        if (this.enabled === false) return;
	
	        event.preventDefault();
	        event.stopPropagation();
	
	        var element = this.domElement === document ? this.domElement.body : this.domElement;
	
	        switch (event.touches.length) {
	
	            case 1:
	                // one-fingered touch: rotate
	
	                if (this.enableRotate === false) return;
	                if (state !== CONTROL_STATE.TOUCH_ROTATE) return;
	
	                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	                rotateDelta.subVectors(rotateEnd, rotateStart);
	
	                // rotating across whole screen goes 360 degrees around
	                this.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * this.rotateSpeed);
	                // rotating up and down along whole screen attempts to go 360, but limited to 180
	                this.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * this.rotateSpeed);
	
	                rotateStart.copy(rotateEnd);
	
	                update();
	                break;
	
	            case 2:
	                // two-fingered touch: dolly
	
	                if (this.enableZoom === false) return;
	                if (state !== CONTROL_STATE.TOUCH_DOLLY) return;
	
	                var dx = event.touches[0].pageX - event.touches[1].pageX;
	                var dy = event.touches[0].pageY - event.touches[1].pageY;
	                var distance = Math.sqrt(dx * dx + dy * dy);
	
	                dollyEnd.set(0, distance);
	                dollyDelta.subVectors(dollyEnd, dollyStart);
	
	                if (dollyDelta.y > 0) {
	                    this.dollyOut();
	                } else if (dollyDelta.y < 0) {
	                    this.dollyIn();
	                }
	
	                dollyStart.copy(dollyEnd);
	
	                update();
	                break;
	
	            case 3:
	                // three-fingered touch: this.mouseToPan
	
	                if (this.enablePan === false) return;
	                if (state !== CONTROL_STATE.TOUCH_PAN) return;
	
	                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	                panDelta.subVectors(panEnd, panStart);
	
	                this.mouseToPan(panDelta.x, panDelta.y);
	
	                panStart.copy(panEnd);
	
	                update();
	                break;
	
	            default:
	
	                state = CONTROL_STATE.NONE;
	
	        }
	    };
	
	    var onTouchEnd = function onTouchEnd() /* event */{
	        if (this.enabled === false) return;
	
	        this.dispatchEvent(this.endEvent);
	        state = CONTROL_STATE.NONE;
	        keyCtrl = false;
	        keyShift = false;
	        keyS = false;
	    };
	
	    // Callback launched when player is stopped
	    this.resetControls = function resetControls() {
	        lastRotation.splice(0);
	        ctrl.progress = 0;
	        updateCameraTargetOnGlobe.bind(this)();
	    };
	
	    // update object camera position
	    this.updateCameraTransformation = function updateCameraTransformation(controlState) {
	        var updateCameraTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	        var bkDamping = this.enableDamping;
	        this.enableDamping = false;
	        state = controlState || CONTROL_STATE.ORBIT;
	        update();
	        if (updateCameraTarget) {
	            updateCameraTargetOnGlobe.bind(this)();
	        }
	        this.enableDamping = bkDamping;
	    };
	
	    this.dispose = function dispose() {
	        // this.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
	        this.domElement.removeEventListener('mousedown', onMouseDown, false);
	        this.domElement.removeEventListener('mousewheel', onMouseWheel, false);
	        this.domElement.removeEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
	
	        this.domElement.removeEventListener('touchstart', onTouchStart, false);
	        this.domElement.removeEventListener('touchend', onTouchEnd, false);
	        this.domElement.removeEventListener('touchmove', onTouchMove, false);
	
	        this.domElement.removeEventListener('mousemove', onMouseMove, false);
	        this.domElement.removeEventListener('mouseup', onMouseUp, false);
	
	        window.removeEventListener('keydown', onKeyDown, false);
	
	        // this.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	    };
	
	    // Instance all
	    this.domElement.addEventListener('contextmenu', function (event) {
	        event.preventDefault();
	    }, false);
	    this.domElement.addEventListener('mousedown', onMouseDown.bind(this), false);
	    this.domElement.addEventListener('mousewheel', onMouseWheel.bind(this), false);
	    this.domElement.addEventListener('dblclick', ondblclick.bind(this), false);
	    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel.bind(this), false); // firefox
	
	    this.domElement.addEventListener('touchstart', onTouchStart.bind(this), false);
	    this.domElement.addEventListener('touchend', onTouchEnd.bind(this), false);
	    this.domElement.addEventListener('touchmove', onTouchMove.bind(this), false);
	
	    // refresh control for each animation's frame
	    player.addEventListener('animation-frame', update.bind(this));
	
	    function isAnimationWithoutDamping(animation) {
	        return animation && !(animation.name === 'damping-move' || animation.name === 'damping-orbit');
	    }
	
	    player.addEventListener('animation-started', function (e) {
	        if (isAnimationWithoutDamping(e.animation)) {
	            _this5.dispatchEvent({
	                type: 'animation-started'
	            });
	        }
	    });
	
	    player.addEventListener('animation-ended', function (e) {
	        if (isAnimationWithoutDamping(e.animation)) {
	            _this5.dispatchEvent({
	                type: 'animation-ended'
	            });
	        }
	    });
	
	    // TODO: Why windows
	    window.addEventListener('keydown', onKeyDown.bind(this), false);
	    window.addEventListener('keyup', onKeyUp.bind(this), false);
	
	    // Initialisation Globe Target and movingGlobeTarget
	    setCameraTargetObjectPosition(target);
	    movingCameraTargetOnGlobe.copy(target);
	    this.camera.up.copy(target.clone().normalize());
	    this._view.scene.add(cameraTargetOnGlobe);
	    spherical.radius = this.camera.position.length();
	
	    update();
	
	    if (enableTargetHelper) {
	        cameraTargetOnGlobe.add(new THREE.AxisHelper(500000));
	        this._view.scene.add(pickingHelper);
	    }
	
	    // Start position
	    initialTarget = cameraTargetOnGlobe.clone();
	    initialPosition = this.camera.position.clone();
	    initialZoom = this.camera.zoom;
	    snapShotSpherical.copy(spherical);
	
	    _handlerMouseMove = onMouseMove.bind(this);
	    _handlerMouseUp = onMouseUp.bind(this);
	
	    this.waitSceneLoaded().then(function () {
	        _this5.updateCameraTransformation();
	        _this5.dispatchEvent(_this5.changeEvent);
	    });
	}
	
	GlobeControls.prototype = (0, _create2.default)(THREE.EventDispatcher.prototype);
	GlobeControls.prototype.constructor = GlobeControls;
	
	function getRangeFromScale(scale, pitch) {
	    // Screen pitch, in millimeters
	    pitch = (pitch || 0.28) / 1000;
	    var alpha = sizeRendering.FOV / 180 * Math.PI * 0.5;
	    // Invert one unit projection (see getDollyScale)
	    var range = pitch * sizeRendering.height / (scale * 2 * Math.tan(alpha));
	
	    return range;
	}
	
	// # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
	
	/**
	 * Change the tilt.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/p6t76zox/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @param {Angle} Number - The angle.
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	GlobeControls.prototype.setTilt = function setTilt(tilt, isAnimated) {
	    return this.setOrbitalPosition({ tilt: tilt }, isAnimated);
	};
	
	/**
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/rxe4xgxj/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * Change the heading.
	 * @param {Angle} Number - The angle.
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	GlobeControls.prototype.setHeading = function setHeading(heading, isAnimated) {
	    return this.setOrbitalPosition({ heading: heading }, isAnimated);
	};
	
	/**
	 * Sets the "range": the distance in meters between the camera and the current central point on the screen.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/Lt3jL5pd/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @param {Number} pRange - The camera altitude.
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	GlobeControls.prototype.setRange = function setRange(range, isAnimated) {
	    return this.setOrbitalPosition({ range: range }, isAnimated);
	};
	
	/**
	 * Sets orientation angles of the current camera, in degrees.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/9qr2mogh/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @param      {object}   orientation  The angle of the rotation in degrees
	 * @param      {boolean}  isAnimated   Indicates if animated
	 * @return     {Promise}   { description_of_the_return_value }
	 */
	GlobeControls.prototype.setOrbitalPosition = function setOrbitalPosition(position, isAnimated) {
	    var _this6 = this;
	
	    isAnimated = isAnimated === undefined ? this.isAnimationEnabled() : isAnimated;
	    var deltaPhi = position.tilt === undefined ? 0 : position.tilt * Math.PI / 180 - this.getTiltRad();
	    var deltaTheta = position.heading === undefined ? 0 : position.heading * Math.PI / 180 - this.getHeadingRad();
	    var deltaRange = position.range === undefined ? 0 : position.range - this.getRange();
	    return this.moveOrbitalPosition(deltaRange, deltaTheta, deltaPhi, isAnimated).then(function () {
	        _this6.dispatchEvent(_this6.changeEvent);
	        return _this6.waitSceneLoaded().then(function () {
	            _this6.updateCameraTransformation();
	        });
	    });
	};
	
	var destSpherical = new THREE.Spherical();
	
	GlobeControls.prototype.moveOrbitalPosition = function moveOrbitalPosition(deltaRange, deltaTheta, deltaPhi, isAnimated) {
	    var _this7 = this;
	
	    isAnimated = isAnimated === undefined ? this.isAnimationEnabled() : isAnimated;
	    var range = deltaRange + this.getRange();
	    if (isAnimated) {
	        destSpherical.theta = deltaTheta + spherical.theta;
	        destSpherical.phi = deltaPhi + spherical.phi;
	        sphericalTo.radius = range;
	        sphericalTo.theta = deltaTheta / (animationOrbit.duration - 1);
	        sphericalTo.phi = deltaPhi / (animationOrbit.duration - 1);
	        state = CONTROL_STATE.ORBIT;
	        return player.play(animationOrbit).then(function () {
	            // To correct errors at animation's end
	            // TODO : find other solution to correct error
	            if (player.isEnded()) {
	                _this7.moveOrbitalPosition(0, destSpherical.theta - spherical.theta, destSpherical.phi - spherical.phi, false);
	            }
	            _this7.resetControls();
	        });
	    } else {
	        sphericalDelta.theta = deltaTheta;
	        sphericalDelta.phi = deltaPhi;
	        orbit.scale = range / this.getRange();
	        this.updateCameraTransformation(CONTROL_STATE.ORBIT, false);
	        return _promise2.default.resolve();
	    }
	};
	
	/**
	 * Returns the coordinates of the globe point targeted by the camera.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/4tjgnv7z/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @return {THREE.Vector3} position
	 */
	GlobeControls.prototype.getCameraTargetPosition = function getCameraTargetPosition() {
	    return cameraTargetOnGlobe.position;
	};
	
	/**
	 * Make the camera aim a point in the globe
	 *
	 * @param {THREE.Vector3} position - the position on the globe to aim, in EPSG:4978 projection
	 * @param {boolean} isAnimated - if we should animate the move
	 */
	GlobeControls.prototype.setCameraTargetPosition = function setCameraTargetPosition(position, isAnimated) {
	    var _this8 = this;
	
	    isAnimated = isAnimated === undefined ? this.isAnimationEnabled() : isAnimated;
	    var center = this.getCameraTargetPosition();
	
	    if (position.range) {
	        // Compensation of the altitude from the approximation of the ellipsoid by a sphere
	        // This approximation comes from the movements around the ellipsoid, are rotations with constant radius
	        var currentTargetPosition = new _Coordinates2.default(this._view.referenceCrs, center).as('EPSG:4326');
	        var targetOnEllipsoid = new _Coordinates.C.EPSG_4326(currentTargetPosition.longitude(), currentTargetPosition.latitude(), 0).as(this._view.referenceCrs).xyz();
	        var compensation = position.length() - targetOnEllipsoid.length();
	        // FIX ME error with compensation negative
	        if (compensation > 0) {
	            position.range += compensation;
	        }
	    }
	
	    snapShotCamera.shot(this.camera);
	
	    ptScreenClick.x = this.domElement.width / 2;
	    ptScreenClick.y = this.domElement.height / 2;
	
	    var vFrom = center.clone().normalize();
	    var vTo = position.normalize();
	
	    var promise = void 0;
	
	    if (isAnimated) {
	        ctrl.qDelta.setFromUnitVectors(vFrom, vTo);
	        if (position.range) {
	            animatedScale = 1.0 - position.range / this.getRange();
	        }
	        state = CONTROL_STATE.MOVE_GLOBE;
	        promise = player.play(animationZoomCenter).then(function () {
	            animatedScale = 0.0;
	            _this8.resetControls();
	        });
	    } else {
	        quatGlobe.setFromUnitVectors(vFrom, vTo);
	        this.updateCameraTransformation(CONTROL_STATE.MOVE_GLOBE);
	        if (animatedScale > 0.0 && animatedScale < 1.0) {
	            this.setRange(this.getRange() * animatedScale);
	        }
	        promise = _promise2.default.resolve();
	    }
	
	    return promise.then(function () {
	        _this8.dispatchEvent(_this8.changeEvent);
	        return _this8.waitSceneLoaded().then(function () {
	            _this8.updateCameraTransformation();
	        });
	    });
	};
	
	/**
	 * Returns the "range": the distance in meters between the camera and the current central point on the screen.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/Lbt1vfek/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @return {number} number
	 */
	GlobeControls.prototype.getRange = function getRange() {
	    return this.getCameraTargetPosition().distanceTo(this.camera.position);
	};
	
	/**
	 * Returns the tilt in degrees.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/kcx0of9j/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @return {Angle} number - The angle of the rotation in degrees.
	 */
	GlobeControls.prototype.getTilt = function getTilt() {
	    return spherical.phi * 180 / Math.PI;
	};
	
	/**
	 * Returns the heading in degrees.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/pxv1Lw16/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @return {Angle} number - The angle of the rotation in degrees.
	 */
	GlobeControls.prototype.getHeading = function getHeading() {
	    return spherical.theta * 180 / Math.PI;
	};
	
	GlobeControls.prototype.getTiltRad = function getTiltRad() {
	    return spherical.phi;
	};
	
	GlobeControls.prototype.getHeadingRad = function getHeadingRad() {
	    return spherical.theta;
	};
	
	GlobeControls.prototype.getPolarAngle = function getPolarAngle() {
	    return spherical.phi;
	};
	
	GlobeControls.prototype.getAzimuthalAngle = function getAzimuthalAngle() {
	    return spherical.theta;
	};
	
	GlobeControls.prototype.moveTarget = function moveTarget() {
	    return movingCameraTargetOnGlobe;
	};
	
	/**
	 * Displaces the central point to a specific amount of pixels from its current position.
	 * The view flies to the desired coordinate, i.e.is not teleported instantly. Note : The results can be strange in some cases, if ever possible, when e.g.the camera looks horizontally or if the displaced center would not pick the ground once displaced.
	 * @param      {vector}  pVector  The vector
	 */
	GlobeControls.prototype.pan = function pan(pVector) {
	    var _this9 = this;
	
	    this.mouseToPan(pVector.x, pVector.y);
	    this.updateCameraTransformation(CONTROL_STATE.PAN);
	    this.dispatchEvent(this.changeEvent);
	    return this.waitSceneLoaded().then(function () {
	        _this9.updateCameraTransformation();
	    });
	};
	
	/**
	 * Returns the orientation angles of the current camera, in degrees.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/okfj460p/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 */
	GlobeControls.prototype.getCameraOrientation = function getCameraOrientation() {
	    var tiltCam = this.getTilt();
	    var headingCam = this.getHeading();
	    return [tiltCam, headingCam];
	};
	
	/**
	 * Returns the camera location projected on the ground in lat,lon.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/mjv7ha02/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @return {Position} position
	 */
	
	GlobeControls.prototype.getCameraLocation = function getCameraLocation() {
	    return new _Coordinates2.default('EPSG:4978', this.camera.position).as('EPSG:4326');
	};
	
	/**
	 * Retuns the coordinates of the central point on screen.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/4tjgnv7z/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @return {Position} position
	 */
	
	GlobeControls.prototype.getCameraTargetGeoPosition = function getCameraTargetGeoPosition() {
	    return new _Coordinates2.default(this._view.referenceCrs, this.getCameraTargetPosition()).as('EPSG:4326');
	};
	
	/**
	 * Sets the animation enabled.
	 * @param      {boolean}  enable  enable
	 */
	GlobeControls.prototype.setAnimationEnabled = function setAnimationEnabled(enable) {
	    enableAnimation = enable;
	};
	
	/**
	 * Determines if animation enabled.
	 * @return     {boolean}  True if animation enabled, False otherwise.
	 */
	GlobeControls.prototype.isAnimationEnabled = function isAnimationEnabled() {
	    return enableAnimation;
	};
	
	/**
	 * Returns the actual zoom. The zoom will always be between the [getMinZoom(), getMaxZoom()].
	 * @return     {number}  The zoom .
	 */
	GlobeControls.prototype.getZoom = function getZoom() {
	    return (0, _GlobeTileProcessing.computeTileZoomFromDistanceCamera)(this.getRange());
	};
	
	/**
	 * Gets the current zoom, which is an index in the logical scales predefined for the application.
	 * The higher the zoom, the closer to the ground.
	 * The zoom is always in the [getMinZoom(), getMaxZoom()] range.
	 * @param      {number}  zoom    The zoom
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	GlobeControls.prototype.setZoom = function setZoom(zoom, isAnimated) {
	    isAnimated = isAnimated === undefined ? this.isAnimationEnabled() : isAnimated;
	    var range = (0, _GlobeTileProcessing.computeDistanceCameraFromTileZoom)(zoom);
	    return this.setRange(range, isAnimated);
	};
	
	/**
	 * Return the current zoom scale at the central point of the view.
	 * This function compute the scale of a map
	 * @param      {number}  pitch   Screen pitch, in millimeters ; 0.28 by default
	 * @return     {number}  The zoom scale.
	 */
	GlobeControls.prototype.getScale = function getScale(pitch) {
	    // TODO: Why error div size height in Chrome?
	    // Screen pitch, in millimeters
	    pitch = (pitch || 0.28) / 1000;
	    var FOV = sizeRendering.FOV / 180 * Math.PI * 0.5;
	    // projection one unit on screen
	    var unitProjection = sizeRendering.height / (2 * this.getRange() * Math.tan(FOV));
	    return pitch * unitProjection;
	};
	
	/**
	 * Changes the zoom of the central point of screen so that screen acts as a map with a specified scale.
	 *  The view flies to the desired zoom scale;
	 * @param      {number}  scale  The scale
	 * @param      {number}  pitch  The pitch
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	// TODO pas de scale suprieur  0.05....
	GlobeControls.prototype.setScale = function setScale(scale, pitch, isAnimated) {
	    isAnimated = isAnimated === undefined ? this.isAnimationEnabled() : isAnimated;
	    var range = getRangeFromScale(scale);
	    return this.setRange(range, isAnimated);
	};
	
	/**
	 * Changes the center of the scene on screen to the specified coordinates.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/x06yhbq6/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->
	 * @function
	 * @memberOf GlobeControls
	 * @param {Object} coordinates - The globe coordinates in EPSG_4326 projection to aim to
	 * @param {number} coordinates.latitude
	 * @param {number} coordinates.longitude
	 * @param {number} coordinates.range
	 * @param {boolean}  isAnimated - if the movement should be animated
	 * @return {Promise} A promise that resolves when the next 'globe-loaded' event fires.
	 */
	GlobeControls.prototype.setCameraTargetGeoPosition = function setCameraTargetGeoPosition(coordinates, isAnimated) {
	    isAnimated = isAnimated === undefined ? this.isAnimationEnabled() : isAnimated;
	    var position = new _Coordinates.C.EPSG_4326(coordinates.longitude, coordinates.latitude, 0).as('EPSG:4978').xyz();
	    position.range = coordinates.range;
	    return this.setCameraTargetPosition(position, isAnimated);
	};
	
	/**
	 * Changes the center of the scene on screen to the specified coordinates.
	 * This function allows to change the central position, the zoom  the range, the scale and the camera orientation at the same time.
	 * The zoom has to be between the [getMinZoom(), getMaxZoom()].
	 * The zoom and the scale can't be set at the same time.
	 * <!--<iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/7yk0mpn0/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>-->-->
	 * @param {Position} position
	 * @param {number}  position.longitude  Coordinate longitude WGS84 in degree
	 * @param {number}  position.latitude  Coordinate latitude WGS84 in degree
	 * @param {number}  [position.tilt]  Camera tilt in degree
	 * @param {number}  [position.heading]  Camera heading in degree
	 * @param {number}  [position.range]  The camera distance to the target center
	 * @param {number}  [position.zoom]  zoom,  ignored if range is set
	 * @param {number}  [position.scale]  scale,  ignored if the zoom zoom or range is set. For a scale of 1/500 it is necessary to write 0,002.
	 * @param {boolean}  isAnimated  Indicates if animated
	 * @return {Promise}
	 */
	GlobeControls.prototype.setCameraTargetGeoPositionAdvanced = function setCameraTargetGeoPositionAdvanced(position, isAnimated) {
	    var _this10 = this;
	
	    isAnimated = isAnimated === undefined ? this.isAnimationEnabled() : isAnimated;
	    if (position.zoom) {
	        position.range = (0, _GlobeTileProcessing.computeDistanceCameraFromTileZoom)(position.zoom);
	    } else if (position.scale) {
	        position.range = getRangeFromScale(position.scale);
	    }
	    enableEventPositionChanged = false;
	    return this.setCameraTargetGeoPosition(position, isAnimated).then(function () {
	        enableEventPositionChanged = true;
	        return _this10.setOrbitalPosition(position, isAnimated);
	    });
	};
	
	/**
	 * Pick a position on the globe at the given position.
	 * @param {number | MouseEvent} x|event - The x-position inside the Globe element or a mouse event.
	 * @param {number | undefined} y - The y-position inside the Globe element.
	 * @return {Position} position
	 */
	GlobeControls.prototype.pickGeoPosition = function pickGeoPosition(mouse, y) {
	    var screenCoords = {
	        x: mouse.clientX || mouse,
	        y: mouse.clientY || y
	    };
	
	    var pickedPosition = _getPickingPosition(this.controlsActiveLayers, screenCoords);
	
	    if (!pickedPosition) {
	        return;
	    }
	
	    return new _Coordinates2.default('EPSG:4978', pickedPosition).as('EPSG:4326');
	};
	
	// # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
	
	GlobeControls.prototype.reset = function reset() {
	    // TODO not reset target globe
	    state = CONTROL_STATE.NONE;
	
	    this.target.copy(initialTarget);
	    this.camera.position.copy(initialPosition);
	    this.camera.zoom = initialZoom;
	
	    this.camera.updateProjectionMatrix();
	    this.dispatchEvent(this.changeEvent);
	
	    this.updateCameraTransformation();
	};
	
	exports.default = GlobeControls;

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function Sphere(center, radius) {
	    this.center = center || new THREE.Vector3();
	    this.radius = radius || 1.0;
	}
	
	Sphere.prototype.constructor = Sphere;
	
	Sphere.prototype.setCenter = function setCenter(center) {
	    this.center.copy(center);
	};
	
	Sphere.prototype.setRadius = function setRadius(radius) {
	    this.radius = radius;
	};
	
	var vector = new THREE.Vector3();
	
	Sphere.prototype.intersectWithRayNoMiss = function intersectWithRayNoMiss(ray) {
	    var pc = ray.closestPointToPoint(this.center);
	    var a = pc.length();
	    var d = void 0;
	    var b = void 0;
	
	    // TODO: recompute mirror ray
	    // If the ray miss sphere, we recompute the new ray with point symetric to tangent sphere
	    if (a > this.radius) {
	        // mirror point is symetric of pc
	        // The mirror ray must pass through the point mirrorPoint
	        var mirrorPoint = pc.clone().setLength(this.radius * 2 - a);
	
	        // Compute the new direction
	        d = ray.direction.subVectors(mirrorPoint, ray.origin).normalize();
	
	        // Classic intersection with the new ray
	        pc = ray.closestPointToPoint(this.center);
	        a = pc.length();
	
	        b = Math.sqrt(this.radius * this.radius - a * a);
	        d.setLength(b);
	
	        return vector.addVectors(pc, d);
	    }
	
	    // TODO: check all intersections : if (ray.origin.length() > this.radius)
	    d = ray.direction.clone();
	    b = Math.sqrt(this.radius * this.radius - a * a);
	    d.setLength(b);
	
	    return vector.subVectors(pc, d);
	};
	
	Sphere.prototype.intersectWithRay = function intersectWithRay(ray) {
	    var pc = ray.closestPointToPoint(this.center);
	    var a = pc.length();
	    if (a > this.radius) return undefined;
	    var d = ray.direction.clone();
	    var b = Math.sqrt(this.radius * this.radius - a * a);
	    d.setLength(b);
	    return vector.subVectors(pc, d);
	};
	
	exports.default = Sphere;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AnimatedExpression = exports.Animation = undefined;
	
	var _promise = __webpack_require__(274);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = __webpack_require__(2);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(329);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(330);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(331);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(347);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FRAMERATE = 60;
	var FRAME_DURATION = 1000 / FRAMERATE;
	// if is true console.log are enabled to sniff animation'state
	var debugAnimation = false;
	
	// player statut
	var PLAYER_STATE = {
	    // player is stopped
	    STOP: 0,
	    // player plays animation
	    PLAY: 1,
	    // player is at the end of an animation
	    END: 2,
	    // player is paused
	    PAUSE: 3
	};
	
	var debugMsg = ['Stop', 'Play', 'End', 'Pause'];
	
	// if debugAnimation is true console.log are enabled to sniff animation'state
	var _DEBUG = null;
	
	if (debugAnimation) {
	    _DEBUG = function DEBUG(message, animation) {
	        if (animation) {
	            // eslint-disable-next-line no-console
	            console.info('Animation ', message, ' : ', animation.name);
	        }
	    };
	} else {
	    _DEBUG = function _DEBUG() {};
	}
	
	// Private functions
	// stop timer and re-init parameter
	var resetTimer = function resetTimer(player) {
	    if (player.id) {
	        clearInterval(player.id);
	        player.id = undefined;
	    }
	    if (player.waitTimer) {
	        clearInterval(player.waitTimer);
	        player.waitTimer = undefined;
	    }
	    player.keyframe = 0;
	};
	
	// finish animation and re-init parameter
	var finishAnimation = function finishAnimation(player) {
	    resetTimer(player);
	    if (player.isEnded()) {
	        player.dispatchEvent({
	            type: 'animation-ended',
	            animation: player.animation
	        });
	    }
	    player.dispatchEvent({
	        type: 'animation-stopped',
	        animation: player.animation
	    });
	    player.animation = null;
	    if (player.resolve) {
	        player.resolve();
	        player.resolve = null;
	        player.promise = null;
	    }
	};
	
	var setPlayerState = function setPlayerState(player, state) {
	    player.state = state;
	    _DEBUG(debugMsg[state], player.animation);
	};
	
	/**
	 * AnimationPlayer
	 * It can play, pause or stop Animation or AnimationExpression (See below).
	 * AnimationPlayer is needed to use Animation or AnimationExpression
	 * AnimationPlayer emits events :
	 *       - for each animation's frame;
	 *       - when Animation is stopped
	 *       - when Animation is ending
	 */
	
	var AnimationPlayer = function (_THREE$EventDispatche) {
	    (0, _inherits3.default)(AnimationPlayer, _THREE$EventDispatche);
	
	    function AnimationPlayer() {
	        (0, _classCallCheck3.default)(this, AnimationPlayer);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (AnimationPlayer.__proto__ || (0, _getPrototypeOf2.default)(AnimationPlayer)).call(this));
	
	        _this.id = null;
	        _this.keyframe = 0;
	        _this.animation = null;
	        _this.resolve = null;
	        _this.promise = null;
	        _this.state = PLAYER_STATE.STOP;
	        _this.waitTimer = null;
	        return _this;
	    }
	
	    (0, _createClass3.default)(AnimationPlayer, [{
	        key: 'isPlaying',
	        value: function isPlaying() {
	            return this.state === PLAYER_STATE.PLAY;
	        }
	    }, {
	        key: 'isStopped',
	        value: function isStopped() {
	            return this.state === PLAYER_STATE.STOP;
	        }
	    }, {
	        key: 'isEnded',
	        value: function isEnded() {
	            return this.state === PLAYER_STATE.END;
	        }
	
	        // Public functions
	
	        /**
	         * { Start animation }
	         * this function play one animation.
	         * If another animation is playing, it's stopped and the new animation is played
	         * @param      {Animation} The animation to play
	         * @return     {Promise}  Promise is resolved when animation is stopped or finished
	         */
	
	    }, {
	        key: 'play',
	        value: function play(animation) {
	            var _this2 = this;
	
	            this.animation = animation;
	            this.dispatchEvent({
	                type: 'animation-started',
	                animation: animation });
	            setPlayerState(this, PLAYER_STATE.PLAY);
	            resetTimer(this);
	            this.id = setInterval(this.frame.bind(this), FRAME_DURATION);
	            this.promise = new _promise2.default(function (r) {
	                _this2.resolve = r;
	            });
	            return this.promise;
	        }
	
	        /**
	         * { The animation is played after a number of frames }
	         *
	         * @param      {Animation}  animation    The animation to play
	         * @param      {Number}  waitingTime  The waiting time before start animation (time in frame)
	         */
	
	    }, {
	        key: 'playLater',
	        value: function playLater(animation, waitingFrame) {
	            var _this3 = this;
	
	            this.resolveWait = null;
	            var promise = new _promise2.default(function (r) {
	                _this3.resolveWait = r;
	            });
	            var timew = Math.floor(FRAME_DURATION * waitingFrame);
	            window.clearInterval(this.waitTimer);
	            this.waitTimer = window.setTimeout(function () {
	                _this3.play(animation).then(function () {
	                    return _this3.resolveWait();
	                });
	            }, timew);
	            return promise;
	        }
	
	        /**
	         * { Stop current animation }
	         *
	         * @return  {Promise}  Promise is resolved when animation is stopped or finished
	         */
	
	    }, {
	        key: 'stop',
	        value: function stop() {
	            setPlayerState(this, PLAYER_STATE.STOP);
	            finishAnimation(this);
	            // needed to return promise to wait sync
	            return _promise2.default.resolve();
	        }
	
	        /**
	         * { this function is executed with each frame }
	         */
	
	    }, {
	        key: 'frame',
	        value: function frame() {
	            if (this.keyframe < this.animation.duration) {
	                if (this.animation.animate) {
	                    this.animation.animate(this.keyframe);
	                }
	                this.keyframe++;
	                this.dispatchEvent({
	                    type: 'animation-frame'
	                });
	            } else {
	                setPlayerState(this, PLAYER_STATE.END);
	                finishAnimation(this);
	            }
	        }
	    }]);
	    return AnimationPlayer;
	}(THREE.EventDispatcher);
	
	/**
	 * { Animation }
	 * Animation is play by the AnimationPlayer during the time of duration
	 * During playback, the AnimationPlayer emits event for each frame
	 * Animation is used to execute a callback to each frame
	 * @class      Animation
	 * @param      {Number}  duration  The animation's duration in number of frames. FRAMERATE is number of frames in one seconde.
	 * @param      {String}  name      The animation's name. It's used for debug message.
	 */
	
	
	var Animation = function Animation(params) {
	    (0, _classCallCheck3.default)(this, Animation);
	
	    this.duration = params.duration || FRAMERATE;
	    this.name = params.name;
	};
	
	/**
	 * { function_description }
	 * AnimatedExpression is play by the AnimationPlayer during the time of duration
	 * During playback, the AnimationPlayer emits event for each frame and
	 * it applies expression on root.
	 * AnimatedExpression is used to change object's values for each frame
	 * @class      AnimatedExpression (name)
	 * @param      {Number}   duration    The animation's duration in number of frames. FRAMERATE is number of frames in one seconde.
	 * @param      {Object}   root        The root is the object in scene to animate
	 * @param      {Function} expression  The expression is function applied to root with each frame
	 * @param      {String}   name        The animation's name. It's used for debug message
	  */
	
	var AnimatedExpression = function (_Animation) {
	    (0, _inherits3.default)(AnimatedExpression, _Animation);
	
	    function AnimatedExpression(params) {
	        (0, _classCallCheck3.default)(this, AnimatedExpression);
	
	        var _this4 = (0, _possibleConstructorReturn3.default)(this, (AnimatedExpression.__proto__ || (0, _getPrototypeOf2.default)(AnimatedExpression)).call(this, params));
	
	        _this4.root = params.root;
	        _this4.expression = params.expression;
	        return _this4;
	    }
	
	    (0, _createClass3.default)(AnimatedExpression, [{
	        key: 'animate',
	        value: function animate(keyFrame) {
	            this.expression(this.root, keyFrame / this.duration);
	        }
	    }]);
	    return AnimatedExpression;
	}(Animation);
	
	exports.Animation = Animation;
	exports.AnimatedExpression = AnimatedExpression;
	exports.default = AnimationPlayer;

/***/ },
/* 329 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(266);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(332);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(333);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(336);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(334), __esModule: true };

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(54);
	__webpack_require__(30);
	module.exports = __webpack_require__(335).f('iterator');

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(53);

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(337), __esModule: true };

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(338);
	__webpack_require__(244);
	__webpack_require__(345);
	__webpack_require__(346);
	module.exports = __webpack_require__(15).Symbol;

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(11)
	  , has            = __webpack_require__(8)
	  , DESCRIPTORS    = __webpack_require__(23)
	  , $export        = __webpack_require__(14)
	  , redefine       = __webpack_require__(40)
	  , META           = __webpack_require__(251).KEY
	  , $fails         = __webpack_require__(24)
	  , shared         = __webpack_require__(10)
	  , setToStringTag = __webpack_require__(52)
	  , uid            = __webpack_require__(12)
	  , wks            = __webpack_require__(53)
	  , wksExt         = __webpack_require__(335)
	  , wksDefine      = __webpack_require__(339)
	  , keyOf          = __webpack_require__(340)
	  , enumKeys       = __webpack_require__(341)
	  , isArray        = __webpack_require__(256)
	  , anObject       = __webpack_require__(20)
	  , toIObject      = __webpack_require__(35)
	  , toPrimitive    = __webpack_require__(26)
	  , createDesc     = __webpack_require__(27)
	  , _create        = __webpack_require__(42)
	  , gOPNExt        = __webpack_require__(342)
	  , $GOPD          = __webpack_require__(344)
	  , $DP            = __webpack_require__(19)
	  , $keys          = __webpack_require__(44)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(343).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(241).f  = $propertyIsEnumerable;
	  __webpack_require__(240).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(39)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(18)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(11)
	  , core           = __webpack_require__(15)
	  , LIBRARY        = __webpack_require__(39)
	  , wksExt         = __webpack_require__(335)
	  , defineProperty = __webpack_require__(19).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(44)
	  , toIObject = __webpack_require__(35);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(44)
	  , gOPS    = __webpack_require__(240)
	  , pIE     = __webpack_require__(241);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(35)
	  , gOPN      = __webpack_require__(343).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(45)
	  , hiddenKeys = __webpack_require__(50).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(241)
	  , createDesc     = __webpack_require__(27)
	  , toIObject      = __webpack_require__(35)
	  , toPrimitive    = __webpack_require__(26)
	  , has            = __webpack_require__(8)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(23) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(339)('asyncIterator');

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(339)('observable');

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(348);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(332);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(349), __esModule: true };

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(350);
	module.exports = __webpack_require__(15).Object.setPrototypeOf;

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(14);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(351).set});

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(21)
	  , anObject = __webpack_require__(20);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(16)(Function.call, __webpack_require__(344).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.globeSchemeTile1 = exports.globeSchemeTile0 = undefined;
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	exports.preGlobeUpdate = preGlobeUpdate;
	exports.globeCulling = globeCulling;
	exports.globeSubdivisionControl = globeSubdivisionControl;
	exports.globeSchemeTileWMTS = globeSchemeTileWMTS;
	exports.computeTileZoomFromDistanceCamera = computeTileZoomFromDistanceCamera;
	exports.computeDistanceCameraFromTileZoom = computeDistanceCameraFromTileZoom;
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _MathExtended = __webpack_require__(228);
	
	var _MathExtended2 = _interopRequireDefault(_MathExtended);
	
	var _SchemeTile = __webpack_require__(353);
	
	var _SchemeTile2 = _interopRequireDefault(_SchemeTile);
	
	var _Coordinates = __webpack_require__(217);
	
	var _OGCWebServiceHelper = __webpack_require__(286);
	
	var _Extent = __webpack_require__(296);
	
	var _Extent2 = _interopRequireDefault(_Extent);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var cV = new THREE.Vector3();
	var vhMagnitudeSquared = void 0;
	var radius = void 0;
	
	var preSSE = void 0;
	var SSE_SUBDIVISION_THRESHOLD = void 0;
	
	function preGlobeUpdate(context) {
	    radius = (0, _Coordinates.ellipsoidSizes)();
	    // pre-horizon culling
	    cV.copy(context.camera.position()).divide(radius);
	    vhMagnitudeSquared = cV.lengthSq() - 1.0;
	
	    // pre-sse
	    var canvasSize = context.engine.getWindowSize();
	    var hypotenuse = canvasSize.length();
	    var radAngle = context.camera.FOV * Math.PI / 180;
	
	    // TODO: not correct -> see new preSSE
	    // const HFOV = 2.0 * Math.atan(Math.tan(radAngle * 0.5) / context.camera.ratio);
	    var HYFOV = 2.0 * Math.atan(Math.tan(radAngle * 0.5) * hypotenuse / canvasSize.x);
	
	    preSSE = hypotenuse * (2.0 * Math.tan(HYFOV * 0.5));
	}
	
	function pointHorizonCulling(pt) {
	    // see https://cesiumjs.org/2013/04/25/Horizon-culling/
	    var vT = pt.divide(radius).sub(cV);
	
	    var vtMagnitudeSquared = vT.lengthSq();
	
	    var dot = -vT.dot(cV);
	
	    var isOccluded = vhMagnitudeSquared < dot && vhMagnitudeSquared < dot * dot / vtMagnitudeSquared;
	
	    return isOccluded;
	}
	
	function horizonCulling(node) {
	    // horizonCulling Oriented bounding box
	    var points = node.OBB().pointsWorld;
	    var isVisible = false;
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(points), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var point = _step.value;
	
	            if (!pointHorizonCulling(point.clone())) {
	                isVisible = true;
	                break;
	            }
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return isVisible;
	}
	
	function frustumCullingOBB(node, camera) {
	    return camera.isBox3DVisible(node.OBB().box3D, node.OBB().matrixWorld);
	}
	
	function globeCulling(minLevelForHorizonCulling) {
	    return function _globeCulling(node, camera) {
	        return !(frustumCullingOBB(node, camera) && (node.level < minLevelForHorizonCulling || horizonCulling(node)));
	    };
	}
	
	function computeNodeSSE(camera, node) {
	    var boundingSphere = node.geometry.boundingSphere;
	    var distance = Math.max(0.0, camera.camera3D.position.distanceTo(node.centerSphere) - boundingSphere.radius);
	
	    // Removed because is false computation, it doesn't consider the altitude of node
	    // Added small oblique weight (distance is not enough, tile orientation is needed)
	    /*
	    var altiW = node.bbox.top() === 10000 ? 0. : node.bbox.bottom() / 10000.;
	    var dotProductW = Math.min(altiW + Math.abs(this.camera3D.getWorldDirection().dot(node.centerSphere.clone().normalize())), 1.);
	    if (this.camera3D.position.length() > 6463300) dotProductW = 1;
	    var SSE = Math.sqrt(dotProductW) * this.preSSE * (node.geometricError / distance);
	    */
	
	    // TODO: node.geometricError is computed using a hardcoded 18 level
	    // The computation of node.geometricError is surely false
	    return preSSE * (node.geometricError / distance);
	}
	
	function globeSubdivisionControl(minLevel, maxLevel, sseThreshold) {
	    SSE_SUBDIVISION_THRESHOLD = sseThreshold;
	    return function _globeSubdivisionControl(context, layer, node) {
	        if (node.level < minLevel) {
	            return true;
	        }
	        if (maxLevel <= node.level) {
	            return false;
	        }
	
	        var sse = computeNodeSSE(context.camera, node);
	
	        return SSE_SUBDIVISION_THRESHOLD < sse;
	    };
	}
	
	// bbox longitude(0,360),latitude(-90,90)
	var globeSchemeTile0 = exports.globeSchemeTile0 = 0;
	// bbox longitude(-180,180),latitude(-90,90)
	var globeSchemeTile1 = exports.globeSchemeTile1 = 1;
	
	function globeSchemeTileWMTS(type) {
	    var schemeT = new _SchemeTile2.default();
	
	    if (type === 0) {
	        // bbox longitude(0,360),latitude(-90,90)
	        schemeT.add(new _Extent2.default('EPSG:4326', 0, _MathExtended2.default.PI, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	        schemeT.add(new _Extent2.default('EPSG:4326', _MathExtended2.default.PI, _MathExtended2.default.TWO_PI, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	    } else if (type == 1) {
	        // bbox longitude(-180,180),latitude(-90,90)
	        schemeT.add(new _Extent2.default('EPSG:4326', -_MathExtended2.default.PI, 0, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	        schemeT.add(new _Extent2.default('EPSG:4326', 0, _MathExtended2.default.PI, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	    }
	    // store internally as Radians to avoid doing too much deg->rad conversions
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = (0, _getIterator3.default)(schemeT.schemeBB), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var bbox = _step2.value;
	
	            bbox._internalStorageUnit = _Coordinates.UNIT.RADIAN;
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    return schemeT;
	}
	
	function computeTileZoomFromDistanceCamera(distance) {
	    var sizeEllipsoid = (0, _Coordinates.ellipsoidSizes)().x;
	    var preSinus = _OGCWebServiceHelper.SIZE_TEXTURE_TILE * (SSE_SUBDIVISION_THRESHOLD * 0.5) / preSSE / sizeEllipsoid;
	
	    var sinus = distance * preSinus;
	    var zoom = Math.log(Math.PI / (2.0 * Math.asin(sinus))) / Math.log(2);
	
	    var delta = Math.PI / Math.pow(2, zoom);
	    var circleChord = 2.0 * sizeEllipsoid * Math.sin(delta * 0.5);
	    var radius = circleChord * 0.5;
	
	    // adjust with bounding sphere rayon
	    sinus = (distance - radius) * preSinus;
	    zoom = Math.log(Math.PI / (2.0 * Math.asin(sinus))) / Math.log(2);
	
	    return isNaN(zoom) ? 0 : Math.round(zoom);
	}
	
	function computeDistanceCameraFromTileZoom(zoom) {
	    var delta = Math.PI / Math.pow(2, zoom);
	    var circleChord = 2.0 * (0, _Coordinates.ellipsoidSizes)().x * Math.sin(delta * 0.5);
	    var radius = circleChord * 0.5;
	    var error = radius / _OGCWebServiceHelper.SIZE_TEXTURE_TILE;
	
	    return preSSE * error / (SSE_SUBDIVISION_THRESHOLD * 0.5) + radius;
	}

/***/ },
/* 353 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: SchemeTile
	 * Description: Cette classe dcrit un dcoupage spatiale.
	 */
	
	function SchemeTile() {
	    // Constructor
	
	    this.maximumChildren = 4;
	    this.schemeBB = [];
	}
	/**
	 *
	 * @param {type} minLo
	 * @param {type} maxLo
	 * @param {type} minLa
	 * @param {type} maxLa
	 * @returns {SchemeTile_L8.SchemeTile.prototype@pro;schemeBB@call;push}
	 */
	
	SchemeTile.prototype.add = function add(bbox) {
	    return this.schemeBB.push(bbox);
	};
	
	SchemeTile.prototype.rootCount = function rootCount() {
	    return this.schemeBB.length;
	};
	
	SchemeTile.prototype.getRoot = function getRoot(id) {
	    return this.schemeBB[id];
	};
	
	exports.default = SchemeTile;

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.GLOBE_VIEW_EVENTS = undefined;
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _View = __webpack_require__(235);
	
	var _View2 = _interopRequireDefault(_View);
	
	var _ColorLayersOrdering = __webpack_require__(322);
	
	var _RendererConstant = __webpack_require__(315);
	
	var _RendererConstant2 = _interopRequireDefault(_RendererConstant);
	
	var _GlobeControls = __webpack_require__(326);
	
	var _GlobeControls2 = _interopRequireDefault(_GlobeControls);
	
	var _MatteIdsMaterial = __webpack_require__(313);
	
	var _Layer = __webpack_require__(265);
	
	var _Atmosphere = __webpack_require__(355);
	
	var _Atmosphere2 = _interopRequireDefault(_Atmosphere);
	
	var _CoordStars = __webpack_require__(363);
	
	var _CoordStars2 = _interopRequireDefault(_CoordStars);
	
	var _Clouds = __webpack_require__(364);
	
	var _Clouds2 = _interopRequireDefault(_Clouds);
	
	var _Coordinates = __webpack_require__(217);
	
	var _TiledNodeProcessing = __webpack_require__(323);
	
	var _LayeredMaterialNodeProcessing = __webpack_require__(324);
	
	var _GlobeTileProcessing = __webpack_require__(352);
	
	var _BuilderEllipsoidTile = __webpack_require__(367);
	
	var _BuilderEllipsoidTile2 = _interopRequireDefault(_BuilderEllipsoidTile);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Globe's EVENT
	 * @property GLOBE_INITIALIZED {string} emit one time when globe is initialized
	 * @property LAYER_ADDED {string} emit when layer id added in viewer
	 * @property LAYER_REMOVED {string} emit when layer id removed in viewer
	 * @property COLOR_LAYERS_ORDER_CHANGED {string} emit when  color layers order change
	 * @example
	 * viewer.addEventListener(itowns.GLOBE_VIEW_EVENTS.LAYER_REMOVED, (event) => console.log(event));
	 */
	
	var GLOBE_VIEW_EVENTS = exports.GLOBE_VIEW_EVENTS = {
	    GLOBE_INITIALIZED: 'initialized',
	    LAYER_ADDED: 'layer-added',
	    LAYER_REMOVED: 'layer-removed',
	    COLOR_LAYERS_ORDER_CHANGED: _ColorLayersOrdering.COLOR_LAYERS_ORDER_CHANGED
	};
	
	/**
	 * Creates the viewer Globe (the globe of iTowns).
	 * The first parameter is the coordinates on wich the globe will be centered at the initialization.
	 * The second one is the HTML div in wich the scene will be created.
	 * @constructor
	 * @augments View
	 * @params {Div} string.
	 * @param {Coords} coords.
	 */
	function GlobeView(viewerDiv, coordCarto, options) {
	    var _this = this;
	
	    THREE.Object3D.DefaultUp.set(0, 0, 1);
	    var size = (0, _Coordinates.ellipsoidSizes)().x;
	    // Setup View
	    _View2.default.call(this, 'EPSG:4978', viewerDiv, options);
	
	    // Configure camera
	    var positionCamera = new _Coordinates.C.EPSG_4326(coordCarto.longitude, coordCarto.latitude, coordCarto.altitude);
	
	    this.camera.setPosition(positionCamera.as('EPSG:4978').xyz());
	    this.camera.camera3D.lookAt({ x: 0, y: 0, z: 0 });
	    this.camera.camera3D.near = Math.max(15.0, 0.000002352 * size);
	    this.camera.camera3D.far = size * 10;
	    this.camera.camera3D.updateProjectionMatrix();
	    this.camera.camera3D.updateMatrixWorld(true);
	
	    // Configure tiles
	    var nodeInitFn = function nodeInitFn(context, layer, parent, node) {
	        node.materials[0].setLightingOn(layer.lighting.enable);
	        node.materials[0].uniforms.lightPosition.value = layer.lighting.position;
	
	        if (false) {
	            node.material.uniforms.showOutline = { value: layer.showOutline || false };
	            node.material.wireframe = layer.wireframe || false;
	        }
	    };
	    var SSE_SUBDIVISION_THRESHOLD = 1.0;
	
	    function _commonAncestorLookup(a, b) {
	        if (!a || !b) {
	            return undefined;
	        }
	        if (a.level == b.level) {
	            if (a.id == b.id) {
	                return a;
	            } else if (a.level != 0) {
	                return _commonAncestorLookup(a.parent, b.parent);
	            } else {
	                return undefined;
	            }
	        } else if (a.level < b.level) {
	            return _commonAncestorLookup(a, b.parent);
	        } else {
	            return _commonAncestorLookup(a.parent, b);
	        }
	    }
	
	    var wgs84TileLayer = new _Layer.GeometryLayer('globe');
	    var initLayer = (0, _TiledNodeProcessing.initTiledGeometryLayer)((0, _GlobeTileProcessing.globeSchemeTileWMTS)(_GlobeTileProcessing.globeSchemeTile1));
	    wgs84TileLayer.preUpdate = function (context, layer, changeSources) {
	        _this._latestUpdateStartingLevel = 0;
	        if (layer.level0Nodes === undefined) {
	            initLayer(context, layer);
	        }
	        (0, _GlobeTileProcessing.preGlobeUpdate)(context);
	        if (changeSources.has(undefined) || changeSources.size == 0) {
	            return layer.level0Nodes;
	        }
	        var commonAncestor = void 0;
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = (0, _getIterator3.default)(changeSources.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var source = _step.value;
	
	                if (!commonAncestor) {
	                    commonAncestor = source;
	                } else {
	                    commonAncestor = _commonAncestorLookup(commonAncestor, source);
	                    if (!commonAncestor) {
	                        return layer.level0Nodes;
	                    }
	                }
	                if (commonAncestor.material == null) {
	                    commonAncestor = undefined;
	                }
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	
	        if (commonAncestor) {
	            _this._latestUpdateStartingLevel = commonAncestor.level;
	            return [commonAncestor];
	        } else {
	            return [];
	        }
	    };
	
	    wgs84TileLayer.update = (0, _TiledNodeProcessing.processTiledGeometryNode)((0, _GlobeTileProcessing.globeCulling)(2), (0, _GlobeTileProcessing.globeSubdivisionControl)(2, 17, SSE_SUBDIVISION_THRESHOLD), nodeInitFn);
	    wgs84TileLayer.builder = new _BuilderEllipsoidTile2.default();
	
	    wgs84TileLayer.type = 'geometry';
	    wgs84TileLayer.protocol = 'tile';
	    wgs84TileLayer.visible = true;
	    wgs84TileLayer.lighting = {
	        enable: false,
	        position: { x: -0.5, y: 0.0, z: 1.0 }
	    };
	
	    this.addLayer(wgs84TileLayer);
	
	    // Atmosphere
	    this.atmosphere = new _Atmosphere2.default();
	    this.clouds = new _Clouds2.default();
	    this.atmosphere.add(this.clouds);
	
	    var atmosphereLayer = this.mainLoop.gfxEngine.getUniqueThreejsLayer();
	    this.atmosphere.traverse(function (obj) {
	        obj.layers.set(atmosphereLayer);
	    });
	    this.camera.camera3D.layers.enable(atmosphereLayer);
	
	    this.scene.add(this.atmosphere);
	
	    // Configure controls
	    var positionTargetCamera = positionCamera.clone();
	    positionTargetCamera.setAltitude(0);
	
	    this.controls = new _GlobeControls2.default(this, positionTargetCamera.as('EPSG:4978').xyz(), this.mainLoop.gfxEngine.renderer.domElement, viewerDiv, size, this.getPickingPositionFromDepth.bind(this));
	    this.controls.rotateSpeed = 0.25;
	    this.controls.zoomSpeed = 2.0;
	    this.controls.minDistance = 30;
	    this.controls.maxDistance = size * 8.0;
	
	    this.controls.addEventListener('change', function () {
	        _this.camera.update();
	        _this.notifyChange(0, true);
	    });
	
	    this.controls.addEventListener('selectClick', function (event) {
	        _this.selectNodeAt(event.mouse);
	    }, false);
	
	    this._renderState = _RendererConstant2.default.FINAL;
	
	    this.preRender = function () {
	        var len = _this.camera.position().length();
	        var lim = size * 1.1;
	
	        if (len < lim) {
	            var t = Math.pow(Math.cos((lim - len) / (lim - size * 0.9981) * Math.PI * 0.5), 1.5);
	            var color = new THREE.Color(0x93d5f8);
	            _this.mainLoop.gfxEngine.renderer.setClearColor(color.multiplyScalar(1.0 - t));
	        } else if (len >= lim) {
	            _this.mainLoop.gfxEngine.renderer.setClearColor(0x030508);
	        }
	    };
	
	    this.wgs84TileLayer = wgs84TileLayer;
	
	    var fn = function fn() {
	        _this.mainLoop.removeEventListener('command-queue-empty', fn);
	        _this.dispatchEvent({ type: GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED });
	    };
	
	    this.mainLoop.addEventListener('command-queue-empty', fn);
	
	    window.addEventListener('resize', function () {
	        _this.controls.updateCamera(_this.camera, _this.viewerDiv.clientWidth, _this.viewerDiv.clientHeight);
	    }, false);
	
	    this.notifyChange(0, true);
	}
	
	GlobeView.prototype = (0, _create2.default)(_View2.default.prototype);
	GlobeView.prototype.constructor = GlobeView;
	
	GlobeView.prototype.addLayer = function addLayer(layer) {
	    if (layer.type == 'color') {
	        var colorLayerCount = this.getLayers(function (l) {
	            return l.type === 'color';
	        }).length;
	        layer.sequence = colorLayerCount - 1;
	        layer.update = _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeImagery;
	    } else if (layer.type == 'elevation') {
	        if (layer.protocol === 'wmts' && layer.options.tileMatrixSet !== 'WGS84G') {
	            throw new Error('Only WGS84G tileMatrixSet is currently supported for WMTS elevation layers');
	        }
	        layer.update = _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeElevation;
	    }
	    _View2.default.prototype.addLayer.call(this, layer, this.wgs84TileLayer);
	
	    this.dispatchEvent({ type: GLOBE_VIEW_EVENTS.LAYER_ADDED });
	
	    return layer;
	};
	
	/**
	 * Removes a specific imagery layer from the current layer list. This removes layers inserted with attach().
	 * @param      {string}   layerId      The identifier
	 * @return     {boolean}
	 */
	GlobeView.prototype.removeLayer = function removeImageryLayer(layerId) {
	    var layer = this.getLayers(function (l) {
	        return l.id === layerId;
	    })[0];
	    if (layer && layer.type === 'color' && this.wgs84TileLayer.detach(layer)) {
	        var cO = function cO(object) {
	            if (object.removeColorLayer) {
	                object.removeColorLayer(layerId);
	            }
	        };
	
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	            for (var _iterator2 = (0, _getIterator3.default)(this.wgs84TileLayer.level0Nodes), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                var root = _step2.value;
	
	                root.traverse(cO);
	            }
	        } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                    _iterator2.return();
	                }
	            } finally {
	                if (_didIteratorError2) {
	                    throw _iteratorError2;
	                }
	            }
	        }
	
	        var imageryLayers = this.getLayers(function (l) {
	            return l.type === 'color';
	        });
	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;
	
	        try {
	            for (var _iterator3 = (0, _getIterator3.default)(imageryLayers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                var color = _step3.value;
	
	                if (color.sequence > layer.sequence) {
	                    color.sequence--;
	                }
	            }
	        } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                    _iterator3.return();
	                }
	            } finally {
	                if (_didIteratorError3) {
	                    throw _iteratorError3;
	                }
	            }
	        }
	
	        this.notifyChange(0, true);
	        this.dispatchEvent({
	            type: GLOBE_VIEW_EVENTS.LAYER_REMOVED,
	            layerId: layerId
	        });
	
	        return true;
	    } else {
	        throw new Error(layerId + ' isn\'t color layer');
	    }
	};
	
	GlobeView.prototype.selectNodeAt = function selectNodeAt(mouse) {
	    var selectedId = this.screenCoordsToNodeId(mouse);
	
	    var _iteratorNormalCompletion4 = true;
	    var _didIteratorError4 = false;
	    var _iteratorError4 = undefined;
	
	    try {
	        for (var _iterator4 = (0, _getIterator3.default)(this.wgs84TileLayer.level0Nodes), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var n = _step4.value;
	
	            n.traverse(function (node) {
	                // only take of selectable nodes
	                if (node.setSelected) {
	                    node.setSelected(node.id === selectedId);
	
	                    if (node.id === selectedId) {
	                        // eslint-disable-next-line no-console
	                        console.info(node);
	                    }
	                }
	            });
	        }
	    } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                _iterator4.return();
	            }
	        } finally {
	            if (_didIteratorError4) {
	                throw _iteratorError4;
	            }
	        }
	    }
	
	    this.notifyChange(0, true);
	};
	
	GlobeView.prototype.screenCoordsToNodeId = function screenCoordsToNodeId(mouse) {
	    var dim = this.mainLoop.gfxEngine.getWindowSize();
	
	    mouse = mouse || new THREE.Vector2(Math.floor(dim.x / 2), Math.floor(dim.y / 2));
	
	    this.camera.update();
	
	    var previousRenderState = this._renderState;
	    this.changeRenderState(_RendererConstant2.default.ID);
	
	    // Prepare state
	    var prev = this.camera.camera3D.layers.mask;
	    this.camera.camera3D.layers.mask = 1 << this.wgs84TileLayer.threejsLayer;
	
	    var buffer = this.mainLoop.gfxEngine.renderViewTobuffer(this, this.mainLoop.gfxEngine.fullSizeRenderTarget, mouse.x, dim.y - mouse.y, 1, 1);
	
	    this.changeRenderState(previousRenderState);
	    this.camera.camera3D.layers.mask = prev;
	
	    var depthRGBA = new THREE.Vector4().fromArray(buffer).divideScalar(255.0);
	
	    // unpack RGBA to float
	    var unpack = (0, _MatteIdsMaterial.unpack1K)(depthRGBA, 10000);
	
	    return Math.round(unpack);
	};
	
	var matrix = new THREE.Matrix4();
	matrix.elements = new Float64Array(16); // /!\ WARNING Matrix JS are in Float32Array
	var screen = new THREE.Vector2();
	var pickWorldPosition = new THREE.Vector3();
	var ray = new THREE.Ray();
	var direction = new THREE.Vector3();
	var depthRGBA = new THREE.Vector4();
	GlobeView.prototype.getPickingPositionFromDepth = function getPickingPositionFromDepth(mouse) {
	    var dim = this.mainLoop.gfxEngine.getWindowSize();
	    mouse = mouse || dim.clone().multiplyScalar(0.5);
	
	    var camera = this.camera.camera3D;
	    this.camera.update();
	
	    // Prepare state
	    var prev = this.camera.camera3D.layers.mask;
	    this.camera.camera3D.layers.mask = 1 << this.wgs84TileLayer.threejsLayer;
	
	    var previousRenderState = this._renderState;
	    this.changeRenderState(_RendererConstant2.default.DEPTH);
	
	    // Render to buffer
	    var buffer = this.mainLoop.gfxEngine.renderViewTobuffer(this, this.mainLoop.gfxEngine.fullSizeRenderTarget, mouse.x, dim.y - mouse.y, 1, 1);
	
	    screen.x = mouse.x / dim.x * 2 - 1;
	    screen.y = -(mouse.y / dim.y) * 2 + 1;
	
	    camera.matrixWorld.setPosition(camera.position);
	
	    // Origin
	    ray.origin.copy(camera.position);
	
	    // Direction
	    ray.direction.set(screen.x, screen.y, 0.5);
	    // Unproject
	    matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
	    ray.direction.applyMatrix4(matrix);
	    ray.direction.sub(ray.origin);
	
	    direction.set(0, 0, 1.0);
	    direction.applyMatrix4(matrix);
	    direction.sub(ray.origin);
	
	    var angle = direction.angleTo(ray.direction);
	
	    depthRGBA.fromArray(buffer).divideScalar(255.0);
	
	    var depth = (0, _MatteIdsMaterial.unpack1K)(depthRGBA, 100000000.0) / Math.cos(angle);
	
	    pickWorldPosition.addVectors(camera.position, ray.direction.setLength(depth));
	
	    // Restore initial state
	    this.changeRenderState(previousRenderState);
	    camera.layers.mask = prev;
	    camera.updateMatrixWorld(true);
	
	    if (pickWorldPosition.length() > 10000000) {
	        return undefined;
	    }
	
	    return pickWorldPosition;
	};
	
	GlobeView.prototype.changeRenderState = function changeRenderState(newRenderState) {
	    if (this._renderState == newRenderState || !this.wgs84TileLayer.level0Nodes) {
	        return;
	    }
	
	    // build traverse function
	    var changeStateFunction = function getChangeStateFunctionFn() {
	        return function changeStateFunction(object3D) {
	            if (object3D.changeState) {
	                object3D.changeState(newRenderState);
	            }
	        };
	    }();
	
	    var _iteratorNormalCompletion5 = true;
	    var _didIteratorError5 = false;
	    var _iteratorError5 = undefined;
	
	    try {
	        for (var _iterator5 = (0, _getIterator3.default)(this.wgs84TileLayer.level0Nodes), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	            var n = _step5.value;
	
	            n.traverseVisible(changeStateFunction);
	        }
	    } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                _iterator5.return();
	            }
	        } finally {
	            if (_didIteratorError5) {
	                throw _iteratorError5;
	            }
	        }
	    }
	
	    this._renderState = newRenderState;
	};
	
	GlobeView.prototype.setRealisticLightingOn = function setRealisticLightingOn(value) {
	    var coSun = _CoordStars2.default.getSunPositionInScene(new Date().getTime(), 48.85, 2.35).normalize();
	
	    this.lightingPos = coSun.normalize();
	
	    var lighting = this.wgs84TileLayer.lighting;
	    lighting.enable = value;
	    lighting.position = coSun;
	
	    this.atmosphere.updateLightingPos(coSun);
	    this.atmosphere.setRealisticOn(value);
	    this.clouds.updateLightingPos(coSun);
	    this.clouds.setLightingOn(value);
	
	    this.updateMaterialUniform('lightingEnabled', value);
	    this.updateMaterialUniform('lightPosition', coSun);
	    this.notifyChange(0, true);
	};
	
	GlobeView.prototype.setLightingPos = function setLightingPos(pos) {
	    var lightingPos = pos || _CoordStars2.default.getSunPositionInScene(this.ellipsoid, new Date().getTime(), 48.85, 2.35);
	
	    this.updateMaterialUniform('lightPosition', lightingPos.clone().normalize());
	    this.notifyChange(0, true);
	};
	
	GlobeView.prototype.updateMaterialUniform = function updateMaterialUniform(uniformName, value) {
	    var _iteratorNormalCompletion6 = true;
	    var _didIteratorError6 = false;
	    var _iteratorError6 = undefined;
	
	    try {
	        for (var _iterator6 = (0, _getIterator3.default)(this.wgs84TileLayer.level0Nodes), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	            var n = _step6.value;
	
	            n.traverse(function (obj) {
	                if (!obj.material || !obj.material.uniforms) {
	                    return;
	                }
	                if (uniformName in obj.material.uniforms) {
	                    obj.material.uniforms[uniformName].value = value;
	                }
	            });
	        }
	    } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                _iterator6.return();
	            }
	        } finally {
	            if (_didIteratorError6) {
	                throw _iteratorError6;
	            }
	        }
	    }
	};
	
	exports.default = GlobeView;

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LIGHTING_POSITION = undefined;
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _SkyShader = __webpack_require__(356);
	
	var _SkyShader2 = _interopRequireDefault(_SkyShader);
	
	var _skyFS = __webpack_require__(357);
	
	var _skyFS2 = _interopRequireDefault(_skyFS);
	
	var _skyVS = __webpack_require__(358);
	
	var _skyVS2 = _interopRequireDefault(_skyVS);
	
	var _groundFS = __webpack_require__(359);
	
	var _groundFS2 = _interopRequireDefault(_groundFS);
	
	var _groundVS = __webpack_require__(360);
	
	var _groundVS2 = _interopRequireDefault(_groundVS);
	
	var _GlowFS = __webpack_require__(361);
	
	var _GlowFS2 = _interopRequireDefault(_GlowFS);
	
	var _GlowVS = __webpack_require__(362);
	
	var _GlowVS2 = _interopRequireDefault(_GlowVS);
	
	var _Coordinates = __webpack_require__(217);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LIGHTING_POSITION = exports.LIGHTING_POSITION = new THREE.Vector3(1, 0, 0); /*
	                                                                                 * To change this license header, choose License Headers in Project Properties.
	                                                                                 * To change this template file, choose Tools | Templates
	                                                                                 * and open the template in the editor.
	                                                                                 */
	
	function Atmosphere() {
	    THREE.Mesh.call(this);
	
	    this.realistic = false;
	    this.sphereSun = null;
	
	    this.uniformsOut = {
	        atmoIN: {
	            type: 'i',
	            value: 0
	        },
	        screenSize: {
	            type: 'v2',
	            value: new THREE.Vector2(window.innerWidth, window.innerHeight)
	        } };
	
	    var material = new THREE.ShaderMaterial({
	
	        uniforms: this.uniformsOut,
	        vertexShader: _GlowVS2.default,
	        fragmentShader: _GlowFS2.default,
	        side: THREE.BackSide,
	        blending: THREE.AdditiveBlending,
	        transparent: true,
	        wireframe: false
	
	    });
	
	    var size = (0, _Coordinates.ellipsoidSizes)();
	    var geometry = new THREE.SphereGeometry(1.14, 128, 128).scale(size.x, size.y, size.z);
	
	    this.geometry = geometry;
	    this.material = material;
	
	    this.uniformsIn = {
	        atmoIN: {
	            type: 'i',
	            value: 1
	        },
	        screenSize: {
	            type: 'v2',
	            value: new THREE.Vector2(window.innerWidth, window.innerHeight)
	        } };
	
	    var materialAtmoIn = new THREE.ShaderMaterial({
	
	        uniforms: this.uniformsIn,
	        vertexShader: _GlowVS2.default,
	        fragmentShader: _GlowFS2.default,
	        side: THREE.FrontSide,
	        blending: THREE.AdditiveBlending,
	        transparent: true
	
	    });
	
	    this.atmosphereIN = new THREE.Mesh(new THREE.SphereGeometry(1.002, 64, 64).scale(size.x, size.y, size.z), materialAtmoIn);
	
	    this.add(this.atmosphereIN);
	
	    var atmosphere = {
	        Kr: 0.0025,
	        Km: 0.0010,
	        ESun: 20.0,
	        g: -0.950,
	        innerRadius: 6400000,
	        outerRadius: 6700000,
	        wavelength: [0.650, 0.570, 0.475],
	        scaleDepth: 0.25,
	        mieScaleDepth: 0.1
	    };
	
	    var uniformsSky = {
	        v3LightPosition: { value: LIGHTING_POSITION.clone().normalize() },
	        v3InvWavelength: { value: new THREE.Vector3(1 / Math.pow(atmosphere.wavelength[0], 4), 1 / Math.pow(atmosphere.wavelength[1], 4), 1 / Math.pow(atmosphere.wavelength[2], 4)) },
	        fCameraHeight: { value: 0.0 },
	        fCameraHeight2: { value: 0.0 },
	        fInnerRadius: { value: atmosphere.innerRadius },
	        fInnerRadius2: { value: atmosphere.innerRadius * atmosphere.innerRadius },
	        fOuterRadius: { value: atmosphere.outerRadius },
	        fOuterRadius2: { value: atmosphere.outerRadius * atmosphere.outerRadius },
	        fKrESun: { value: atmosphere.Kr * atmosphere.ESun },
	        fKmESun: { value: atmosphere.Km * atmosphere.ESun },
	        fKr4PI: { value: atmosphere.Kr * 4.0 * Math.PI },
	        fKm4PI: { value: atmosphere.Km * 4.0 * Math.PI },
	        fScale: { value: 1 / (atmosphere.outerRadius - atmosphere.innerRadius) },
	        fScaleDepth: { value: atmosphere.scaleDepth },
	        fScaleOverScaleDepth: { value: 1 / (atmosphere.outerRadius - atmosphere.innerRadius) / atmosphere.scaleDepth },
	        g: { value: atmosphere.g },
	        g2: { value: atmosphere.g * atmosphere.g },
	        nSamples: { value: 3 },
	        fSamples: { value: 3.0 },
	        tDisplacement: { value: new THREE.Texture() },
	        tSkyboxDiffuse: { value: new THREE.Texture() },
	        fNightScale: { value: 1.0 }
	    };
	
	    this.ground = {
	        geometry: new THREE.SphereGeometry(atmosphere.innerRadius, 50, 50),
	        material: new THREE.ShaderMaterial({
	            uniforms: uniformsSky,
	            vertexShader: _groundVS2.default,
	            fragmentShader: _groundFS2.default,
	            blending: THREE.AdditiveBlending,
	            transparent: true,
	            depthTest: false,
	            depthWrite: false
	        })
	    };
	
	    this.ground.mesh = new THREE.Mesh(this.ground.geometry, this.ground.material);
	
	    this.sky = {
	        geometry: new THREE.SphereGeometry(atmosphere.outerRadius, 196, 196),
	        material: new THREE.ShaderMaterial({
	            uniforms: uniformsSky,
	            vertexShader: _skyVS2.default,
	            fragmentShader: _skyFS2.default
	        })
	    };
	
	    this.sky.mesh = new THREE.Mesh(this.sky.geometry, this.sky.material);
	    this.sky.material.side = THREE.BackSide;
	    this.sky.material.transparent = true;
	
	    this.ground.mesh.visible = false;
	    this.sky.mesh.visible = false;
	    this.add(this.ground.mesh);
	    this.add(this.sky.mesh);
	
	    this.skyDome = new _SkyShader2.default();
	    this.skyDome.mesh.frustumCulled = false;
	    this.skyDome.mesh.material.transparent = true;
	    this.skyDome.mesh.visible = false;
	    this.skyDome.mesh.material.depthWrite = false;
	    this.add(this.skyDome.mesh);
	
	    var effectController = {
	        turbidity: 10,
	        reileigh: 2,
	        mieCoefficient: 0.005,
	        mieDirectionalG: 0.8,
	        luminance: 1,
	        inclination: 0.49, // elevation / inclination
	        azimuth: 0.25, // Facing front,
	        sun: !true
	    };
	
	    var uniforms = this.skyDome.uniforms;
	    uniforms.turbidity.value = effectController.turbidity;
	    uniforms.reileigh.value = effectController.reileigh;
	    uniforms.luminance.value = effectController.luminance;
	    uniforms.mieCoefficient.value = effectController.mieCoefficient;
	    uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
	    uniforms.up.value = new THREE.Vector3(); // no more necessary, estimate normal from cam..
	}
	
	Atmosphere.prototype = (0, _create2.default)(THREE.Mesh.prototype);
	Atmosphere.prototype.constructor = Atmosphere;
	
	Atmosphere.prototype.setRealisticOn = function setRealisticOn(bool) {
	    this.realistic = bool;
	    this.material.visible = !this.realistic;
	    this.atmosphereIN.visible = !this.realistic;
	    this.ground.mesh.visible = this.realistic;
	    this.sky.mesh.visible = this.realistic;
	    this.skyDome.mesh.visible = this.realistic;
	    // this.lensFlare.visible = this.realistic;
	
	    // this.sphereSun.visible     = this.realistic;
	};
	
	Atmosphere.prototype.updateLightingPos = function updateLightingPos(pos) {
	    this.ground.material.uniforms.v3LightPosition.value = pos.clone().normalize();
	    this.sky.material.uniforms.v3LightPosition.value = pos.clone().normalize();
	    //  this.sphereSun.position.copy(pos);
	    this.skyDome.uniforms.sunPosition.value.copy(pos);
	    // this.lensFlare.position.copy(pos);
	};
	
	exports.default = Atmosphere;

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var skyShader = {
	
	    uniforms: {
	
	        luminance: {
	            type: 'f',
	            value: 1
	        },
	        turbidity: {
	            type: 'f',
	            value: 2
	        },
	        reileigh: {
	            type: 'f',
	            value: 1
	        },
	        mieCoefficient: {
	            type: 'f',
	            value: 0.005
	        },
	        mieDirectionalG: {
	            type: 'f',
	            value: 0.8
	        },
	        sunPosition: {
	            type: 'v3',
	            value: new THREE.Vector3()
	        },
	        up: {
	            type: 'v3',
	            value: new THREE.Vector3(0.0, 1.0, 0.0)
	        }
	
	    },
	
	    vertexShader: ['varying vec3 vWorldPosition;', 'void main() {', 'vec4 worldPosition = modelMatrix *  vec4( cameraPosition + position, 1.0 );', 'vWorldPosition = worldPosition.xyz;', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( cameraPosition + position, 1.0 );', '}'].join('\n'),
	
	    fragmentShader: ['uniform sampler2D skySampler;', 'uniform vec3 sunPosition;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;',
	
	    // "vec3 cameraPos = cameraPosition; //vec3(0., 0., 0.);",
	    '// uniform sampler2D sDiffuse;', '// const float turbidity = 10.0; //', '// const float reileigh = 2.; //', '// const float luminance = 1.0; //', '// const float mieCoefficient = 0.005;', '// const float mieDirectionalG = 0.8;', 'uniform float luminance;', 'uniform float turbidity;', 'uniform float reileigh;', 'uniform float mieCoefficient;', 'uniform float mieDirectionalG;', '// constants for atmospheric scattering', 'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003; // refractive index of air', 'const float N = 2.545E25; // number of molecules per unit volume for air at', '// 288.15K and 1013mb (sea level -45 celsius)', 'const float pn = 0.035; // depolatization factor for standard air', '// wavelength of used primaries, according to preetham', 'const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);', '// mie stuff', '// K coefficient for the primaries', 'const vec3 K = vec3(0.686, 0.678, 0.666);', 'const float v = 4.0;', '// optical length at zenith for molecules', 'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;',
	    // "const vec3 up = vec3(0.0, 1.0, 0.0);",
	
	
	    'const float EE = 1000.0;', 'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', '// 66 arc seconds -> degrees, and the cosine of that', '// earth shadow hack', 'const float cutoffAngle = pi/1.95;', 'const float steepness = 1.5;', 'vec3 totalRayleigh(vec3 lambda)', '{', 'return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));', '}',
	
	    // see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness
	    '// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE', 'vec3 simplifiedRayleigh()', '{', 'return 0.0005 / vec3(94, 40, 18);',
	    // return 0.00054532832366 / (3.0 * 2.545E25 * pow(vec3(680E-9, 550E-9, 450E-9), vec3(4.0)) * 6.245);
	    '}', 'float rayleighPhase(float cosTheta)', '{ ', 'return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));', '// return (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));', '// return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));', '}', 'vec3 totalMie(vec3 lambda, vec3 K, float T)', '{', 'float c = (0.2 * T ) * 10E-18;', 'return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;', '}', 'float hgPhase(float cosTheta, float g)', '{', 'return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));', '}', 'float sunIntensity(float zenithAngleCos)', '{', 'return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));', '}', '// float logLuminance(vec3 c)', '// {', '//     return log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);', '// }', '// Filmic ToneMapping http://filmicgames.com/archives/75', 'float A = 0.15;', 'float B = 0.50;', 'float C = 0.10;', 'float D = 0.20;', 'float E = 0.02;', 'float F = 0.30;', 'float W = 1000.0;', 'vec3 Uncharted2Tonemap(vec3 x)', '{', 'return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;', '}', 'void main() ', '{', 'vec3 up2 = normalize(cameraPosition.xyz);', 'float sunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);', 'float reileighCoefficient = reileigh - (1.0* (1.0-sunfade));', 'vec3 sunDirection = normalize(sunPosition);', 'float sunE = sunIntensity(dot(sunDirection, up2));', '// extinction (absorbtion + out scattering) ', '// rayleigh coefficients',
	
	    // "vec3 betaR = totalRayleigh(lambda) * reileighCoefficient;",
	    'vec3 betaR = simplifiedRayleigh() * reileighCoefficient;', '// mie coefficients', 'vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;', '// optical length', '// cutoff angle at 90 to avoid singularity in next formula.', 'float zenithAngle = acos(max(0.0, dot(up2, normalize(vWorldPosition - cameraPosition))));', 'float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));', 'float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));', '// combined extinction factor', 'vec3 Fex = exp(-(betaR * sR + betaM * sM));', '// in scattering', 'float cosTheta = dot(normalize(vWorldPosition - cameraPosition), sunDirection);', 'float rPhase = rayleighPhase(cosTheta*0.5+0.5);', 'vec3 betaRTheta = betaR * rPhase;', 'float mPhase = hgPhase(cosTheta, mieDirectionalG);', 'vec3 betaMTheta = betaM * mPhase;', 'vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));', 'Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up2, sunDirection),5.0),0.0,1.0));', '//nightsky', 'vec3 direction = normalize(vWorldPosition - cameraPosition);', 'float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]', 'float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]', 'vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);', '// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;', 'vec3 L0 = vec3(0.1) * Fex;', '// composition + solar disc', '//if (cosTheta > sunAngularDiameterCos)', 'float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);', '// if (normalize(vWorldPosition - cameraPosition).y>0.0)', 'L0 += (sunE * 19000.0 * Fex)*sundisk;', 'vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));', 'vec3 texColor = (Lin+L0);   ', 'texColor *= 0.04 ;', 'texColor += vec3(0.0,0.001,0.0025)*0.3;', 'float g_fMaxLuminance = 1.0;', 'float fLumScaled = 0.1 / luminance;     ', 'float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); ', 'float ExposureBias = fLumCompressed;', 'vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);', 'vec3 color = curr*whiteScale;', 'vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));', 'gl_FragColor.rgb = retColor;', 'gl_FragColor.a = 1. - ( (length(cameraPosition) - 6400000.) / 1000.);', '}'].join('\n')
	
	}; /**
	    * @author zz85 / https://github.com/zz85
	    *
	    * Based on "A Practical Analytic Model for Daylight"
	    * aka The Preetham Model, the de facto standard analytic skydome model
	    * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf
	    *
	    * First implemented by Simon Wallner
	    * http://www.simonwallner.at/projects/atmospheric-scattering
	    *
	    * Improved by Martin Upitis
	    * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR
	    *
	    * Three.js integration by zz85 http://twitter.com/blurspline
	    */
	
	function Sky() {
	    var skyUniforms = THREE.UniformsUtils.clone(skyShader.uniforms);
	
	    var skyMat = new THREE.ShaderMaterial({
	        fragmentShader: skyShader.fragmentShader,
	        vertexShader: skyShader.vertexShader,
	        uniforms: skyUniforms,
	        side: THREE.BackSide
	    });
	
	    var skyGeo = new THREE.SphereBufferGeometry(40000, 32, 15);
	    var skyMesh = new THREE.Mesh(skyGeo, skyMat);
	
	    // Expose variables
	    this.mesh = skyMesh;
	    this.uniforms = skyUniforms;
	}
	// Sky.prototype = Object.create(THREE.EventDispatcher.prototype);
	Sky.prototype.constructor = Sky;
	
	exports.default = Sky;

/***/ },
/* 357 */
/***/ function(module, exports) {

	module.exports = "uniform vec3 v3LightPos;\nuniform float g;\nuniform float g2;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n// Calculates the Mie phase function\nfloat getMiePhase(float fCos, float fCos2, float g, float g2) {\n    return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0 * g * fCos, 1.5);\n}\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(float fCos2) {\n    return 0.75 + 0.75 * fCos2;\n}\n\nvoid main (void) {\n    float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);\n    float fCos2 = fCos * fCos;\n\n    vec3 color = getRayleighPhase(fCos2) * c0 + getMiePhase(fCos, fCos2, g, g2) * c1;\n\n    gl_FragColor = vec4(color, 1.0);\n    gl_FragColor.a = gl_FragColor.b;\n}"

/***/ },
/* 358 */
/***/ function(module, exports) {

	module.exports = "uniform vec3 v3LightPosition;   // The direction vector to the light source\nuniform vec3 v3InvWavelength;   // 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;    // The camera's current height\nuniform float fCameraHeight2;   // fCameraHeight^2\nuniform float fOuterRadius;     // The outer (atmosphere) radius\nuniform float fOuterRadius2;    // fOuterRadius^2\nuniform float fInnerRadius;     // The inner (planetary) radius\nuniform float fInnerRadius2;    // fInnerRadius^2\nuniform float fKrESun;          // Kr * ESun\nuniform float fKmESun;          // Km * ESun\nuniform float fKr4PI;           // Kr * 4 * PI\nuniform float fKm4PI;           // Km * 4 * PI\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\nfloat scale(float fCos) {\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void) {\n    float lengthCamera = length(cameraPosition);\n    float cameraHeight2 = lengthCamera * lengthCamera;\n\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Ray = position - cameraPosition;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(cameraPosition, v3Ray);\n    float C = cameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\n    fFar -= fNear;\n    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n    float fStartDepth = exp(-1.0 / fScaleDepth);\n    float fStartOffset = fStartDepth * scale(fStartAngle);\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        float fLightAngle = dot(v3LightPosition, v3SamplePoint) / fHeight;\n        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n        float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));\n        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    c0 = v3FrontColor * (v3InvWavelength * fKrESun);\n    c1 = v3FrontColor * fKmESun;\n    v3Direction = cameraPosition - position;\n}"

/***/ },
/* 359 */
/***/ function(module, exports) {

	module.exports = "varying vec3 c0;\nvarying vec3 c1;\n\nvoid main (void) {\n\tgl_FragColor = vec4(c1, 1.0 - c0/4.);\n}"

/***/ },
/* 360 */
/***/ function(module, exports) {

	module.exports = "uniform vec3 v3LightPosition;   // The direction vector to the light source\nuniform vec3 v3InvWavelength;   // 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;    // The camera's current height\nuniform float fCameraHeight2;   // fCameraHeight^2\nuniform float fOuterRadius;     // The outer (atmosphere) radius\nuniform float fOuterRadius2;    // fOuterRadius^2\nuniform float fInnerRadius;     // The inner (planetary) radius\nuniform float fInnerRadius2;    // fInnerRadius^2\nuniform float fKrESun;          // Kr * ESun\nuniform float fKmESun;          // Km * ESun\nuniform float fKr4PI;           // Kr * 4 * PI\nuniform float fKm4PI;           // Km * 4 * PI\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n\nvarying vec3 c0;\nvarying vec3 c1;\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nfloat scale(float fCos)\n{\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void) {\n\n     float cameraHeight2 = length(cameraPosition) * length(cameraPosition);\n\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Ray = position - cameraPosition;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(cameraPosition, v3Ray);\n    float C = cameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\n    fFar -= fNear;\n    float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n    float fCameraAngle = dot(-v3Ray, position) / length(position);\n    float fLightAngle = dot(v3LightPosition, position) / length(position);\n    float fCameraScale = scale(fCameraAngle);\n    float fLightScale = scale(fLightAngle);\n    float fCameraOffset = fDepth*fCameraScale;\n    float fTemp = (fLightScale + fCameraScale);\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    vec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        float fScatter = fDepth*fTemp - fCameraOffset;\n        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Calculate the attenuation factor for the ground\n    c0 = v3Attenuate;\n    c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"

/***/ },
/* 361 */
/***/ function(module, exports) {

	module.exports = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\n\nuniform int atmoIN;\nvarying float intensity;\n\nvec4 glowColor = vec4(0.45, 0.74, 1. ,1.0);\n\nvoid main() \n{\n     #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    gl_FragColor = glowColor * intensity;\n\n}\n\n"

/***/ },
/* 362 */
/***/ function(module, exports) {

	module.exports = "\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n#define EPSILON 1e-6\n\n\nuniform int atmoIN;\nvarying float intensity;\nvec3 normalES;\nvec3 normalCAMES;\n\nvoid main() \n{\n    normalES    = normalize( normalMatrix * normal );\n    normalCAMES = normalize( normalMatrix * cameraPosition );\n\n    if(atmoIN == 0)\n        intensity = pow(0.666 - dot(normalES, normalCAMES), 4. ); \n      else\n        intensity = pow( 1.  - dot(normalES, normalCAMES), 0.8 );\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n    \n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n    \n}\n\n\n"

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _Coordinates = __webpack_require__(217);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var CoordStars = {
	    getSunPosition: function getSunPosition() {
	        var m = Math;
	        var PI = m.PI;
	        var sin = m.sin;
	        var cos = m.cos;
	        var tan = m.tan;
	        var asin = m.asin;
	        var atan = m.atan2;
	
	        var rad = PI / 180;
	        var dayMs = 1000 * 60 * 60 * 24;
	        var J1970 = 2440588;
	        var J2000 = 2451545;
	        var e = rad * 23.4397; // obliquity of the Earth
	
	        function toJulian(date) {
	            return date.valueOf() / dayMs - 0.5 + J1970;
	        }
	
	        function toDays(date) {
	            return toJulian(date) - J2000;
	        }
	
	        function getRightAscension(l, b) {
	            return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
	        }
	
	        function getDeclination(l, b) {
	            return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
	        }
	
	        function getAzimuth(H, phi, dec) {
	            return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
	        }
	
	        function getAltitude(H, phi, dec) {
	            return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
	        }
	
	        function getSiderealTime(d, lw) {
	            return rad * (280.16 + 360.9856235 * d) - lw;
	        }
	
	        function getSolarMeanAnomaly(d) {
	            return rad * (357.5291 + 0.98560028 * d);
	        }
	
	        function getEquationOfCenter(M) {
	            return rad * (1.9148 * sin(M) + 0.0200 * sin(2 * M) + 0.0003 * sin(3 * M));
	        }
	
	        function getEclipticLongitude(M, C) {
	            var P = rad * 102.9372; // perihelion of the Earth
	            return M + C + P + PI;
	        }
	
	        return function getSunPosition(date, lat, lon) {
	            var lw = rad * -lon;
	            var phi = rad * lat;
	            var d = toDays(date);
	            var M = getSolarMeanAnomaly(d);
	            var C = getEquationOfCenter(M);
	            var L = getEclipticLongitude(M, C);
	            var D = getDeclination(L, 0);
	            var A = getRightAscension(L, 0);
	            var t = getSiderealTime(d, lw);
	            var H = t - A;
	
	            return {
	                EclipticLongitude: L,
	                declinaison: D,
	                ascension: A,
	                H: H,
	                SiderealTime: t,
	                altitude: getAltitude(H, phi, D),
	                azimuth: getAzimuth(H, phi, D) + PI / 2 };
	        };
	    },
	
	
	    // Return scene coordinate ({x,y,z}) of sun
	    getSunPositionInScene: function getSunPositionInScene(date, lat, lon) {
	        var sun = CoordStars.getSunPosition()(date, lat, lon);
	        var dayMilliSec = 24 * 3600000;
	        var longitude = sun.ascension + date % dayMilliSec / dayMilliSec * -360 + 180; // cause midday
	        var coSunCarto = new _Coordinates2.default('EPSG:4326', longitude, lat, 50000000).as('EPSG:4978').xyz();
	
	        return coSunCarto;
	    }
	}; /**
	    * Generated On: 2016-02-25
	    * Class: CoordStars
	    * Description: get coord of stars like earth...
	    */
	exports.default = CoordStars;

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _WMS_Provider = __webpack_require__(297);
	
	var _WMS_Provider2 = _interopRequireDefault(_WMS_Provider);
	
	var _CloudsFS = __webpack_require__(365);
	
	var _CloudsFS2 = _interopRequireDefault(_CloudsFS);
	
	var _CloudsVS = __webpack_require__(366);
	
	var _CloudsVS2 = _interopRequireDefault(_CloudsVS);
	
	var _Atmosphere = __webpack_require__(355);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Clouds() /* size*/{
	    THREE.Mesh.call(this);
	
	    this.providerWMS = new _WMS_Provider2.default({});
	    this.loader = new THREE.TextureLoader();
	    this.loader.crossOrigin = '';
	    this.live = false;
	    this.satelliteAnimation = true;
	    this.texture = null;
	    this.geometry = new THREE.SphereGeometry(6400000, 96, 96);
	
	    this.uniforms = {
	        diffuse: {
	            type: 't',
	            value: new THREE.Texture() },
	        time: {
	            type: 'f',
	            value: 0.0
	        },
	        lightingEnabled: { value: false },
	        lightPosition: {
	            type: 'v3',
	            value: _Atmosphere.LIGHTING_POSITION.clone().normalize()
	        }
	    };
	
	    this.material = new THREE.ShaderMaterial({
	
	        uniforms: this.uniforms,
	        vertexShader: _CloudsVS2.default,
	        fragmentShader: _CloudsFS2.default,
	        //   blending        : THREE.AdditiveBlending,
	        transparent: true,
	        wireframe: false
	
	    });
	
	    this.rotation.y += Math.PI;
	
	    // this.generate();
	
	    this.visible = false;
	} /*
	   * To change this license header, choose License Headers in Project Properties.
	   * To change this template file, choose Tools | Templates
	   * and open the template in the editor.
	   */
	
	Clouds.prototype = (0, _create2.default)(THREE.Mesh.prototype);
	Clouds.prototype.constructor = Clouds;
	
	Clouds.prototype.generate = function generate(satelliteAnimation) {
	    var _this = this;
	
	    this.satelliteAnimation = satelliteAnimation;
	    if (!satelliteAnimation) {
	        this.live = true;
	        var coWMS = {
	            latBound: new THREE.Vector2(-85, 85),
	            longBound: new THREE.Vector2(-178, 178),
	            width: 2048,
	            height: 1024
	        };
	
	        var url = this.providerWMS.urlGlobalIR(coWMS, 0);
	        this.loader.load(url, function (texture) {
	            _this.material.blending = THREE.NormalBlending;
	            _this.material.uniforms.diffuse.value = texture;
	            _this.material.uniforms.diffuse.needsUpdate = true;
	            _this.animate();
	        });
	    } else {
	        this.live = true;
	        var video = document.getElementById('video');
	
	        this.texture = new THREE.VideoTexture(video);
	        this.texture.minFilter = THREE.LinearFilter;
	        this.texture.magFilter = THREE.LinearFilter;
	        this.texture.format = THREE.RGBFormat;
	
	        // this.material = new THREE.MeshBasicMaterial( { color: 0xffffff, map: this.texture});//, transparent : true, opacity:0.8});
	        this.material.blending = THREE.AdditiveBlending;
	        this.material.uniforms.diffuse.value = this.texture;
	        this.material.uniforms.diffuse.needsUpdate = true;
	        this.animate();
	    }
	};
	
	Clouds.prototype.animate = function animate() {
	    if (!this.satelliteAnimation) this.material.uniforms.time.value += 0.01;
	    requestAnimationFrame(this.animate.bind(this));
	};
	
	Clouds.prototype.setLightingOn = function setLightingOn(enable) {
	    this.material.uniforms.lightingEnabled.value = enable;
	};
	
	Clouds.prototype.updateLightingPos = function updateLightingPos(pos) {
	    this.material.uniforms.lightPosition.value = pos.clone().normalize();
	};
	
	exports.default = Clouds;

/***/ },
/* 365 */
/***/ function(module, exports) {

	module.exports = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\nuniform vec3 lightPosition;\nuniform sampler2D diffuse;\nuniform float time;\nuniform bool lightingEnabled;\nvarying vec2  vUv;\nvarying vec3 pos;\nvarying vec3 vNormal;\n\nfloat speed = 0.01;\nfloat noiseScale = 0.005;\n\nvoid main()\n{\n     #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    // Correct Y knowing image is -85 85\n    vec2 vUv2 = vec2(vUv.x, clamp(vUv.y + (vUv.y - 0.5) * - 0.45, 0., 1.));\n    float coefDistCam = (length(cameraPosition.xyz) - 6400000.) / 500000.;\n\n    vec2 uvTime =  vUv2 + vec2( -0.1, .1 ) * mod(time * speed, 1.);\n    vec4 noiseColor = texture2D( diffuse, uvTime );\n    vec2 uvNoise = vUv2 + noiseScale * vUv2 * vec2(noiseColor.r, noiseColor.b );\n\n    vec4 color = texture2D( diffuse, uvNoise); //texture2D( diffuse, vUv2 );\n    float l = (max(color.r,max(color.g,color.b)) + min(color.r,min(color.g,color.b))) / 2.;\n    l *= l*1.5;\n    gl_FragColor =  0.25 +  (texture2D( diffuse, vUv2 ) * 0.95);\n    gl_FragColor.b += 0.1;\n\n    gl_FragColor.a = min(time * min( coefDistCam, 1.2) , 1.) * (vUv.y <= 0.75 ? l : (1. - ((vUv.y - 0.75) / 0.25)) * l  );\n\n    if(lightingEnabled){   // Add lighting\n        float light = min(2. * dot(vNormal, lightPosition),1.); //normalize(pos.xyz)\n        gl_FragColor.a *= -light;\n    }\n}"

/***/ },
/* 366 */
/***/ function(module, exports) {

	module.exports = "\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n#define EPSILON 1e-6\n\nuniform vec3  lightPosition;\nvarying vec2  vUv;\nvarying vec3 vNormal;\nvarying vec3 pos;\nvec3 normalES;\nvec3 normalCAMES;\n\n\nvoid main()\n{\n\n    vUv = uv;\n    vNormal = normal;\n    pos = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n\n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n\n}\n\n\n"

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Coordinates = __webpack_require__(217);
	
	var _Projection = __webpack_require__(291);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _OBB = __webpack_require__(368);
	
	var _OBB2 = _interopRequireDefault(_OBB);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function BuilderEllipsoidTile() {
	    this.projector = new _Projection2.default();
	}
	
	BuilderEllipsoidTile.prototype.constructor = BuilderEllipsoidTile;
	
	// prepare params
	// init projected object -> params.projected
	BuilderEllipsoidTile.prototype.Prepare = function Prepare(params) {
	    params.nbRow = Math.pow(2.0, params.level + 1.0);
	
	    var st1 = this.projector.WGS84ToOneSubY(params.extent.south());
	
	    if (!isFinite(st1)) {
	        st1 = 0;
	    }
	
	    var sizeTexture = 1.0 / params.nbRow;
	
	    var start = st1 % sizeTexture;
	
	    params.deltaUV1 = (st1 - start) * params.nbRow;
	
	    // let's avoid building too much temp objects
	    params.projected = { longitudeRad: 0, latitudeRad: 0 };
	};
	
	// get center tile in cartesian 3D
	BuilderEllipsoidTile.prototype.Center = function Center(params) {
	    params.center = params.extent.center().as('EPSG:4978').xyz();
	    return params.center;
	};
	
	// get position 3D cartesian
	BuilderEllipsoidTile.prototype.VertexPosition = function VertexPosition(params) {
	    params.cartesianPosition = new _Coordinates.C.EPSG_4326_Radians(params.projected.longitudeRad, params.projected.latitudeRad).as('EPSG:4978');
	    return params.cartesianPosition;
	};
	
	// get normal for last vertex
	BuilderEllipsoidTile.prototype.VertexNormal = function VertexNormal(params) {
	    return params.cartesianPosition.xyz().normalize();
	};
	
	// coord u tile to projected
	BuilderEllipsoidTile.prototype.uProjecte = function uProjecte(u, params) {
	    params.projected.longitudeRad = this.projector.UnitaryToLongitudeWGS84(u, params.extent);
	};
	
	// coord v tile to projected
	BuilderEllipsoidTile.prototype.vProjecte = function vProjecte(v, params) {
	    params.projected.latitudeRad = this.projector.UnitaryToLatitudeWGS84(v, params.extent);
	};
	
	// Compute uv 1, if isn't defined the uv1 isn't computed
	BuilderEllipsoidTile.prototype.getUV_PM = function getUV_PM(params) {
	    var t = this.projector.WGS84ToOneSubY(params.projected.latitudeRad) * params.nbRow;
	
	    if (!isFinite(t)) {
	        t = 0;
	    }
	
	    return t - params.deltaUV1;
	};
	
	// get oriented bounding box of tile
	BuilderEllipsoidTile.prototype.OBB = function OBBFn(params) {
	    var cardinals = [];
	
	    var normal = params.center.clone().normalize();
	
	    var bboxDimension = params.extent.dimensions(_Coordinates.UNIT.RADIAN);
	    var phiStart = params.extent.west();
	    var phiLength = bboxDimension.x;
	
	    var thetaStart = params.extent.south();
	    var thetaLength = bboxDimension.y;
	
	    //      0---1---2
	    //      |       |
	    //      7       3
	    //      |       |
	    //      6---5---4
	
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart, thetaStart));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + bboxDimension.x * 0.5, thetaStart));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + phiLength, thetaStart));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + phiLength, thetaStart + bboxDimension.y * 0.5));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + phiLength, thetaStart + thetaLength));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + bboxDimension.x * 0.5, thetaStart + thetaLength));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart, thetaStart + thetaLength));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart, thetaStart + bboxDimension.y * 0.5));
	    cardinals.push(params.extent.center());
	
	    var cardin3DPlane = [];
	
	    var maxV = new THREE.Vector3(-1000, -1000, -1000);
	    var minV = new THREE.Vector3(1000, 1000, 1000);
	    var halfMaxHeight = 0;
	    var planeZ = new THREE.Quaternion();
	    var qRotY = new THREE.Quaternion();
	    var vec = new THREE.Vector3();
	    var tangentPlaneAtOrigin = new THREE.Plane(normal);
	
	    planeZ.setFromUnitVectors(normal, new THREE.Vector3(0, 0, 1));
	    qRotY.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -params.extent.center().longitude(_Coordinates.UNIT.RADIAN));
	    qRotY.multiply(planeZ);
	
	    for (var i = 0; i < cardinals.length; i++) {
	        var cardinal3D = cardinals[i].as('EPSG:4978').xyz().sub(params.center);
	        cardin3DPlane.push(tangentPlaneAtOrigin.projectPoint(cardinal3D));
	        // compute height max
	        var d = cardin3DPlane[i].distanceTo(vec);
	        halfMaxHeight = Math.max(halfMaxHeight, d * 0.5);
	        // compute tile's min/max
	        cardin3DPlane[i].applyQuaternion(qRotY);
	        maxV.max(cardin3DPlane[i]);
	        minV.min(cardin3DPlane[i]);
	    }
	
	    var halfLength = Math.abs(maxV.y - minV.y) * 0.5;
	    var halfWidth = Math.abs(maxV.x - minV.x) * 0.5;
	    var max = new THREE.Vector3(halfLength, halfWidth, halfMaxHeight);
	    var min = new THREE.Vector3(-halfLength, -halfWidth, -halfMaxHeight);
	
	    // delta is the distance between line `([6],[4])` and the point `[5]`
	    // These points [6],[5],[4] aren't aligned because of the ellipsoid shape
	    var delta = halfWidth - Math.abs(cardin3DPlane[5].x);
	    var translate = new THREE.Vector3(0, delta, -halfMaxHeight);
	    var obb = new _OBB2.default(min, max, normal, translate);
	
	    return obb;
	};
	
	exports.default = BuilderEllipsoidTile;

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function OBB(min, max, lookAt, translate) {
	    THREE.Object3D.call(this);
	    this.box3D = new THREE.Box3(min, max);
	
	    this.natBox = this.box3D.clone();
	
	    if (lookAt) {
	        this.lookAt(lookAt);
	    }
	
	    if (translate) {
	        this.translateX(translate.x);
	        this.translateY(translate.y);
	        this.translateZ(translate.z);
	    }
	
	    this.oPosition = new THREE.Vector3();
	
	    this.update();
	
	    this.oPosition = this.position.clone();
	    this.z = { min: 0, max: 0 };
	}
	
	OBB.prototype = (0, _create2.default)(THREE.Object3D.prototype);
	OBB.prototype.constructor = OBB;
	
	OBB.prototype.update = function update() {
	    this.updateMatrixWorld(true);
	
	    this.pointsWorld = this._cPointsWorld(this._points());
	};
	
	OBB.prototype.updateZ = function updateZ(min, max) {
	    this.z = { min: min, max: max };
	    return this.addHeight(min, max);
	};
	
	OBB.prototype.addHeight = function addHeight(minz, maxz) {
	    var depth = Math.abs(this.natBox.min.z - this.natBox.max.z);
	    //
	    this.box3D.min.z = this.natBox.min.z + minz;
	    this.box3D.max.z = this.natBox.max.z + maxz;
	
	    // TODO  vrifier --->
	
	    var nHalfSize = Math.abs(this.box3D.min.z - this.box3D.max.z) * 0.5;
	    var translaZ = this.box3D.min.z + nHalfSize;
	    this.box3D.min.z = -nHalfSize;
	    this.box3D.max.z = nHalfSize;
	
	    this.position.copy(this.oPosition);
	
	    this.translateZ(translaZ);
	
	    this.update();
	
	    return new THREE.Vector2(nHalfSize - depth * 0.5, translaZ);
	
	    // TODO <----  vrifier
	};
	
	OBB.prototype._points = function _points() {
	    var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
	
	    points[0].set(this.box3D.max.x, this.box3D.max.y, this.box3D.max.z);
	    points[1].set(this.box3D.min.x, this.box3D.max.y, this.box3D.max.z);
	    points[2].set(this.box3D.min.x, this.box3D.min.y, this.box3D.max.z);
	    points[3].set(this.box3D.max.x, this.box3D.min.y, this.box3D.max.z);
	    points[4].set(this.box3D.max.x, this.box3D.max.y, this.box3D.min.z);
	    points[5].set(this.box3D.min.x, this.box3D.max.y, this.box3D.min.z);
	    points[6].set(this.box3D.min.x, this.box3D.min.y, this.box3D.min.z);
	    points[7].set(this.box3D.max.x, this.box3D.min.y, this.box3D.min.z);
	
	    return points;
	};
	
	OBB.prototype._cPointsWorld = function _cPointsWorld(points) {
	    var m = this.matrixWorld;
	
	    for (var i = 0, max = points.length; i < max; i++) {
	        points[i].applyMatrix4(m);
	    }
	
	    return points;
	};
	
	exports.default = OBB;

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(231);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _View = __webpack_require__(235);
	
	var _View2 = _interopRequireDefault(_View);
	
	var _RendererConstant = __webpack_require__(315);
	
	var _RendererConstant2 = _interopRequireDefault(_RendererConstant);
	
	var _MatteIdsMaterial = __webpack_require__(313);
	
	var _Layer = __webpack_require__(265);
	
	var _TiledNodeProcessing = __webpack_require__(323);
	
	var _LayeredMaterialNodeProcessing = __webpack_require__(324);
	
	var _PlanarTileProcessing = __webpack_require__(370);
	
	var _PlanarTileBuilder = __webpack_require__(371);
	
	var _PlanarTileBuilder2 = _interopRequireDefault(_PlanarTileBuilder);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function PlanarView(viewerDiv, boundingbox, options) {
	    var _this = this;
	
	    THREE.Object3D.DefaultUp.set(0, 0, 1);
	
	    // Setup View
	    _View2.default.call(this, boundingbox.crs(), viewerDiv, options);
	
	    // Configure camera
	    var dim = boundingbox.dimensions();
	    var positionCamera = boundingbox.center().clone();
	    positionCamera._values[2] = Math.max(dim.x, dim.y);
	    var lookat = positionCamera.xyz();
	    lookat.z = 0;
	
	    this.camera.setPosition(positionCamera.xyz());
	    this.camera.camera3D.lookAt(lookat);
	    this.camera.camera3D.near = 0.1;
	    this.camera.camera3D.far = 2 * Math.max(dim.x, dim.y);
	    this.camera.camera3D.updateProjectionMatrix();
	    this.camera.camera3D.updateMatrixWorld(true);
	
	    // Configure tiles
	    var nodeInitFn = function nodeInitFn(context, layer, parent, node) {
	        node.materials[0].setLightingOn(layer.lighting.enable);
	        node.materials[0].uniforms.lightPosition.value = layer.lighting.position;
	
	        if (false) {
	            node.material.uniforms.showOutline = { value: layer.showOutline || false };
	            node.material.wireframe = layer.wireframe || false;
	        }
	    };
	    var SSE_SUBDIVISION_THRESHOLD = 6.0;
	
	    var tileLayer = new _Layer.GeometryLayer('planar');
	    var initLayer = (0, _TiledNodeProcessing.initTiledGeometryLayer)((0, _PlanarTileProcessing.planarSchemeTile)(boundingbox));
	
	    function _commonAncestorLookup(a, b) {
	        if (!a || !b) {
	            return undefined;
	        }
	        if (a.level == b.level) {
	            if (a.id == b.id) {
	                return a;
	            } else if (a.level != 0) {
	                return _commonAncestorLookup(a.parent, b.parent);
	            } else {
	                return undefined;
	            }
	        } else if (a.level < b.level) {
	            return _commonAncestorLookup(a, b.parent);
	        } else {
	            return _commonAncestorLookup(a.parent, b);
	        }
	    }
	
	    tileLayer.preUpdate = function (context, layer, changeSources) {
	        _this._latestUpdateStartingLevel = 0;
	        if (layer.level0Nodes === undefined) {
	            initLayer(context, layer);
	        }
	
	        if (changeSources.has(undefined) || changeSources.size == 0) {
	            return layer.level0Nodes;
	        }
	        var commonAncestor = void 0;
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	            for (var _iterator = (0, _getIterator3.default)(changeSources.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var source = _step.value;
	
	                if (!commonAncestor) {
	                    commonAncestor = source;
	                } else {
	                    commonAncestor = _commonAncestorLookup(commonAncestor, source);
	                    if (!commonAncestor) {
	                        return layer.level0Nodes;
	                    }
	                }
	                if (commonAncestor.material == null) {
	                    commonAncestor = undefined;
	                }
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }
	
	        if (commonAncestor) {
	            _this._latestUpdateStartingLevel = commonAncestor.level;
	            return [commonAncestor];
	        } else {
	            return [];
	        }
	    };
	
	    tileLayer.update = (0, _TiledNodeProcessing.processTiledGeometryNode)(_PlanarTileProcessing.planarCulling, (0, _PlanarTileProcessing.planarSubdivisionControl)(4, SSE_SUBDIVISION_THRESHOLD), nodeInitFn);
	    tileLayer.builder = new _PlanarTileBuilder2.default();
	
	    tileLayer.type = 'geometry';
	    tileLayer.protocol = 'tile';
	    tileLayer.visible = true;
	    tileLayer.lighting = {
	        enable: false,
	        position: { x: -0.5, y: 0.0, z: 1.0 }
	    };
	
	    this.addLayer(tileLayer);
	
	    this._renderState = _RendererConstant2.default.FINAL;
	
	    this.tileLayer = tileLayer;
	}
	
	PlanarView.prototype = (0, _create2.default)(_View2.default.prototype);
	PlanarView.prototype.constructor = PlanarView;
	
	PlanarView.prototype.addLayer = function addLayer(layer) {
	    if (layer.type == 'color') {
	        layer.update = _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeImagery;
	    } else if (layer.type == 'elevation') {
	        layer.update = _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeElevation;
	    }
	    _View2.default.prototype.addLayer.call(this, layer, this.tileLayer);
	    // we probably want to move some code from ApiGlobe.prototype.addImageryLayer|ApiPlanarView.prototype.addElevationLayer here
	};
	
	PlanarView.prototype.selectNodeAt = function selectNodeAt(mouse) {
	    var selectedId = this.screenCoordsToNodeId(mouse);
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = (0, _getIterator3.default)(this.tileLayer.level0Nodes), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var n = _step2.value;
	
	            n.traverse(function (node) {
	                // only take of selectable nodes
	                if (node.setSelected) {
	                    node.setSelected(node.id === selectedId);
	
	                    if (node.id === selectedId) {
	                        // eslint-disable-next-line no-console
	                        console.info(node);
	                    }
	                }
	            });
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    this.notifyChange();
	};
	
	PlanarView.prototype.screenCoordsToNodeId = function screenCoordsToNodeId(mouse) {
	    var dim = this.mainLoop.gfxEngine.getWindowSize();
	
	    this.camera.update();
	
	    var previousRenderState = this._renderState;
	    this.changeRenderState(_RendererConstant2.default.ID);
	
	    var buffer = this.mainLoop.gfxEngine.renderViewTobuffer(this, this.mainLoop.gfxEngine.fullSizeRenderTarget, mouse.x, dim.y - mouse.y, 1, 1);
	
	    this.changeRenderState(previousRenderState);
	
	    var depthRGBA = new THREE.Vector4().fromArray(buffer).divideScalar(255.0);
	
	    // unpack RGBA to float
	    var unpack = (0, _MatteIdsMaterial.unpack1K)(depthRGBA, 10000);
	
	    return Math.round(unpack);
	};
	
	var matrix = new THREE.Matrix4();
	matrix.elements = new Float64Array(16); // /!\ WARNING Matrix JS are in Float32Array
	var screen = new THREE.Vector2();
	var pickWorldPosition = new THREE.Vector3();
	var ray = new THREE.Ray();
	var direction = new THREE.Vector3();
	var depthRGBA = new THREE.Vector4();
	PlanarView.prototype.getPickingPositionFromDepth = function getPickingPositionFromDepth(mouse) {
	    var dim = this.mainLoop.gfxEngine.getWindowSize();
	    mouse = mouse || dim.clone().multiplyScalar(0.5);
	
	    var camera = this.camera.camera3D;
	    this.camera.update();
	    // camera.updateMatrixWorld();
	
	    // Prepare state
	    var prev = this.camera.camera3D.layers.mask;
	    this.camera.camera3D.layers.mask = 1 << this.tileLayer.threejsLayer;
	
	    var previousRenderState = this._renderState;
	    this.changeRenderState(_RendererConstant2.default.DEPTH);
	
	    // Render to buffer
	    var buffer = this.mainLoop.gfxEngine.renderViewTobuffer(this, this.mainLoop.gfxEngine.fullSizeRenderTarget, mouse.x, dim.y - mouse.y, 1, 1);
	
	    screen.x = mouse.x / dim.x * 2 - 1;
	    screen.y = -(mouse.y / dim.y) * 2 + 1;
	
	    camera.matrixWorld.setPosition(camera.position);
	
	    // Origin
	    ray.origin.copy(camera.position);
	
	    // Direction
	    ray.direction.set(screen.x, screen.y, 0.5);
	    // Unproject
	    matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
	    ray.direction.applyMatrix4(matrix);
	    ray.direction.sub(ray.origin);
	
	    direction.set(0, 0, 1.0);
	    direction.applyMatrix4(matrix);
	    direction.sub(ray.origin);
	
	    var angle = direction.angleTo(ray.direction);
	
	    depthRGBA.fromArray(buffer).divideScalar(255.0);
	
	    var depth = (0, _MatteIdsMaterial.unpack1K)(depthRGBA, 100000000.0) / Math.cos(angle);
	
	    pickWorldPosition.addVectors(camera.position, ray.direction.setLength(depth));
	
	    // Restore initial state
	    this.changeRenderState(previousRenderState);
	    camera.layers.mask = prev;
	    camera.updateMatrixWorld(true);
	
	    if (pickWorldPosition.length() > 10000000) {
	        return undefined;
	    }
	
	    return pickWorldPosition;
	};
	
	PlanarView.prototype.changeRenderState = function changeRenderState(newRenderState) {
	    if (this._renderState == newRenderState || !this.tileLayer.level0Nodes) {
	        return;
	    }
	
	    // build traverse function
	    var changeStateFunction = function getChangeStateFunctionFn() {
	        return function changeStateFunction(object3D) {
	            if (object3D.changeState) {
	                object3D.changeState(newRenderState);
	            }
	        };
	    }();
	
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	        for (var _iterator3 = (0, _getIterator3.default)(this.tileLayer.level0Nodes), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var n = _step3.value;
	
	            n.traverseVisible(changeStateFunction);
	        }
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	
	    this._renderState = newRenderState;
	};
	
	exports.default = PlanarView;

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.planarCulling = planarCulling;
	exports.planarSubdivisionControl = planarSubdivisionControl;
	exports.planarSchemeTile = planarSchemeTile;
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _SchemeTile = __webpack_require__(353);
	
	var _SchemeTile2 = _interopRequireDefault(_SchemeTile);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function frustumCullingOBB(node, camera) {
	    return camera.isBox3DVisible(node.OBB().box3D, node.OBB().matrixWorld);
	}
	
	function planarCulling(node, camera) {
	    return !frustumCullingOBB(node, camera);
	}
	
	function computeNodeSSE(camera, node) {
	    var vFOV = camera.FOV * Math.PI / 180;
	
	    var tmp1 = new THREE.Vector3();
	    tmp1.setFromMatrixPosition(node.matrixWorld);
	    var tmp2 = new THREE.Vector3();
	    tmp2.setFromMatrixPosition(camera.camera3D.matrixWorld);
	    var diff = tmp2.sub(tmp1);
	    var dim = node.extent.dimensions();
	
	    var d = Math.max(0.1, diff.length() - new THREE.Vector3(dim.x, dim.y, dim.z).length() * 0.5);
	    var height = 2 * Math.tan(vFOV / 2) * d;
	
	    var dot = diff.normalize().z;
	
	    var ratio = dim.x * dot / height;
	
	    if (ratio >= 0.25) {
	        return 7;
	    }
	    return 1;
	}
	
	function planarSubdivisionControl(maxLevel, threshold) {
	    return function _planarSubdivisionControl(context, layer, node) {
	        if (maxLevel <= node.level) {
	            return false;
	        }
	        // don't allow subdivision if tile does'nt have at least:
	        //  - 1 elevation texture
	        if (!node.isElevationLayerLoaded()) {
	            return false;
	        }
	        //  - 1 color texture
	        if (node.materials[0].loadedTexturesCount[1] == 0) {
	            return false;
	        }
	
	        var sse = computeNodeSSE(context.camera, node);
	
	        return threshold < sse;
	    };
	}
	
	function planarSchemeTile(bbox) {
	    var planeSchemeTile = new _SchemeTile2.default();
	    planeSchemeTile.add(bbox);
	    return planeSchemeTile;
	}

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(226);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _OBB2 = __webpack_require__(368);
	
	var _OBB3 = _interopRequireDefault(_OBB2);
	
	var _Coordinates = __webpack_require__(217);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function PlanarTileBuilder() {}
	
	PlanarTileBuilder.prototype.constructor = PlanarTileBuilder;
	
	// prepare params
	// init projected object -> params.projected
	PlanarTileBuilder.prototype.Prepare = function Prepare(params) {
	    params.nbRow = Math.pow(2.0, params.zoom + 1.0);
	    params.projected = new THREE.Vector3();
	};
	
	// get center tile in cartesian 3D
	PlanarTileBuilder.prototype.Center = function Center(params) {
	    params.center = new THREE.Vector3(params.extent.center().x(), params.extent.center().y(), 0);
	    return params.center;
	};
	
	// get position 3D cartesian
	PlanarTileBuilder.prototype.VertexPosition = function VertexPosition(params) {
	    return new _Coordinates2.default(params.extent.crs(), params.projected.x, params.projected.y);
	};
	
	// get normal for last vertex
	PlanarTileBuilder.prototype.VertexNormal = function VertexNormal() /* params */{
	    return new THREE.Vector3(0.0, 0.0, 1.0);
	};
	
	// coord u tile to projected
	PlanarTileBuilder.prototype.uProjecte = function uProjecte(u, params) {
	    params.projected.x = params.extent.west() + u * (params.extent.east() - params.extent.west());
	};
	
	// coord v tile to projected
	PlanarTileBuilder.prototype.vProjecte = function vProjecte(v, params) {
	    params.projected.y = params.extent.south() + v * (params.extent.north() - params.extent.south());
	};
	
	// get oriented bounding box of tile
	PlanarTileBuilder.prototype.OBB = function _OBB(params) {
	    var center = params.extent.center().xyz();
	    var max = new THREE.Vector3(params.extent.east(), params.extent.north(), 0).sub(center);
	    var min = new THREE.Vector3(params.extent.west(), params.extent.south(), 0).sub(center);
	    var translate = new THREE.Vector3(0, 0, 0);
	    // normal is up vector
	    return new _OBB3.default(min, max, undefined, translate);
	};
	
	exports.default = PlanarTileBuilder;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=itowns.js.map