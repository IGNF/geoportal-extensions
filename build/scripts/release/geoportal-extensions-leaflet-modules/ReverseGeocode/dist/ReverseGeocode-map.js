/*!
 * @brief French Geoportal Extension for Leaflet
 *
 * This software is released under the licence CeCILL-B (Free BSD compatible)
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt
 * @see http://www.cecill.info/
 *
 * @copyright copyright (c) IGN 
 * @license CeCILL-B
 * @author IGN
 * @version 2.2.7
 * @date 18/11/2022
 *
 */

ReverseGeocode =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Leaflet/Controls/ReverseGeocoding.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcz8xMzY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLFNBQytCO0FBQ2hDLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMseUNBQXlDLFVBQWM7QUFDeEQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgdjQuMi44KzFlNjhkY2U2XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB4O1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cblxuXG52YXIgX2lzQXJyYXkgPSB2b2lkIDA7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdm9pZCAwO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdm9pZCAwO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZlcnR4ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKS5yZXF1aXJlKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB2b2lkIDA7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cblxuICBpZiAoX3N0YXRlKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciB0aGVuJCQxID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICB0aGVuJCQxID0gdmFsdWUudGhlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgdGhlbiQkMSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdm9pZCAwLFxuICAgICAgZXJyb3IgPSB2b2lkIDAsXG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzdWNjZWVkZWQgPT09IGZhbHNlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG52YXIgRW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gICAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgIH1cbiAgfVxuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiBfZW51bWVyYXRlKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIF9lYWNoRW50cnkoZW50cnksIGkpIHtcbiAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cblxuICAgIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICAgIHZhciBfdGhlbiA9IHZvaWQgMDtcbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoZW4gPSBlbnRyeS50aGVuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0oKTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZS50aGVuID0gdGhlbjtcblByb21pc2UkMS5hbGwgPSBhbGw7XG5Qcm9taXNlJDEucmFjZSA9IHJhY2U7XG5Qcm9taXNlJDEucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMS5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQxLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMS5fYXNhcCA9IGFzYXA7XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICBpZiAoUCkge1xuICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cbnJldHVybiBQcm9taXNlJDE7XG5cbn0pKSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es6-promise/dist/es6-promise.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/package.json":
/*!********************************************************!*\
  !*** ./node_modules/geoportal-access-lib/package.json ***!
  \********************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, date, dependencies, deprecated, description, devDependencies, homepage, keywords, license, main, module, name, nyc, optionalDependencies, peerDependencies, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"_id\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-914Yk0C3mnYI+X56Y40t4OJwBiZ1nEbW8D9Dse4WcS54Au8ZpkZ9Ep1efNYMxC5618zqn7r4VvzF58Xa+BqzEQ==\\\",\\\"_location\\\":\\\"/geoportal-access-lib\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"name\\\":\\\"geoportal-access-lib\\\",\\\"escapedName\\\":\\\"geoportal-access-lib\\\",\\\"rawSpec\\\":\\\"3.2.0\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"3.2.0\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/geoportal-access-lib/-/geoportal-access-lib-3.2.0.tgz\\\",\\\"_shasum\\\":\\\"7a707b75743f01b5465cc72d1316f13f8b87df7a\\\",\\\"_spec\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"_where\\\":\\\"/home/JPBazonnais/Projets/API/geoportal-extensions\\\",\\\"author\\\":{\\\"name\\\":\\\"IGNF\\\"},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/IGNF/geoportal-access-lib/issues\\\"},\\\"bundleDependencies\\\":false,\\\"date\\\":\\\"04/10/2022\\\",\\\"dependencies\\\":{\\\"es6-promise\\\":\\\"^4.2.4\\\",\\\"node-fetch\\\":\\\"^2.6.1\\\",\\\"xmldom\\\":\\\"^0.1.27\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"French Geoportal resources access library\\\",\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.12.10\\\",\\\"@babel/plugin-transform-template-literals\\\":\\\"^7.12.1\\\",\\\"@babel/preset-env\\\":\\\"^7.12.11\\\",\\\"babel-loader\\\":\\\"^8.2.2\\\",\\\"chai\\\":\\\"^4.1.2\\\",\\\"clean-webpack-plugin\\\":\\\"^3.0.0\\\",\\\"copy-webpack-plugin\\\":\\\"^5.1.2\\\",\\\"eslint\\\":\\\"^7.18.0\\\",\\\"eslint-config-standard\\\":\\\"^16.0.2\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"eslint-plugin-import\\\":\\\"^2.22.1\\\",\\\"eslint-plugin-node\\\":\\\"^11.1.0\\\",\\\"eslint-plugin-promise\\\":\\\"^4.2.1\\\",\\\"eslint-plugin-standard\\\":\\\"^5.0.0\\\",\\\"glob\\\":\\\"^7.1.2\\\",\\\"handlebars-layouts\\\":\\\"^3.1.4\\\",\\\"handlebars-webpack-plugin\\\":\\\"^1.4.1\\\",\\\"html-webpack-plugin\\\":\\\"^4.5.1\\\",\\\"istanbul-instrumenter-loader\\\":\\\"^3.0.1\\\",\\\"jsdoc-webpack-plugin\\\":\\\"^0.3.0\\\",\\\"loglevel\\\":\\\"^1.6.1\\\",\\\"mocha\\\":\\\"^7.2.0\\\",\\\"mocha-loader\\\":\\\"^5.1.5\\\",\\\"mocha-webpack\\\":\\\"^2.0.0-beta.0\\\",\\\"mochawesome\\\":\\\"^6.2.1\\\",\\\"nyc\\\":\\\"^15.1.0\\\",\\\"path\\\":\\\"^0.12.7\\\",\\\"replace-bundle-webpack-plugin\\\":\\\"^1.0.0\\\",\\\"sinon\\\":\\\"^9.2.4\\\",\\\"sinon-es6\\\":\\\"0.0.3\\\",\\\"speed-measure-webpack-plugin\\\":\\\"^1.4.2\\\",\\\"string-template\\\":\\\"^1.0.0\\\",\\\"terser-webpack-plugin\\\":\\\"^2.3.8\\\",\\\"webpack\\\":\\\"^4.46.0\\\",\\\"webpack-cli\\\":\\\"^3.3.12\\\",\\\"webpack-dev-server\\\":\\\"^3.11.2\\\",\\\"webpack-node-externals\\\":\\\"^2.5.2\\\",\\\"webpack-shell-plugin\\\":\\\"^0.5.0\\\"},\\\"homepage\\\":\\\"https://github.com/IGNF/geoportal-access-lib#readme\\\",\\\"keywords\\\":[\\\"geoportail\\\",\\\"webservice\\\",\\\"javascript\\\",\\\"es6\\\"],\\\"license\\\":\\\"CECILL-B\\\",\\\"main\\\":\\\"dist/GpServices-src.js\\\",\\\"module\\\":\\\"src/Gp.js\\\",\\\"name\\\":\\\"geoportal-access-lib\\\",\\\"nyc\\\":{\\\"include\\\":[\\\"src/**/*.js\\\"],\\\"instrument\\\":false,\\\"sourceMap\\\":false},\\\"optionalDependencies\\\":{},\\\"peerDependencies\\\":{},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/IGNF/geoportal-access-lib.git\\\"},\\\"scripts\\\":{\\\"build\\\":\\\"webpack --mode=none\\\",\\\"build:dev\\\":\\\"webpack --mode=development\\\",\\\"build:prod\\\":\\\"webpack --mode=production\\\",\\\"clean\\\":\\\"echo \\\\\\\"Warning: no yet implemented!\\\\\\\" && exit 0\\\",\\\"cover\\\":\\\"nyc --reporter=lcov --reporter=text npm run test\\\",\\\"doc\\\":\\\"npm run doc:serve\\\",\\\"doc:serve\\\":\\\"webpack-dev-server --content-base jsdoc --port 9001 --open\\\",\\\"eslint\\\":\\\"eslint src/\\\",\\\"sample\\\":\\\"npm run sample:serve\\\",\\\"sample:serve\\\":\\\"webpack-dev-server --mode=none --open-page samples/index-src.html --https --content-base . --output-public-path '/dist/' --port 9001 --open\\\",\\\"sample:serve:dev\\\":\\\"webpack-dev-server --mode=development --open-page samples/index-map.html --content-base . --output-public-path '/dist/' --port 9001 --open\\\",\\\"sample:serve:prod\\\":\\\"webpack-dev-server --mode=production --open-page samples/index-prod.html --content-base . --output-public-path '/dist/' --port 9001 --open\\\",\\\"setup\\\":\\\"npm install\\\",\\\"test\\\":\\\"mocha-webpack --reporter mochawesome --reporter-options reportDir=test-report,reportFilename=index --webpack-config ./test/webpack/webpack.test.js --glob \\\\\\\"test_*.js\\\\\\\" test/spec/\\\",\\\"test:end-to-end:serve\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.js\\\",\\\"test:end-to-end:serve:docker\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.docker.js\\\",\\\"test:serve\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.js\\\",\\\"test:serve:docker\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.docker.js\\\"},\\\"version\\\":\\\"3.2.0\\\"}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9wYWNrYWdlLmpzb24uanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/package.json\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js":
/*!**************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Errors raised by API for one among three reasons : wrong API usage, underlying service error or unknown reason.\n *\n * @property {String} message - Error message\n * @property {Number} status - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} ; -1 otherwise.\n * @property {String} type - Error type ({@link Gp.Error.TYPE_SRVERR}, {@link Gp.Error.TYPE_USEERR} or {@link Gp.Error.TYPE_UNKERR}).\n *\n * @namespace\n * @alias Gp.Error\n * @param {Object|String} error - Options for creating error object. Can be a String (message) or an Object.\n * @param {String} error.message - Error message to return to user.\n * @param {enum} [error.type=TYPE_UNKERR] - Error type\n * @param {status} [error.status=-1] - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}.\n *\n */\nfunction ErrorService (error) {\n    if (!(this instanceof ErrorService)) {\n        throw new TypeError(\"ErrorService constructor cannot be called as a function.\");\n    }\n\n    var e = error;\n    if (typeof error === \"string\" || error instanceof String) {\n        this.message = error;\n        this.status = -1;\n        this.type = ErrorService.TYPE_UNKERR;\n    } else {\n        this.message = e.message || \"undefined!?\";\n        this.type = e.type;\n        this.status = e.status || -1;\n    }\n\n    this.name = \"ErrorService\";\n    this.stack = (new Error()).stack;\n}\n\n/**\n * Error raised when underlying geoportal service answers on error.\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_SRVERR = \"SERVICE_ERROR\";\n/**\n * Error raised when funcion use is inappropriate\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_USEERR = \"USAGE_ERROR\";\n/**\n * Error raised when API can't perform the job for a reason other than the two other ones.\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_UNKERR = \"UNKNOWN_ERROR\";\n\n/**\n * @lends module:ErrorService\n */\nErrorService.prototype = Object.create(Error.prototype, {\n    constructor : {\n        value : ErrorService,\n        writable : true,\n        configurable : true\n    }\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ErrorService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL0V4Y2VwdGlvbnMvRXJyb3JTZXJ2aWNlLmpzPzg0YmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPLCtCQUErQiwyQkFBMkIsaUVBQWlFLDhEQUE4RCxFQUFFO0FBQ2hOLGNBQWMsT0FBTyxxQkFBcUIsMkJBQTJCLEdBQUcsMkJBQTJCLEtBQUssMkJBQTJCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTywwQ0FBMEMsMkJBQTJCLGlFQUFpRSw4REFBOEQ7QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVjLDJFQUFZLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL0V4Y2VwdGlvbnMvRXJyb3JTZXJ2aWNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFcnJvcnMgcmFpc2VkIGJ5IEFQSSBmb3Igb25lIGFtb25nIHRocmVlIHJlYXNvbnMgOiB3cm9uZyBBUEkgdXNhZ2UsIHVuZGVybHlpbmcgc2VydmljZSBlcnJvciBvciB1bmtub3duIHJlYXNvbi5cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGF0dXMgLSBFcnJvciBzdGF0dXMgOiB3aGVuIHtAbGluayBHcC5FcnJvci5UWVBFX1NSVkVSUn0sIGdpdmVzIHRoZSBbSFRUUCBzdGF0dXMgb2YgdGhlIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UgcmVzcG9uc2Vde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfSFRUUF9zdGF0dXNfY29kZXN9IDsgLTEgb3RoZXJ3aXNlLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgLSBFcnJvciB0eXBlICh7QGxpbmsgR3AuRXJyb3IuVFlQRV9TUlZFUlJ9LCB7QGxpbmsgR3AuRXJyb3IuVFlQRV9VU0VFUlJ9IG9yIHtAbGluayBHcC5FcnJvci5UWVBFX1VOS0VSUn0pLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5FcnJvclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBlcnJvciAtIE9wdGlvbnMgZm9yIGNyZWF0aW5nIGVycm9yIG9iamVjdC4gQ2FuIGJlIGEgU3RyaW5nIChtZXNzYWdlKSBvciBhbiBPYmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gZXJyb3IubWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gcmV0dXJuIHRvIHVzZXIuXG4gKiBAcGFyYW0ge2VudW19IFtlcnJvci50eXBlPVRZUEVfVU5LRVJSXSAtIEVycm9yIHR5cGVcbiAqIEBwYXJhbSB7c3RhdHVzfSBbZXJyb3Iuc3RhdHVzPS0xXSAtIEVycm9yIHN0YXR1cyA6IHdoZW4ge0BsaW5rIEdwLkVycm9yLlRZUEVfU1JWRVJSfSwgZ2l2ZXMgdGhlIFtIVFRQIHN0YXR1cyBvZiB0aGUgdW5kZXJseWluZyB3ZWIgc2VydmljZSByZXNwb25zZV17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9IVFRQX3N0YXR1c19jb2Rlc30uXG4gKlxuICovXG5mdW5jdGlvbiBFcnJvclNlcnZpY2UgKGVycm9yKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVycm9yU2VydmljZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVycm9yU2VydmljZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBlID0gZXJyb3I7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiB8fCBlcnJvciBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAtMTtcbiAgICAgICAgdGhpcy50eXBlID0gRXJyb3JTZXJ2aWNlLlRZUEVfVU5LRVJSO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZSB8fCBcInVuZGVmaW5lZCE/XCI7XG4gICAgICAgIHRoaXMudHlwZSA9IGUudHlwZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBlLnN0YXR1cyB8fCAtMTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSBcIkVycm9yU2VydmljZVwiO1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xufVxuXG4vKipcbiAqIEVycm9yIHJhaXNlZCB3aGVuIHVuZGVybHlpbmcgZ2VvcG9ydGFsIHNlcnZpY2UgYW5zd2VycyBvbiBlcnJvci5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGNvbnN0YW50XG4gKiBAc3RhdGljXG4gKi9cbkVycm9yU2VydmljZS5UWVBFX1NSVkVSUiA9IFwiU0VSVklDRV9FUlJPUlwiO1xuLyoqXG4gKiBFcnJvciByYWlzZWQgd2hlbiBmdW5jaW9uIHVzZSBpcyBpbmFwcHJvcHJpYXRlXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBjb25zdGFudFxuICogQHN0YXRpY1xuICovXG5FcnJvclNlcnZpY2UuVFlQRV9VU0VFUlIgPSBcIlVTQUdFX0VSUk9SXCI7XG4vKipcbiAqIEVycm9yIHJhaXNlZCB3aGVuIEFQSSBjYW4ndCBwZXJmb3JtIHRoZSBqb2IgZm9yIGEgcmVhc29uIG90aGVyIHRoYW4gdGhlIHR3byBvdGhlciBvbmVzLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqL1xuRXJyb3JTZXJ2aWNlLlRZUEVfVU5LRVJSID0gXCJVTktOT1dOX0VSUk9SXCI7XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpFcnJvclNlcnZpY2VcbiAqL1xuRXJyb3JTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3IgOiB7XG4gICAgICAgIHZhbHVlIDogRXJyb3JTZXJ2aWNlLFxuICAgICAgICB3cml0YWJsZSA6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZSA6IHRydWVcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRXJyb3JTZXJ2aWNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/JSONP.js":
/*!******************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/JSONP.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/**\n * JSONP : Implémentation du protocole JSONP de la plateforme Géoportail\n *\n * @module JSONP\n * @private\n * @alias Gp.Protocols.JSONP\n */\n\n\n// cf. https://github.com/sobstel/jsonp.js\nvar JSONP = {\n\n    /**\n     * Construction d'un identifiant statique basé sur le timestamp,\n     * et qui s'incremente de +1 à chaque appel\n     */\n    uuid : (function () {\n        var id = Math.floor(Date.now());\n        return function () {\n            return id++;\n        };\n    })(),\n\n    /**\n     * Cette fonction réalise l'appel du service fourni via le paramètre \"options.url\"\n     * en mettant en œuvre le protocole JSONP.\n     *\n     * @method call\n     * @static\n     * @param {Object} options - parametres d'invocation du service en JSONP\n     * @param {String} options.url - URL du service à invoquer (indépendamment du protocole JSONP).\n     *  Cette URL contient déjà les paramètres du service.\n     *  Si le paramètre dédié à la mise en oeuvre du protocole JSONP (callback=xxx) n'est pas présent, il est rajouté par la fonction ;\n     *  sa valeur est déterminée en fonction du paramètre callbackName.\n     * @param {Number} [options.timeOut = 0] - Nombre de ms au bout duquel on considère que le service n'a pas répondu.\n     *  Une valeur de 0 pour ce paramètre permet de désactiver la gestion du timeOut.\n     * @param {String} [options.callbackSuffix = null] - Suffixe de la fonction de callback à rajouter sur l'URL.\n     *  Si aucun suffixe n'est spécifié (cas par défaut), on utilisera l'identifiant this.uuid () comme suffixe. Ex: \"callback1458574396582 ()\"\n     * @param {String} [options.callbackName = gp.protocol.jsonp] - Valeur du paramètre callback à rajouter sur l'URL.\n     *  Si l'URL fournie contient déjà le paramètre callback, le paramètre callbackName ne sera pas pris en compte.\n     *  La fonction de callback est créée dynamiquement par la fonction JSONP ;\n     *  elle a deux fonctions :\n     *    elle annule la condition de timeOut\n     *    puis appelle la fonction fournie par l'utilisateur via le paramètre onResponse.\n     * @param {Function} options.onResponse - Nom de la fonction qui sera appelée lors de la réception des résultats du service.\n     *  Ce paramètre sera ignoré si l'URL contient déjà le paramètre callback.\n     *  La fonction de rappel appelée sera alors celle ayant pour nom la valeur de ce paramètre.\n     * @param {Function} [options.onTimeOut] - Nom de la fonction qui sera appelée en cas de non réponse du service.\n     *  Le temps au bout duquel on considère que le service n'a pas répondu est déterminé par le paramètre timeOut.\n     *  @example\n     *  var options = {\n     *      url : 'http://localhost/some/test.json&callback=myResults',\n     *      timeOut : 100,\n     *      callbackName : 'myResults',\n     *      callbackSuffix : \"\",\n     *      onResponse : function (response) {\n     *          console.log('results : ', response);\n     *      },\n     *\n     *   };\n     *   JSONP.call(options);\n     */\n    call : function (options) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"JSONP\");\n        logger.trace(\"[JSONP::call ()]\");\n\n        // analyse parametres\n\n        if (!options) {\n            logger.error(\"missing parameter : options !\");\n            throw new Error(\"missing parameter : options !\");\n        }\n\n        if (!options.url) {\n            logger.error(\"missing parameter : options.url !\");\n            throw new Error(\"missing parameter : options.url !\");\n        }\n\n        if (!options.timeOut) {\n            logger.info(\"setting 'options.timeOut' default value\");\n            options.timeOut = 0;\n        }\n\n        // FIXME si un callback coté client a été mis en place,\n        // cette condition sur cette methode n'a pas de sens !?\n        if (!options.onResponse) {\n            logger.error(\"missing parameter : options.onResponse !\");\n            throw new Error(\"missing parameter : options.onResponse !\");\n            // FIXME doit on definir un callback interne par defaut !?\n            // options.onResponse = function (data) {\n            //    console.log(\"response callback (inner) : \", data);\n            // };\n        }\n\n        // ID du callback à utiliser : null ou string.\n        // si l'utilisateur a spécifié un suffixe pour le callback, on le récupère comme un ID (ex: options.callbackSuffix = \"\")\n        // sinon, on utilise un timestamp : this.uuid ()\n        var callbackId = (typeof options.callbackSuffix === \"string\") ? options.callbackSuffix : this.uuid();\n\n        // on recherche le parametre callback et son nom de fonction dans l'url\n        var urlHasCallbackKey = false;\n        var urlHasCallbackName = false;\n\n        var idx = options.url.indexOf(\"callback=\");\n\n        if (idx !== -1) {\n            urlHasCallbackKey = true;\n            // extraction callbackName de l'url : entre \"callback=\" et \"&\" ou fin de ligne\n            var j = options.url.indexOf(\"&\", idx);\n            if (j === -1) {\n                j = options.url.length;\n            }\n\n            // on ecrase le parametre options.callbackName s'il avait été défini\n            var callbackName = options.url.substring(idx + 9, j);\n\n            if (callbackName) {\n                urlHasCallbackName = true;\n                options.callbackName = callbackName;\n                logger.info(\"setting 'options.callbackName' value (\" + options.callbackName + \") from 'options.url' parameter\");\n            }\n        }\n\n        // on ajoute le parametre callback dans l'URL s'il n'existe pas\n        if (!urlHasCallbackKey) {\n            // gestion des autres param. et \"?\"\n            var k = options.url.indexOf(\"?\");\n            if (k === -1) {\n                // aucun param., ni de '?'\n                options.url = options.url + \"?\" + \"callback=\";\n            } else if (k === options.url.length) {\n                // uniquement le '?'\n                options.url = options.url + \"callback=\";\n            } else {\n                // le '?' et les param. existent\n                options.url = options.url + \"&\" + \"callback=\";\n            }\n            logger.info(\"setting callback default key in 'options.url' : \" + options.url);\n        }\n\n        // utilisation de la fonction callback coté client ?\n        var HasCallbackName = options.callbackName ? true : urlHasCallbackName;\n\n        // on ajoute le nom de la fonction callback dans l'URL si elle n'existe pas\n        if (!urlHasCallbackName) {\n            // fonction callback par defaut\n            if (!options.callbackName) {\n                logger.info(\"setting 'options.callbackName' default value\");\n                options.callbackName = \"callback\"; // ou \"gp.protocol.jsonp\" ?\n                // info : si on ne veut pas gerer d'ID dans le callback,\n                // options.callbackSuffix = \"\"\n                if (callbackId || callbackId === \"\") {\n                    options.callbackName += callbackId;\n                }\n            }\n            options.url = options.url.replace(\"callback=\", \"callback=\" + options.callbackName);\n            logger.info(\"setting callback function name in 'options.url' : \" + options.url);\n        }\n\n        // timeOut par defaut\n        if (!options.onTimeOut) {\n            logger.info(\"setting 'options.onTimeOut' default value\");\n            /** callback timeout par defaut */\n            options.onTimeOut = function (/* error */) {\n                console.log(\"TimeOut while invoking url : \" + options.url);\n            };\n        }\n\n        if (!HasCallbackName) {\n            var self = this;\n\n            // event du timeout\n            var onTimeOutTrigger = null;\n\n            // declenche le timeout si > à 0 !\n            if (options.timeOut > 0) {\n                onTimeOutTrigger = window.setTimeout(\n                    function () {\n                        /** fonction de reponse du service */\n                        window[options.callbackName] = function () {};\n                        options.onTimeOut();\n                        self._deleteScript(callbackId);\n                    }, options.timeOut);\n            }\n\n            // FIXME le nom de la fonction n'accepte pas de namespace !\n            // ex. Gp.Function.callback\n            /**\n            * fonction de reponse du service\n            * @param {Object} data - data\n            * @private\n            */\n            window[options.callbackName] = function (data) {\n                window.clearTimeout(onTimeOutTrigger);\n                options.onResponse(data);\n                self._deleteScript(callbackId);\n            };\n        }\n\n        this._createScript(callbackId, options.url);\n    },\n\n    /**\n    * create Script\n    * @param {String} callbackId - callback Id\n    * @param {String} url - url\n    * @private\n    */\n    _createScript : function (callbackId, url) {\n        var scriptu;\n        var scripto = document.getElementById(\"results\" + callbackId);\n\n        scriptu = document.createElement(\"script\");\n        scriptu.setAttribute(\"type\", \"text/javascript\");\n        scriptu.setAttribute(\"src\", url);\n        scriptu.setAttribute(\"charset\", \"UTF-8\");\n        scriptu.setAttribute(\"id\", \"results\" + callbackId);\n        scriptu.setAttribute(\"async\", \"true\"); // FIXME async ?\n        // head ou body ou autres ?\n        var node = document.documentElement || document.getElementsByTagName(\"head\")[0];\n        if (scripto === null) {\n            node.appendChild(scriptu);\n        } else {\n            // s'il existe déjà, on le remplace !\n            node.replaceChild(scriptu, scripto);\n        }\n    },\n\n    /**\n    * delete Script\n    * @param {String} callbackId - callback Id\n    * @private\n    */\n    _deleteScript : function (callbackId) {\n        var script = document.getElementById(\"results\" + callbackId);\n        if (script) {\n            var node = script.parentNode || document.documentElement;\n            if (!node) {\n                return;\n            }\n            node.removeChild(script);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (JSONP);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9KU09OUC5qcz8zYjE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFNO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxvRUFBSyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2dlb3BvcnRhbC1hY2Nlc3MtbGliL3NyYy9Qcm90b2NvbHMvSlNPTlAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEpTT05QIDogSW1wbMOpbWVudGF0aW9uIGR1IHByb3RvY29sZSBKU09OUCBkZSBsYSBwbGF0ZWZvcm1lIEfDqW9wb3J0YWlsXG4gKlxuICogQG1vZHVsZSBKU09OUFxuICogQHByaXZhdGVcbiAqIEBhbGlhcyBHcC5Qcm90b2NvbHMuSlNPTlBcbiAqL1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cbi8vIGNmLiBodHRwczovL2dpdGh1Yi5jb20vc29ic3RlbC9qc29ucC5qc1xudmFyIEpTT05QID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0aW9uIGQndW4gaWRlbnRpZmlhbnQgc3RhdGlxdWUgYmFzw6kgc3VyIGxlIHRpbWVzdGFtcCxcbiAgICAgKiBldCBxdWkgcydpbmNyZW1lbnRlIGRlICsxIMOgIGNoYXF1ZSBhcHBlbFxuICAgICAqL1xuICAgIHV1aWQgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSBNYXRoLmZsb29yKERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKys7XG4gICAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIC8qKlxuICAgICAqIENldHRlIGZvbmN0aW9uIHLDqWFsaXNlIGwnYXBwZWwgZHUgc2VydmljZSBmb3VybmkgdmlhIGxlIHBhcmFtw6h0cmUgXCJvcHRpb25zLnVybFwiXG4gICAgICogZW4gbWV0dGFudCBlbiDFk3V2cmUgbGUgcHJvdG9jb2xlIEpTT05QLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjYWxsXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gcGFyYW1ldHJlcyBkJ2ludm9jYXRpb24gZHUgc2VydmljZSBlbiBKU09OUFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIFVSTCBkdSBzZXJ2aWNlIMOgIGludm9xdWVyIChpbmTDqXBlbmRhbW1lbnQgZHUgcHJvdG9jb2xlIEpTT05QKS5cbiAgICAgKiAgQ2V0dGUgVVJMIGNvbnRpZW50IGTDqWrDoCBsZXMgcGFyYW3DqHRyZXMgZHUgc2VydmljZS5cbiAgICAgKiAgU2kgbGUgcGFyYW3DqHRyZSBkw6lkacOpIMOgIGxhIG1pc2UgZW4gb2V1dnJlIGR1IHByb3RvY29sZSBKU09OUCAoY2FsbGJhY2s9eHh4KSBuJ2VzdCBwYXMgcHLDqXNlbnQsIGlsIGVzdCByYWpvdXTDqSBwYXIgbGEgZm9uY3Rpb24gO1xuICAgICAqICBzYSB2YWxldXIgZXN0IGTDqXRlcm1pbsOpZSBlbiBmb25jdGlvbiBkdSBwYXJhbcOodHJlIGNhbGxiYWNrTmFtZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZU91dCA9IDBdIC0gTm9tYnJlIGRlIG1zIGF1IGJvdXQgZHVxdWVsIG9uIGNvbnNpZMOocmUgcXVlIGxlIHNlcnZpY2UgbidhIHBhcyByw6lwb25kdS5cbiAgICAgKiAgVW5lIHZhbGV1ciBkZSAwIHBvdXIgY2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgZMOpc2FjdGl2ZXIgbGEgZ2VzdGlvbiBkdSB0aW1lT3V0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9IG51bGxdIC0gU3VmZml4ZSBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayDDoCByYWpvdXRlciBzdXIgbCdVUkwuXG4gICAgICogIFNpIGF1Y3VuIHN1ZmZpeGUgbidlc3Qgc3DDqWNpZmnDqSAoY2FzIHBhciBkw6lmYXV0KSwgb24gdXRpbGlzZXJhIGwnaWRlbnRpZmlhbnQgdGhpcy51dWlkICgpIGNvbW1lIHN1ZmZpeGUuIEV4OiBcImNhbGxiYWNrMTQ1ODU3NDM5NjU4MiAoKVwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNhbGxiYWNrTmFtZSA9IGdwLnByb3RvY29sLmpzb25wXSAtIFZhbGV1ciBkdSBwYXJhbcOodHJlIGNhbGxiYWNrIMOgIHJham91dGVyIHN1ciBsJ1VSTC5cbiAgICAgKiAgU2kgbCdVUkwgZm91cm5pZSBjb250aWVudCBkw6lqw6AgbGUgcGFyYW3DqHRyZSBjYWxsYmFjaywgbGUgcGFyYW3DqHRyZSBjYWxsYmFja05hbWUgbmUgc2VyYSBwYXMgcHJpcyBlbiBjb21wdGUuXG4gICAgICogIExhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIGVzdCBjcsOpw6llIGR5bmFtaXF1ZW1lbnQgcGFyIGxhIGZvbmN0aW9uIEpTT05QIDtcbiAgICAgKiAgZWxsZSBhIGRldXggZm9uY3Rpb25zIDpcbiAgICAgKiAgICBlbGxlIGFubnVsZSBsYSBjb25kaXRpb24gZGUgdGltZU91dFxuICAgICAqICAgIHB1aXMgYXBwZWxsZSBsYSBmb25jdGlvbiBmb3VybmllIHBhciBsJ3V0aWxpc2F0ZXVyIHZpYSBsZSBwYXJhbcOodHJlIG9uUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblJlc3BvbnNlIC0gTm9tIGRlIGxhIGZvbmN0aW9uIHF1aSBzZXJhIGFwcGVsw6llIGxvcnMgZGUgbGEgcsOpY2VwdGlvbiBkZXMgcsOpc3VsdGF0cyBkdSBzZXJ2aWNlLlxuICAgICAqICBDZSBwYXJhbcOodHJlIHNlcmEgaWdub3LDqSBzaSBsJ1VSTCBjb250aWVudCBkw6lqw6AgbGUgcGFyYW3DqHRyZSBjYWxsYmFjay5cbiAgICAgKiAgTGEgZm9uY3Rpb24gZGUgcmFwcGVsIGFwcGVsw6llIHNlcmEgYWxvcnMgY2VsbGUgYXlhbnQgcG91ciBub20gbGEgdmFsZXVyIGRlIGNlIHBhcmFtw6h0cmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25UaW1lT3V0XSAtIE5vbSBkZSBsYSBmb25jdGlvbiBxdWkgc2VyYSBhcHBlbMOpZSBlbiBjYXMgZGUgbm9uIHLDqXBvbnNlIGR1IHNlcnZpY2UuXG4gICAgICogIExlIHRlbXBzIGF1IGJvdXQgZHVxdWVsIG9uIGNvbnNpZMOocmUgcXVlIGxlIHNlcnZpY2UgbidhIHBhcyByw6lwb25kdSBlc3QgZMOpdGVybWluw6kgcGFyIGxlIHBhcmFtw6h0cmUgdGltZU91dC5cbiAgICAgKiAgQGV4YW1wbGVcbiAgICAgKiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAgICB1cmwgOiAnaHR0cDovL2xvY2FsaG9zdC9zb21lL3Rlc3QuanNvbiZjYWxsYmFjaz1teVJlc3VsdHMnLFxuICAgICAqICAgICAgdGltZU91dCA6IDEwMCxcbiAgICAgKiAgICAgIGNhbGxiYWNrTmFtZSA6ICdteVJlc3VsdHMnLFxuICAgICAqICAgICAgY2FsbGJhY2tTdWZmaXggOiBcIlwiLFxuICAgICAqICAgICAgb25SZXNwb25zZSA6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzIDogJywgcmVzcG9uc2UpO1xuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgfTtcbiAgICAgKiAgIEpTT05QLmNhbGwob3B0aW9ucyk7XG4gICAgICovXG4gICAgY2FsbCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuICAgICAgICB2YXIgbG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcihcIkpTT05QXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJbSlNPTlA6OmNhbGwgKCldXCIpO1xuXG4gICAgICAgIC8vIGFuYWx5c2UgcGFyYW1ldHJlc1xuXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwibWlzc2luZyBwYXJhbWV0ZXIgOiBvcHRpb25zICFcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHBhcmFtZXRlciA6IG9wdGlvbnMgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogb3B0aW9ucy51cmwgIVwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogb3B0aW9ucy51cmwgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy50aW1lT3V0KSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgJ29wdGlvbnMudGltZU91dCcgZGVmYXVsdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIG9wdGlvbnMudGltZU91dCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBzaSB1biBjYWxsYmFjayBjb3TDqSBjbGllbnQgYSDDqXTDqSBtaXMgZW4gcGxhY2UsXG4gICAgICAgIC8vIGNldHRlIGNvbmRpdGlvbiBzdXIgY2V0dGUgbWV0aG9kZSBuJ2EgcGFzIGRlIHNlbnMgIT9cbiAgICAgICAgaWYgKCFvcHRpb25zLm9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogb3B0aW9ucy5vblJlc3BvbnNlICFcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHBhcmFtZXRlciA6IG9wdGlvbnMub25SZXNwb25zZSAhXCIpO1xuICAgICAgICAgICAgLy8gRklYTUUgZG9pdCBvbiBkZWZpbmlyIHVuIGNhbGxiYWNrIGludGVybmUgcGFyIGRlZmF1dCAhP1xuICAgICAgICAgICAgLy8gb3B0aW9ucy5vblJlc3BvbnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2UgY2FsbGJhY2sgKGlubmVyKSA6IFwiLCBkYXRhKTtcbiAgICAgICAgICAgIC8vIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRCBkdSBjYWxsYmFjayDDoCB1dGlsaXNlciA6IG51bGwgb3Ugc3RyaW5nLlxuICAgICAgICAvLyBzaSBsJ3V0aWxpc2F0ZXVyIGEgc3DDqWNpZmnDqSB1biBzdWZmaXhlIHBvdXIgbGUgY2FsbGJhY2ssIG9uIGxlIHLDqWN1cMOocmUgY29tbWUgdW4gSUQgKGV4OiBvcHRpb25zLmNhbGxiYWNrU3VmZml4ID0gXCJcIilcbiAgICAgICAgLy8gc2lub24sIG9uIHV0aWxpc2UgdW4gdGltZXN0YW1wIDogdGhpcy51dWlkICgpXG4gICAgICAgIHZhciBjYWxsYmFja0lkID0gKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrU3VmZml4ID09PSBcInN0cmluZ1wiKSA/IG9wdGlvbnMuY2FsbGJhY2tTdWZmaXggOiB0aGlzLnV1aWQoKTtcblxuICAgICAgICAvLyBvbiByZWNoZXJjaGUgbGUgcGFyYW1ldHJlIGNhbGxiYWNrIGV0IHNvbiBub20gZGUgZm9uY3Rpb24gZGFucyBsJ3VybFxuICAgICAgICB2YXIgdXJsSGFzQ2FsbGJhY2tLZXkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVybEhhc0NhbGxiYWNrTmFtZSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBpZHggPSBvcHRpb25zLnVybC5pbmRleE9mKFwiY2FsbGJhY2s9XCIpO1xuXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICB1cmxIYXNDYWxsYmFja0tleSA9IHRydWU7XG4gICAgICAgICAgICAvLyBleHRyYWN0aW9uIGNhbGxiYWNrTmFtZSBkZSBsJ3VybCA6IGVudHJlIFwiY2FsbGJhY2s9XCIgZXQgXCImXCIgb3UgZmluIGRlIGxpZ25lXG4gICAgICAgICAgICB2YXIgaiA9IG9wdGlvbnMudXJsLmluZGV4T2YoXCImXCIsIGlkeCk7XG4gICAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBqID0gb3B0aW9ucy51cmwubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbiBlY3Jhc2UgbGUgcGFyYW1ldHJlIG9wdGlvbnMuY2FsbGJhY2tOYW1lIHMnaWwgYXZhaXQgw6l0w6kgZMOpZmluaVxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrTmFtZSA9IG9wdGlvbnMudXJsLnN1YnN0cmluZyhpZHggKyA5LCBqKTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrTmFtZSkge1xuICAgICAgICAgICAgICAgIHVybEhhc0NhbGxiYWNrTmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFja05hbWUgPSBjYWxsYmFja05hbWU7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nICdvcHRpb25zLmNhbGxiYWNrTmFtZScgdmFsdWUgKFwiICsgb3B0aW9ucy5jYWxsYmFja05hbWUgKyBcIikgZnJvbSAnb3B0aW9ucy51cmwnIHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uIGFqb3V0ZSBsZSBwYXJhbWV0cmUgY2FsbGJhY2sgZGFucyBsJ1VSTCBzJ2lsIG4nZXhpc3RlIHBhc1xuICAgICAgICBpZiAoIXVybEhhc0NhbGxiYWNrS2V5KSB7XG4gICAgICAgICAgICAvLyBnZXN0aW9uIGRlcyBhdXRyZXMgcGFyYW0uIGV0IFwiP1wiXG4gICAgICAgICAgICB2YXIgayA9IG9wdGlvbnMudXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gYXVjdW4gcGFyYW0uLCBuaSBkZSAnPydcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgXCI/XCIgKyBcImNhbGxiYWNrPVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrID09PSBvcHRpb25zLnVybC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmlxdWVtZW50IGxlICc/J1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBcImNhbGxiYWNrPVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsZSAnPycgZXQgbGVzIHBhcmFtLiBleGlzdGVudFxuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBcIiZcIiArIFwiY2FsbGJhY2s9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgY2FsbGJhY2sgZGVmYXVsdCBrZXkgaW4gJ29wdGlvbnMudXJsJyA6IFwiICsgb3B0aW9ucy51cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXRpbGlzYXRpb24gZGUgbGEgZm9uY3Rpb24gY2FsbGJhY2sgY290w6kgY2xpZW50ID9cbiAgICAgICAgdmFyIEhhc0NhbGxiYWNrTmFtZSA9IG9wdGlvbnMuY2FsbGJhY2tOYW1lID8gdHJ1ZSA6IHVybEhhc0NhbGxiYWNrTmFtZTtcblxuICAgICAgICAvLyBvbiBham91dGUgbGUgbm9tIGRlIGxhIGZvbmN0aW9uIGNhbGxiYWNrIGRhbnMgbCdVUkwgc2kgZWxsZSBuJ2V4aXN0ZSBwYXNcbiAgICAgICAgaWYgKCF1cmxIYXNDYWxsYmFja05hbWUpIHtcbiAgICAgICAgICAgIC8vIGZvbmN0aW9uIGNhbGxiYWNrIHBhciBkZWZhdXRcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jYWxsYmFja05hbWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgJ29wdGlvbnMuY2FsbGJhY2tOYW1lJyBkZWZhdWx0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tOYW1lID0gXCJjYWxsYmFja1wiOyAvLyBvdSBcImdwLnByb3RvY29sLmpzb25wXCIgP1xuICAgICAgICAgICAgICAgIC8vIGluZm8gOiBzaSBvbiBuZSB2ZXV0IHBhcyBnZXJlciBkJ0lEIGRhbnMgbGUgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9IFwiXCJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tJZCB8fCBjYWxsYmFja0lkID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tOYW1lICs9IGNhbGxiYWNrSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybC5yZXBsYWNlKFwiY2FsbGJhY2s9XCIsIFwiY2FsbGJhY2s9XCIgKyBvcHRpb25zLmNhbGxiYWNrTmFtZSk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgY2FsbGJhY2sgZnVuY3Rpb24gbmFtZSBpbiAnb3B0aW9ucy51cmwnIDogXCIgKyBvcHRpb25zLnVybCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lT3V0IHBhciBkZWZhdXRcbiAgICAgICAgaWYgKCFvcHRpb25zLm9uVGltZU91dCkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nICdvcHRpb25zLm9uVGltZU91dCcgZGVmYXVsdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIC8qKiBjYWxsYmFjayB0aW1lb3V0IHBhciBkZWZhdXQgKi9cbiAgICAgICAgICAgIG9wdGlvbnMub25UaW1lT3V0ID0gZnVuY3Rpb24gKC8qIGVycm9yICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUaW1lT3V0IHdoaWxlIGludm9raW5nIHVybCA6IFwiICsgb3B0aW9ucy51cmwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghSGFzQ2FsbGJhY2tOYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50IGR1IHRpbWVvdXRcbiAgICAgICAgICAgIHZhciBvblRpbWVPdXRUcmlnZ2VyID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gZGVjbGVuY2hlIGxlIHRpbWVvdXQgc2kgPiDDoCAwICFcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgb25UaW1lT3V0VHJpZ2dlciA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogZm9uY3Rpb24gZGUgcmVwb25zZSBkdSBzZXJ2aWNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dbb3B0aW9ucy5jYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uVGltZU91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGVsZXRlU2NyaXB0KGNhbGxiYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVPdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRSBsZSBub20gZGUgbGEgZm9uY3Rpb24gbidhY2NlcHRlIHBhcyBkZSBuYW1lc3BhY2UgIVxuICAgICAgICAgICAgLy8gZXguIEdwLkZ1bmN0aW9uLmNhbGxiYWNrXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogZm9uY3Rpb24gZGUgcmVwb25zZSBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZGF0YVxuICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHdpbmRvd1tvcHRpb25zLmNhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQob25UaW1lT3V0VHJpZ2dlcik7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlc3BvbnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2RlbGV0ZVNjcmlwdChjYWxsYmFja0lkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jcmVhdGVTY3JpcHQoY2FsbGJhY2tJZCwgb3B0aW9ucy51cmwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIGNyZWF0ZSBTY3JpcHRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWxsYmFja0lkIC0gY2FsbGJhY2sgSWRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSB1cmxcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfY3JlYXRlU2NyaXB0IDogZnVuY3Rpb24gKGNhbGxiYWNrSWQsIHVybCkge1xuICAgICAgICB2YXIgc2NyaXB0dTtcbiAgICAgICAgdmFyIHNjcmlwdG8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc3VsdHNcIiArIGNhbGxiYWNrSWQpO1xuXG4gICAgICAgIHNjcmlwdHUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHR1LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2phdmFzY3JpcHRcIik7XG4gICAgICAgIHNjcmlwdHUuc2V0QXR0cmlidXRlKFwic3JjXCIsIHVybCk7XG4gICAgICAgIHNjcmlwdHUuc2V0QXR0cmlidXRlKFwiY2hhcnNldFwiLCBcIlVURi04XCIpO1xuICAgICAgICBzY3JpcHR1LnNldEF0dHJpYnV0ZShcImlkXCIsIFwicmVzdWx0c1wiICsgY2FsbGJhY2tJZCk7XG4gICAgICAgIHNjcmlwdHUuc2V0QXR0cmlidXRlKFwiYXN5bmNcIiwgXCJ0cnVlXCIpOyAvLyBGSVhNRSBhc3luYyA/XG4gICAgICAgIC8vIGhlYWQgb3UgYm9keSBvdSBhdXRyZXMgP1xuICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gICAgICAgIGlmIChzY3JpcHRvID09PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHNjcmlwdHUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcydpbCBleGlzdGUgZMOpasOgLCBvbiBsZSByZW1wbGFjZSAhXG4gICAgICAgICAgICBub2RlLnJlcGxhY2VDaGlsZChzY3JpcHR1LCBzY3JpcHRvKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIGRlbGV0ZSBTY3JpcHRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWxsYmFja0lkIC0gY2FsbGJhY2sgSWRcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfZGVsZXRlU2NyaXB0IDogZnVuY3Rpb24gKGNhbGxiYWNrSWQpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzdWx0c1wiICsgY2FsbGJhY2tJZCk7XG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2NyaXB0LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgSlNPTlA7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Protocols/JSONP.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/Protocol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/Protocol.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/Helper */ \"./node_modules/geoportal-access-lib/src/Utils/Helper.js\");\n/* harmony import */ var _XHR__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XHR */ \"./node_modules/geoportal-access-lib/src/Protocols/XHR.js\");\n/* harmony import */ var _JSONP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JSONP */ \"./node_modules/geoportal-access-lib/src/Protocols/JSONP.js\");\n/**\n * Interface de dialogue avec les webservices\n *\n * @module Protocols\n * @private\n * @alias Gp.Protocols\n */\n\n\n\n\nvar Protocol = {\n\n    /**\n     * Interface unique d\"envoi d\"une requête.\n     *\n     * @method send\n     * @static\n     * @param {Object} options - options generales\n     * @param {String} options.url      - url du service\n     * @param {String} options.method   - GET, POST, PUT, DELETE\n     * @param {String} options.protocol - XHR | JSONP\n     * @param {String} options.format   - format de la reponse du service : json, xml ou null (brute)...\n     * @param {String} options.wrap     - encapsuler la reponse du service dans du JSON : true|false (true par defaut sur le protocole JSONP)\n     * @param {String} options.callbackSuffix - suffixe de la fonction de callback (JSONP uniquement) (ex: si callbackSuffix=\"\", la fonction s'appellera \"callback\")\n     * @param {String} options.timeOut  - 0 ms\n     * @param {Boolean} options.nocache  - true|false\n     * @param {Object|String} options.data        - content (post) ou param (get)\n     * @param {Object|String} options.headers     - (post) ex. referer\n     * @param {Object|String} options.content - (post) ex. \"application/json\"\n     * @param {String} options.scope       - this (TODO)\n     * @param {Function} options.onResponse - callback\n     * @param {Function} options.onFailure - callback\n     * @param {Function} options.onTimeOut - callback\n     * @param {String} options.proxyUrl -  (TODO)\n     */\n    send : function (options) {\n        // INFO\n        // \"output\" - param est interne à la classe \"Protocol\" (parametrable via \"wrap\"), et à ajouter à l\"url\n        //      ce param est independant du service car il est géré par le filtre LUA :\n        //          ex. json|xml (json par defaut).\n        //          Ce param. permet d\"encapsuler du XML dans du JSON :\n        //              {http : {status:200, error:null},xml :\"réponse du service\"}\n        //          Utile pour les services qui ne repondent que du XML (ex. Geocodage)\n        //\n        // |-------------------------------------------------|\n        // |      \\service |      |     |                    |\n        // | output\\ format| json | xml |     remarques      |\n        // |--------\\------|------|-----|--------------------|\n        // |    json       | json | json| json/xml encapsulé |\n        // |    xml        | json | xml | param inactif      |\n        // |-------------------------------------------------|\n        // ex. le service demande une reponse native au \"format\" json et avec un \"output\" json.\n        // on a donc une reponse json encapsulé dans un json : ce qu'on ne souhaite pas !\n        // dans ce cas on ne renseigne pas output=json\n\n        // INFO\n        // \"wrap\" - choix d\"encapsuler ou non les reponses dans du JSON.\n        //      Par defaut, on encapsule uniquement les reponses sur le protocole JSONP (et qui sont en xml) !\n\n        // INFO\n        // \"callback\" - param est interne à la classe \"Protocol\" (non parametrable), et à ajouter à l\"url\n        //      ce param est independant du service car il est géré aussi par le filtre LUA :\n        //          ex. callback|null\n        //          Ce param. permet de renvoyer une reponse javascript :\n        //              callback ({http : {status:200, error:null},xml :\"réponse du service\"})\n        //          Ce param. est non renseigné par defaut car pour du JSONP, on utilise le\n        //          le protocol JSONP, et ce dernier implemente déjà le callback !\n\n        // settings par defaut\n        var settings = options || {\n            method : \"GET\",\n            // protocol : \"JSONP\",\n            protocol : \"XHR\",\n            timeOut : 0,\n            format : null,\n            wrap : true,\n            nocache : true,\n            output : \"json\",\n            callback : null,\n            callbackSuffix : null\n        };\n\n        // on determine l'environnement d'execution : browser ou non ?\n        // et on stoppe pour nodeJS... sur un protocole JSONP !\n        if (typeof window === \"undefined\" && options.protocol === \"JSONP\") {\n            console.log(\"Value (s) for parameter (s) 'protocol=JSONP (instead use XHR)' not supported to NodeJS\");\n            return;\n        }\n\n        if (options.protocol === \"XHR\" || options.format === \"json\") {\n            settings.wrap = false;\n        } else if (options.protocol === \"JSONP\" && options.format === \"xml\") {\n            settings.wrap = true;\n        }\n\n        settings.callback = null; // FIXME non géré !?\n        settings.output = settings.wrap ? \"json\" : null;\n\n        // on encapsule les reponses dans un objet JSON\n        if (settings.wrap) {\n            var params = {};\n            params.output = settings.output;\n            params.callback = settings.callback;\n            delete params.callback; // FIXME non géré !?\n            settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalyzeUrl(options.url, params);\n        }\n\n        // choix de l\"implementation :\n        // XHR ou JSONP\n        switch (settings.protocol) {\n            case \"XHR\":\n                // on normalise l'url (gestion du cache)\n                if (options.method === \"GET\" && options.nocache) {\n                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalyzeUrl(settings.url, {\n                        t : new Date().getTime()\n                    });\n                }\n                // appel du service en XHR\n                _XHR__WEBPACK_IMPORTED_MODULE_1__[\"default\"].call(settings);\n                break;\n            case \"JSONP\":\n\n                // on normalise l'url si les params. sont renseignés dans la string|object \"data\"\n                if (settings.data) {\n                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalyzeUrl(settings.url, settings.data);\n                }\n\n                // appel du service en JSONP\n                _JSONP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].call(settings);\n                break;\n            default:\n                throw new Error(\"protocol not supported (XHR|JSONP) !\");\n        }\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Protocol);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9Qcm90b2NvbC5qcz8yMjYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDYjtBQUNJOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUSx1QkFBdUIsMkJBQTJCO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQkFBMkIscURBQU07QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFNO0FBQ3pDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQUc7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFNO0FBQ3pDOztBQUVBO0FBQ0EsZ0JBQWdCLDhDQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsdUVBQVEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvUHJvdG9jb2xzL1Byb3RvY29sLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcmZhY2UgZGUgZGlhbG9ndWUgYXZlYyBsZXMgd2Vic2VydmljZXNcbiAqXG4gKiBAbW9kdWxlIFByb3RvY29sc1xuICogQHByaXZhdGVcbiAqIEBhbGlhcyBHcC5Qcm90b2NvbHNcbiAqL1xuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi4vVXRpbHMvSGVscGVyXCI7XG5pbXBvcnQgWEhSIGZyb20gXCIuL1hIUlwiO1xuaW1wb3J0IEpTT05QIGZyb20gXCIuL0pTT05QXCI7XG5cbnZhciBQcm90b2NvbCA9IHtcblxuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB1bmlxdWUgZFwiZW52b2kgZFwidW5lIHJlcXXDqnRlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZW5kXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBnZW5lcmFsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgICAgICAtIHVybCBkdSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubWV0aG9kICAgLSBHRVQsIFBPU1QsIFBVVCwgREVMRVRFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvdG9jb2wgLSBYSFIgfCBKU09OUFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZvcm1hdCAgIC0gZm9ybWF0IGRlIGxhIHJlcG9uc2UgZHUgc2VydmljZSA6IGpzb24sIHhtbCBvdSBudWxsIChicnV0ZSkuLi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy53cmFwICAgICAtIGVuY2Fwc3VsZXIgbGEgcmVwb25zZSBkdSBzZXJ2aWNlIGRhbnMgZHUgSlNPTiA6IHRydWV8ZmFsc2UgKHRydWUgcGFyIGRlZmF1dCBzdXIgbGUgcHJvdG9jb2xlIEpTT05QKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrU3VmZml4IC0gc3VmZml4ZSBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayAoSlNPTlAgdW5pcXVlbWVudCkgKGV4OiBzaSBjYWxsYmFja1N1ZmZpeD1cIlwiLCBsYSBmb25jdGlvbiBzJ2FwcGVsbGVyYSBcImNhbGxiYWNrXCIpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltZU91dCAgLSAwIG1zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm5vY2FjaGUgIC0gdHJ1ZXxmYWxzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0aW9ucy5kYXRhICAgICAgICAtIGNvbnRlbnQgKHBvc3QpIG91IHBhcmFtIChnZXQpXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zLmhlYWRlcnMgICAgIC0gKHBvc3QpIGV4LiByZWZlcmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zLmNvbnRlbnQgLSAocG9zdCkgZXguIFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2NvcGUgICAgICAgLSB0aGlzIChUT0RPKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25SZXNwb25zZSAtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbkZhaWx1cmUgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25UaW1lT3V0IC0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcm94eVVybCAtICAoVE9ETylcbiAgICAgKi9cbiAgICBzZW5kIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICAvLyBcIm91dHB1dFwiIC0gcGFyYW0gZXN0IGludGVybmUgw6AgbGEgY2xhc3NlIFwiUHJvdG9jb2xcIiAocGFyYW1ldHJhYmxlIHZpYSBcIndyYXBcIiksIGV0IMOgIGFqb3V0ZXIgw6AgbFwidXJsXG4gICAgICAgIC8vICAgICAgY2UgcGFyYW0gZXN0IGluZGVwZW5kYW50IGR1IHNlcnZpY2UgY2FyIGlsIGVzdCBnw6lyw6kgcGFyIGxlIGZpbHRyZSBMVUEgOlxuICAgICAgICAvLyAgICAgICAgICBleC4ganNvbnx4bWwgKGpzb24gcGFyIGRlZmF1dCkuXG4gICAgICAgIC8vICAgICAgICAgIENlIHBhcmFtLiBwZXJtZXQgZFwiZW5jYXBzdWxlciBkdSBYTUwgZGFucyBkdSBKU09OIDpcbiAgICAgICAgLy8gICAgICAgICAgICAgIHtodHRwIDoge3N0YXR1czoyMDAsIGVycm9yOm51bGx9LHhtbCA6XCJyw6lwb25zZSBkdSBzZXJ2aWNlXCJ9XG4gICAgICAgIC8vICAgICAgICAgIFV0aWxlIHBvdXIgbGVzIHNlcnZpY2VzIHF1aSBuZSByZXBvbmRlbnQgcXVlIGR1IFhNTCAoZXguIEdlb2NvZGFnZSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgIC8vIHwgICAgICBcXHNlcnZpY2UgfCAgICAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgLy8gfCBvdXRwdXRcXCBmb3JtYXR8IGpzb24gfCB4bWwgfCAgICAgcmVtYXJxdWVzICAgICAgfFxuICAgICAgICAvLyB8LS0tLS0tLS1cXC0tLS0tLXwtLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgIC8vIHwgICAganNvbiAgICAgICB8IGpzb24gfCBqc29ufCBqc29uL3htbCBlbmNhcHN1bMOpIHxcbiAgICAgICAgLy8gfCAgICB4bWwgICAgICAgIHwganNvbiB8IHhtbCB8IHBhcmFtIGluYWN0aWYgICAgICB8XG4gICAgICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAvLyBleC4gbGUgc2VydmljZSBkZW1hbmRlIHVuZSByZXBvbnNlIG5hdGl2ZSBhdSBcImZvcm1hdFwiIGpzb24gZXQgYXZlYyB1biBcIm91dHB1dFwiIGpzb24uXG4gICAgICAgIC8vIG9uIGEgZG9uYyB1bmUgcmVwb25zZSBqc29uIGVuY2Fwc3Vsw6kgZGFucyB1biBqc29uIDogY2UgcXUnb24gbmUgc291aGFpdGUgcGFzICFcbiAgICAgICAgLy8gZGFucyBjZSBjYXMgb24gbmUgcmVuc2VpZ25lIHBhcyBvdXRwdXQ9anNvblxuXG4gICAgICAgIC8vIElORk9cbiAgICAgICAgLy8gXCJ3cmFwXCIgLSBjaG9peCBkXCJlbmNhcHN1bGVyIG91IG5vbiBsZXMgcmVwb25zZXMgZGFucyBkdSBKU09OLlxuICAgICAgICAvLyAgICAgIFBhciBkZWZhdXQsIG9uIGVuY2Fwc3VsZSB1bmlxdWVtZW50IGxlcyByZXBvbnNlcyBzdXIgbGUgcHJvdG9jb2xlIEpTT05QIChldCBxdWkgc29udCBlbiB4bWwpICFcblxuICAgICAgICAvLyBJTkZPXG4gICAgICAgIC8vIFwiY2FsbGJhY2tcIiAtIHBhcmFtIGVzdCBpbnRlcm5lIMOgIGxhIGNsYXNzZSBcIlByb3RvY29sXCIgKG5vbiBwYXJhbWV0cmFibGUpLCBldCDDoCBham91dGVyIMOgIGxcInVybFxuICAgICAgICAvLyAgICAgIGNlIHBhcmFtIGVzdCBpbmRlcGVuZGFudCBkdSBzZXJ2aWNlIGNhciBpbCBlc3QgZ8OpcsOpIGF1c3NpIHBhciBsZSBmaWx0cmUgTFVBIDpcbiAgICAgICAgLy8gICAgICAgICAgZXguIGNhbGxiYWNrfG51bGxcbiAgICAgICAgLy8gICAgICAgICAgQ2UgcGFyYW0uIHBlcm1ldCBkZSByZW52b3llciB1bmUgcmVwb25zZSBqYXZhc2NyaXB0IDpcbiAgICAgICAgLy8gICAgICAgICAgICAgIGNhbGxiYWNrICh7aHR0cCA6IHtzdGF0dXM6MjAwLCBlcnJvcjpudWxsfSx4bWwgOlwicsOpcG9uc2UgZHUgc2VydmljZVwifSlcbiAgICAgICAgLy8gICAgICAgICAgQ2UgcGFyYW0uIGVzdCBub24gcmVuc2VpZ27DqSBwYXIgZGVmYXV0IGNhciBwb3VyIGR1IEpTT05QLCBvbiB1dGlsaXNlIGxlXG4gICAgICAgIC8vICAgICAgICAgIGxlIHByb3RvY29sIEpTT05QLCBldCBjZSBkZXJuaWVyIGltcGxlbWVudGUgZMOpasOgIGxlIGNhbGxiYWNrICFcblxuICAgICAgICAvLyBzZXR0aW5ncyBwYXIgZGVmYXV0XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgbWV0aG9kIDogXCJHRVRcIixcbiAgICAgICAgICAgIC8vIHByb3RvY29sIDogXCJKU09OUFwiLFxuICAgICAgICAgICAgcHJvdG9jb2wgOiBcIlhIUlwiLFxuICAgICAgICAgICAgdGltZU91dCA6IDAsXG4gICAgICAgICAgICBmb3JtYXQgOiBudWxsLFxuICAgICAgICAgICAgd3JhcCA6IHRydWUsXG4gICAgICAgICAgICBub2NhY2hlIDogdHJ1ZSxcbiAgICAgICAgICAgIG91dHB1dCA6IFwianNvblwiLFxuICAgICAgICAgICAgY2FsbGJhY2sgOiBudWxsLFxuICAgICAgICAgICAgY2FsbGJhY2tTdWZmaXggOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb24gZGV0ZXJtaW5lIGwnZW52aXJvbm5lbWVudCBkJ2V4ZWN1dGlvbiA6IGJyb3dzZXIgb3Ugbm9uID9cbiAgICAgICAgLy8gZXQgb24gc3RvcHBlIHBvdXIgbm9kZUpTLi4uIHN1ciB1biBwcm90b2NvbGUgSlNPTlAgIVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmFsdWUgKHMpIGZvciBwYXJhbWV0ZXIgKHMpICdwcm90b2NvbD1KU09OUCAoaW5zdGVhZCB1c2UgWEhSKScgbm90IHN1cHBvcnRlZCB0byBOb2RlSlNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PT0gXCJYSFJcIiB8fCBvcHRpb25zLmZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLndyYXAgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIgJiYgb3B0aW9ucy5mb3JtYXQgPT09IFwieG1sXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLndyYXAgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuY2FsbGJhY2sgPSBudWxsOyAvLyBGSVhNRSBub24gZ8OpcsOpICE/XG4gICAgICAgIHNldHRpbmdzLm91dHB1dCA9IHNldHRpbmdzLndyYXAgPyBcImpzb25cIiA6IG51bGw7XG5cbiAgICAgICAgLy8gb24gZW5jYXBzdWxlIGxlcyByZXBvbnNlcyBkYW5zIHVuIG9iamV0IEpTT05cbiAgICAgICAgaWYgKHNldHRpbmdzLndyYXApIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5vdXRwdXQgPSBzZXR0aW5ncy5vdXRwdXQ7XG4gICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2sgPSBzZXR0aW5ncy5jYWxsYmFjaztcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuY2FsbGJhY2s7IC8vIEZJWE1FIG5vbiBnw6lyw6kgIT9cbiAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IEhlbHBlci5ub3JtYWx5emVVcmwob3B0aW9ucy51cmwsIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaG9peCBkZSBsXCJpbXBsZW1lbnRhdGlvbiA6XG4gICAgICAgIC8vIFhIUiBvdSBKU09OUFxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLnByb3RvY29sKSB7XG4gICAgICAgICAgICBjYXNlIFwiWEhSXCI6XG4gICAgICAgICAgICAgICAgLy8gb24gbm9ybWFsaXNlIGwndXJsIChnZXN0aW9uIGR1IGNhY2hlKVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBvcHRpb25zLm5vY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudXJsID0gSGVscGVyLm5vcm1hbHl6ZVVybChzZXR0aW5ncy51cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwZWwgZHUgc2VydmljZSBlbiBYSFJcbiAgICAgICAgICAgICAgICBYSFIuY2FsbChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSlNPTlBcIjpcblxuICAgICAgICAgICAgICAgIC8vIG9uIG5vcm1hbGlzZSBsJ3VybCBzaSBsZXMgcGFyYW1zLiBzb250IHJlbnNlaWduw6lzIGRhbnMgbGEgc3RyaW5nfG9iamVjdCBcImRhdGFcIlxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IEhlbHBlci5ub3JtYWx5emVVcmwoc2V0dGluZ3MudXJsLCBzZXR0aW5ncy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhcHBlbCBkdSBzZXJ2aWNlIGVuIEpTT05QXG4gICAgICAgICAgICAgICAgSlNPTlAuY2FsbChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb3RvY29sIG5vdCBzdXBwb3J0ZWQgKFhIUnxKU09OUCkgIVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvdG9jb2w7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Protocols/Protocol.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/XHR.js":
/*!****************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/XHR.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/Helper */ \"./node_modules/geoportal-access-lib/src/Utils/Helper.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(es6_promise__WEBPACK_IMPORTED_MODULE_2__);\n/* global Promise, require, XDomainRequest */\n\n\n\n\n// import __request from \"request\";\n// import __xmldom from \"xmldom\";\n\n/**\n * Ajax Request (use of Promises)\n *\n * @module XHR\n * @alias Gp.Protocols.XHR\n * @see dependance 'es6-promise'\n */\n\n// cf. https://xhr.spec.whatwg.org/\n// cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\nvar XHR = {\n\n    /**\n     * Interface unique d'envoi d'une requête.\n     *\n     * @method call\n     * @static\n     * @param {Object} settings - options generales\n     * @param {String} settings.url    - url du service\n     * @param {String} settings.method - GET, POST, PUT, DELETE\n     * @param {String} settings.format - format de la reponse du service : json, xml ou null (brute)\n     * @param {String} settings.data   - content (post) ou param (get)\n     * @param {String} settings.proxy  - proxy url\n     * @param {Object|String} settings.headers - (post) ex. referer\n     * @param {Object|String} settings.content - (post) ex. 'application/json'\n     * @param {String} settings.timeOut - timeout = 0 par defaut\n     * @param {String} settings.scope - this\n     * @param {Function} settings.onResponse - callback\n     * @param {Function} settings.onFailure  - callback\n     */\n    call : function (settings) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"XHR\");\n        logger.trace(\"[XHR::call()]\");\n\n        // FIXME\n        // To polyfill the global environment\n        es6_promise__WEBPACK_IMPORTED_MODULE_2___default.a.polyfill();\n\n        // test sur les settings obligatoires\n        if (!settings.url) {\n            throw new Error(\"missing parameter : url is not defined !\");\n        }\n\n        if (!settings.method) {\n            throw new Error(\"missing parameter : method is not defined !\");\n        }\n\n        if (!settings.format) {\n            settings.format = \"text\"; // reponse brute !\n        }\n\n        var options = {};\n        options.url = settings.url;\n        options.data = settings.data ? settings.data : null;\n        options.method = settings.method;\n        options.timeOut = settings.timeOut || 0;\n        options.scope = settings.scope || this;\n        options.proxy = settings.proxy || null;\n        options.content = settings.content || null;\n        options.headers = settings.headers || {\n            referer : \"http://localhost\"\n        };\n\n        // test sur les valeurs de 'settings.method'\n        switch (settings.method) {\n            case \"DELETE\":\n            case \"GET\":\n                break;\n            case \"PUT\":\n            case \"POST\":\n                // on force sur ces params spécifiques au mode POST\n                options.content = settings.content ? settings.content : \"application/x-www-form-urlencoded\"; // FIXME en attente des services : bascule en \"application/xml\" ou \"application/json\"\n                options.headers = settings.headers ? settings.headers : { referer : \"http://localhost\" }; // FIXME parametrable...\n                break;\n            case \"HEAD\":\n            case \"OPTIONS\":\n                throw new Error(\"HTTP method not yet supported !\");\n            default:\n                throw new Error(\"HTTP method unknown !\");\n        }\n\n        // test sur les valeurs de 'settings.format'\n        switch (settings.format) {\n            case \"text\":\n                this.__call(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            case \"json\":\n                this.__callJSON(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            case \"xml\":\n                this.__callXML(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            default:\n                throw new Error(\"This output Format is not yet supported !\");\n        }\n    },\n\n    /**\n     * Requete\n     *\n     * @method __call\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __call : function (options) {\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"XHR\");\n        logger.trace(\"[XHR::__call()]\");\n\n        var promise = new Promise(\n            function (resolve, reject) {\n                // traitement du corps de la requête\n                var corps = (options.method === \"POST\" || options.method === \"PUT\") ? 1 : 0;\n\n                // seulement si options.data n'est pas vide (peut être un objet ou une chaine de caractères)\n                if (options.data && ((typeof options.data === \"object\" && Object.keys(options.data).length) || (typeof options.data === \"string\" && options.data.length)) && !corps) {\n                    if (options.scope.CLASSNAME === \"Geocode\" || options.scope.CLASSNAME === \"ReverseGeocode\") {\n                        options.url = options.url + options.data;\n                    } else {\n                        options.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(options.url, options.data);\n                    }\n                }\n\n                logger.trace(\"URL = \", options.url);\n\n                var hXHR = null;\n\n                // test on env. nodejs or browser\n                if (typeof window === \"undefined\") {\n                    var nodefetch = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n\n                    var opts = {\n                        headers : {\n                            Referer : \"https://localhost\"\n                        }\n                    };\n\n                    if (options.data && typeof options.data === \"string\" && corps) {\n                        opts = {\n                            method : options.method,\n                            body : options.data,\n                            headers : {\n                                \"Content-Type\" : options.content,\n                                Referer : \"https://localhost\"\n                            }\n                        };\n                    }\n\n                    return nodefetch(options.url, opts)\n                        .then(function (response) {\n                            if (response.ok) { // res.status >= 200 && res.status < 300\n                                resolve(response.text());\n                            } else {\n                                var message = \"Errors Occured on Http Request (status : '\" + response.statusText + \"' | url : '\" + response.url + \"')\";\n                                var status = response.status;\n                                reject({\n                                    message : message,\n                                    status : status\n                                });\n                            }\n                        })\n                        .catch(function (e) {\n                            reject({\n                                message : e,\n                                status : -1\n                            });\n                        });\n                } else {\n                    if (window.XMLHttpRequest) {\n                        logger.trace(\"XMLHttpRequest\");\n\n                        hXHR = new XMLHttpRequest();\n                        hXHR.open(options.method, options.url, true); // async\n                        hXHR.overrideMimeType = options.content;\n\n                        // gestion du timeout\n                        var onTimeOutTrigger = null;\n                        if (options.timeOut > 0) {\n                            // FIXME le timeout interne ne me permet pas de declencher le bon message...\n                            // hXHR.timeout = options.timeOut;\n                            logger.trace(\"XHR - TimeOut actif !\");\n                            /**\n                             * Description\n                             *\n                             * @method onTimeOutTrigger\n                             * @private\n                             */\n                            onTimeOutTrigger = window.setTimeout(\n                                function () {\n                                    var message = \"TimeOut Occured on Http Request with XMLHttpRequest !\";\n                                    reject({\n                                        message : message,\n                                        status : -1\n                                    });\n                                }, options.timeOut);\n                        }\n\n                        if (corps) {\n                            // headers, data, content of data\n                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader\n                            logger.trace(\"data = \", options.data);\n                            hXHR.setRequestHeader(\"Content-type\", options.content);\n                            // FIXME refused to set unsafe header content-length javascript\n                            // hXHR.setRequestHeader (\"Content-length\", options.data.length);\n                            // hXHR.setRequestHeader (\"Referer\", options.headers.referer);\n                        }\n\n                        /**\n                         * On Error\n                         * FIXME ne se declenche pas !?\n                         *\n                         * @param {Object} e - Event\n                         * @method onerror\n                         * @private\n                         */\n                        hXHR.onerror = function (e) {\n                            console.log(e);\n                            reject(new Error(\"Errors Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * On Timeout\n                         * FIXME ne se declenche pas !?\n                         *\n                         * @param {Object} e - Event\n                         * @method ontimeout\n                         * @private\n                         */\n                        hXHR.ontimeout = function (e) {\n                            console.log(e);\n                            reject(new Error(\"TimeOut Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * Description\n                         *\n                         * @method onreadystatechange\n                         * @private\n                         */\n                        hXHR.onreadystatechange = function (e) {\n                            if (hXHR.readyState === 4) { // DONE\n                                if (hXHR.status === 200) {\n                                    window.clearTimeout(onTimeOutTrigger);\n                                    resolve(hXHR.response);\n                                } else {\n                                    var message = \"Errors Occured on Http Request (status : '\" + e.target.statusText + \"' | url : '\" + e.target.responseURL + \"' | response : '\" + e.target.response + \"')\";\n                                    var status = e.target.status;\n                                    reject({\n                                        message : message,\n                                        status : status\n                                    });\n                                }\n                            }\n                        };\n\n                        // gestion du content data\n                        var data4xhr = (options.data && corps) ? options.data : null;\n\n                        hXHR.send(data4xhr);\n                    } else if (window.XDomainRequest) {\n                        // worked in Internet Explorer 8–10 only !\n                        logger.trace(\"XDomainRequest\");\n\n                        hXHR = new XDomainRequest();\n                        hXHR.open(options.method, options.url);\n\n                        hXHR.overrideMimeType = options.content;\n\n                        if (options.timeOut > 0) {\n                            hXHR.timeout = options.timeout;\n                            logger.trace(\"XHR - TimeOut actif !\");\n                        }\n\n                        if (corps) {\n                            // headers, data, content of data\n                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader\n                            hXHR.setRequestHeader(\"Content-type\", options.content);\n                            // FIXME refused to set unsafe header content-length javascript\n                            // hXHR.setRequestHeader (\"Content-length\", options.data.length);\n                            // hXHR.setRequestHeader (\"Referer\", options.headers.referer);\n                        }\n\n                        /**\n                         * Description\n                         *\n                         * @method onerror\n                         * @private\n                         */\n                        hXHR.onerror = function () {\n                            reject(new Error(\"Errors Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * Description\n                         *\n                         * @method ontimeout\n                         * @private\n                         */\n                        hXHR.ontimeout = function () {\n                            reject(new Error(\"TimeOut Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * On Load\n                         *\n                         * @method onload\n                         * @private\n                         */\n                        hXHR.onload = function (e) {\n                            if (hXHR.status === 200) {\n                                resolve(hXHR.responseText);\n                            } else {\n                                var message = \"Errors Occured on Http Request (status : '\" + e.target.statusText + \"' | url : '\" + e.target.responseURL + \"')\";\n                                var status = e.target.status;\n                                reject({\n                                    message : message,\n                                    status : status\n                                });\n                            }\n                        };\n\n                        var data4xdr = (options.data && corps) ? options.data : null;\n\n                        hXHR.send(data4xdr);\n                    } else {\n                        throw new Error(\"CORS not supported\");\n                    }\n                }\n            }\n        );\n\n        return promise;\n    },\n\n    /**\n     * Requete avec parser JSON\n     *\n     * @method __callJSON\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __callJSON : function (options) {\n        return this.__call(options)\n            .then(JSON.parse)\n            .catch(function (error) {\n                console.log(\"_callJSON failed on : \", options.url, error);\n                // FIXME pas d'exception, laissons le fil se derouler...\n                // throw error;\n            });\n    },\n\n    /**\n     * Requete avec parser XML\n     *\n     * @method __callXML\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __callXML : function (options) {\n        return this.__call(options)\n            .then(function (response) {\n                var xmlDoc;\n\n                // test on env. nodejs or browser\n                if (typeof window === \"undefined\") {\n                    var DOMParser = __webpack_require__(/*! xmldom */ \"xmldom\").DOMParser; // __xmldom.DOMParser\n                    xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n                } else {\n                    if (window.DOMParser) {\n                        var parser = new window.DOMParser();\n                        xmlDoc = parser.parseFromString(response, \"text/xml\");\n                    } else { // IE\n                        xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n                        xmlDoc.async = false;\n                        xmlDoc.loadXML(response);\n                    }\n                }\n\n                return xmlDoc;\n            })\n            .catch(function (error) {\n                console.log(\"__callXML failed on : \", options.url, error);\n                // FIXME pas d'exception, laissons le fil se derouler...\n                // throw error;\n            });\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (XHR);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9YSFIuanM/MGM1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRThDO0FBQ1Q7QUFDQTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBTTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxrREFBVTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1Ryx5RUFBeUUsZ0NBQWdDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtB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QUVBOztBQUVlLGtFQUFHLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9YSFIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgUHJvbWlzZSwgcmVxdWlyZSwgWERvbWFpblJlcXVlc3QgKi9cblxuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgSGVscGVyIGZyb20gXCIuLi9VdGlscy9IZWxwZXJcIjtcbmltcG9ydCBFUzZQcm9taXNlIGZyb20gXCJlczYtcHJvbWlzZVwiO1xuLy8gaW1wb3J0IF9fcmVxdWVzdCBmcm9tIFwicmVxdWVzdFwiO1xuLy8gaW1wb3J0IF9feG1sZG9tIGZyb20gXCJ4bWxkb21cIjtcblxuLyoqXG4gKiBBamF4IFJlcXVlc3QgKHVzZSBvZiBQcm9taXNlcylcbiAqXG4gKiBAbW9kdWxlIFhIUlxuICogQGFsaWFzIEdwLlByb3RvY29scy5YSFJcbiAqIEBzZWUgZGVwZW5kYW5jZSAnZXM2LXByb21pc2UnXG4gKi9cblxuLy8gY2YuIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy9cbi8vIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3RcblxudmFyIFhIUiA9IHtcblxuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB1bmlxdWUgZCdlbnZvaSBkJ3VuZSByZXF1w6p0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2FsbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgLSBvcHRpb25zIGdlbmVyYWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy51cmwgICAgLSB1cmwgZHUgc2VydmljZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5tZXRob2QgLSBHRVQsIFBPU1QsIFBVVCwgREVMRVRFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmZvcm1hdCAtIGZvcm1hdCBkZSBsYSByZXBvbnNlIGR1IHNlcnZpY2UgOiBqc29uLCB4bWwgb3UgbnVsbCAoYnJ1dGUpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmRhdGEgICAtIGNvbnRlbnQgKHBvc3QpIG91IHBhcmFtIChnZXQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnByb3h5ICAtIHByb3h5IHVybFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2V0dGluZ3MuaGVhZGVycyAtIChwb3N0KSBleC4gcmVmZXJlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2V0dGluZ3MuY29udGVudCAtIChwb3N0KSBleC4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnRpbWVPdXQgLSB0aW1lb3V0ID0gMCBwYXIgZGVmYXV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnNjb3BlIC0gdGhpc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm9uUmVzcG9uc2UgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm9uRmFpbHVyZSAgLSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNhbGwgOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiWEhSXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJbWEhSOjpjYWxsKCldXCIpO1xuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIFRvIHBvbHlmaWxsIHRoZSBnbG9iYWwgZW52aXJvbm1lbnRcbiAgICAgICAgRVM2UHJvbWlzZS5wb2x5ZmlsbCgpO1xuXG4gICAgICAgIC8vIHRlc3Qgc3VyIGxlcyBzZXR0aW5ncyBvYmxpZ2F0b2lyZXNcbiAgICAgICAgaWYgKCFzZXR0aW5ncy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogdXJsIGlzIG5vdCBkZWZpbmVkICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNldHRpbmdzLm1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwYXJhbWV0ZXIgOiBtZXRob2QgaXMgbm90IGRlZmluZWQgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2V0dGluZ3MuZm9ybWF0KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5mb3JtYXQgPSBcInRleHRcIjsgLy8gcmVwb25zZSBicnV0ZSAhXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgb3B0aW9ucy5kYXRhID0gc2V0dGluZ3MuZGF0YSA/IHNldHRpbmdzLmRhdGEgOiBudWxsO1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IHNldHRpbmdzLm1ldGhvZDtcbiAgICAgICAgb3B0aW9ucy50aW1lT3V0ID0gc2V0dGluZ3MudGltZU91dCB8fCAwO1xuICAgICAgICBvcHRpb25zLnNjb3BlID0gc2V0dGluZ3Muc2NvcGUgfHwgdGhpcztcbiAgICAgICAgb3B0aW9ucy5wcm94eSA9IHNldHRpbmdzLnByb3h5IHx8IG51bGw7XG4gICAgICAgIG9wdGlvbnMuY29udGVudCA9IHNldHRpbmdzLmNvbnRlbnQgfHwgbnVsbDtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycyB8fCB7XG4gICAgICAgICAgICByZWZlcmVyIDogXCJodHRwOi8vbG9jYWxob3N0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0ZXN0IHN1ciBsZXMgdmFsZXVycyBkZSAnc2V0dGluZ3MubWV0aG9kJ1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcIkRFTEVURVwiOlxuICAgICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICAgICAgY2FzZSBcIlBPU1RcIjpcbiAgICAgICAgICAgICAgICAvLyBvbiBmb3JjZSBzdXIgY2VzIHBhcmFtcyBzcMOpY2lmaXF1ZXMgYXUgbW9kZSBQT1NUXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50ID0gc2V0dGluZ3MuY29udGVudCA/IHNldHRpbmdzLmNvbnRlbnQgOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiOyAvLyBGSVhNRSBlbiBhdHRlbnRlIGRlcyBzZXJ2aWNlcyA6IGJhc2N1bGUgZW4gXCJhcHBsaWNhdGlvbi94bWxcIiBvdSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHNldHRpbmdzLmhlYWRlcnMgPyBzZXR0aW5ncy5oZWFkZXJzIDogeyByZWZlcmVyIDogXCJodHRwOi8vbG9jYWxob3N0XCIgfTsgLy8gRklYTUUgcGFyYW1ldHJhYmxlLi4uXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSEVBRFwiOlxuICAgICAgICAgICAgY2FzZSBcIk9QVElPTlNcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIVFRQIG1ldGhvZCBub3QgeWV0IHN1cHBvcnRlZCAhXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIVFRQIG1ldGhvZCB1bmtub3duICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXN0IHN1ciBsZXMgdmFsZXVycyBkZSAnc2V0dGluZ3MuZm9ybWF0J1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FsbChvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblJlc3BvbnNlLmNhbGwodGhpcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbkZhaWx1cmUuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FsbEpTT04ob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25SZXNwb25zZS5jYWxsKHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25GYWlsdXJlLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ4bWxcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FsbFhNTChvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblJlc3BvbnNlLmNhbGwodGhpcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbkZhaWx1cmUuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG91dHB1dCBGb3JtYXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgIVwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXRlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9fY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvbWlzZVxuICAgICAqL1xuICAgIF9fY2FsbCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiWEhSXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJbWEhSOjpfX2NhbGwoKV1cIik7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmFpdGVtZW50IGR1IGNvcnBzIGRlIGxhIHJlcXXDqnRlXG4gICAgICAgICAgICAgICAgdmFyIGNvcnBzID0gKG9wdGlvbnMubWV0aG9kID09PSBcIlBPU1RcIiB8fCBvcHRpb25zLm1ldGhvZCA9PT0gXCJQVVRcIikgPyAxIDogMDtcblxuICAgICAgICAgICAgICAgIC8vIHNldWxlbWVudCBzaSBvcHRpb25zLmRhdGEgbidlc3QgcGFzIHZpZGUgKHBldXQgw6p0cmUgdW4gb2JqZXQgb3UgdW5lIGNoYWluZSBkZSBjYXJhY3TDqHJlcylcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhICYmICgodHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhvcHRpb25zLmRhdGEpLmxlbmd0aCkgfHwgKHR5cGVvZiBvcHRpb25zLmRhdGEgPT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5kYXRhLmxlbmd0aCkpICYmICFjb3Jwcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zY29wZS5DTEFTU05BTUUgPT09IFwiR2VvY29kZVwiIHx8IG9wdGlvbnMuc2NvcGUuQ0xBU1NOQU1FID09PSBcIlJldmVyc2VHZW9jb2RlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBvcHRpb25zLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IEhlbHBlci5ub3JtYWx5emVVcmwob3B0aW9ucy51cmwsIG9wdGlvbnMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJVUkwgPSBcIiwgb3B0aW9ucy51cmwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhYSFIgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBvbiBlbnYuIG5vZGVqcyBvciBicm93c2VyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVmZXRjaCA9IHJlcXVpcmUoXCJub2RlLWZldGNoXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWZlcmVyIDogXCJodHRwczovL2xvY2FsaG9zdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiB0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSBcInN0cmluZ1wiICYmIGNvcnBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIiA6IG9wdGlvbnMuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVmZXJlciA6IFwiaHR0cHM6Ly9sb2NhbGhvc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZWZldGNoKG9wdGlvbnMudXJsLCBvcHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7IC8vIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJFcnJvcnMgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3QgKHN0YXR1cyA6ICdcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQgKyBcIicgfCB1cmwgOiAnXCIgKyByZXNwb25zZS51cmwgKyBcIicpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJYTUxIdHRwUmVxdWVzdFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUiA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCwgdHJ1ZSk7IC8vIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm92ZXJyaWRlTWltZVR5cGUgPSBvcHRpb25zLmNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdlc3Rpb24gZHUgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uVGltZU91dFRyaWdnZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZU91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBsZSB0aW1lb3V0IGludGVybmUgbmUgbWUgcGVybWV0IHBhcyBkZSBkZWNsZW5jaGVyIGxlIGJvbiBtZXNzYWdlLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaFhIUi50aW1lb3V0ID0gb3B0aW9ucy50aW1lT3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlhIUiAtIFRpbWVPdXQgYWN0aWYgIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1ldGhvZCBvblRpbWVPdXRUcmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblRpbWVPdXRUcmlnZ2VyID0gd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJUaW1lT3V0IE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IHdpdGggWE1MSHR0cFJlcXVlc3QgIVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3Jwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlYWRlcnMsIGRhdGEsIGNvbnRlbnQgb2YgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNmLiBodHRwczovL2R2Y3MudzMub3JnL2hnL3hoci9yYXctZmlsZS90aXAvT3ZlcnZpZXcuaHRtbCNkb20teG1saHR0cHJlcXVlc3Qtc2V0cmVxdWVzdGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImRhdGEgPSBcIiwgb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgb3B0aW9ucy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSByZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIGNvbnRlbnQtbGVuZ3RoIGphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoWEhSLnNldFJlcXVlc3RIZWFkZXIgKFwiQ29udGVudC1sZW5ndGhcIiwgb3B0aW9ucy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaFhIUi5zZXRSZXF1ZXN0SGVhZGVyIChcIlJlZmVyZXJcIiwgb3B0aW9ucy5oZWFkZXJzLnJlZmVyZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIE9uIEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGSVhNRSBuZSBzZSBkZWNsZW5jaGUgcGFzICE/XG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1ldGhvZCBvbmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvcnMgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogT24gVGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICogRklYTUUgbmUgc2UgZGVjbGVuY2hlIHBhcyAhP1xuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb250aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9udGltZW91dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVPdXQgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoWEhSLnJlYWR5U3RhdGUgPT09IDQpIHsgLy8gRE9ORVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaFhIUi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChvblRpbWVPdXRUcmlnZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaFhIUi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXJyb3JzIE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IChzdGF0dXMgOiAnXCIgKyBlLnRhcmdldC5zdGF0dXNUZXh0ICsgXCInIHwgdXJsIDogJ1wiICsgZS50YXJnZXQucmVzcG9uc2VVUkwgKyBcIicgfCByZXNwb25zZSA6ICdcIiArIGUudGFyZ2V0LnJlc3BvbnNlICsgXCInKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGUudGFyZ2V0LnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdlc3Rpb24gZHUgY29udGVudCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YTR4aHIgPSAob3B0aW9ucy5kYXRhICYmIGNvcnBzKSA/IG9wdGlvbnMuZGF0YSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIuc2VuZChkYXRhNHhocik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOOKAkzEwIG9ubHkgIVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiWERvbWFpblJlcXVlc3RcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIub3BlbihvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm92ZXJyaWRlTWltZVR5cGUgPSBvcHRpb25zLmNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlhIUiAtIFRpbWVPdXQgYWN0aWYgIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVycywgZGF0YSwgY29udGVudCBvZiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vZHZjcy53My5vcmcvaGcveGhyL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2RvbS14bWxodHRwcmVxdWVzdC1zZXRyZXF1ZXN0aGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIG9wdGlvbnMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgcmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBjb250ZW50LWxlbmd0aCBqYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaFhIUi5zZXRSZXF1ZXN0SGVhZGVyIChcIkNvbnRlbnQtbGVuZ3RoXCIsIG9wdGlvbnMuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhYSFIuc2V0UmVxdWVzdEhlYWRlciAoXCJSZWZlcmVyXCIsIG9wdGlvbnMuaGVhZGVycy5yZWZlcmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb25lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvcnMgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIG9udGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVPdXQgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogT24gTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb25sb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhYSFIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShoWEhSLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkVycm9ycyBPY2N1cmVkIG9uIEh0dHAgUmVxdWVzdCAoc3RhdHVzIDogJ1wiICsgZS50YXJnZXQuc3RhdHVzVGV4dCArIFwiJyB8IHVybCA6ICdcIiArIGUudGFyZ2V0LnJlc3BvbnNlVVJMICsgXCInKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gZS50YXJnZXQuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGE0eGRyID0gKG9wdGlvbnMuZGF0YSAmJiBjb3JwcykgPyBvcHRpb25zLmRhdGEgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLnNlbmQoZGF0YTR4ZHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ09SUyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXRlIGF2ZWMgcGFyc2VyIEpTT05cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX19jYWxsSlNPTlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvbWlzZVxuICAgICAqL1xuICAgIF9fY2FsbEpTT04gOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhbGwob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKEpTT04ucGFyc2UpXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJfY2FsbEpTT04gZmFpbGVkIG9uIDogXCIsIG9wdGlvbnMudXJsLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgcGFzIGQnZXhjZXB0aW9uLCBsYWlzc29ucyBsZSBmaWwgc2UgZGVyb3VsZXIuLi5cbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXRlIGF2ZWMgcGFyc2VyIFhNTFxuICAgICAqXG4gICAgICogQG1ldGhvZCBfX2NhbGxYTUxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHByb21pc2VcbiAgICAgKi9cbiAgICBfX2NhbGxYTUwgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhbGwob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciB4bWxEb2M7XG5cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IG9uIGVudi4gbm9kZWpzIG9yIGJyb3dzZXJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRE9NUGFyc2VyID0gcmVxdWlyZShcInhtbGRvbVwiKS5ET01QYXJzZXI7IC8vIF9feG1sZG9tLkRPTVBhcnNlclxuICAgICAgICAgICAgICAgICAgICB4bWxEb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHJlc3BvbnNlLCBcInRleHQveG1sXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcocmVzcG9uc2UsIFwidGV4dC94bWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIElFXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxEb2MgPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sRG9jLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxEb2MubG9hZFhNTChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIl9fY2FsbFhNTCBmYWlsZWQgb24gOiBcIiwgb3B0aW9ucy51cmwsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBwYXMgZCdleGNlcHRpb24sIGxhaXNzb25zIGxlIGZpbCBzZSBkZXJvdWxlci4uLlxuICAgICAgICAgICAgICAgIC8vIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBYSFI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Protocols/XHR.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/CommonService.js":
/*!*************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/CommonService.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/Helper */ \"./node_modules/geoportal-access-lib/src/Utils/Helper.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Protocols/Protocol */ \"./node_modules/geoportal-access-lib/src/Protocols/Protocol.js\");\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DefaultUrlService */ \"./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js\");\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../package.json */ \"./node_modules/geoportal-access-lib/package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_6___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../package.json */ \"./node_modules/geoportal-access-lib/package.json\", 1);\n\n\n\n\n\n\n// package.json (extract version)\n\n\n/**\n * @classdesc\n * Composant Service\n *\n * @constructor\n * @alias Gp.Services.CommonService\n * @param {Object} options - options communes à tous les services\n *\n * @param {String} options.apiKey - Clef d'accès à la plateforme Géoportail,\n *      nécessaire pour franchir la couche de contrôle des accès pour avoir une réponse du service invoqué.\n *      Plusieurs clefs peuvent être passées dans le cas de l'invocation du service d'autoconfiguration.\n *      Si ce paramètre n'est pas renseigné, alors le paramètre serverUrl doit être renseigné (comprenant alors, si nécessaire la clef API).\n *\n * @param {String} options.serverUrl - URL d'accès au service.\n *      Permet de forcer l'utilisation d'un service équivalent déployé derrière une éventuelle autre URL d'accès.\n *      Si ce paramètre est renseigné alors, le paramètre apiKey est ignoré.\n *\n * @param {String} [options.protocol] - Le protocole à utiliser pour récupérer les informations du service :\n *      peut valoir 'JSONP' ou 'XHR'.\n *      Par défaut, c'est le protocole XHR qui sera utilisé.\n *      Attention, le protocole JSONP n'est pas valide dans un environnement NodeJS (Utilisation du mode XHR).\n *\n * @param {Boolean} [options.ssl] - Indique si l'on souhaite intérroger les services en https.\n *      Ce paramètre ne fonctionne que pour une utilisation hors navigateur (ex. NodeJS).\n *      Sur un navigateur, le protocole est automatiquement extrait de l'url du site...\n *      Par défaut, on utilise le protocole http (ssl=false).\n *\n * @param {String} [options.proxyURL] - Le proxy à utiliser pour pallier au problème de cross-domain dans le cas d'une requête XHR.\n *      Utile si le paramètre 'protocol' vaut 'XHR', il ne sera pas pris en compte si protocol vaut JSONP.\n *\n * @param {String} [options.callbackSuffix] - Suffixe de la fonction de callback à utiliser, dans le cas du protocole JSONP.\n *      Par défaut, la fonction de callback portera un nom du type \"callback\"+ID, où ID est soit un identifiant unique généré à chaque requête,\n *      soit le paramètre callbackSuffix s'il est spécifié. Par exemple, si callbackSuffix=\"_2\", la fonction sera \"callback_2 ()\".\n *      Utile pour utiliser une réponse déjà encapsulée dans une fonction de callback, dont le nom est connu (ex : chargement de l'autoconfiguration en local)\n *      Utile seulement si le paramètre 'protocol' vaut 'JSONP', il ne sera pas pris en compte si protocol vaut 'XHR'.\n *\n * @param {String} [options.httpMethod] - La méthode HTTP\n *      à utiliser dans le cas d'une requête XHR : peut valoir 'GET' ou 'POST'.\n *      Non pris en compte si 'protocol' vaut JSONP qui fonctionne obligatoirement en GET.\n *      Par défaut, c'est la méthode GET qui est utilisée.\n *\n * @param {String} [options.contentType] - Content-Type de la requete\n *      à utiliser dans le cas d'une requête XHR en mode POST.\n *      Non pris en compte si 'protocol' vaut JSONP et/ou la méthode HTTP vaut GET.\n *      Par défaut, c'est la méthode GET qui est utilisée donc on n'utilise pas de Content-Type.\n *\n * @param {Number} [options.timeOut] - Délai d'attente maximal (en ms) de la réponse du service (à partir de l'envoi de la requête).\n *      Par défaut, aucun timeOut n'est pris en compte (timeoutDelay= 0).\n *\n * @param {Boolean} [options.rawResponse] - Indique si l'on souhaite que la réponse du service ne soit pas parsée par l'API avant d'être restituée.\n *      (Cf. paramètre « onSuccess » pour plus de détails).\n *\n * @param {Function} [options.onSuccess] - Fonction appelée lorsque le service répond correctement à la requête\n *      (code HTTP 200, sans message d'erreur).\n *      Cette fonction prend en paramètre la réponse du service,\n *      soit sous la forme d'un Object Javascript formaté par le parseur dédié à la syntaxe du service (comportement par défaut) ;\n *      soit brute au format String non prétraité si le paramètre « rawResponse » a été précisé avec la valeur « true ».\n *\n * @param {Function} [options.onFailure] - Fonction appelée lorsque le service ne répond pas correctement\n *      (code HTTP de retour différent de 200 ou pas de réponse).\n *\n * @param {Function} [options.onBeforeParse] - Fonction appelée avant le parsing de la réponse\n *      Permet de modifier la réponse avant parsing et la fonction doit retourner une String.\n *      Cette fonction prend en paramètre la réponse telle que renvoyée par le service\n *      (cad au format json ou xml).\n *      Pour le JSONP, si le paramètre \"rawResponse\" a été précisé avec la valeur \"true\",\n *      la fonction prend en paramètre un Object JavaScript contenant la réponse XML.\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      ssl : false,\n *      proxyURL : null,\n *      callbackName : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      onBeforeParse : function (rawResponse) {}\n *   };\n * @private\n */\nfunction CommonService (options) {\n    if (!(this instanceof CommonService)) {\n        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"CLASS_CONSTRUCTOR\"));\n    }\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"CommonService\");\n    this.logger.trace(\"[Constructeur CommonService (options)]\");\n\n    // #####################\n    // récupération des options par défaut pour les paramètres optionnels\n    // #####################\n\n    /**\n     * Options du service\n     * @type {Object}\n     */\n    this.options = {\n        // protocol : \"JSONP\",\n        protocol : \"XHR\",\n        ssl : true,\n        proxyURL : \"\",\n        // callbackName : \"\",\n        callbackSuffix : null,\n        httpMethod : \"GET\",\n        timeOut : 0,\n        rawResponse : false,\n        scope : this,\n        /**\n        * callback par defaut pour la reponse\n        * @param {Object} response - response\n        * @private\n        */\n        onSuccess : function (response) {\n            console.log(\"onSuccess - la reponse est la suivante : \", response);\n        },\n        /**\n        * callback par defaut pour les erreurs\n        * @param {Object} error - error\n        * @private\n        */\n        onFailure : function (error) {\n            if (error.status === 200 || !error.status) {\n                console.log(\"onFailure : \", error.message);\n            } else {\n                console.log(\"onFailure - Erreur (\", error.status, \") : \", error.message);\n            }\n        }\n    };\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n\n    // #####################\n    // analyse des options\n    // #####################\n\n    // gestion des clefs API\n    if (!this.options.apiKey && !this.options.serverUrl) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_MISSING\", \"apiKey\", \"serverUrl\"));\n    }\n\n    // modification de la fonction de callback onSuccess dans le cas où la réponse brute est demandée\n    if (this.options.rawResponse && !this.options.onSuccess) {\n        /**\n        * callback par defaut pour la reponse\n        * @param {Object} response - response\n        * @private\n        */\n        this.options.onSuccess = function (response) {\n            console.log(\"onSuccess - la réponse brute du service est la suivante : \", response);\n        };\n    }\n\n    // gestion du callback onSuccess\n    var bOnSuccess = !!(this.options.onSuccess !== null && typeof this.options.onSuccess === \"function\");\n    if (!bOnSuccess) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_MISSING\", \"onSuccess()\"));\n    }\n\n    // gestion de l'url du service par defaut\n    if (!this.options.serverUrl) {\n        // INFO\n        // gestion de l'url du service par defaut pour les services qui ne possèdent qu'une seul url par defaut\n        // les cas particuliers des services avec plusieurs urls (ex. Alti) devront être traité dans la classe du composant\n        // donc si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n        _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ssl = this.options.ssl;\n        var urlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__[\"default\"][this.CLASSNAME].url(this.options.apiKey);\n        if (typeof urlByDefault === \"string\") {\n            this.options.serverUrl = urlByDefault;\n        } else {\n            this.logger.trace(\"URL par defaut à determiner au niveau du composant...\");\n        }\n    }\n\n    // FIXME nettoyage des KVP dans l'url du service\n    // if (this.options.serverUrl) {\n    //     // INFO\n    //     // si l'url est renseignée, il faut la nettoyer de tous ses KVP\n    //     // ex. on ne veut pas de params. 'callback' ou 'output' car ceci declencherait\n    //     // des opérations d'encapsulations des reponses légèrement farfelues ...\n    //     var urlsource = this.options.serverUrl;\n    //     var urlparts = urlsource.split(\"?\");\n    //     this.options.serverUrl = urlparts[0];\n    // }\n\n    // gestion de la methode HTTP\n    this.options.httpMethod = (typeof options.httpMethod === \"string\") ? options.httpMethod.toUpperCase() : \"GET\";\n\n    switch (this.options.httpMethod) {\n        case \"POST\":\n        case \"GET\":\n            break;\n        case \"PUT\":\n        case \"DELETE\":\n        case \"HEAD\":\n        case \"OPTIONS\":\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_NOT_SUPPORT\", \"httpMethod\"));\n        default:\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_UNKNOWN\", \"httpMethod\"));\n    }\n\n    // gestion du protocole\n    // this.options.protocol = (typeof options.protocol === \"string\" ) ? options.protocol.toUpperCase() : \"JSONP\";\n    this.options.protocol = (typeof options.protocol === \"string\") ? options.protocol.toUpperCase() : \"XHR\";\n\n    switch (this.options.protocol) {\n        case \"JSONP\":\n        case \"XHR\":\n            break;\n        default:\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_UNKNOWN\", \"protocol\"));\n    }\n\n    // on determine l'environnement d'execution : browser ou non ?\n    // et on lance une exception sur l'utilisation du protocole JSONP pour nodeJS...\n    if (typeof window === \"undefined\" && this.options.protocol === \"JSONP\") {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_NOT_SUPPORT_NODEJS\", \"protocol=JSONP (instead use XHR)\"));\n    }\n\n    // le protocole JSONP ne fonctionne qu'en GET.\n    if (this.options.protocol === \"JSONP\") {\n        this.options.httpMethod = \"GET\";\n    }\n\n    // gestion du cache\n    this.options.nocache = options.nocache || false;\n\n    // #####################\n    // attributs d'instances\n    // #####################\n\n    /**\n     * Format de réponse du service\n     */\n    this.options.outputFormat = null;\n    /**\n     * Requête envoyée au service\n     */\n    this.request = null;\n    /**\n     * Reponse du service\n     */\n    this.response = null;\n}\n\n/**\n * @lends module:CommonService\n */\nCommonService.prototype = {\n\n    /*\n     * Constructeur (alias)\n     */\n    constructor : CommonService,\n\n    /**\n     * Appel du service Géoportail\n     */\n    call : function () {\n        /* jshint validthis : true */\n        this.logger.trace(\"CommonService::call ()\");\n\n        var context = this;\n        /** fonction d'execution */\n        function run () {\n            this.logger.trace(\"CommonService::run ()\");\n            this.buildRequest.call(context, onError, onBuildRequest);\n        }\n\n        run.call(context);\n\n        // callback de fin de construction de la requête\n        function onBuildRequest (result) {\n            this.logger.trace(\"CommonService::onBuildRequest : \", result);\n            this.callService.call(context, onError, onCallService);\n        }\n\n        // callback de fin d'appel au service\n        function onCallService (result) {\n            this.logger.trace(\"CommonService::onCallService : \", result);\n            this.analyzeResponse.call(context, onError, onAnalyzeResponse);\n        }\n\n        // callback de fin de lecture de la reponse\n        function onAnalyzeResponse (result) {\n            this.logger.trace(\"CommonService::onAnalyzeResponse : \", result);\n            if (result) {\n                this.options.onSuccess.call(this, result);\n            } else {\n                return onError.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"Analyse de la reponse en échec !?\"));\n            }\n        }\n\n        // callback de gestion des erreurs : renvoit un objet de type ErrorService\n        function onError (error) {\n            this.logger.trace(\"CommonService::onError()\");\n            // error : l'objet est du type ErrorService ou Error\n            var e = error;\n            if (!(e instanceof _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"])) {\n                e = new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](error.message);\n            }\n            this.options.onFailure.call(this, e);\n        }\n    },\n\n    /**\n     * Création de la requête\n     * @param {Function} error - callback\n     * @param {Function} success - callback\n     */\n    buildRequest : function (error, success) {\n        // INFO\n        this.logger.error(\"overwritten method !\");\n        // retourne l'objet 'this.request'\n        if (error) {\n            error.call(this, \"This method must be overwritten !\");\n        }\n        success.call(this, \"This method must be overwritten !\");\n    },\n\n    /**\n     * Appel du service\n     * @param {Function} error - callback\n     * @param {Function} success - callback\n     */\n    callService : function (error, success) {\n        // INFO\n        // retourne l'objet 'this.response'\n\n        // NOTES\n        //  Pour le mode XHR, on recupère une reponse sous forme d'un json ou xml (#document).\n        //  Pour le mode JSONP, on a toujours un objet JSON mais sous 2 formes :\n        //      - natif\n        //      - XML encapsulé :\n        //          {http : {status:200, error:null},xml :'réponse du service'}\n        //          {http : {status:400, error:'reponse du service'},xml :null}\n        //  En XHR, la reponse est directement sauvegardée dans 'this.response'.\n        //  Par contre, en JSONP, on doit analyser la reponse (status ou non vide),\n        //  et ne renvoyer que le contenu (xml ou l'objet)\n\n        // gestion de la proxification du service\n        var strUrlProxified = null;\n        var strData = this.request;\n\n        // a t on mis en place un proxy ?\n        // la proxyfication est valable uniquement en mode XHR !\n        var bUrlProxified = !!(this.options.proxyURL && this.options.protocol === \"XHR\");\n\n        // rajout de l'option gpbibaccess\n        // INFO : acces au numero de version de package.conf aprés compilation !\n        if (this.CLASSNAME !== \"Geocode\" && this.CLASSNAME !== \"ReverseGeocode\" && this.CLASSNAME !== \"AutoComplete\") {\n            this.options.serverUrl = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(this.options.serverUrl, {\n                \"gp-access-lib\" : _package_json__WEBPACK_IMPORTED_MODULE_6__.version\n            }, false);\n        }\n\n        // si le proxy est renseigné, on proxifie l'url du service\n        if (bUrlProxified) {\n            if (this.options.httpMethod === \"GET\") {\n                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(this.options.serverUrl, this.request, true);\n                strData = null;\n            }\n\n            if (this.options.httpMethod === \"POST\") {\n                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(this.options.serverUrl, null, true);\n                strData = this.request;\n            }\n        }\n\n        // contexte du composant spécifique !\n        var self = this;\n\n        var options = {\n            url : strUrlProxified || this.options.serverUrl,\n            method : this.options.httpMethod,\n            protocol : this.options.protocol,\n            timeOut : this.options.timeOut || 0,\n            format : this.options.outputFormat, // ceci declenche le parsing de la reponse du service, mais on souhaite toujours une reponse brute (string) !\n            nocache : this.options.nocache || false, // ceci permet d'ajouter un timestamp dans la requête\n            wrap : this.options.protocol !== \"XHR\", // ceci declenche l'encapsulation de la reponse XML du service dans du JSON, mais pas en mode XHR !\n            callbackSuffix : this.options.callbackSuffix,\n            // callbackName : this.options.callbackName || null,\n            data : strData,\n            headers : null, // TODO...\n            content : this.options.contentType || \"application/xml\",\n            scope : this.options.scope || this,\n            // callback de reponse\n            onResponse : function (response) {\n                self.logger.trace(\"callService::onResponse()\");\n\n                // le contenu de la reponse à renvoyer !\n                var content = null;\n\n                // XHR : on renvoie toujours la reponse brute du service (json ou xml)\n                // au parser du composant...\n                if (self.options.protocol === \"XHR\") {\n                    self.logger.trace(\"Response XHR\", response);\n                    content = response; // par defaut, la reponse du service  !\n                }\n\n                // JSONP : on pre-analyse la reponse brute du service (encapsuler ou pas)\n                // avant de l'envoyer au parser du composant...\n                if (self.options.protocol === \"JSONP\") {\n                    self.logger.trace(\"Response JSON\", response);\n                    if (response) {\n                        if (response.http) {\n                            // reponse encapsulée :\n                            // ex. reponse du service en xml\n                            // > {http : {status:200, error:null},xml :'réponse du service'}\n                            if (response.http.status !== 200) {\n                                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n                                    status : response.http.status,\n                                    message : response.http.error,\n                                    type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"].TYPE_SRVERR\n                                }));\n                                return;\n                            } else {\n                                content = response.xml; // par defaut !\n                                if (self.options.rawResponse) {\n                                    content = response;\n                                }\n                            }\n                        } else {\n                            // reponse non encapsulée :\n                            // ex. reponse du service en json ou xml\n                            content = response;\n                        }\n                    } else {\n                        error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"Le contenu de la reponse est vide !?\"));\n                        return;\n                    }\n                }\n\n                // si on souhaite parser la reponse du service\n                if (typeof self.options.onBeforeParse === \"function\") {\n                    var newResponse = self.options.onBeforeParse(content);\n                    if (typeof newResponse === \"string\") {\n                        // la reponse parsée par l'utilisateur est retournée sous\n                        // forme de string !\n                        content = newResponse;\n                    }\n                }\n                // sauvegarde de la reponse dans l'objet parent (CommonService)\n                self.response = content;\n                // on renvoie la reponse...\n                success.call(self, content);\n            },\n            // callback des erreurs\n            onFailure : function (e) {\n                self.logger.trace(\"callService::onFailure()\");\n                // on est forcement sur une erreur levée par un service !\n                e.type = _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"].TYPE_SRVERR;\n                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](e));\n            },\n            // callback de timeOut\n            onTimeOut : function () {\n                self.logger.trace(\"callService::onTimeOut()\");\n                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"TimeOut!\"));\n            }\n        };\n\n        _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__[\"default\"].send(options);\n    },\n\n    /**\n     * Analyse de la réponse\n     * @param {Function} error - callback\n     * @param {Function} success - callback\n     */\n    analyzeResponse : function (error, success) {\n        // INFO\n        this.logger.error(\"overwritten method !\");\n        // retourne l'objet spécifique au type de composant (json)\n        if (error) {\n            error.call(this, \"This method must be overwritten !\");\n        }\n        success.call(this, \"This method must be overwritten !\");\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CommonService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0NvbW1vblNlcnZpY2UuanM/MWIyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBOEM7QUFDVDtBQUNNO0FBQ0U7QUFDUztBQUNGO0FBQ3BEO0FBQ3FDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFDO0FBQzdCOztBQUVBLGtCQUFrQiw4REFBTTtBQUN4Qjs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSx1QkFBdUI7QUFDakU7QUFDQSxxREFBcUQsZ0VBQVk7QUFDakU7QUFDQTtBQUNBLDJDQUEyQyxnRUFBWTtBQUN2RCxpQ0FBaUM7QUFDakM7QUFDQSw2QkFBNkI7QUFDN0IsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDZDQUE2QyxnRUFBWTtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQVk7QUFDckMscUNBQXFDLGdFQUFZO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0VBQVk7QUFDakQ7QUFDQTs7QUFFQSxRQUFRLDJEQUFRO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsNEVBQWEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvQ29tbW9uU2VydmljZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi4vVXRpbHMvSGVscGVyXCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBQcm90b2NvbCBmcm9tIFwiLi4vUHJvdG9jb2xzL1Byb3RvY29sXCI7XG5pbXBvcnQgRXJyb3JTZXJ2aWNlIGZyb20gXCIuLi9FeGNlcHRpb25zL0Vycm9yU2VydmljZVwiO1xuaW1wb3J0IERlZmF1bHRVcmxTZXJ2aWNlIGZyb20gXCIuL0RlZmF1bHRVcmxTZXJ2aWNlXCI7XG4vLyBwYWNrYWdlLmpzb24gKGV4dHJhY3QgdmVyc2lvbilcbmltcG9ydCBQa2cgZnJvbSBcIi4uLy4uL3BhY2thZ2UuanNvblwiO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbXBvc2FudCBTZXJ2aWNlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQ29tbW9uU2VydmljZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGNvbW11bmVzIMOgIHRvdXMgbGVzIHNlcnZpY2VzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gQ2xlZiBkJ2FjY8OocyDDoCBsYSBwbGF0ZWZvcm1lIEfDqW9wb3J0YWlsLFxuICogICAgICBuw6ljZXNzYWlyZSBwb3VyIGZyYW5jaGlyIGxhIGNvdWNoZSBkZSBjb250csO0bGUgZGVzIGFjY8OocyBwb3VyIGF2b2lyIHVuZSByw6lwb25zZSBkdSBzZXJ2aWNlIGludm9xdcOpLlxuICogICAgICBQbHVzaWV1cnMgY2xlZnMgcGV1dmVudCDDqnRyZSBwYXNzw6llcyBkYW5zIGxlIGNhcyBkZSBsJ2ludm9jYXRpb24gZHUgc2VydmljZSBkJ2F1dG9jb25maWd1cmF0aW9uLlxuICogICAgICBTaSBjZSBwYXJhbcOodHJlIG4nZXN0IHBhcyByZW5zZWlnbsOpLCBhbG9ycyBsZSBwYXJhbcOodHJlIHNlcnZlclVybCBkb2l0IMOqdHJlIHJlbnNlaWduw6kgKGNvbXByZW5hbnQgYWxvcnMsIHNpIG7DqWNlc3NhaXJlIGxhIGNsZWYgQVBJKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5zZXJ2ZXJVcmwgLSBVUkwgZCdhY2PDqHMgYXUgc2VydmljZS5cbiAqICAgICAgUGVybWV0IGRlIGZvcmNlciBsJ3V0aWxpc2F0aW9uIGQndW4gc2VydmljZSDDqXF1aXZhbGVudCBkw6lwbG95w6kgZGVycmnDqHJlIHVuZSDDqXZlbnR1ZWxsZSBhdXRyZSBVUkwgZCdhY2PDqHMuXG4gKiAgICAgIFNpIGNlIHBhcmFtw6h0cmUgZXN0IHJlbnNlaWduw6kgYWxvcnMsIGxlIHBhcmFtw6h0cmUgYXBpS2V5IGVzdCBpZ25vcsOpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm90b2NvbF0gLSBMZSBwcm90b2NvbGUgw6AgdXRpbGlzZXIgcG91ciByw6ljdXDDqXJlciBsZXMgaW5mb3JtYXRpb25zIGR1IHNlcnZpY2UgOlxuICogICAgICBwZXV0IHZhbG9pciAnSlNPTlAnIG91ICdYSFInLlxuICogICAgICBQYXIgZMOpZmF1dCwgYydlc3QgbGUgcHJvdG9jb2xlIFhIUiBxdWkgc2VyYSB1dGlsaXPDqS5cbiAqICAgICAgQXR0ZW50aW9uLCBsZSBwcm90b2NvbGUgSlNPTlAgbidlc3QgcGFzIHZhbGlkZSBkYW5zIHVuIGVudmlyb25uZW1lbnQgTm9kZUpTIChVdGlsaXNhdGlvbiBkdSBtb2RlIFhIUikuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zc2xdIC0gSW5kaXF1ZSBzaSBsJ29uIHNvdWhhaXRlIGludMOpcnJvZ2VyIGxlcyBzZXJ2aWNlcyBlbiBodHRwcy5cbiAqICAgICAgQ2UgcGFyYW3DqHRyZSBuZSBmb25jdGlvbm5lIHF1ZSBwb3VyIHVuZSB1dGlsaXNhdGlvbiBob3JzIG5hdmlnYXRldXIgKGV4LiBOb2RlSlMpLlxuICogICAgICBTdXIgdW4gbmF2aWdhdGV1ciwgbGUgcHJvdG9jb2xlIGVzdCBhdXRvbWF0aXF1ZW1lbnQgZXh0cmFpdCBkZSBsJ3VybCBkdSBzaXRlLi4uXG4gKiAgICAgIFBhciBkw6lmYXV0LCBvbiB1dGlsaXNlIGxlIHByb3RvY29sZSBodHRwIChzc2w9ZmFsc2UpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm94eVVSTF0gLSBMZSBwcm94eSDDoCB1dGlsaXNlciBwb3VyIHBhbGxpZXIgYXUgcHJvYmzDqG1lIGRlIGNyb3NzLWRvbWFpbiBkYW5zIGxlIGNhcyBkJ3VuZSByZXF1w6p0ZSBYSFIuXG4gKiAgICAgIFV0aWxlIHNpIGxlIHBhcmFtw6h0cmUgJ3Byb3RvY29sJyB2YXV0ICdYSFInLCBpbCBuZSBzZXJhIHBhcyBwcmlzIGVuIGNvbXB0ZSBzaSBwcm90b2NvbCB2YXV0IEpTT05QLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeF0gLSBTdWZmaXhlIGRlIGxhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIMOgIHV0aWxpc2VyLCBkYW5zIGxlIGNhcyBkdSBwcm90b2NvbGUgSlNPTlAuXG4gKiAgICAgIFBhciBkw6lmYXV0LCBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayBwb3J0ZXJhIHVuIG5vbSBkdSB0eXBlIFwiY2FsbGJhY2tcIitJRCwgb8O5IElEIGVzdCBzb2l0IHVuIGlkZW50aWZpYW50IHVuaXF1ZSBnw6luw6lyw6kgw6AgY2hhcXVlIHJlcXXDqnRlLFxuICogICAgICBzb2l0IGxlIHBhcmFtw6h0cmUgY2FsbGJhY2tTdWZmaXggcydpbCBlc3Qgc3DDqWNpZmnDqS4gUGFyIGV4ZW1wbGUsIHNpIGNhbGxiYWNrU3VmZml4PVwiXzJcIiwgbGEgZm9uY3Rpb24gc2VyYSBcImNhbGxiYWNrXzIgKClcIi5cbiAqICAgICAgVXRpbGUgcG91ciB1dGlsaXNlciB1bmUgcsOpcG9uc2UgZMOpasOgIGVuY2Fwc3Vsw6llIGRhbnMgdW5lIGZvbmN0aW9uIGRlIGNhbGxiYWNrLCBkb250IGxlIG5vbSBlc3QgY29ubnUgKGV4IDogY2hhcmdlbWVudCBkZSBsJ2F1dG9jb25maWd1cmF0aW9uIGVuIGxvY2FsKVxuICogICAgICBVdGlsZSBzZXVsZW1lbnQgc2kgbGUgcGFyYW3DqHRyZSAncHJvdG9jb2wnIHZhdXQgJ0pTT05QJywgaWwgbmUgc2VyYSBwYXMgcHJpcyBlbiBjb21wdGUgc2kgcHJvdG9jb2wgdmF1dCAnWEhSJy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaHR0cE1ldGhvZF0gLSBMYSBtw6l0aG9kZSBIVFRQXG4gKiAgICAgIMOgIHV0aWxpc2VyIGRhbnMgbGUgY2FzIGQndW5lIHJlcXXDqnRlIFhIUiA6IHBldXQgdmFsb2lyICdHRVQnIG91ICdQT1NUJy5cbiAqICAgICAgTm9uIHByaXMgZW4gY29tcHRlIHNpICdwcm90b2NvbCcgdmF1dCBKU09OUCBxdWkgZm9uY3Rpb25uZSBvYmxpZ2F0b2lyZW1lbnQgZW4gR0VULlxuICogICAgICBQYXIgZMOpZmF1dCwgYydlc3QgbGEgbcOpdGhvZGUgR0VUIHF1aSBlc3QgdXRpbGlzw6llLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb250ZW50VHlwZV0gLSBDb250ZW50LVR5cGUgZGUgbGEgcmVxdWV0ZVxuICogICAgICDDoCB1dGlsaXNlciBkYW5zIGxlIGNhcyBkJ3VuZSByZXF1w6p0ZSBYSFIgZW4gbW9kZSBQT1NULlxuICogICAgICBOb24gcHJpcyBlbiBjb21wdGUgc2kgJ3Byb3RvY29sJyB2YXV0IEpTT05QIGV0L291IGxhIG3DqXRob2RlIEhUVFAgdmF1dCBHRVQuXG4gKiAgICAgIFBhciBkw6lmYXV0LCBjJ2VzdCBsYSBtw6l0aG9kZSBHRVQgcXVpIGVzdCB1dGlsaXPDqWUgZG9uYyBvbiBuJ3V0aWxpc2UgcGFzIGRlIENvbnRlbnQtVHlwZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZU91dF0gLSBEw6lsYWkgZCdhdHRlbnRlIG1heGltYWwgKGVuIG1zKSBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlICjDoCBwYXJ0aXIgZGUgbCdlbnZvaSBkZSBsYSByZXF1w6p0ZSkuXG4gKiAgICAgIFBhciBkw6lmYXV0LCBhdWN1biB0aW1lT3V0IG4nZXN0IHByaXMgZW4gY29tcHRlICh0aW1lb3V0RGVsYXk9IDApLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzcG9uc2VdIC0gSW5kaXF1ZSBzaSBsJ29uIHNvdWhhaXRlIHF1ZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIG5lIHNvaXQgcGFzIHBhcnPDqWUgcGFyIGwnQVBJIGF2YW50IGQnw6p0cmUgcmVzdGl0dcOpZS5cbiAqICAgICAgKENmLiBwYXJhbcOodHJlIMKrIG9uU3VjY2VzcyDCuyBwb3VyIHBsdXMgZGUgZMOpdGFpbHMpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uU3VjY2Vzc10gLSBGb25jdGlvbiBhcHBlbMOpZSBsb3JzcXVlIGxlIHNlcnZpY2UgcsOpcG9uZCBjb3JyZWN0ZW1lbnQgw6AgbGEgcmVxdcOqdGVcbiAqICAgICAgKGNvZGUgSFRUUCAyMDAsIHNhbnMgbWVzc2FnZSBkJ2VycmV1cikuXG4gKiAgICAgIENldHRlIGZvbmN0aW9uIHByZW5kIGVuIHBhcmFtw6h0cmUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSxcbiAqICAgICAgc29pdCBzb3VzIGxhIGZvcm1lIGQndW4gT2JqZWN0IEphdmFzY3JpcHQgZm9ybWF0w6kgcGFyIGxlIHBhcnNldXIgZMOpZGnDqSDDoCBsYSBzeW50YXhlIGR1IHNlcnZpY2UgKGNvbXBvcnRlbWVudCBwYXIgZMOpZmF1dCkgO1xuICogICAgICBzb2l0IGJydXRlIGF1IGZvcm1hdCBTdHJpbmcgbm9uIHByw6l0cmFpdMOpIHNpIGxlIHBhcmFtw6h0cmUgwqsgcmF3UmVzcG9uc2UgwrsgYSDDqXTDqSBwcsOpY2lzw6kgYXZlYyBsYSB2YWxldXIgwqsgdHJ1ZSDCuy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZhaWx1cmVdIC0gRm9uY3Rpb24gYXBwZWzDqWUgbG9yc3F1ZSBsZSBzZXJ2aWNlIG5lIHLDqXBvbmQgcGFzIGNvcnJlY3RlbWVudFxuICogICAgICAoY29kZSBIVFRQIGRlIHJldG91ciBkaWZmw6lyZW50IGRlIDIwMCBvdSBwYXMgZGUgcsOpcG9uc2UpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQmVmb3JlUGFyc2VdIC0gRm9uY3Rpb24gYXBwZWzDqWUgYXZhbnQgbGUgcGFyc2luZyBkZSBsYSByw6lwb25zZVxuICogICAgICBQZXJtZXQgZGUgbW9kaWZpZXIgbGEgcsOpcG9uc2UgYXZhbnQgcGFyc2luZyBldCBsYSBmb25jdGlvbiBkb2l0IHJldG91cm5lciB1bmUgU3RyaW5nLlxuICogICAgICBDZXR0ZSBmb25jdGlvbiBwcmVuZCBlbiBwYXJhbcOodHJlIGxhIHLDqXBvbnNlIHRlbGxlIHF1ZSByZW52b3nDqWUgcGFyIGxlIHNlcnZpY2VcbiAqICAgICAgKGNhZCBhdSBmb3JtYXQganNvbiBvdSB4bWwpLlxuICogICAgICBQb3VyIGxlIEpTT05QLCBzaSBsZSBwYXJhbcOodHJlIFwicmF3UmVzcG9uc2VcIiBhIMOpdMOpIHByw6ljaXPDqSBhdmVjIGxhIHZhbGV1ciBcInRydWVcIixcbiAqICAgICAgbGEgZm9uY3Rpb24gcHJlbmQgZW4gcGFyYW3DqHRyZSB1biBPYmplY3QgSmF2YVNjcmlwdCBjb250ZW5hbnQgbGEgcsOpcG9uc2UgWE1MLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHZhciBvcHRpb25zID0ge1xuICogICAgICBhcGlLZXkgOiBudWxsLFxuICogICAgICBzZXJ2ZXJVcmwgOiAnaHR0cDovL2xvY2FsaG9zdC9zZXJ2aWNlLycsXG4gKiAgICAgIHByb3RvY29sIDogJ0pTT05QJywgLy8gSlNPTlB8WEhSXG4gKiAgICAgIHNzbCA6IGZhbHNlLFxuICogICAgICBwcm94eVVSTCA6IG51bGwsXG4gKiAgICAgIGNhbGxiYWNrTmFtZSA6IG51bGwsXG4gKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAqICAgICAgdGltZU91dCA6IDEwMDAwLCAvLyBtc1xuICogICAgICByYXdSZXNwb25zZSA6IGZhbHNlLCAvLyB0cnVlfGZhbHNlXG4gKiAgICAgIHNjb3BlIDogbnVsbCwgLy8gdGhpc1xuICogICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHt9LFxuICogICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICogICAgICBvbkJlZm9yZVBhcnNlIDogZnVuY3Rpb24gKHJhd1Jlc3BvbnNlKSB7fVxuICogICB9O1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29tbW9uU2VydmljZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21tb25TZXJ2aWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKF8uZ2V0TWVzc2FnZShcIkNMQVNTX0NPTlNUUlVDVE9SXCIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJDb21tb25TZXJ2aWNlXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBDb21tb25TZXJ2aWNlIChvcHRpb25zKV1cIik7XG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAvLyByw6ljdXDDqXJhdGlvbiBkZXMgb3B0aW9ucyBwYXIgZMOpZmF1dCBwb3VyIGxlcyBwYXJhbcOodHJlcyBvcHRpb25uZWxzXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIGR1IHNlcnZpY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgLy8gcHJvdG9jb2wgOiBcIkpTT05QXCIsXG4gICAgICAgIHByb3RvY29sIDogXCJYSFJcIixcbiAgICAgICAgc3NsIDogdHJ1ZSxcbiAgICAgICAgcHJveHlVUkwgOiBcIlwiLFxuICAgICAgICAvLyBjYWxsYmFja05hbWUgOiBcIlwiLFxuICAgICAgICBjYWxsYmFja1N1ZmZpeCA6IG51bGwsXG4gICAgICAgIGh0dHBNZXRob2QgOiBcIkdFVFwiLFxuICAgICAgICB0aW1lT3V0IDogMCxcbiAgICAgICAgcmF3UmVzcG9uc2UgOiBmYWxzZSxcbiAgICAgICAgc2NvcGUgOiB0aGlzLFxuICAgICAgICAvKipcbiAgICAgICAgKiBjYWxsYmFjayBwYXIgZGVmYXV0IHBvdXIgbGEgcmVwb25zZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSAtIHJlc3BvbnNlXG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uU3VjY2VzcyAtIGxhIHJlcG9uc2UgZXN0IGxhIHN1aXZhbnRlIDogXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogY2FsbGJhY2sgcGFyIGRlZmF1dCBwb3VyIGxlcyBlcnJldXJzXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIC0gZXJyb3JcbiAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDIwMCB8fCAhZXJyb3Iuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJvbkZhaWx1cmUgOiBcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib25GYWlsdXJlIC0gRXJyZXVyIChcIiwgZXJyb3Iuc3RhdHVzLCBcIikgOiBcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXQgb24gYWpvdXRlIGxlcyBvcHRpb25zIGVuIHBhcmFtw6h0cmUgYXV4IG9wdGlvbnMgcGFyIGTDqWZhdXRcbiAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgIC8vIGFuYWx5c2UgZGVzIG9wdGlvbnNcbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICAgIC8vIGdlc3Rpb24gZGVzIGNsZWZzIEFQSVxuICAgIGlmICghdGhpcy5vcHRpb25zLmFwaUtleSAmJiAhdGhpcy5vcHRpb25zLnNlcnZlclVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcImFwaUtleVwiLCBcInNlcnZlclVybFwiKSk7XG4gICAgfVxuXG4gICAgLy8gbW9kaWZpY2F0aW9uIGRlIGxhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIG9uU3VjY2VzcyBkYW5zIGxlIGNhcyBvw7kgbGEgcsOpcG9uc2UgYnJ1dGUgZXN0IGRlbWFuZMOpZVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UgJiYgIXRoaXMub3B0aW9ucy5vblN1Y2Nlc3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogY2FsbGJhY2sgcGFyIGRlZmF1dCBwb3VyIGxhIHJlcG9uc2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSByZXNwb25zZVxuICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib25TdWNjZXNzIC0gbGEgcsOpcG9uc2UgYnJ1dGUgZHUgc2VydmljZSBlc3QgbGEgc3VpdmFudGUgOiBcIiwgcmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGdlc3Rpb24gZHUgY2FsbGJhY2sgb25TdWNjZXNzXG4gICAgdmFyIGJPblN1Y2Nlc3MgPSAhISh0aGlzLm9wdGlvbnMub25TdWNjZXNzICE9PSBudWxsICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMub25TdWNjZXNzID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIGlmICghYk9uU3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcIm9uU3VjY2VzcygpXCIpKTtcbiAgICB9XG5cbiAgICAvLyBnZXN0aW9uIGRlIGwndXJsIGR1IHNlcnZpY2UgcGFyIGRlZmF1dFxuICAgIGlmICghdGhpcy5vcHRpb25zLnNlcnZlclVybCkge1xuICAgICAgICAvLyBJTkZPXG4gICAgICAgIC8vIGdlc3Rpb24gZGUgbCd1cmwgZHUgc2VydmljZSBwYXIgZGVmYXV0IHBvdXIgbGVzIHNlcnZpY2VzIHF1aSBuZSBwb3Nzw6hkZW50IHF1J3VuZSBzZXVsIHVybCBwYXIgZGVmYXV0XG4gICAgICAgIC8vIGxlcyBjYXMgcGFydGljdWxpZXJzIGRlcyBzZXJ2aWNlcyBhdmVjIHBsdXNpZXVycyB1cmxzIChleC4gQWx0aSkgZGV2cm9udCDDqnRyZSB0cmFpdMOpIGRhbnMgbGEgY2xhc3NlIGR1IGNvbXBvc2FudFxuICAgICAgICAvLyBkb25jIHNpIGwndXJsIG4nZXN0IHBhcyByZW5zZWlnbsOpZSwgaWwgZmF1dCB1dGlsaXNlciBsZXMgdXJscyBwYXIgZGVmYXV0XG4gICAgICAgIERlZmF1bHRVcmxTZXJ2aWNlLnNzbCA9IHRoaXMub3B0aW9ucy5zc2w7XG4gICAgICAgIHZhciB1cmxCeURlZmF1bHQgPSBEZWZhdWx0VXJsU2VydmljZVt0aGlzLkNMQVNTTkFNRV0udXJsKHRoaXMub3B0aW9ucy5hcGlLZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHVybEJ5RGVmYXVsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlcnZlclVybCA9IHVybEJ5RGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiVVJMIHBhciBkZWZhdXQgw6AgZGV0ZXJtaW5lciBhdSBuaXZlYXUgZHUgY29tcG9zYW50Li4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYTUUgbmV0dG95YWdlIGRlcyBLVlAgZGFucyBsJ3VybCBkdSBzZXJ2aWNlXG4gICAgLy8gaWYgKHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAvLyAgICAgLy8gSU5GT1xuICAgIC8vICAgICAvLyBzaSBsJ3VybCBlc3QgcmVuc2VpZ27DqWUsIGlsIGZhdXQgbGEgbmV0dG95ZXIgZGUgdG91cyBzZXMgS1ZQXG4gICAgLy8gICAgIC8vIGV4LiBvbiBuZSB2ZXV0IHBhcyBkZSBwYXJhbXMuICdjYWxsYmFjaycgb3UgJ291dHB1dCcgY2FyIGNlY2kgZGVjbGVuY2hlcmFpdFxuICAgIC8vICAgICAvLyBkZXMgb3DDqXJhdGlvbnMgZCdlbmNhcHN1bGF0aW9ucyBkZXMgcmVwb25zZXMgbMOpZ8OocmVtZW50IGZhcmZlbHVlcyAuLi5cbiAgICAvLyAgICAgdmFyIHVybHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmw7XG4gICAgLy8gICAgIHZhciB1cmxwYXJ0cyA9IHVybHNvdXJjZS5zcGxpdChcIj9cIik7XG4gICAgLy8gICAgIHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwgPSB1cmxwYXJ0c1swXTtcbiAgICAvLyB9XG5cbiAgICAvLyBnZXN0aW9uIGRlIGxhIG1ldGhvZGUgSFRUUFxuICAgIHRoaXMub3B0aW9ucy5odHRwTWV0aG9kID0gKHR5cGVvZiBvcHRpb25zLmh0dHBNZXRob2QgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5odHRwTWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiO1xuXG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCkge1xuICAgICAgICBjYXNlIFwiUE9TVFwiOlxuICAgICAgICBjYXNlIFwiR0VUXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICBjYXNlIFwiREVMRVRFXCI6XG4gICAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICAgIGNhc2UgXCJPUFRJT05TXCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTk9UX1NVUFBPUlRcIiwgXCJodHRwTWV0aG9kXCIpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9VTktOT1dOXCIsIFwiaHR0cE1ldGhvZFwiKSk7XG4gICAgfVxuXG4gICAgLy8gZ2VzdGlvbiBkdSBwcm90b2NvbGVcbiAgICAvLyB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPSAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09IFwic3RyaW5nXCIgKSA/IG9wdGlvbnMucHJvdG9jb2wudG9VcHBlckNhc2UoKSA6IFwiSlNPTlBcIjtcbiAgICB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPSAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5wcm90b2NvbC50b1VwcGVyQ2FzZSgpIDogXCJYSFJcIjtcblxuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnByb3RvY29sKSB7XG4gICAgICAgIGNhc2UgXCJKU09OUFwiOlxuICAgICAgICBjYXNlIFwiWEhSXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9VTktOT1dOXCIsIFwicHJvdG9jb2xcIikpO1xuICAgIH1cblxuICAgIC8vIG9uIGRldGVybWluZSBsJ2Vudmlyb25uZW1lbnQgZCdleGVjdXRpb24gOiBicm93c2VyIG91IG5vbiA/XG4gICAgLy8gZXQgb24gbGFuY2UgdW5lIGV4Y2VwdGlvbiBzdXIgbCd1dGlsaXNhdGlvbiBkdSBwcm90b2NvbGUgSlNPTlAgcG91ciBub2RlSlMuLi5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPT09IFwiSlNPTlBcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTk9UX1NVUFBPUlRfTk9ERUpTXCIsIFwicHJvdG9jb2w9SlNPTlAgKGluc3RlYWQgdXNlIFhIUilcIikpO1xuICAgIH1cblxuICAgIC8vIGxlIHByb3RvY29sZSBKU09OUCBuZSBmb25jdGlvbm5lIHF1J2VuIEdFVC5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmh0dHBNZXRob2QgPSBcIkdFVFwiO1xuICAgIH1cblxuICAgIC8vIGdlc3Rpb24gZHUgY2FjaGVcbiAgICB0aGlzLm9wdGlvbnMubm9jYWNoZSA9IG9wdGlvbnMubm9jYWNoZSB8fCBmYWxzZTtcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgIC8vIGF0dHJpYnV0cyBkJ2luc3RhbmNlc1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGRlIHLDqXBvbnNlIGR1IHNlcnZpY2VcbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBSZXF1w6p0ZSBlbnZvecOpZSBhdSBzZXJ2aWNlXG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBSZXBvbnNlIGR1IHNlcnZpY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkNvbW1vblNlcnZpY2VcbiAqL1xuQ29tbW9uU2VydmljZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBDb21tb25TZXJ2aWNlLFxuXG4gICAgLyoqXG4gICAgICogQXBwZWwgZHUgc2VydmljZSBHw6lvcG9ydGFpbFxuICAgICAqL1xuICAgIGNhbGwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXMgOiB0cnVlICovXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQ29tbW9uU2VydmljZTo6Y2FsbCAoKVwiKTtcblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIC8qKiBmb25jdGlvbiBkJ2V4ZWN1dGlvbiAqL1xuICAgICAgICBmdW5jdGlvbiBydW4gKCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpydW4gKClcIik7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUmVxdWVzdC5jYWxsKGNvbnRleHQsIG9uRXJyb3IsIG9uQnVpbGRSZXF1ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bi5jYWxsKGNvbnRleHQpO1xuXG4gICAgICAgIC8vIGNhbGxiYWNrIGRlIGZpbiBkZSBjb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGVcbiAgICAgICAgZnVuY3Rpb24gb25CdWlsZFJlcXVlc3QgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpvbkJ1aWxkUmVxdWVzdCA6IFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5jYWxsU2VydmljZS5jYWxsKGNvbnRleHQsIG9uRXJyb3IsIG9uQ2FsbFNlcnZpY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZGUgZmluIGQnYXBwZWwgYXUgc2VydmljZVxuICAgICAgICBmdW5jdGlvbiBvbkNhbGxTZXJ2aWNlIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQ29tbW9uU2VydmljZTo6b25DYWxsU2VydmljZSA6IFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5hbmFseXplUmVzcG9uc2UuY2FsbChjb250ZXh0LCBvbkVycm9yLCBvbkFuYWx5emVSZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFjayBkZSBmaW4gZGUgbGVjdHVyZSBkZSBsYSByZXBvbnNlXG4gICAgICAgIGZ1bmN0aW9uIG9uQW5hbHl6ZVJlc3BvbnNlIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQ29tbW9uU2VydmljZTo6b25BbmFseXplUmVzcG9uc2UgOiBcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IuY2FsbCh0aGlzLCBuZXcgRXJyb3JTZXJ2aWNlKFwiQW5hbHlzZSBkZSBsYSByZXBvbnNlIGVuIMOpY2hlYyAhP1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFjayBkZSBnZXN0aW9uIGRlcyBlcnJldXJzIDogcmVudm9pdCB1biBvYmpldCBkZSB0eXBlIEVycm9yU2VydmljZVxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpvbkVycm9yKClcIik7XG4gICAgICAgICAgICAvLyBlcnJvciA6IGwnb2JqZXQgZXN0IGR1IHR5cGUgRXJyb3JTZXJ2aWNlIG91IEVycm9yXG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yO1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yU2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICBlID0gbmV3IEVycm9yU2VydmljZShlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkZhaWx1cmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gICAgICovXG4gICAgYnVpbGRSZXF1ZXN0IDogZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgICAgIC8vIElORk9cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJvdmVyd3JpdHRlbiBtZXRob2QgIVwiKTtcbiAgICAgICAgLy8gcmV0b3VybmUgbCdvYmpldCAndGhpcy5yZXF1ZXN0J1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcywgXCJUaGlzIG1ldGhvZCBtdXN0IGJlIG92ZXJ3cml0dGVuICFcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMsIFwiVGhpcyBtZXRob2QgbXVzdCBiZSBvdmVyd3JpdHRlbiAhXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbCBkdSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNhbGxTZXJ2aWNlIDogZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgICAgIC8vIElORk9cbiAgICAgICAgLy8gcmV0b3VybmUgbCdvYmpldCAndGhpcy5yZXNwb25zZSdcblxuICAgICAgICAvLyBOT1RFU1xuICAgICAgICAvLyAgUG91ciBsZSBtb2RlIFhIUiwgb24gcmVjdXDDqHJlIHVuZSByZXBvbnNlIHNvdXMgZm9ybWUgZCd1biBqc29uIG91IHhtbCAoI2RvY3VtZW50KS5cbiAgICAgICAgLy8gIFBvdXIgbGUgbW9kZSBKU09OUCwgb24gYSB0b3Vqb3VycyB1biBvYmpldCBKU09OIG1haXMgc291cyAyIGZvcm1lcyA6XG4gICAgICAgIC8vICAgICAgLSBuYXRpZlxuICAgICAgICAvLyAgICAgIC0gWE1MIGVuY2Fwc3Vsw6kgOlxuICAgICAgICAvLyAgICAgICAgICB7aHR0cCA6IHtzdGF0dXM6MjAwLCBlcnJvcjpudWxsfSx4bWwgOidyw6lwb25zZSBkdSBzZXJ2aWNlJ31cbiAgICAgICAgLy8gICAgICAgICAge2h0dHAgOiB7c3RhdHVzOjQwMCwgZXJyb3I6J3JlcG9uc2UgZHUgc2VydmljZSd9LHhtbCA6bnVsbH1cbiAgICAgICAgLy8gIEVuIFhIUiwgbGEgcmVwb25zZSBlc3QgZGlyZWN0ZW1lbnQgc2F1dmVnYXJkw6llIGRhbnMgJ3RoaXMucmVzcG9uc2UnLlxuICAgICAgICAvLyAgUGFyIGNvbnRyZSwgZW4gSlNPTlAsIG9uIGRvaXQgYW5hbHlzZXIgbGEgcmVwb25zZSAoc3RhdHVzIG91IG5vbiB2aWRlKSxcbiAgICAgICAgLy8gIGV0IG5lIHJlbnZveWVyIHF1ZSBsZSBjb250ZW51ICh4bWwgb3UgbCdvYmpldClcblxuICAgICAgICAvLyBnZXN0aW9uIGRlIGxhIHByb3hpZmljYXRpb24gZHUgc2VydmljZVxuICAgICAgICB2YXIgc3RyVXJsUHJveGlmaWVkID0gbnVsbDtcbiAgICAgICAgdmFyIHN0ckRhdGEgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICAgICAgLy8gYSB0IG9uIG1pcyBlbiBwbGFjZSB1biBwcm94eSA/XG4gICAgICAgIC8vIGxhIHByb3h5ZmljYXRpb24gZXN0IHZhbGFibGUgdW5pcXVlbWVudCBlbiBtb2RlIFhIUiAhXG4gICAgICAgIHZhciBiVXJsUHJveGlmaWVkID0gISEodGhpcy5vcHRpb25zLnByb3h5VVJMICYmIHRoaXMub3B0aW9ucy5wcm90b2NvbCA9PT0gXCJYSFJcIik7XG5cbiAgICAgICAgLy8gcmFqb3V0IGRlIGwnb3B0aW9uIGdwYmliYWNjZXNzXG4gICAgICAgIC8vIElORk8gOiBhY2NlcyBhdSBudW1lcm8gZGUgdmVyc2lvbiBkZSBwYWNrYWdlLmNvbmYgYXByw6lzIGNvbXBpbGF0aW9uICFcbiAgICAgICAgaWYgKHRoaXMuQ0xBU1NOQU1FICE9PSBcIkdlb2NvZGVcIiAmJiB0aGlzLkNMQVNTTkFNRSAhPT0gXCJSZXZlcnNlR2VvY29kZVwiICYmIHRoaXMuQ0xBU1NOQU1FICE9PSBcIkF1dG9Db21wbGV0ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VydmVyVXJsID0gSGVscGVyLm5vcm1hbHl6ZVVybCh0aGlzLm9wdGlvbnMuc2VydmVyVXJsLCB7XG4gICAgICAgICAgICAgICAgXCJncC1hY2Nlc3MtbGliXCIgOiBQa2cudmVyc2lvblxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2kgbGUgcHJveHkgZXN0IHJlbnNlaWduw6ksIG9uIHByb3hpZmllIGwndXJsIGR1IHNlcnZpY2VcbiAgICAgICAgaWYgKGJVcmxQcm94aWZpZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgICAgIHN0clVybFByb3hpZmllZCA9IHRoaXMub3B0aW9ucy5wcm94eVVSTCArIEhlbHBlci5ub3JtYWx5emVVcmwodGhpcy5vcHRpb25zLnNlcnZlclVybCwgdGhpcy5yZXF1ZXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzdHJEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5odHRwTWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgICAgIHN0clVybFByb3hpZmllZCA9IHRoaXMub3B0aW9ucy5wcm94eVVSTCArIEhlbHBlci5ub3JtYWx5emVVcmwodGhpcy5vcHRpb25zLnNlcnZlclVybCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RyRGF0YSA9IHRoaXMucmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRleHRlIGR1IGNvbXBvc2FudCBzcMOpY2lmaXF1ZSAhXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybCA6IHN0clVybFByb3hpZmllZCB8fCB0aGlzLm9wdGlvbnMuc2VydmVyVXJsLFxuICAgICAgICAgICAgbWV0aG9kIDogdGhpcy5vcHRpb25zLmh0dHBNZXRob2QsXG4gICAgICAgICAgICBwcm90b2NvbCA6IHRoaXMub3B0aW9ucy5wcm90b2NvbCxcbiAgICAgICAgICAgIHRpbWVPdXQgOiB0aGlzLm9wdGlvbnMudGltZU91dCB8fCAwLFxuICAgICAgICAgICAgZm9ybWF0IDogdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCwgLy8gY2VjaSBkZWNsZW5jaGUgbGUgcGFyc2luZyBkZSBsYSByZXBvbnNlIGR1IHNlcnZpY2UsIG1haXMgb24gc291aGFpdGUgdG91am91cnMgdW5lIHJlcG9uc2UgYnJ1dGUgKHN0cmluZykgIVxuICAgICAgICAgICAgbm9jYWNoZSA6IHRoaXMub3B0aW9ucy5ub2NhY2hlIHx8IGZhbHNlLCAvLyBjZWNpIHBlcm1ldCBkJ2Fqb3V0ZXIgdW4gdGltZXN0YW1wIGRhbnMgbGEgcmVxdcOqdGVcbiAgICAgICAgICAgIHdyYXAgOiB0aGlzLm9wdGlvbnMucHJvdG9jb2wgIT09IFwiWEhSXCIsIC8vIGNlY2kgZGVjbGVuY2hlIGwnZW5jYXBzdWxhdGlvbiBkZSBsYSByZXBvbnNlIFhNTCBkdSBzZXJ2aWNlIGRhbnMgZHUgSlNPTiwgbWFpcyBwYXMgZW4gbW9kZSBYSFIgIVxuICAgICAgICAgICAgY2FsbGJhY2tTdWZmaXggOiB0aGlzLm9wdGlvbnMuY2FsbGJhY2tTdWZmaXgsXG4gICAgICAgICAgICAvLyBjYWxsYmFja05hbWUgOiB0aGlzLm9wdGlvbnMuY2FsbGJhY2tOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBkYXRhIDogc3RyRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnMgOiBudWxsLCAvLyBUT0RPLi4uXG4gICAgICAgICAgICBjb250ZW50IDogdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlIHx8IFwiYXBwbGljYXRpb24veG1sXCIsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXMub3B0aW9ucy5zY29wZSB8fCB0aGlzLFxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgZGUgcmVwb25zZVxuICAgICAgICAgICAgb25SZXNwb25zZSA6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiY2FsbFNlcnZpY2U6Om9uUmVzcG9uc2UoKVwiKTtcblxuICAgICAgICAgICAgICAgIC8vIGxlIGNvbnRlbnUgZGUgbGEgcmVwb25zZSDDoCByZW52b3llciAhXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gWEhSIDogb24gcmVudm9pZSB0b3Vqb3VycyBsYSByZXBvbnNlIGJydXRlIGR1IHNlcnZpY2UgKGpzb24gb3UgeG1sKVxuICAgICAgICAgICAgICAgIC8vIGF1IHBhcnNlciBkdSBjb21wb3NhbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnByb3RvY29sID09PSBcIlhIUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiUmVzcG9uc2UgWEhSXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHJlc3BvbnNlOyAvLyBwYXIgZGVmYXV0LCBsYSByZXBvbnNlIGR1IHNlcnZpY2UgICFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBKU09OUCA6IG9uIHByZS1hbmFseXNlIGxhIHJlcG9uc2UgYnJ1dGUgZHUgc2VydmljZSAoZW5jYXBzdWxlciBvdSBwYXMpXG4gICAgICAgICAgICAgICAgLy8gYXZhbnQgZGUgbCdlbnZveWVyIGF1IHBhcnNlciBkdSBjb21wb3NhbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIudHJhY2UoXCJSZXNwb25zZSBKU09OXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaHR0cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcG9uc2UgZW5jYXBzdWzDqWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4LiByZXBvbnNlIGR1IHNlcnZpY2UgZW4geG1sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPiB7aHR0cCA6IHtzdGF0dXM6MjAwLCBlcnJvcjpudWxsfSx4bWwgOidyw6lwb25zZSBkdSBzZXJ2aWNlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaHR0cC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHNlbGYsIG5ldyBFcnJvclNlcnZpY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogcmVzcG9uc2UuaHR0cC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogcmVzcG9uc2UuaHR0cC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBFcnJvclNlcnZpY2UuVFlQRV9TUlZFUlJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHJlc3BvbnNlLnhtbDsgLy8gcGFyIGRlZmF1dCAhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMucmF3UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb25zZSBub24gZW5jYXBzdWzDqWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4LiByZXBvbnNlIGR1IHNlcnZpY2UgZW4ganNvbiBvdSB4bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHNlbGYsIG5ldyBFcnJvclNlcnZpY2UoXCJMZSBjb250ZW51IGRlIGxhIHJlcG9uc2UgZXN0IHZpZGUgIT9cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2kgb24gc291aGFpdGUgcGFyc2VyIGxhIHJlcG9uc2UgZHUgc2VydmljZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLm9uQmVmb3JlUGFyc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UmVzcG9uc2UgPSBzZWxmLm9wdGlvbnMub25CZWZvcmVQYXJzZShjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdSZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGEgcmVwb25zZSBwYXJzw6llIHBhciBsJ3V0aWxpc2F0ZXVyIGVzdCByZXRvdXJuw6llIHNvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcm1lIGRlIHN0cmluZyAhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gbmV3UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2F1dmVnYXJkZSBkZSBsYSByZXBvbnNlIGRhbnMgbCdvYmpldCBwYXJlbnQgKENvbW1vblNlcnZpY2UpXG4gICAgICAgICAgICAgICAgc2VsZi5yZXNwb25zZSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgLy8gb24gcmVudm9pZSBsYSByZXBvbnNlLi4uXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHNlbGYsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGRlcyBlcnJldXJzXG4gICAgICAgICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiY2FsbFNlcnZpY2U6Om9uRmFpbHVyZSgpXCIpO1xuICAgICAgICAgICAgICAgIC8vIG9uIGVzdCBmb3JjZW1lbnQgc3VyIHVuZSBlcnJldXIgbGV2w6llIHBhciB1biBzZXJ2aWNlICFcbiAgICAgICAgICAgICAgICBlLnR5cGUgPSBFcnJvclNlcnZpY2UuVFlQRV9TUlZFUlI7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2FsbChzZWxmLCBuZXcgRXJyb3JTZXJ2aWNlKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBjYWxsYmFjayBkZSB0aW1lT3V0XG4gICAgICAgICAgICBvblRpbWVPdXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIudHJhY2UoXCJjYWxsU2VydmljZTo6b25UaW1lT3V0KClcIik7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2FsbChzZWxmLCBuZXcgRXJyb3JTZXJ2aWNlKFwiVGltZU91dCFcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIFByb3RvY29sLnNlbmQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuYWx5c2UgZGUgbGEgcsOpcG9uc2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5hbHl6ZVJlc3BvbnNlIDogZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgICAgIC8vIElORk9cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJvdmVyd3JpdHRlbiBtZXRob2QgIVwiKTtcbiAgICAgICAgLy8gcmV0b3VybmUgbCdvYmpldCBzcMOpY2lmaXF1ZSBhdSB0eXBlIGRlIGNvbXBvc2FudCAoanNvbilcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5jYWxsKHRoaXMsIFwiVGhpcyBtZXRob2QgbXVzdCBiZSBvdmVyd3JpdHRlbiAhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzLCBcIlRoaXMgbWV0aG9kIG11c3QgYmUgb3ZlcndyaXR0ZW4gIVwiKTtcbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbW1vblNlcnZpY2U7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/CommonService.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// cette classe contient les URLs par defaut des services.\n//  DefaultUrlService.Alti.url(key)[elevation-json]\n//  DefaultUrlService.Alti.url(key)[elevation-xml]\n//  DefaultUrlService.Alti.url(key)[profil-json]\n//  DefaultUrlService.Alti.url(key)[profil-xml]\n//  DefaultUrlService.Alti.url(key)[wps]\n//  DefaultUrlService.ProcessIsoCurve.url(key)\n//  DefaultUrlService.AutoComplete.url(key)\n//  DefaultUrlService.ReverseGeocode.url(key)\n//  DefaultUrlService.AutoConf.url(key)[apiKey]\n//  DefaultUrlService.AutoConf.url(key)[apiKeys]\n//  DefaultUrlService.AutoConf.url(key)[aggregate]\n//  DefaultUrlService.Geocode.url(key)\n//  DefaultUrlService.Route.url(key)\n\n// Example :\n//\n// DefaultUrlService.Alti.url('alti')[elevation-json]\n//  output {String} -> http://wxs.ign.fr/calcul/alti/rest/elevation.json\n//\n// DefaultUrlService.Alti.url('calcul')\n// output {Object|String}\n// -> http://wxs.ign.fr/calcul/alti/rest/elevation.json\n// -> http://wxs.ign.fr/calcul/alti/rest/elevation.xml\n// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.json\n// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.xml\n// -> http://wxs.ign.fr/calcul/alti/wps\n//\n// ssl by default.\n//\n// Force to not do ssl :\n// DefaultUrlService.ssl = false;\n//\n// DefaultUrlService.AutoComplete.url('calcul')\n// output {Object|String}\n// -> https://wxs.ign.fr/calcul/ols/apis/completion\n\n// constantes internes\nvar HOSTNAME = \"wxs.ign.fr\";\n\n/**\n * Default Geoportal web services URLs access.\n *\n * @namespace\n * @alias Gp.Services.DefaultUrl\n */\nvar DefaultUrlService = {\n\n    /** if set true, require the use of https protocol */\n    ssl : true,\n\n    /**\n    * base url of services (ssl protocol management)\n    * @param {String} key - key\n    * @param {String} path - path\n    * @returns {String} url\n    */\n    url : function (key, path) {\n        // comportement par défaut => https\n        // sinon, il est fixé par l'option 'ssl' (false => http)\n        var _protocol;\n        if (DefaultUrlService.ssl === false) {\n            _protocol = \"http://\";\n        } else {\n            _protocol = \"https://\";\n        }\n\n        return _protocol + HOSTNAME.concat(\"/\", key, path);\n    },\n\n    /**\n     * Elevation web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns elevation service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols (\"elevation-json\", \"elevation-xml\", \"profil-json\" or \"profil-xml\").\n     */\n    Alti : {\n        _key : {\n            // rest\n            \"elevation-json\" : \"/alti/rest/elevation.json\",\n            \"elevation-xml\" : \"/alti/rest/elevation.xml\",\n            \"profil-json\" : \"/alti/rest/elevationLine.json\",\n            \"profil-xml\" : \"/alti/rest/elevationLine.xml\",\n            // other\n            wps : \"/alti/wps\"\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return {\n                // rest\n                \"elevation-json\" : DefaultUrlService.url(key, this._key[\"elevation-json\"]),\n                \"elevation-xml\" : DefaultUrlService.url(key, this._key[\"elevation-xml\"]),\n                \"profil-json\" : DefaultUrlService.url(key, this._key[\"profil-json\"]),\n                \"profil-xml\" : DefaultUrlService.url(key, this._key[\"profil-xml\"]),\n                // other\n                wps : DefaultUrlService.url(key, this._key[\"wps\"])\n            };\n        }\n    },\n    /**\n     * IsoCurve web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns isocurve service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols (\"iso-json\" or \"iso-xml\").\n     */\n    ProcessIsoCurve : {\n        _key : \"/geoportail/isochrone/rest/1.0.0/isochrone\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Autocompletion web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns autocomplete service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    AutoComplete : {\n        _key : \"/ols/apis/completion\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Reverse geocoding web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns reverse geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    ReverseGeocode : {\n        _key : \"/geoportail/ols\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Autoconfiguration web service access\n     *\n     * @member {Object}\n     * @property {Function} url ([key1,...]) - Returns autoconfiguration service default urls with geoportal access key (s) given as a String array parameter. The result is a javascript object with different urls given the access mode (\"apiKey\", \"apiKeys\" or \"aggregate\").\n     */\n    AutoConf : {\n        _key : {\n            apiKey : \"/autoconf\",\n            apiKeys : \"/autoconf?keys=%KEYS%\",\n            aggregate : \"/autoconf/id/\"\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            var keys = \"\";\n            if (Array.isArray(key) && key.length > 0) {\n                keys = key[0];\n                for (var i = 1; i < key.length; i++) {\n                    keys += \",\" + key[i];\n                }\n            }\n            return {\n                apiKey : DefaultUrlService.url(key, this._key[\"apiKey\"]), // une seule clé\n                apiKeys : DefaultUrlService.url(key[0], this._key[\"apiKeys\"]).replace(\"%KEYS%\", keys), // autoconf de plusieurs clés\n                aggregate : DefaultUrlService.url(key, this._key[\"aggregate\"])\n            };\n        }\n    },\n    /**\n     * Geocoding web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    Geocode : {\n        _key : \"/geoportail/ols\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Routing web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns routing service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols.\n     */\n    Route : {\n        _key : \"/geoportail/itineraire/rest/1.0.0/route\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (DefaultUrlService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0RlZmF1bHRVcmxTZXJ2aWNlLmpzPzMxOTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsZ0ZBQWlCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0RlZmF1bHRVcmxTZXJ2aWNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gY2V0dGUgY2xhc3NlIGNvbnRpZW50IGxlcyBVUkxzIHBhciBkZWZhdXQgZGVzIHNlcnZpY2VzLlxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbZWxldmF0aW9uLWpzb25dXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoa2V5KVtlbGV2YXRpb24teG1sXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbcHJvZmlsLWpzb25dXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoa2V5KVtwcm9maWwteG1sXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbd3BzXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLlByb2Nlc3NJc29DdXJ2ZS51cmwoa2V5KVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db21wbGV0ZS51cmwoa2V5KVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLlJldmVyc2VHZW9jb2RlLnVybChrZXkpXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQXV0b0NvbmYudXJsKGtleSlbYXBpS2V5XVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db25mLnVybChrZXkpW2FwaUtleXNdXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQXV0b0NvbmYudXJsKGtleSlbYWdncmVnYXRlXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkdlb2NvZGUudXJsKGtleSlcbi8vICBEZWZhdWx0VXJsU2VydmljZS5Sb3V0ZS51cmwoa2V5KVxuXG4vLyBFeGFtcGxlIDpcbi8vXG4vLyBEZWZhdWx0VXJsU2VydmljZS5BbHRpLnVybCgnYWx0aScpW2VsZXZhdGlvbi1qc29uXVxuLy8gIG91dHB1dCB7U3RyaW5nfSAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXG4vL1xuLy8gRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoJ2NhbGN1bCcpXG4vLyBvdXRwdXQge09iamVjdHxTdHJpbmd9XG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbi54bWxcbi8vIC0+IGh0dHA6Ly93eHMuaWduLmZyL2NhbGN1bC9hbHRpL3Jlc3QvZWxldmF0aW9uTGluZS5qc29uXG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbkxpbmUueG1sXG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS93cHNcbi8vXG4vLyBzc2wgYnkgZGVmYXVsdC5cbi8vXG4vLyBGb3JjZSB0byBub3QgZG8gc3NsIDpcbi8vIERlZmF1bHRVcmxTZXJ2aWNlLnNzbCA9IGZhbHNlO1xuLy9cbi8vIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db21wbGV0ZS51cmwoJ2NhbGN1bCcpXG4vLyBvdXRwdXQge09iamVjdHxTdHJpbmd9XG4vLyAtPiBodHRwczovL3d4cy5pZ24uZnIvY2FsY3VsL29scy9hcGlzL2NvbXBsZXRpb25cblxuLy8gY29uc3RhbnRlcyBpbnRlcm5lc1xudmFyIEhPU1ROQU1FID0gXCJ3eHMuaWduLmZyXCI7XG5cbi8qKlxuICogRGVmYXVsdCBHZW9wb3J0YWwgd2ViIHNlcnZpY2VzIFVSTHMgYWNjZXNzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5EZWZhdWx0VXJsXG4gKi9cbnZhciBEZWZhdWx0VXJsU2VydmljZSA9IHtcblxuICAgIC8qKiBpZiBzZXQgdHJ1ZSwgcmVxdWlyZSB0aGUgdXNlIG9mIGh0dHBzIHByb3RvY29sICovXG4gICAgc3NsIDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICogYmFzZSB1cmwgb2Ygc2VydmljZXMgKHNzbCBwcm90b2NvbCBtYW5hZ2VtZW50KVxuICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAqL1xuICAgIHVybCA6IGZ1bmN0aW9uIChrZXksIHBhdGgpIHtcbiAgICAgICAgLy8gY29tcG9ydGVtZW50IHBhciBkw6lmYXV0ID0+IGh0dHBzXG4gICAgICAgIC8vIHNpbm9uLCBpbCBlc3QgZml4w6kgcGFyIGwnb3B0aW9uICdzc2wnIChmYWxzZSA9PiBodHRwKVxuICAgICAgICB2YXIgX3Byb3RvY29sO1xuICAgICAgICBpZiAoRGVmYXVsdFVybFNlcnZpY2Uuc3NsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgX3Byb3RvY29sID0gXCJodHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcHJvdG9jb2wgPSBcImh0dHBzOi8vXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3Byb3RvY29sICsgSE9TVE5BTUUuY29uY2F0KFwiL1wiLCBrZXksIHBhdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbGV2YXRpb24gd2ViIHNlcnZpY2UgYWNjZXNzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXJsIChrZXkpIC0gUmV0dXJucyBlbGV2YXRpb24gc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB1c2VkIHByb3RvY29scyAoXCJlbGV2YXRpb24tanNvblwiLCBcImVsZXZhdGlvbi14bWxcIiwgXCJwcm9maWwtanNvblwiIG9yIFwicHJvZmlsLXhtbFwiKS5cbiAgICAgKi9cbiAgICBBbHRpIDoge1xuICAgICAgICBfa2V5IDoge1xuICAgICAgICAgICAgLy8gcmVzdFxuICAgICAgICAgICAgXCJlbGV2YXRpb24tanNvblwiIDogXCIvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXCIsXG4gICAgICAgICAgICBcImVsZXZhdGlvbi14bWxcIiA6IFwiL2FsdGkvcmVzdC9lbGV2YXRpb24ueG1sXCIsXG4gICAgICAgICAgICBcInByb2ZpbC1qc29uXCIgOiBcIi9hbHRpL3Jlc3QvZWxldmF0aW9uTGluZS5qc29uXCIsXG4gICAgICAgICAgICBcInByb2ZpbC14bWxcIiA6IFwiL2FsdGkvcmVzdC9lbGV2YXRpb25MaW5lLnhtbFwiLFxuICAgICAgICAgICAgLy8gb3RoZXJcbiAgICAgICAgICAgIHdwcyA6IFwiL2FsdGkvd3BzXCJcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogdXJsXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAgICAqL1xuICAgICAgICB1cmwgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIHJlc3RcbiAgICAgICAgICAgICAgICBcImVsZXZhdGlvbi1qc29uXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJlbGV2YXRpb24tanNvblwiXSksXG4gICAgICAgICAgICAgICAgXCJlbGV2YXRpb24teG1sXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJlbGV2YXRpb24teG1sXCJdKSxcbiAgICAgICAgICAgICAgICBcInByb2ZpbC1qc29uXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJwcm9maWwtanNvblwiXSksXG4gICAgICAgICAgICAgICAgXCJwcm9maWwteG1sXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJwcm9maWwteG1sXCJdKSxcbiAgICAgICAgICAgICAgICAvLyBvdGhlclxuICAgICAgICAgICAgICAgIHdwcyA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcIndwc1wiXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzb0N1cnZlIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoa2V5KSAtIFJldHVybnMgaXNvY3VydmUgc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB1c2VkIHByb3RvY29scyAoXCJpc28tanNvblwiIG9yIFwiaXNvLXhtbFwiKS5cbiAgICAgKi9cbiAgICBQcm9jZXNzSXNvQ3VydmUgOiB7XG4gICAgICAgIF9rZXkgOiBcIi9nZW9wb3J0YWlsL2lzb2Nocm9uZS9yZXN0LzEuMC4wL2lzb2Nocm9uZVwiLFxuICAgICAgICAvKipcbiAgICAgICAgKiB1cmxcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5XG4gICAgICAgICogQHJldHVybnMge1N0cmluZ30gdXJsXG4gICAgICAgICovXG4gICAgICAgIHVybCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBdXRvY29tcGxldGlvbiB3ZWIgc2VydmljZSBhY2Nlc3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cmwgKGtleSkgLSBSZXR1cm5zIGF1dG9jb21wbGV0ZSBzZXJ2aWNlIGRlZmF1bHQgdXJscyB3aXRoIG9yIHdpdGhvdXQgZ2VvcG9ydGFsIGFjY2VzcyBrZXkgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXN1bHQgaXMgYSBTdHJpbmcuXG4gICAgICovXG4gICAgQXV0b0NvbXBsZXRlIDoge1xuICAgICAgICBfa2V5IDogXCIvb2xzL2FwaXMvY29tcGxldGlvblwiLFxuICAgICAgICAvKipcbiAgICAgICAgKiB1cmxcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5XG4gICAgICAgICogQHJldHVybnMge1N0cmluZ30gdXJsXG4gICAgICAgICovXG4gICAgICAgIHVybCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXZlcnNlIGdlb2NvZGluZyB3ZWIgc2VydmljZSBhY2Nlc3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cmwgKGtleSkgLSBSZXR1cm5zIHJldmVyc2UgZ2VvY29kaW5nIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggb3Igd2l0aG91dCBnZW9wb3J0YWwgYWNjZXNzIGtleSBnaXZlbiBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIFN0cmluZy5cbiAgICAgKi9cbiAgICBSZXZlcnNlR2VvY29kZSA6IHtcbiAgICAgICAgX2tleSA6IFwiL2dlb3BvcnRhaWwvb2xzXCIsXG4gICAgICAgIC8qKlxuICAgICAgICAqIHVybFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgICAgKi9cbiAgICAgICAgdXJsIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEF1dG9jb25maWd1cmF0aW9uIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoW2tleTEsLi4uXSkgLSBSZXR1cm5zIGF1dG9jb25maWd1cmF0aW9uIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggZ2VvcG9ydGFsIGFjY2VzcyBrZXkgKHMpIGdpdmVuIGFzIGEgU3RyaW5nIGFycmF5IHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggZGlmZmVyZW50IHVybHMgZ2l2ZW4gdGhlIGFjY2VzcyBtb2RlIChcImFwaUtleVwiLCBcImFwaUtleXNcIiBvciBcImFnZ3JlZ2F0ZVwiKS5cbiAgICAgKi9cbiAgICBBdXRvQ29uZiA6IHtcbiAgICAgICAgX2tleSA6IHtcbiAgICAgICAgICAgIGFwaUtleSA6IFwiL2F1dG9jb25mXCIsXG4gICAgICAgICAgICBhcGlLZXlzIDogXCIvYXV0b2NvbmY/a2V5cz0lS0VZUyVcIixcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZSA6IFwiL2F1dG9jb25mL2lkL1wiXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHVybFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgICAgKi9cbiAgICAgICAgdXJsIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSAmJiBrZXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGtleXMgPSBrZXlbMF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyArPSBcIixcIiArIGtleVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFwaUtleSA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcImFwaUtleVwiXSksIC8vIHVuZSBzZXVsZSBjbMOpXG4gICAgICAgICAgICAgICAgYXBpS2V5cyA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXlbMF0sIHRoaXMuX2tleVtcImFwaUtleXNcIl0pLnJlcGxhY2UoXCIlS0VZUyVcIiwga2V5cyksIC8vIGF1dG9jb25mIGRlIHBsdXNpZXVycyBjbMOpc1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZSA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcImFnZ3JlZ2F0ZVwiXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlb2NvZGluZyB3ZWIgc2VydmljZSBhY2Nlc3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cmwgKGtleSkgLSBSZXR1cm5zIGdlb2NvZGluZyBzZXJ2aWNlIGRlZmF1bHQgdXJscyB3aXRoIG9yIHdpdGhvdXQgZ2VvcG9ydGFsIGFjY2VzcyBrZXkgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXN1bHQgaXMgYSBTdHJpbmcuXG4gICAgICovXG4gICAgR2VvY29kZSA6IHtcbiAgICAgICAgX2tleSA6IFwiL2dlb3BvcnRhaWwvb2xzXCIsXG4gICAgICAgIC8qKlxuICAgICAgICAqIHVybFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgICAgKi9cbiAgICAgICAgdXJsIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJvdXRpbmcgd2ViIHNlcnZpY2UgYWNjZXNzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXJsIChrZXkpIC0gUmV0dXJucyByb3V0aW5nIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggb3Igd2l0aG91dCBnZW9wb3J0YWwgYWNjZXNzIGtleSBnaXZlbiBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggZGlmZmVyZW50IHVybHMgZ2l2ZW4gdXNlZCBwcm90b2NvbHMuXG4gICAgICovXG4gICAgUm91dGUgOiB7XG4gICAgICAgIF9rZXkgOiBcIi9nZW9wb3J0YWlsL2l0aW5lcmFpcmUvcmVzdC8xLjAuMC9yb3V0ZVwiLFxuICAgICAgICAvKipcbiAgICAgICAgKiB1cmxcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5XG4gICAgICAgICogQHJldHVybnMge1N0cmluZ30gdXJsXG4gICAgICAgICovXG4gICAgICAgIHVybCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdFVybFNlcnZpY2U7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Response/model/GeocodeResponse */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js\");\n/* harmony import */ var _Response_model_GeocodedLocation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Response/model/GeocodedLocation */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js\");\n/**\n * Fonction retournant un objet contenant des clés de lecture (readers)\n *      qui permettent de parser des réponses XML du service de géocodage direct du Géoportail\n *      afin de récupérer les résultats retournés.\n * @module GeocodeResponseParser\n * @alias Gp.Services.Geocode.Formats.GeocodeResponseParser\n * @private\n */\n\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n\n\n/**\n * @classdesc\n *\n * Classe permettant de parser une réponse GeoJSON\n *\n * @constructor\n * @alias Gp.Formats.GeocodeResponseParser\n *\n * @private\n */\nfunction GeocodeResponseParser () {\n    if (!(this instanceof GeocodeResponseParser)) {\n        throw new TypeError(\"GeocodeResponseParser constructor cannot be called as a function.\");\n    }\n}\n\nGeocodeResponseParser.prototype = {\n\n    /**\n     * @lends module:GeocodeResponseParser\n     */\n\n    /*\n     * Constructeur (alias)\n     */\n    constructor : GeocodeResponseParser,\n\n    /**\n     * Méthode permettant de lancer la lecture d'une réponse GeoJSON,\n     *\n     * @param {String} json - réponse au format GeoJSON\n     * @return {Object} geocodeResponse|exceptionReport : l'objet contenant les informations de la réponse GeoJSON,\n     *      sous la forme d'un objet GeocodeResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.\n     */\n    parse : function (json) {\n        var geocodeResponse = new _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n\n        const obj = JSON.parse(json);\n\n        if (obj.type === \"FeatureCollection\") {\n            for (var i = 0; i < obj.features.length; ++i) {\n                _parseFeature(obj.features[i], geocodeResponse);\n            }\n        } else if (obj.type === \"Feature\") {\n            _parseFeature(obj, geocodeResponse);\n        } else if (obj.type === \"SERVICE_ERROR\") {\n            return _parseError(obj);\n        } else {\n            var mess = _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getMessage(\"SERVICE_RESPONSE_ANALYSE\", obj.type);\n            throw new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                message : mess,\n                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__[\"default\"].TYPE_UNKERR,\n                status : 200\n            });\n        }\n\n        return geocodeResponse;\n    }\n};\n\n/**\n * Méthode permettant de parser un feature\n *\n * @private\n *\n * @param {Object} feature\n * @param {Object} geocodeResponse\n *\n * @memberof GeocodeResponseParser\n * @return {Object} objet GeocodedLocation\n */\nfunction _parseFeature (feature, geocodeResponse) {\n    var location = new _Response_model_GeocodedLocation__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n    if (feature.geometry && feature.geometry.type === \"Point\") {\n        location.position = {\n            lon : feature.geometry.coordinates[0],\n            lat : feature.geometry.coordinates[1]\n        };\n    }\n    if (feature.properties) {\n        for (var prop in feature.properties) {\n            if (prop === \"_score\") {\n                location.accuracy = feature.properties[prop];\n            } else if (prop === \"_type\") {\n                if (feature.properties[prop] === \"address\") {\n                    location.type = \"StreetAddress\";\n                } else if (feature.properties[prop] === \"poi\") {\n                    location.type = \"PositionOfInterest\";\n                } else if (feature.properties[prop] === \"parcel\") {\n                    location.type = \"CadastralParcel\";\n                }\n            } else {\n                location.placeAttributes[prop] = feature.properties[prop];\n            }\n        }\n        if (feature.properties._type === \"address\") {\n            location.matchType = feature.properties.number !== undefined && feature.properties.number !== null ? \"street number\" : \"street\";\n        }\n    }\n    geocodeResponse.locations.push(location);\n}\n\n/**\n * Méthode permettant de parser une erreur\n *\n * @private\n *\n * @param {Object} error\n *\n * @memberof GeocodeResponseParser\n * @return {Object}\n */\nfunction _parseError (error) {\n    return {\n        exceptionReport : error\n    };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeocodeResponseParser);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvRm9ybWF0cy9HZW9jb2RlUmVzcG9uc2VQYXJzZXIuanM/MzNiMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrRDtBQUNJO0FBQ1U7QUFDRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVFQUFlOztBQUVqRDs7QUFFQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsZ0VBQUU7QUFDekIsc0JBQXNCLGdFQUFNO0FBQzVCO0FBQ0EsdUJBQXVCLGdFQUFNO0FBQzdCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSx1QkFBdUIsd0VBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxvRkFBcUIsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvR2VvY29kZS9Gb3JtYXRzL0dlb2NvZGVSZXNwb25zZVBhcnNlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRm9uY3Rpb24gcmV0b3VybmFudCB1biBvYmpldCBjb250ZW5hbnQgZGVzIGNsw6lzIGRlIGxlY3R1cmUgKHJlYWRlcnMpXG4gKiAgICAgIHF1aSBwZXJtZXR0ZW50IGRlIHBhcnNlciBkZXMgcsOpcG9uc2VzIFhNTCBkdSBzZXJ2aWNlIGRlIGfDqW9jb2RhZ2UgZGlyZWN0IGR1IEfDqW9wb3J0YWlsXG4gKiAgICAgIGFmaW4gZGUgcsOpY3Vww6lyZXIgbGVzIHLDqXN1bHRhdHMgcmV0b3VybsOpcy5cbiAqIEBtb2R1bGUgR2VvY29kZVJlc3BvbnNlUGFyc2VyXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5Gb3JtYXRzLkdlb2NvZGVSZXNwb25zZVBhcnNlclxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbmltcG9ydCBNUiBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBFcnJTcnYgZnJvbSBcIi4uLy4uLy4uL0V4Y2VwdGlvbnMvRXJyb3JTZXJ2aWNlXCI7XG5pbXBvcnQgR2VvY29kZVJlc3BvbnNlIGZyb20gXCIuLi9SZXNwb25zZS9tb2RlbC9HZW9jb2RlUmVzcG9uc2VcIjtcbmltcG9ydCBHZW9jb2RlZExvY2F0aW9uIGZyb20gXCIuLi9SZXNwb25zZS9tb2RlbC9HZW9jb2RlZExvY2F0aW9uXCI7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIENsYXNzZSBwZXJtZXR0YW50IGRlIHBhcnNlciB1bmUgcsOpcG9uc2UgR2VvSlNPTlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLkZvcm1hdHMuR2VvY29kZVJlc3BvbnNlUGFyc2VyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2VvY29kZVJlc3BvbnNlUGFyc2VyICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2VvY29kZVJlc3BvbnNlUGFyc2VyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VvY29kZVJlc3BvbnNlUGFyc2VyIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxufVxuXG5HZW9jb2RlUmVzcG9uc2VQYXJzZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpHZW9jb2RlUmVzcG9uc2VQYXJzZXJcbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IEdlb2NvZGVSZXNwb25zZVBhcnNlcixcblxuICAgIC8qKlxuICAgICAqIE3DqXRob2RlIHBlcm1ldHRhbnQgZGUgbGFuY2VyIGxhIGxlY3R1cmUgZCd1bmUgcsOpcG9uc2UgR2VvSlNPTixcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqc29uIC0gcsOpcG9uc2UgYXUgZm9ybWF0IEdlb0pTT05cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGdlb2NvZGVSZXNwb25zZXxleGNlcHRpb25SZXBvcnQgOiBsJ29iamV0IGNvbnRlbmFudCBsZXMgaW5mb3JtYXRpb25zIGRlIGxhIHLDqXBvbnNlIEdlb0pTT04sXG4gICAgICogICAgICBzb3VzIGxhIGZvcm1lIGQndW4gb2JqZXQgR2VvY29kZVJlc3BvbnNlLCBvdSB1biBvYmpldCBsaXR0w6lyYWwgZXhjZXB0aW9uUmVwb3J0IHNpIGxlIHNlcnZpY2UgYSByZW52b3nDqSB1bmUgZXhjZXB0aW9uLlxuICAgICAqL1xuICAgIHBhcnNlIDogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdmFyIGdlb2NvZGVSZXNwb25zZSA9IG5ldyBHZW9jb2RlUmVzcG9uc2UoKTtcblxuICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGpzb24pO1xuXG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5mZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIF9wYXJzZUZlYXR1cmUob2JqLmZlYXR1cmVzW2ldLCBnZW9jb2RlUmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9iai50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgICAgICAgICAgX3BhcnNlRmVhdHVyZShvYmosIGdlb2NvZGVSZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09IFwiU0VSVklDRV9FUlJPUlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BhcnNlRXJyb3Iob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXNzID0gTVIuZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfQU5BTFlTRVwiLCBvYmoudHlwZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyU3J2KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlIDogbWVzcyxcbiAgICAgICAgICAgICAgICB0eXBlIDogRXJyU3J2LlRZUEVfVU5LRVJSLFxuICAgICAgICAgICAgICAgIHN0YXR1cyA6IDIwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2VvY29kZVJlc3BvbnNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogTcOpdGhvZGUgcGVybWV0dGFudCBkZSBwYXJzZXIgdW4gZmVhdHVyZVxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBnZW9jb2RlUmVzcG9uc2VcbiAqXG4gKiBAbWVtYmVyb2YgR2VvY29kZVJlc3BvbnNlUGFyc2VyXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9iamV0IEdlb2NvZGVkTG9jYXRpb25cbiAqL1xuZnVuY3Rpb24gX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgZ2VvY29kZVJlc3BvbnNlKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbmV3IEdlb2NvZGVkTG9jYXRpb24oKTtcbiAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeSAmJiBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICBsb2NhdGlvbi5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxvbiA6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgICAgICBsYXQgOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSBcIl9zY29yZVwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uYWNjdXJhY3kgPSBmZWF0dXJlLnByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiX3R5cGVcIikge1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXNbcHJvcF0gPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnR5cGUgPSBcIlN0cmVldEFkZHJlc3NcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUucHJvcGVydGllc1twcm9wXSA9PT0gXCJwb2lcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi50eXBlID0gXCJQb3NpdGlvbk9mSW50ZXJlc3RcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUucHJvcGVydGllc1twcm9wXSA9PT0gXCJwYXJjZWxcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi50eXBlID0gXCJDYWRhc3RyYWxQYXJjZWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLnBsYWNlQXR0cmlidXRlc1twcm9wXSA9IGZlYXR1cmUucHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVhdHVyZS5wcm9wZXJ0aWVzLl90eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgbG9jYXRpb24ubWF0Y2hUeXBlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLm51bWJlciAhPT0gdW5kZWZpbmVkICYmIGZlYXR1cmUucHJvcGVydGllcy5udW1iZXIgIT09IG51bGwgPyBcInN0cmVldCBudW1iZXJcIiA6IFwic3RyZWV0XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VvY29kZVJlc3BvbnNlLmxvY2F0aW9ucy5wdXNoKGxvY2F0aW9uKTtcbn1cblxuLyoqXG4gKiBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIHBhcnNlciB1bmUgZXJyZXVyXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXJyb3JcbiAqXG4gKiBAbWVtYmVyb2YgR2VvY29kZVJlc3BvbnNlUGFyc2VyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9wYXJzZUVycm9yIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4Y2VwdGlvblJlcG9ydCA6IGVycm9yXG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VvY29kZVJlc3BvbnNlUGFyc2VyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _GeocodeRequestREST__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeocodeRequestREST */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js\");\n/**\n * Creation d'une requête\n * (Factory)\n *\n * @module GeocodeRequestFactory\n * @alias Gp.Services.Geocode.Request.GeocodeRequestFactory\n * @private\n */\n\n\n\nvar GeocodeRequestFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Geocode\n     *\n     * @example\n     *   var options = {\n     *      // options specifiques du service\n     *      geocodeMethod:\n     *      query:\n     *      filters:\n     *      maximumResponses:\n     *   };\n     *   var result = GeocodeRequestFactory.build(options);\n     *   if (!result) {\n     *       // error...\n     *   }\n     * @returns {String} request\n     */\n    build : function (options) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"GeocodeRequestFactory\");\n        logger.trace([\"GeocodeRequestFactory::build()\"]);\n\n        var settings = options || {};\n\n        var myReq = new _GeocodeRequestREST__WEBPACK_IMPORTED_MODULE_1__[\"default\"](settings);\n        if (!myReq.processRequestString()) {\n            throw new Error(\"Error process request (rest) !\");\n        }\n        var request = myReq.requestString;\n\n        logger.trace(request);\n\n        return request;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeocodeRequestFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVxdWVzdC9HZW9jb2RlUmVxdWVzdEZhY3RvcnkuanM/MTUzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29EO0FBQ0U7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQU07QUFDM0I7O0FBRUE7O0FBRUEsd0JBQXdCLDJEQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsb0ZBQXFCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVxdWVzdC9HZW9jb2RlUmVxdWVzdEZhY3RvcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0aW9uIGQndW5lIHJlcXXDqnRlXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIEdlb2NvZGVSZXF1ZXN0RmFjdG9yeVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGUuUmVxdWVzdC5HZW9jb2RlUmVxdWVzdEZhY3RvcnlcbiAqIEBwcml2YXRlXG4gKi9cbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uLy4uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IEdlb2NvZGVSZXF1ZXN0UkVTVCBmcm9tIFwiLi9HZW9jb2RlUmVxdWVzdFJFU1RcIjtcblxudmFyIEdlb2NvZGVSZXF1ZXN0RmFjdG9yeSA9IHtcblxuICAgIC8qKlxuICAgICAqIGludGVyZmFjZSB1bmlxdWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IEdlb2NvZGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIC8vIG9wdGlvbnMgc3BlY2lmaXF1ZXMgZHUgc2VydmljZVxuICAgICAqICAgICAgZ2VvY29kZU1ldGhvZDpcbiAgICAgKiAgICAgIHF1ZXJ5OlxuICAgICAqICAgICAgZmlsdGVyczpcbiAgICAgKiAgICAgIG1heGltdW1SZXNwb25zZXM6XG4gICAgICogICB9O1xuICAgICAqICAgdmFyIHJlc3VsdCA9IEdlb2NvZGVSZXF1ZXN0RmFjdG9yeS5idWlsZChvcHRpb25zKTtcbiAgICAgKiAgIGlmICghcmVzdWx0KSB7XG4gICAgICogICAgICAgLy8gZXJyb3IuLi5cbiAgICAgKiAgIH1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXF1ZXN0XG4gICAgICovXG4gICAgYnVpbGQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBsb2dnZXJcbiAgICAgICAgdmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJHZW9jb2RlUmVxdWVzdEZhY3RvcnlcIik7XG4gICAgICAgIGxvZ2dlci50cmFjZShbXCJHZW9jb2RlUmVxdWVzdEZhY3Rvcnk6OmJ1aWxkKClcIl0pO1xuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIG15UmVxID0gbmV3IEdlb2NvZGVSZXF1ZXN0UkVTVChzZXR0aW5ncyk7XG4gICAgICAgIGlmICghbXlSZXEucHJvY2Vzc1JlcXVlc3RTdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcHJvY2VzcyByZXF1ZXN0IChyZXN0KSAhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0ID0gbXlSZXEucmVxdWVzdFN0cmluZztcblxuICAgICAgICBsb2dnZXIudHJhY2UocmVxdWVzdCk7XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgR2VvY29kZVJlcXVlc3RGYWN0b3J5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _model_GeocodeParamREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/GeocodeParamREST */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js\");\n\n\n\n\n\n/**\n * @classdesc\n * Classe de gestion des requêtes de type REST sur le service de calcul d'itineraire\n * (uniquement en GET)\n *\n * @constructor\n * @alias Gp.Services.Geocode.Request.GeocodeRequestREST\n * @param {Object} options - options definies dans le composant Route\n *\n * @example\n * var options = {\n *      (...)\n * };\n *\n * @private\n */\nfunction GeocodeRequestREST (options) {\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"GeocodeRequestREST\");\n    this.logger.trace(\"[Constructeur GeocodeRequestREST ()]\");\n\n    if (!(this instanceof GeocodeRequestREST)) {\n        throw new TypeError(\"GeocodeRequestREST constructor cannot be called as a function.\");\n    }\n\n    // existance des options\n    if (!options) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_EMPTY\", \"options\"));\n    }\n\n    /** liste des options */\n    this.settings = options;\n}\n\nGeocodeRequestREST.prototype = {\n\n    /**\n     * @lends module:GeocodeRequestREST#\n     */\n\n    /**\n     * request\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : GeocodeRequestREST,\n\n    /**\n     * Construction de la requête.\n     *\n     * @returns {String} request\n     */\n    processRequestString : function () {\n        var request = \"\";\n\n        // Mapping des options avec le service de l'API REST\n        const oParams = new _model_GeocodeParamREST__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.settings);\n\n        const params = oParams.getParams();\n        for (var i = 0; i < params.length; i++) {\n            var o = params[i];\n            if (request) {\n                request += \"&\";\n            }\n            request += o.k + \"=\" + o.v;\n        }\n\n        if (!this.settings.geocodeMethod || (this.settings.geocodeMethod !== \"search\" && this.settings.geocodeMethod !== \"reverse\")) {\n            throw new Error(\"Error geocodeMethod not valid\");\n        }\n\n        this.requestString = \"?\" + request;\n        this.logger.trace(this.requestString);\n\n        return this.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeocodeRequestREST);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVxdWVzdC9HZW9jb2RlUmVxdWVzdFJFU1QuanM/MmUzOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNvRDtBQUNIO0FBQ087O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBTTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnRUFBQztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsK0RBQWdCOztBQUU1QztBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZSxpRkFBa0IsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvR2VvY29kZS9SZXF1ZXN0L0dlb2NvZGVSZXF1ZXN0UkVTVC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBHZW9jb2RlUGFyYW1SRVNUIGZyb20gXCIuL21vZGVsL0dlb2NvZGVQYXJhbVJFU1RcIjtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgcmVxdcOqdGVzIGRlIHR5cGUgUkVTVCBzdXIgbGUgc2VydmljZSBkZSBjYWxjdWwgZCdpdGluZXJhaXJlXG4gKiAodW5pcXVlbWVudCBlbiBHRVQpXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5SZXF1ZXN0Lkdlb2NvZGVSZXF1ZXN0UkVTVFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IFJvdXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBvcHRpb25zID0ge1xuICogICAgICAoLi4uKVxuICogfTtcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBHZW9jb2RlUmVxdWVzdFJFU1QgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJHZW9jb2RlUmVxdWVzdFJFU1RcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEdlb2NvZGVSZXF1ZXN0UkVTVCAoKV1cIik7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2VvY29kZVJlcXVlc3RSRVNUKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VvY29kZVJlcXVlc3RSRVNUIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gZXhpc3RhbmNlIGRlcyBvcHRpb25zXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9FTVBUWVwiLCBcIm9wdGlvbnNcIikpO1xuICAgIH1cblxuICAgIC8qKiBsaXN0ZSBkZXMgb3B0aW9ucyAqL1xuICAgIHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zO1xufVxuXG5HZW9jb2RlUmVxdWVzdFJFU1QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpHZW9jb2RlUmVxdWVzdFJFU1QjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiByZXF1ZXN0XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICByZXF1ZXN0U3RyaW5nIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBHZW9jb2RlUmVxdWVzdFJFU1QsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXF1ZXN0XG4gICAgICovXG4gICAgcHJvY2Vzc1JlcXVlc3RTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gXCJcIjtcblxuICAgICAgICAvLyBNYXBwaW5nIGRlcyBvcHRpb25zIGF2ZWMgbGUgc2VydmljZSBkZSBsJ0FQSSBSRVNUXG4gICAgICAgIGNvbnN0IG9QYXJhbXMgPSBuZXcgR2VvY29kZVBhcmFtUkVTVCh0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICBjb25zdCBwYXJhbXMgPSBvUGFyYW1zLmdldFBhcmFtcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgKz0gXCImXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0ICs9IG8uayArIFwiPVwiICsgby52O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmdlb2NvZGVNZXRob2QgfHwgKHRoaXMuc2V0dGluZ3MuZ2VvY29kZU1ldGhvZCAhPT0gXCJzZWFyY2hcIiAmJiB0aGlzLnNldHRpbmdzLmdlb2NvZGVNZXRob2QgIT09IFwicmV2ZXJzZVwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZ2VvY29kZU1ldGhvZCBub3QgdmFsaWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlcXVlc3RTdHJpbmcgPSBcIj9cIiArIHJlcXVlc3Q7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKHRoaXMucmVxdWVzdFN0cmluZyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0cmluZztcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW9jb2RlUmVxdWVzdFJFU1Q7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n\n\n\n/**\n * @classdesc\n * Classe de gestion des param. des requêtes du service de calcul d'itineraire (REST).\n *      Permet le mapping avec les options du service.\n * @constructor\n * @alias Gp.Services.Route.Request.RouteParamREST\n * @param {Object} options - options\n *\n * @private\n */\nfunction GeocodeParamREST (options) {\n    if (!(this instanceof GeocodeParamREST)) {\n        throw new TypeError(\"GeocodeParamREST constructor cannot be called as a function.\");\n    }\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger();\n    this.logger.trace(\"[Constructeur GeocodeParamREST ()]\");\n\n    /**\n     * Options en paramêtres du constructeur.\n     */\n    this.options = options || {};\n\n    // methode de geocodage\n    if (!this.options.geocodeMethod || (this.options.geocodeMethod !== \"search\" && this.options.geocodeMethod !== \"reverse\")) {\n        throw new Error(\"Error geocodeMethod not valid\");\n    }\n    this.geocodeMethod = this.options.geocodeMethod;\n\n    // mapping des options avec l'API REST\n    this.query = (typeof this.options !== \"undefined\") ? this.options.query : null;\n\n    this.searchGeometry = this.options.searchGeometry || null;\n\n    this.index = this.options.index || null;\n\n    this.lon = this.options.position && this.options.position.lon ? this.options.position.lon : null;\n\n    this.lat = this.options.position && this.options.position.lat ? this.options.position.lat : null;\n\n    this.maxResp = this.options.maxResp || null;\n\n    this.returnTrueGeometry = this.options.returnTrueGeometry || null;\n\n    this.filters = this.options.filters || {};\n}\n\n/**\n * CLASSNAME\n */\nGeocodeParamREST.CLASSNAME = \"GeocodeParamREST\";\n\nGeocodeParamREST.prototype = {\n\n    /**\n     * @lends module:GeocodeParamREST#\n     */\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : GeocodeParamREST,\n\n    /**\n     * Retourne les filtres\n     * @returns {String} les filtres\n     */\n    getFilters : function () {\n        var filters = {};\n        for (var prop in this.filters) {\n            if (this.filters.hasOwnProperty(prop)) {\n                filters[prop] = this.filters[prop];\n            }\n        }\n        return filters;\n    },\n\n    /**\n     * Retourne l'index\n     * @returns {String} l'index\n     */\n    getIndex : function () {\n        if (this.index === undefined) {\n            return null;\n        }\n        if (this.index === \"StreetAddress\") {\n            return \"address\";\n        } else if (this.index === \"CadastralParcel\") {\n            return \"parcel\";\n        } else if (this.index === \"PositionOfInterest\") {\n            return \"poi\";\n        } else if (this.index === \"location\") {\n            return \"location\";\n        }\n        return this.index;\n    },\n\n    /**\n     * Retourne la géométrie de recherche\n     * @returns {String} la géométrie de recherche au format json\n     */\n    getSearchGeometry : function () {\n        return JSON.stringify(this.searchGeometry);\n    }\n};\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Array} liste de paramêtres\n */\nGeocodeParamREST.prototype.getParams = function () {\n    var map = [];\n\n    if (this.geocodeMethod === \"search\") {\n        map.push({\n            k : \"q\",\n            v : this.query\n        });\n    }\n\n    if (this.index) {\n        map.push({\n            k : \"index\",\n            v : this.getIndex()\n        });\n    }\n\n    if (this.geocodeMethod === \"reverse\") {\n        map.push({\n            k : \"searchgeom\",\n            v : this.getSearchGeometry()\n        });\n    }\n\n    if (this.lon && this.lat) {\n        map.push({\n            k : \"lon\",\n            v : this.lon\n        });\n        map.push({\n            k : \"lat\",\n            v : this.lat\n        });\n    }\n\n    if (this.maxResp) {\n        map.push({\n            k : \"limit\",\n            v : this.maxResp\n        });\n    }\n\n    if (this.returnTrueGeometry) {\n        map.push({\n            k : \"returntruegeometry\",\n            v : this.returnTrueGeometry\n        });\n    }\n\n    const filters = this.getFilters();\n    for (var key in filters) {\n        map.push({\n            k : key,\n            v : filters[key]\n        });\n    }\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeocodeParamREST);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVxdWVzdC9tb2RlbC9HZW9jb2RlUGFyYW1SRVNULmpzPzI1MjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ3VEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDhEQUFNO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRWUsK0VBQWdCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVxdWVzdC9tb2RlbC9HZW9jb2RlUGFyYW1SRVNULmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgcGFyYW0uIGRlcyByZXF1w6p0ZXMgZHUgc2VydmljZSBkZSBjYWxjdWwgZCdpdGluZXJhaXJlIChSRVNUKS5cbiAqICAgICAgUGVybWV0IGxlIG1hcHBpbmcgYXZlYyBsZXMgb3B0aW9ucyBkdSBzZXJ2aWNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuUm91dGUuUmVxdWVzdC5Sb3V0ZVBhcmFtUkVTVFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2VvY29kZVBhcmFtUkVTVCAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHZW9jb2RlUGFyYW1SRVNUKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VvY29kZVBhcmFtUkVTVCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBHZW9jb2RlUGFyYW1SRVNUICgpXVwiKTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgZW4gcGFyYW3DqnRyZXMgZHUgY29uc3RydWN0ZXVyLlxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBtZXRob2RlIGRlIGdlb2NvZGFnZVxuICAgIGlmICghdGhpcy5vcHRpb25zLmdlb2NvZGVNZXRob2QgfHwgKHRoaXMub3B0aW9ucy5nZW9jb2RlTWV0aG9kICE9PSBcInNlYXJjaFwiICYmIHRoaXMub3B0aW9ucy5nZW9jb2RlTWV0aG9kICE9PSBcInJldmVyc2VcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZ2VvY29kZU1ldGhvZCBub3QgdmFsaWRcIik7XG4gICAgfVxuICAgIHRoaXMuZ2VvY29kZU1ldGhvZCA9IHRoaXMub3B0aW9ucy5nZW9jb2RlTWV0aG9kO1xuXG4gICAgLy8gbWFwcGluZyBkZXMgb3B0aW9ucyBhdmVjIGwnQVBJIFJFU1RcbiAgICB0aGlzLnF1ZXJ5ID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMgIT09IFwidW5kZWZpbmVkXCIpID8gdGhpcy5vcHRpb25zLnF1ZXJ5IDogbnVsbDtcblxuICAgIHRoaXMuc2VhcmNoR2VvbWV0cnkgPSB0aGlzLm9wdGlvbnMuc2VhcmNoR2VvbWV0cnkgfHwgbnVsbDtcblxuICAgIHRoaXMuaW5kZXggPSB0aGlzLm9wdGlvbnMuaW5kZXggfHwgbnVsbDtcblxuICAgIHRoaXMubG9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uICYmIHRoaXMub3B0aW9ucy5wb3NpdGlvbi5sb24gPyB0aGlzLm9wdGlvbnMucG9zaXRpb24ubG9uIDogbnVsbDtcblxuICAgIHRoaXMubGF0ID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uICYmIHRoaXMub3B0aW9ucy5wb3NpdGlvbi5sYXQgPyB0aGlzLm9wdGlvbnMucG9zaXRpb24ubGF0IDogbnVsbDtcblxuICAgIHRoaXMubWF4UmVzcCA9IHRoaXMub3B0aW9ucy5tYXhSZXNwIHx8IG51bGw7XG5cbiAgICB0aGlzLnJldHVyblRydWVHZW9tZXRyeSA9IHRoaXMub3B0aW9ucy5yZXR1cm5UcnVlR2VvbWV0cnkgfHwgbnVsbDtcblxuICAgIHRoaXMuZmlsdGVycyA9IHRoaXMub3B0aW9ucy5maWx0ZXJzIHx8IHt9O1xufVxuXG4vKipcbiAqIENMQVNTTkFNRVxuICovXG5HZW9jb2RlUGFyYW1SRVNULkNMQVNTTkFNRSA9IFwiR2VvY29kZVBhcmFtUkVTVFwiO1xuXG5HZW9jb2RlUGFyYW1SRVNULnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBsZW5kcyBtb2R1bGU6R2VvY29kZVBhcmFtUkVTVCNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBHZW9jb2RlUGFyYW1SRVNULFxuXG4gICAgLyoqXG4gICAgICogUmV0b3VybmUgbGVzIGZpbHRyZXNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBsZXMgZmlsdHJlc1xuICAgICAqL1xuICAgIGdldEZpbHRlcnMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJzID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyc1twcm9wXSA9IHRoaXMuZmlsdGVyc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0b3VybmUgbCdpbmRleFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGwnaW5kZXhcbiAgICAgKi9cbiAgICBnZXRJbmRleCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IFwiU3RyZWV0QWRkcmVzc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhZGRyZXNzXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmRleCA9PT0gXCJDYWRhc3RyYWxQYXJjZWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwicGFyY2VsXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmRleCA9PT0gXCJQb3NpdGlvbk9mSW50ZXJlc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwicG9pXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmRleCA9PT0gXCJsb2NhdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsb2NhdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRvdXJuZSBsYSBnw6lvbcOpdHJpZSBkZSByZWNoZXJjaGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBsYSBnw6lvbcOpdHJpZSBkZSByZWNoZXJjaGUgYXUgZm9ybWF0IGpzb25cbiAgICAgKi9cbiAgICBnZXRTZWFyY2hHZW9tZXRyeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuc2VhcmNoR2VvbWV0cnkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGFibGVhdSBkZSBjbGVmcy92YWxldXJzIHBvdXIgcGFyYW0uXG4gKlxuICogQHJldHVybnMge0FycmF5fSBsaXN0ZSBkZSBwYXJhbcOqdHJlc1xuICovXG5HZW9jb2RlUGFyYW1SRVNULnByb3RvdHlwZS5nZXRQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZ2VvY29kZU1ldGhvZCA9PT0gXCJzZWFyY2hcIikge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJxXCIsXG4gICAgICAgICAgICB2IDogdGhpcy5xdWVyeVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmRleCkge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJpbmRleFwiLFxuICAgICAgICAgICAgdiA6IHRoaXMuZ2V0SW5kZXgoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZW9jb2RlTWV0aG9kID09PSBcInJldmVyc2VcIikge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJzZWFyY2hnZW9tXCIsXG4gICAgICAgICAgICB2IDogdGhpcy5nZXRTZWFyY2hHZW9tZXRyeSgpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvbiAmJiB0aGlzLmxhdCkge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJsb25cIixcbiAgICAgICAgICAgIHYgOiB0aGlzLmxvblxuICAgICAgICB9KTtcbiAgICAgICAgbWFwLnB1c2goe1xuICAgICAgICAgICAgayA6IFwibGF0XCIsXG4gICAgICAgICAgICB2IDogdGhpcy5sYXRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF4UmVzcCkge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJsaW1pdFwiLFxuICAgICAgICAgICAgdiA6IHRoaXMubWF4UmVzcFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXR1cm5UcnVlR2VvbWV0cnkpIHtcbiAgICAgICAgbWFwLnB1c2goe1xuICAgICAgICAgICAgayA6IFwicmV0dXJudHJ1ZWdlb21ldHJ5XCIsXG4gICAgICAgICAgICB2IDogdGhpcy5yZXR1cm5UcnVlR2VvbWV0cnlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVycyA9IHRoaXMuZ2V0RmlsdGVycygpO1xuICAgIGZvciAodmFyIGtleSBpbiBmaWx0ZXJzKSB7XG4gICAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgICAgIGsgOiBrZXksXG4gICAgICAgICAgICB2IDogZmlsdGVyc1trZXldXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW9jb2RlUGFyYW1SRVNUO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Formats_GeocodeResponseParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Formats/GeocodeResponseParser */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js\");\n/**\n * Factory pour générer une reponse JSON à partir d'un XML\n * (Factory)\n *\n * @module GeocodeResponseFactory\n * @alias Gp.Services.Geocode.Response.GeocodeResponseFactory\n * @private\n */\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n\nvar GeocodeReponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Geocode\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // data de type GeocodeResponse\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                data = options.response;\n            } else {\n                try {\n                    const parser = new _Formats_GeocodeResponseParser__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n                    data = parser.parse(options.response);\n\n                    if (!data) {\n                        throw new Error(\"L'analyse de la réponse du service !?\");\n                    }\n                } catch (e) {\n                    var message = e.message;\n                    if (typeof options.response === \"string\") {\n                        message += \"('\" + options.response + \"')\";\n                    } else {\n                        message += \"('\" + options.response.documentElement.innerHTML + \"')\";\n                    }\n                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_ANALYSE\", message),\n                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_UNKERR,\n                        status : -1\n                    }));\n                    return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service\n                if (data.exceptionReport) {\n                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_SRVERR,\n                        status : 200 // FIXME : 200 ?\n                    }));\n                    return;\n                }\n            }\n        } else {\n            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EMPTY\"),\n                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_SRVERR,\n                status : -1 // FIXME : status response\n            }));\n            return;\n        }\n\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeocodeReponseFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVzcG9uc2UvR2VvY29kZVJlc3BvbnNlRmFjdG9yeS5qcz85YjdiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzREO0FBQ1I7QUFDaUI7O0FBRXJFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1Q0FBdUMsc0VBQXFCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDREQUE0RCxnRUFBWTtBQUN4RSxrQ0FBa0MsZ0VBQUk7QUFDdEMsK0JBQStCLGdFQUFZO0FBQzNDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RCxnRUFBWTtBQUN4RSxrQ0FBa0MsZ0VBQUk7QUFDdEMsK0JBQStCLGdFQUFZO0FBQzNDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvREFBb0QsZ0VBQVk7QUFDaEUsMEJBQTBCLGdFQUFJO0FBQzlCLHVCQUF1QixnRUFBWTtBQUNuQztBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZSxvRkFBcUIsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvR2VvY29kZS9SZXNwb25zZS9HZW9jb2RlUmVzcG9uc2VGYWN0b3J5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGYWN0b3J5IHBvdXIgZ8OpbsOpcmVyIHVuZSByZXBvbnNlIEpTT04gw6AgcGFydGlyIGQndW4gWE1MXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIEdlb2NvZGVSZXNwb25zZUZhY3RvcnlcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5HZW9jb2RlLlJlc3BvbnNlLkdlb2NvZGVSZXNwb25zZUZhY3RvcnlcbiAqIEBwcml2YXRlXG4gKi9cbi8vIGltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uLy4uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IEVycm9yU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vRXhjZXB0aW9ucy9FcnJvclNlcnZpY2VcIjtcbmltcG9ydCBNUmVzIGZyb20gXCIuLi8uLi8uLi9VdGlscy9NZXNzYWdlc1Jlc291cmNlc1wiO1xuaW1wb3J0IEdlb2NvZGVSZXNwb25zZVBhcnNlciBmcm9tIFwiLi4vRm9ybWF0cy9HZW9jb2RlUmVzcG9uc2VQYXJzZXJcIjtcblxudmFyIEdlb2NvZGVSZXBvbnNlRmFjdG9yeSA9IHtcblxuICAgIC8qKlxuICAgICAqIGludGVyZmFjZSB1bmlxdWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IEdlb2NvZGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIHJlc3BvbnNlIDpcbiAgICAgKiAgICAgIHJhd1Jlc3BvbnNlIDpcbiAgICAgKiAgICAgIHNjb3BlIDpcbiAgICAgKiAgICAgIG9uU3VjY2VzcyA6XG4gICAgICogICAgICBvbkVycm9yIDpcbiAgICAgKiAgIH07XG4gICAgICpcbiAgICAgKi9cbiAgICBidWlsZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGRhdGEgZGUgdHlwZSBHZW9jb2RlUmVzcG9uc2VcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yYXdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgR2VvY29kZVJlc3BvbnNlUGFyc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwYXJzZXIucGFyc2Uob3B0aW9ucy5yZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMJ2FuYWx5c2UgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSAhP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIignXCIgKyBvcHRpb25zLnJlc3BvbnNlICsgXCInKVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIignXCIgKyBvcHRpb25zLnJlc3BvbnNlLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgKyBcIicpXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IEVycm9yU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogTVJlcy5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9BTkFMWVNFXCIsIG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IEVycm9yU2VydmljZS5UWVBFX1VOS0VSUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IC0xXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNpIGxhIHLDqXBvbnNlIGNvbnRlbmFpdCB1bmUgZXhjZXB0aW9uIHJlbnZvecOpZSBwYXIgbGUgc2VydmljZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmV4Y2VwdGlvblJlcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgRXJyb3JTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBNUmVzLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBkYXRhLmV4Y2VwdGlvblJlcG9ydCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogRXJyb3JTZXJ2aWNlLlRZUEVfU1JWRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogMjAwIC8vIEZJWE1FIDogMjAwID9cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IEVycm9yU2VydmljZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA6IE1SZXMuZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRU1QVFlcIiksXG4gICAgICAgICAgICAgICAgdHlwZSA6IEVycm9yU2VydmljZS5UWVBFX1NSVkVSUixcbiAgICAgICAgICAgICAgICBzdGF0dXMgOiAtMSAvLyBGSVhNRSA6IHN0YXR1cyByZXNwb25zZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MuY2FsbChvcHRpb25zLnNjb3BlLCBkYXRhKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW9jb2RlUmVwb25zZUZhY3Rvcnk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n/**\n * Response object for {@link module:Services~geocode Gp.Services.geocode ()} or {@link module:Services~reverseGeocode Gp.Services.reverseGeocode ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Array.<Gp.Services.Geocode.GeocodedLocation>} locations - locations array.\n *\n * @namespace\n * @alias Gp.Services.GeocodeResponse\n */\nfunction GeocodeResponse () {\n    if (!(this instanceof GeocodeResponse)) {\n        throw new TypeError(\"GeocodeResponse constructor cannot be called as a function.\");\n    }\n\n    this.locations = [];\n}\n\nGeocodeResponse.prototype = {\n\n    constructor : GeocodeResponse\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeocodeResponse);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVzcG9uc2UvbW9kZWwvR2VvY29kZVJlc3BvbnNlLmpzP2VhNDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQsS0FBSyxtRUFBbUU7QUFDcko7QUFDQSxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRWUsOEVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvR2VvY29kZS9SZXNwb25zZS9tb2RlbC9HZW9jb2RlUmVzcG9uc2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogUmVzcG9uc2Ugb2JqZWN0IGZvciB7QGxpbmsgbW9kdWxlOlNlcnZpY2Vzfmdlb2NvZGUgR3AuU2VydmljZXMuZ2VvY29kZSAoKX0gb3Ige0BsaW5rIG1vZHVsZTpTZXJ2aWNlc35yZXZlcnNlR2VvY29kZSBHcC5TZXJ2aWNlcy5yZXZlcnNlR2VvY29kZSAoKX0gaW52b2NhdGlvbiB3aGVuIHN1Y2Nlc3NmdWwuIFJlY2VpdmVkIGFzIHRoZSBhcmd1bWVudCBvZiBvblN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48R3AuU2VydmljZXMuR2VvY29kZS5HZW9jb2RlZExvY2F0aW9uPn0gbG9jYXRpb25zIC0gbG9jYXRpb25zIGFycmF5LlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5HZW9jb2RlUmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gR2VvY29kZVJlc3BvbnNlICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2VvY29kZVJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VvY29kZVJlc3BvbnNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5sb2NhdGlvbnMgPSBbXTtcbn1cblxuR2VvY29kZVJlc3BvbnNlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogR2VvY29kZVJlc3BvbnNlXG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdlb2NvZGVSZXNwb25zZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n/**\n * Single location object returned by the underlying geocoding web service.\n *\n * @property {Gp.Point} position - Position of the location given in the requested coordinates system.\n * @property {String} type - location type \"StreetAddress\" (for an address), \"PositionOfInterest\" (for a place name) or \"CadastralParcel\" (for cadastral parcel).\n * @property {String} matchType - how geocoding is performed : \"street number\" (exact address), \"street enhanced\" (street number calculated by interpolation), \"street\" (only the street), \"city\" (only the city).\n * @property {Float} accuracy - Accuracy of the response towards the requested location between 0 (unaccurate) and 1 (exact match).\n * @property {Object} placeAttributes - Associative array matching the following attributes with their values given by the underlying web service :\n *\n * *Common attributes : *\n *\n * - **trueGeometry** - the 'real life' geometry if different from 'Point' type.\n *\n * *if type === \"StreetAddress\" :*\n *\n * - **number** - Street number.\n * - **postalCode** - PostCode\n * - **street** - Street name\n * - **city** - City\n * - **houseNumberInfos** - additional street number information\n * - **inseeCode** - INSEE Code\n *\n *\n * *if type === \"PositionOfInterest\" :*\n *\n * - **type** - Place name type\n * - **postalCode** - PostCode\n * - **toponyme** - Toponyme\n * - **extraFields** - additional place name properties\n * - **inseeCode** - INSEE Code\n *\n *\n * *si type = \"CadastralParcel\" :*\n *\n * - **codeCommuneAbs** - when a parcel comes from a city that was absorbed by another, code of that old city. \"000\" otherwise.\n * - **codeArrondissement** - arrondissement\n * - **identifiant** - cadastral parcel code\n * - **feuille** - Parcel Sheet (eg. \"1\").\n * - **numero** - Parcel Number (eg. \"0041\")\n * - **section** - Parcel Section (eg. \"0D\").\n * - **nomCommune** - Parcel municipality name.\n * - **codeCommune** - Parcel municipality.\n * - **codeDepartement** - Parcel Department.\n *\n * @namespace\n * @alias Gp.Services.Geocode.GeocodedLocation\n */\nfunction GeocodedLocation () {\n    if (!(this instanceof GeocodedLocation)) {\n        throw new TypeError(\"GeocodedLocation constructor cannot be called as a function.\");\n    }\n\n    this.position = null;\n\n    this.matchType = null;\n\n    this.placeAttributes = {};\n\n    this.type = null;\n\n    this.accuracy = null;\n\n    /**\n     * Nom de la classe : \"GeocodedLocation\"\n     * @type {String}\n     */\n    this.CLASSNAME = \"GeocodedLocation\";\n}\n\nGeocodedLocation.prototype = {\n\n    constructor : GeocodedLocation\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeocodedLocation);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmVzcG9uc2UvbW9kZWwvR2VvY29kZWRMb2NhdGlvbi5qcz83NmQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFZSwrRUFBZ0IsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvR2VvY29kZS9SZXNwb25zZS9tb2RlbC9HZW9jb2RlZExvY2F0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFNpbmdsZSBsb2NhdGlvbiBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIHVuZGVybHlpbmcgZ2VvY29kaW5nIHdlYiBzZXJ2aWNlLlxuICpcbiAqIEBwcm9wZXJ0eSB7R3AuUG9pbnR9IHBvc2l0aW9uIC0gUG9zaXRpb24gb2YgdGhlIGxvY2F0aW9uIGdpdmVuIGluIHRoZSByZXF1ZXN0ZWQgY29vcmRpbmF0ZXMgc3lzdGVtLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgLSBsb2NhdGlvbiB0eXBlIFwiU3RyZWV0QWRkcmVzc1wiIChmb3IgYW4gYWRkcmVzcyksIFwiUG9zaXRpb25PZkludGVyZXN0XCIgKGZvciBhIHBsYWNlIG5hbWUpIG9yIFwiQ2FkYXN0cmFsUGFyY2VsXCIgKGZvciBjYWRhc3RyYWwgcGFyY2VsKS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtYXRjaFR5cGUgLSBob3cgZ2VvY29kaW5nIGlzIHBlcmZvcm1lZCA6IFwic3RyZWV0IG51bWJlclwiIChleGFjdCBhZGRyZXNzKSwgXCJzdHJlZXQgZW5oYW5jZWRcIiAoc3RyZWV0IG51bWJlciBjYWxjdWxhdGVkIGJ5IGludGVycG9sYXRpb24pLCBcInN0cmVldFwiIChvbmx5IHRoZSBzdHJlZXQpLCBcImNpdHlcIiAob25seSB0aGUgY2l0eSkuXG4gKiBAcHJvcGVydHkge0Zsb2F0fSBhY2N1cmFjeSAtIEFjY3VyYWN5IG9mIHRoZSByZXNwb25zZSB0b3dhcmRzIHRoZSByZXF1ZXN0ZWQgbG9jYXRpb24gYmV0d2VlbiAwICh1bmFjY3VyYXRlKSBhbmQgMSAoZXhhY3QgbWF0Y2gpLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHBsYWNlQXR0cmlidXRlcyAtIEFzc29jaWF0aXZlIGFycmF5IG1hdGNoaW5nIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyB3aXRoIHRoZWlyIHZhbHVlcyBnaXZlbiBieSB0aGUgdW5kZXJseWluZyB3ZWIgc2VydmljZSA6XG4gKlxuICogKkNvbW1vbiBhdHRyaWJ1dGVzIDogKlxuICpcbiAqIC0gKip0cnVlR2VvbWV0cnkqKiAtIHRoZSAncmVhbCBsaWZlJyBnZW9tZXRyeSBpZiBkaWZmZXJlbnQgZnJvbSAnUG9pbnQnIHR5cGUuXG4gKlxuICogKmlmIHR5cGUgPT09IFwiU3RyZWV0QWRkcmVzc1wiIDoqXG4gKlxuICogLSAqKm51bWJlcioqIC0gU3RyZWV0IG51bWJlci5cbiAqIC0gKipwb3N0YWxDb2RlKiogLSBQb3N0Q29kZVxuICogLSAqKnN0cmVldCoqIC0gU3RyZWV0IG5hbWVcbiAqIC0gKipjaXR5KiogLSBDaXR5XG4gKiAtICoqaG91c2VOdW1iZXJJbmZvcyoqIC0gYWRkaXRpb25hbCBzdHJlZXQgbnVtYmVyIGluZm9ybWF0aW9uXG4gKiAtICoqaW5zZWVDb2RlKiogLSBJTlNFRSBDb2RlXG4gKlxuICpcbiAqICppZiB0eXBlID09PSBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiIDoqXG4gKlxuICogLSAqKnR5cGUqKiAtIFBsYWNlIG5hbWUgdHlwZVxuICogLSAqKnBvc3RhbENvZGUqKiAtIFBvc3RDb2RlXG4gKiAtICoqdG9wb255bWUqKiAtIFRvcG9ueW1lXG4gKiAtICoqZXh0cmFGaWVsZHMqKiAtIGFkZGl0aW9uYWwgcGxhY2UgbmFtZSBwcm9wZXJ0aWVzXG4gKiAtICoqaW5zZWVDb2RlKiogLSBJTlNFRSBDb2RlXG4gKlxuICpcbiAqICpzaSB0eXBlID0gXCJDYWRhc3RyYWxQYXJjZWxcIiA6KlxuICpcbiAqIC0gKipjb2RlQ29tbXVuZUFicyoqIC0gd2hlbiBhIHBhcmNlbCBjb21lcyBmcm9tIGEgY2l0eSB0aGF0IHdhcyBhYnNvcmJlZCBieSBhbm90aGVyLCBjb2RlIG9mIHRoYXQgb2xkIGNpdHkuIFwiMDAwXCIgb3RoZXJ3aXNlLlxuICogLSAqKmNvZGVBcnJvbmRpc3NlbWVudCoqIC0gYXJyb25kaXNzZW1lbnRcbiAqIC0gKippZGVudGlmaWFudCoqIC0gY2FkYXN0cmFsIHBhcmNlbCBjb2RlXG4gKiAtICoqZmV1aWxsZSoqIC0gUGFyY2VsIFNoZWV0IChlZy4gXCIxXCIpLlxuICogLSAqKm51bWVybyoqIC0gUGFyY2VsIE51bWJlciAoZWcuIFwiMDA0MVwiKVxuICogLSAqKnNlY3Rpb24qKiAtIFBhcmNlbCBTZWN0aW9uIChlZy4gXCIwRFwiKS5cbiAqIC0gKipub21Db21tdW5lKiogLSBQYXJjZWwgbXVuaWNpcGFsaXR5IG5hbWUuXG4gKiAtICoqY29kZUNvbW11bmUqKiAtIFBhcmNlbCBtdW5pY2lwYWxpdHkuXG4gKiAtICoqY29kZURlcGFydGVtZW50KiogLSBQYXJjZWwgRGVwYXJ0bWVudC5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5HZW9jb2RlZExvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIEdlb2NvZGVkTG9jYXRpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHZW9jb2RlZExvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VvY29kZWRMb2NhdGlvbiBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy5tYXRjaFR5cGUgPSBudWxsO1xuXG4gICAgdGhpcy5wbGFjZUF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHRoaXMudHlwZSA9IG51bGw7XG5cbiAgICB0aGlzLmFjY3VyYWN5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE5vbSBkZSBsYSBjbGFzc2UgOiBcIkdlb2NvZGVkTG9jYXRpb25cIlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIkdlb2NvZGVkTG9jYXRpb25cIjtcbn1cblxuR2VvY29kZWRMb2NhdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IEdlb2NvZGVkTG9jYXRpb25cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgR2VvY29kZWRMb2NhdGlvbjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CommonService */ \"./node_modules/geoportal-access-lib/src/Services/CommonService.js\");\n/* harmony import */ var _Request_GeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Request/GeocodeRequestFactory */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js\");\n/* harmony import */ var _Response_GeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Response/GeocodeResponseFactory */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js\");\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Appel du service de géocodage inverse du Géoportail :\n *     envoi de la requête construite selon les paramètres en options,\n *     éventuellement parsing et analyse  de la réponse,\n *     retour d'une réponse en paramètre de la fonction onSuccess.\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.ReverseGeocode\n *\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {Object} options.position - Position du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs.\n *      @param {Float} options.position.lon - Longitude du point de référence pour le calcul de proximité.\n *      @param {Float} options.position.lat - Latitude du point de référence pour le calcul de proximité.\n *\n * @param {Object} [options.filters] - Les propriétés possibles de cet objet.\n * @param {String} [options.filters.[proprietes du filtre]] - Critère supplémentaire pour filtrer la recherche sous la forme\n *      d'un couple clé/valeur à définir selon les possibilités du serveur ajouté à la requête.\n *      Le service de géocodage du Géoportail permet de filtrer les adresses postales avec les propriétés :\n *          \"postalCode\", \"inseeCode\", \"city\".\n *      Il permet également de filtrer les toponymes avec les propriétés :\n *          \"postalCode\", \"inseeCode\", \"type\".\n *      Enfin, il permet de filtrer les parcelles cadastrales avec les propriétés :\n *          \"codeDepartement\", \"codeCommune\", \"nomCommune\", \"codeCommuneAbs\", \"codeArrondissement\", \"section\", \"numero\", \"feuille\".\n *\n * @param {Object} [options.searchGeometry] - Emprise dans laquelle on souhaite effectuer la recherche.\n *      Les propriétés possibles de cet objet sont décrites ci-après.\n *      @param {String} options.searchGeometry.type   - Type de géometrie (Point|Circle|Linestring|Polygon)\n *      @param {Array.<Float>|Array.Array.<Float>} options.searchGeometry.coordinates - Coordonnées des points constituant la géométrie.\n *      @param {Float} options.searchGeometry.radius    - Rayon. Paramètre applicable uniquement pour le type 'Circle'.\n *\n * @param {String} [options.index = \"StreetAddress\"] - Type de l'objet recherché.\n *      Le service de géocodage du Géoportail permet de rechercher des 'PositionOfInterest' pour des toponymes, des 'StreetAddress'\n *      pour des adresses postales ou des 'CadastralParcel' pour des parcelles cadastrales. L'index 'location' permet une recherche\n *      multi-indexes en regroupant les indexes 'PositionOfInterest' et 'StreetAddress'.\n *      D'autres types pourront être rajoutés selon l'évolution du service.\n *      Par défaut, index = 'StreetAddress'.\n *\n * @param {Number} [options.maximumResponses] - Nombre de réponses maximal que l'on souhaite recevoir.\n *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 20s.\n *\n * @param {Boolean} [options.returnTrueGeometry] - Booléen indiquant si l'on souhaite récupérer la géométrie vraie des objects géolocalisés.\n *      false par défaut.\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      proxyURL : null,\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      index : 'StreetAddress',\n *      searchGeometry : {\n *          type : Circle,\n *          coordinates : [48, 2],\n *          radius : 100\n *      },\n *      position : {lon:2 , lat:48.5},\n *      maximumResponses : 25,\n *   };\n *\n * @private\n */\nfunction ReverseGeocode (options_) {\n    if (!(this instanceof ReverseGeocode)) {\n        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"CLASS_CONSTRUCTOR\", \"ReverseGeocode\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"ReverseGeocode\";\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"Gp.Services.ReverseGeocode\");\n    this.logger.trace(\"[Constructeur ReverseGeocode (options)]\");\n\n    var options = this.patchOptionConvertor(options_);\n    options.serverUrl = options.serverUrl || \"https://wxs.ign.fr/calcul/geoportail/geocodage/rest/0.1/reverse\";\n\n    // appel du constructeur par heritage\n    _CommonService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].apply(this, [options]);\n\n    if (!options.searchGeometry) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_MISSING\", \"searchGeometry\"));\n    }\n\n    // ajout des options spécifiques au service\n    this.options.searchGeometry = options.searchGeometry;\n\n    // on definit l'index par defaut\n    if (!options.index) {\n        this.options.index = options.index = \"StreetAddress\";\n    }\n\n    if (options.filters) {\n        var filter = Object.keys(options.filters);\n        for (var i = 0; i < filter.length; i++) {\n            var key = filter[i];\n            // on supprime les filtres vides\n            if (typeof options.filters[key] === \"undefined\" ||\n                (typeof options.filters[key] === \"object\" && Object.keys(options.filters[key]).length === 0) ||\n                (typeof options.filters[key] === \"string\" && options.filters[key].length === 0) ||\n                (Array.isArray(options.filters[key]) && options.filters[key].length === 0)\n            ) {\n                delete this.options.filters[key];\n            }\n        }\n    }\n\n    this.options.position = options.position;\n    this.options.index = options.index || \"StreetAddress\";\n    this.options.maximumResponses = options.maximumResponses || 20;\n}\n\n/**\n * @lends module:ReverseGeocode#\n */\nReverseGeocode.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype, {\n    // todo\n    // getter/setter\n});\n\n/*\n * Constructeur (alias)\n */\nReverseGeocode.prototype.constructor = ReverseGeocode;\n\n/**\n * Patch pour la convertion des options vers le nouveau formalisme.\n *\n * @param {Object} options_ - options du service\n * @return {Object} - options\n */\nReverseGeocode.prototype.patchOptionConvertor = function (options_) {\n    var options = options_;\n\n    if (options.filterOptions) {\n        this.logger.warn(\"The parameter 'filterOptions' is deprecated\");\n\n        if (options.filterOptions.type) {\n            this.logger.warn(\"The parameter 'filterOptions.type' is deprecated\");\n            if (!options.index) {\n                if (Array.isArray(options.filterOptions.type) && options.filterOptions.type.length > 0) {\n                    options.index = options.filterOptions.type[0];\n                } else {\n                    options.index = options.filterOptions.type;\n                }\n            }\n            delete options.filterOptions.type;\n        }\n\n        if (options.filterOptions.bbox) {\n            this.logger.warn(\"The parameter 'filterOptions.bbox' is deprecated\");\n            if (!options.searchGeometry) {\n                // convertir la geometrie\n                options.searchGeometry = this.bbox2Json(options.filterOptions.bbox);\n            }\n            delete options.filterOptions.bbox;\n        }\n\n        if (options.filterOptions.circle) {\n            this.logger.warn(\"The parameter 'filterOptions.circle' is deprecated\");\n            if (!options.searchGeometry) {\n                // convertir la geometrie\n                options.searchGeometry = this.circle2Json(options.filterOptions.circle);\n            }\n            delete options.filterOptions.circle;\n        }\n\n        if (options.filterOptions.polygon) {\n            this.logger.warn(\"The parameter 'filterOptions.polygon' is deprecated\");\n            if (!options.searchGeometry) {\n                // convertir la geometrie\n                options.searchGeometry = this.polygon2Json(options.filterOptions.polygon);\n            }\n            delete options.filterOptions.polygon;\n        }\n\n        if (!options.filters && Object.keys(options.filterOptions).length > 0) {\n            options.filters = options.filterOptions;\n        }\n\n        delete options.filterOptions;\n    }\n\n    if (options.position) {\n        if (options.position.x) {\n            this.logger.warn(\"The parameter 'position.x' is deprecated\");\n\n            if (!options.position.lon) {\n                options.position.lon = options.position.x;\n            }\n            delete options.position.x;\n        }\n\n        if (options.position.y) {\n            this.logger.warn(\"The parameter 'position.y' is deprecated\");\n\n            if (!options.position.lat) {\n                options.position.lat = options.position.y;\n            }\n            delete options.position.y;\n        }\n    }\n\n    if (options.srs) {\n        this.logger.warn(\"The parameter 'srs' is deprecated\");\n        delete options.srs;\n    }\n\n    return options;\n};\n\n/**\n * (overwrite)\n * Création de la requête\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nReverseGeocode.prototype.buildRequest = function (error, success) {\n    var options = {\n        httpMethod : this.options.httpMethod,\n        // options specifiques du service\n        geocodeMethod : \"reverse\",\n        searchGeometry : this.options.searchGeometry,\n        index : this.options.index,\n        position : this.options.position,\n        returnTrueGeometry : this.options.returnTrueGeometry,\n        maxResp : this.options.maximumResponses,\n        filters : this.options.filters\n    };\n\n    this.request = _Request_GeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_4__[\"default\"].build(options);\n\n    // on teste si la requete a bien été construite !\n    (!this.request)\n        ? error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_REQUEST_BUILD\")))\n        : success.call(this, this.request);\n};\n\n/**\n * (overwrite)\n * Analyse de la reponse\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nReverseGeocode.prototype.analyzeResponse = function (error, success) {\n    if (this.response) {\n        var options = {\n            response : this.response,\n            rawResponse : this.options.rawResponse,\n            onError : error,\n            onSuccess : success,\n            scope : this\n        };\n\n        _Response_GeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_5__[\"default\"].build(options);\n    } else {\n        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/**\n * Patch pour la convertion des options vers le nouveau formalisme.\n *\n * @param {Array} bbox - bbox\n * @return {Object} - geometrie au format json\n */\nReverseGeocode.prototype.bbox2Json = function (bbox) {\n    return {\n        type : \"Polygon\",\n        coordinates : [[\n            [bbox.left, bbox.top],\n            [bbox.right, bbox.top],\n            [bbox.right, bbox.bottom],\n            [bbox.left, bbox.bottom],\n            [bbox.left, bbox.top]\n        ]]\n    };\n};\n\n/**\n * Patch pour la convertion des options vers le nouveau formalisme.\n *\n * @param {Object} circle - circle\n * @return {Object} - geometrie au format json\n */\nReverseGeocode.prototype.circle2Json = function (circle) {\n    return {\n        type : \"Circle\",\n        radius : circle.radius,\n        coordinates : [circle.x, circle.y]\n    };\n};\n\n/**\n * Patch pour la convertion des options vers le nouveau formalisme.\n *\n * @param {Array} polygon - polygon\n * @return {Object} - geometrie au format json\n */\nReverseGeocode.prototype.polygon2Json = function (polygon) {\n    var jsonGeom = {\n        type : \"Polygon\",\n        coordinates : [[]]\n    };\n\n    for (var i = 0; i < polygon.length; ++i) {\n        jsonGeom.coordinates[0].push([polygon[i].x, polygon[i].y]);\n    }\n\n    return jsonGeom;\n};\n\n/**\n * Codes EPSG géographiques (lat/lon). Utiles car les coordonnées doivent être inversées.\n */\nReverseGeocode.geoEPSG = [\"EPSG:4326\"];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReverseGeocode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmV2ZXJzZUdlb2NvZGUuanM/YmRhZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFpRDtBQUNIO0FBQ1c7QUFDWjtBQUN1QjtBQUNHOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGtDQUFrQztBQUNsRCxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQUM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsOERBQU07QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUksc0RBQWE7O0FBRWpCO0FBQ0Esd0JBQXdCLGdFQUFDO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0RBQWE7QUFDdEQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNFQUFxQjs7QUFFeEM7QUFDQTtBQUNBLCtCQUErQixnRUFBWSxDQUFDLGdFQUFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsd0VBQXNCO0FBQzlCLEtBQUs7QUFDTCw2QkFBNkIsZ0VBQVksQ0FBQyxnRUFBQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLDZFQUFjLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0dlb2NvZGUvUmV2ZXJzZUdlb2NvZGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbmltcG9ydCBfIGZyb20gXCIuLi8uLi9VdGlscy9NZXNzYWdlc1Jlc291cmNlc1wiO1xuaW1wb3J0IEVycm9yU2VydmljZSBmcm9tIFwiLi4vLi4vRXhjZXB0aW9ucy9FcnJvclNlcnZpY2VcIjtcbmltcG9ydCBDb21tb25TZXJ2aWNlIGZyb20gXCIuLi9Db21tb25TZXJ2aWNlXCI7XG5pbXBvcnQgR2VvY29kZVJlcXVlc3RGYWN0b3J5IGZyb20gXCIuL1JlcXVlc3QvR2VvY29kZVJlcXVlc3RGYWN0b3J5XCI7XG5pbXBvcnQgR2VvY29kZVJlc3BvbnNlRmFjdG9yeSBmcm9tIFwiLi9SZXNwb25zZS9HZW9jb2RlUmVzcG9uc2VGYWN0b3J5XCI7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQXBwZWwgZHUgc2VydmljZSBkZSBnw6lvY29kYWdlIGludmVyc2UgZHUgR8Opb3BvcnRhaWwgOlxuICogICAgIGVudm9pIGRlIGxhIHJlcXXDqnRlIGNvbnN0cnVpdGUgc2Vsb24gbGVzIHBhcmFtw6h0cmVzIGVuIG9wdGlvbnMsXG4gKiAgICAgw6l2ZW50dWVsbGVtZW50IHBhcnNpbmcgZXQgYW5hbHlzZSAgZGUgbGEgcsOpcG9uc2UsXG4gKiAgICAgcmV0b3VyIGQndW5lIHLDqXBvbnNlIGVuIHBhcmFtw6h0cmUgZGUgbGEgZm9uY3Rpb24gb25TdWNjZXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7R3AuU2VydmljZXMuQ29tbW9uU2VydmljZX1cbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5SZXZlcnNlR2VvY29kZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBzcMOpY2lmaXF1ZXMgYXUgc2VydmljZSAoKyBsZXMgb3B0aW9ucyBoZXJpdMOpZXMpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSBQb3NpdGlvbiBkdSBwb2ludCBkZSByw6lmw6lyZW5jZSBwb3VyIGxlIGNhbGN1bCBkZSBwcm94aW1pdMOpIGV4cHJpbcOpZSBkYW5zIGxlIHN5c3TDqG1lIGRlIHLDqWbDqXJlbmNlIHNww6ljaWZpw6kgcGFyIGxlIHNycy5cbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5wb3NpdGlvbi5sb24gLSBMb25naXR1ZGUgZHUgcG9pbnQgZGUgcsOpZsOpcmVuY2UgcG91ciBsZSBjYWxjdWwgZGUgcHJveGltaXTDqS5cbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5wb3NpdGlvbi5sYXQgLSBMYXRpdHVkZSBkdSBwb2ludCBkZSByw6lmw6lyZW5jZSBwb3VyIGxlIGNhbGN1bCBkZSBwcm94aW1pdMOpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJzXSAtIExlcyBwcm9wcmnDqXTDqXMgcG9zc2libGVzIGRlIGNldCBvYmpldC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5maWx0ZXJzLltwcm9wcmlldGVzIGR1IGZpbHRyZV1dIC0gQ3JpdMOocmUgc3VwcGzDqW1lbnRhaXJlIHBvdXIgZmlsdHJlciBsYSByZWNoZXJjaGUgc291cyBsYSBmb3JtZVxuICogICAgICBkJ3VuIGNvdXBsZSBjbMOpL3ZhbGV1ciDDoCBkw6lmaW5pciBzZWxvbiBsZXMgcG9zc2liaWxpdMOpcyBkdSBzZXJ2ZXVyIGFqb3V0w6kgw6AgbGEgcmVxdcOqdGUuXG4gKiAgICAgIExlIHNlcnZpY2UgZGUgZ8Opb2NvZGFnZSBkdSBHw6lvcG9ydGFpbCBwZXJtZXQgZGUgZmlsdHJlciBsZXMgYWRyZXNzZXMgcG9zdGFsZXMgYXZlYyBsZXMgcHJvcHJpw6l0w6lzIDpcbiAqICAgICAgICAgIFwicG9zdGFsQ29kZVwiLCBcImluc2VlQ29kZVwiLCBcImNpdHlcIi5cbiAqICAgICAgSWwgcGVybWV0IMOpZ2FsZW1lbnQgZGUgZmlsdHJlciBsZXMgdG9wb255bWVzIGF2ZWMgbGVzIHByb3ByacOpdMOpcyA6XG4gKiAgICAgICAgICBcInBvc3RhbENvZGVcIiwgXCJpbnNlZUNvZGVcIiwgXCJ0eXBlXCIuXG4gKiAgICAgIEVuZmluLCBpbCBwZXJtZXQgZGUgZmlsdHJlciBsZXMgcGFyY2VsbGVzIGNhZGFzdHJhbGVzIGF2ZWMgbGVzIHByb3ByacOpdMOpcyA6XG4gKiAgICAgICAgICBcImNvZGVEZXBhcnRlbWVudFwiLCBcImNvZGVDb21tdW5lXCIsIFwibm9tQ29tbXVuZVwiLCBcImNvZGVDb21tdW5lQWJzXCIsIFwiY29kZUFycm9uZGlzc2VtZW50XCIsIFwic2VjdGlvblwiLCBcIm51bWVyb1wiLCBcImZldWlsbGVcIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2VhcmNoR2VvbWV0cnldIC0gRW1wcmlzZSBkYW5zIGxhcXVlbGxlIG9uIHNvdWhhaXRlIGVmZmVjdHVlciBsYSByZWNoZXJjaGUuXG4gKiAgICAgIExlcyBwcm9wcmnDqXTDqXMgcG9zc2libGVzIGRlIGNldCBvYmpldCBzb250IGTDqWNyaXRlcyBjaS1hcHLDqHMuXG4gKiAgICAgIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnNlYXJjaEdlb21ldHJ5LnR5cGUgICAtIFR5cGUgZGUgZ8Opb21ldHJpZSAoUG9pbnR8Q2lyY2xlfExpbmVzdHJpbmd8UG9seWdvbilcbiAqICAgICAgQHBhcmFtIHtBcnJheS48RmxvYXQ+fEFycmF5LkFycmF5LjxGbG9hdD59IG9wdGlvbnMuc2VhcmNoR2VvbWV0cnkuY29vcmRpbmF0ZXMgLSBDb29yZG9ubsOpZXMgZGVzIHBvaW50cyBjb25zdGl0dWFudCBsYSBnw6lvbcOpdHJpZS5cbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5zZWFyY2hHZW9tZXRyeS5yYWRpdXMgICAgLSBSYXlvbi4gUGFyYW3DqHRyZSBhcHBsaWNhYmxlIHVuaXF1ZW1lbnQgcG91ciBsZSB0eXBlICdDaXJjbGUnLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbmRleCA9IFwiU3RyZWV0QWRkcmVzc1wiXSAtIFR5cGUgZGUgbCdvYmpldCByZWNoZXJjaMOpLlxuICogICAgICBMZSBzZXJ2aWNlIGRlIGfDqW9jb2RhZ2UgZHUgR8Opb3BvcnRhaWwgcGVybWV0IGRlIHJlY2hlcmNoZXIgZGVzICdQb3NpdGlvbk9mSW50ZXJlc3QnIHBvdXIgZGVzIHRvcG9ueW1lcywgZGVzICdTdHJlZXRBZGRyZXNzJ1xuICogICAgICBwb3VyIGRlcyBhZHJlc3NlcyBwb3N0YWxlcyBvdSBkZXMgJ0NhZGFzdHJhbFBhcmNlbCcgcG91ciBkZXMgcGFyY2VsbGVzIGNhZGFzdHJhbGVzLiBMJ2luZGV4ICdsb2NhdGlvbicgcGVybWV0IHVuZSByZWNoZXJjaGVcbiAqICAgICAgbXVsdGktaW5kZXhlcyBlbiByZWdyb3VwYW50IGxlcyBpbmRleGVzICdQb3NpdGlvbk9mSW50ZXJlc3QnIGV0ICdTdHJlZXRBZGRyZXNzJy5cbiAqICAgICAgRCdhdXRyZXMgdHlwZXMgcG91cnJvbnQgw6p0cmUgcmFqb3V0w6lzIHNlbG9uIGwnw6l2b2x1dGlvbiBkdSBzZXJ2aWNlLlxuICogICAgICBQYXIgZMOpZmF1dCwgaW5kZXggPSAnU3RyZWV0QWRkcmVzcycuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heGltdW1SZXNwb25zZXNdIC0gTm9tYnJlIGRlIHLDqXBvbnNlcyBtYXhpbWFsIHF1ZSBsJ29uIHNvdWhhaXRlIHJlY2V2b2lyLlxuICogICAgICBQYXMgZGUgdmFsZXVyIHBhciBkw6lmYXV0LiBTaSBsZSBzZXJ2ZXVyIGNvbnN1bHTDqSBlc3QgY2VsdWkgZHUgR8Opb3BvcnRhaWwsIGxhIHZhbGV1ciBwYXIgZMOpZmF1dCBzZXJhIGRvbmMgY2VsbGUgZHUgc2VydmljZSA6IDIwcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldHVyblRydWVHZW9tZXRyeV0gLSBCb29sw6llbiBpbmRpcXVhbnQgc2kgbCdvbiBzb3VoYWl0ZSByw6ljdXDDqXJlciBsYSBnw6lvbcOpdHJpZSB2cmFpZSBkZXMgb2JqZWN0cyBnw6lvbG9jYWxpc8Opcy5cbiAqICAgICAgZmFsc2UgcGFyIGTDqWZhdXQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgdmFyIG9wdGlvbnMgPSB7XG4gKiAgICAgIGFwaUtleSA6IG51bGwsXG4gKiAgICAgIHNlcnZlclVybCA6ICdodHRwOi8vbG9jYWxob3N0L3NlcnZpY2UvJyxcbiAqICAgICAgcHJveHlVUkwgOiBudWxsLFxuICogICAgICB0aW1lT3V0IDogMTAwMDAsIC8vIG1zXG4gKiAgICAgIHJhd1Jlc3BvbnNlIDogZmFsc2UsIC8vIHRydWV8ZmFsc2VcbiAqICAgICAgc2NvcGUgOiBudWxsLCAvLyB0aGlzXG4gKiAgICAgIG9uU3VjY2VzcyA6IGZ1bmN0aW9uIChyZXNwb25zZSkge30sXG4gKiAgICAgIG9uRmFpbHVyZSA6IGZ1bmN0aW9uIChlcnJvcikge30sXG4gKiAgICAgIC8vIHNww6ljaWZpcXVlIGF1IHNlcnZpY2VcbiAqICAgICAgaW5kZXggOiAnU3RyZWV0QWRkcmVzcycsXG4gKiAgICAgIHNlYXJjaEdlb21ldHJ5IDoge1xuICogICAgICAgICAgdHlwZSA6IENpcmNsZSxcbiAqICAgICAgICAgIGNvb3JkaW5hdGVzIDogWzQ4LCAyXSxcbiAqICAgICAgICAgIHJhZGl1cyA6IDEwMFxuICogICAgICB9LFxuICogICAgICBwb3NpdGlvbiA6IHtsb246MiAsIGxhdDo0OC41fSxcbiAqICAgICAgbWF4aW11bVJlc3BvbnNlcyA6IDI1LFxuICogICB9O1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFJldmVyc2VHZW9jb2RlIChvcHRpb25zXykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXZlcnNlR2VvY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihfLmdldE1lc3NhZ2UoXCJDTEFTU19DT05TVFJVQ1RPUlwiLCBcIlJldmVyc2VHZW9jb2RlXCIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKiBGSVhNRSBpbnN0YW5jZSBvdSBjbGFzc2UgP1xuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJSZXZlcnNlR2VvY29kZVwiO1xuXG4gICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiR3AuU2VydmljZXMuUmV2ZXJzZUdlb2NvZGVcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJldmVyc2VHZW9jb2RlIChvcHRpb25zKV1cIik7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMucGF0Y2hPcHRpb25Db252ZXJ0b3Iob3B0aW9uc18pO1xuICAgIG9wdGlvbnMuc2VydmVyVXJsID0gb3B0aW9ucy5zZXJ2ZXJVcmwgfHwgXCJodHRwczovL3d4cy5pZ24uZnIvY2FsY3VsL2dlb3BvcnRhaWwvZ2VvY29kYWdlL3Jlc3QvMC4xL3JldmVyc2VcIjtcblxuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBwYXIgaGVyaXRhZ2VcbiAgICBDb21tb25TZXJ2aWNlLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuc2VhcmNoR2VvbWV0cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF8uZ2V0TWVzc2FnZShcIlBBUkFNX01JU1NJTkdcIiwgXCJzZWFyY2hHZW9tZXRyeVwiKSk7XG4gICAgfVxuXG4gICAgLy8gYWpvdXQgZGVzIG9wdGlvbnMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2VcbiAgICB0aGlzLm9wdGlvbnMuc2VhcmNoR2VvbWV0cnkgPSBvcHRpb25zLnNlYXJjaEdlb21ldHJ5O1xuXG4gICAgLy8gb24gZGVmaW5pdCBsJ2luZGV4IHBhciBkZWZhdXRcbiAgICBpZiAoIW9wdGlvbnMuaW5kZXgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmluZGV4ID0gb3B0aW9ucy5pbmRleCA9IFwiU3RyZWV0QWRkcmVzc1wiO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbHRlcnMpIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IE9iamVjdC5rZXlzKG9wdGlvbnMuZmlsdGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZmlsdGVyW2ldO1xuICAgICAgICAgICAgLy8gb24gc3VwcHJpbWUgbGVzIGZpbHRyZXMgdmlkZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXJzW2tleV0gPT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMuZmlsdGVyc1trZXldID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKG9wdGlvbnMuZmlsdGVyc1trZXldKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zLmZpbHRlcnNba2V5XSA9PT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLmZpbHRlcnNba2V5XS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5maWx0ZXJzW2tleV0pICYmIG9wdGlvbnMuZmlsdGVyc1trZXldLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuZmlsdGVyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICB0aGlzLm9wdGlvbnMuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IFwiU3RyZWV0QWRkcmVzc1wiO1xuICAgIHRoaXMub3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzID0gb3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzIHx8IDIwO1xufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6UmV2ZXJzZUdlb2NvZGUjXG4gKi9cblJldmVyc2VHZW9jb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tbW9uU2VydmljZS5wcm90b3R5cGUsIHtcbiAgICAvLyB0b2RvXG4gICAgLy8gZ2V0dGVyL3NldHRlclxufSk7XG5cbi8qXG4gKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXZlcnNlR2VvY29kZTtcblxuLyoqXG4gKiBQYXRjaCBwb3VyIGxhIGNvbnZlcnRpb24gZGVzIG9wdGlvbnMgdmVycyBsZSBub3V2ZWF1IGZvcm1hbGlzbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNfIC0gb3B0aW9ucyBkdSBzZXJ2aWNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gb3B0aW9uc1xuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUucGF0Y2hPcHRpb25Db252ZXJ0b3IgPSBmdW5jdGlvbiAob3B0aW9uc18pIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfO1xuXG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyT3B0aW9ucykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHBhcmFtZXRlciAnZmlsdGVyT3B0aW9ucycgaXMgZGVwcmVjYXRlZFwiKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgcGFyYW1ldGVyICdmaWx0ZXJPcHRpb25zLnR5cGUnIGlzIGRlcHJlY2F0ZWRcIik7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmZpbHRlck9wdGlvbnMudHlwZSkgJiYgb3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmluZGV4ID0gb3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGVbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleCA9IG9wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmZpbHRlck9wdGlvbnMudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmZpbHRlck9wdGlvbnMuYmJveCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBwYXJhbWV0ZXIgJ2ZpbHRlck9wdGlvbnMuYmJveCcgaXMgZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zZWFyY2hHZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRpciBsYSBnZW9tZXRyaWVcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlYXJjaEdlb21ldHJ5ID0gdGhpcy5iYm94Mkpzb24ob3B0aW9ucy5maWx0ZXJPcHRpb25zLmJib3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZmlsdGVyT3B0aW9ucy5iYm94O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyT3B0aW9ucy5jaXJjbGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgcGFyYW1ldGVyICdmaWx0ZXJPcHRpb25zLmNpcmNsZScgaXMgZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zZWFyY2hHZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRpciBsYSBnZW9tZXRyaWVcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlYXJjaEdlb21ldHJ5ID0gdGhpcy5jaXJjbGUySnNvbihvcHRpb25zLmZpbHRlck9wdGlvbnMuY2lyY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmZpbHRlck9wdGlvbnMuY2lyY2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyT3B0aW9ucy5wb2x5Z29uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHBhcmFtZXRlciAnZmlsdGVyT3B0aW9ucy5wb2x5Z29uJyBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNlYXJjaEdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gY29udmVydGlyIGxhIGdlb21ldHJpZVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VhcmNoR2VvbWV0cnkgPSB0aGlzLnBvbHlnb24ySnNvbihvcHRpb25zLmZpbHRlck9wdGlvbnMucG9seWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5maWx0ZXJPcHRpb25zLnBvbHlnb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuZmlsdGVycyAmJiBPYmplY3Qua2V5cyhvcHRpb25zLmZpbHRlck9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVycyA9IG9wdGlvbnMuZmlsdGVyT3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmZpbHRlck9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ueCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBwYXJhbWV0ZXIgJ3Bvc2l0aW9uLngnIGlzIGRlcHJlY2F0ZWRcIik7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wb3NpdGlvbi5sb24pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLmxvbiA9IG9wdGlvbnMucG9zaXRpb24ueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnBvc2l0aW9uLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi55KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHBhcmFtZXRlciAncG9zaXRpb24ueScgaXMgZGVwcmVjYXRlZFwiKTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBvc2l0aW9uLmxhdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ubGF0ID0gb3B0aW9ucy5wb3NpdGlvbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMucG9zaXRpb24ueTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNycykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHBhcmFtZXRlciAnc3JzJyBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5zcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIChvdmVyd3JpdGUpXG4gKiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUuYnVpbGRSZXF1ZXN0ID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBNZXRob2QgOiB0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCxcbiAgICAgICAgLy8gb3B0aW9ucyBzcGVjaWZpcXVlcyBkdSBzZXJ2aWNlXG4gICAgICAgIGdlb2NvZGVNZXRob2QgOiBcInJldmVyc2VcIixcbiAgICAgICAgc2VhcmNoR2VvbWV0cnkgOiB0aGlzLm9wdGlvbnMuc2VhcmNoR2VvbWV0cnksXG4gICAgICAgIGluZGV4IDogdGhpcy5vcHRpb25zLmluZGV4LFxuICAgICAgICBwb3NpdGlvbiA6IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgcmV0dXJuVHJ1ZUdlb21ldHJ5IDogdGhpcy5vcHRpb25zLnJldHVyblRydWVHZW9tZXRyeSxcbiAgICAgICAgbWF4UmVzcCA6IHRoaXMub3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzLFxuICAgICAgICBmaWx0ZXJzIDogdGhpcy5vcHRpb25zLmZpbHRlcnNcbiAgICB9O1xuXG4gICAgdGhpcy5yZXF1ZXN0ID0gR2VvY29kZVJlcXVlc3RGYWN0b3J5LmJ1aWxkKG9wdGlvbnMpO1xuXG4gICAgLy8gb24gdGVzdGUgc2kgbGEgcmVxdWV0ZSBhIGJpZW4gw6l0w6kgY29uc3RydWl0ZSAhXG4gICAgKCF0aGlzLnJlcXVlc3QpXG4gICAgICAgID8gZXJyb3IuY2FsbCh0aGlzLCBuZXcgRXJyb3JTZXJ2aWNlKF8uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVRVUVTVF9CVUlMRFwiKSkpXG4gICAgICAgIDogc3VjY2Vzcy5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdCk7XG59O1xuXG4vKipcbiAqIChvdmVyd3JpdGUpXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUuYW5hbHl6ZVJlc3BvbnNlID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZXNwb25zZSA6IHRoaXMucmVzcG9uc2UsXG4gICAgICAgICAgICByYXdSZXNwb25zZSA6IHRoaXMub3B0aW9ucy5yYXdSZXNwb25zZSxcbiAgICAgICAgICAgIG9uRXJyb3IgOiBlcnJvcixcbiAgICAgICAgICAgIG9uU3VjY2VzcyA6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICBHZW9jb2RlUmVzcG9uc2VGYWN0b3J5LmJ1aWxkKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yLmNhbGwodGhpcywgbmV3IEVycm9yU2VydmljZShfLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VNUFRZXCIpKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXRjaCBwb3VyIGxhIGNvbnZlcnRpb24gZGVzIG9wdGlvbnMgdmVycyBsZSBub3V2ZWF1IGZvcm1hbGlzbWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYmJveCAtIGJib3hcbiAqIEByZXR1cm4ge09iamVjdH0gLSBnZW9tZXRyaWUgYXUgZm9ybWF0IGpzb25cbiAqL1xuUmV2ZXJzZUdlb2NvZGUucHJvdG90eXBlLmJib3gySnNvbiA9IGZ1bmN0aW9uIChiYm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSA6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlcyA6IFtbXG4gICAgICAgICAgICBbYmJveC5sZWZ0LCBiYm94LnRvcF0sXG4gICAgICAgICAgICBbYmJveC5yaWdodCwgYmJveC50b3BdLFxuICAgICAgICAgICAgW2Jib3gucmlnaHQsIGJib3guYm90dG9tXSxcbiAgICAgICAgICAgIFtiYm94LmxlZnQsIGJib3guYm90dG9tXSxcbiAgICAgICAgICAgIFtiYm94LmxlZnQsIGJib3gudG9wXVxuICAgICAgICBdXVxuICAgIH07XG59O1xuXG4vKipcbiAqIFBhdGNoIHBvdXIgbGEgY29udmVydGlvbiBkZXMgb3B0aW9ucyB2ZXJzIGxlIG5vdXZlYXUgZm9ybWFsaXNtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2lyY2xlIC0gY2lyY2xlXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gZ2VvbWV0cmllIGF1IGZvcm1hdCBqc29uXG4gKi9cblJldmVyc2VHZW9jb2RlLnByb3RvdHlwZS5jaXJjbGUySnNvbiA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlIDogXCJDaXJjbGVcIixcbiAgICAgICAgcmFkaXVzIDogY2lyY2xlLnJhZGl1cyxcbiAgICAgICAgY29vcmRpbmF0ZXMgOiBbY2lyY2xlLngsIGNpcmNsZS55XVxuICAgIH07XG59O1xuXG4vKipcbiAqIFBhdGNoIHBvdXIgbGEgY29udmVydGlvbiBkZXMgb3B0aW9ucyB2ZXJzIGxlIG5vdXZlYXUgZm9ybWFsaXNtZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwb2x5Z29uIC0gcG9seWdvblxuICogQHJldHVybiB7T2JqZWN0fSAtIGdlb21ldHJpZSBhdSBmb3JtYXQganNvblxuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUucG9seWdvbjJKc29uID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICB2YXIganNvbkdlb20gPSB7XG4gICAgICAgIHR5cGUgOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXMgOiBbW11dXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBqc29uR2VvbS5jb29yZGluYXRlc1swXS5wdXNoKFtwb2x5Z29uW2ldLngsIHBvbHlnb25baV0ueV0pO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uR2VvbTtcbn07XG5cbi8qKlxuICogQ29kZXMgRVBTRyBnw6lvZ3JhcGhpcXVlcyAobGF0L2xvbikuIFV0aWxlcyBjYXIgbGVzIGNvb3Jkb25uw6llcyBkb2l2ZW50IMOqdHJlIGludmVyc8OpZXMuXG4gKi9cblJldmVyc2VHZW9jb2RlLmdlb0VQU0cgPSBbXCJFUFNHOjQzMjZcIl07XG5cbmV4cG9ydCBkZWZhdWx0IFJldmVyc2VHZW9jb2RlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/Helper.js":
/*!***************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/Helper.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Classe utilitaire\n *\n * @module Helper\n * @alias Gp.Helper\n */\nvar Helper = {\n\n    /**\n     * concatenation des parametres key/value dans les urls\n     *\n     * @method normalyzeParameters\n     * @static\n     * @param {Object} params - tableau de clef/valeur\n     *\n     * @example\n     *  Gp.Utils.Helper.normalyzeParameters ({\n     *         key1:value1,\n     *         key2:value2,\n     *         key3:value3\n     *  });\n     *  // out : \"key1=value1&key2=value2&key3=value3\"\n     *\n     * @returns {String} retourne les paramètres concaténés\n     */\n    normalyzeParameters : function (params) {\n        var myParams = null;\n\n        if (params) {\n            var tabParams = [];\n            for (var key in params) {\n                if (params.hasOwnProperty(key)) {\n                    var value = params[key];\n                    if (!value) {\n                        value = \"\";\n                    }\n                    tabParams.push(key + \"=\" + value);\n                }\n            }\n\n            myParams = tabParams.join(\"&\");\n        }\n\n        return myParams;\n    },\n\n    /**\n     * Concaténation et encodage des urls.\n     *\n     * @method normalyzeUrl\n     * @static\n     * @param {String} url - url\n     * @param {Object|String} params - tableau de clef/valeur ou string\n     * @param {Boolean} encode - true|false, false par defaut\n     *\n     * @example\n     *  Gp.Utils.Helper.normalyzeUrl (url, {\n     *         key1:value1,\n     *         key2=:value2,\n     *         key3:value3\n     *  });\n     *  // out : \"url?key1=value1&key2=value2&key3=value3\"\n     *\n     * @returns {String} retourne une url normalisée\n     */\n    normalyzeUrl : function (url, params, encode) {\n        var myUrl = url;\n\n        if (url) {\n            var k = url.indexOf(\"?\");\n            if (k === -1) { // pas de ? et KVP\n                myUrl += \"?\";\n            }\n\n            if (k !== -1 && k !== url.length - 1) { // KVP\n                myUrl += \"&\";\n            }\n        }\n\n        if (params) {\n            if (typeof params === \"string\") {\n                myUrl += params;\n            } else {\n                myUrl += this.normalyzeParameters(params);\n            }\n        }\n\n        if (encode) {\n            // FIXME bonne idée ?\n            myUrl = encodeURIComponent(myUrl);\n        }\n\n        return myUrl;\n    },\n\n    /**\n     * Indentation d'une chaine\n     *\n     * @method indent\n     * @static\n     * @param {Number} n - nombre de tabulation\n     * @param {String} msg - chaine\n     *\n     * @example\n     * Gp.Utils.Helper.indent (2, \"message à indenter\")\n     * // out\n     * // ........message à indenter\n     *\n     * @returns {String} retourne une chaine indentée\n     */\n    indent : function (n, msg) {\n        var num = n || 0;\n        return new Array(num + 1).join(\"\\t\") + msg;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Helper);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL0hlbHBlci5qcz8wYmQwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUscUVBQU0sRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvVXRpbHMvSGVscGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGFzc2UgdXRpbGl0YWlyZVxuICpcbiAqIEBtb2R1bGUgSGVscGVyXG4gKiBAYWxpYXMgR3AuSGVscGVyXG4gKi9cbnZhciBIZWxwZXIgPSB7XG5cbiAgICAvKipcbiAgICAgKiBjb25jYXRlbmF0aW9uIGRlcyBwYXJhbWV0cmVzIGtleS92YWx1ZSBkYW5zIGxlcyB1cmxzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5vcm1hbHl6ZVBhcmFtZXRlcnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHRhYmxlYXUgZGUgY2xlZi92YWxldXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIEdwLlV0aWxzLkhlbHBlci5ub3JtYWx5emVQYXJhbWV0ZXJzICh7XG4gICAgICogICAgICAgICBrZXkxOnZhbHVlMSxcbiAgICAgKiAgICAgICAgIGtleTI6dmFsdWUyLFxuICAgICAqICAgICAgICAga2V5Mzp2YWx1ZTNcbiAgICAgKiAgfSk7XG4gICAgICogIC8vIG91dCA6IFwia2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTNcIlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgbGVzIHBhcmFtw6h0cmVzIGNvbmNhdMOpbsOpc1xuICAgICAqL1xuICAgIG5vcm1hbHl6ZVBhcmFtZXRlcnMgOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBteVBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHRhYlBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhYlBhcmFtcy5wdXNoKGtleSArIFwiPVwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXlQYXJhbXMgPSB0YWJQYXJhbXMuam9pbihcIiZcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXlQYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdMOpbmF0aW9uIGV0IGVuY29kYWdlIGRlcyB1cmxzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBub3JtYWx5emVVcmxcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIHVybFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcGFyYW1zIC0gdGFibGVhdSBkZSBjbGVmL3ZhbGV1ciBvdSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZSAtIHRydWV8ZmFsc2UsIGZhbHNlIHBhciBkZWZhdXRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIEdwLlV0aWxzLkhlbHBlci5ub3JtYWx5emVVcmwgKHVybCwge1xuICAgICAqICAgICAgICAga2V5MTp2YWx1ZTEsXG4gICAgICogICAgICAgICBrZXkyPTp2YWx1ZTIsXG4gICAgICogICAgICAgICBrZXkzOnZhbHVlM1xuICAgICAqICB9KTtcbiAgICAgKiAgLy8gb3V0IDogXCJ1cmw/a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTNcIlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgdW5lIHVybCBub3JtYWxpc8OpZVxuICAgICAqL1xuICAgIG5vcm1hbHl6ZVVybCA6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgZW5jb2RlKSB7XG4gICAgICAgIHZhciBteVVybCA9IHVybDtcblxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgayA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgICAgIGlmIChrID09PSAtMSkgeyAvLyBwYXMgZGUgPyBldCBLVlBcbiAgICAgICAgICAgICAgICBteVVybCArPSBcIj9cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGsgIT09IC0xICYmIGsgIT09IHVybC5sZW5ndGggLSAxKSB7IC8vIEtWUFxuICAgICAgICAgICAgICAgIG15VXJsICs9IFwiJlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBteVVybCArPSBwYXJhbXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG15VXJsICs9IHRoaXMubm9ybWFseXplUGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuY29kZSkge1xuICAgICAgICAgICAgLy8gRklYTUUgYm9ubmUgaWTDqWUgP1xuICAgICAgICAgICAgbXlVcmwgPSBlbmNvZGVVUklDb21wb25lbnQobXlVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG15VXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRlbnRhdGlvbiBkJ3VuZSBjaGFpbmVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5kZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gbm9tYnJlIGRlIHRhYnVsYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gY2hhaW5lXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEdwLlV0aWxzLkhlbHBlci5pbmRlbnQgKDIsIFwibWVzc2FnZSDDoCBpbmRlbnRlclwiKVxuICAgICAqIC8vIG91dFxuICAgICAqIC8vIC4uLi4uLi4ubWVzc2FnZSDDoCBpbmRlbnRlclxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgdW5lIGNoYWluZSBpbmRlbnTDqWVcbiAgICAgKi9cbiAgICBpbmRlbnQgOiBmdW5jdGlvbiAobiwgbXNnKSB7XG4gICAgICAgIHZhciBudW0gPSBuIHx8IDA7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkobnVtICsgMSkuam9pbihcIlxcdFwiKSArIG1zZztcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIZWxwZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Utils/Helper.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js":
/*!************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar LoggerByDefault = {\n    /**\n     * logger statique\n     *\n     * @static\n     * @param {String} name - nom du logger\n     * @returns {Object} retourne un logger\n     */\n    getLogger : function (name) {\n        // Substitute global constants configured at compile time\n        // cf. webpack.config.js\n        // FIXME howtodo !? DefineWebpackPlugin ? EnvironmentWebpackPlugin ?\n        (\"false\".match(/true/)) ? loglevel__WEBPACK_IMPORTED_MODULE_0__[\"disableAll\"]() : loglevel__WEBPACK_IMPORTED_MODULE_0__[\"enableAll\"]();\n        var logname = name || \"default\";\n        return loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"](logname);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LoggerByDefault);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcz8wNjVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1EQUFjLEtBQUssa0RBQWE7QUFDM0U7QUFDQSxlQUFlLGtEQUFhO0FBQzVCO0FBQ0E7O0FBRWUsOEVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvVXRpbHMvTG9nZ2VyQnlEZWZhdWx0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgTG9nIGZyb20gXCJsb2dsZXZlbFwiO1xuXG52YXIgTG9nZ2VyQnlEZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIGxvZ2dlciBzdGF0aXF1ZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbm9tIGR1IGxvZ2dlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJldG91cm5lIHVuIGxvZ2dlclxuICAgICAqL1xuICAgIGdldExvZ2dlciA6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgZ2xvYmFsIGNvbnN0YW50cyBjb25maWd1cmVkIGF0IGNvbXBpbGUgdGltZVxuICAgICAgICAvLyBjZi4gd2VicGFjay5jb25maWcuanNcbiAgICAgICAgLy8gRklYTUUgaG93dG9kbyAhPyBEZWZpbmVXZWJwYWNrUGx1Z2luID8gRW52aXJvbm1lbnRXZWJwYWNrUGx1Z2luID9cbiAgICAgICAgKFwiX19QUk9EVUNUSU9OX19cIi5tYXRjaCgvdHJ1ZS8pKSA/IExvZy5kaXNhYmxlQWxsKCkgOiBMb2cuZW5hYmxlQWxsKCk7XG4gICAgICAgIHZhciBsb2duYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgcmV0dXJuIExvZy5nZXRMb2dnZXIobG9nbmFtZSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9nZ2VyQnlEZWZhdWx0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js":
/*!**************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Classe de gestion des erreurs qui permer d'associer un message d'erreur à l'exception lancée.\n *\n * @example\n * MessagesResources.getMessage(\"ERROR_PARAM_MISSING\", \"x\", \"y\", \"z\")));\n * // --> output : Parameter(s) 'x - y - z' missing\n *\n * @module MessagesResources\n * @alias Gp.Utils.MessagesResources\n * @private\n */\nvar MessagesResources = {\n\n    // Paramètres\n    PARAM_MISSING : \"Parameter(s) '%var%' missing\",\n    PARAM_EMPTY : \"Parameter(s) '%var%' empty\",\n    PARAM_TYPE : \"Wrong type(s) for parameter(s) '%var%'\",\n    PARAM_FORMAT : \"Parameter(s) '%var%' not correctly formatted\",\n    PARAM_NOT_SUPPORT : \"Value(s) for parameter(s) '%var%' not supported\",\n    PARAM_NOT_SUPPORT_NODEJS : \"Value(s) for parameter(s) '%var%' not supported to NodeJS\",\n    PARAM_UNKNOWN : \"Value(s) for parameter(s) '%var%' unknown\",\n\n    // Services\n    // Requête\n    SERVICE_REQUEST_BUILD : \"An error occurred during the request building of the service\",\n    SERVICE_REQUEST_EMPTY : \"The request sent to the service is empty\",\n\n    // Réponse\n    SERVICE_RESPONSE_EXCEPTION : \"The service returned an exception : '%var%'\",\n    SERVICE_RESPONSE_EXCEPTION_2 : \"The service returned an exception\",\n    SERVICE_RESPONSE_ANALYSE : \"An error occurred while parsing the response '%var%' of the service\",\n    SERVICE_RESPONSE_ANALYSE_2 : \"An unknown error occurred while parsing the response\",\n    SERVICE_RESPONSE_EMPTY : \"The response of the service is empty\",\n    SERVICE_RESPONSE_EMPTY_2 : \"The response from the service could not be analyzed or is empty\",\n    SERVICE_RESPONSE_FORMAT : \"The format of the service response is not supported (handled format(s) : '%var%')\",\n    SERVICE_RESPONSE_FORMAT_2 : \"The format of the service response is not supported\",\n    SERVICE_RESPONSE_FORMAT_3 : \"No suggestion matching the search\",\n\n    // Classes\n    CLASS_CONSTRUCTOR : \"'%var%' constructor cannot be called as a function.\",\n\n    /**\n     * Fonction qui va retourner le message d'erreur associé à la clé donnée\n     *\n     * @method getMessage\n     * @param {String} clef - Clef de l'erreur (ex : ERROR_PARAM)\n     * @param {String[]} parametres - Paramètres/variables concernés par le message d'erreur associé à la clef donnée\n     * @return {String} message - String contenant le message de l'exception\n     */\n    getMessage : function (clef, parametres) {\n        // param de la fonction uniquement pour la documentation...\n\n        if (Object.keys(arguments).length === 0) {\n            return \"Message indefined !\";\n        }\n\n        var params = Array.prototype.slice.call(arguments);\n        var key = params.shift();\n        var args = params;\n\n        var message = this[key];\n\n        try {\n            if (Array.isArray(args) && args.length > 0) {\n                message = message.replace(\"%var%\", args.join(\" - \"));\n            } else {\n                message = message.replace(\"%var%\", \"%var% (not specified)\");\n            }\n        } catch (e) {\n            // error de string.replace()\n\n        }\n\n        return message;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MessagesResources);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL01lc3NhZ2VzUmVzb3VyY2VzLmpzP2NlYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsZ0ZBQWlCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL01lc3NhZ2VzUmVzb3VyY2VzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgZXJyZXVycyBxdWkgcGVybWVyIGQnYXNzb2NpZXIgdW4gbWVzc2FnZSBkJ2VycmV1ciDDoCBsJ2V4Y2VwdGlvbiBsYW5jw6llLlxuICpcbiAqIEBleGFtcGxlXG4gKiBNZXNzYWdlc1Jlc291cmNlcy5nZXRNZXNzYWdlKFwiRVJST1JfUEFSQU1fTUlTU0lOR1wiLCBcInhcIiwgXCJ5XCIsIFwielwiKSkpO1xuICogLy8gLS0+IG91dHB1dCA6IFBhcmFtZXRlcihzKSAneCAtIHkgLSB6JyBtaXNzaW5nXG4gKlxuICogQG1vZHVsZSBNZXNzYWdlc1Jlc291cmNlc1xuICogQGFsaWFzIEdwLlV0aWxzLk1lc3NhZ2VzUmVzb3VyY2VzXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTWVzc2FnZXNSZXNvdXJjZXMgPSB7XG5cbiAgICAvLyBQYXJhbcOodHJlc1xuICAgIFBBUkFNX01JU1NJTkcgOiBcIlBhcmFtZXRlcihzKSAnJXZhciUnIG1pc3NpbmdcIixcbiAgICBQQVJBTV9FTVBUWSA6IFwiUGFyYW1ldGVyKHMpICcldmFyJScgZW1wdHlcIixcbiAgICBQQVJBTV9UWVBFIDogXCJXcm9uZyB0eXBlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJ1wiLFxuICAgIFBBUkFNX0ZPUk1BVCA6IFwiUGFyYW1ldGVyKHMpICcldmFyJScgbm90IGNvcnJlY3RseSBmb3JtYXR0ZWRcIixcbiAgICBQQVJBTV9OT1RfU1VQUE9SVCA6IFwiVmFsdWUocykgZm9yIHBhcmFtZXRlcihzKSAnJXZhciUnIG5vdCBzdXBwb3J0ZWRcIixcbiAgICBQQVJBTV9OT1RfU1VQUE9SVF9OT0RFSlMgOiBcIlZhbHVlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJyBub3Qgc3VwcG9ydGVkIHRvIE5vZGVKU1wiLFxuICAgIFBBUkFNX1VOS05PV04gOiBcIlZhbHVlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJyB1bmtub3duXCIsXG5cbiAgICAvLyBTZXJ2aWNlc1xuICAgIC8vIFJlcXXDqnRlXG4gICAgU0VSVklDRV9SRVFVRVNUX0JVSUxEIDogXCJBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIHJlcXVlc3QgYnVpbGRpbmcgb2YgdGhlIHNlcnZpY2VcIixcbiAgICBTRVJWSUNFX1JFUVVFU1RfRU1QVFkgOiBcIlRoZSByZXF1ZXN0IHNlbnQgdG8gdGhlIHNlcnZpY2UgaXMgZW1wdHlcIixcblxuICAgIC8vIFLDqXBvbnNlXG4gICAgU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT04gOiBcIlRoZSBzZXJ2aWNlIHJldHVybmVkIGFuIGV4Y2VwdGlvbiA6ICcldmFyJSdcIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTl8yIDogXCJUaGUgc2VydmljZSByZXR1cm5lZCBhbiBleGNlcHRpb25cIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0UgOiBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHBhcnNpbmcgdGhlIHJlc3BvbnNlICcldmFyJScgb2YgdGhlIHNlcnZpY2VcIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0VfMiA6IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBwYXJzaW5nIHRoZSByZXNwb25zZVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRU1QVFkgOiBcIlRoZSByZXNwb25zZSBvZiB0aGUgc2VydmljZSBpcyBlbXB0eVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRU1QVFlfMiA6IFwiVGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZpY2UgY291bGQgbm90IGJlIGFuYWx5emVkIG9yIGlzIGVtcHR5XCIsXG4gICAgU0VSVklDRV9SRVNQT05TRV9GT1JNQVQgOiBcIlRoZSBmb3JtYXQgb2YgdGhlIHNlcnZpY2UgcmVzcG9uc2UgaXMgbm90IHN1cHBvcnRlZCAoaGFuZGxlZCBmb3JtYXQocykgOiAnJXZhciUnKVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRk9STUFUXzIgOiBcIlRoZSBmb3JtYXQgb2YgdGhlIHNlcnZpY2UgcmVzcG9uc2UgaXMgbm90IHN1cHBvcnRlZFwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRk9STUFUXzMgOiBcIk5vIHN1Z2dlc3Rpb24gbWF0Y2hpbmcgdGhlIHNlYXJjaFwiLFxuXG4gICAgLy8gQ2xhc3Nlc1xuICAgIENMQVNTX0NPTlNUUlVDVE9SIDogXCInJXZhciUnIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIixcblxuICAgIC8qKlxuICAgICAqIEZvbmN0aW9uIHF1aSB2YSByZXRvdXJuZXIgbGUgbWVzc2FnZSBkJ2VycmV1ciBhc3NvY2nDqSDDoCBsYSBjbMOpIGRvbm7DqWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0TWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGVmIC0gQ2xlZiBkZSBsJ2VycmV1ciAoZXggOiBFUlJPUl9QQVJBTSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJhbWV0cmVzIC0gUGFyYW3DqHRyZXMvdmFyaWFibGVzIGNvbmNlcm7DqXMgcGFyIGxlIG1lc3NhZ2UgZCdlcnJldXIgYXNzb2Npw6kgw6AgbGEgY2xlZiBkb25uw6llXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBtZXNzYWdlIC0gU3RyaW5nIGNvbnRlbmFudCBsZSBtZXNzYWdlIGRlIGwnZXhjZXB0aW9uXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZSA6IGZ1bmN0aW9uIChjbGVmLCBwYXJhbWV0cmVzKSB7XG4gICAgICAgIC8vIHBhcmFtIGRlIGxhIGZvbmN0aW9uIHVuaXF1ZW1lbnQgcG91ciBsYSBkb2N1bWVudGF0aW9uLi4uXG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFyZ3VtZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlIGluZGVmaW5lZCAhXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcmFtcy5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJncyA9IHBhcmFtcztcblxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXNba2V5XTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcIiV2YXIlXCIsIGFyZ3Muam9pbihcIiAtIFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXCIldmFyJVwiLCBcIiV2YXIlIChub3Qgc3BlY2lmaWVkKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZXJyb3IgZGUgc3RyaW5nLnJlcGxhY2UoKVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlc1Jlc291cmNlcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\n");

/***/ }),

/***/ "./node_modules/leaflet-draw/dist/leaflet.draw-src.css":
/*!*************************************************************!*\
  !*** ./node_modules/leaflet-draw/dist/leaflet.draw-src.css ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvbGVhZmxldC1kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LXNyYy5jc3M/Y2FhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9sZWFmbGV0LWRyYXcvZGlzdC9sZWFmbGV0LmRyYXctc3JjLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/leaflet-draw/dist/leaflet.draw-src.css\n");

/***/ }),

/***/ "./node_modules/leaflet-draw/dist/leaflet.draw-src.js":
/*!************************************************************!*\
  !*** ./node_modules/leaflet-draw/dist/leaflet.draw-src.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n Leaflet.draw 1.0.4, a plugin that adds drawing and editing tools to Leaflet powered maps.\n (c) 2012-2017, Jacob Toye, Jon West, Smartrak, Leaflet\n\n https://github.com/Leaflet/Leaflet.draw\n http://leafletjs.com\n */\n(function (window, document, undefined) {/**\n * Leaflet.draw assumes that you have already included the Leaflet library.\n */\nL.drawVersion = \"1.0.4\";\n/**\n * @class L.Draw\n * @aka Draw\n *\n *\n * To add the draw toolbar set the option drawControl: true in the map options.\n *\n * @example\n * ```js\n *      var map = L.map('map', {drawControl: true}).setView([51.505, -0.09], 13);\n *\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n *      }).addTo(map);\n * ```\n *\n * ### Adding the edit toolbar\n * To use the edit toolbar you must initialise the Leaflet.draw control and manually add it to the map.\n *\n * ```js\n *      var map = L.map('map').setView([51.505, -0.09], 13);\n *\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n *      }).addTo(map);\n *\n *      // FeatureGroup is to store editable layers\n *      var drawnItems = new L.FeatureGroup();\n *      map.addLayer(drawnItems);\n *\n *      var drawControl = new L.Control.Draw({\n *          edit: {\n *              featureGroup: drawnItems\n *          }\n *      });\n *      map.addControl(drawControl);\n * ```\n *\n * The key here is the featureGroup option. This tells the plugin which FeatureGroup contains the layers that\n * should be editable. The featureGroup can contain 0 or more features with geometry types Point, LineString, and Polygon.\n * Leaflet.draw does not work with multigeometry features such as MultiPoint, MultiLineString, MultiPolygon,\n * or GeometryCollection. If you need to add multigeometry features to the draw plugin, convert them to a\n * FeatureCollection of non-multigeometries (Points, LineStrings, or Polygons).\n */\nL.Draw = {};\n\n/**\n * @class L.drawLocal\n * @aka L.drawLocal\n *\n * The core toolbar class of the API — it is used to create the toolbar ui\n *\n * @example\n * ```js\n *      var modifiedDraw = L.drawLocal.extend({\n *          draw: {\n *              toolbar: {\n *                  buttons: {\n *                      polygon: 'Draw an awesome polygon'\n *                  }\n *              }\n *          }\n *      });\n * ```\n *\n * The default state for the control is the draw toolbar just below the zoom control.\n *  This will allow map users to draw vectors and markers.\n *  **Please note the edit toolbar is not enabled by default.**\n */\nL.drawLocal = {\n\t// format: {\n\t// \tnumeric: {\n\t// \t\tdelimiters: {\n\t// \t\t\tthousands: ',',\n\t// \t\t\tdecimal: '.'\n\t// \t\t}\n\t// \t}\n\t// },\n\tdraw: {\n\t\ttoolbar: {\n\t\t\t// #TODO: this should be reorganized where actions are nested in actions\n\t\t\t// ex: actions.undo  or actions.cancel\n\t\t\tactions: {\n\t\t\t\ttitle: 'Cancel drawing',\n\t\t\t\ttext: 'Cancel'\n\t\t\t},\n\t\t\tfinish: {\n\t\t\t\ttitle: 'Finish drawing',\n\t\t\t\ttext: 'Finish'\n\t\t\t},\n\t\t\tundo: {\n\t\t\t\ttitle: 'Delete last point drawn',\n\t\t\t\ttext: 'Delete last point'\n\t\t\t},\n\t\t\tbuttons: {\n\t\t\t\tpolyline: 'Draw a polyline',\n\t\t\t\tpolygon: 'Draw a polygon',\n\t\t\t\trectangle: 'Draw a rectangle',\n\t\t\t\tcircle: 'Draw a circle',\n\t\t\t\tmarker: 'Draw a marker',\n\t\t\t\tcirclemarker: 'Draw a circlemarker'\n\t\t\t}\n\t\t},\n\t\thandlers: {\n\t\t\tcircle: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click and drag to draw circle.'\n\t\t\t\t},\n\t\t\t\tradius: 'Radius'\n\t\t\t},\n\t\t\tcirclemarker: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click map to place circle marker.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tmarker: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click map to place marker.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tpolygon: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click to start drawing shape.',\n\t\t\t\t\tcont: 'Click to continue drawing shape.',\n\t\t\t\t\tend: 'Click first point to close this shape.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tpolyline: {\n\t\t\t\terror: '<strong>Error:</strong> shape edges cannot cross!',\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click to start drawing line.',\n\t\t\t\t\tcont: 'Click to continue drawing line.',\n\t\t\t\t\tend: 'Click last point to finish line.'\n\t\t\t\t}\n\t\t\t},\n\t\t\trectangle: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click and drag to draw rectangle.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tsimpleshape: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tend: 'Release mouse to finish drawing.'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tedit: {\n\t\ttoolbar: {\n\t\t\tactions: {\n\t\t\t\tsave: {\n\t\t\t\t\ttitle: 'Save changes',\n\t\t\t\t\ttext: 'Save'\n\t\t\t\t},\n\t\t\t\tcancel: {\n\t\t\t\t\ttitle: 'Cancel editing, discards all changes',\n\t\t\t\t\ttext: 'Cancel'\n\t\t\t\t},\n\t\t\t\tclearAll: {\n\t\t\t\t\ttitle: 'Clear all layers',\n\t\t\t\t\ttext: 'Clear All'\n\t\t\t\t}\n\t\t\t},\n\t\t\tbuttons: {\n\t\t\t\tedit: 'Edit layers',\n\t\t\t\teditDisabled: 'No layers to edit',\n\t\t\t\tremove: 'Delete layers',\n\t\t\t\tremoveDisabled: 'No layers to delete'\n\t\t\t}\n\t\t},\n\t\thandlers: {\n\t\t\tedit: {\n\t\t\t\ttooltip: {\n\t\t\t\t\ttext: 'Drag handles or markers to edit features.',\n\t\t\t\t\tsubtext: 'Click cancel to undo changes.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tremove: {\n\t\t\t\ttooltip: {\n\t\t\t\t\ttext: 'Click on a feature to remove.'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n/**\n * ### Events\n * Once you have successfully added the Leaflet.draw plugin to your map you will want to respond to the different\n * actions users can initiate. The following events will be triggered on the map:\n *\n * @class L.Draw.Event\n * @aka Draw.Event\n *\n * Use `L.Draw.Event.EVENTNAME` constants to ensure events are correct.\n *\n * @example\n * ```js\n * map.on(L.Draw.Event.CREATED; function (e) {\n *    var type = e.layerType,\n *        layer = e.layer;\n *\n *    if (type === 'marker') {\n *        // Do marker specific actions\n *    }\n *\n *    // Do whatever else you need to. (save to db; add to map etc)\n *    map.addLayer(layer);\n *});\n * ```\n */\nL.Draw.Event = {};\n/**\n * @event draw:created: PolyLine; Polygon; Rectangle; Circle; Marker | String\n *\n * Layer that was just created.\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\n * Triggered when a new vector or marker has been created.\n *\n */\nL.Draw.Event.CREATED = 'draw:created';\n\n/**\n * @event draw:edited: LayerGroup\n *\n * List of all layers just edited on the map.\n *\n *\n * Triggered when layers in the FeatureGroup; initialised with the plugin; have been edited and saved.\n *\n * @example\n * ```js\n *      map.on('draw:edited', function (e) {\n     *          var layers = e.layers;\n     *          layers.eachLayer(function (layer) {\n     *              //do whatever you want; most likely save back to db\n     *          });\n     *      });\n * ```\n */\nL.Draw.Event.EDITED = 'draw:edited';\n\n/**\n * @event draw:deleted: LayerGroup\n *\n * List of all layers just removed from the map.\n *\n * Triggered when layers have been removed (and saved) from the FeatureGroup.\n */\nL.Draw.Event.DELETED = 'draw:deleted';\n\n/**\n * @event draw:drawstart: String\n *\n * The type of layer this is. One of:`polyline`; `polygon`; `rectangle`; `circle`; `marker`\n *\n * Triggered when the user has chosen to draw a particular vector or marker.\n */\nL.Draw.Event.DRAWSTART = 'draw:drawstart';\n\n/**\n * @event draw:drawstop: String\n *\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\n *\n * Triggered when the user has finished a particular vector or marker.\n */\n\nL.Draw.Event.DRAWSTOP = 'draw:drawstop';\n\n/**\n * @event draw:drawvertex: LayerGroup\n *\n * List of all layers just being added from the map.\n *\n * Triggered when a vertex is created on a polyline or polygon.\n */\nL.Draw.Event.DRAWVERTEX = 'draw:drawvertex';\n\n/**\n * @event draw:editstart: String\n *\n * The type of edit this is. One of: `edit`\n *\n * Triggered when the user starts edit mode by clicking the edit tool button.\n */\n\nL.Draw.Event.EDITSTART = 'draw:editstart';\n\n/**\n * @event draw:editmove: ILayer\n *\n *  Layer that was just moved.\n *\n * Triggered as the user moves a rectangle; circle or marker.\n */\nL.Draw.Event.EDITMOVE = 'draw:editmove';\n\n/**\n * @event draw:editresize: ILayer\n *\n * Layer that was just moved.\n *\n * Triggered as the user resizes a rectangle or circle.\n */\nL.Draw.Event.EDITRESIZE = 'draw:editresize';\n\n/**\n * @event draw:editvertex: LayerGroup\n *\n * List of all layers just being edited from the map.\n *\n * Triggered when a vertex is edited on a polyline or polygon.\n */\nL.Draw.Event.EDITVERTEX = 'draw:editvertex';\n\n/**\n * @event draw:editstop: String\n *\n * The type of edit this is. One of: `edit`\n *\n * Triggered when the user has finshed editing (edit mode) and saves edits.\n */\nL.Draw.Event.EDITSTOP = 'draw:editstop';\n\n/**\n * @event draw:deletestart: String\n *\n * The type of edit this is. One of: `remove`\n *\n * Triggered when the user starts remove mode by clicking the remove tool button.\n */\nL.Draw.Event.DELETESTART = 'draw:deletestart';\n\n/**\n * @event draw:deletestop: String\n *\n * The type of edit this is. One of: `remove`\n *\n * Triggered when the user has finished removing shapes (remove mode) and saves.\n */\nL.Draw.Event.DELETESTOP = 'draw:deletestop';\n\n/**\n * @event draw:toolbaropened: String\n *\n * Triggered when a toolbar is opened.\n */\nL.Draw.Event.TOOLBAROPENED = 'draw:toolbaropened';\n\n/**\n * @event draw:toolbarclosed: String\n *\n * Triggered when a toolbar is closed.\n */\nL.Draw.Event.TOOLBARCLOSED = 'draw:toolbarclosed';\n\n/**\n * @event draw:markercontext: String\n *\n * Triggered when a marker is right clicked.\n */\nL.Draw.Event.MARKERCONTEXT = 'draw:markercontext';\n\n\nL.Draw = L.Draw || {};\n\n/**\n * @class L.Draw.Feature\n * @aka Draw.Feature\n */\nL.Draw.Feature = L.Handler.extend({\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._overlayPane = map._panes.overlayPane;\n\t\tthis._popupPane = map._panes.popupPane;\n\n\t\t// Merge default shapeOptions options with custom shapeOptions\n\t\tif (options && options.shapeOptions) {\n\t\t\toptions.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);\n\t\t}\n\t\tL.setOptions(this, options);\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.Draw.Feature.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.Draw.Feature.include(L.Mixin.Events);\n\t\t}\n\t},\n\n\t// @method enable(): void\n\t// Enables this handler\n\tenable: function () {\n\t\tif (this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.Handler.prototype.enable.call(this);\n\n\t\tthis.fire('enabled', {handler: this.type});\n\n\t\tthis._map.fire(L.Draw.Event.DRAWSTART, {layerType: this.type});\n\t},\n\n\t// @method disable(): void\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.Handler.prototype.disable.call(this);\n\n\t\tthis._map.fire(L.Draw.Event.DRAWSTOP, {layerType: this.type});\n\n\t\tthis.fire('disabled', {handler: this.type});\n\t},\n\n\t// @method addHooks(): void\n\t// Add's event listeners to this handler\n\taddHooks: function () {\n\t\tvar map = this._map;\n\n\t\tif (map) {\n\t\t\tL.DomUtil.disableTextSelection();\n\n\t\t\tmap.getContainer().focus();\n\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\n\n\t\t\tL.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Removes event listeners from this handler\n\tremoveHooks: function () {\n\t\tif (this._map) {\n\t\t\tL.DomUtil.enableTextSelection();\n\n\t\t\tthis._tooltip.dispose();\n\t\t\tthis._tooltip = null;\n\n\t\t\tL.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);\n\t\t}\n\t},\n\n\t// @method setOptions(object): void\n\t// Sets new options to this handler\n\tsetOptions: function (options) {\n\t\tL.setOptions(this, options);\n\t},\n\n\t_fireCreatedEvent: function (layer) {\n\t\tthis._map.fire(L.Draw.Event.CREATED, {layer: layer, layerType: this.type});\n\t},\n\n\t// Cancel drawing when the escape key is pressed\n\t_cancelDrawing: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._map.fire('draw:canceled', {layerType: this.type});\n\t\t\tthis.disable();\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Polyline\n * @aka Draw.Polyline\n * @inherits L.Draw.Feature\n */\nL.Draw.Polyline = L.Draw.Feature.extend({\n\tstatics: {\n\t\tTYPE: 'polyline'\n\t},\n\n\tPoly: L.Polyline,\n\n\toptions: {\n\t\tallowIntersection: true,\n\t\trepeatMode: false,\n\t\tdrawError: {\n\t\t\tcolor: '#b00b00',\n\t\t\ttimeout: 2500\n\t\t},\n\t\ticon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\n\t\t}),\n\t\ttouchIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n\t\t}),\n\t\tguidelineDistance: 20,\n\t\tmaxGuideLineLength: 4000,\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: false,\n\t\t\tclickable: true\n\t\t},\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\n\t\tshowLength: true, // Whether to display distance in the tooltip\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any map layers\n\t\tfactor: 1, // To change distance calculation\n\t\tmaxPoints: 0 // Once this number of points are placed, finish shape\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.icon = this.options.touchIcon;\n\t\t}\n\n\t\t// Need to set this here to ensure the correct message is used.\n\t\tthis.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;\n\n\t\t// Merge default drawError options with custom options\n\t\tif (options && options.drawError) {\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n\t\t}\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Polyline.TYPE;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\t\tif (this._map) {\n\t\t\tthis._markers = [];\n\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t\tthis._map.addLayer(this._markerGroup);\n\n\t\t\tthis._poly = new L.Polyline([], this.options.shapeOptions);\n\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\n\n\t\t\t// Make a transparent marker that will used to catch click events. These click\n\t\t\t// events will create the vertices. We need to do this so we can ensure that\n\t\t\t// we can create vertices over other map layers (markers, vector layers). We\n\t\t\t// also do not want to trigger any click handlers of objects we are clicking on\n\t\t\t// while drawing.\n\t\t\tif (!this._mouseMarker) {\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\n\t\t\t\t\ticon: L.divIcon({\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\n\t\t\t\t\t\ticonAnchor: [20, 20],\n\t\t\t\t\t\ticonSize: [40, 40]\n\t\t\t\t\t}),\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mouseMarker\n\t\t\t\t.on('mouseout', this._onMouseOut, this)\n\t\t\t\t.on('mousemove', this._onMouseMove, this) // Necessary to prevent 0.8 stutter\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.8 compatibility\n\t\t\t\t.addTo(this._map);\n\n\t\t\tthis._map\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.7 compatibility\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t\t.on('touchstart', this._onTouch, this)\n\t\t\t\t.on('zoomend', this._onZoomEnd, this);\n\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\tthis._cleanUpShape();\n\n\t\t// remove markers from map\n\t\tthis._map.removeLayer(this._markerGroup);\n\t\tdelete this._markerGroup;\n\t\tdelete this._markers;\n\n\t\tthis._map.removeLayer(this._poly);\n\t\tdelete this._poly;\n\n\t\tthis._mouseMarker\n\t\t\t.off('mousedown', this._onMouseDown, this)\n\t\t\t.off('mouseout', this._onMouseOut, this)\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this);\n\t\tthis._map.removeLayer(this._mouseMarker);\n\t\tdelete this._mouseMarker;\n\n\t\t// clean up DOM\n\t\tthis._clearGuides();\n\n\t\tthis._map\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t.off('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t.off('zoomend', this._onZoomEnd, this)\n\t\t\t.off('touchstart', this._onTouch, this)\n\t\t\t.off('click', this._onTouch, this);\n\t},\n\n\t// @method deleteLastVertex(): void\n\t// Remove the last vertex from the polyline, removes polyline from map if only one point exists.\n\tdeleteLastVertex: function () {\n\t\tif (this._markers.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lastMarker = this._markers.pop(),\n\t\t\tpoly = this._poly,\n\t\t\t// Replaces .spliceLatLngs()\n\t\t\tlatlngs = poly.getLatLngs(),\n\t\t\tlatlng = latlngs.splice(-1, 1)[0];\n\t\tthis._poly.setLatLngs(latlngs);\n\n\t\tthis._markerGroup.removeLayer(lastMarker);\n\n\t\tif (poly.getLatLngs().length < 2) {\n\t\t\tthis._map.removeLayer(poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, false);\n\t},\n\n\t// @method addVertex(): void\n\t// Add a vertex to the end of the polyline\n\taddVertex: function (latlng) {\n\t\tvar markersLength = this._markers.length;\n\t\t// markersLength must be greater than or equal to 2 before intersections can occur\n\t\tif (markersLength >= 2 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\t\telse if (this._errorShown) {\n\t\t\tthis._hideErrorTooltip();\n\t\t}\n\n\t\tthis._markers.push(this._createMarker(latlng));\n\n\t\tthis._poly.addLatLng(latlng);\n\n\t\tif (this._poly.getLatLngs().length === 2) {\n\t\t\tthis._map.addLayer(this._poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, true);\n\t},\n\n\t// @method completeShape(): void\n\t// Closes the polyline between the first and last points\n\tcompleteShape: function () {\n\t\tif (this._markers.length <= 1 || !this._shapeIsValid()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t_finishShape: function () {\n\t\tvar latlngs = this._poly._defaultShape ? this._poly._defaultShape() : this._poly.getLatLngs();\n\t\tvar intersects = this._poly.newLatLngIntersects(latlngs[latlngs.length - 1]);\n\n\t\tif ((!this.options.allowIntersection && intersects) || !this._shapeIsValid()) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t// Called to verify the shape is valid when the user tries to finish it\n\t// Return false if the shape is not valid\n\t_shapeIsValid: function () {\n\t\treturn true;\n\t},\n\n\t_onZoomEnd: function () {\n\t\tif (this._markers !== null) {\n\t\t\tthis._updateGuide();\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar newPos = this._map.mouseEventToLayerPoint(e.originalEvent);\n\t\tvar latlng = this._map.layerPointToLatLng(newPos);\n\n\t\t// Save latlng\n\t\t// should this be moved to _updateGuide() ?\n\t\tthis._currentLatLng = latlng;\n\n\t\tthis._updateTooltip(latlng);\n\n\t\t// Update the guide line\n\t\tthis._updateGuide(newPos);\n\n\t\t// Update the mouse marker position\n\t\tthis._mouseMarker.setLatLng(latlng);\n\n\t\tL.DomEvent.preventDefault(e.originalEvent);\n\t},\n\n\t_vertexChanged: function (latlng, added) {\n\t\tthis._map.fire(L.Draw.Event.DRAWVERTEX, {layers: this._markerGroup});\n\t\tthis._updateFinishHandler();\n\n\t\tthis._updateRunningMeasure(latlng, added);\n\n\t\tthis._clearGuides();\n\n\t\tthis._updateTooltip();\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tif (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tthis._onMouseMove(e);\n\t\t\tthis._clickHandled = true;\n\t\t\tthis._disableNewMarkers();\n\t\t\tvar originalEvent = e.originalEvent;\n\t\t\tvar clientX = originalEvent.clientX;\n\t\t\tvar clientY = originalEvent.clientY;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t}\n\t},\n\n\t_startPoint: function (clientX, clientY) {\n\t\tthis._mouseDownOrigin = L.point(clientX, clientY);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX = originalEvent.clientX;\n\t\tvar clientY = originalEvent.clientY;\n\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\tthis._clickHandled = null;\n\t},\n\n\t_endPoint: function (clientX, clientY, e) {\n\t\tif (this._mouseDownOrigin) {\n\t\t\tvar dragCheckDistance = L.point(clientX, clientY)\n\t\t\t\t.distanceTo(this._mouseDownOrigin);\n\t\t\tvar lastPtDistance = this._calculateFinishDistance(e.latlng);\n\t\t\tif (this.options.maxPoints > 1 && this.options.maxPoints == this._markers.length + 1) {\n\t\t\t\tthis.addVertex(e.latlng);\n\t\t\t\tthis._finishShape();\n\t\t\t} else if (lastPtDistance < 10 && L.Browser.touch) {\n\t\t\t\tthis._finishShape();\n\t\t\t} else if (Math.abs(dragCheckDistance) < 9 * (window.devicePixelRatio || 1)) {\n\t\t\t\tthis.addVertex(e.latlng);\n\t\t\t}\n\t\t\tthis._enableNewMarkers(); // after a short pause, enable new markers\n\t\t}\n\t\tthis._mouseDownOrigin = null;\n\t},\n\n\t// ontouch prevented by clickHandled flag because some browsers fire both click/touch events,\n\t// causing unwanted behavior\n\t_onTouch: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX;\n\t\tvar clientY;\n\t\tif (originalEvent.touches && originalEvent.touches[0] && !this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tclientX = originalEvent.touches[0].clientX;\n\t\t\tclientY = originalEvent.touches[0].clientY;\n\t\t\tthis._disableNewMarkers();\n\t\t\tthis._touchHandled = true;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\t\tthis._touchHandled = null;\n\t\t}\n\t\tthis._clickHandled = null;\n\t},\n\n\t_onMouseOut: function () {\n\t\tif (this._tooltip) {\n\t\t\tthis._tooltip._onMouseOut.call(this._tooltip);\n\t\t}\n\t},\n\n\t// calculate if we are currently within close enough distance\n\t// of the closing point (first point for shapes, last point for lines)\n\t// this is semi-ugly code but the only reliable way i found to get the job done\n\t// note: calculating point.distanceTo between mouseDownOrigin and last marker did NOT work\n\t_calculateFinishDistance: function (potentialLatLng) {\n\t\tvar lastPtDistance;\n\t\tif (this._markers.length > 0) {\n\t\t\tvar finishMarker;\n\t\t\tif (this.type === L.Draw.Polyline.TYPE) {\n\t\t\t\tfinishMarker = this._markers[this._markers.length - 1];\n\t\t\t} else if (this.type === L.Draw.Polygon.TYPE) {\n\t\t\t\tfinishMarker = this._markers[0];\n\t\t\t} else {\n\t\t\t\treturn Infinity;\n\t\t\t}\n\t\t\tvar lastMarkerPoint = this._map.latLngToContainerPoint(finishMarker.getLatLng()),\n\t\t\t\tpotentialMarker = new L.Marker(potentialLatLng, {\n\t\t\t\t\ticon: this.options.icon,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t\t\t});\n\t\t\tvar potentialMarkerPint = this._map.latLngToContainerPoint(potentialMarker.getLatLng());\n\t\t\tlastPtDistance = lastMarkerPoint.distanceTo(potentialMarkerPint);\n\t\t} else {\n\t\t\tlastPtDistance = Infinity;\n\t\t}\n\t\treturn lastPtDistance;\n\t},\n\n\t_updateFinishHandler: function () {\n\t\tvar markerCount = this._markers.length;\n\t\t// The last marker should have a click handler to close the polyline\n\t\tif (markerCount > 1) {\n\t\t\tthis._markers[markerCount - 1].on('click', this._finishShape, this);\n\t\t}\n\n\t\t// Remove the old marker click handler (as only the last point should close the polyline)\n\t\tif (markerCount > 2) {\n\t\t\tthis._markers[markerCount - 2].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng) {\n\t\tvar marker = new L.Marker(latlng, {\n\t\t\ticon: this.options.icon,\n\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t});\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_updateGuide: function (newPos) {\n\t\tvar markerCount = this._markers ? this._markers.length : 0;\n\n\t\tif (markerCount > 0) {\n\t\t\tnewPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);\n\n\t\t\t// draw the guide line\n\t\t\tthis._clearGuides();\n\t\t\tthis._drawGuide(\n\t\t\t\tthis._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()),\n\t\t\t\tnewPos\n\t\t\t);\n\t\t}\n\t},\n\n\t_updateTooltip: function (latLng) {\n\t\tvar text = this._getTooltipText();\n\n\t\tif (latLng) {\n\t\t\tthis._tooltip.updatePosition(latLng);\n\t\t}\n\n\t\tif (!this._errorShown) {\n\t\t\tthis._tooltip.updateContent(text);\n\t\t}\n\t},\n\n\t_drawGuide: function (pointA, pointB) {\n\t\tvar length = Math.floor(Math.sqrt(Math.pow((pointB.x - pointA.x), 2) + Math.pow((pointB.y - pointA.y), 2))),\n\t\t\tguidelineDistance = this.options.guidelineDistance,\n\t\t\tmaxGuideLineLength = this.options.maxGuideLineLength,\n\t\t\t// Only draw a guideline with a max length\n\t\t\ti = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,\n\t\t\tfraction,\n\t\t\tdashPoint,\n\t\t\tdash;\n\n\t\t//create the guides container if we haven't yet\n\t\tif (!this._guidesContainer) {\n\t\t\tthis._guidesContainer = L.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);\n\t\t}\n\n\t\t//draw a dash every GuildeLineDistance\n\t\tfor (; i < length; i += this.options.guidelineDistance) {\n\t\t\t//work out fraction along line we are\n\t\t\tfraction = i / length;\n\n\t\t\t//calculate new x,y point\n\t\t\tdashPoint = {\n\t\t\t\tx: Math.floor((pointA.x * (1 - fraction)) + (fraction * pointB.x)),\n\t\t\t\ty: Math.floor((pointA.y * (1 - fraction)) + (fraction * pointB.y))\n\t\t\t};\n\n\t\t\t//add guide dash to guide container\n\t\t\tdash = L.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);\n\t\t\tdash.style.backgroundColor =\n\t\t\t\t!this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;\n\n\t\t\tL.DomUtil.setPosition(dash, dashPoint);\n\t\t}\n\t},\n\n\t_updateGuideColor: function (color) {\n\t\tif (this._guidesContainer) {\n\t\t\tfor (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {\n\t\t\t\tthis._guidesContainer.childNodes[i].style.backgroundColor = color;\n\t\t\t}\n\t\t}\n\t},\n\n\t// removes all child elements (guide dashes) from the guides container\n\t_clearGuides: function () {\n\t\tif (this._guidesContainer) {\n\t\t\twhile (this._guidesContainer.firstChild) {\n\t\t\t\tthis._guidesContainer.removeChild(this._guidesContainer.firstChild);\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar showLength = this.options.showLength,\n\t\t\tlabelText, distanceStr;\n\t\tif (this._markers.length === 0) {\n\t\t\tlabelText = {\n\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.start\n\t\t\t};\n\t\t} else {\n\t\t\tdistanceStr = showLength ? this._getMeasurementString() : '';\n\n\t\t\tif (this._markers.length === 1) {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.cont,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.end,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn labelText;\n\t},\n\n\t_updateRunningMeasure: function (latlng, added) {\n\t\tvar markersLength = this._markers.length,\n\t\t\tpreviousMarkerIndex, distance;\n\n\t\tif (this._markers.length === 1) {\n\t\t\tthis._measurementRunningTotal = 0;\n\t\t} else {\n\t\t\tpreviousMarkerIndex = markersLength - (added ? 2 : 1);\n\n\t\t\t// Calculate the distance based on the version\n\t\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\t\tdistance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\n\t\t\t} else {\n\t\t\t\tdistance = this._map.distance(latlng, this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\n\t\t\t}\n\n\t\t\tthis._measurementRunningTotal += distance * (added ? 1 : -1);\n\t\t}\n\t},\n\n\t_getMeasurementString: function () {\n\t\tvar currentLatLng = this._currentLatLng,\n\t\t\tpreviousLatLng = this._markers[this._markers.length - 1].getLatLng(),\n\t\t\tdistance;\n\n\t\t// Calculate the distance from the last fixed point to the mouse position based on the version\n\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\tdistance = previousLatLng && currentLatLng && currentLatLng.distanceTo ? this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\n\t\t} else {\n\t\t\tdistance = previousLatLng && currentLatLng ? this._measurementRunningTotal + this._map.distance(currentLatLng, previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\n\t\t}\n\n\t\treturn L.GeometryUtil.readableDistance(distance, this.options.metric, this.options.feet, this.options.nautic, this.options.precision);\n\t},\n\n\t_showErrorTooltip: function () {\n\t\tthis._errorShown = true;\n\n\t\t// Update tooltip\n\t\tthis._tooltip\n\t\t\t.showAsError()\n\t\t\t.updateContent({text: this.options.drawError.message});\n\n\t\t// Update shape\n\t\tthis._updateGuideColor(this.options.drawError.color);\n\t\tthis._poly.setStyle({color: this.options.drawError.color});\n\n\t\t// Hide the error after 2 seconds\n\t\tthis._clearHideErrorTimeout();\n\t\tthis._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);\n\t},\n\n\t_hideErrorTooltip: function () {\n\t\tthis._errorShown = false;\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\t// Revert tooltip\n\t\tthis._tooltip\n\t\t\t.removeError()\n\t\t\t.updateContent(this._getTooltipText());\n\n\t\t// Revert shape\n\t\tthis._updateGuideColor(this.options.shapeOptions.color);\n\t\tthis._poly.setStyle({color: this.options.shapeOptions.color});\n\t},\n\n\t_clearHideErrorTimeout: function () {\n\t\tif (this._hideErrorTimeout) {\n\t\t\tclearTimeout(this._hideErrorTimeout);\n\t\t\tthis._hideErrorTimeout = null;\n\t\t}\n\t},\n\n\t// disable new markers temporarily;\n\t// this is to prevent duplicated touch/click events in some browsers\n\t_disableNewMarkers: function () {\n\t\tthis._disableMarkers = true;\n\t},\n\n\t// see _disableNewMarkers\n\t_enableNewMarkers: function () {\n\t\tsetTimeout(function () {\n\t\t\tthis._disableMarkers = false;\n\t\t}.bind(this), 50);\n\t},\n\n\t_cleanUpShape: function () {\n\t\tif (this._markers.length > 1) {\n\t\t\tthis._markers[this._markers.length - 1].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Polygon\n * @aka Draw.Polygon\n * @inherits L.Draw.Polyline\n */\nL.Draw.Polygon = L.Draw.Polyline.extend({\n\tstatics: {\n\t\tTYPE: 'polygon'\n\t},\n\n\tPoly: L.Polygon,\n\n\toptions: {\n\t\tshowArea: false,\n\t\tshowLength: false,\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: true,\n\t\t\tfillColor: null, //same as color by default\n\t\t\tfillOpacity: 0.2,\n\t\t\tclickable: true\n\t\t},\n\t\t// Whether to use the metric measurement system (truthy) or not (falsy).\n\t\t// Also defines the units to use for the metric system as an array of\n\t\t// strings (e.g. `['ha', 'm']`).\n\t\tmetric: true,\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\n\t\t// Defines the precision for each type of unit (e.g. {km: 2, ft: 0}\n\t\tprecision: {}\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\tL.Draw.Polyline.prototype.initialize.call(this, map, options);\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Polygon.TYPE;\n\t},\n\n\t_updateFinishHandler: function () {\n\t\tvar markerCount = this._markers.length;\n\n\t\t// The first marker should have a click handler to close the polygon\n\t\tif (markerCount === 1) {\n\t\t\tthis._markers[0].on('click', this._finishShape, this);\n\t\t}\n\n\t\t// Add and update the double click handler\n\t\tif (markerCount > 2) {\n\t\t\tthis._markers[markerCount - 1].on('dblclick', this._finishShape, this);\n\t\t\t// Only need to remove handler if has been added before\n\t\t\tif (markerCount > 3) {\n\t\t\t\tthis._markers[markerCount - 2].off('dblclick', this._finishShape, this);\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar text, subtext;\n\n\t\tif (this._markers.length === 0) {\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.start;\n\t\t} else if (this._markers.length < 3) {\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.cont;\n\t\t\tsubtext = this._getMeasurementString();\n\t\t} else {\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.end;\n\t\t\tsubtext = this._getMeasurementString();\n\t\t}\n\n\t\treturn {\n\t\t\ttext: text,\n\t\t\tsubtext: subtext\n\t\t};\n\t},\n\n\t_getMeasurementString: function () {\n\t\tvar area = this._area,\n\t\t\tmeasurementString = '';\n\n\n\t\tif (!area && !this.options.showLength) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.options.showLength) {\n\t\t\tmeasurementString = L.Draw.Polyline.prototype._getMeasurementString.call(this);\n\t\t}\n\n\t\tif (area) {\n\t\t\tmeasurementString += '<br>' + L.GeometryUtil.readableArea(area, this.options.metric, this.options.precision);\n\t\t}\n\n\t\treturn measurementString;\n\t},\n\n\t_shapeIsValid: function () {\n\t\treturn this._markers.length >= 3;\n\t},\n\n\t_vertexChanged: function (latlng, added) {\n\t\tvar latLngs;\n\n\t\t// Check to see if we should show the area\n\t\tif (!this.options.allowIntersection && this.options.showArea) {\n\t\t\tlatLngs = this._poly.getLatLngs();\n\n\t\t\tthis._area = L.GeometryUtil.geodesicArea(latLngs);\n\t\t}\n\n\t\tL.Draw.Polyline.prototype._vertexChanged.call(this, latlng, added);\n\t},\n\n\t_cleanUpShape: function () {\n\t\tvar markerCount = this._markers.length;\n\n\t\tif (markerCount > 0) {\n\t\t\tthis._markers[0].off('click', this._finishShape, this);\n\n\t\t\tif (markerCount > 2) {\n\t\t\t\tthis._markers[markerCount - 1].off('dblclick', this._finishShape, this);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n\nL.SimpleShape = {};\n/**\n * @class L.Draw.SimpleShape\n * @aka Draw.SimpleShape\n * @inherits L.Draw.Feature\n */\nL.Draw.SimpleShape = L.Draw.Feature.extend({\n\toptions: {\n\t\trepeatMode: false\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\tthis._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\t\tif (this._map) {\n\t\t\tthis._mapDraggable = this._map.dragging.enabled();\n\n\t\t\tif (this._mapDraggable) {\n\t\t\t\tthis._map.dragging.disable();\n\t\t\t}\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\n\n\t\t\tthis._map\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('touchstart', this._onMouseDown, this)\n\t\t\t\t.on('touchmove', this._onMouseMove, this);\n\n\t\t\t// we should prevent default, otherwise default behavior (scrolling) will fire,\n\t\t\t// and that will cause document.touchend to fire and will stop the drawing\n\t\t\t// (circle, rectangle) in touch mode.\n\t\t\t// (update): we have to send passive now to prevent scroll, because by default it is {passive: true} now, which means,\n\t\t\t// handler can't event.preventDefault\n\t\t\t// check the news https://developers.google.com/web/updates/2016/06/passive-event-listeners\n\t\t\tdocument.addEventListener('touchstart', L.DomEvent.preventDefault, {passive: false});\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\t\tif (this._map) {\n\t\t\tif (this._mapDraggable) {\n\t\t\t\tthis._map.dragging.enable();\n\t\t\t}\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = '';\n\n\t\t\tthis._map\n\t\t\t\t.off('mousedown', this._onMouseDown, this)\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t\t.off('touchstart', this._onMouseDown, this)\n\t\t\t\t.off('touchmove', this._onMouseMove, this);\n\n\t\t\tL.DomEvent.off(document, 'mouseup', this._onMouseUp, this);\n\t\t\tL.DomEvent.off(document, 'touchend', this._onMouseUp, this);\n\n\t\t\tdocument.removeEventListener('touchstart', L.DomEvent.preventDefault);\n\n\t\t\t// If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return\n\t\t\tif (this._shape) {\n\t\t\t\tthis._map.removeLayer(this._shape);\n\t\t\t\tdelete this._shape;\n\t\t\t}\n\t\t}\n\t\tthis._isDrawing = false;\n\t},\n\n\t_getTooltipText: function () {\n\t\treturn {\n\t\t\ttext: this._endLabelText\n\t\t};\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._isDrawing = true;\n\t\tthis._startLatLng = e.latlng;\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'mouseup', this._onMouseUp, this)\n\t\t\t.on(document, 'touchend', this._onMouseUp, this)\n\t\t\t.preventDefault(e.originalEvent);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tif (this._isDrawing) {\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\n\t\t\tthis._drawShape(latlng);\n\t\t}\n\t},\n\n\t_onMouseUp: function () {\n\t\tif (this._shape) {\n\t\t\tthis._fireCreatedEvent();\n\t\t}\n\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Rectangle\n * @aka Draw.Rectangle\n * @inherits L.Draw.SimpleShape\n */\nL.Draw.Rectangle = L.Draw.SimpleShape.extend({\n\tstatics: {\n\t\tTYPE: 'rectangle'\n\t},\n\n\toptions: {\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: true,\n\t\t\tfillColor: null, //same as color by default\n\t\t\tfillOpacity: 0.2,\n\t\t\tclickable: true\n\t\t},\n\t\tshowArea: true, //Whether to show the area in the tooltip\n\t\tmetric: true // Whether to use the metric measurement system or imperial\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Rectangle.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;\n\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method disable(): void\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isCurrentlyTwoClickDrawing = false;\n\t\tL.Draw.SimpleShape.prototype.disable.call(this);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tif (!this._shape && !this._isCurrentlyTwoClickDrawing) {\n\t\t\tthis._isCurrentlyTwoClickDrawing = true;\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure closing click is on map\n\t\tif (this._isCurrentlyTwoClickDrawing && !_hasAncestor(e.target, 'leaflet-pane')) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.Draw.SimpleShape.prototype._onMouseUp.call(this);\n\t},\n\n\t_drawShape: function (latlng) {\n\t\tif (!this._shape) {\n\t\t\tthis._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);\n\t\t\tthis._map.addLayer(this._shape);\n\t\t} else {\n\t\t\tthis._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar tooltipText = L.Draw.SimpleShape.prototype._getTooltipText.call(this),\n\t\t\tshape = this._shape,\n\t\t\tshowArea = this.options.showArea,\n\t\t\tlatLngs, area, subtext;\n\n\t\tif (shape) {\n\t\t\tlatLngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs();\n\t\t\tarea = L.GeometryUtil.geodesicArea(latLngs);\n\t\t\tsubtext = showArea ? L.GeometryUtil.readableArea(area, this.options.metric) : '';\n\t\t}\n\n\t\treturn {\n\t\t\ttext: tooltipText.text,\n\t\t\tsubtext: subtext\n\t\t};\n\t}\n});\n\nfunction _hasAncestor(el, cls) {\n\twhile ((el = el.parentElement) && !el.classList.contains(cls)) {\n\t\t;\n\t}\n\treturn el;\n}\n\n\n\n/**\n * @class L.Draw.Marker\n * @aka Draw.Marker\n * @inherits L.Draw.Feature\n */\nL.Draw.Marker = L.Draw.Feature.extend({\n\tstatics: {\n\t\tTYPE: 'marker'\n\t},\n\n\toptions: {\n\t\ticon: new L.Icon.Default(),\n\t\trepeatMode: false,\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Marker.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.marker.tooltip.start;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\n\t\tif (this._map) {\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\n\n\t\t\t// Same mouseMarker as in Draw.Polyline\n\t\t\tif (!this._mouseMarker) {\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\n\t\t\t\t\ticon: L.divIcon({\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\n\t\t\t\t\t\ticonAnchor: [20, 20],\n\t\t\t\t\t\ticonSize: [40, 40]\n\t\t\t\t\t}),\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mouseMarker\n\t\t\t\t.on('click', this._onClick, this)\n\t\t\t\t.addTo(this._map);\n\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\n\t\t\tthis._map.on('click', this._onTouch, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\n\t\tif (this._map) {\n\t\t\tthis._map\n\t\t\t\t.off('click', this._onClick, this)\n\t\t\t\t.off('click', this._onTouch, this);\n\t\t\tif (this._marker) {\n\t\t\t\tthis._marker.off('click', this._onClick, this);\n\t\t\t\tthis._map\n\t\t\t\t\t.removeLayer(this._marker);\n\t\t\t\tdelete this._marker;\n\t\t\t}\n\n\t\t\tthis._mouseMarker.off('click', this._onClick, this);\n\t\t\tthis._map.removeLayer(this._mouseMarker);\n\t\t\tdelete this._mouseMarker;\n\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tthis._mouseMarker.setLatLng(latlng);\n\n\t\tif (!this._marker) {\n\t\t\tthis._marker = this._createMarker(latlng);\n\t\t\t// Bind to both marker and map to make sure we get the click event.\n\t\t\tthis._marker.on('click', this._onClick, this);\n\t\t\tthis._map\n\t\t\t\t.on('click', this._onClick, this)\n\t\t\t\t.addLayer(this._marker);\n\t\t}\n\t\telse {\n\t\t\tlatlng = this._mouseMarker.getLatLng();\n\t\t\tthis._marker.setLatLng(latlng);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng) {\n\t\treturn new L.Marker(latlng, {\n\t\t\ticon: this.options.icon,\n\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t});\n\t},\n\n\t_onClick: function () {\n\t\tthis._fireCreatedEvent();\n\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t_onTouch: function (e) {\n\t\t// called on click & tap, only really does any thing on tap\n\t\tthis._onMouseMove(e); // creates & places marker\n\t\tthis._onClick(); // permanently places marker & ends interaction\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar marker = new L.Marker.Touch(this._marker.getLatLng(), {icon: this.options.icon});\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.CircleMarker\n * @aka Draw.CircleMarker\n * @inherits L.Draw.Marker\n */\nL.Draw.CircleMarker = L.Draw.Marker.extend({\n\tstatics: {\n\t\tTYPE: 'circlemarker'\n\t},\n\n\toptions: {\n\t\tstroke: true,\n\t\tcolor: '#3388ff',\n\t\tweight: 4,\n\t\topacity: 0.5,\n\t\tfill: true,\n\t\tfillColor: null, //same as color by default\n\t\tfillOpacity: 0.2,\n\t\tclickable: true,\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.CircleMarker.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circlemarker.tooltip.start;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\n\t_fireCreatedEvent: function () {\n\t\tvar circleMarker = new L.CircleMarker(this._marker.getLatLng(), this.options);\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, circleMarker);\n\t},\n\n\t_createMarker: function (latlng) {\n\t\treturn new L.CircleMarker(latlng, this.options);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Circle\n * @aka Draw.Circle\n * @inherits L.Draw.SimpleShape\n */\nL.Draw.Circle = L.Draw.SimpleShape.extend({\n\tstatics: {\n\t\tTYPE: 'circle'\n\t},\n\n\toptions: {\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: true,\n\t\t\tfillColor: null, //same as color by default\n\t\t\tfillOpacity: 0.2,\n\t\t\tclickable: true\n\t\t},\n\t\tshowRadius: true,\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\n\t\tfeet: true, // When not metric, use feet instead of yards for display\n\t\tnautic: false // When not metric, not feet use nautic mile for display\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Circle.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;\n\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\n\t},\n\n\t_drawShape: function (latlng) {\n\t\t// Calculate the distance based on the version\n\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\tvar distance = this._startLatLng.distanceTo(latlng);\n\t\t} else {\n\t\t\tvar distance = this._map.distance(this._startLatLng, latlng);\n\t\t}\n\n\t\tif (!this._shape) {\n\t\t\tthis._shape = new L.Circle(this._startLatLng, distance, this.options.shapeOptions);\n\t\t\tthis._map.addLayer(this._shape);\n\t\t} else {\n\t\t\tthis._shape.setRadius(distance);\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng,\n\t\t\tshowRadius = this.options.showRadius,\n\t\t\tuseMetric = this.options.metric,\n\t\t\tradius;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tif (this._isDrawing) {\n\t\t\tthis._drawShape(latlng);\n\n\t\t\t// Get the new radius (rounded to 1 dp)\n\t\t\tradius = this._shape.getRadius().toFixed(1);\n\n\t\t\tvar subtext = '';\n\t\t\tif (showRadius) {\n\t\t\t\tsubtext = L.drawLocal.draw.handlers.circle.radius + ': ' +\n\t\t\t\t\tL.GeometryUtil.readableDistance(radius, useMetric, this.options.feet, this.options.nautic);\n\t\t\t}\n\t\t\tthis._tooltip.updateContent({\n\t\t\t\ttext: this._endLabelText,\n\t\t\t\tsubtext: subtext\n\t\t\t});\n\t\t}\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n\n/**\n * @class L.Edit.Marker\n * @aka Edit.Marker\n */\nL.Edit.Marker = L.Handler.extend({\n\t// @method initialize(): void\n\tinitialize: function (marker, options) {\n\t\tthis._marker = marker;\n\t\tL.setOptions(this, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tvar marker = this._marker;\n\n\t\tmarker.dragging.enable();\n\t\tmarker.on('dragend', this._onDragEnd, marker);\n\t\tthis._toggleMarkerHighlight();\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tvar marker = this._marker;\n\n\t\tmarker.dragging.disable();\n\t\tmarker.off('dragend', this._onDragEnd, marker);\n\t\tthis._toggleMarkerHighlight();\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar layer = e.target;\n\t\tlayer.edited = true;\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: layer});\n\t},\n\n\t_toggleMarkerHighlight: function () {\n\t\tvar icon = this._marker._icon;\n\n\t\t// Don't do anything if this layer is a marker but doesn't have an icon. Markers\n\t\t// should usually have icons. If using Leaflet.draw with Leaflet.markercluster there\n\t\t// is a chance that a marker doesn't.\n\t\tif (!icon) {\n\t\t\treturn;\n\t\t}\n\n\t\t// This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)\n\t\ticon.style.display = 'none';\n\n\t\tif (L.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {\n\t\t\tL.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected');\n\t\t\t// Offset as the border will make the icon move.\n\t\t\tthis._offsetMarker(icon, -4);\n\n\t\t} else {\n\t\t\tL.DomUtil.addClass(icon, 'leaflet-edit-marker-selected');\n\t\t\t// Offset as the border will make the icon move.\n\t\t\tthis._offsetMarker(icon, 4);\n\t\t}\n\n\t\ticon.style.display = '';\n\t},\n\n\t_offsetMarker: function (icon, offset) {\n\t\tvar iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,\n\t\t\ticonMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;\n\n\t\ticon.style.marginTop = iconMarginTop + 'px';\n\t\ticon.style.marginLeft = iconMarginLeft + 'px';\n\t}\n});\n\nL.Marker.addInitHook(function () {\n\tif (L.Edit.Marker) {\n\t\tthis.editing = new L.Edit.Marker(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n\n/**\n * @class L.Edit.Polyline\n * @aka L.Edit.Poly\n * @aka Edit.Poly\n */\nL.Edit.Poly = L.Handler.extend({\n\t// @method initialize(): void\n\tinitialize: function (poly) {\n\n\t\tthis.latlngs = [poly._latlngs];\n\t\tif (poly._holes) {\n\t\t\tthis.latlngs = this.latlngs.concat(poly._holes);\n\t\t}\n\n\t\tthis._poly = poly;\n\n\t\tthis._poly.on('revert-edited', this._updateLatLngs, this);\n\t},\n\n\t// Compatibility method to normalize Poly* objects\n\t// between 0.7.x and 1.0+\n\t_defaultShape: function () {\n\t\tif (!L.Polyline._flat) {\n\t\t\treturn this._poly._latlngs;\n\t\t}\n\t\treturn L.Polyline._flat(this._poly._latlngs) ? this._poly._latlngs : this._poly._latlngs[0];\n\t},\n\n\t_eachVertexHandler: function (callback) {\n\t\tfor (var i = 0; i < this._verticesHandlers.length; i++) {\n\t\t\tcallback(this._verticesHandlers[i]);\n\t\t}\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tthis._initHandlers();\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.addHooks();\n\t\t});\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.removeHooks();\n\t\t});\n\t},\n\n\t// @method updateMarkers(): void\n\t// Fire an update for each vertex handler\n\tupdateMarkers: function () {\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.updateMarkers();\n\t\t});\n\t},\n\n\t_initHandlers: function () {\n\t\tthis._verticesHandlers = [];\n\t\tfor (var i = 0; i < this.latlngs.length; i++) {\n\t\t\tthis._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly, this.latlngs[i], this._poly.options.poly));\n\t\t}\n\t},\n\n\t_updateLatLngs: function (e) {\n\t\tthis.latlngs = [e.layer._latlngs];\n\t\tif (e.layer._holes) {\n\t\t\tthis.latlngs = this.latlngs.concat(e.layer._holes);\n\t\t}\n\t}\n\n});\n\n/**\n * @class L.Edit.PolyVerticesEdit\n * @aka Edit.PolyVerticesEdit\n */\nL.Edit.PolyVerticesEdit = L.Handler.extend({\n\toptions: {\n\t\ticon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\n\t\t}),\n\t\ttouchIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n\t\t}),\n\t\tdrawError: {\n\t\t\tcolor: '#b00b00',\n\t\t\ttimeout: 1000\n\t\t}\n\n\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (poly, latlngs, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.icon = this.options.touchIcon;\n\t\t}\n\t\tthis._poly = poly;\n\n\t\tif (options && options.drawError) {\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n\t\t}\n\n\t\tthis._latlngs = latlngs;\n\n\t\tL.setOptions(this, options);\n\t},\n\n\t// Compatibility method to normalize Poly* objects\n\t// between 0.7.x and 1.0+\n\t_defaultShape: function () {\n\t\tif (!L.Polyline._flat) {\n\t\t\treturn this._latlngs;\n\t\t}\n\t\treturn L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tvar poly = this._poly;\n\t\tvar path = poly._path;\n\n\t\tif (!(poly instanceof L.Polygon)) {\n\t\t\tpoly.options.fill = false;\n\t\t\tif (poly.options.editing) {\n\t\t\t\tpoly.options.editing.fill = false;\n\t\t\t}\n\t\t}\n\n\t\tif (path) {\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\n\t\t\t\tif (poly.options.original.className) {\n\t\t\t\t\tpoly.options.original.className.split(' ').forEach(function (className) {\n\t\t\t\t\t\tL.DomUtil.removeClass(path, className);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tpoly.options.editing.className.split(' ').forEach(function (className) {\n\t\t\t\t\tL.DomUtil.addClass(path, className);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tpoly.setStyle(poly.options.editing);\n\n\t\tif (this._poly._map) {\n\n\t\t\tthis._map = this._poly._map; // Set map\n\n\t\t\tif (!this._markerGroup) {\n\t\t\t\tthis._initMarkers();\n\t\t\t}\n\t\t\tthis._poly._map.addLayer(this._markerGroup);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tvar poly = this._poly;\n\t\tvar path = poly._path;\n\n\t\tif (path) {\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\n\t\t\t\tpoly.options.editing.className.split(' ').forEach(function (className) {\n\t\t\t\t\tL.DomUtil.removeClass(path, className);\n\t\t\t\t});\n\t\t\t\tif (poly.options.original.className) {\n\t\t\t\t\tpoly.options.original.className.split(' ').forEach(function (className) {\n\t\t\t\t\t\tL.DomUtil.addClass(path, className);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpoly.setStyle(poly.options.original);\n\n\t\tif (poly._map) {\n\t\t\tpoly._map.removeLayer(this._markerGroup);\n\t\t\tdelete this._markerGroup;\n\t\t\tdelete this._markers;\n\t\t}\n\t},\n\n\t// @method updateMarkers(): void\n\t// Clear markers and update their location\n\tupdateMarkers: function () {\n\t\tthis._markerGroup.clearLayers();\n\t\tthis._initMarkers();\n\t},\n\n\t_initMarkers: function () {\n\t\tif (!this._markerGroup) {\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t}\n\t\tthis._markers = [];\n\n\t\tvar latlngs = this._defaultShape(),\n\t\t\ti, j, len, marker;\n\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\n\n\t\t\tmarker = this._createMarker(latlngs[i], i);\n\t\t\tmarker.on('click', this._onMarkerClick, this);\n\t\t\tmarker.on('contextmenu', this._onContextMenu, this);\n\t\t\tthis._markers.push(marker);\n\t\t}\n\n\t\tvar markerLeft, markerRight;\n\n\t\tfor (i = 0, j = len - 1; i < len; j = i++) {\n\t\t\tif (i === 0 && !(L.Polygon && (this._poly instanceof L.Polygon))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmarkerLeft = this._markers[j];\n\t\t\tmarkerRight = this._markers[i];\n\n\t\t\tthis._createMiddleMarker(markerLeft, markerRight);\n\t\t\tthis._updatePrevNext(markerLeft, markerRight);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng, index) {\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\n\t\tvar marker = new L.Marker.Touch(latlng, {\n\t\t\tdraggable: true,\n\t\t\ticon: this.options.icon,\n\t\t});\n\n\t\tmarker._origLatLng = latlng;\n\t\tmarker._index = index;\n\n\t\tmarker\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\n\t\t\t.on('drag', this._onMarkerDrag, this)\n\t\t\t.on('dragend', this._fireEdit, this)\n\t\t\t.on('touchmove', this._onTouchMove, this)\n\t\t\t.on('touchend', this._fireEdit, this)\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\n\t\t\t.on('MSPointerUp', this._fireEdit, this);\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_onMarkerDragStart: function () {\n\t\tthis._poly.fire('editstart');\n\t},\n\n\t_spliceLatLngs: function () {\n\t\tvar latlngs = this._defaultShape();\n\t\tvar removed = [].splice.apply(latlngs, arguments);\n\t\tthis._poly._convertLatLngs(latlngs, true);\n\t\tthis._poly.redraw();\n\t\treturn removed;\n\t},\n\n\t_removeMarker: function (marker) {\n\t\tvar i = marker._index;\n\n\t\tthis._markerGroup.removeLayer(marker);\n\t\tthis._markers.splice(i, 1);\n\t\tthis._spliceLatLngs(i, 1);\n\t\tthis._updateIndexes(i, -1);\n\n\t\tmarker\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\n\t\t\t.off('drag', this._onMarkerDrag, this)\n\t\t\t.off('dragend', this._fireEdit, this)\n\t\t\t.off('touchmove', this._onMarkerDrag, this)\n\t\t\t.off('touchend', this._fireEdit, this)\n\t\t\t.off('click', this._onMarkerClick, this)\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\n\t\t\t.off('MSPointerUp', this._fireEdit, this);\n\t},\n\n\t_fireEdit: function () {\n\t\tthis._poly.edited = true;\n\t\tthis._poly.fire('edit');\n\t\tthis._poly._map.fire(L.Draw.Event.EDITVERTEX, {layers: this._markerGroup, poly: this._poly});\n\t},\n\n\t_onMarkerDrag: function (e) {\n\t\tvar marker = e.target;\n\t\tvar poly = this._poly;\n\n\t\tvar oldOrigLatLng = L.LatLngUtil.cloneLatLng(marker._origLatLng);\n\t\tL.extend(marker._origLatLng, marker._latlng);\n\t\tif (poly.options.poly) {\n\t\t\tvar tooltip = poly._map._editTooltip; // Access the tooltip\n\n\t\t\t// If we don't allow intersections and the polygon intersects\n\t\t\tif (!poly.options.poly.allowIntersection && poly.intersects()) {\n\t\t\t\tL.extend(marker._origLatLng, oldOrigLatLng);\n\t\t\t\tmarker.setLatLng(oldOrigLatLng);\n\t\t\t\tvar originalColor = poly.options.color;\n\t\t\t\tpoly.setStyle({color: this.options.drawError.color});\n\t\t\t\tif (tooltip) {\n\t\t\t\t\ttooltip.updateContent({\n\t\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.error\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Reset everything back to normal after a second\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tpoly.setStyle({color: originalColor});\n\t\t\t\t\tif (tooltip) {\n\t\t\t\t\t\ttooltip.updateContent({\n\t\t\t\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\t\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}\n\n\t\tif (marker._middleLeft) {\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n\t\t}\n\n\t\t//refresh the bounds when draging\n\t\tthis._poly._bounds._southWest = L.latLng(Infinity, Infinity);\n\t\tthis._poly._bounds._northEast = L.latLng(-Infinity, -Infinity);\n\t\tvar latlngs = this._poly.getLatLngs();\n\t\tthis._poly._convertLatLngs(latlngs, true);\n\t\tthis._poly.redraw();\n\t\tthis._poly.fire('editdrag');\n\t},\n\n\t_onMarkerClick: function (e) {\n\n\t\tvar minPoints = L.Polygon && (this._poly instanceof L.Polygon) ? 4 : 3,\n\t\t\tmarker = e.target;\n\n\t\t// If removing this point would create an invalid polyline/polygon don't remove\n\t\tif (this._defaultShape().length < minPoints) {\n\t\t\treturn;\n\t\t}\n\n\t\t// remove the marker\n\t\tthis._removeMarker(marker);\n\n\t\t// update prev/next links of adjacent markers\n\t\tthis._updatePrevNext(marker._prev, marker._next);\n\n\t\t// remove ghost markers near the removed marker\n\t\tif (marker._middleLeft) {\n\t\t\tthis._markerGroup.removeLayer(marker._middleLeft);\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tthis._markerGroup.removeLayer(marker._middleRight);\n\t\t}\n\n\t\t// create a ghost marker in place of the removed one\n\t\tif (marker._prev && marker._next) {\n\t\t\tthis._createMiddleMarker(marker._prev, marker._next);\n\n\t\t} else if (!marker._prev) {\n\t\t\tmarker._next._middleLeft = null;\n\n\t\t} else if (!marker._next) {\n\t\t\tmarker._prev._middleRight = null;\n\t\t}\n\n\t\tthis._fireEdit();\n\t},\n\n\t_onContextMenu: function (e) {\n\t\tvar marker = e.target;\n\t\tvar poly = this._poly;\n\t\tthis._poly._map.fire(L.Draw.Event.MARKERCONTEXT, {marker: marker, layers: this._markerGroup, poly: this._poly});\n\t\tL.DomEvent.stopPropagation;\n\t},\n\n\t_onTouchMove: function (e) {\n\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\n\t\t\tmarker = e.target;\n\n\t\tL.extend(marker._origLatLng, latlng);\n\n\t\tif (marker._middleLeft) {\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n\t\t}\n\n\t\tthis._poly.redraw();\n\t\tthis.updateMarkers();\n\t},\n\n\t_updateIndexes: function (index, delta) {\n\t\tthis._markerGroup.eachLayer(function (marker) {\n\t\t\tif (marker._index > index) {\n\t\t\t\tmarker._index += delta;\n\t\t\t}\n\t\t});\n\t},\n\n\t_createMiddleMarker: function (marker1, marker2) {\n\t\tvar latlng = this._getMiddleLatLng(marker1, marker2),\n\t\t\tmarker = this._createMarker(latlng),\n\t\t\tonClick,\n\t\t\tonDragStart,\n\t\t\tonDragEnd;\n\n\t\tmarker.setOpacity(0.6);\n\n\t\tmarker1._middleRight = marker2._middleLeft = marker;\n\n\t\tonDragStart = function () {\n\t\t\tmarker.off('touchmove', onDragStart, this);\n\t\t\tvar i = marker2._index;\n\n\t\t\tmarker._index = i;\n\n\t\t\tmarker\n\t\t\t\t.off('click', onClick, this)\n\t\t\t\t.on('click', this._onMarkerClick, this);\n\n\t\t\tlatlng.lat = marker.getLatLng().lat;\n\t\t\tlatlng.lng = marker.getLatLng().lng;\n\t\t\tthis._spliceLatLngs(i, 0, latlng);\n\t\t\tthis._markers.splice(i, 0, marker);\n\n\t\t\tmarker.setOpacity(1);\n\n\t\t\tthis._updateIndexes(i, 1);\n\t\t\tmarker2._index++;\n\t\t\tthis._updatePrevNext(marker1, marker);\n\t\t\tthis._updatePrevNext(marker, marker2);\n\n\t\t\tthis._poly.fire('editstart');\n\t\t};\n\n\t\tonDragEnd = function () {\n\t\t\tmarker.off('dragstart', onDragStart, this);\n\t\t\tmarker.off('dragend', onDragEnd, this);\n\t\t\tmarker.off('touchmove', onDragStart, this);\n\n\t\t\tthis._createMiddleMarker(marker1, marker);\n\t\t\tthis._createMiddleMarker(marker, marker2);\n\t\t};\n\n\t\tonClick = function () {\n\t\t\tonDragStart.call(this);\n\t\t\tonDragEnd.call(this);\n\t\t\tthis._fireEdit();\n\t\t};\n\n\t\tmarker\n\t\t\t.on('click', onClick, this)\n\t\t\t.on('dragstart', onDragStart, this)\n\t\t\t.on('dragend', onDragEnd, this)\n\t\t\t.on('touchmove', onDragStart, this);\n\n\t\tthis._markerGroup.addLayer(marker);\n\t},\n\n\t_updatePrevNext: function (marker1, marker2) {\n\t\tif (marker1) {\n\t\t\tmarker1._next = marker2;\n\t\t}\n\t\tif (marker2) {\n\t\t\tmarker2._prev = marker1;\n\t\t}\n\t},\n\n\t_getMiddleLatLng: function (marker1, marker2) {\n\t\tvar map = this._poly._map,\n\t\t\tp1 = map.project(marker1.getLatLng()),\n\t\t\tp2 = map.project(marker2.getLatLng());\n\n\t\treturn map.unproject(p1._add(p2)._divideBy(2));\n\t}\n});\n\nL.Polyline.addInitHook(function () {\n\n\t// Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit\n\tif (this.editing) {\n\t\treturn;\n\t}\n\n\tif (L.Edit.Poly) {\n\n\t\tthis.editing = new L.Edit.Poly(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n\n\tthis.on('add', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.addHooks();\n\t\t}\n\t});\n\n\tthis.on('remove', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.removeHooks();\n\t\t}\n\t});\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.SimpleShape\n * @aka Edit.SimpleShape\n */\nL.Edit.SimpleShape = L.Handler.extend({\n\toptions: {\n\t\tmoveIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move'\n\t\t}),\n\t\tresizeIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize'\n\t\t}),\n\t\ttouchMoveIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon'\n\t\t}),\n\t\ttouchResizeIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon'\n\t\t}),\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (shape, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.moveIcon = this.options.touchMoveIcon;\n\t\t\tthis.options.resizeIcon = this.options.touchResizeIcon;\n\t\t}\n\n\t\tthis._shape = shape;\n\t\tL.Util.setOptions(this, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tvar shape = this._shape;\n\t\tif (this._shape._map) {\n\t\t\tthis._map = this._shape._map;\n\t\t\tshape.setStyle(shape.options.editing);\n\n\t\t\tif (shape._map) {\n\t\t\t\tthis._map = shape._map;\n\t\t\t\tif (!this._markerGroup) {\n\t\t\t\t\tthis._initMarkers();\n\t\t\t\t}\n\t\t\t\tthis._map.addLayer(this._markerGroup);\n\t\t\t}\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tvar shape = this._shape;\n\n\t\tshape.setStyle(shape.options.original);\n\n\t\tif (shape._map) {\n\t\t\tthis._unbindMarker(this._moveMarker);\n\n\t\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n\t\t\t\tthis._unbindMarker(this._resizeMarkers[i]);\n\t\t\t}\n\t\t\tthis._resizeMarkers = null;\n\n\t\t\tthis._map.removeLayer(this._markerGroup);\n\t\t\tdelete this._markerGroup;\n\t\t}\n\n\t\tthis._map = null;\n\t},\n\n\t// @method updateMarkers(): void\n\t// Remove the edit markers from this layer\n\tupdateMarkers: function () {\n\t\tthis._markerGroup.clearLayers();\n\t\tthis._initMarkers();\n\t},\n\n\t_initMarkers: function () {\n\t\tif (!this._markerGroup) {\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t}\n\n\t\t// Create center marker\n\t\tthis._createMoveMarker();\n\n\t\t// Create edge marker\n\t\tthis._createResizeMarker();\n\t},\n\n\t_createMoveMarker: function () {\n\t\t// Children override\n\t},\n\n\t_createResizeMarker: function () {\n\t\t// Children override\n\t},\n\n\t_createMarker: function (latlng, icon) {\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\n\t\tvar marker = new L.Marker.Touch(latlng, {\n\t\t\tdraggable: true,\n\t\t\ticon: icon,\n\t\t\tzIndexOffset: 10\n\t\t});\n\n\t\tthis._bindMarker(marker);\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_bindMarker: function (marker) {\n\t\tmarker\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\n\t\t\t.on('drag', this._onMarkerDrag, this)\n\t\t\t.on('dragend', this._onMarkerDragEnd, this)\n\t\t\t.on('touchstart', this._onTouchStart, this)\n\t\t\t.on('touchmove', this._onTouchMove, this)\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\n\t\t\t.on('touchend', this._onTouchEnd, this)\n\t\t\t.on('MSPointerUp', this._onTouchEnd, this);\n\t},\n\n\t_unbindMarker: function (marker) {\n\t\tmarker\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\n\t\t\t.off('drag', this._onMarkerDrag, this)\n\t\t\t.off('dragend', this._onMarkerDragEnd, this)\n\t\t\t.off('touchstart', this._onTouchStart, this)\n\t\t\t.off('touchmove', this._onTouchMove, this)\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\n\t\t\t.off('touchend', this._onTouchEnd, this)\n\t\t\t.off('MSPointerUp', this._onTouchEnd, this);\n\t},\n\n\t_onMarkerDragStart: function (e) {\n\t\tvar marker = e.target;\n\t\tmarker.setOpacity(0);\n\n\t\tthis._shape.fire('editstart');\n\t},\n\n\t_fireEdit: function () {\n\t\tthis._shape.edited = true;\n\t\tthis._shape.fire('edit');\n\t},\n\n\t_onMarkerDrag: function (e) {\n\t\tvar marker = e.target,\n\t\t\tlatlng = marker.getLatLng();\n\n\t\tif (marker === this._moveMarker) {\n\t\t\tthis._move(latlng);\n\t\t} else {\n\t\t\tthis._resize(latlng);\n\t\t}\n\n\t\tthis._shape.redraw();\n\t\tthis._shape.fire('editdrag');\n\t},\n\n\t_onMarkerDragEnd: function (e) {\n\t\tvar marker = e.target;\n\t\tmarker.setOpacity(1);\n\n\t\tthis._fireEdit();\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\n\n\t\tif (typeof(this._getCorners) === 'function') {\n\t\t\t// Save a reference to the opposite point\n\t\t\tvar corners = this._getCorners(),\n\t\t\t\tmarker = e.target,\n\t\t\t\tcurrentCornerIndex = marker._cornerIndex;\n\n\t\t\tmarker.setOpacity(0);\n\n\t\t\t// Copyed from Edit.Rectangle.js line 23 _onMarkerDragStart()\n\t\t\t// Latlng is null otherwise.\n\t\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\n\t\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\n\t\t}\n\n\t\tthis._shape.fire('editstart');\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\n\t\t\tmarker = e.target;\n\n\t\tif (marker === this._moveMarker) {\n\t\t\tthis._move(latlng);\n\t\t} else {\n\t\t\tthis._resize(latlng);\n\t\t}\n\n\t\tthis._shape.redraw();\n\n\t\t// prevent touchcancel in IOS\n\t\t// e.preventDefault();\n\t\treturn false;\n\t},\n\n\t_onTouchEnd: function (e) {\n\t\tvar marker = e.target;\n\t\tmarker.setOpacity(1);\n\t\tthis.updateMarkers();\n\t\tthis._fireEdit();\n\t},\n\n\t_move: function () {\n\t\t// Children override\n\t},\n\n\t_resize: function () {\n\t\t// Children override\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.Rectangle\n * @aka Edit.Rectangle\n * @inherits L.Edit.SimpleShape\n */\nL.Edit.Rectangle = L.Edit.SimpleShape.extend({\n\t_createMoveMarker: function () {\n\t\tvar bounds = this._shape.getBounds(),\n\t\t\tcenter = bounds.getCenter();\n\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\n\t},\n\n\t_createResizeMarker: function () {\n\t\tvar corners = this._getCorners();\n\n\t\tthis._resizeMarkers = [];\n\n\t\tfor (var i = 0, l = corners.length; i < l; i++) {\n\t\t\tthis._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon));\n\t\t\t// Monkey in the corner index as we will need to know this for dragging\n\t\t\tthis._resizeMarkers[i]._cornerIndex = i;\n\t\t}\n\t},\n\n\t_onMarkerDragStart: function (e) {\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\n\n\t\t// Save a reference to the opposite point\n\t\tvar corners = this._getCorners(),\n\t\t\tmarker = e.target,\n\t\t\tcurrentCornerIndex = marker._cornerIndex;\n\n\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\n\n\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\n\t},\n\n\t_onMarkerDragEnd: function (e) {\n\t\tvar marker = e.target,\n\t\t\tbounds, center;\n\n\t\t// Reset move marker position to the center\n\t\tif (marker === this._moveMarker) {\n\t\t\tbounds = this._shape.getBounds();\n\t\t\tcenter = bounds.getCenter();\n\n\t\t\tmarker.setLatLng(center);\n\t\t}\n\n\t\tthis._toggleCornerMarkers(1);\n\n\t\tthis._repositionCornerMarkers();\n\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);\n\t},\n\n\t_move: function (newCenter) {\n\t\tvar latlngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(),\n\t\t\tbounds = this._shape.getBounds(),\n\t\t\tcenter = bounds.getCenter(),\n\t\t\toffset, newLatLngs = [];\n\n\t\t// Offset the latlngs to the new center\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\n\t\t\toffset = [latlngs[i].lat - center.lat, latlngs[i].lng - center.lng];\n\t\t\tnewLatLngs.push([newCenter.lat + offset[0], newCenter.lng + offset[1]]);\n\t\t}\n\n\t\tthis._shape.setLatLngs(newLatLngs);\n\n\t\t// Reposition the resize markers\n\t\tthis._repositionCornerMarkers();\n\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\n\t},\n\n\t_resize: function (latlng) {\n\t\tvar bounds;\n\n\t\t// Update the shape based on the current position of this corner and the opposite point\n\t\tthis._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner));\n\n\t\t// Reposition the move marker\n\t\tbounds = this._shape.getBounds();\n\t\tthis._moveMarker.setLatLng(bounds.getCenter());\n\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\n\t},\n\n\t_getCorners: function () {\n\t\tvar bounds = this._shape.getBounds(),\n\t\t\tnw = bounds.getNorthWest(),\n\t\t\tne = bounds.getNorthEast(),\n\t\t\tse = bounds.getSouthEast(),\n\t\t\tsw = bounds.getSouthWest();\n\n\t\treturn [nw, ne, se, sw];\n\t},\n\n\t_toggleCornerMarkers: function (opacity) {\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n\t\t\tthis._resizeMarkers[i].setOpacity(opacity);\n\t\t}\n\t},\n\n\t_repositionCornerMarkers: function () {\n\t\tvar corners = this._getCorners();\n\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n\t\t\tthis._resizeMarkers[i].setLatLng(corners[i]);\n\t\t}\n\t}\n});\n\nL.Rectangle.addInitHook(function () {\n\tif (L.Edit.Rectangle) {\n\t\tthis.editing = new L.Edit.Rectangle(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.CircleMarker\n * @aka Edit.Circle\n * @inherits L.Edit.SimpleShape\n */\nL.Edit.CircleMarker = L.Edit.SimpleShape.extend({\n\t_createMoveMarker: function () {\n\t\tvar center = this._shape.getLatLng();\n\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\n\t},\n\n\t_createResizeMarker: function () {\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\n\t\tthis._resizeMarkers = [];\n\t},\n\n\t_move: function (latlng) {\n\t\tif (this._resizeMarkers.length) {\n\t\t\tvar resizemarkerPoint = this._getResizeMarkerPoint(latlng);\n\t\t\t// Move the resize marker\n\t\t\tthis._resizeMarkers[0].setLatLng(resizemarkerPoint);\n\t\t}\n\n\t\t// Move the circle\n\t\tthis._shape.setLatLng(latlng);\n\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\n\t},\n});\n\nL.CircleMarker.addInitHook(function () {\n\tif (L.Edit.CircleMarker) {\n\t\tthis.editing = new L.Edit.CircleMarker(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n\n\tthis.on('add', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.addHooks();\n\t\t}\n\t});\n\n\tthis.on('remove', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.removeHooks();\n\t\t}\n\t});\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.Circle\n * @aka Edit.Circle\n * @inherits L.Edit.CircleMarker\n */\nL.Edit.Circle = L.Edit.CircleMarker.extend({\n\n\t_createResizeMarker: function () {\n\t\tvar center = this._shape.getLatLng(),\n\t\t\tresizemarkerPoint = this._getResizeMarkerPoint(center);\n\n\t\tthis._resizeMarkers = [];\n\t\tthis._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));\n\t},\n\n\t_getResizeMarkerPoint: function (latlng) {\n\t\t// From L.shape.getBounds()\n\t\tvar delta = this._shape._radius * Math.cos(Math.PI / 4),\n\t\t\tpoint = this._map.project(latlng);\n\t\treturn this._map.unproject([point.x + delta, point.y - delta]);\n\t},\n\n\t_resize: function (latlng) {\n\t\tvar moveLatLng = this._moveMarker.getLatLng();\n\n\t\t// Calculate the radius based on the version\n\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\tradius = moveLatLng.distanceTo(latlng);\n\t\t} else {\n\t\t\tradius = this._map.distance(moveLatLng, latlng);\n\t\t}\n\t\tthis._shape.setRadius(radius);\n\n\t\tif (this._map.editTooltip) {\n\t\t\tthis._map._editTooltip.updateContent({\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.subtext + '<br />' + L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\t\tsubtext: L.drawLocal.draw.handlers.circle.radius + ': ' +\n\t\t\t\tL.GeometryUtil.readableDistance(radius, true, this.options.feet, this.options.nautic)\n\t\t\t});\n\t\t}\n\n\t\tthis._shape.setRadius(radius);\n\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\n\t}\n});\n\nL.Circle.addInitHook(function () {\n\tif (L.Edit.Circle) {\n\t\tthis.editing = new L.Edit.Circle(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n});\n\n\n\nL.Map.mergeOptions({\n\ttouchExtend: true\n});\n\n/**\n * @class L.Map.TouchExtend\n * @aka TouchExtend\n */\nL.Map.TouchExtend = L.Handler.extend({\n\n\t// @method initialize(): void\n\t// Sets TouchExtend private accessor variables\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t},\n\n\t// @method addHooks(): void\n\t// Adds dom listener events to the map container\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);\n\t\tL.DomEvent.on(this._container, 'touchend', this._onTouchEnd, this);\n\t\tL.DomEvent.on(this._container, 'touchmove', this._onTouchMove, this);\n\t\tif (this._detectIE()) {\n\t\t\tL.DomEvent.on(this._container, 'MSPointerDown', this._onTouchStart, this);\n\t\t\tL.DomEvent.on(this._container, 'MSPointerUp', this._onTouchEnd, this);\n\t\t\tL.DomEvent.on(this._container, 'MSPointerMove', this._onTouchMove, this);\n\t\t\tL.DomEvent.on(this._container, 'MSPointerCancel', this._onTouchCancel, this);\n\n\t\t} else {\n\t\t\tL.DomEvent.on(this._container, 'touchcancel', this._onTouchCancel, this);\n\t\t\tL.DomEvent.on(this._container, 'touchleave', this._onTouchLeave, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Removes dom listener events from the map container\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'touchstart', this._onTouchStart, this);\n\t\tL.DomEvent.off(this._container, 'touchend', this._onTouchEnd, this);\n\t\tL.DomEvent.off(this._container, 'touchmove', this._onTouchMove, this);\n\t\tif (this._detectIE()) {\n\t\t\tL.DomEvent.off(this._container, 'MSPointerDown', this._onTouchStart, this);\n\t\t\tL.DomEvent.off(this._container, 'MSPointerUp', this._onTouchEnd, this);\n\t\t\tL.DomEvent.off(this._container, 'MSPointerMove', this._onTouchMove, this);\n\t\t\tL.DomEvent.off(this._container, 'MSPointerCancel', this._onTouchCancel, this);\n\t\t} else {\n\t\t\tL.DomEvent.off(this._container, 'touchcancel', this._onTouchCancel, this);\n\t\t\tL.DomEvent.off(this._container, 'touchleave', this._onTouchLeave, this);\n\t\t}\n\t},\n\n\t_touchEvent: function (e, type) {\n\t\t// #TODO: fix the pageX error that is do a bug in Android where a single touch triggers two click events\n\t\t// _filterClick is what leaflet uses as a workaround.\n\t\t// This is a problem with more things than just android. Another problem is touchEnd has no touches in\n\t\t// its touch list.\n\t\tvar touchEvent = {};\n\t\tif (typeof e.touches !== 'undefined') {\n\t\t\tif (!e.touches.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttouchEvent = e.touches[0];\n\t\t} else if (e.pointerType === 'touch') {\n\t\t\ttouchEvent = e;\n\t\t\tif (!this._filterClick(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tvar containerPoint = this._map.mouseEventToContainerPoint(touchEvent),\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\n\n\t\tthis._map.fire(type, {\n\t\t\tlatlng: latlng,\n\t\t\tlayerPoint: layerPoint,\n\t\t\tcontainerPoint: containerPoint,\n\t\t\tpageX: touchEvent.pageX,\n\t\t\tpageY: touchEvent.pageY,\n\t\t\toriginalEvent: e\n\t\t});\n\t},\n\n\t/** Borrowed from Leaflet and modified for bool ops **/\n\t_filterClick: function (e) {\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\n\n\t\t// are they closer together than 500ms yet more than 100ms?\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\n\t\t// on the same event should be triggered far faster;\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\n\t\t\tL.DomEvent.stop(e);\n\t\t\treturn false;\n\t\t}\n\t\tL.DomEvent._lastClick = timeStamp;\n\t\treturn true;\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchstart';\n\t\tthis._touchEvent(e, type);\n\n\t},\n\n\t_onTouchEnd: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchend';\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_onTouchCancel: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchcancel';\n\t\tif (this._detectIE()) {\n\t\t\ttype = 'pointercancel';\n\t\t}\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_onTouchLeave: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchleave';\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchmove';\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_detectIE: function () {\n\t\tvar ua = window.navigator.userAgent;\n\n\t\tvar msie = ua.indexOf('MSIE ');\n\t\tif (msie > 0) {\n\t\t\t// IE 10 or older => return version number\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t\t}\n\n\t\tvar trident = ua.indexOf('Trident/');\n\t\tif (trident > 0) {\n\t\t\t// IE 11 => return version number\n\t\t\tvar rv = ua.indexOf('rv:');\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t\t}\n\n\t\tvar edge = ua.indexOf('Edge/');\n\t\tif (edge > 0) {\n\t\t\t// IE 12 => return version number\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t\t}\n\n\t\t// other browser\n\t\treturn false;\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchExtend', L.Map.TouchExtend);\n\n\n/**\n * @class L.Marker.Touch\n * @aka Marker.Touch\n *\n * This isn't full Touch support. This is just to get markers to also support dom touch events after creation\n * #TODO: find a better way of getting markers to support touch.\n */\nL.Marker.Touch = L.Marker.extend({\n\n\t_initInteraction: function () {\n\t\tif (!this.addInteractiveTarget) {\n\t\t\t// 0.7.x support\n\t\t\treturn this._initInteractionLegacy();\n\t\t}\n\t\t// TODO this may need be updated to re-add touch events for 1.0+\n\t\treturn L.Marker.prototype._initInteraction.apply(this);\n\t},\n\n\t// This is an exact copy of https://github.com/Leaflet/Leaflet/blob/v0.7/src/layer/marker/Marker.js\n\t// with the addition of the touch events\n\t_initInteractionLegacy: function () {\n\n\t\tif (!this.options.clickable) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\n\n\t\tvar icon = this._icon,\n\t\t\tevents = ['dblclick',\n\t\t\t\t'mousedown',\n\t\t\t\t'mouseover',\n\t\t\t\t'mouseout',\n\t\t\t\t'contextmenu',\n\t\t\t\t'touchstart',\n\t\t\t\t'touchend',\n\t\t\t\t'touchmove'];\n\t\tif (this._detectIE) {\n\t\t\tevents.concat(['MSPointerDown',\n\t\t\t\t'MSPointerUp',\n\t\t\t\t'MSPointerMove',\n\t\t\t\t'MSPointerCancel']);\n\t\t} else {\n\t\t\tevents.concat(['touchcancel']);\n\t\t}\n\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\n\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\n\t\t}\n\n\t\tif (L.Handler.MarkerDrag) {\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\n\n\t\t\tif (this.options.draggable) {\n\t\t\t\tthis.dragging.enable();\n\t\t\t}\n\t\t}\n\t},\n\n\t_detectIE: function () {\n\t\tvar ua = window.navigator.userAgent;\n\n\t\tvar msie = ua.indexOf('MSIE ');\n\t\tif (msie > 0) {\n\t\t\t// IE 10 or older => return version number\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t\t}\n\n\t\tvar trident = ua.indexOf('Trident/');\n\t\tif (trident > 0) {\n\t\t\t// IE 11 => return version number\n\t\t\tvar rv = ua.indexOf('rv:');\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t\t}\n\n\t\tvar edge = ua.indexOf('Edge/');\n\t\tif (edge > 0) {\n\t\t\t// IE 12 => return version number\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t\t}\n\n\t\t// other browser\n\t\treturn false;\n\t}\n});\n\n\n\n/**\n * @class L.LatLngUtil\n * @aka LatLngUtil\n */\nL.LatLngUtil = {\n\t// Clones a LatLngs[], returns [][]\n\n\t// @method cloneLatLngs(LatLngs[]): L.LatLngs[]\n\t// Clone the latLng point or points or nested points and return an array with those points\n\tcloneLatLngs: function (latlngs) {\n\t\tvar clone = [];\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\n\t\t\t// Check for nested array (Polyline/Polygon)\n\t\t\tif (Array.isArray(latlngs[i])) {\n\t\t\t\tclone.push(L.LatLngUtil.cloneLatLngs(latlngs[i]));\n\t\t\t} else {\n\t\t\t\tclone.push(this.cloneLatLng(latlngs[i]));\n\t\t\t}\n\t\t}\n\t\treturn clone;\n\t},\n\n\t// @method cloneLatLng(LatLng): L.LatLng\n\t// Clone the latLng and return a new LatLng object.\n\tcloneLatLng: function (latlng) {\n\t\treturn L.latLng(latlng.lat, latlng.lng);\n\t}\n};\n\n\n\n(function () {\n\n\tvar defaultPrecision = {\n\t\tkm: 2,\n\t\tha: 2,\n\t\tm: 0,\n\t\tmi: 2,\n\t\tac: 2,\n\t\tyd: 0,\n\t\tft: 0,\n\t\tnm: 2\n\t};\n\n\n\t/**\n\t * @class L.GeometryUtil\n\t * @aka GeometryUtil\n\t */\n\tL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\t\t// Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270\n\n\t\t// @method geodesicArea(): number\n\t\tgeodesicArea: function (latLngs) {\n\t\t\tvar pointsCount = latLngs.length,\n\t\t\t\tarea = 0.0,\n\t\t\t\td2r = Math.PI / 180,\n\t\t\t\tp1, p2;\n\n\t\t\tif (pointsCount > 2) {\n\t\t\t\tfor (var i = 0; i < pointsCount; i++) {\n\t\t\t\t\tp1 = latLngs[i];\n\t\t\t\t\tp2 = latLngs[(i + 1) % pointsCount];\n\t\t\t\t\tarea += ((p2.lng - p1.lng) * d2r) *\n\t\t\t\t\t\t(2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));\n\t\t\t\t}\n\t\t\t\tarea = area * 6378137.0 * 6378137.0 / 2.0;\n\t\t\t}\n\n\t\t\treturn Math.abs(area);\n\t\t},\n\n\t\t// @method formattedNumber(n, precision): string\n\t\t// Returns n in specified number format (if defined) and precision\n\t\tformattedNumber: function (n, precision) {\n\t\t\tvar formatted = parseFloat(n).toFixed(precision),\n\t\t\t\tformat = L.drawLocal.format && L.drawLocal.format.numeric,\n\t\t\t\tdelimiters = format && format.delimiters,\n\t\t\t\tthousands = delimiters && delimiters.thousands,\n\t\t\t\tdecimal = delimiters && delimiters.decimal;\n\n\t\t\tif (thousands || decimal) {\n\t\t\t\tvar splitValue = formatted.split('.');\n\t\t\t\tformatted = thousands ? splitValue[0].replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + thousands) : splitValue[0];\n\t\t\t\tdecimal = decimal || '.';\n\t\t\t\tif (splitValue.length > 1) {\n\t\t\t\t\tformatted = formatted + decimal + splitValue[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formatted;\n\t\t},\n\n\t\t// @method readableArea(area, isMetric, precision): string\n\t\t// Returns a readable area string in yards or metric.\n\t\t// The value will be rounded as defined by the precision option object.\n\t\treadableArea: function (area, isMetric, precision) {\n\t\t\tvar areaStr,\n\t\t\t\tunits,\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\t\tif (isMetric) {\n\t\t\t\tunits = ['ha', 'm'];\n\t\t\t\ttype = typeof isMetric;\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tunits = [isMetric];\n\t\t\t\t} else if (type !== 'boolean') {\n\t\t\t\t\tunits = isMetric;\n\t\t\t\t}\n\n\t\t\t\tif (area >= 1000000 && units.indexOf('km') !== -1) {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.000001, precision['km']) + ' km²';\n\t\t\t\t} else if (area >= 10000 && units.indexOf('ha') !== -1) {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.0001, precision['ha']) + ' ha';\n\t\t\t\t} else {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['m']) + ' m²';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarea /= 0.836127; // Square yards in 1 meter\n\n\t\t\t\tif (area >= 3097600) { //3097600 square yards in 1 square mile\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 3097600, precision['mi']) + ' mi²';\n\t\t\t\t} else if (area >= 4840) { //4840 square yards in 1 acre\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 4840, precision['ac']) + ' acres';\n\t\t\t\t} else {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['yd']) + ' yd²';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn areaStr;\n\t\t},\n\n\t\t// @method readableDistance(distance, units): string\n\t\t// Converts a metric distance to one of [ feet, nauticalMile, metric or yards ] string\n\t\t//\n\t\t// @alternative\n\t\t// @method readableDistance(distance, isMetric, useFeet, isNauticalMile, precision): string\n\t\t// Converts metric distance to distance string.\n\t\t// The value will be rounded as defined by the precision option object.\n\t\treadableDistance: function (distance, isMetric, isFeet, isNauticalMile, precision) {\n\t\t\tvar distanceStr,\n\t\t\t\tunits,\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\t\tif (isMetric) {\n\t\t\t\tunits = typeof isMetric == 'string' ? isMetric : 'metric';\n\t\t\t} else if (isFeet) {\n\t\t\t\tunits = 'feet';\n\t\t\t} else if (isNauticalMile) {\n\t\t\t\tunits = 'nauticalMile';\n\t\t\t} else {\n\t\t\t\tunits = 'yards';\n\t\t\t}\n\n\t\t\tswitch (units) {\n\t\t\t\tcase 'metric':\n\t\t\t\t\t// show metres when distance is < 1km, then show km\n\t\t\t\t\tif (distance > 1000) {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['km']) + ' km';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['m']) + ' m';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'feet':\n\t\t\t\t\tdistance *= 1.09361 * 3;\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['ft']) + ' ft';\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'nauticalMile':\n\t\t\t\t\tdistance *= 0.53996;\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['nm']) + ' nm';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'yards':\n\t\t\t\tdefault:\n\t\t\t\t\tdistance *= 1.09361;\n\n\t\t\t\t\tif (distance > 1760) {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1760, precision['mi']) + ' miles';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['yd']) + ' yd';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn distanceStr;\n\t\t},\n\n\t\t// @method isVersion07x(): boolean\n\t\t// Returns true if the Leaflet version is 0.7.x, false otherwise.\n\t\tisVersion07x: function () {\n\t\t\tvar version = L.version.split('.');\n\t\t\t//If Version is == 0.7.*\n\t\t\treturn parseInt(version[0], 10) === 0 && parseInt(version[1], 10) === 7;\n\t\t},\n\t});\n\n})();\n\n\n\n/**\n * @class L.LineUtil\n * @aka Util\n * @aka L.Utils\n */\nL.Util.extend(L.LineUtil, {\n\n\t// @method segmentsIntersect(): boolean\n\t// Checks to see if two line segments intersect. Does not handle degenerate cases.\n\t// http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf\n\tsegmentsIntersect: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3) {\n\t\treturn this._checkCounterclockwise(p, p2, p3) !==\n\t\t\tthis._checkCounterclockwise(p1, p2, p3) &&\n\t\t\tthis._checkCounterclockwise(p, p1, p2) !==\n\t\t\tthis._checkCounterclockwise(p, p1, p3);\n\t},\n\n\t// check to see if points are in counterclockwise order\n\t_checkCounterclockwise: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\n\t\treturn (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);\n\t}\n});\n\n\n\n/**\n * @class L.Polyline\n * @aka Polyline\n */\nL.Polyline.include({\n\n\t// @method intersects(): boolean\n\t// Check to see if this polyline has any linesegments that intersect.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tintersects: function () {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0,\n\t\t\ti, p, p1;\n\n\t\tif (this._tooFewPointsForIntersection()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = len - 1; i >= 3; i--) {\n\t\t\tp = points[i - 1];\n\t\t\tp1 = points[i];\n\n\n\t\t\tif (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// @method newLatLngIntersects(): boolean\n\t// Check for intersection if new latlng was added to this polyline.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tnewLatLngIntersects: function (latlng, skipFirst) {\n\t\t// Cannot check a polyline for intersecting lats/lngs when not added to the map\n\t\tif (!this._map) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\n\t},\n\n\t// @method newPointIntersects(): boolean\n\t// Check for intersection if new point was added to this polyline.\n\t// newPoint must be a layer point.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tnewPointIntersects: function (newPoint, skipFirst) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0,\n\t\t\tlastPoint = points ? points[len - 1] : null,\n\t\t\t// The previous previous line segment. Previous line segment doesn't need testing.\n\t\t\tmaxIndex = len - 2;\n\n\t\tif (this._tooFewPointsForIntersection(1)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\n\t},\n\n\t// Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).\n\t// Cannot have intersection when < 3 line segments (< 4 points)\n\t_tooFewPointsForIntersection: function (extraPoints) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0;\n\t\t// Increment length by extraPoints if present\n\t\tlen += extraPoints || 0;\n\n\t\treturn !points || len <= 3;\n\t},\n\n\t// Checks a line segment intersections with any line segments before its predecessor.\n\t// Don't need to check the predecessor as will never intersect.\n\t_lineSegmentsIntersectsRange: function (p, p1, maxIndex, minIndex) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tp2, p3;\n\n\t\tminIndex = minIndex || 0;\n\n\t\t// Check all previous line segments (beside the immediately previous) for intersections\n\t\tfor (var j = maxIndex; j > minIndex; j--) {\n\t\t\tp2 = points[j - 1];\n\t\t\tp3 = points[j];\n\n\t\t\tif (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_getProjectedPoints: function () {\n\t\tif (!this._defaultShape) {\n\t\t\treturn this._originalPoints;\n\t\t}\n\t\tvar points = [],\n\t\t\t_shape = this._defaultShape();\n\n\t\tfor (var i = 0; i < _shape.length; i++) {\n\t\t\tpoints.push(this._map.latLngToLayerPoint(_shape[i]));\n\t\t}\n\t\treturn points;\n\t}\n});\n\n\n\n/**\n * @class L.Polygon\n * @aka Polygon\n */\nL.Polygon.include({\n\n\t// @method intersects(): boolean\n\t// Checks a polygon for any intersecting line segments. Ignores holes.\n\tintersects: function () {\n\t\tvar polylineIntersects,\n\t\t\tpoints = this._getProjectedPoints(),\n\t\t\tlen, firstPoint, lastPoint, maxIndex;\n\n\t\tif (this._tooFewPointsForIntersection()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tpolylineIntersects = L.Polyline.prototype.intersects.call(this);\n\n\t\t// If already found an intersection don't need to check for any more.\n\t\tif (polylineIntersects) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlen = points.length;\n\t\tfirstPoint = points[0];\n\t\tlastPoint = points[len - 1];\n\t\tmaxIndex = len - 2;\n\n\t\t// Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);\n\t}\n});\n\n\n\n/**\n * @class L.Control.Draw\n * @aka L.Draw\n */\nL.Control.Draw = L.Control.extend({\n\n\t// Options\n\toptions: {\n\t\tposition: 'topleft',\n\t\tdraw: {},\n\t\tedit: false\n\t},\n\n\t// @method initialize(): void\n\t// Initializes draw control, toolbars from the options\n\tinitialize: function (options) {\n\t\tif (L.version < '0.7') {\n\t\t\tthrow new Error('Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/');\n\t\t}\n\n\t\tL.Control.prototype.initialize.call(this, options);\n\n\t\tvar toolbar;\n\n\t\tthis._toolbars = {};\n\n\t\t// Initialize toolbars\n\t\tif (L.DrawToolbar && this.options.draw) {\n\t\t\ttoolbar = new L.DrawToolbar(this.options.draw);\n\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE] = toolbar;\n\n\t\t\t// Listen for when toolbar is enabled\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE].on('enable', this._toolbarEnabled, this);\n\t\t}\n\n\t\tif (L.EditToolbar && this.options.edit) {\n\t\t\ttoolbar = new L.EditToolbar(this.options.edit);\n\n\t\t\tthis._toolbars[L.EditToolbar.TYPE] = toolbar;\n\n\t\t\t// Listen for when toolbar is enabled\n\t\t\tthis._toolbars[L.EditToolbar.TYPE].on('enable', this._toolbarEnabled, this);\n\t\t}\n\t\tL.toolbar = this; //set global var for editing the toolbar\n\t},\n\n\t// @method onAdd(): container\n\t// Adds the toolbar container to the map\n\tonAdd: function (map) {\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw'),\n\t\t\taddedTopClass = false,\n\t\t\ttopClassName = 'leaflet-draw-toolbar-top',\n\t\t\ttoolbarContainer;\n\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\n\t\t\t\ttoolbarContainer = this._toolbars[toolbarId].addToolbar(map);\n\n\t\t\t\tif (toolbarContainer) {\n\t\t\t\t\t// Add class to the first toolbar to remove the margin\n\t\t\t\t\tif (!addedTopClass) {\n\t\t\t\t\t\tif (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {\n\t\t\t\t\t\t\tL.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddedTopClass = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer.appendChild(toolbarContainer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn container;\n\t},\n\n\t// @method onRemove(): void\n\t// Removes the toolbars from the map toolbar container\n\tonRemove: function () {\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\n\t\t\t\tthis._toolbars[toolbarId].removeToolbar();\n\t\t\t}\n\t\t}\n\t},\n\n\t// @method setDrawingOptions(options): void\n\t// Sets options to all toolbar instances\n\tsetDrawingOptions: function (options) {\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars[toolbarId] instanceof L.DrawToolbar) {\n\t\t\t\tthis._toolbars[toolbarId].setOptions(options);\n\t\t\t}\n\t\t}\n\t},\n\n\t_toolbarEnabled: function (e) {\n\t\tvar enabledToolbar = e.target;\n\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars[toolbarId] !== enabledToolbar) {\n\t\t\t\tthis._toolbars[toolbarId].disable();\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.mergeOptions({\n\tdrawControlTooltips: true,\n\tdrawControl: false\n});\n\nL.Map.addInitHook(function () {\n\tif (this.options.drawControl) {\n\t\tthis.drawControl = new L.Control.Draw();\n\t\tthis.addControl(this.drawControl);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Toolbar\n * @aka Toolbar\n *\n * The toolbar class of the API — it is used to create the ui\n * This will be depreciated\n *\n * @example\n *\n * ```js\n *    var toolbar = L.Toolbar();\n *    toolbar.addToolbar(map);\n * ```\n *\n * ### Disabling a toolbar\n *\n * If you do not want a particular toolbar in your app you can turn it off by setting the toolbar to false.\n *\n * ```js\n *      var drawControl = new L.Control.Draw({\n *          draw: false,\n *          edit: {\n *              featureGroup: editableLayers\n *          }\n *      });\n * ```\n *\n * ### Disabling a toolbar item\n *\n * If you want to turn off a particular toolbar item, set it to false. The following disables drawing polygons and\n * markers. It also turns off the ability to edit layers.\n *\n * ```js\n *      var drawControl = new L.Control.Draw({\n *          draw: {\n *              polygon: false,\n *              marker: false\n *          },\n *          edit: {\n *              featureGroup: editableLayers,\n *              edit: false\n *          }\n *      });\n * ```\n */\nL.Toolbar = L.Class.extend({\n\t// @section Methods for modifying the toolbar\n\n\t// @method initialize(options): void\n\t// Toolbar constructor\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\n\t\tthis._modes = {};\n\t\tthis._actionButtons = [];\n\t\tthis._activeMode = null;\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.Toolbar.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.Toolbar.include(L.Mixin.Events);\n\t\t}\n\t},\n\n\t// @method enabled(): boolean\n\t// Gets a true/false of whether the toolbar is enabled\n\tenabled: function () {\n\t\treturn this._activeMode !== null;\n\t},\n\n\t// @method disable(): void\n\t// Disables the toolbar\n\tdisable: function () {\n\t\tif (!this.enabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._activeMode.handler.disable();\n\t},\n\n\t// @method addToolbar(map): L.DomUtil\n\t// Adds the toolbar to the map and returns the toolbar dom element\n\taddToolbar: function (map) {\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw-section'),\n\t\t\tbuttonIndex = 0,\n\t\t\tbuttonClassPrefix = this._toolbarClass || '',\n\t\t\tmodeHandlers = this.getModeHandlers(map),\n\t\t\ti;\n\n\t\tthis._toolbarContainer = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');\n\t\tthis._map = map;\n\n\t\tfor (i = 0; i < modeHandlers.length; i++) {\n\t\t\tif (modeHandlers[i].enabled) {\n\t\t\t\tthis._initModeHandler(\n\t\t\t\t\tmodeHandlers[i].handler,\n\t\t\t\t\tthis._toolbarContainer,\n\t\t\t\t\tbuttonIndex++,\n\t\t\t\t\tbuttonClassPrefix,\n\t\t\t\t\tmodeHandlers[i].title\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// if no buttons were added, do not add the toolbar\n\t\tif (!buttonIndex) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Save button index of the last button, -1 as we would have ++ after the last button\n\t\tthis._lastButtonIndex = --buttonIndex;\n\n\t\t// Create empty actions part of the toolbar\n\t\tthis._actionsContainer = L.DomUtil.create('ul', 'leaflet-draw-actions');\n\n\t\t// Add draw and cancel containers to the control container\n\t\tcontainer.appendChild(this._toolbarContainer);\n\t\tcontainer.appendChild(this._actionsContainer);\n\n\t\treturn container;\n\t},\n\n\t// @method removeToolbar(): void\n\t// Removes the toolbar and drops the handler event listeners\n\tremoveToolbar: function () {\n\t\t// Dispose each handler\n\t\tfor (var handlerId in this._modes) {\n\t\t\tif (this._modes.hasOwnProperty(handlerId)) {\n\t\t\t\t// Unbind handler button\n\t\t\t\tthis._disposeButton(\n\t\t\t\t\tthis._modes[handlerId].button,\n\t\t\t\t\tthis._modes[handlerId].handler.enable,\n\t\t\t\t\tthis._modes[handlerId].handler\n\t\t\t\t);\n\n\t\t\t\t// Make sure is disabled\n\t\t\t\tthis._modes[handlerId].handler.disable();\n\n\t\t\t\t// Unbind handler\n\t\t\t\tthis._modes[handlerId].handler\n\t\t\t\t\t.off('enabled', this._handlerActivated, this)\n\t\t\t\t\t.off('disabled', this._handlerDeactivated, this);\n\t\t\t}\n\t\t}\n\t\tthis._modes = {};\n\n\t\t// Dispose the actions toolbar\n\t\tfor (var i = 0, l = this._actionButtons.length; i < l; i++) {\n\t\t\tthis._disposeButton(\n\t\t\t\tthis._actionButtons[i].button,\n\t\t\t\tthis._actionButtons[i].callback,\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\t\tthis._actionButtons = [];\n\t\tthis._actionsContainer = null;\n\t},\n\n\t_initModeHandler: function (handler, container, buttonIndex, classNamePredix, buttonTitle) {\n\t\tvar type = handler.type;\n\n\t\tthis._modes[type] = {};\n\n\t\tthis._modes[type].handler = handler;\n\n\t\tthis._modes[type].button = this._createButton({\n\t\t\ttype: type,\n\t\t\ttitle: buttonTitle,\n\t\t\tclassName: classNamePredix + '-' + type,\n\t\t\tcontainer: container,\n\t\t\tcallback: this._modes[type].handler.enable,\n\t\t\tcontext: this._modes[type].handler\n\t\t});\n\n\t\tthis._modes[type].buttonIndex = buttonIndex;\n\n\t\tthis._modes[type].handler\n\t\t\t.on('enabled', this._handlerActivated, this)\n\t\t\t.on('disabled', this._handlerDeactivated, this);\n\t},\n\n\t/* Detect iOS based on browser User Agent, based on:\n\t * http://stackoverflow.com/a/9039885 */\n\t_detectIOS: function () {\n\t\tvar iOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);\n\t\treturn iOS;\n\t},\n\n\t_createButton: function (options) {\n\n\t\tvar link = L.DomUtil.create('a', options.className || '', options.container);\n\t\t// Screen reader tag\n\t\tvar sr = L.DomUtil.create('span', 'sr-only', options.container);\n\n\t\tlink.href = '#';\n\t\tlink.appendChild(sr);\n\n\t\tif (options.title) {\n\t\t\tlink.title = options.title;\n\t\t\tsr.innerHTML = options.title;\n\t\t}\n\n\t\tif (options.text) {\n\t\t\tlink.innerHTML = options.text;\n\t\t\tsr.innerHTML = options.text;\n\t\t}\n\n\t\t/* iOS does not use click events */\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\n\n\t\tL.DomEvent\n\t\t\t.on(link, 'click', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'mousedown', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'dblclick', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'touchstart', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'click', L.DomEvent.preventDefault)\n\t\t\t.on(link, buttonEvent, options.callback, options.context);\n\n\t\treturn link;\n\t},\n\n\t_disposeButton: function (button, callback) {\n\t\t/* iOS does not use click events */\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\n\n\t\tL.DomEvent\n\t\t\t.off(button, 'click', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'mousedown', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'dblclick', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'touchstart', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'click', L.DomEvent.preventDefault)\n\t\t\t.off(button, buttonEvent, callback);\n\t},\n\n\t_handlerActivated: function (e) {\n\t\t// Disable active mode (if present)\n\t\tthis.disable();\n\n\t\t// Cache new active feature\n\t\tthis._activeMode = this._modes[e.handler];\n\n\t\tL.DomUtil.addClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n\n\t\tthis._showActionsToolbar();\n\n\t\tthis.fire('enable');\n\t},\n\n\t_handlerDeactivated: function () {\n\t\tthis._hideActionsToolbar();\n\n\t\tL.DomUtil.removeClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n\n\t\tthis._activeMode = null;\n\n\t\tthis.fire('disable');\n\t},\n\n\t_createActions: function (handler) {\n\t\tvar container = this._actionsContainer,\n\t\t\tbuttons = this.getActions(handler),\n\t\t\tl = buttons.length,\n\t\t\tli, di, dl, button;\n\n\t\t// Dispose the actions toolbar (todo: dispose only not used buttons)\n\t\tfor (di = 0, dl = this._actionButtons.length; di < dl; di++) {\n\t\t\tthis._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);\n\t\t}\n\t\tthis._actionButtons = [];\n\n\t\t// Remove all old buttons\n\t\twhile (container.firstChild) {\n\t\t\tcontainer.removeChild(container.firstChild);\n\t\t}\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif ('enabled' in buttons[i] && !buttons[i].enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tli = L.DomUtil.create('li', '', container);\n\n\t\t\tbutton = this._createButton({\n\t\t\t\ttitle: buttons[i].title,\n\t\t\t\ttext: buttons[i].text,\n\t\t\t\tcontainer: li,\n\t\t\t\tcallback: buttons[i].callback,\n\t\t\t\tcontext: buttons[i].context\n\t\t\t});\n\n\t\t\tthis._actionButtons.push({\n\t\t\t\tbutton: button,\n\t\t\t\tcallback: buttons[i].callback\n\t\t\t});\n\t\t}\n\t},\n\n\t_showActionsToolbar: function () {\n\t\tvar buttonIndex = this._activeMode.buttonIndex,\n\t\t\tlastButtonIndex = this._lastButtonIndex,\n\t\t\ttoolbarPosition = this._activeMode.button.offsetTop - 1;\n\n\t\t// Recreate action buttons on every click\n\t\tthis._createActions(this._activeMode.handler);\n\n\t\t// Correctly position the cancel button\n\t\tthis._actionsContainer.style.top = toolbarPosition + 'px';\n\n\t\tif (buttonIndex === 0) {\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-top');\n\t\t}\n\n\t\tif (buttonIndex === lastButtonIndex) {\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n\t\t}\n\n\t\tthis._actionsContainer.style.display = 'block';\n\t\tthis._map.fire(L.Draw.Event.TOOLBAROPENED);\n\t},\n\n\t_hideActionsToolbar: function () {\n\t\tthis._actionsContainer.style.display = 'none';\n\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-top');\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n\t\tthis._map.fire(L.Draw.Event.TOOLBARCLOSED);\n\t}\n});\n\n\n\nL.Draw = L.Draw || {};\n/**\n * @class L.Draw.Tooltip\n * @aka Tooltip\n *\n * The tooltip class — it is used to display the tooltip while drawing\n * This will be depreciated\n *\n * @example\n *\n * ```js\n *    var tooltip = L.Draw.Tooltip();\n * ```\n *\n */\nL.Draw.Tooltip = L.Class.extend({\n\n\t// @section Methods for modifying draw state\n\n\t// @method initialize(map): void\n\t// Tooltip constructor\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._popupPane = map._panes.popupPane;\n\t\tthis._visible = false;\n\n\t\tthis._container = map.options.drawControlTooltips ?\n\t\t\tL.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;\n\t\tthis._singleLineLabel = false;\n\n\t\tthis._map.on('mouseout', this._onMouseOut, this);\n\t},\n\n\t// @method dispose(): void\n\t// Remove Tooltip DOM and unbind events\n\tdispose: function () {\n\t\tthis._map.off('mouseout', this._onMouseOut, this);\n\n\t\tif (this._container) {\n\t\t\tthis._popupPane.removeChild(this._container);\n\t\t\tthis._container = null;\n\t\t}\n\t},\n\n\t// @method updateContent(labelText): this\n\t// Changes the tooltip text to string in function call\n\tupdateContent: function (labelText) {\n\t\tif (!this._container) {\n\t\t\treturn this;\n\t\t}\n\t\tlabelText.subtext = labelText.subtext || '';\n\n\t\t// update the vertical position (only if changed)\n\t\tif (labelText.subtext.length === 0 && !this._singleLineLabel) {\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');\n\t\t\tthis._singleLineLabel = true;\n\t\t}\n\t\telse if (labelText.subtext.length > 0 && this._singleLineLabel) {\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');\n\t\t\tthis._singleLineLabel = false;\n\t\t}\n\n\t\tthis._container.innerHTML =\n\t\t\t(labelText.subtext.length > 0 ?\n\t\t\t\t'<span class=\"leaflet-draw-tooltip-subtext\">' + labelText.subtext + '</span>' + '<br />' : '') +\n\t\t\t'<span>' + labelText.text + '</span>';\n\n\t\tif (!labelText.text && !labelText.subtext) {\n\t\t\tthis._visible = false;\n\t\t\tthis._container.style.visibility = 'hidden';\n\t\t} else {\n\t\t\tthis._visible = true;\n\t\t\tthis._container.style.visibility = 'inherit';\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t// @method updatePosition(latlng): this\n\t// Changes the location of the tooltip\n\tupdatePosition: function (latlng) {\n\t\tvar pos = this._map.latLngToLayerPoint(latlng),\n\t\t\ttooltipContainer = this._container;\n\n\t\tif (this._container) {\n\t\t\tif (this._visible) {\n\t\t\t\ttooltipContainer.style.visibility = 'inherit';\n\t\t\t}\n\t\t\tL.DomUtil.setPosition(tooltipContainer, pos);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t// @method showAsError(): this\n\t// Applies error class to tooltip\n\tshowAsError: function () {\n\t\tif (this._container) {\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');\n\t\t}\n\t\treturn this;\n\t},\n\n\t// @method removeError(): this\n\t// Removes the error class from the tooltip\n\tremoveError: function () {\n\t\tif (this._container) {\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');\n\t\t}\n\t\treturn this;\n\t},\n\n\t_onMouseOut: function () {\n\t\tif (this._container) {\n\t\t\tthis._container.style.visibility = 'hidden';\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.DrawToolbar\n * @aka Toolbar\n */\nL.DrawToolbar = L.Toolbar.extend({\n\n\tstatics: {\n\t\tTYPE: 'draw'\n\t},\n\n\toptions: {\n\t\tpolyline: {},\n\t\tpolygon: {},\n\t\trectangle: {},\n\t\tcircle: {},\n\t\tmarker: {},\n\t\tcirclemarker: {}\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (options) {\n\t\t// Ensure that the options are merged correctly since L.extend is only shallow\n\t\tfor (var type in this.options) {\n\t\t\tif (this.options.hasOwnProperty(type)) {\n\t\t\t\tif (options[type]) {\n\t\t\t\t\toptions[type] = L.extend({}, this.options[type], options[type]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._toolbarClass = 'leaflet-draw-draw';\n\t\tL.Toolbar.prototype.initialize.call(this, options);\n\t},\n\n\t// @method getModeHandlers(): object\n\t// Get mode handlers information\n\tgetModeHandlers: function (map) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: this.options.polyline,\n\t\t\t\thandler: new L.Draw.Polyline(map, this.options.polyline),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polyline\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.polygon,\n\t\t\t\thandler: new L.Draw.Polygon(map, this.options.polygon),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polygon\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.rectangle,\n\t\t\t\thandler: new L.Draw.Rectangle(map, this.options.rectangle),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.rectangle\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.circle,\n\t\t\t\thandler: new L.Draw.Circle(map, this.options.circle),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.circle\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.marker,\n\t\t\t\thandler: new L.Draw.Marker(map, this.options.marker),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.marker\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.circlemarker,\n\t\t\t\thandler: new L.Draw.CircleMarker(map, this.options.circlemarker),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.circlemarker\n\t\t\t}\n\t\t];\n\t},\n\n\t// @method getActions(): object\n\t// Get action information\n\tgetActions: function (handler) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: handler.completeShape,\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.finish.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.finish.text,\n\t\t\t\tcallback: handler.completeShape,\n\t\t\t\tcontext: handler\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: handler.deleteLastVertex,\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.undo.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.undo.text,\n\t\t\t\tcallback: handler.deleteLastVertex,\n\t\t\t\tcontext: handler\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.actions.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.actions.text,\n\t\t\t\tcallback: this.disable,\n\t\t\t\tcontext: this\n\t\t\t}\n\t\t];\n\t},\n\n\t// @method setOptions(): void\n\t// Sets the options to the toolbar\n\tsetOptions: function (options) {\n\t\tL.setOptions(this, options);\n\n\t\tfor (var type in this._modes) {\n\t\t\tif (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {\n\t\t\t\tthis._modes[type].handler.setOptions(options[type]);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n\n/*L.Map.mergeOptions({\n editControl: true\n });*/\n/**\n * @class L.EditToolbar\n * @aka EditToolbar\n */\nL.EditToolbar = L.Toolbar.extend({\n\tstatics: {\n\t\tTYPE: 'edit'\n\t},\n\n\toptions: {\n\t\tedit: {\n\t\t\tselectedPathOptions: {\n\t\t\t\tdashArray: '10, 10',\n\n\t\t\t\tfill: true,\n\t\t\t\tfillColor: '#fe57a1',\n\t\t\t\tfillOpacity: 0.1,\n\n\t\t\t\t// Whether to user the existing layers color\n\t\t\t\tmaintainColor: false\n\t\t\t}\n\t\t},\n\t\tremove: {},\n\t\tpoly: null,\n\t\tfeatureGroup: null /* REQUIRED! TODO: perhaps if not set then all layers on the map are selectable? */\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (options) {\n\t\t// Need to set this manually since null is an acceptable value here\n\t\tif (options.edit) {\n\t\t\tif (typeof options.edit.selectedPathOptions === 'undefined') {\n\t\t\t\toptions.edit.selectedPathOptions = this.options.edit.selectedPathOptions;\n\t\t\t}\n\t\t\toptions.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, options.edit.selectedPathOptions);\n\t\t}\n\n\t\tif (options.remove) {\n\t\t\toptions.remove = L.extend({}, this.options.remove, options.remove);\n\t\t}\n\n\t\tif (options.poly) {\n\t\t\toptions.poly = L.extend({}, this.options.poly, options.poly);\n\t\t}\n\n\t\tthis._toolbarClass = 'leaflet-draw-edit';\n\t\tL.Toolbar.prototype.initialize.call(this, options);\n\n\t\tthis._selectedFeatureCount = 0;\n\t},\n\n\t// @method getModeHandlers(): object\n\t// Get mode handlers information\n\tgetModeHandlers: function (map) {\n\t\tvar featureGroup = this.options.featureGroup;\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: this.options.edit,\n\t\t\t\thandler: new L.EditToolbar.Edit(map, {\n\t\t\t\t\tfeatureGroup: featureGroup,\n\t\t\t\t\tselectedPathOptions: this.options.edit.selectedPathOptions,\n\t\t\t\t\tpoly: this.options.poly\n\t\t\t\t}),\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.edit\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.remove,\n\t\t\t\thandler: new L.EditToolbar.Delete(map, {\n\t\t\t\t\tfeatureGroup: featureGroup\n\t\t\t\t}),\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.remove\n\t\t\t}\n\t\t];\n\t},\n\n\t// @method getActions(): object\n\t// Get actions information\n\tgetActions: function (handler) {\n\t\tvar actions = [\n\t\t\t{\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.save.title,\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.save.text,\n\t\t\t\tcallback: this._save,\n\t\t\t\tcontext: this\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.cancel.title,\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.cancel.text,\n\t\t\t\tcallback: this.disable,\n\t\t\t\tcontext: this\n\t\t\t}\n\t\t];\n\n\t\tif (handler.removeAllLayers) {\n\t\t\tactions.push({\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.clearAll.title,\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.clearAll.text,\n\t\t\t\tcallback: this._clearAllLayers,\n\t\t\t\tcontext: this\n\t\t\t});\n\t\t}\n\n\t\treturn actions;\n\t},\n\n\t// @method addToolbar(map): L.DomUtil\n\t// Adds the toolbar to the map\n\taddToolbar: function (map) {\n\t\tvar container = L.Toolbar.prototype.addToolbar.call(this, map);\n\n\t\tthis._checkDisabled();\n\n\t\tthis.options.featureGroup.on('layeradd layerremove', this._checkDisabled, this);\n\n\t\treturn container;\n\t},\n\n\t// @method removeToolbar(): void\n\t// Removes the toolbar from the map\n\tremoveToolbar: function () {\n\t\tthis.options.featureGroup.off('layeradd layerremove', this._checkDisabled, this);\n\n\t\tL.Toolbar.prototype.removeToolbar.call(this);\n\t},\n\n\t// @method disable(): void\n\t// Disables the toolbar\n\tdisable: function () {\n\t\tif (!this.enabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._activeMode.handler.revertLayers();\n\n\t\tL.Toolbar.prototype.disable.call(this);\n\t},\n\n\t_save: function () {\n\t\tthis._activeMode.handler.save();\n\t\tif (this._activeMode) {\n\t\t\tthis._activeMode.handler.disable();\n\t\t}\n\t},\n\n\t_clearAllLayers: function () {\n\t\tthis._activeMode.handler.removeAllLayers();\n\t\tif (this._activeMode) {\n\t\t\tthis._activeMode.handler.disable();\n\t\t}\n\t},\n\n\t_checkDisabled: function () {\n\t\tvar featureGroup = this.options.featureGroup,\n\t\t\thasLayers = featureGroup.getLayers().length !== 0,\n\t\t\tbutton;\n\n\t\tif (this.options.edit) {\n\t\t\tbutton = this._modes[L.EditToolbar.Edit.TYPE].button;\n\n\t\t\tif (hasLayers) {\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\n\t\t\t} else {\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\n\t\t\t}\n\n\t\t\tbutton.setAttribute(\n\t\t\t\t'title',\n\t\t\t\thasLayers ?\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.edit\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.editDisabled\n\t\t\t);\n\t\t}\n\n\t\tif (this.options.remove) {\n\t\t\tbutton = this._modes[L.EditToolbar.Delete.TYPE].button;\n\n\t\t\tif (hasLayers) {\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\n\t\t\t} else {\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\n\t\t\t}\n\n\t\t\tbutton.setAttribute(\n\t\t\t\t'title',\n\t\t\t\thasLayers ?\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.remove\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.removeDisabled\n\t\t\t);\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.EditToolbar.Edit\n * @aka EditToolbar.Edit\n */\nL.EditToolbar.Edit = L.Handler.extend({\n\tstatics: {\n\t\tTYPE: 'edit'\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (map, options) {\n\t\tL.Handler.prototype.initialize.call(this, map);\n\n\t\tL.setOptions(this, options);\n\n\t\t// Store the selectable layer group for ease of access\n\t\tthis._featureGroup = options.featureGroup;\n\n\t\tif (!(this._featureGroup instanceof L.FeatureGroup)) {\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\n\t\t}\n\n\t\tthis._uneditedLayerProps = {};\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.EditToolbar.Edit.TYPE;\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.EditToolbar.Edit.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.EditToolbar.Edit.include(L.Mixin.Events);\n\t\t}\n\t},\n\n\t// @method enable(): void\n\t// Enable the edit toolbar\n\tenable: function () {\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('enabled', {handler: this.type});\n\t\t//this disable other handlers\n\n\t\tthis._map.fire(L.Draw.Event.EDITSTART, {handler: this.type});\n\t\t//allow drawLayer to be updated before beginning edition.\n\n\t\tL.Handler.prototype.enable.call(this);\n\t\tthis._featureGroup\n\t\t\t.on('layeradd', this._enableLayerEdit, this)\n\t\t\t.on('layerremove', this._disableLayerEdit, this);\n\t},\n\n\t// @method disable(): void\n\t// Disable the edit toolbar\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\t\tthis._featureGroup\n\t\t\t.off('layeradd', this._enableLayerEdit, this)\n\t\t\t.off('layerremove', this._disableLayerEdit, this);\n\t\tL.Handler.prototype.disable.call(this);\n\t\tthis._map.fire(L.Draw.Event.EDITSTOP, {handler: this.type});\n\t\tthis.fire('disabled', {handler: this.type});\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks for this handler\n\taddHooks: function () {\n\t\tvar map = this._map;\n\n\t\tif (map) {\n\t\t\tmap.getContainer().focus();\n\n\t\t\tthis._featureGroup.eachLayer(this._enableLayerEdit, this);\n\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\n\t\t\tthis._tooltip.updateContent({\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n\t\t\t});\n\n\t\t\t// Quickly access the tooltip to update for intersection checking\n\t\t\tmap._editTooltip = this._tooltip;\n\n\t\t\tthis._updateTooltip();\n\n\t\t\tthis._map\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('touchmove', this._onMouseMove, this)\n\t\t\t\t.on('MSPointerMove', this._onMouseMove, this)\n\t\t\t\t.on(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks for this handler\n\tremoveHooks: function () {\n\t\tif (this._map) {\n\t\t\t// Clean up selected layers.\n\t\t\tthis._featureGroup.eachLayer(this._disableLayerEdit, this);\n\n\t\t\t// Clear the backups of the original layers\n\t\t\tthis._uneditedLayerProps = {};\n\n\t\t\tthis._tooltip.dispose();\n\t\t\tthis._tooltip = null;\n\n\t\t\tthis._map\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t\t.off('touchmove', this._onMouseMove, this)\n\t\t\t\t.off('MSPointerMove', this._onMouseMove, this)\n\t\t\t\t.off(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\n\t\t}\n\t},\n\n\t// @method revertLayers(): void\n\t// Revert each layer's geometry changes\n\trevertLayers: function () {\n\t\tthis._featureGroup.eachLayer(function (layer) {\n\t\t\tthis._revertLayer(layer);\n\t\t}, this);\n\t},\n\n\t// @method save(): void\n\t// Save the layer geometries\n\tsave: function () {\n\t\tvar editedLayers = new L.LayerGroup();\n\t\tthis._featureGroup.eachLayer(function (layer) {\n\t\t\tif (layer.edited) {\n\t\t\t\teditedLayers.addLayer(layer);\n\t\t\t\tlayer.edited = false;\n\t\t\t}\n\t\t});\n\t\tthis._map.fire(L.Draw.Event.EDITED, {layers: editedLayers});\n\t},\n\n\t_backupLayer: function (layer) {\n\t\tvar id = L.Util.stamp(layer);\n\n\t\tif (!this._uneditedLayerProps[id]) {\n\t\t\t// Polyline, Polygon or Rectangle\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\n\t\t\t\tthis._uneditedLayerProps[id] = {\n\t\t\t\t\tlatlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs())\n\t\t\t\t};\n\t\t\t} else if (layer instanceof L.Circle) {\n\t\t\t\tthis._uneditedLayerProps[id] = {\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng()),\n\t\t\t\t\tradius: layer.getRadius()\n\t\t\t\t};\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker\n\t\t\t\tthis._uneditedLayerProps[id] = {\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng())\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\treturn ({\n\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n\t\t});\n\t},\n\n\t_updateTooltip: function () {\n\t\tthis._tooltip.updateContent(this._getTooltipText());\n\t},\n\n\t_revertLayer: function (layer) {\n\t\tvar id = L.Util.stamp(layer);\n\t\tlayer.edited = false;\n\t\tif (this._uneditedLayerProps.hasOwnProperty(id)) {\n\t\t\t// Polyline, Polygon or Rectangle\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\n\t\t\t\tlayer.setLatLngs(this._uneditedLayerProps[id].latlngs);\n\t\t\t} else if (layer instanceof L.Circle) {\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\n\t\t\t\tlayer.setRadius(this._uneditedLayerProps[id].radius);\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker or CircleMarker\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\n\t\t\t}\n\n\t\t\tlayer.fire('revert-edited', {layer: layer});\n\t\t}\n\t},\n\n\t_enableLayerEdit: function (e) {\n\t\tvar layer = e.layer || e.target || e,\n\t\t\tpathOptions, poly;\n\n\t\t// Back up this layer (if haven't before)\n\t\tthis._backupLayer(layer);\n\n\t\tif (this.options.poly) {\n\t\t\tpoly = L.Util.extend({}, this.options.poly);\n\t\t\tlayer.options.poly = poly;\n\t\t}\n\n\t\t// Set different style for editing mode\n\t\tif (this.options.selectedPathOptions) {\n\t\t\tpathOptions = L.Util.extend({}, this.options.selectedPathOptions);\n\n\t\t\t// Use the existing color of the layer\n\t\t\tif (pathOptions.maintainColor) {\n\t\t\t\tpathOptions.color = layer.options.color;\n\t\t\t\tpathOptions.fillColor = layer.options.fillColor;\n\t\t\t}\n\n\t\t\tlayer.options.original = L.extend({}, layer.options);\n\t\t\tlayer.options.editing = pathOptions;\n\n\t\t}\n\n\t\tif (layer instanceof L.Marker) {\n\t\t\tif (layer.editing) {\n\t\t\t\tlayer.editing.enable();\n\t\t\t}\n\t\t\tlayer.dragging.enable();\n\t\t\tlayer\n\t\t\t\t.on('dragend', this._onMarkerDragEnd)\n\t\t\t\t// #TODO: remove when leaflet finally fixes their draggable so it's touch friendly again.\n\t\t\t\t.on('touchmove', this._onTouchMove, this)\n\t\t\t\t.on('MSPointerMove', this._onTouchMove, this)\n\t\t\t\t.on('touchend', this._onMarkerDragEnd, this)\n\t\t\t\t.on('MSPointerUp', this._onMarkerDragEnd, this);\n\t\t} else {\n\t\t\tlayer.editing.enable();\n\t\t}\n\t},\n\n\t_disableLayerEdit: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tlayer.edited = false;\n\t\tif (layer.editing) {\n\t\t\tlayer.editing.disable();\n\t\t}\n\n\t\tdelete layer.options.editing;\n\t\tdelete layer.options.original;\n\t\t// Reset layer styles to that of before select\n\t\tif (this._selectedPathOptions) {\n\t\t\tif (layer instanceof L.Marker) {\n\t\t\t\tthis._toggleMarkerHighlight(layer);\n\t\t\t} else {\n\t\t\t\t// reset the layer style to what is was before being selected\n\t\t\t\tlayer.setStyle(layer.options.previousOptions);\n\t\t\t\t// remove the cached options for the layer object\n\t\t\t\tdelete layer.options.previousOptions;\n\t\t\t}\n\t\t}\n\n\t\tif (layer instanceof L.Marker) {\n\t\t\tlayer.dragging.disable();\n\t\t\tlayer\n\t\t\t\t.off('dragend', this._onMarkerDragEnd, this)\n\t\t\t\t.off('touchmove', this._onTouchMove, this)\n\t\t\t\t.off('MSPointerMove', this._onTouchMove, this)\n\t\t\t\t.off('touchend', this._onMarkerDragEnd, this)\n\t\t\t\t.off('MSPointerUp', this._onMarkerDragEnd, this);\n\t\t} else {\n\t\t\tlayer.editing.disable();\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tthis._tooltip.updatePosition(e.latlng);\n\t},\n\n\t_onMarkerDragEnd: function (e) {\n\t\tvar layer = e.target;\n\t\tlayer.edited = true;\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: layer});\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar touchEvent = e.originalEvent.changedTouches[0],\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\n\t\te.target.setLatLng(latlng);\n\t},\n\n\t_hasAvailableLayers: function () {\n\t\treturn this._featureGroup.getLayers().length !== 0;\n\t}\n});\n\n\n\n/**\n * @class L.EditToolbar.Delete\n * @aka EditToolbar.Delete\n */\nL.EditToolbar.Delete = L.Handler.extend({\n\tstatics: {\n\t\tTYPE: 'remove' // not delete as delete is reserved in js\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (map, options) {\n\t\tL.Handler.prototype.initialize.call(this, map);\n\n\t\tL.Util.setOptions(this, options);\n\n\t\t// Store the selectable layer group for ease of access\n\t\tthis._deletableLayers = this.options.featureGroup;\n\n\t\tif (!(this._deletableLayers instanceof L.FeatureGroup)) {\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\n\t\t}\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.EditToolbar.Delete.TYPE;\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.EditToolbar.Delete.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.EditToolbar.Delete.include(L.Mixin.Events);\n\t\t}\n\n\t},\n\n\t// @method enable(): void\n\t// Enable the delete toolbar\n\tenable: function () {\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('enabled', {handler: this.type});\n\n\t\tthis._map.fire(L.Draw.Event.DELETESTART, {handler: this.type});\n\n\t\tL.Handler.prototype.enable.call(this);\n\n\t\tthis._deletableLayers\n\t\t\t.on('layeradd', this._enableLayerDelete, this)\n\t\t\t.on('layerremove', this._disableLayerDelete, this);\n\t},\n\n\t// @method disable(): void\n\t// Disable the delete toolbar\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._deletableLayers\n\t\t\t.off('layeradd', this._enableLayerDelete, this)\n\t\t\t.off('layerremove', this._disableLayerDelete, this);\n\n\t\tL.Handler.prototype.disable.call(this);\n\n\t\tthis._map.fire(L.Draw.Event.DELETESTOP, {handler: this.type});\n\n\t\tthis.fire('disabled', {handler: this.type});\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tvar map = this._map;\n\n\t\tif (map) {\n\t\t\tmap.getContainer().focus();\n\n\t\t\tthis._deletableLayers.eachLayer(this._enableLayerDelete, this);\n\t\t\tthis._deletedLayers = new L.LayerGroup();\n\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\n\t\t\tthis._tooltip.updateContent({text: L.drawLocal.edit.handlers.remove.tooltip.text});\n\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tif (this._map) {\n\t\t\tthis._deletableLayers.eachLayer(this._disableLayerDelete, this);\n\t\t\tthis._deletedLayers = null;\n\n\t\t\tthis._tooltip.dispose();\n\t\t\tthis._tooltip = null;\n\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\n\t\t}\n\t},\n\n\t// @method revertLayers(): void\n\t// Revert the deleted layers back to their prior state.\n\trevertLayers: function () {\n\t\t// Iterate of the deleted layers and add them back into the featureGroup\n\t\tthis._deletedLayers.eachLayer(function (layer) {\n\t\t\tthis._deletableLayers.addLayer(layer);\n\t\t\tlayer.fire('revert-deleted', {layer: layer});\n\t\t}, this);\n\t},\n\n\t// @method save(): void\n\t// Save deleted layers\n\tsave: function () {\n\t\tthis._map.fire(L.Draw.Event.DELETED, {layers: this._deletedLayers});\n\t},\n\n\t// @method removeAllLayers(): void\n\t// Remove all delateable layers\n\tremoveAllLayers: function () {\n\t\t// Iterate of the delateable layers and add remove them\n\t\tthis._deletableLayers.eachLayer(function (layer) {\n\t\t\tthis._removeLayer({layer: layer});\n\t\t}, this);\n\t\tthis.save();\n\t},\n\n\t_enableLayerDelete: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tlayer.on('click', this._removeLayer, this);\n\t},\n\n\t_disableLayerDelete: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tlayer.off('click', this._removeLayer, this);\n\n\t\t// Remove from the deleted layers so we can't accidentally revert if the user presses cancel\n\t\tthis._deletedLayers.removeLayer(layer);\n\t},\n\n\t_removeLayer: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tthis._deletableLayers.removeLayer(layer);\n\n\t\tthis._deletedLayers.addLayer(layer);\n\n\t\tlayer.fire('deleted');\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tthis._tooltip.updatePosition(e.latlng);\n\t},\n\n\t_hasAvailableLayers: function () {\n\t\treturn this._deletableLayers.getLayers().length !== 0;\n\t}\n});\n\n\n\n}(window, document));\n//# sourceMappingURL=leaflet.draw-src.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvbGVhZmxldC1kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LXNyYy5qcz82MWZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBLDZCQUE2QixFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3hELGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3hELGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFB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RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwyQ0FBMkMsMEJBQTBCO0FBQ3JFOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQzs7QUFFeEQ7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QztBQUM5RCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLDZCQUE2Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsY0FBYztBQUN2RztBQUNBO0FBQ0EsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLDZCQUE2Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixFQUFFOztBQUVGO0FBQ0EsNkRBQTZELHdCQUF3QjtBQUNyRjtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7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QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDREQUE0RDtBQUNoSDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsbUJBQW1CO0FBQzVELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsbUJBQW1CO0FBQzlELEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxtQkFBbUI7QUFDNUQsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCOztBQUVyQiwwQkFBMEI7QUFDMUI7QUFDQSxLQUFLLHlCQUF5QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGNBQWM7QUFDZCxhQUFhO0FBQ2IsZUFBZTtBQUNmLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQSxFQUFFLEVBQUU7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFD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QUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjs7QUFFM0MsNENBQTRDLG1CQUFtQjs7QUFFL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxtQkFBbUI7O0FBRTlELHlCQUF5QixtQkFBbUI7QUFDNUMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msb0RBQW9EOztBQUVwRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QyxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtZHJhdy9kaXN0L2xlYWZsZXQuZHJhdy1zcmMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIExlYWZsZXQuZHJhdyAxLjAuNCwgYSBwbHVnaW4gdGhhdCBhZGRzIGRyYXdpbmcgYW5kIGVkaXRpbmcgdG9vbHMgdG8gTGVhZmxldCBwb3dlcmVkIG1hcHMuXG4gKGMpIDIwMTItMjAxNywgSmFjb2IgVG95ZSwgSm9uIFdlc3QsIFNtYXJ0cmFrLCBMZWFmbGV0XG5cbiBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0LmRyYXdcbiBodHRwOi8vbGVhZmxldGpzLmNvbVxuICovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkgey8qKlxuICogTGVhZmxldC5kcmF3IGFzc3VtZXMgdGhhdCB5b3UgaGF2ZSBhbHJlYWR5IGluY2x1ZGVkIHRoZSBMZWFmbGV0IGxpYnJhcnkuXG4gKi9cbkwuZHJhd1ZlcnNpb24gPSBcIjEuMC40XCI7XG4vKipcbiAqIEBjbGFzcyBMLkRyYXdcbiAqIEBha2EgRHJhd1xuICpcbiAqXG4gKiBUbyBhZGQgdGhlIGRyYXcgdG9vbGJhciBzZXQgdGhlIG9wdGlvbiBkcmF3Q29udHJvbDogdHJ1ZSBpbiB0aGUgbWFwIG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAgICAgIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge2RyYXdDb250cm9sOiB0cnVlfSkuc2V0VmlldyhbNTEuNTA1LCAtMC4wOV0sIDEzKTtcbiAqXG4gKiAgICAgIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnRpbGUub3NtLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gKiAgICAgICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cDovL29zbS5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ1xuICogICAgICB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogIyMjIEFkZGluZyB0aGUgZWRpdCB0b29sYmFyXG4gKiBUbyB1c2UgdGhlIGVkaXQgdG9vbGJhciB5b3UgbXVzdCBpbml0aWFsaXNlIHRoZSBMZWFmbGV0LmRyYXcgY29udHJvbCBhbmQgbWFudWFsbHkgYWRkIGl0IHRvIHRoZSBtYXAuXG4gKlxuICogYGBganNcbiAqICAgICAgdmFyIG1hcCA9IEwubWFwKCdtYXAnKS5zZXRWaWV3KFs1MS41MDUsIC0wLjA5XSwgMTMpO1xuICpcbiAqICAgICAgTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30udGlsZS5vc20ub3JnL3t6fS97eH0ve3l9LnBuZycsIHtcbiAqICAgICAgICAgIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwOi8vb3NtLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnXG4gKiAgICAgIH0pLmFkZFRvKG1hcCk7XG4gKlxuICogICAgICAvLyBGZWF0dXJlR3JvdXAgaXMgdG8gc3RvcmUgZWRpdGFibGUgbGF5ZXJzXG4gKiAgICAgIHZhciBkcmF3bkl0ZW1zID0gbmV3IEwuRmVhdHVyZUdyb3VwKCk7XG4gKiAgICAgIG1hcC5hZGRMYXllcihkcmF3bkl0ZW1zKTtcbiAqXG4gKiAgICAgIHZhciBkcmF3Q29udHJvbCA9IG5ldyBMLkNvbnRyb2wuRHJhdyh7XG4gKiAgICAgICAgICBlZGl0OiB7XG4gKiAgICAgICAgICAgICAgZmVhdHVyZUdyb3VwOiBkcmF3bkl0ZW1zXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH0pO1xuICogICAgICBtYXAuYWRkQ29udHJvbChkcmF3Q29udHJvbCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUga2V5IGhlcmUgaXMgdGhlIGZlYXR1cmVHcm91cCBvcHRpb24uIFRoaXMgdGVsbHMgdGhlIHBsdWdpbiB3aGljaCBGZWF0dXJlR3JvdXAgY29udGFpbnMgdGhlIGxheWVycyB0aGF0XG4gKiBzaG91bGQgYmUgZWRpdGFibGUuIFRoZSBmZWF0dXJlR3JvdXAgY2FuIGNvbnRhaW4gMCBvciBtb3JlIGZlYXR1cmVzIHdpdGggZ2VvbWV0cnkgdHlwZXMgUG9pbnQsIExpbmVTdHJpbmcsIGFuZCBQb2x5Z29uLlxuICogTGVhZmxldC5kcmF3IGRvZXMgbm90IHdvcmsgd2l0aCBtdWx0aWdlb21ldHJ5IGZlYXR1cmVzIHN1Y2ggYXMgTXVsdGlQb2ludCwgTXVsdGlMaW5lU3RyaW5nLCBNdWx0aVBvbHlnb24sXG4gKiBvciBHZW9tZXRyeUNvbGxlY3Rpb24uIElmIHlvdSBuZWVkIHRvIGFkZCBtdWx0aWdlb21ldHJ5IGZlYXR1cmVzIHRvIHRoZSBkcmF3IHBsdWdpbiwgY29udmVydCB0aGVtIHRvIGFcbiAqIEZlYXR1cmVDb2xsZWN0aW9uIG9mIG5vbi1tdWx0aWdlb21ldHJpZXMgKFBvaW50cywgTGluZVN0cmluZ3MsIG9yIFBvbHlnb25zKS5cbiAqL1xuTC5EcmF3ID0ge307XG5cbi8qKlxuICogQGNsYXNzIEwuZHJhd0xvY2FsXG4gKiBAYWthIEwuZHJhd0xvY2FsXG4gKlxuICogVGhlIGNvcmUgdG9vbGJhciBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdG9vbGJhciB1aVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogICAgICB2YXIgbW9kaWZpZWREcmF3ID0gTC5kcmF3TG9jYWwuZXh0ZW5kKHtcbiAqICAgICAgICAgIGRyYXc6IHtcbiAqICAgICAgICAgICAgICB0b29sYmFyOiB7XG4gKiAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAqICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb246ICdEcmF3IGFuIGF3ZXNvbWUgcG9seWdvbidcbiAqICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgIH1cbiAqICAgICAgICAgIH1cbiAqICAgICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgZGVmYXVsdCBzdGF0ZSBmb3IgdGhlIGNvbnRyb2wgaXMgdGhlIGRyYXcgdG9vbGJhciBqdXN0IGJlbG93IHRoZSB6b29tIGNvbnRyb2wuXG4gKiAgVGhpcyB3aWxsIGFsbG93IG1hcCB1c2VycyB0byBkcmF3IHZlY3RvcnMgYW5kIG1hcmtlcnMuXG4gKiAgKipQbGVhc2Ugbm90ZSB0aGUgZWRpdCB0b29sYmFyIGlzIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQuKipcbiAqL1xuTC5kcmF3TG9jYWwgPSB7XG5cdC8vIGZvcm1hdDoge1xuXHQvLyBcdG51bWVyaWM6IHtcblx0Ly8gXHRcdGRlbGltaXRlcnM6IHtcblx0Ly8gXHRcdFx0dGhvdXNhbmRzOiAnLCcsXG5cdC8vIFx0XHRcdGRlY2ltYWw6ICcuJ1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gfSxcblx0ZHJhdzoge1xuXHRcdHRvb2xiYXI6IHtcblx0XHRcdC8vICNUT0RPOiB0aGlzIHNob3VsZCBiZSByZW9yZ2FuaXplZCB3aGVyZSBhY3Rpb25zIGFyZSBuZXN0ZWQgaW4gYWN0aW9uc1xuXHRcdFx0Ly8gZXg6IGFjdGlvbnMudW5kbyAgb3IgYWN0aW9ucy5jYW5jZWxcblx0XHRcdGFjdGlvbnM6IHtcblx0XHRcdFx0dGl0bGU6ICdDYW5jZWwgZHJhd2luZycsXG5cdFx0XHRcdHRleHQ6ICdDYW5jZWwnXG5cdFx0XHR9LFxuXHRcdFx0ZmluaXNoOiB7XG5cdFx0XHRcdHRpdGxlOiAnRmluaXNoIGRyYXdpbmcnLFxuXHRcdFx0XHR0ZXh0OiAnRmluaXNoJ1xuXHRcdFx0fSxcblx0XHRcdHVuZG86IHtcblx0XHRcdFx0dGl0bGU6ICdEZWxldGUgbGFzdCBwb2ludCBkcmF3bicsXG5cdFx0XHRcdHRleHQ6ICdEZWxldGUgbGFzdCBwb2ludCdcblx0XHRcdH0sXG5cdFx0XHRidXR0b25zOiB7XG5cdFx0XHRcdHBvbHlsaW5lOiAnRHJhdyBhIHBvbHlsaW5lJyxcblx0XHRcdFx0cG9seWdvbjogJ0RyYXcgYSBwb2x5Z29uJyxcblx0XHRcdFx0cmVjdGFuZ2xlOiAnRHJhdyBhIHJlY3RhbmdsZScsXG5cdFx0XHRcdGNpcmNsZTogJ0RyYXcgYSBjaXJjbGUnLFxuXHRcdFx0XHRtYXJrZXI6ICdEcmF3IGEgbWFya2VyJyxcblx0XHRcdFx0Y2lyY2xlbWFya2VyOiAnRHJhdyBhIGNpcmNsZW1hcmtlcidcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhbmRsZXJzOiB7XG5cdFx0XHRjaXJjbGU6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgYW5kIGRyYWcgdG8gZHJhdyBjaXJjbGUuJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyYWRpdXM6ICdSYWRpdXMnXG5cdFx0XHR9LFxuXHRcdFx0Y2lyY2xlbWFya2VyOiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHRzdGFydDogJ0NsaWNrIG1hcCB0byBwbGFjZSBjaXJjbGUgbWFya2VyLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1hcmtlcjoge1xuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0c3RhcnQ6ICdDbGljayBtYXAgdG8gcGxhY2UgbWFya2VyLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHBvbHlnb246IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgdG8gc3RhcnQgZHJhd2luZyBzaGFwZS4nLFxuXHRcdFx0XHRcdGNvbnQ6ICdDbGljayB0byBjb250aW51ZSBkcmF3aW5nIHNoYXBlLicsXG5cdFx0XHRcdFx0ZW5kOiAnQ2xpY2sgZmlyc3QgcG9pbnQgdG8gY2xvc2UgdGhpcyBzaGFwZS4nXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwb2x5bGluZToge1xuXHRcdFx0XHRlcnJvcjogJzxzdHJvbmc+RXJyb3I6PC9zdHJvbmc+IHNoYXBlIGVkZ2VzIGNhbm5vdCBjcm9zcyEnLFxuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0c3RhcnQ6ICdDbGljayB0byBzdGFydCBkcmF3aW5nIGxpbmUuJyxcblx0XHRcdFx0XHRjb250OiAnQ2xpY2sgdG8gY29udGludWUgZHJhd2luZyBsaW5lLicsXG5cdFx0XHRcdFx0ZW5kOiAnQ2xpY2sgbGFzdCBwb2ludCB0byBmaW5pc2ggbGluZS4nXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWN0YW5nbGU6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgYW5kIGRyYWcgdG8gZHJhdyByZWN0YW5nbGUuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2ltcGxlc2hhcGU6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdGVuZDogJ1JlbGVhc2UgbW91c2UgdG8gZmluaXNoIGRyYXdpbmcuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRlZGl0OiB7XG5cdFx0dG9vbGJhcjoge1xuXHRcdFx0YWN0aW9uczoge1xuXHRcdFx0XHRzYXZlOiB7XG5cdFx0XHRcdFx0dGl0bGU6ICdTYXZlIGNoYW5nZXMnLFxuXHRcdFx0XHRcdHRleHQ6ICdTYXZlJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjYW5jZWw6IHtcblx0XHRcdFx0XHR0aXRsZTogJ0NhbmNlbCBlZGl0aW5nLCBkaXNjYXJkcyBhbGwgY2hhbmdlcycsXG5cdFx0XHRcdFx0dGV4dDogJ0NhbmNlbCdcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xlYXJBbGw6IHtcblx0XHRcdFx0XHR0aXRsZTogJ0NsZWFyIGFsbCBsYXllcnMnLFxuXHRcdFx0XHRcdHRleHQ6ICdDbGVhciBBbGwnXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRidXR0b25zOiB7XG5cdFx0XHRcdGVkaXQ6ICdFZGl0IGxheWVycycsXG5cdFx0XHRcdGVkaXREaXNhYmxlZDogJ05vIGxheWVycyB0byBlZGl0Jyxcblx0XHRcdFx0cmVtb3ZlOiAnRGVsZXRlIGxheWVycycsXG5cdFx0XHRcdHJlbW92ZURpc2FibGVkOiAnTm8gbGF5ZXJzIHRvIGRlbGV0ZSdcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhbmRsZXJzOiB7XG5cdFx0XHRlZGl0OiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHR0ZXh0OiAnRHJhZyBoYW5kbGVzIG9yIG1hcmtlcnMgdG8gZWRpdCBmZWF0dXJlcy4nLFxuXHRcdFx0XHRcdHN1YnRleHQ6ICdDbGljayBjYW5jZWwgdG8gdW5kbyBjaGFuZ2VzLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbW92ZToge1xuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0dGV4dDogJ0NsaWNrIG9uIGEgZmVhdHVyZSB0byByZW1vdmUuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5cblxuLyoqXG4gKiAjIyMgRXZlbnRzXG4gKiBPbmNlIHlvdSBoYXZlIHN1Y2Nlc3NmdWxseSBhZGRlZCB0aGUgTGVhZmxldC5kcmF3IHBsdWdpbiB0byB5b3VyIG1hcCB5b3Ugd2lsbCB3YW50IHRvIHJlc3BvbmQgdG8gdGhlIGRpZmZlcmVudFxuICogYWN0aW9ucyB1c2VycyBjYW4gaW5pdGlhdGUuIFRoZSBmb2xsb3dpbmcgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkIG9uIHRoZSBtYXA6XG4gKlxuICogQGNsYXNzIEwuRHJhdy5FdmVudFxuICogQGFrYSBEcmF3LkV2ZW50XG4gKlxuICogVXNlIGBMLkRyYXcuRXZlbnQuRVZFTlROQU1FYCBjb25zdGFudHMgdG8gZW5zdXJlIGV2ZW50cyBhcmUgY29ycmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIG1hcC5vbihMLkRyYXcuRXZlbnQuQ1JFQVRFRDsgZnVuY3Rpb24gKGUpIHtcbiAqICAgIHZhciB0eXBlID0gZS5sYXllclR5cGUsXG4gKiAgICAgICAgbGF5ZXIgPSBlLmxheWVyO1xuICpcbiAqICAgIGlmICh0eXBlID09PSAnbWFya2VyJykge1xuICogICAgICAgIC8vIERvIG1hcmtlciBzcGVjaWZpYyBhY3Rpb25zXG4gKiAgICB9XG4gKlxuICogICAgLy8gRG8gd2hhdGV2ZXIgZWxzZSB5b3UgbmVlZCB0by4gKHNhdmUgdG8gZGI7IGFkZCB0byBtYXAgZXRjKVxuICogICAgbWFwLmFkZExheWVyKGxheWVyKTtcbiAqfSk7XG4gKiBgYGBcbiAqL1xuTC5EcmF3LkV2ZW50ID0ge307XG4vKipcbiAqIEBldmVudCBkcmF3OmNyZWF0ZWQ6IFBvbHlMaW5lOyBQb2x5Z29uOyBSZWN0YW5nbGU7IENpcmNsZTsgTWFya2VyIHwgU3RyaW5nXG4gKlxuICogTGF5ZXIgdGhhdCB3YXMganVzdCBjcmVhdGVkLlxuICogVGhlIHR5cGUgb2YgbGF5ZXIgdGhpcyBpcy4gT25lIG9mOiBgcG9seWxpbmVgOyBgcG9seWdvbmA7IGByZWN0YW5nbGVgOyBgY2lyY2xlYDsgYG1hcmtlcmBcbiAqIFRyaWdnZXJlZCB3aGVuIGEgbmV3IHZlY3RvciBvciBtYXJrZXIgaGFzIGJlZW4gY3JlYXRlZC5cbiAqXG4gKi9cbkwuRHJhdy5FdmVudC5DUkVBVEVEID0gJ2RyYXc6Y3JlYXRlZCc7XG5cbi8qKlxuICogQGV2ZW50IGRyYXc6ZWRpdGVkOiBMYXllckdyb3VwXG4gKlxuICogTGlzdCBvZiBhbGwgbGF5ZXJzIGp1c3QgZWRpdGVkIG9uIHRoZSBtYXAuXG4gKlxuICpcbiAqIFRyaWdnZXJlZCB3aGVuIGxheWVycyBpbiB0aGUgRmVhdHVyZUdyb3VwOyBpbml0aWFsaXNlZCB3aXRoIHRoZSBwbHVnaW47IGhhdmUgYmVlbiBlZGl0ZWQgYW5kIHNhdmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogICAgICBtYXAub24oJ2RyYXc6ZWRpdGVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgKiAgICAgICAgICB2YXIgbGF5ZXJzID0gZS5sYXllcnM7XG4gICAgICogICAgICAgICAgbGF5ZXJzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgKiAgICAgICAgICAgICAgLy9kbyB3aGF0ZXZlciB5b3Ugd2FudDsgbW9zdCBsaWtlbHkgc2F2ZSBiYWNrIHRvIGRiXG4gICAgICogICAgICAgICAgfSk7XG4gICAgICogICAgICB9KTtcbiAqIGBgYFxuICovXG5MLkRyYXcuRXZlbnQuRURJVEVEID0gJ2RyYXc6ZWRpdGVkJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkZWxldGVkOiBMYXllckdyb3VwXG4gKlxuICogTGlzdCBvZiBhbGwgbGF5ZXJzIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gbGF5ZXJzIGhhdmUgYmVlbiByZW1vdmVkIChhbmQgc2F2ZWQpIGZyb20gdGhlIEZlYXR1cmVHcm91cC5cbiAqL1xuTC5EcmF3LkV2ZW50LkRFTEVURUQgPSAnZHJhdzpkZWxldGVkJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkcmF3c3RhcnQ6IFN0cmluZ1xuICpcbiAqIFRoZSB0eXBlIG9mIGxheWVyIHRoaXMgaXMuIE9uZSBvZjpgcG9seWxpbmVgOyBgcG9seWdvbmA7IGByZWN0YW5nbGVgOyBgY2lyY2xlYDsgYG1hcmtlcmBcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBoYXMgY2hvc2VuIHRvIGRyYXcgYSBwYXJ0aWN1bGFyIHZlY3RvciBvciBtYXJrZXIuXG4gKi9cbkwuRHJhdy5FdmVudC5EUkFXU1RBUlQgPSAnZHJhdzpkcmF3c3RhcnQnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OmRyYXdzdG9wOiBTdHJpbmdcbiAqXG4gKiBUaGUgdHlwZSBvZiBsYXllciB0aGlzIGlzLiBPbmUgb2Y6IGBwb2x5bGluZWA7IGBwb2x5Z29uYDsgYHJlY3RhbmdsZWA7IGBjaXJjbGVgOyBgbWFya2VyYFxuICpcbiAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCBhIHBhcnRpY3VsYXIgdmVjdG9yIG9yIG1hcmtlci5cbiAqL1xuXG5MLkRyYXcuRXZlbnQuRFJBV1NUT1AgPSAnZHJhdzpkcmF3c3RvcCc7XG5cbi8qKlxuICogQGV2ZW50IGRyYXc6ZHJhd3ZlcnRleDogTGF5ZXJHcm91cFxuICpcbiAqIExpc3Qgb2YgYWxsIGxheWVycyBqdXN0IGJlaW5nIGFkZGVkIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiBhIHZlcnRleCBpcyBjcmVhdGVkIG9uIGEgcG9seWxpbmUgb3IgcG9seWdvbi5cbiAqL1xuTC5EcmF3LkV2ZW50LkRSQVdWRVJURVggPSAnZHJhdzpkcmF3dmVydGV4JztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzplZGl0c3RhcnQ6IFN0cmluZ1xuICpcbiAqIFRoZSB0eXBlIG9mIGVkaXQgdGhpcyBpcy4gT25lIG9mOiBgZWRpdGBcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZWRpdCBtb2RlIGJ5IGNsaWNraW5nIHRoZSBlZGl0IHRvb2wgYnV0dG9uLlxuICovXG5cbkwuRHJhdy5FdmVudC5FRElUU1RBUlQgPSAnZHJhdzplZGl0c3RhcnQnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OmVkaXRtb3ZlOiBJTGF5ZXJcbiAqXG4gKiAgTGF5ZXIgdGhhdCB3YXMganVzdCBtb3ZlZC5cbiAqXG4gKiBUcmlnZ2VyZWQgYXMgdGhlIHVzZXIgbW92ZXMgYSByZWN0YW5nbGU7IGNpcmNsZSBvciBtYXJrZXIuXG4gKi9cbkwuRHJhdy5FdmVudC5FRElUTU9WRSA9ICdkcmF3OmVkaXRtb3ZlJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzplZGl0cmVzaXplOiBJTGF5ZXJcbiAqXG4gKiBMYXllciB0aGF0IHdhcyBqdXN0IG1vdmVkLlxuICpcbiAqIFRyaWdnZXJlZCBhcyB0aGUgdXNlciByZXNpemVzIGEgcmVjdGFuZ2xlIG9yIGNpcmNsZS5cbiAqL1xuTC5EcmF3LkV2ZW50LkVESVRSRVNJWkUgPSAnZHJhdzplZGl0cmVzaXplJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzplZGl0dmVydGV4OiBMYXllckdyb3VwXG4gKlxuICogTGlzdCBvZiBhbGwgbGF5ZXJzIGp1c3QgYmVpbmcgZWRpdGVkIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiBhIHZlcnRleCBpcyBlZGl0ZWQgb24gYSBwb2x5bGluZSBvciBwb2x5Z29uLlxuICovXG5MLkRyYXcuRXZlbnQuRURJVFZFUlRFWCA9ICdkcmF3OmVkaXR2ZXJ0ZXgnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OmVkaXRzdG9wOiBTdHJpbmdcbiAqXG4gKiBUaGUgdHlwZSBvZiBlZGl0IHRoaXMgaXMuIE9uZSBvZjogYGVkaXRgXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgaGFzIGZpbnNoZWQgZWRpdGluZyAoZWRpdCBtb2RlKSBhbmQgc2F2ZXMgZWRpdHMuXG4gKi9cbkwuRHJhdy5FdmVudC5FRElUU1RPUCA9ICdkcmF3OmVkaXRzdG9wJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkZWxldGVzdGFydDogU3RyaW5nXG4gKlxuICogVGhlIHR5cGUgb2YgZWRpdCB0aGlzIGlzLiBPbmUgb2Y6IGByZW1vdmVgXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIHJlbW92ZSBtb2RlIGJ5IGNsaWNraW5nIHRoZSByZW1vdmUgdG9vbCBidXR0b24uXG4gKi9cbkwuRHJhdy5FdmVudC5ERUxFVEVTVEFSVCA9ICdkcmF3OmRlbGV0ZXN0YXJ0JztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkZWxldGVzdG9wOiBTdHJpbmdcbiAqXG4gKiBUaGUgdHlwZSBvZiBlZGl0IHRoaXMgaXMuIE9uZSBvZjogYHJlbW92ZWBcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBoYXMgZmluaXNoZWQgcmVtb3Zpbmcgc2hhcGVzIChyZW1vdmUgbW9kZSkgYW5kIHNhdmVzLlxuICovXG5MLkRyYXcuRXZlbnQuREVMRVRFU1RPUCA9ICdkcmF3OmRlbGV0ZXN0b3AnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OnRvb2xiYXJvcGVuZWQ6IFN0cmluZ1xuICpcbiAqIFRyaWdnZXJlZCB3aGVuIGEgdG9vbGJhciBpcyBvcGVuZWQuXG4gKi9cbkwuRHJhdy5FdmVudC5UT09MQkFST1BFTkVEID0gJ2RyYXc6dG9vbGJhcm9wZW5lZCc7XG5cbi8qKlxuICogQGV2ZW50IGRyYXc6dG9vbGJhcmNsb3NlZDogU3RyaW5nXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gYSB0b29sYmFyIGlzIGNsb3NlZC5cbiAqL1xuTC5EcmF3LkV2ZW50LlRPT0xCQVJDTE9TRUQgPSAnZHJhdzp0b29sYmFyY2xvc2VkJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzptYXJrZXJjb250ZXh0OiBTdHJpbmdcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiBhIG1hcmtlciBpcyByaWdodCBjbGlja2VkLlxuICovXG5MLkRyYXcuRXZlbnQuTUFSS0VSQ09OVEVYVCA9ICdkcmF3Om1hcmtlcmNvbnRleHQnO1xuXG5cbkwuRHJhdyA9IEwuRHJhdyB8fCB7fTtcblxuLyoqXG4gKiBAY2xhc3MgTC5EcmF3LkZlYXR1cmVcbiAqIEBha2EgRHJhdy5GZWF0dXJlXG4gKi9cbkwuRHJhdy5GZWF0dXJlID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9vdmVybGF5UGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fcG9wdXBQYW5lID0gbWFwLl9wYW5lcy5wb3B1cFBhbmU7XG5cblx0XHQvLyBNZXJnZSBkZWZhdWx0IHNoYXBlT3B0aW9ucyBvcHRpb25zIHdpdGggY3VzdG9tIHNoYXBlT3B0aW9uc1xuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2hhcGVPcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zLnNoYXBlT3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMsIG9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblx0XHR9XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0dmFyIHZlcnNpb24gPSBMLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHQvL0lmIFZlcnNpb24gaXMgPj0gMS4yLjBcblx0XHRpZiAocGFyc2VJbnQodmVyc2lvblswXSwgMTApID09PSAxICYmIHBhcnNlSW50KHZlcnNpb25bMV0sIDEwKSA+PSAyKSB7XG5cdFx0XHRMLkRyYXcuRmVhdHVyZS5pbmNsdWRlKEwuRXZlbnRlZC5wcm90b3R5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRyYXcuRmVhdHVyZS5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdm9pZFxuXHQvLyBFbmFibGVzIHRoaXMgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLmZpcmUoJ2VuYWJsZWQnLCB7aGFuZGxlcjogdGhpcy50eXBlfSk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRFJBV1NUQVJULCB7bGF5ZXJUeXBlOiB0aGlzLnR5cGV9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdm9pZFxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRFJBV1NUT1AsIHtsYXllclR5cGU6IHRoaXMudHlwZX0pO1xuXG5cdFx0dGhpcy5maXJlKCdkaXNhYmxlZCcsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkJ3MgZXZlbnQgbGlzdGVuZXJzIHRvIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblxuXHRcdFx0bWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XG5cblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgTC5EcmF3LlRvb2x0aXAodGhpcy5fbWFwKTtcblxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdrZXl1cCcsIHRoaXMuX2NhbmNlbERyYXdpbmcsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKCk6IHZvaWRcblx0Ly8gUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdrZXl1cCcsIHRoaXMuX2NhbmNlbERyYXdpbmcsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wdGlvbnMob2JqZWN0KTogdm9pZFxuXHQvLyBTZXRzIG5ldyBvcHRpb25zIHRvIHRoaXMgaGFuZGxlclxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRfZmlyZUNyZWF0ZWRFdmVudDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkNSRUFURUQsIHtsYXllcjogbGF5ZXIsIGxheWVyVHlwZTogdGhpcy50eXBlfSk7XG5cdH0sXG5cblx0Ly8gQ2FuY2VsIGRyYXdpbmcgd2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkXG5cdF9jYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnZHJhdzpjYW5jZWxlZCcsIHtsYXllclR5cGU6IHRoaXMudHlwZX0pO1xuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRHJhdy5Qb2x5bGluZVxuICogQGFrYSBEcmF3LlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgTC5EcmF3LkZlYXR1cmVcbiAqL1xuTC5EcmF3LlBvbHlsaW5lID0gTC5EcmF3LkZlYXR1cmUuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdwb2x5bGluZSdcblx0fSxcblxuXHRQb2x5OiBMLlBvbHlsaW5lLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRhbGxvd0ludGVyc2VjdGlvbjogdHJ1ZSxcblx0XHRyZXBlYXRNb2RlOiBmYWxzZSxcblx0XHRkcmF3RXJyb3I6IHtcblx0XHRcdGNvbG9yOiAnI2IwMGIwMCcsXG5cdFx0XHR0aW1lb3V0OiAyNTAwXG5cdFx0fSxcblx0XHRpY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24nXG5cdFx0fSksXG5cdFx0dG91Y2hJY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApLFxuXHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LXRvdWNoLWljb24nXG5cdFx0fSksXG5cdFx0Z3VpZGVsaW5lRGlzdGFuY2U6IDIwLFxuXHRcdG1heEd1aWRlTGluZUxlbmd0aDogNDAwMCxcblx0XHRzaGFwZU9wdGlvbnM6IHtcblx0XHRcdHN0cm9rZTogdHJ1ZSxcblx0XHRcdGNvbG9yOiAnIzMzODhmZicsXG5cdFx0XHR3ZWlnaHQ6IDQsXG5cdFx0XHRvcGFjaXR5OiAwLjUsXG5cdFx0XHRmaWxsOiBmYWxzZSxcblx0XHRcdGNsaWNrYWJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0bWV0cmljOiB0cnVlLCAvLyBXaGV0aGVyIHRvIHVzZSB0aGUgbWV0cmljIG1lYXN1cmVtZW50IHN5c3RlbSBvciBpbXBlcmlhbFxuXHRcdGZlZXQ6IHRydWUsIC8vIFdoZW4gbm90IG1ldHJpYywgdG8gdXNlIGZlZXQgaW5zdGVhZCBvZiB5YXJkcyBmb3IgZGlzcGxheS5cblx0XHRuYXV0aWM6IGZhbHNlLCAvLyBXaGVuIG5vdCBtZXRyaWMsIG5vdCBmZWV0IHVzZSBuYXV0aWMgbWlsZSBmb3IgZGlzcGxheVxuXHRcdHNob3dMZW5ndGg6IHRydWUsIC8vIFdoZXRoZXIgdG8gZGlzcGxheSBkaXN0YW5jZSBpbiB0aGUgdG9vbHRpcFxuXHRcdHpJbmRleE9mZnNldDogMjAwMCwgLy8gVGhpcyBzaG91bGQgYmUgPiB0aGFuIHRoZSBoaWdoZXN0IHotaW5kZXggYW55IG1hcCBsYXllcnNcblx0XHRmYWN0b3I6IDEsIC8vIFRvIGNoYW5nZSBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXHRcdG1heFBvaW50czogMCAvLyBPbmNlIHRoaXMgbnVtYmVyIG9mIHBvaW50cyBhcmUgcGxhY2VkLCBmaW5pc2ggc2hhcGVcblx0fSxcblxuXHQvLyBAbWV0aG9kIGluaXRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0Ly8gaWYgdG91Y2gsIHN3aXRjaCB0byB0b3VjaCBpY29uXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0dGhpcy5vcHRpb25zLmljb24gPSB0aGlzLm9wdGlvbnMudG91Y2hJY29uO1xuXHRcdH1cblxuXHRcdC8vIE5lZWQgdG8gc2V0IHRoaXMgaGVyZSB0byBlbnN1cmUgdGhlIGNvcnJlY3QgbWVzc2FnZSBpcyB1c2VkLlxuXHRcdHRoaXMub3B0aW9ucy5kcmF3RXJyb3IubWVzc2FnZSA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMucG9seWxpbmUuZXJyb3I7XG5cblx0XHQvLyBNZXJnZSBkZWZhdWx0IGRyYXdFcnJvciBvcHRpb25zIHdpdGggY3VzdG9tIG9wdGlvbnNcblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRyYXdFcnJvcikge1xuXHRcdFx0b3B0aW9ucy5kcmF3RXJyb3IgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLCBvcHRpb25zLmRyYXdFcnJvcik7XG5cdFx0fVxuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkRyYXcuUG9seWxpbmUuVFlQRTtcblxuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkIGxpc3RlbmVyIGhvb2tzIHRvIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5hZGRIb29rcy5jYWxsKHRoaXMpO1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcmtlcnMgPSBbXTtcblxuXHRcdFx0dGhpcy5fbWFya2VyR3JvdXAgPSBuZXcgTC5MYXllckdyb3VwKCk7XG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApO1xuXG5cdFx0XHR0aGlzLl9wb2x5ID0gbmV3IEwuUG9seWxpbmUoW10sIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQodGhpcy5fZ2V0VG9vbHRpcFRleHQoKSk7XG5cblx0XHRcdC8vIE1ha2UgYSB0cmFuc3BhcmVudCBtYXJrZXIgdGhhdCB3aWxsIHVzZWQgdG8gY2F0Y2ggY2xpY2sgZXZlbnRzLiBUaGVzZSBjbGlja1xuXHRcdFx0Ly8gZXZlbnRzIHdpbGwgY3JlYXRlIHRoZSB2ZXJ0aWNlcy4gV2UgbmVlZCB0byBkbyB0aGlzIHNvIHdlIGNhbiBlbnN1cmUgdGhhdFxuXHRcdFx0Ly8gd2UgY2FuIGNyZWF0ZSB2ZXJ0aWNlcyBvdmVyIG90aGVyIG1hcCBsYXllcnMgKG1hcmtlcnMsIHZlY3RvciBsYXllcnMpLiBXZVxuXHRcdFx0Ly8gYWxzbyBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIGFueSBjbGljayBoYW5kbGVycyBvZiBvYmplY3RzIHdlIGFyZSBjbGlja2luZyBvblxuXHRcdFx0Ly8gd2hpbGUgZHJhd2luZy5cblx0XHRcdGlmICghdGhpcy5fbW91c2VNYXJrZXIpIHtcblx0XHRcdFx0dGhpcy5fbW91c2VNYXJrZXIgPSBMLm1hcmtlcih0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHtcblx0XHRcdFx0XHRpY29uOiBMLmRpdkljb24oe1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1tb3VzZS1tYXJrZXInLFxuXHRcdFx0XHRcdFx0aWNvbkFuY2hvcjogWzIwLCAyMF0sXG5cdFx0XHRcdFx0XHRpY29uU2l6ZTogWzQwLCA0MF1cblx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbW91c2VNYXJrZXJcblx0XHRcdFx0Lm9uKCdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQsIHRoaXMpXG5cdFx0XHRcdC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpIC8vIE5lY2Vzc2FyeSB0byBwcmV2ZW50IDAuOCBzdHV0dGVyXG5cdFx0XHRcdC5vbignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHRcdC5vbignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcykgLy8gTmVjZXNzYXJ5IGZvciAwLjggY29tcGF0aWJpbGl0eVxuXHRcdFx0XHQuYWRkVG8odGhpcy5fbWFwKTtcblxuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcykgLy8gTmVjZXNzYXJ5IGZvciAwLjcgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHQub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ3pvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpXG5cdFx0XHRcdC5vbigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gsIHRoaXMpXG5cdFx0XHRcdC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmcm9tIHRoaXMgaGFuZGxlci5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUucmVtb3ZlSG9va3MuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2NsZWFySGlkZUVycm9yVGltZW91dCgpO1xuXG5cdFx0dGhpcy5fY2xlYW5VcFNoYXBlKCk7XG5cblx0XHQvLyByZW1vdmUgbWFya2VycyBmcm9tIG1hcFxuXHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9tYXJrZXJHcm91cCk7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcmtlckdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXJzO1xuXG5cdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3BvbHkpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wb2x5O1xuXG5cdFx0dGhpcy5fbW91c2VNYXJrZXJcblx0XHRcdC5vZmYoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0Lm9mZignbW91c2VvdXQnLCB0aGlzLl9vbk1vdXNlT3V0LCB0aGlzKVxuXHRcdFx0Lm9mZignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcylcblx0XHRcdC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbW91c2VNYXJrZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9tb3VzZU1hcmtlcjtcblxuXHRcdC8vIGNsZWFuIHVwIERPTVxuXHRcdHRoaXMuX2NsZWFyR3VpZGVzKCk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5vZmYoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIHRoaXMpXG5cdFx0XHQub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdC5vZmYoJ3pvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpXG5cdFx0XHQub2ZmKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKVxuXHRcdFx0Lm9mZigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gsIHRoaXMpXG5cdFx0XHQub2ZmKCdjbGljaycsIHRoaXMuX29uVG91Y2gsIHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGVsZXRlTGFzdFZlcnRleCgpOiB2b2lkXG5cdC8vIFJlbW92ZSB0aGUgbGFzdCB2ZXJ0ZXggZnJvbSB0aGUgcG9seWxpbmUsIHJlbW92ZXMgcG9seWxpbmUgZnJvbSBtYXAgaWYgb25seSBvbmUgcG9pbnQgZXhpc3RzLlxuXHRkZWxldGVMYXN0VmVydGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoIDw9IDEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGFzdE1hcmtlciA9IHRoaXMuX21hcmtlcnMucG9wKCksXG5cdFx0XHRwb2x5ID0gdGhpcy5fcG9seSxcblx0XHRcdC8vIFJlcGxhY2VzIC5zcGxpY2VMYXRMbmdzKClcblx0XHRcdGxhdGxuZ3MgPSBwb2x5LmdldExhdExuZ3MoKSxcblx0XHRcdGxhdGxuZyA9IGxhdGxuZ3Muc3BsaWNlKC0xLCAxKVswXTtcblx0XHR0aGlzLl9wb2x5LnNldExhdExuZ3MobGF0bG5ncyk7XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihsYXN0TWFya2VyKTtcblxuXHRcdGlmIChwb2x5LmdldExhdExuZ3MoKS5sZW5ndGggPCAyKSB7XG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocG9seSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmVydGV4Q2hhbmdlZChsYXRsbmcsIGZhbHNlKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZFZlcnRleCgpOiB2b2lkXG5cdC8vIEFkZCBhIHZlcnRleCB0byB0aGUgZW5kIG9mIHRoZSBwb2x5bGluZVxuXHRhZGRWZXJ0ZXg6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgbWFya2Vyc0xlbmd0aCA9IHRoaXMuX21hcmtlcnMubGVuZ3RoO1xuXHRcdC8vIG1hcmtlcnNMZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMiBiZWZvcmUgaW50ZXJzZWN0aW9ucyBjYW4gb2NjdXJcblx0XHRpZiAobWFya2Vyc0xlbmd0aCA+PSAyICYmICF0aGlzLm9wdGlvbnMuYWxsb3dJbnRlcnNlY3Rpb24gJiYgdGhpcy5fcG9seS5uZXdMYXRMbmdJbnRlcnNlY3RzKGxhdGxuZykpIHtcblx0XHRcdHRoaXMuX3Nob3dFcnJvclRvb2x0aXAoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5fZXJyb3JTaG93bikge1xuXHRcdFx0dGhpcy5faGlkZUVycm9yVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcmtlcnMucHVzaCh0aGlzLl9jcmVhdGVNYXJrZXIobGF0bG5nKSk7XG5cblx0XHR0aGlzLl9wb2x5LmFkZExhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX3BvbHkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3ZlcnRleENoYW5nZWQobGF0bG5nLCB0cnVlKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNvbXBsZXRlU2hhcGUoKTogdm9pZFxuXHQvLyBDbG9zZXMgdGhlIHBvbHlsaW5lIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50c1xuXHRjb21wbGV0ZVNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoIDw9IDEgfHwgIXRoaXMuX3NoYXBlSXNWYWxpZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZUNyZWF0ZWRFdmVudCgpO1xuXHRcdHRoaXMuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXBlYXRNb2RlKSB7XG5cdFx0XHR0aGlzLmVuYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZmluaXNoU2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX3BvbHkuX2RlZmF1bHRTaGFwZSA/IHRoaXMuX3BvbHkuX2RlZmF1bHRTaGFwZSgpIDogdGhpcy5fcG9seS5nZXRMYXRMbmdzKCk7XG5cdFx0dmFyIGludGVyc2VjdHMgPSB0aGlzLl9wb2x5Lm5ld0xhdExuZ0ludGVyc2VjdHMobGF0bG5nc1tsYXRsbmdzLmxlbmd0aCAtIDFdKTtcblxuXHRcdGlmICgoIXRoaXMub3B0aW9ucy5hbGxvd0ludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3RzKSB8fCAhdGhpcy5fc2hhcGVJc1ZhbGlkKCkpIHtcblx0XHRcdHRoaXMuX3Nob3dFcnJvclRvb2x0aXAoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9maXJlQ3JlYXRlZEV2ZW50KCk7XG5cdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXBlYXRNb2RlKSB7XG5cdFx0XHR0aGlzLmVuYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYWxsZWQgdG8gdmVyaWZ5IHRoZSBzaGFwZSBpcyB2YWxpZCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIGZpbmlzaCBpdFxuXHQvLyBSZXR1cm4gZmFsc2UgaWYgdGhlIHNoYXBlIGlzIG5vdCB2YWxpZFxuXHRfc2hhcGVJc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXJzICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVHdWlkZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG5ld1BvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0dmFyIGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobmV3UG9zKTtcblxuXHRcdC8vIFNhdmUgbGF0bG5nXG5cdFx0Ly8gc2hvdWxkIHRoaXMgYmUgbW92ZWQgdG8gX3VwZGF0ZUd1aWRlKCkgP1xuXHRcdHRoaXMuX2N1cnJlbnRMYXRMbmcgPSBsYXRsbmc7XG5cblx0XHR0aGlzLl91cGRhdGVUb29sdGlwKGxhdGxuZyk7XG5cblx0XHQvLyBVcGRhdGUgdGhlIGd1aWRlIGxpbmVcblx0XHR0aGlzLl91cGRhdGVHdWlkZShuZXdQb3MpO1xuXG5cdFx0Ly8gVXBkYXRlIHRoZSBtb3VzZSBtYXJrZXIgcG9zaXRpb25cblx0XHR0aGlzLl9tb3VzZU1hcmtlci5zZXRMYXRMbmcobGF0bG5nKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZS5vcmlnaW5hbEV2ZW50KTtcblx0fSxcblxuXHRfdmVydGV4Q2hhbmdlZDogZnVuY3Rpb24gKGxhdGxuZywgYWRkZWQpIHtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRFJBV1ZFUlRFWCwge2xheWVyczogdGhpcy5fbWFya2VyR3JvdXB9KTtcblx0XHR0aGlzLl91cGRhdGVGaW5pc2hIYW5kbGVyKCk7XG5cblx0XHR0aGlzLl91cGRhdGVSdW5uaW5nTWVhc3VyZShsYXRsbmcsIGFkZGVkKTtcblxuXHRcdHRoaXMuX2NsZWFyR3VpZGVzKCk7XG5cblx0XHR0aGlzLl91cGRhdGVUb29sdGlwKCk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fY2xpY2tIYW5kbGVkICYmICF0aGlzLl90b3VjaEhhbmRsZWQgJiYgIXRoaXMuX2Rpc2FibGVNYXJrZXJzKSB7XG5cdFx0XHR0aGlzLl9vbk1vdXNlTW92ZShlKTtcblx0XHRcdHRoaXMuX2NsaWNrSGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9kaXNhYmxlTmV3TWFya2VycygpO1xuXHRcdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0XHR2YXIgY2xpZW50WCA9IG9yaWdpbmFsRXZlbnQuY2xpZW50WDtcblx0XHRcdHZhciBjbGllbnRZID0gb3JpZ2luYWxFdmVudC5jbGllbnRZO1xuXHRcdFx0dGhpcy5fc3RhcnRQb2ludC5jYWxsKHRoaXMsIGNsaWVudFgsIGNsaWVudFkpO1xuXHRcdH1cblx0fSxcblxuXHRfc3RhcnRQb2ludDogZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcblx0XHR0aGlzLl9tb3VzZURvd25PcmlnaW4gPSBMLnBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0dmFyIGNsaWVudFggPSBvcmlnaW5hbEV2ZW50LmNsaWVudFg7XG5cdFx0dmFyIGNsaWVudFkgPSBvcmlnaW5hbEV2ZW50LmNsaWVudFk7XG5cdFx0dGhpcy5fZW5kUG9pbnQuY2FsbCh0aGlzLCBjbGllbnRYLCBjbGllbnRZLCBlKTtcblx0XHR0aGlzLl9jbGlja0hhbmRsZWQgPSBudWxsO1xuXHR9LFxuXG5cdF9lbmRQb2ludDogZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFksIGUpIHtcblx0XHRpZiAodGhpcy5fbW91c2VEb3duT3JpZ2luKSB7XG5cdFx0XHR2YXIgZHJhZ0NoZWNrRGlzdGFuY2UgPSBMLnBvaW50KGNsaWVudFgsIGNsaWVudFkpXG5cdFx0XHRcdC5kaXN0YW5jZVRvKHRoaXMuX21vdXNlRG93bk9yaWdpbik7XG5cdFx0XHR2YXIgbGFzdFB0RGlzdGFuY2UgPSB0aGlzLl9jYWxjdWxhdGVGaW5pc2hEaXN0YW5jZShlLmxhdGxuZyk7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm1heFBvaW50cyA+IDEgJiYgdGhpcy5vcHRpb25zLm1heFBvaW50cyA9PSB0aGlzLl9tYXJrZXJzLmxlbmd0aCArIDEpIHtcblx0XHRcdFx0dGhpcy5hZGRWZXJ0ZXgoZS5sYXRsbmcpO1xuXHRcdFx0XHR0aGlzLl9maW5pc2hTaGFwZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXN0UHREaXN0YW5jZSA8IDEwICYmIEwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHR0aGlzLl9maW5pc2hTaGFwZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChNYXRoLmFicyhkcmFnQ2hlY2tEaXN0YW5jZSkgPCA5ICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSB7XG5cdFx0XHRcdHRoaXMuYWRkVmVydGV4KGUubGF0bG5nKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2VuYWJsZU5ld01hcmtlcnMoKTsgLy8gYWZ0ZXIgYSBzaG9ydCBwYXVzZSwgZW5hYmxlIG5ldyBtYXJrZXJzXG5cdFx0fVxuXHRcdHRoaXMuX21vdXNlRG93bk9yaWdpbiA9IG51bGw7XG5cdH0sXG5cblx0Ly8gb250b3VjaCBwcmV2ZW50ZWQgYnkgY2xpY2tIYW5kbGVkIGZsYWcgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGZpcmUgYm90aCBjbGljay90b3VjaCBldmVudHMsXG5cdC8vIGNhdXNpbmcgdW53YW50ZWQgYmVoYXZpb3Jcblx0X29uVG91Y2g6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0dmFyIGNsaWVudFg7XG5cdFx0dmFyIGNsaWVudFk7XG5cdFx0aWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0gJiYgIXRoaXMuX2NsaWNrSGFuZGxlZCAmJiAhdGhpcy5fdG91Y2hIYW5kbGVkICYmICF0aGlzLl9kaXNhYmxlTWFya2Vycykge1xuXHRcdFx0Y2xpZW50WCA9IG9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuXHRcdFx0Y2xpZW50WSA9IG9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuXHRcdFx0dGhpcy5fZGlzYWJsZU5ld01hcmtlcnMoKTtcblx0XHRcdHRoaXMuX3RvdWNoSGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9zdGFydFBvaW50LmNhbGwodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG5cdFx0XHR0aGlzLl9lbmRQb2ludC5jYWxsKHRoaXMsIGNsaWVudFgsIGNsaWVudFksIGUpO1xuXHRcdFx0dGhpcy5fdG91Y2hIYW5kbGVkID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5fY2xpY2tIYW5kbGVkID0gbnVsbDtcblx0fSxcblxuXHRfb25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLl9vbk1vdXNlT3V0LmNhbGwodGhpcy5fdG9vbHRpcCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNhbGN1bGF0ZSBpZiB3ZSBhcmUgY3VycmVudGx5IHdpdGhpbiBjbG9zZSBlbm91Z2ggZGlzdGFuY2Vcblx0Ly8gb2YgdGhlIGNsb3NpbmcgcG9pbnQgKGZpcnN0IHBvaW50IGZvciBzaGFwZXMsIGxhc3QgcG9pbnQgZm9yIGxpbmVzKVxuXHQvLyB0aGlzIGlzIHNlbWktdWdseSBjb2RlIGJ1dCB0aGUgb25seSByZWxpYWJsZSB3YXkgaSBmb3VuZCB0byBnZXQgdGhlIGpvYiBkb25lXG5cdC8vIG5vdGU6IGNhbGN1bGF0aW5nIHBvaW50LmRpc3RhbmNlVG8gYmV0d2VlbiBtb3VzZURvd25PcmlnaW4gYW5kIGxhc3QgbWFya2VyIGRpZCBOT1Qgd29ya1xuXHRfY2FsY3VsYXRlRmluaXNoRGlzdGFuY2U6IGZ1bmN0aW9uIChwb3RlbnRpYWxMYXRMbmcpIHtcblx0XHR2YXIgbGFzdFB0RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIGZpbmlzaE1hcmtlcjtcblx0XHRcdGlmICh0aGlzLnR5cGUgPT09IEwuRHJhdy5Qb2x5bGluZS5UWVBFKSB7XG5cdFx0XHRcdGZpbmlzaE1hcmtlciA9IHRoaXMuX21hcmtlcnNbdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxXTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBMLkRyYXcuUG9seWdvbi5UWVBFKSB7XG5cdFx0XHRcdGZpbmlzaE1hcmtlciA9IHRoaXMuX21hcmtlcnNbMF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gSW5maW5pdHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGFzdE1hcmtlclBvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoZmluaXNoTWFya2VyLmdldExhdExuZygpKSxcblx0XHRcdFx0cG90ZW50aWFsTWFya2VyID0gbmV3IEwuTWFya2VyKHBvdGVudGlhbExhdExuZywge1xuXHRcdFx0XHRcdGljb246IHRoaXMub3B0aW9ucy5pY29uLFxuXHRcdFx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCAqIDJcblx0XHRcdFx0fSk7XG5cdFx0XHR2YXIgcG90ZW50aWFsTWFya2VyUGludCA9IHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHBvdGVudGlhbE1hcmtlci5nZXRMYXRMbmcoKSk7XG5cdFx0XHRsYXN0UHREaXN0YW5jZSA9IGxhc3RNYXJrZXJQb2ludC5kaXN0YW5jZVRvKHBvdGVudGlhbE1hcmtlclBpbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXN0UHREaXN0YW5jZSA9IEluZmluaXR5O1xuXHRcdH1cblx0XHRyZXR1cm4gbGFzdFB0RGlzdGFuY2U7XG5cdH0sXG5cblx0X3VwZGF0ZUZpbmlzaEhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyQ291bnQgPSB0aGlzLl9tYXJrZXJzLmxlbmd0aDtcblx0XHQvLyBUaGUgbGFzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYSBjbGljayBoYW5kbGVyIHRvIGNsb3NlIHRoZSBwb2x5bGluZVxuXHRcdGlmIChtYXJrZXJDb3VudCA+IDEpIHtcblx0XHRcdHRoaXMuX21hcmtlcnNbbWFya2VyQ291bnQgLSAxXS5vbignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBvbGQgbWFya2VyIGNsaWNrIGhhbmRsZXIgKGFzIG9ubHkgdGhlIGxhc3QgcG9pbnQgc2hvdWxkIGNsb3NlIHRoZSBwb2x5bGluZSlcblx0XHRpZiAobWFya2VyQ291bnQgPiAyKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzW21hcmtlckNvdW50IC0gMl0ub2ZmKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG5cdFx0XHRpY29uOiB0aGlzLm9wdGlvbnMuaWNvbixcblx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCAqIDJcblx0XHR9KTtcblxuXHRcdHRoaXMuX21hcmtlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cblx0XHRyZXR1cm4gbWFya2VyO1xuXHR9LFxuXG5cdF91cGRhdGVHdWlkZTogZnVuY3Rpb24gKG5ld1Bvcykge1xuXHRcdHZhciBtYXJrZXJDb3VudCA9IHRoaXMuX21hcmtlcnMgPyB0aGlzLl9tYXJrZXJzLmxlbmd0aCA6IDA7XG5cblx0XHRpZiAobWFya2VyQ291bnQgPiAwKSB7XG5cdFx0XHRuZXdQb3MgPSBuZXdQb3MgfHwgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9jdXJyZW50TGF0TG5nKTtcblxuXHRcdFx0Ly8gZHJhdyB0aGUgZ3VpZGUgbGluZVxuXHRcdFx0dGhpcy5fY2xlYXJHdWlkZXMoKTtcblx0XHRcdHRoaXMuX2RyYXdHdWlkZShcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9tYXJrZXJzW21hcmtlckNvdW50IC0gMV0uZ2V0TGF0TG5nKCkpLFxuXHRcdFx0XHRuZXdQb3Ncblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVUb29sdGlwOiBmdW5jdGlvbiAobGF0TG5nKSB7XG5cdFx0dmFyIHRleHQgPSB0aGlzLl9nZXRUb29sdGlwVGV4dCgpO1xuXG5cdFx0aWYgKGxhdExuZykge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVQb3NpdGlvbihsYXRMbmcpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fZXJyb3JTaG93bikge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHRleHQpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd0d1aWRlOiBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpIHtcblx0XHR2YXIgbGVuZ3RoID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoTWF0aC5wb3coKHBvaW50Qi54IC0gcG9pbnRBLngpLCAyKSArIE1hdGgucG93KChwb2ludEIueSAtIHBvaW50QS55KSwgMikpKSxcblx0XHRcdGd1aWRlbGluZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLmd1aWRlbGluZURpc3RhbmNlLFxuXHRcdFx0bWF4R3VpZGVMaW5lTGVuZ3RoID0gdGhpcy5vcHRpb25zLm1heEd1aWRlTGluZUxlbmd0aCxcblx0XHRcdC8vIE9ubHkgZHJhdyBhIGd1aWRlbGluZSB3aXRoIGEgbWF4IGxlbmd0aFxuXHRcdFx0aSA9IGxlbmd0aCA+IG1heEd1aWRlTGluZUxlbmd0aCA/IGxlbmd0aCAtIG1heEd1aWRlTGluZUxlbmd0aCA6IGd1aWRlbGluZURpc3RhbmNlLFxuXHRcdFx0ZnJhY3Rpb24sXG5cdFx0XHRkYXNoUG9pbnQsXG5cdFx0XHRkYXNoO1xuXG5cdFx0Ly9jcmVhdGUgdGhlIGd1aWRlcyBjb250YWluZXIgaWYgd2UgaGF2ZW4ndCB5ZXRcblx0XHRpZiAoIXRoaXMuX2d1aWRlc0NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5fZ3VpZGVzQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy1ndWlkZXMnLCB0aGlzLl9vdmVybGF5UGFuZSk7XG5cdFx0fVxuXG5cdFx0Ly9kcmF3IGEgZGFzaCBldmVyeSBHdWlsZGVMaW5lRGlzdGFuY2Vcblx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSB0aGlzLm9wdGlvbnMuZ3VpZGVsaW5lRGlzdGFuY2UpIHtcblx0XHRcdC8vd29yayBvdXQgZnJhY3Rpb24gYWxvbmcgbGluZSB3ZSBhcmVcblx0XHRcdGZyYWN0aW9uID0gaSAvIGxlbmd0aDtcblxuXHRcdFx0Ly9jYWxjdWxhdGUgbmV3IHgseSBwb2ludFxuXHRcdFx0ZGFzaFBvaW50ID0ge1xuXHRcdFx0XHR4OiBNYXRoLmZsb29yKChwb2ludEEueCAqICgxIC0gZnJhY3Rpb24pKSArIChmcmFjdGlvbiAqIHBvaW50Qi54KSksXG5cdFx0XHRcdHk6IE1hdGguZmxvb3IoKHBvaW50QS55ICogKDEgLSBmcmFjdGlvbikpICsgKGZyYWN0aW9uICogcG9pbnRCLnkpKVxuXHRcdFx0fTtcblxuXHRcdFx0Ly9hZGQgZ3VpZGUgZGFzaCB0byBndWlkZSBjb250YWluZXJcblx0XHRcdGRhc2ggPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1kcmF3LWd1aWRlLWRhc2gnLCB0aGlzLl9ndWlkZXNDb250YWluZXIpO1xuXHRcdFx0ZGFzaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPVxuXHRcdFx0XHQhdGhpcy5fZXJyb3JTaG93biA/IHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMuY29sb3IgOiB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLmNvbG9yO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oZGFzaCwgZGFzaFBvaW50KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUd1aWRlQ29sb3I6IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdGlmICh0aGlzLl9ndWlkZXNDb250YWluZXIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fZ3VpZGVzQ29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2d1aWRlc0NvbnRhaW5lci5jaGlsZE5vZGVzW2ldLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyByZW1vdmVzIGFsbCBjaGlsZCBlbGVtZW50cyAoZ3VpZGUgZGFzaGVzKSBmcm9tIHRoZSBndWlkZXMgY29udGFpbmVyXG5cdF9jbGVhckd1aWRlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9ndWlkZXNDb250YWluZXIpIHtcblx0XHRcdHdoaWxlICh0aGlzLl9ndWlkZXNDb250YWluZXIuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHR0aGlzLl9ndWlkZXNDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZ3VpZGVzQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VG9vbHRpcFRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2hvd0xlbmd0aCA9IHRoaXMub3B0aW9ucy5zaG93TGVuZ3RoLFxuXHRcdFx0bGFiZWxUZXh0LCBkaXN0YW5jZVN0cjtcblx0XHRpZiAodGhpcy5fbWFya2Vycy5sZW5ndGggPT09IDApIHtcblx0XHRcdGxhYmVsVGV4dCA9IHtcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS50b29sdGlwLnN0YXJ0XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXN0YW5jZVN0ciA9IHNob3dMZW5ndGggPyB0aGlzLl9nZXRNZWFzdXJlbWVudFN0cmluZygpIDogJyc7XG5cblx0XHRcdGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRsYWJlbFRleHQgPSB7XG5cdFx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS50b29sdGlwLmNvbnQsXG5cdFx0XHRcdFx0c3VidGV4dDogZGlzdGFuY2VTdHJcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhYmVsVGV4dCA9IHtcblx0XHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlsaW5lLnRvb2x0aXAuZW5kLFxuXHRcdFx0XHRcdHN1YnRleHQ6IGRpc3RhbmNlU3RyXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsYWJlbFRleHQ7XG5cdH0sXG5cblx0X3VwZGF0ZVJ1bm5pbmdNZWFzdXJlOiBmdW5jdGlvbiAobGF0bG5nLCBhZGRlZCkge1xuXHRcdHZhciBtYXJrZXJzTGVuZ3RoID0gdGhpcy5fbWFya2Vycy5sZW5ndGgsXG5cdFx0XHRwcmV2aW91c01hcmtlckluZGV4LCBkaXN0YW5jZTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmV2aW91c01hcmtlckluZGV4ID0gbWFya2Vyc0xlbmd0aCAtIChhZGRlZCA/IDIgOiAxKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiYXNlZCBvbiB0aGUgdmVyc2lvblxuXHRcdFx0aWYgKEwuR2VvbWV0cnlVdGlsLmlzVmVyc2lvbjA3eCgpKSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gbGF0bG5nLmRpc3RhbmNlVG8odGhpcy5fbWFya2Vyc1twcmV2aW91c01hcmtlckluZGV4XS5nZXRMYXRMbmcoKSkgKiAodGhpcy5vcHRpb25zLmZhY3RvciB8fCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gdGhpcy5fbWFwLmRpc3RhbmNlKGxhdGxuZywgdGhpcy5fbWFya2Vyc1twcmV2aW91c01hcmtlckluZGV4XS5nZXRMYXRMbmcoKSkgKiAodGhpcy5vcHRpb25zLmZhY3RvciB8fCAxKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgKz0gZGlzdGFuY2UgKiAoYWRkZWQgPyAxIDogLTEpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0TWVhc3VyZW1lbnRTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3VycmVudExhdExuZyA9IHRoaXMuX2N1cnJlbnRMYXRMbmcsXG5cdFx0XHRwcmV2aW91c0xhdExuZyA9IHRoaXMuX21hcmtlcnNbdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxXS5nZXRMYXRMbmcoKSxcblx0XHRcdGRpc3RhbmNlO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBsYXN0IGZpeGVkIHBvaW50IHRvIHRoZSBtb3VzZSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdmVyc2lvblxuXHRcdGlmIChMLkdlb21ldHJ5VXRpbC5pc1ZlcnNpb24wN3goKSkge1xuXHRcdFx0ZGlzdGFuY2UgPSBwcmV2aW91c0xhdExuZyAmJiBjdXJyZW50TGF0TG5nICYmIGN1cnJlbnRMYXRMbmcuZGlzdGFuY2VUbyA/IHRoaXMuX21lYXN1cmVtZW50UnVubmluZ1RvdGFsICsgY3VycmVudExhdExuZy5kaXN0YW5jZVRvKHByZXZpb3VzTGF0TG5nKSAqICh0aGlzLm9wdGlvbnMuZmFjdG9yIHx8IDEpIDogdGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgfHwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzdGFuY2UgPSBwcmV2aW91c0xhdExuZyAmJiBjdXJyZW50TGF0TG5nID8gdGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgKyB0aGlzLl9tYXAuZGlzdGFuY2UoY3VycmVudExhdExuZywgcHJldmlvdXNMYXRMbmcpICogKHRoaXMub3B0aW9ucy5mYWN0b3IgfHwgMSkgOiB0aGlzLl9tZWFzdXJlbWVudFJ1bm5pbmdUb3RhbCB8fCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBMLkdlb21ldHJ5VXRpbC5yZWFkYWJsZURpc3RhbmNlKGRpc3RhbmNlLCB0aGlzLm9wdGlvbnMubWV0cmljLCB0aGlzLm9wdGlvbnMuZmVldCwgdGhpcy5vcHRpb25zLm5hdXRpYywgdGhpcy5vcHRpb25zLnByZWNpc2lvbik7XG5cdH0sXG5cblx0X3Nob3dFcnJvclRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9lcnJvclNob3duID0gdHJ1ZTtcblxuXHRcdC8vIFVwZGF0ZSB0b29sdGlwXG5cdFx0dGhpcy5fdG9vbHRpcFxuXHRcdFx0LnNob3dBc0Vycm9yKClcblx0XHRcdC51cGRhdGVDb250ZW50KHt0ZXh0OiB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLm1lc3NhZ2V9KTtcblxuXHRcdC8vIFVwZGF0ZSBzaGFwZVxuXHRcdHRoaXMuX3VwZGF0ZUd1aWRlQ29sb3IodGhpcy5vcHRpb25zLmRyYXdFcnJvci5jb2xvcik7XG5cdFx0dGhpcy5fcG9seS5zZXRTdHlsZSh7Y29sb3I6IHRoaXMub3B0aW9ucy5kcmF3RXJyb3IuY29sb3J9KTtcblxuXHRcdC8vIEhpZGUgdGhlIGVycm9yIGFmdGVyIDIgc2Vjb25kc1xuXHRcdHRoaXMuX2NsZWFySGlkZUVycm9yVGltZW91dCgpO1xuXHRcdHRoaXMuX2hpZGVFcnJvclRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuVXRpbC5iaW5kKHRoaXMuX2hpZGVFcnJvclRvb2x0aXAsIHRoaXMpLCB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLnRpbWVvdXQpO1xuXHR9LFxuXG5cdF9oaWRlRXJyb3JUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZXJyb3JTaG93biA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY2xlYXJIaWRlRXJyb3JUaW1lb3V0KCk7XG5cblx0XHQvLyBSZXZlcnQgdG9vbHRpcFxuXHRcdHRoaXMuX3Rvb2x0aXBcblx0XHRcdC5yZW1vdmVFcnJvcigpXG5cdFx0XHQudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKTtcblxuXHRcdC8vIFJldmVydCBzaGFwZVxuXHRcdHRoaXMuX3VwZGF0ZUd1aWRlQ29sb3IodGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucy5jb2xvcik7XG5cdFx0dGhpcy5fcG9seS5zZXRTdHlsZSh7Y29sb3I6IHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMuY29sb3J9KTtcblx0fSxcblxuXHRfY2xlYXJIaWRlRXJyb3JUaW1lb3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2hpZGVFcnJvclRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9oaWRlRXJyb3JUaW1lb3V0KTtcblx0XHRcdHRoaXMuX2hpZGVFcnJvclRpbWVvdXQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvLyBkaXNhYmxlIG5ldyBtYXJrZXJzIHRlbXBvcmFyaWx5O1xuXHQvLyB0aGlzIGlzIHRvIHByZXZlbnQgZHVwbGljYXRlZCB0b3VjaC9jbGljayBldmVudHMgaW4gc29tZSBicm93c2Vyc1xuXHRfZGlzYWJsZU5ld01hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kaXNhYmxlTWFya2VycyA9IHRydWU7XG5cdH0sXG5cblx0Ly8gc2VlIF9kaXNhYmxlTmV3TWFya2Vyc1xuXHRfZW5hYmxlTmV3TWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZGlzYWJsZU1hcmtlcnMgPSBmYWxzZTtcblx0XHR9LmJpbmQodGhpcyksIDUwKTtcblx0fSxcblxuXHRfY2xlYW5VcFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fbWFya2Vyc1t0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDFdLm9mZignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9maXJlQ3JlYXRlZEV2ZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvbHkgPSBuZXcgdGhpcy5Qb2x5KHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpLCB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCBwb2x5KTtcblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkRyYXcuUG9seWdvblxuICogQGFrYSBEcmF3LlBvbHlnb25cbiAqIEBpbmhlcml0cyBMLkRyYXcuUG9seWxpbmVcbiAqL1xuTC5EcmF3LlBvbHlnb24gPSBMLkRyYXcuUG9seWxpbmUuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdwb2x5Z29uJ1xuXHR9LFxuXG5cdFBvbHk6IEwuUG9seWdvbixcblxuXHRvcHRpb25zOiB7XG5cdFx0c2hvd0FyZWE6IGZhbHNlLFxuXHRcdHNob3dMZW5ndGg6IGZhbHNlLFxuXHRcdHNoYXBlT3B0aW9uczoge1xuXHRcdFx0c3Ryb2tlOiB0cnVlLFxuXHRcdFx0Y29sb3I6ICcjMzM4OGZmJyxcblx0XHRcdHdlaWdodDogNCxcblx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRmaWxsQ29sb3I6IG51bGwsIC8vc2FtZSBhcyBjb2xvciBieSBkZWZhdWx0XG5cdFx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXHRcdFx0Y2xpY2thYmxlOiB0cnVlXG5cdFx0fSxcblx0XHQvLyBXaGV0aGVyIHRvIHVzZSB0aGUgbWV0cmljIG1lYXN1cmVtZW50IHN5c3RlbSAodHJ1dGh5KSBvciBub3QgKGZhbHN5KS5cblx0XHQvLyBBbHNvIGRlZmluZXMgdGhlIHVuaXRzIHRvIHVzZSBmb3IgdGhlIG1ldHJpYyBzeXN0ZW0gYXMgYW4gYXJyYXkgb2Zcblx0XHQvLyBzdHJpbmdzIChlLmcuIGBbJ2hhJywgJ20nXWApLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblx0XHRmZWV0OiB0cnVlLCAvLyBXaGVuIG5vdCBtZXRyaWMsIHRvIHVzZSBmZWV0IGluc3RlYWQgb2YgeWFyZHMgZm9yIGRpc3BsYXkuXG5cdFx0bmF1dGljOiBmYWxzZSwgLy8gV2hlbiBub3QgbWV0cmljLCBub3QgZmVldCB1c2UgbmF1dGljIG1pbGUgZm9yIGRpc3BsYXlcblx0XHQvLyBEZWZpbmVzIHRoZSBwcmVjaXNpb24gZm9yIGVhY2ggdHlwZSBvZiB1bml0IChlLmcuIHtrbTogMiwgZnQ6IDB9XG5cdFx0cHJlY2lzaW9uOiB7fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHRMLkRyYXcuUG9seWxpbmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkRyYXcuUG9seWdvbi5UWVBFO1xuXHR9LFxuXG5cdF91cGRhdGVGaW5pc2hIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcmtlckNvdW50ID0gdGhpcy5fbWFya2Vycy5sZW5ndGg7XG5cblx0XHQvLyBUaGUgZmlyc3QgbWFya2VyIHNob3VsZCBoYXZlIGEgY2xpY2sgaGFuZGxlciB0byBjbG9zZSB0aGUgcG9seWdvblxuXHRcdGlmIChtYXJrZXJDb3VudCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fbWFya2Vyc1swXS5vbignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGFuZCB1cGRhdGUgdGhlIGRvdWJsZSBjbGljayBoYW5kbGVyXG5cdFx0aWYgKG1hcmtlckNvdW50ID4gMikge1xuXHRcdFx0dGhpcy5fbWFya2Vyc1ttYXJrZXJDb3VudCAtIDFdLm9uKCdkYmxjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHRcdC8vIE9ubHkgbmVlZCB0byByZW1vdmUgaGFuZGxlciBpZiBoYXMgYmVlbiBhZGRlZCBiZWZvcmVcblx0XHRcdGlmIChtYXJrZXJDb3VudCA+IDMpIHtcblx0XHRcdFx0dGhpcy5fbWFya2Vyc1ttYXJrZXJDb3VudCAtIDJdLm9mZignZGJsY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUb29sdGlwVGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0ZXh0LCBzdWJ0ZXh0O1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0ZXh0ID0gTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5Z29uLnRvb2x0aXAuc3RhcnQ7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA8IDMpIHtcblx0XHRcdHRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlnb24udG9vbHRpcC5jb250O1xuXHRcdFx0c3VidGV4dCA9IHRoaXMuX2dldE1lYXN1cmVtZW50U3RyaW5nKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlnb24udG9vbHRpcC5lbmQ7XG5cdFx0XHRzdWJ0ZXh0ID0gdGhpcy5fZ2V0TWVhc3VyZW1lbnRTdHJpbmcoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGV4dDogdGV4dCxcblx0XHRcdHN1YnRleHQ6IHN1YnRleHRcblx0XHR9O1xuXHR9LFxuXG5cdF9nZXRNZWFzdXJlbWVudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhcmVhID0gdGhpcy5fYXJlYSxcblx0XHRcdG1lYXN1cmVtZW50U3RyaW5nID0gJyc7XG5cblxuXHRcdGlmICghYXJlYSAmJiAhdGhpcy5vcHRpb25zLnNob3dMZW5ndGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2hvd0xlbmd0aCkge1xuXHRcdFx0bWVhc3VyZW1lbnRTdHJpbmcgPSBMLkRyYXcuUG9seWxpbmUucHJvdG90eXBlLl9nZXRNZWFzdXJlbWVudFN0cmluZy5jYWxsKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhKSB7XG5cdFx0XHRtZWFzdXJlbWVudFN0cmluZyArPSAnPGJyPicgKyBMLkdlb21ldHJ5VXRpbC5yZWFkYWJsZUFyZWEoYXJlYSwgdGhpcy5vcHRpb25zLm1ldHJpYywgdGhpcy5vcHRpb25zLnByZWNpc2lvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lYXN1cmVtZW50U3RyaW5nO1xuXHR9LFxuXG5cdF9zaGFwZUlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFya2Vycy5sZW5ndGggPj0gMztcblx0fSxcblxuXHRfdmVydGV4Q2hhbmdlZDogZnVuY3Rpb24gKGxhdGxuZywgYWRkZWQpIHtcblx0XHR2YXIgbGF0TG5ncztcblxuXHRcdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgc2hvdyB0aGUgYXJlYVxuXHRcdGlmICghdGhpcy5vcHRpb25zLmFsbG93SW50ZXJzZWN0aW9uICYmIHRoaXMub3B0aW9ucy5zaG93QXJlYSkge1xuXHRcdFx0bGF0TG5ncyA9IHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpO1xuXG5cdFx0XHR0aGlzLl9hcmVhID0gTC5HZW9tZXRyeVV0aWwuZ2VvZGVzaWNBcmVhKGxhdExuZ3MpO1xuXHRcdH1cblxuXHRcdEwuRHJhdy5Qb2x5bGluZS5wcm90b3R5cGUuX3ZlcnRleENoYW5nZWQuY2FsbCh0aGlzLCBsYXRsbmcsIGFkZGVkKTtcblx0fSxcblxuXHRfY2xlYW5VcFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcmtlckNvdW50ID0gdGhpcy5fbWFya2Vycy5sZW5ndGg7XG5cblx0XHRpZiAobWFya2VyQ291bnQgPiAwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzWzBdLm9mZignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cblx0XHRcdGlmIChtYXJrZXJDb3VudCA+IDIpIHtcblx0XHRcdFx0dGhpcy5fbWFya2Vyc1ttYXJrZXJDb3VudCAtIDFdLm9mZignZGJsY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbkwuU2ltcGxlU2hhcGUgPSB7fTtcbi8qKlxuICogQGNsYXNzIEwuRHJhdy5TaW1wbGVTaGFwZVxuICogQGFrYSBEcmF3LlNpbXBsZVNoYXBlXG4gKiBAaW5oZXJpdHMgTC5EcmF3LkZlYXR1cmVcbiAqL1xuTC5EcmF3LlNpbXBsZVNoYXBlID0gTC5EcmF3LkZlYXR1cmUuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdHJlcGVhdE1vZGU6IGZhbHNlXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdHRoaXMuX2VuZExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMuc2ltcGxlc2hhcGUudG9vbHRpcC5lbmQ7XG5cblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXIuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLmFkZEhvb2tzLmNhbGwodGhpcyk7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwRHJhZ2dhYmxlID0gdGhpcy5fbWFwLmRyYWdnaW5nLmVuYWJsZWQoKTtcblxuXHRcdFx0aWYgKHRoaXMuX21hcERyYWdnYWJsZSkge1xuXHRcdFx0XHR0aGlzLl9tYXAuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1RPRE8gcmVmYWN0b3I6IG1vdmUgY3Vyc29yIHRvIHN0eWxlc1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdjcm9zc2hhaXInO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe3RleHQ6IHRoaXMuX2luaXRpYWxMYWJlbFRleHR9KTtcblxuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHRcdC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpXG5cdFx0XHRcdC5vbigndG91Y2hzdGFydCcsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0XHQub24oJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblxuXHRcdFx0Ly8gd2Ugc2hvdWxkIHByZXZlbnQgZGVmYXVsdCwgb3RoZXJ3aXNlIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZykgd2lsbCBmaXJlLFxuXHRcdFx0Ly8gYW5kIHRoYXQgd2lsbCBjYXVzZSBkb2N1bWVudC50b3VjaGVuZCB0byBmaXJlIGFuZCB3aWxsIHN0b3AgdGhlIGRyYXdpbmdcblx0XHRcdC8vIChjaXJjbGUsIHJlY3RhbmdsZSkgaW4gdG91Y2ggbW9kZS5cblx0XHRcdC8vICh1cGRhdGUpOiB3ZSBoYXZlIHRvIHNlbmQgcGFzc2l2ZSBub3cgdG8gcHJldmVudCBzY3JvbGwsIGJlY2F1c2UgYnkgZGVmYXVsdCBpdCBpcyB7cGFzc2l2ZTogdHJ1ZX0gbm93LCB3aGljaCBtZWFucyxcblx0XHRcdC8vIGhhbmRsZXIgY2FuJ3QgZXZlbnQucHJldmVudERlZmF1bHRcblx0XHRcdC8vIGNoZWNrIHRoZSBuZXdzIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTYvMDYvcGFzc2l2ZS1ldmVudC1saXN0ZW5lcnNcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0LCB7cGFzc2l2ZTogZmFsc2V9KTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmcm9tIHRoaXMgaGFuZGxlci5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUucmVtb3ZlSG9va3MuY2FsbCh0aGlzKTtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRpZiAodGhpcy5fbWFwRHJhZ2dhYmxlKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9UT0RPIHJlZmFjdG9yOiBtb3ZlIGN1cnNvciB0byBzdHlsZXNcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnJztcblxuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vZmYoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0XHQub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2hzdGFydCcsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0XHQub2ZmKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cblx0XHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwLCB0aGlzKTtcblxuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXG5cdFx0XHQvLyBJZiB0aGUgYm94IGVsZW1lbnQgZG9lc24ndCBleGlzdCB0aGV5IG11c3Qgbm90IGhhdmUgbW92ZWQgdGhlIG1vdXNlLCBzbyBkb24ndCBuZWVkIHRvIGRlc3Ryb3kvcmV0dXJuXG5cdFx0XHRpZiAodGhpcy5fc2hhcGUpIHtcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3NoYXBlKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3NoYXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9pc0RyYXdpbmcgPSBmYWxzZTtcblx0fSxcblxuXHRfZ2V0VG9vbHRpcFRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dGV4dDogdGhpcy5fZW5kTGFiZWxUZXh0XG5cdFx0fTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5faXNEcmF3aW5nID0gdHJ1ZTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IGUubGF0bG5nO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdFx0Lm9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcylcblx0XHRcdC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwLCB0aGlzKVxuXHRcdFx0LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZztcblxuXHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24obGF0bG5nKTtcblx0XHRpZiAodGhpcy5faXNEcmF3aW5nKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQodGhpcy5fZ2V0VG9vbHRpcFRleHQoKSk7XG5cdFx0XHR0aGlzLl9kcmF3U2hhcGUobGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9zaGFwZSkge1xuXHRcdFx0dGhpcy5fZmlyZUNyZWF0ZWRFdmVudCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdGlmICh0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSkge1xuXHRcdFx0dGhpcy5lbmFibGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5EcmF3LlJlY3RhbmdsZVxuICogQGFrYSBEcmF3LlJlY3RhbmdsZVxuICogQGluaGVyaXRzIEwuRHJhdy5TaW1wbGVTaGFwZVxuICovXG5MLkRyYXcuUmVjdGFuZ2xlID0gTC5EcmF3LlNpbXBsZVNoYXBlLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAncmVjdGFuZ2xlJ1xuXHR9LFxuXG5cdG9wdGlvbnM6IHtcblx0XHRzaGFwZU9wdGlvbnM6IHtcblx0XHRcdHN0cm9rZTogdHJ1ZSxcblx0XHRcdGNvbG9yOiAnIzMzODhmZicsXG5cdFx0XHR3ZWlnaHQ6IDQsXG5cdFx0XHRvcGFjaXR5OiAwLjUsXG5cdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0ZmlsbENvbG9yOiBudWxsLCAvL3NhbWUgYXMgY29sb3IgYnkgZGVmYXVsdFxuXHRcdFx0ZmlsbE9wYWNpdHk6IDAuMixcblx0XHRcdGNsaWNrYWJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0c2hvd0FyZWE6IHRydWUsIC8vV2hldGhlciB0byBzaG93IHRoZSBhcmVhIGluIHRoZSB0b29sdGlwXG5cdFx0bWV0cmljOiB0cnVlIC8vIFdoZXRoZXIgdG8gdXNlIHRoZSBtZXRyaWMgbWVhc3VyZW1lbnQgc3lzdGVtIG9yIGltcGVyaWFsXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdC8vIFNhdmUgdGhlIHR5cGUgc28gc3VwZXIgY2FuIGZpcmUsIG5lZWQgdG8gZG8gdGhpcyBhcyBjYW5ub3QgZG8gdGhpcy5UWVBFIDooXG5cdFx0dGhpcy50eXBlID0gTC5EcmF3LlJlY3RhbmdsZS5UWVBFO1xuXG5cdFx0dGhpcy5faW5pdGlhbExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMucmVjdGFuZ2xlLnRvb2x0aXAuc3RhcnQ7XG5cblx0XHRMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB2b2lkXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pc0N1cnJlbnRseVR3b0NsaWNrRHJhd2luZyA9IGZhbHNlO1xuXHRcdEwuRHJhdy5TaW1wbGVTaGFwZS5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9zaGFwZSAmJiAhdGhpcy5faXNDdXJyZW50bHlUd29DbGlja0RyYXdpbmcpIHtcblx0XHRcdHRoaXMuX2lzQ3VycmVudGx5VHdvQ2xpY2tEcmF3aW5nID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgY2xvc2luZyBjbGljayBpcyBvbiBtYXBcblx0XHRpZiAodGhpcy5faXNDdXJyZW50bHlUd29DbGlja0RyYXdpbmcgJiYgIV9oYXNBbmNlc3RvcihlLnRhcmdldCwgJ2xlYWZsZXQtcGFuZScpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fb25Nb3VzZVVwLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0X2RyYXdTaGFwZTogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdGlmICghdGhpcy5fc2hhcGUpIHtcblx0XHRcdHRoaXMuX3NoYXBlID0gbmV3IEwuUmVjdGFuZ2xlKG5ldyBMLkxhdExuZ0JvdW5kcyh0aGlzLl9zdGFydExhdExuZywgbGF0bG5nKSwgdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fc2hhcGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zaGFwZS5zZXRCb3VuZHMobmV3IEwuTGF0TG5nQm91bmRzKHRoaXMuX3N0YXJ0TGF0TG5nLCBsYXRsbmcpKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmVjdGFuZ2xlID0gbmV3IEwuUmVjdGFuZ2xlKHRoaXMuX3NoYXBlLmdldEJvdW5kcygpLCB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblx0XHRMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9maXJlQ3JlYXRlZEV2ZW50LmNhbGwodGhpcywgcmVjdGFuZ2xlKTtcblx0fSxcblxuXHRfZ2V0VG9vbHRpcFRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdG9vbHRpcFRleHQgPSBMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9nZXRUb29sdGlwVGV4dC5jYWxsKHRoaXMpLFxuXHRcdFx0c2hhcGUgPSB0aGlzLl9zaGFwZSxcblx0XHRcdHNob3dBcmVhID0gdGhpcy5vcHRpb25zLnNob3dBcmVhLFxuXHRcdFx0bGF0TG5ncywgYXJlYSwgc3VidGV4dDtcblxuXHRcdGlmIChzaGFwZSkge1xuXHRcdFx0bGF0TG5ncyA9IHRoaXMuX3NoYXBlLl9kZWZhdWx0U2hhcGUgPyB0aGlzLl9zaGFwZS5fZGVmYXVsdFNoYXBlKCkgOiB0aGlzLl9zaGFwZS5nZXRMYXRMbmdzKCk7XG5cdFx0XHRhcmVhID0gTC5HZW9tZXRyeVV0aWwuZ2VvZGVzaWNBcmVhKGxhdExuZ3MpO1xuXHRcdFx0c3VidGV4dCA9IHNob3dBcmVhID8gTC5HZW9tZXRyeVV0aWwucmVhZGFibGVBcmVhKGFyZWEsIHRoaXMub3B0aW9ucy5tZXRyaWMpIDogJyc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRleHQ6IHRvb2x0aXBUZXh0LnRleHQsXG5cdFx0XHRzdWJ0ZXh0OiBzdWJ0ZXh0XG5cdFx0fTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIF9oYXNBbmNlc3RvcihlbCwgY2xzKSB7XG5cdHdoaWxlICgoZWwgPSBlbC5wYXJlbnRFbGVtZW50KSAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNscykpIHtcblx0XHQ7XG5cdH1cblx0cmV0dXJuIGVsO1xufVxuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5EcmF3Lk1hcmtlclxuICogQGFrYSBEcmF3Lk1hcmtlclxuICogQGluaGVyaXRzIEwuRHJhdy5GZWF0dXJlXG4gKi9cbkwuRHJhdy5NYXJrZXIgPSBMLkRyYXcuRmVhdHVyZS5leHRlbmQoe1xuXHRzdGF0aWNzOiB7XG5cdFx0VFlQRTogJ21hcmtlcidcblx0fSxcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCksXG5cdFx0cmVwZWF0TW9kZTogZmFsc2UsXG5cdFx0ekluZGV4T2Zmc2V0OiAyMDAwIC8vIFRoaXMgc2hvdWxkIGJlID4gdGhhbiB0aGUgaGlnaGVzdCB6LWluZGV4IGFueSBtYXJrZXJzXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdC8vIFNhdmUgdGhlIHR5cGUgc28gc3VwZXIgY2FuIGZpcmUsIG5lZWQgdG8gZG8gdGhpcyBhcyBjYW5ub3QgZG8gdGhpcy5UWVBFIDooXG5cdFx0dGhpcy50eXBlID0gTC5EcmF3Lk1hcmtlci5UWVBFO1xuXG5cdFx0dGhpcy5faW5pdGlhbExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMubWFya2VyLnRvb2x0aXAuc3RhcnQ7XG5cblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXIuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLmFkZEhvb2tzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe3RleHQ6IHRoaXMuX2luaXRpYWxMYWJlbFRleHR9KTtcblxuXHRcdFx0Ly8gU2FtZSBtb3VzZU1hcmtlciBhcyBpbiBEcmF3LlBvbHlsaW5lXG5cdFx0XHRpZiAoIXRoaXMuX21vdXNlTWFya2VyKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlTWFya2VyID0gTC5tYXJrZXIodGhpcy5fbWFwLmdldENlbnRlcigpLCB7XG5cdFx0XHRcdFx0aWNvbjogTC5kaXZJY29uKHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtbW91c2UtbWFya2VyJyxcblx0XHRcdFx0XHRcdGljb25BbmNob3I6IFsyMCwgMjBdLFxuXHRcdFx0XHRcdFx0aWNvblNpemU6IFs0MCwgNDBdXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0b3BhY2l0eTogMCxcblx0XHRcdFx0XHR6SW5kZXhPZmZzZXQ6IHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlTWFya2VyXG5cdFx0XHRcdC5vbignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0XHQuYWRkVG8odGhpcy5fbWFwKTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fb25Ub3VjaCwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXIuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLnJlbW92ZUhvb2tzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0Lm9mZignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0XHQub2ZmKCdjbGljaycsIHRoaXMuX29uVG91Y2gsIHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMuX21hcmtlcikge1xuXHRcdFx0XHR0aGlzLl9tYXJrZXIub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0XHQucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2VyKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX21hcmtlcjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbW91c2VNYXJrZXIub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21vdXNlTWFya2VyKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tb3VzZU1hcmtlcjtcblxuXHRcdFx0dGhpcy5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nO1xuXG5cdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVQb3NpdGlvbihsYXRsbmcpO1xuXHRcdHRoaXMuX21vdXNlTWFya2VyLnNldExhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKCF0aGlzLl9tYXJrZXIpIHtcblx0XHRcdHRoaXMuX21hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihsYXRsbmcpO1xuXHRcdFx0Ly8gQmluZCB0byBib3RoIG1hcmtlciBhbmQgbWFwIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgdGhlIGNsaWNrIGV2ZW50LlxuXHRcdFx0dGhpcy5fbWFya2VyLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0XHQuYWRkTGF5ZXIodGhpcy5fbWFya2VyKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tb3VzZU1hcmtlci5nZXRMYXRMbmcoKTtcblx0XHRcdHRoaXMuX21hcmtlci5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHJldHVybiBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG5cdFx0XHRpY29uOiB0aGlzLm9wdGlvbnMuaWNvbixcblx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldFxuXHRcdH0pO1xuXHR9LFxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZmlyZUNyZWF0ZWRFdmVudCgpO1xuXG5cdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXBlYXRNb2RlKSB7XG5cdFx0XHR0aGlzLmVuYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Ub3VjaDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBjYWxsZWQgb24gY2xpY2sgJiB0YXAsIG9ubHkgcmVhbGx5IGRvZXMgYW55IHRoaW5nIG9uIHRhcFxuXHRcdHRoaXMuX29uTW91c2VNb3ZlKGUpOyAvLyBjcmVhdGVzICYgcGxhY2VzIG1hcmtlclxuXHRcdHRoaXMuX29uQ2xpY2soKTsgLy8gcGVybWFuZW50bHkgcGxhY2VzIG1hcmtlciAmIGVuZHMgaW50ZXJhY3Rpb25cblx0fSxcblxuXHRfZmlyZUNyZWF0ZWRFdmVudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIuVG91Y2godGhpcy5fbWFya2VyLmdldExhdExuZygpLCB7aWNvbjogdGhpcy5vcHRpb25zLmljb259KTtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRHJhdy5DaXJjbGVNYXJrZXJcbiAqIEBha2EgRHJhdy5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBMLkRyYXcuTWFya2VyXG4gKi9cbkwuRHJhdy5DaXJjbGVNYXJrZXIgPSBMLkRyYXcuTWFya2VyLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnY2lyY2xlbWFya2VyJ1xuXHR9LFxuXG5cdG9wdGlvbnM6IHtcblx0XHRzdHJva2U6IHRydWUsXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblx0XHR3ZWlnaHQ6IDQsXG5cdFx0b3BhY2l0eTogMC41LFxuXHRcdGZpbGw6IHRydWUsXG5cdFx0ZmlsbENvbG9yOiBudWxsLCAvL3NhbWUgYXMgY29sb3IgYnkgZGVmYXVsdFxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cdFx0Y2xpY2thYmxlOiB0cnVlLFxuXHRcdHpJbmRleE9mZnNldDogMjAwMCAvLyBUaGlzIHNob3VsZCBiZSA+IHRoYW4gdGhlIGhpZ2hlc3Qgei1pbmRleCBhbnkgbWFya2Vyc1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHQvLyBTYXZlIHRoZSB0eXBlIHNvIHN1cGVyIGNhbiBmaXJlLCBuZWVkIHRvIGRvIHRoaXMgYXMgY2Fubm90IGRvIHRoaXMuVFlQRSA6KFxuXHRcdHRoaXMudHlwZSA9IEwuRHJhdy5DaXJjbGVNYXJrZXIuVFlQRTtcblxuXHRcdHRoaXMuX2luaXRpYWxMYWJlbFRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLmNpcmNsZW1hcmtlci50b29sdGlwLnN0YXJ0O1xuXG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXHR9LFxuXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2lyY2xlTWFya2VyID0gbmV3IEwuQ2lyY2xlTWFya2VyKHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKSwgdGhpcy5vcHRpb25zKTtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCBjaXJjbGVNYXJrZXIpO1xuXHR9LFxuXG5cdF9jcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHRyZXR1cm4gbmV3IEwuQ2lyY2xlTWFya2VyKGxhdGxuZywgdGhpcy5vcHRpb25zKTtcblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkRyYXcuQ2lyY2xlXG4gKiBAYWthIERyYXcuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgTC5EcmF3LlNpbXBsZVNoYXBlXG4gKi9cbkwuRHJhdy5DaXJjbGUgPSBMLkRyYXcuU2ltcGxlU2hhcGUuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdjaXJjbGUnXG5cdH0sXG5cblx0b3B0aW9uczoge1xuXHRcdHNoYXBlT3B0aW9uczoge1xuXHRcdFx0c3Ryb2tlOiB0cnVlLFxuXHRcdFx0Y29sb3I6ICcjMzM4OGZmJyxcblx0XHRcdHdlaWdodDogNCxcblx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRmaWxsQ29sb3I6IG51bGwsIC8vc2FtZSBhcyBjb2xvciBieSBkZWZhdWx0XG5cdFx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXHRcdFx0Y2xpY2thYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRzaG93UmFkaXVzOiB0cnVlLFxuXHRcdG1ldHJpYzogdHJ1ZSwgLy8gV2hldGhlciB0byB1c2UgdGhlIG1ldHJpYyBtZWFzdXJlbWVudCBzeXN0ZW0gb3IgaW1wZXJpYWxcblx0XHRmZWV0OiB0cnVlLCAvLyBXaGVuIG5vdCBtZXRyaWMsIHVzZSBmZWV0IGluc3RlYWQgb2YgeWFyZHMgZm9yIGRpc3BsYXlcblx0XHRuYXV0aWM6IGZhbHNlIC8vIFdoZW4gbm90IG1ldHJpYywgbm90IGZlZXQgdXNlIG5hdXRpYyBtaWxlIGZvciBkaXNwbGF5XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdC8vIFNhdmUgdGhlIHR5cGUgc28gc3VwZXIgY2FuIGZpcmUsIG5lZWQgdG8gZG8gdGhpcyBhcyBjYW5ub3QgZG8gdGhpcy5UWVBFIDooXG5cdFx0dGhpcy50eXBlID0gTC5EcmF3LkNpcmNsZS5UWVBFO1xuXG5cdFx0dGhpcy5faW5pdGlhbExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMuY2lyY2xlLnRvb2x0aXAuc3RhcnQ7XG5cblx0XHRMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9kcmF3U2hhcGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHQvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJhc2VkIG9uIHRoZSB2ZXJzaW9uXG5cdFx0aWYgKEwuR2VvbWV0cnlVdGlsLmlzVmVyc2lvbjA3eCgpKSB7XG5cdFx0XHR2YXIgZGlzdGFuY2UgPSB0aGlzLl9zdGFydExhdExuZy5kaXN0YW5jZVRvKGxhdGxuZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkaXN0YW5jZSA9IHRoaXMuX21hcC5kaXN0YW5jZSh0aGlzLl9zdGFydExhdExuZywgbGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3NoYXBlKSB7XG5cdFx0XHR0aGlzLl9zaGFwZSA9IG5ldyBMLkNpcmNsZSh0aGlzLl9zdGFydExhdExuZywgZGlzdGFuY2UsIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX3NoYXBlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc2hhcGUuc2V0UmFkaXVzKGRpc3RhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2lyY2xlID0gbmV3IEwuQ2lyY2xlKHRoaXMuX3N0YXJ0TGF0TG5nLCB0aGlzLl9zaGFwZS5nZXRSYWRpdXMoKSwgdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyk7XG5cdFx0TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fZmlyZUNyZWF0ZWRFdmVudC5jYWxsKHRoaXMsIGNpcmNsZSk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZyxcblx0XHRcdHNob3dSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hvd1JhZGl1cyxcblx0XHRcdHVzZU1ldHJpYyA9IHRoaXMub3B0aW9ucy5tZXRyaWMsXG5cdFx0XHRyYWRpdXM7XG5cblx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGxhdGxuZyk7XG5cdFx0aWYgKHRoaXMuX2lzRHJhd2luZykge1xuXHRcdFx0dGhpcy5fZHJhd1NoYXBlKGxhdGxuZyk7XG5cblx0XHRcdC8vIEdldCB0aGUgbmV3IHJhZGl1cyAocm91bmRlZCB0byAxIGRwKVxuXHRcdFx0cmFkaXVzID0gdGhpcy5fc2hhcGUuZ2V0UmFkaXVzKCkudG9GaXhlZCgxKTtcblxuXHRcdFx0dmFyIHN1YnRleHQgPSAnJztcblx0XHRcdGlmIChzaG93UmFkaXVzKSB7XG5cdFx0XHRcdHN1YnRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLmNpcmNsZS5yYWRpdXMgKyAnOiAnICtcblx0XHRcdFx0XHRMLkdlb21ldHJ5VXRpbC5yZWFkYWJsZURpc3RhbmNlKHJhZGl1cywgdXNlTWV0cmljLCB0aGlzLm9wdGlvbnMuZmVldCwgdGhpcy5vcHRpb25zLm5hdXRpYyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe1xuXHRcdFx0XHR0ZXh0OiB0aGlzLl9lbmRMYWJlbFRleHQsXG5cdFx0XHRcdHN1YnRleHQ6IHN1YnRleHRcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG5cbi8qKlxuICogQGNsYXNzIEwuRWRpdC5NYXJrZXJcbiAqIEBha2EgRWRpdC5NYXJrZXJcbiAqL1xuTC5FZGl0Lk1hcmtlciA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHQvLyBAbWV0aG9kIGluaXRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkIGxpc3RlbmVyIGhvb2tzIHRvIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXI7XG5cblx0XHRtYXJrZXIuZHJhZ2dpbmcuZW5hYmxlKCk7XG5cdFx0bWFya2VyLm9uKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCBtYXJrZXIpO1xuXHRcdHRoaXMuX3RvZ2dsZU1hcmtlckhpZ2hsaWdodCgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyO1xuXG5cdFx0bWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcblx0XHRtYXJrZXIub2ZmKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCBtYXJrZXIpO1xuXHRcdHRoaXMuX3RvZ2dsZU1hcmtlckhpZ2hsaWdodCgpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS50YXJnZXQ7XG5cdFx0bGF5ZXIuZWRpdGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVE1PVkUsIHtsYXllcjogbGF5ZXJ9KTtcblx0fSxcblxuXHRfdG9nZ2xlTWFya2VySGlnaGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHQvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGxheWVyIGlzIGEgbWFya2VyIGJ1dCBkb2Vzbid0IGhhdmUgYW4gaWNvbi4gTWFya2Vyc1xuXHRcdC8vIHNob3VsZCB1c3VhbGx5IGhhdmUgaWNvbnMuIElmIHVzaW5nIExlYWZsZXQuZHJhdyB3aXRoIExlYWZsZXQubWFya2VyY2x1c3RlciB0aGVyZVxuXHRcdC8vIGlzIGEgY2hhbmNlIHRoYXQgYSBtYXJrZXIgZG9lc24ndC5cblx0XHRpZiAoIWljb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBUaGlzIGlzIHF1aXRlIG5hdWdodHksIGJ1dCBJIGRvbid0IHNlZSBhbm90aGVyIHdheSBvZiBkb2luZyBpdC4gKHNob3J0IG9mIHNldHRpbmcgYSBuZXcgaWNvbilcblx0XHRpY29uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cblx0XHRpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKGljb24sICdsZWFmbGV0LWVkaXQtbWFya2VyLXNlbGVjdGVkJykpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhpY29uLCAnbGVhZmxldC1lZGl0LW1hcmtlci1zZWxlY3RlZCcpO1xuXHRcdFx0Ly8gT2Zmc2V0IGFzIHRoZSBib3JkZXIgd2lsbCBtYWtlIHRoZSBpY29uIG1vdmUuXG5cdFx0XHR0aGlzLl9vZmZzZXRNYXJrZXIoaWNvbiwgLTQpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCAnbGVhZmxldC1lZGl0LW1hcmtlci1zZWxlY3RlZCcpO1xuXHRcdFx0Ly8gT2Zmc2V0IGFzIHRoZSBib3JkZXIgd2lsbCBtYWtlIHRoZSBpY29uIG1vdmUuXG5cdFx0XHR0aGlzLl9vZmZzZXRNYXJrZXIoaWNvbiwgNCk7XG5cdFx0fVxuXG5cdFx0aWNvbi5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cdH0sXG5cblx0X29mZnNldE1hcmtlcjogZnVuY3Rpb24gKGljb24sIG9mZnNldCkge1xuXHRcdHZhciBpY29uTWFyZ2luVG9wID0gcGFyc2VJbnQoaWNvbi5zdHlsZS5tYXJnaW5Ub3AsIDEwKSAtIG9mZnNldCxcblx0XHRcdGljb25NYXJnaW5MZWZ0ID0gcGFyc2VJbnQoaWNvbi5zdHlsZS5tYXJnaW5MZWZ0LCAxMCkgLSBvZmZzZXQ7XG5cblx0XHRpY29uLnN0eWxlLm1hcmdpblRvcCA9IGljb25NYXJnaW5Ub3AgKyAncHgnO1xuXHRcdGljb24uc3R5bGUubWFyZ2luTGVmdCA9IGljb25NYXJnaW5MZWZ0ICsgJ3B4Jztcblx0fVxufSk7XG5cbkwuTWFya2VyLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0aWYgKEwuRWRpdC5NYXJrZXIpIHtcblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0Lk1hcmtlcih0aGlzKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5lbmFibGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuTC5FZGl0ID0gTC5FZGl0IHx8IHt9O1xuXG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuUG9seWxpbmVcbiAqIEBha2EgTC5FZGl0LlBvbHlcbiAqIEBha2EgRWRpdC5Qb2x5XG4gKi9cbkwuRWRpdC5Qb2x5ID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChwb2x5KSB7XG5cblx0XHR0aGlzLmxhdGxuZ3MgPSBbcG9seS5fbGF0bG5nc107XG5cdFx0aWYgKHBvbHkuX2hvbGVzKSB7XG5cdFx0XHR0aGlzLmxhdGxuZ3MgPSB0aGlzLmxhdGxuZ3MuY29uY2F0KHBvbHkuX2hvbGVzKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2x5ID0gcG9seTtcblxuXHRcdHRoaXMuX3BvbHkub24oJ3JldmVydC1lZGl0ZWQnLCB0aGlzLl91cGRhdGVMYXRMbmdzLCB0aGlzKTtcblx0fSxcblxuXHQvLyBDb21wYXRpYmlsaXR5IG1ldGhvZCB0byBub3JtYWxpemUgUG9seSogb2JqZWN0c1xuXHQvLyBiZXR3ZWVuIDAuNy54IGFuZCAxLjArXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIUwuUG9seWxpbmUuX2ZsYXQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wb2x5Ll9sYXRsbmdzO1xuXHRcdH1cblx0XHRyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9wb2x5Ll9sYXRsbmdzKSA/IHRoaXMuX3BvbHkuX2xhdGxuZ3MgOiB0aGlzLl9wb2x5Ll9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdF9lYWNoVmVydGV4SGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl92ZXJ0aWNlc0hhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjYWxsYmFjayh0aGlzLl92ZXJ0aWNlc0hhbmRsZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXJcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0SGFuZGxlcnMoKTtcblx0XHR0aGlzLl9lYWNoVmVydGV4SGFuZGxlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlci5hZGRIb29rcygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9lYWNoVmVydGV4SGFuZGxlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlci5yZW1vdmVIb29rcygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdXBkYXRlTWFya2VycygpOiB2b2lkXG5cdC8vIEZpcmUgYW4gdXBkYXRlIGZvciBlYWNoIHZlcnRleCBoYW5kbGVyXG5cdHVwZGF0ZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9lYWNoVmVydGV4SGFuZGxlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlci51cGRhdGVNYXJrZXJzKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3ZlcnRpY2VzSGFuZGxlcnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGF0bG5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5fdmVydGljZXNIYW5kbGVycy5wdXNoKG5ldyBMLkVkaXQuUG9seVZlcnRpY2VzRWRpdCh0aGlzLl9wb2x5LCB0aGlzLmxhdGxuZ3NbaV0sIHRoaXMuX3BvbHkub3B0aW9ucy5wb2x5KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVMYXRMbmdzOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMubGF0bG5ncyA9IFtlLmxheWVyLl9sYXRsbmdzXTtcblx0XHRpZiAoZS5sYXllci5faG9sZXMpIHtcblx0XHRcdHRoaXMubGF0bG5ncyA9IHRoaXMubGF0bG5ncy5jb25jYXQoZS5sYXllci5faG9sZXMpO1xuXHRcdH1cblx0fVxuXG59KTtcblxuLyoqXG4gKiBAY2xhc3MgTC5FZGl0LlBvbHlWZXJ0aWNlc0VkaXRcbiAqIEBha2EgRWRpdC5Qb2x5VmVydGljZXNFZGl0XG4gKi9cbkwuRWRpdC5Qb2x5VmVydGljZXNFZGl0ID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRpY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24nXG5cdFx0fSksXG5cdFx0dG91Y2hJY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApLFxuXHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LXRvdWNoLWljb24nXG5cdFx0fSksXG5cdFx0ZHJhd0Vycm9yOiB7XG5cdFx0XHRjb2xvcjogJyNiMDBiMDAnLFxuXHRcdFx0dGltZW91dDogMTAwMFxuXHRcdH1cblxuXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAocG9seSwgbGF0bG5ncywgb3B0aW9ucykge1xuXHRcdC8vIGlmIHRvdWNoLCBzd2l0Y2ggdG8gdG91Y2ggaWNvblxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2gpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5pY29uID0gdGhpcy5vcHRpb25zLnRvdWNoSWNvbjtcblx0XHR9XG5cdFx0dGhpcy5fcG9seSA9IHBvbHk7XG5cblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRyYXdFcnJvcikge1xuXHRcdFx0b3B0aW9ucy5kcmF3RXJyb3IgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLCBvcHRpb25zLmRyYXdFcnJvcik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF0bG5ncyA9IGxhdGxuZ3M7XG5cblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQ29tcGF0aWJpbGl0eSBtZXRob2QgdG8gbm9ybWFsaXplIFBvbHkqIG9iamVjdHNcblx0Ly8gYmV0d2VlbiAwLjcueCBhbmQgMS4wK1xuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCFMLlBvbHlsaW5lLl9mbGF0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0XHR9XG5cdFx0cmV0dXJuIEwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkIGxpc3RlbmVyIGhvb2tzIHRvIHRoaXMgaGFuZGxlci5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9seSA9IHRoaXMuX3BvbHk7XG5cdFx0dmFyIHBhdGggPSBwb2x5Ll9wYXRoO1xuXG5cdFx0aWYgKCEocG9seSBpbnN0YW5jZW9mIEwuUG9seWdvbikpIHtcblx0XHRcdHBvbHkub3B0aW9ucy5maWxsID0gZmFsc2U7XG5cdFx0XHRpZiAocG9seS5vcHRpb25zLmVkaXRpbmcpIHtcblx0XHRcdFx0cG9seS5vcHRpb25zLmVkaXRpbmcuZmlsbCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAocG9seS5vcHRpb25zLmVkaXRpbmcgJiYgcG9seS5vcHRpb25zLmVkaXRpbmcuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGlmIChwb2x5Lm9wdGlvbnMub3JpZ2luYWwuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0cG9seS5vcHRpb25zLm9yaWdpbmFsLmNsYXNzTmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHBhdGgsIGNsYXNzTmFtZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9seS5vcHRpb25zLmVkaXRpbmcuY2xhc3NOYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhdGgsIGNsYXNzTmFtZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHBvbHkuc2V0U3R5bGUocG9seS5vcHRpb25zLmVkaXRpbmcpO1xuXG5cdFx0aWYgKHRoaXMuX3BvbHkuX21hcCkge1xuXG5cdFx0XHR0aGlzLl9tYXAgPSB0aGlzLl9wb2x5Ll9tYXA7IC8vIFNldCBtYXBcblxuXHRcdFx0aWYgKCF0aGlzLl9tYXJrZXJHcm91cCkge1xuXHRcdFx0XHR0aGlzLl9pbml0TWFya2VycygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcG9seS5fbWFwLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmcm9tIHRoaXMgaGFuZGxlci5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9seSA9IHRoaXMuX3BvbHk7XG5cdFx0dmFyIHBhdGggPSBwb2x5Ll9wYXRoO1xuXG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdGlmIChwb2x5Lm9wdGlvbnMuZWRpdGluZyAmJiBwb2x5Lm9wdGlvbnMuZWRpdGluZy5jbGFzc05hbWUpIHtcblx0XHRcdFx0cG9seS5vcHRpb25zLmVkaXRpbmcuY2xhc3NOYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHBhdGgsIGNsYXNzTmFtZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAocG9seS5vcHRpb25zLm9yaWdpbmFsLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdHBvbHkub3B0aW9ucy5vcmlnaW5hbC5jbGFzc05hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRcdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBjbGFzc05hbWUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cG9seS5zZXRTdHlsZShwb2x5Lm9wdGlvbnMub3JpZ2luYWwpO1xuXG5cdFx0aWYgKHBvbHkuX21hcCkge1xuXHRcdFx0cG9seS5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXJHcm91cDtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXJzO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZU1hcmtlcnMoKTogdm9pZFxuXHQvLyBDbGVhciBtYXJrZXJzIGFuZCB1cGRhdGUgdGhlaXIgbG9jYXRpb25cblx0dXBkYXRlTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcmtlckdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cdFx0dGhpcy5faW5pdE1hcmtlcnMoKTtcblx0fSxcblxuXHRfaW5pdE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcmtlckdyb3VwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJHcm91cCA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblx0XHR9XG5cdFx0dGhpcy5fbWFya2VycyA9IFtdO1xuXG5cdFx0dmFyIGxhdGxuZ3MgPSB0aGlzLl9kZWZhdWx0U2hhcGUoKSxcblx0XHRcdGksIGosIGxlbiwgbWFya2VyO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHRtYXJrZXIgPSB0aGlzLl9jcmVhdGVNYXJrZXIobGF0bG5nc1tpXSwgaSk7XG5cdFx0XHRtYXJrZXIub24oJ2NsaWNrJywgdGhpcy5fb25NYXJrZXJDbGljaywgdGhpcyk7XG5cdFx0XHRtYXJrZXIub24oJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXJrZXJzLnB1c2gobWFya2VyKTtcblx0XHR9XG5cblx0XHR2YXIgbWFya2VyTGVmdCwgbWFya2VyUmlnaHQ7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0aWYgKGkgPT09IDAgJiYgIShMLlBvbHlnb24gJiYgKHRoaXMuX3BvbHkgaW5zdGFuY2VvZiBMLlBvbHlnb24pKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bWFya2VyTGVmdCA9IHRoaXMuX21hcmtlcnNbal07XG5cdFx0XHRtYXJrZXJSaWdodCA9IHRoaXMuX21hcmtlcnNbaV07XG5cblx0XHRcdHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihtYXJrZXJMZWZ0LCBtYXJrZXJSaWdodCk7XG5cdFx0XHR0aGlzLl91cGRhdGVQcmV2TmV4dChtYXJrZXJMZWZ0LCBtYXJrZXJSaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIGluZGV4KSB7XG5cdFx0Ly8gRXh0ZW5kaW5nIEwuTWFya2VyIGluIFRvdWNoRXZlbnRzLmpzIHRvIGluY2x1ZGUgdG91Y2guXG5cdFx0dmFyIG1hcmtlciA9IG5ldyBMLk1hcmtlci5Ub3VjaChsYXRsbmcsIHtcblx0XHRcdGRyYWdnYWJsZTogdHJ1ZSxcblx0XHRcdGljb246IHRoaXMub3B0aW9ucy5pY29uLFxuXHRcdH0pO1xuXG5cdFx0bWFya2VyLl9vcmlnTGF0TG5nID0gbGF0bG5nO1xuXHRcdG1hcmtlci5faW5kZXggPSBpbmRleDtcblxuXHRcdG1hcmtlclxuXHRcdFx0Lm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbk1hcmtlckRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vbignZHJhZycsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcylcblx0XHRcdC5vbignZHJhZ2VuZCcsIHRoaXMuX2ZpcmVFZGl0LCB0aGlzKVxuXHRcdFx0Lm9uKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdC5vbigndG91Y2hlbmQnLCB0aGlzLl9maXJlRWRpdCwgdGhpcylcblx0XHRcdC5vbignTVNQb2ludGVyTW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdFx0Lm9uKCdNU1BvaW50ZXJVcCcsIHRoaXMuX2ZpcmVFZGl0LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcmtlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cblx0XHRyZXR1cm4gbWFya2VyO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvbHkuZmlyZSgnZWRpdHN0YXJ0Jyk7XG5cdH0sXG5cblx0X3NwbGljZUxhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdHZhciByZW1vdmVkID0gW10uc3BsaWNlLmFwcGx5KGxhdGxuZ3MsIGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fcG9seS5fY29udmVydExhdExuZ3MobGF0bG5ncywgdHJ1ZSk7XG5cdFx0dGhpcy5fcG9seS5yZWRyYXcoKTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRfcmVtb3ZlTWFya2VyOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dmFyIGkgPSBtYXJrZXIuX2luZGV4O1xuXG5cdFx0dGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIobWFya2VyKTtcblx0XHR0aGlzLl9tYXJrZXJzLnNwbGljZShpLCAxKTtcblx0XHR0aGlzLl9zcGxpY2VMYXRMbmdzKGksIDEpO1xuXHRcdHRoaXMuX3VwZGF0ZUluZGV4ZXMoaSwgLTEpO1xuXG5cdFx0bWFya2VyXG5cdFx0XHQub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9vbk1hcmtlckRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vZmYoJ2RyYWcnLCB0aGlzLl9vbk1hcmtlckRyYWcsIHRoaXMpXG5cdFx0XHQub2ZmKCdkcmFnZW5kJywgdGhpcy5fZmlyZUVkaXQsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1hcmtlckRyYWcsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaGVuZCcsIHRoaXMuX2ZpcmVFZGl0LCB0aGlzKVxuXHRcdFx0Lm9mZignY2xpY2snLCB0aGlzLl9vbk1hcmtlckNsaWNrLCB0aGlzKVxuXHRcdFx0Lm9mZignTVNQb2ludGVyTW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdFx0Lm9mZignTVNQb2ludGVyVXAnLCB0aGlzLl9maXJlRWRpdCwgdGhpcyk7XG5cdH0sXG5cblx0X2ZpcmVFZGl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9seS5lZGl0ZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3BvbHkuZmlyZSgnZWRpdCcpO1xuXHRcdHRoaXMuX3BvbHkuX21hcC5maXJlKEwuRHJhdy5FdmVudC5FRElUVkVSVEVYLCB7bGF5ZXJzOiB0aGlzLl9tYXJrZXJHcm91cCwgcG9seTogdGhpcy5fcG9seX0pO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IGUudGFyZ2V0O1xuXHRcdHZhciBwb2x5ID0gdGhpcy5fcG9seTtcblxuXHRcdHZhciBvbGRPcmlnTGF0TG5nID0gTC5MYXRMbmdVdGlsLmNsb25lTGF0TG5nKG1hcmtlci5fb3JpZ0xhdExuZyk7XG5cdFx0TC5leHRlbmQobWFya2VyLl9vcmlnTGF0TG5nLCBtYXJrZXIuX2xhdGxuZyk7XG5cdFx0aWYgKHBvbHkub3B0aW9ucy5wb2x5KSB7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IHBvbHkuX21hcC5fZWRpdFRvb2x0aXA7IC8vIEFjY2VzcyB0aGUgdG9vbHRpcFxuXG5cdFx0XHQvLyBJZiB3ZSBkb24ndCBhbGxvdyBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgcG9seWdvbiBpbnRlcnNlY3RzXG5cdFx0XHRpZiAoIXBvbHkub3B0aW9ucy5wb2x5LmFsbG93SW50ZXJzZWN0aW9uICYmIHBvbHkuaW50ZXJzZWN0cygpKSB7XG5cdFx0XHRcdEwuZXh0ZW5kKG1hcmtlci5fb3JpZ0xhdExuZywgb2xkT3JpZ0xhdExuZyk7XG5cdFx0XHRcdG1hcmtlci5zZXRMYXRMbmcob2xkT3JpZ0xhdExuZyk7XG5cdFx0XHRcdHZhciBvcmlnaW5hbENvbG9yID0gcG9seS5vcHRpb25zLmNvbG9yO1xuXHRcdFx0XHRwb2x5LnNldFN0eWxlKHtjb2xvcjogdGhpcy5vcHRpb25zLmRyYXdFcnJvci5jb2xvcn0pO1xuXHRcdFx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0XHRcdHRvb2x0aXAudXBkYXRlQ29udGVudCh7XG5cdFx0XHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlsaW5lLmVycm9yXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCBldmVyeXRoaW5nIGJhY2sgdG8gbm9ybWFsIGFmdGVyIGEgc2Vjb25kXG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHBvbHkuc2V0U3R5bGUoe2NvbG9yOiBvcmlnaW5hbENvbG9yfSk7XG5cdFx0XHRcdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdFx0XHRcdHRvb2x0aXAudXBkYXRlQ29udGVudCh7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnRleHQsXG5cdFx0XHRcdFx0XHRcdHN1YnRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnN1YnRleHRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgMTAwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlTGVmdCkge1xuXHRcdFx0bWFya2VyLl9taWRkbGVMZWZ0LnNldExhdExuZyh0aGlzLl9nZXRNaWRkbGVMYXRMbmcobWFya2VyLl9wcmV2LCBtYXJrZXIpKTtcblx0XHR9XG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlUmlnaHQpIHtcblx0XHRcdG1hcmtlci5fbWlkZGxlUmlnaHQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIsIG1hcmtlci5fbmV4dCkpO1xuXHRcdH1cblxuXHRcdC8vcmVmcmVzaCB0aGUgYm91bmRzIHdoZW4gZHJhZ2luZ1xuXHRcdHRoaXMuX3BvbHkuX2JvdW5kcy5fc291dGhXZXN0ID0gTC5sYXRMbmcoSW5maW5pdHksIEluZmluaXR5KTtcblx0XHR0aGlzLl9wb2x5Ll9ib3VuZHMuX25vcnRoRWFzdCA9IEwubGF0TG5nKC1JbmZpbml0eSwgLUluZmluaXR5KTtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpO1xuXHRcdHRoaXMuX3BvbHkuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MsIHRydWUpO1xuXHRcdHRoaXMuX3BvbHkucmVkcmF3KCk7XG5cdFx0dGhpcy5fcG9seS5maXJlKCdlZGl0ZHJhZycpO1xuXHR9LFxuXG5cdF9vbk1hcmtlckNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0dmFyIG1pblBvaW50cyA9IEwuUG9seWdvbiAmJiAodGhpcy5fcG9seSBpbnN0YW5jZW9mIEwuUG9seWdvbikgPyA0IDogMyxcblx0XHRcdG1hcmtlciA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gSWYgcmVtb3ZpbmcgdGhpcyBwb2ludCB3b3VsZCBjcmVhdGUgYW4gaW52YWxpZCBwb2x5bGluZS9wb2x5Z29uIGRvbid0IHJlbW92ZVxuXHRcdGlmICh0aGlzLl9kZWZhdWx0U2hhcGUoKS5sZW5ndGggPCBtaW5Qb2ludHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyByZW1vdmUgdGhlIG1hcmtlclxuXHRcdHRoaXMuX3JlbW92ZU1hcmtlcihtYXJrZXIpO1xuXG5cdFx0Ly8gdXBkYXRlIHByZXYvbmV4dCBsaW5rcyBvZiBhZGphY2VudCBtYXJrZXJzXG5cdFx0dGhpcy5fdXBkYXRlUHJldk5leHQobWFya2VyLl9wcmV2LCBtYXJrZXIuX25leHQpO1xuXG5cdFx0Ly8gcmVtb3ZlIGdob3N0IG1hcmtlcnMgbmVhciB0aGUgcmVtb3ZlZCBtYXJrZXJcblx0XHRpZiAobWFya2VyLl9taWRkbGVMZWZ0KSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihtYXJrZXIuX21pZGRsZUxlZnQpO1xuXHRcdH1cblx0XHRpZiAobWFya2VyLl9taWRkbGVSaWdodCkge1xuXHRcdFx0dGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIobWFya2VyLl9taWRkbGVSaWdodCk7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIGEgZ2hvc3QgbWFya2VyIGluIHBsYWNlIG9mIHRoZSByZW1vdmVkIG9uZVxuXHRcdGlmIChtYXJrZXIuX3ByZXYgJiYgbWFya2VyLl9uZXh0KSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobWFya2VyLl9wcmV2LCBtYXJrZXIuX25leHQpO1xuXG5cdFx0fSBlbHNlIGlmICghbWFya2VyLl9wcmV2KSB7XG5cdFx0XHRtYXJrZXIuX25leHQuX21pZGRsZUxlZnQgPSBudWxsO1xuXG5cdFx0fSBlbHNlIGlmICghbWFya2VyLl9uZXh0KSB7XG5cdFx0XHRtYXJrZXIuX3ByZXYuX21pZGRsZVJpZ2h0ID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlzLl9maXJlRWRpdCgpO1xuXHR9LFxuXG5cdF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblx0XHR2YXIgcG9seSA9IHRoaXMuX3BvbHk7XG5cdFx0dGhpcy5fcG9seS5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50Lk1BUktFUkNPTlRFWFQsIHttYXJrZXI6IG1hcmtlciwgbGF5ZXJzOiB0aGlzLl9tYXJrZXJHcm91cCwgcG9seTogdGhpcy5fcG9seX0pO1xuXHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0pLFxuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KSxcblx0XHRcdG1hcmtlciA9IGUudGFyZ2V0O1xuXG5cdFx0TC5leHRlbmQobWFya2VyLl9vcmlnTGF0TG5nLCBsYXRsbmcpO1xuXG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlTGVmdCkge1xuXHRcdFx0bWFya2VyLl9taWRkbGVMZWZ0LnNldExhdExuZyh0aGlzLl9nZXRNaWRkbGVMYXRMbmcobWFya2VyLl9wcmV2LCBtYXJrZXIpKTtcblx0XHR9XG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlUmlnaHQpIHtcblx0XHRcdG1hcmtlci5fbWlkZGxlUmlnaHQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIsIG1hcmtlci5fbmV4dCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvbHkucmVkcmF3KCk7XG5cdFx0dGhpcy51cGRhdGVNYXJrZXJzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUluZGV4ZXM6IGZ1bmN0aW9uIChpbmRleCwgZGVsdGEpIHtcblx0XHR0aGlzLl9tYXJrZXJHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdFx0aWYgKG1hcmtlci5faW5kZXggPiBpbmRleCkge1xuXHRcdFx0XHRtYXJrZXIuX2luZGV4ICs9IGRlbHRhO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9jcmVhdGVNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChtYXJrZXIxLCBtYXJrZXIyKSB7XG5cdFx0dmFyIGxhdGxuZyA9IHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIxLCBtYXJrZXIyKSxcblx0XHRcdG1hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihsYXRsbmcpLFxuXHRcdFx0b25DbGljayxcblx0XHRcdG9uRHJhZ1N0YXJ0LFxuXHRcdFx0b25EcmFnRW5kO1xuXG5cdFx0bWFya2VyLnNldE9wYWNpdHkoMC42KTtcblxuXHRcdG1hcmtlcjEuX21pZGRsZVJpZ2h0ID0gbWFya2VyMi5fbWlkZGxlTGVmdCA9IG1hcmtlcjtcblxuXHRcdG9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0bWFya2VyLm9mZigndG91Y2htb3ZlJywgb25EcmFnU3RhcnQsIHRoaXMpO1xuXHRcdFx0dmFyIGkgPSBtYXJrZXIyLl9pbmRleDtcblxuXHRcdFx0bWFya2VyLl9pbmRleCA9IGk7XG5cblx0XHRcdG1hcmtlclxuXHRcdFx0XHQub2ZmKCdjbGljaycsIG9uQ2xpY2ssIHRoaXMpXG5cdFx0XHRcdC5vbignY2xpY2snLCB0aGlzLl9vbk1hcmtlckNsaWNrLCB0aGlzKTtcblxuXHRcdFx0bGF0bG5nLmxhdCA9IG1hcmtlci5nZXRMYXRMbmcoKS5sYXQ7XG5cdFx0XHRsYXRsbmcubG5nID0gbWFya2VyLmdldExhdExuZygpLmxuZztcblx0XHRcdHRoaXMuX3NwbGljZUxhdExuZ3MoaSwgMCwgbGF0bG5nKTtcblx0XHRcdHRoaXMuX21hcmtlcnMuc3BsaWNlKGksIDAsIG1hcmtlcik7XG5cblx0XHRcdG1hcmtlci5zZXRPcGFjaXR5KDEpO1xuXG5cdFx0XHR0aGlzLl91cGRhdGVJbmRleGVzKGksIDEpO1xuXHRcdFx0bWFya2VyMi5faW5kZXgrKztcblx0XHRcdHRoaXMuX3VwZGF0ZVByZXZOZXh0KG1hcmtlcjEsIG1hcmtlcik7XG5cdFx0XHR0aGlzLl91cGRhdGVQcmV2TmV4dChtYXJrZXIsIG1hcmtlcjIpO1xuXG5cdFx0XHR0aGlzLl9wb2x5LmZpcmUoJ2VkaXRzdGFydCcpO1xuXHRcdH07XG5cblx0XHRvbkRyYWdFbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRtYXJrZXIub2ZmKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCwgdGhpcyk7XG5cdFx0XHRtYXJrZXIub2ZmKCdkcmFnZW5kJywgb25EcmFnRW5kLCB0aGlzKTtcblx0XHRcdG1hcmtlci5vZmYoJ3RvdWNobW92ZScsIG9uRHJhZ1N0YXJ0LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fY3JlYXRlTWlkZGxlTWFya2VyKG1hcmtlcjEsIG1hcmtlcik7XG5cdFx0XHR0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobWFya2VyLCBtYXJrZXIyKTtcblx0XHR9O1xuXG5cdFx0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdG9uRHJhZ1N0YXJ0LmNhbGwodGhpcyk7XG5cdFx0XHRvbkRyYWdFbmQuY2FsbCh0aGlzKTtcblx0XHRcdHRoaXMuX2ZpcmVFZGl0KCk7XG5cdFx0fTtcblxuXHRcdG1hcmtlclxuXHRcdFx0Lm9uKCdjbGljaycsIG9uQ2xpY2ssIHRoaXMpXG5cdFx0XHQub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9uKCdkcmFnZW5kJywgb25EcmFnRW5kLCB0aGlzKVxuXHRcdFx0Lm9uKCd0b3VjaG1vdmUnLCBvbkRyYWdTdGFydCwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5hZGRMYXllcihtYXJrZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQcmV2TmV4dDogZnVuY3Rpb24gKG1hcmtlcjEsIG1hcmtlcjIpIHtcblx0XHRpZiAobWFya2VyMSkge1xuXHRcdFx0bWFya2VyMS5fbmV4dCA9IG1hcmtlcjI7XG5cdFx0fVxuXHRcdGlmIChtYXJrZXIyKSB7XG5cdFx0XHRtYXJrZXIyLl9wcmV2ID0gbWFya2VyMTtcblx0XHR9XG5cdH0sXG5cblx0X2dldE1pZGRsZUxhdExuZzogZnVuY3Rpb24gKG1hcmtlcjEsIG1hcmtlcjIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fcG9seS5fbWFwLFxuXHRcdFx0cDEgPSBtYXAucHJvamVjdChtYXJrZXIxLmdldExhdExuZygpKSxcblx0XHRcdHAyID0gbWFwLnByb2plY3QobWFya2VyMi5nZXRMYXRMbmcoKSk7XG5cblx0XHRyZXR1cm4gbWFwLnVucHJvamVjdChwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHR9XG59KTtcblxuTC5Qb2x5bGluZS5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGhhbmRsZXIgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4gVGhpcyBpcyB0byBzdXBwb3J0IHZlcnNpb25zIG9mIExlYWZsZXQgdGhhdCBzdGlsbCBoYXZlIEwuSGFuZGxlci5Qb2x5RWRpdFxuXHRpZiAodGhpcy5lZGl0aW5nKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKEwuRWRpdC5Qb2x5KSB7XG5cblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0LlBvbHkodGhpcyk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcuZW5hYmxlKCk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5vbignYWRkJywgZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmVkaXRpbmcgJiYgdGhpcy5lZGl0aW5nLmVuYWJsZWQoKSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLmFkZEhvb2tzKCk7XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZWRpdGluZyAmJiB0aGlzLmVkaXRpbmcuZW5hYmxlZCgpKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcucmVtb3ZlSG9va3MoKTtcblx0XHR9XG5cdH0pO1xufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuU2ltcGxlU2hhcGVcbiAqIEBha2EgRWRpdC5TaW1wbGVTaGFwZVxuICovXG5MLkVkaXQuU2ltcGxlU2hhcGUgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdG1vdmVJY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC1lZGl0LW1vdmUnXG5cdFx0fSksXG5cdFx0cmVzaXplSWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOCksXG5cdFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtZWRpdGluZy1pY29uIGxlYWZsZXQtZWRpdC1yZXNpemUnXG5cdFx0fSksXG5cdFx0dG91Y2hNb3ZlSWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoMjAsIDIwKSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC1lZGl0LW1vdmUgbGVhZmxldC10b3VjaC1pY29uJ1xuXHRcdH0pLFxuXHRcdHRvdWNoUmVzaXplSWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoMjAsIDIwKSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC1lZGl0LXJlc2l6ZSBsZWFmbGV0LXRvdWNoLWljb24nXG5cdFx0fSksXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoc2hhcGUsIG9wdGlvbnMpIHtcblx0XHQvLyBpZiB0b3VjaCwgc3dpdGNoIHRvIHRvdWNoIGljb25cblx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMubW92ZUljb24gPSB0aGlzLm9wdGlvbnMudG91Y2hNb3ZlSWNvbjtcblx0XHRcdHRoaXMub3B0aW9ucy5yZXNpemVJY29uID0gdGhpcy5vcHRpb25zLnRvdWNoUmVzaXplSWNvbjtcblx0XHR9XG5cblx0XHR0aGlzLl9zaGFwZSA9IHNoYXBlO1xuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKTogdm9pZFxuXHQvLyBBZGQgbGlzdGVuZXIgaG9va3MgdG8gdGhpcyBoYW5kbGVyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNoYXBlID0gdGhpcy5fc2hhcGU7XG5cdFx0aWYgKHRoaXMuX3NoYXBlLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcCA9IHRoaXMuX3NoYXBlLl9tYXA7XG5cdFx0XHRzaGFwZS5zZXRTdHlsZShzaGFwZS5vcHRpb25zLmVkaXRpbmcpO1xuXG5cdFx0XHRpZiAoc2hhcGUuX21hcCkge1xuXHRcdFx0XHR0aGlzLl9tYXAgPSBzaGFwZS5fbWFwO1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcmtlckdyb3VwKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdE1hcmtlcnMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKCk6IHZvaWRcblx0Ly8gUmVtb3ZlIGxpc3RlbmVyIGhvb2tzIGZyb20gdGhpcyBoYW5kbGVyXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNoYXBlID0gdGhpcy5fc2hhcGU7XG5cblx0XHRzaGFwZS5zZXRTdHlsZShzaGFwZS5vcHRpb25zLm9yaWdpbmFsKTtcblxuXHRcdGlmIChzaGFwZS5fbWFwKSB7XG5cdFx0XHR0aGlzLl91bmJpbmRNYXJrZXIodGhpcy5fbW92ZU1hcmtlcik7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fcmVzaXplTWFya2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fdW5iaW5kTWFya2VyKHRoaXMuX3Jlc2l6ZU1hcmtlcnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVzaXplTWFya2VycyA9IG51bGw7XG5cblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9tYXJrZXJHcm91cCk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbWFya2VyR3JvdXA7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZU1hcmtlcnMoKTogdm9pZFxuXHQvLyBSZW1vdmUgdGhlIGVkaXQgbWFya2VycyBmcm9tIHRoaXMgbGF5ZXJcblx0dXBkYXRlTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcmtlckdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cdFx0dGhpcy5faW5pdE1hcmtlcnMoKTtcblx0fSxcblxuXHRfaW5pdE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcmtlckdyb3VwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJHcm91cCA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgY2VudGVyIG1hcmtlclxuXHRcdHRoaXMuX2NyZWF0ZU1vdmVNYXJrZXIoKTtcblxuXHRcdC8vIENyZWF0ZSBlZGdlIG1hcmtlclxuXHRcdHRoaXMuX2NyZWF0ZVJlc2l6ZU1hcmtlcigpO1xuXHR9LFxuXG5cdF9jcmVhdGVNb3ZlTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fSxcblxuXHRfY3JlYXRlUmVzaXplTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fSxcblxuXHRfY3JlYXRlTWFya2VyOiBmdW5jdGlvbiAobGF0bG5nLCBpY29uKSB7XG5cdFx0Ly8gRXh0ZW5kaW5nIEwuTWFya2VyIGluIFRvdWNoRXZlbnRzLmpzIHRvIGluY2x1ZGUgdG91Y2guXG5cdFx0dmFyIG1hcmtlciA9IG5ldyBMLk1hcmtlci5Ub3VjaChsYXRsbmcsIHtcblx0XHRcdGRyYWdnYWJsZTogdHJ1ZSxcblx0XHRcdGljb246IGljb24sXG5cdFx0XHR6SW5kZXhPZmZzZXQ6IDEwXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9iaW5kTWFya2VyKG1hcmtlcik7XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5hZGRMYXllcihtYXJrZXIpO1xuXG5cdFx0cmV0dXJuIG1hcmtlcjtcblx0fSxcblxuXHRfYmluZE1hcmtlcjogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdG1hcmtlclxuXHRcdFx0Lm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbk1hcmtlckRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vbignZHJhZycsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcylcblx0XHRcdC5vbignZHJhZ2VuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcylcblx0XHRcdC5vbigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcylcblx0XHRcdC5vbigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHQub24oJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdC5vbigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKVxuXHRcdFx0Lm9uKCdNU1BvaW50ZXJVcCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXHR9LFxuXG5cdF91bmJpbmRNYXJrZXI6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHRtYXJrZXJcblx0XHRcdC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX29uTWFya2VyRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9mZignZHJhZycsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcylcblx0XHRcdC5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9vbk1hcmtlckRyYWdFbmQsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9mZigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHQub2ZmKCdNU1BvaW50ZXJNb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpXG5cdFx0XHQub2ZmKCdNU1BvaW50ZXJVcCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gZS50YXJnZXQ7XG5cdFx0bWFya2VyLnNldE9wYWNpdHkoMCk7XG5cblx0XHR0aGlzLl9zaGFwZS5maXJlKCdlZGl0c3RhcnQnKTtcblx0fSxcblxuXHRfZmlyZUVkaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9zaGFwZS5lZGl0ZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3NoYXBlLmZpcmUoJ2VkaXQnKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldCxcblx0XHRcdGxhdGxuZyA9IG1hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdGlmIChtYXJrZXIgPT09IHRoaXMuX21vdmVNYXJrZXIpIHtcblx0XHRcdHRoaXMuX21vdmUobGF0bG5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVzaXplKGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2hhcGUucmVkcmF3KCk7XG5cdFx0dGhpcy5fc2hhcGUuZmlyZSgnZWRpdGRyYWcnKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblx0XHRtYXJrZXIuc2V0T3BhY2l0eSgxKTtcblxuXHRcdHRoaXMuX2ZpcmVFZGl0KCk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRMLkVkaXQuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9vbk1hcmtlckRyYWdTdGFydC5jYWxsKHRoaXMsIGUpO1xuXG5cdFx0aWYgKHR5cGVvZih0aGlzLl9nZXRDb3JuZXJzKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGUgb3Bwb3NpdGUgcG9pbnRcblx0XHRcdHZhciBjb3JuZXJzID0gdGhpcy5fZ2V0Q29ybmVycygpLFxuXHRcdFx0XHRtYXJrZXIgPSBlLnRhcmdldCxcblx0XHRcdFx0Y3VycmVudENvcm5lckluZGV4ID0gbWFya2VyLl9jb3JuZXJJbmRleDtcblxuXHRcdFx0bWFya2VyLnNldE9wYWNpdHkoMCk7XG5cblx0XHRcdC8vIENvcHllZCBmcm9tIEVkaXQuUmVjdGFuZ2xlLmpzIGxpbmUgMjMgX29uTWFya2VyRHJhZ1N0YXJ0KClcblx0XHRcdC8vIExhdGxuZyBpcyBudWxsIG90aGVyd2lzZS5cblx0XHRcdHRoaXMuX29wcG9zaXRlQ29ybmVyID0gY29ybmVyc1soY3VycmVudENvcm5lckluZGV4ICsgMikgJSA0XTtcblx0XHRcdHRoaXMuX3RvZ2dsZUNvcm5lck1hcmtlcnMoMCwgY3VycmVudENvcm5lckluZGV4KTtcblx0XHR9XG5cblx0XHR0aGlzLl9zaGFwZS5maXJlKCdlZGl0c3RhcnQnKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSksXG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpLFxuXHRcdFx0bWFya2VyID0gZS50YXJnZXQ7XG5cblx0XHRpZiAobWFya2VyID09PSB0aGlzLl9tb3ZlTWFya2VyKSB7XG5cdFx0XHR0aGlzLl9tb3ZlKGxhdGxuZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Jlc2l6ZShsYXRsbmcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYXBlLnJlZHJhdygpO1xuXG5cdFx0Ly8gcHJldmVudCB0b3VjaGNhbmNlbCBpbiBJT1Ncblx0XHQvLyBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblx0XHRtYXJrZXIuc2V0T3BhY2l0eSgxKTtcblx0XHR0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcblx0XHR0aGlzLl9maXJlRWRpdCgpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fVxufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuUmVjdGFuZ2xlXG4gKiBAYWthIEVkaXQuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgTC5FZGl0LlNpbXBsZVNoYXBlXG4gKi9cbkwuRWRpdC5SZWN0YW5nbGUgPSBMLkVkaXQuU2ltcGxlU2hhcGUuZXh0ZW5kKHtcblx0X2NyZWF0ZU1vdmVNYXJrZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fc2hhcGUuZ2V0Qm91bmRzKCksXG5cdFx0XHRjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cblx0XHR0aGlzLl9tb3ZlTWFya2VyID0gdGhpcy5fY3JlYXRlTWFya2VyKGNlbnRlciwgdGhpcy5vcHRpb25zLm1vdmVJY29uKTtcblx0fSxcblxuXHRfY3JlYXRlUmVzaXplTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9nZXRDb3JuZXJzKCk7XG5cblx0XHR0aGlzLl9yZXNpemVNYXJrZXJzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvcm5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9yZXNpemVNYXJrZXJzLnB1c2godGhpcy5fY3JlYXRlTWFya2VyKGNvcm5lcnNbaV0sIHRoaXMub3B0aW9ucy5yZXNpemVJY29uKSk7XG5cdFx0XHQvLyBNb25rZXkgaW4gdGhlIGNvcm5lciBpbmRleCBhcyB3ZSB3aWxsIG5lZWQgdG8ga25vdyB0aGlzIGZvciBkcmFnZ2luZ1xuXHRcdFx0dGhpcy5fcmVzaXplTWFya2Vyc1tpXS5fY29ybmVySW5kZXggPSBpO1xuXHRcdH1cblx0fSxcblxuXHRfb25NYXJrZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0TC5FZGl0LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fb25NYXJrZXJEcmFnU3RhcnQuY2FsbCh0aGlzLCBlKTtcblxuXHRcdC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIG9wcG9zaXRlIHBvaW50XG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9nZXRDb3JuZXJzKCksXG5cdFx0XHRtYXJrZXIgPSBlLnRhcmdldCxcblx0XHRcdGN1cnJlbnRDb3JuZXJJbmRleCA9IG1hcmtlci5fY29ybmVySW5kZXg7XG5cblx0XHR0aGlzLl9vcHBvc2l0ZUNvcm5lciA9IGNvcm5lcnNbKGN1cnJlbnRDb3JuZXJJbmRleCArIDIpICUgNF07XG5cblx0XHR0aGlzLl90b2dnbGVDb3JuZXJNYXJrZXJzKDAsIGN1cnJlbnRDb3JuZXJJbmRleCk7XG5cdH0sXG5cblx0X29uTWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gZS50YXJnZXQsXG5cdFx0XHRib3VuZHMsIGNlbnRlcjtcblxuXHRcdC8vIFJlc2V0IG1vdmUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBjZW50ZXJcblx0XHRpZiAobWFya2VyID09PSB0aGlzLl9tb3ZlTWFya2VyKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9zaGFwZS5nZXRCb3VuZHMoKTtcblx0XHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblxuXHRcdFx0bWFya2VyLnNldExhdExuZyhjZW50ZXIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RvZ2dsZUNvcm5lck1hcmtlcnMoMSk7XG5cblx0XHR0aGlzLl9yZXBvc2l0aW9uQ29ybmVyTWFya2VycygpO1xuXG5cdFx0TC5FZGl0LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fb25NYXJrZXJEcmFnRW5kLmNhbGwodGhpcywgZSk7XG5cdH0sXG5cblx0X21vdmU6IGZ1bmN0aW9uIChuZXdDZW50ZXIpIHtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX3NoYXBlLl9kZWZhdWx0U2hhcGUgPyB0aGlzLl9zaGFwZS5fZGVmYXVsdFNoYXBlKCkgOiB0aGlzLl9zaGFwZS5nZXRMYXRMbmdzKCksXG5cdFx0XHRib3VuZHMgPSB0aGlzLl9zaGFwZS5nZXRCb3VuZHMoKSxcblx0XHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcblx0XHRcdG9mZnNldCwgbmV3TGF0TG5ncyA9IFtdO1xuXG5cdFx0Ly8gT2Zmc2V0IHRoZSBsYXRsbmdzIHRvIHRoZSBuZXcgY2VudGVyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0b2Zmc2V0ID0gW2xhdGxuZ3NbaV0ubGF0IC0gY2VudGVyLmxhdCwgbGF0bG5nc1tpXS5sbmcgLSBjZW50ZXIubG5nXTtcblx0XHRcdG5ld0xhdExuZ3MucHVzaChbbmV3Q2VudGVyLmxhdCArIG9mZnNldFswXSwgbmV3Q2VudGVyLmxuZyArIG9mZnNldFsxXV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYXBlLnNldExhdExuZ3MobmV3TGF0TG5ncyk7XG5cblx0XHQvLyBSZXBvc2l0aW9uIHRoZSByZXNpemUgbWFya2Vyc1xuXHRcdHRoaXMuX3JlcG9zaXRpb25Db3JuZXJNYXJrZXJzKCk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVE1PVkUsIHtsYXllcjogdGhpcy5fc2hhcGV9KTtcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIGJvdW5kcztcblxuXHRcdC8vIFVwZGF0ZSB0aGUgc2hhcGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhpcyBjb3JuZXIgYW5kIHRoZSBvcHBvc2l0ZSBwb2ludFxuXHRcdHRoaXMuX3NoYXBlLnNldEJvdW5kcyhMLmxhdExuZ0JvdW5kcyhsYXRsbmcsIHRoaXMuX29wcG9zaXRlQ29ybmVyKSk7XG5cblx0XHQvLyBSZXBvc2l0aW9uIHRoZSBtb3ZlIG1hcmtlclxuXHRcdGJvdW5kcyA9IHRoaXMuX3NoYXBlLmdldEJvdW5kcygpO1xuXHRcdHRoaXMuX21vdmVNYXJrZXIuc2V0TGF0TG5nKGJvdW5kcy5nZXRDZW50ZXIoKSk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFJFU0laRSwge2xheWVyOiB0aGlzLl9zaGFwZX0pO1xuXHR9LFxuXG5cdF9nZXRDb3JuZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3NoYXBlLmdldEJvdW5kcygpLFxuXHRcdFx0bncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxuXHRcdFx0c3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCk7XG5cblx0XHRyZXR1cm4gW253LCBuZSwgc2UsIHN3XTtcblx0fSxcblxuXHRfdG9nZ2xlQ29ybmVyTWFya2VyczogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3Jlc2l6ZU1hcmtlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9yZXNpemVNYXJrZXJzW2ldLnNldE9wYWNpdHkob3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXBvc2l0aW9uQ29ybmVyTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fZ2V0Q29ybmVycygpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9yZXNpemVNYXJrZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fcmVzaXplTWFya2Vyc1tpXS5zZXRMYXRMbmcoY29ybmVyc1tpXSk7XG5cdFx0fVxuXHR9XG59KTtcblxuTC5SZWN0YW5nbGUuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXHRpZiAoTC5FZGl0LlJlY3RhbmdsZSkge1xuXHRcdHRoaXMuZWRpdGluZyA9IG5ldyBMLkVkaXQuUmVjdGFuZ2xlKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLmVuYWJsZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuQ2lyY2xlTWFya2VyXG4gKiBAYWthIEVkaXQuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgTC5FZGl0LlNpbXBsZVNoYXBlXG4gKi9cbkwuRWRpdC5DaXJjbGVNYXJrZXIgPSBMLkVkaXQuU2ltcGxlU2hhcGUuZXh0ZW5kKHtcblx0X2NyZWF0ZU1vdmVNYXJrZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2VudGVyID0gdGhpcy5fc2hhcGUuZ2V0TGF0TG5nKCk7XG5cblx0XHR0aGlzLl9tb3ZlTWFya2VyID0gdGhpcy5fY3JlYXRlTWFya2VyKGNlbnRlciwgdGhpcy5vcHRpb25zLm1vdmVJY29uKTtcblx0fSxcblxuXHRfY3JlYXRlUmVzaXplTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVG8gYXZvaWQgYW4gdW5kZWZpbmVkIGNoZWNrIGluIEwuRWRpdC5TaW1wbGVTaGFwZS5yZW1vdmVIb29rc1xuXHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnMgPSBbXTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl9yZXNpemVNYXJrZXJzLmxlbmd0aCkge1xuXHRcdFx0dmFyIHJlc2l6ZW1hcmtlclBvaW50ID0gdGhpcy5fZ2V0UmVzaXplTWFya2VyUG9pbnQobGF0bG5nKTtcblx0XHRcdC8vIE1vdmUgdGhlIHJlc2l6ZSBtYXJrZXJcblx0XHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnNbMF0uc2V0TGF0TG5nKHJlc2l6ZW1hcmtlclBvaW50KTtcblx0XHR9XG5cblx0XHQvLyBNb3ZlIHRoZSBjaXJjbGVcblx0XHR0aGlzLl9zaGFwZS5zZXRMYXRMbmcobGF0bG5nKTtcblxuXHRcdHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5FRElUTU9WRSwge2xheWVyOiB0aGlzLl9zaGFwZX0pO1xuXHR9LFxufSk7XG5cbkwuQ2lyY2xlTWFya2VyLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0aWYgKEwuRWRpdC5DaXJjbGVNYXJrZXIpIHtcblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0LkNpcmNsZU1hcmtlcih0aGlzKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5lbmFibGUoKTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLm9uKCdhZGQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZWRpdGluZyAmJiB0aGlzLmVkaXRpbmcuZW5hYmxlZCgpKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcuYWRkSG9va3MoKTtcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5lZGl0aW5nICYmIHRoaXMuZWRpdGluZy5lbmFibGVkKCkpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5yZW1vdmVIb29rcygpO1xuXHRcdH1cblx0fSk7XG59KTtcblxuXG5cbkwuRWRpdCA9IEwuRWRpdCB8fCB7fTtcbi8qKlxuICogQGNsYXNzIEwuRWRpdC5DaXJjbGVcbiAqIEBha2EgRWRpdC5DaXJjbGVcbiAqIEBpbmhlcml0cyBMLkVkaXQuQ2lyY2xlTWFya2VyXG4gKi9cbkwuRWRpdC5DaXJjbGUgPSBMLkVkaXQuQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0X2NyZWF0ZVJlc2l6ZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjZW50ZXIgPSB0aGlzLl9zaGFwZS5nZXRMYXRMbmcoKSxcblx0XHRcdHJlc2l6ZW1hcmtlclBvaW50ID0gdGhpcy5fZ2V0UmVzaXplTWFya2VyUG9pbnQoY2VudGVyKTtcblxuXHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnMgPSBbXTtcblx0XHR0aGlzLl9yZXNpemVNYXJrZXJzLnB1c2godGhpcy5fY3JlYXRlTWFya2VyKHJlc2l6ZW1hcmtlclBvaW50LCB0aGlzLm9wdGlvbnMucmVzaXplSWNvbikpO1xuXHR9LFxuXG5cdF9nZXRSZXNpemVNYXJrZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdC8vIEZyb20gTC5zaGFwZS5nZXRCb3VuZHMoKVxuXHRcdHZhciBkZWx0YSA9IHRoaXMuX3NoYXBlLl9yYWRpdXMgKiBNYXRoLmNvcyhNYXRoLlBJIC8gNCksXG5cdFx0XHRwb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC51bnByb2plY3QoW3BvaW50LnggKyBkZWx0YSwgcG9pbnQueSAtIGRlbHRhXSk7XG5cdH0sXG5cblx0X3Jlc2l6ZTogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBtb3ZlTGF0TG5nID0gdGhpcy5fbW92ZU1hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgcmFkaXVzIGJhc2VkIG9uIHRoZSB2ZXJzaW9uXG5cdFx0aWYgKEwuR2VvbWV0cnlVdGlsLmlzVmVyc2lvbjA3eCgpKSB7XG5cdFx0XHRyYWRpdXMgPSBtb3ZlTGF0TG5nLmRpc3RhbmNlVG8obGF0bG5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gdGhpcy5fbWFwLmRpc3RhbmNlKG1vdmVMYXRMbmcsIGxhdGxuZyk7XG5cdFx0fVxuXHRcdHRoaXMuX3NoYXBlLnNldFJhZGl1cyhyYWRpdXMpO1xuXG5cdFx0aWYgKHRoaXMuX21hcC5lZGl0VG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fbWFwLl9lZGl0VG9vbHRpcC51cGRhdGVDb250ZW50KHtcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAuc3VidGV4dCArICc8YnIgLz4nICsgTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxcblx0XHRcdFx0c3VidGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5jaXJjbGUucmFkaXVzICsgJzogJyArXG5cdFx0XHRcdEwuR2VvbWV0cnlVdGlsLnJlYWRhYmxlRGlzdGFuY2UocmFkaXVzLCB0cnVlLCB0aGlzLm9wdGlvbnMuZmVldCwgdGhpcy5vcHRpb25zLm5hdXRpYylcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYXBlLnNldFJhZGl1cyhyYWRpdXMpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRSRVNJWkUsIHtsYXllcjogdGhpcy5fc2hhcGV9KTtcblx0fVxufSk7XG5cbkwuQ2lyY2xlLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0aWYgKEwuRWRpdC5DaXJjbGUpIHtcblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0LkNpcmNsZSh0aGlzKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5lbmFibGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0dG91Y2hFeHRlbmQ6IHRydWVcbn0pO1xuXG4vKipcbiAqIEBjbGFzcyBMLk1hcC5Ub3VjaEV4dGVuZFxuICogQGFrYSBUb3VjaEV4dGVuZFxuICovXG5MLk1hcC5Ub3VjaEV4dGVuZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdC8vIFNldHMgVG91Y2hFeHRlbmQgcHJpdmF0ZSBhY2Nlc3NvciB2YXJpYWJsZXNcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkcyBkb20gbGlzdGVuZXIgZXZlbnRzIHRvIHRoZSBtYXAgY29udGFpbmVyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0aWYgKHRoaXMuX2RldGVjdElFKCkpIHtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnTVNQb2ludGVyRG93bicsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlclVwJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlckNhbmNlbCcsIHRoaXMuX29uVG91Y2hDYW5jZWwsIHRoaXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoQ2FuY2VsLCB0aGlzKTtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAndG91Y2hsZWF2ZScsIHRoaXMuX29uVG91Y2hMZWF2ZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmVzIGRvbSBsaXN0ZW5lciBldmVudHMgZnJvbSB0aGUgbWFwIGNvbnRhaW5lclxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdGlmICh0aGlzLl9kZXRlY3RJRSgpKSB7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdNU1BvaW50ZXJEb3duJywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlclVwJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdNU1BvaW50ZXJNb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnTVNQb2ludGVyQ2FuY2VsJywgdGhpcy5fb25Ub3VjaENhbmNlbCwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaENhbmNlbCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICd0b3VjaGxlYXZlJywgdGhpcy5fb25Ub3VjaExlYXZlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X3RvdWNoRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XG5cdFx0Ly8gI1RPRE86IGZpeCB0aGUgcGFnZVggZXJyb3IgdGhhdCBpcyBkbyBhIGJ1ZyBpbiBBbmRyb2lkIHdoZXJlIGEgc2luZ2xlIHRvdWNoIHRyaWdnZXJzIHR3byBjbGljayBldmVudHNcblx0XHQvLyBfZmlsdGVyQ2xpY2sgaXMgd2hhdCBsZWFmbGV0IHVzZXMgYXMgYSB3b3JrYXJvdW5kLlxuXHRcdC8vIFRoaXMgaXMgYSBwcm9ibGVtIHdpdGggbW9yZSB0aGluZ3MgdGhhbiBqdXN0IGFuZHJvaWQuIEFub3RoZXIgcHJvYmxlbSBpcyB0b3VjaEVuZCBoYXMgbm8gdG91Y2hlcyBpblxuXHRcdC8vIGl0cyB0b3VjaCBsaXN0LlxuXHRcdHZhciB0b3VjaEV2ZW50ID0ge307XG5cdFx0aWYgKHR5cGVvZiBlLnRvdWNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRpZiAoIWUudG91Y2hlcy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dG91Y2hFdmVudCA9IGUudG91Y2hlc1swXTtcblx0XHR9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcblx0XHRcdHRvdWNoRXZlbnQgPSBlO1xuXHRcdFx0aWYgKCF0aGlzLl9maWx0ZXJDbGljayhlKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodG91Y2hFdmVudCksXG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQodG91Y2hFdmVudCksXG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwge1xuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXG5cdFx0XHRsYXllclBvaW50OiBsYXllclBvaW50LFxuXHRcdFx0Y29udGFpbmVyUG9pbnQ6IGNvbnRhaW5lclBvaW50LFxuXHRcdFx0cGFnZVg6IHRvdWNoRXZlbnQucGFnZVgsXG5cdFx0XHRwYWdlWTogdG91Y2hFdmVudC5wYWdlWSxcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcblx0XHR9KTtcblx0fSxcblxuXHQvKiogQm9ycm93ZWQgZnJvbSBMZWFmbGV0IGFuZCBtb2RpZmllZCBmb3IgYm9vbCBvcHMgKiovXG5cdF9maWx0ZXJDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IGUub3JpZ2luYWxFdmVudC50aW1lU3RhbXApLFxuXHRcdFx0ZWxhcHNlZCA9IEwuRG9tRXZlbnQuX2xhc3RDbGljayAmJiAodGltZVN0YW1wIC0gTC5Eb21FdmVudC5fbGFzdENsaWNrKTtcblxuXHRcdC8vIGFyZSB0aGV5IGNsb3NlciB0b2dldGhlciB0aGFuIDUwMG1zIHlldCBtb3JlIHRoYW4gMTAwbXM/XG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXG5cdFx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xuXHRcdC8vIG9yIGNoZWNrIGlmIGNsaWNrIGlzIHNpbXVsYXRlZCBvbiB0aGUgZWxlbWVudCwgYW5kIGlmIGl0IGlzLCByZWplY3QgYW55IG5vbi1zaW11bGF0ZWQgZXZlbnRzXG5cdFx0aWYgKChlbGFwc2VkICYmIGVsYXBzZWQgPiAxMDAgJiYgZWxhcHNlZCA8IDUwMCkgfHwgKGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayAmJiAhZS5fc2ltdWxhdGVkKSkge1xuXHRcdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcC5fbG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHR5cGUgPSAndG91Y2hzdGFydCc7XG5cdFx0dGhpcy5fdG91Y2hFdmVudChlLCB0eXBlKTtcblxuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwLl9sb2FkZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHlwZSA9ICd0b3VjaGVuZCc7XG5cdFx0dGhpcy5fdG91Y2hFdmVudChlLCB0eXBlKTtcblx0fSxcblxuXHRfb25Ub3VjaENhbmNlbDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcC5fbG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHR5cGUgPSAndG91Y2hjYW5jZWwnO1xuXHRcdGlmICh0aGlzLl9kZXRlY3RJRSgpKSB7XG5cdFx0XHR0eXBlID0gJ3BvaW50ZXJjYW5jZWwnO1xuXHRcdH1cblx0XHR0aGlzLl90b3VjaEV2ZW50KGUsIHR5cGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTGVhdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAuX2xvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0eXBlID0gJ3RvdWNobGVhdmUnO1xuXHRcdHRoaXMuX3RvdWNoRXZlbnQoZSwgdHlwZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwLl9sb2FkZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHlwZSA9ICd0b3VjaG1vdmUnO1xuXHRcdHRoaXMuX3RvdWNoRXZlbnQoZSwgdHlwZSk7XG5cdH0sXG5cblx0X2RldGVjdElFOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cblx0XHR2YXIgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJyk7XG5cdFx0aWYgKG1zaWUgPiAwKSB7XG5cdFx0XHQvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcblx0XHRcdHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcobXNpZSArIDUsIHVhLmluZGV4T2YoJy4nLCBtc2llKSksIDEwKTtcblx0XHR9XG5cblx0XHR2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ1RyaWRlbnQvJyk7XG5cdFx0aWYgKHRyaWRlbnQgPiAwKSB7XG5cdFx0XHQvLyBJRSAxMSA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcblx0XHRcdHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhydiArIDMsIHVhLmluZGV4T2YoJy4nLCBydikpLCAxMCk7XG5cdFx0fVxuXG5cdFx0dmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdFZGdlLycpO1xuXHRcdGlmIChlZGdlID4gMCkge1xuXHRcdFx0Ly8gSUUgMTIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKGVkZ2UgKyA1LCB1YS5pbmRleE9mKCcuJywgZWRnZSkpLCAxMCk7XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgYnJvd3NlclxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoRXh0ZW5kJywgTC5NYXAuVG91Y2hFeHRlbmQpO1xuXG5cbi8qKlxuICogQGNsYXNzIEwuTWFya2VyLlRvdWNoXG4gKiBAYWthIE1hcmtlci5Ub3VjaFxuICpcbiAqIFRoaXMgaXNuJ3QgZnVsbCBUb3VjaCBzdXBwb3J0LiBUaGlzIGlzIGp1c3QgdG8gZ2V0IG1hcmtlcnMgdG8gYWxzbyBzdXBwb3J0IGRvbSB0b3VjaCBldmVudHMgYWZ0ZXIgY3JlYXRpb25cbiAqICNUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSBvZiBnZXR0aW5nIG1hcmtlcnMgdG8gc3VwcG9ydCB0b3VjaC5cbiAqL1xuTC5NYXJrZXIuVG91Y2ggPSBMLk1hcmtlci5leHRlbmQoe1xuXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQpIHtcblx0XHRcdC8vIDAuNy54IHN1cHBvcnRcblx0XHRcdHJldHVybiB0aGlzLl9pbml0SW50ZXJhY3Rpb25MZWdhY3koKTtcblx0XHR9XG5cdFx0Ly8gVE9ETyB0aGlzIG1heSBuZWVkIGJlIHVwZGF0ZWQgdG8gcmUtYWRkIHRvdWNoIGV2ZW50cyBmb3IgMS4wK1xuXHRcdHJldHVybiBMLk1hcmtlci5wcm90b3R5cGUuX2luaXRJbnRlcmFjdGlvbi5hcHBseSh0aGlzKTtcblx0fSxcblxuXHQvLyBUaGlzIGlzIGFuIGV4YWN0IGNvcHkgb2YgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9ibG9iL3YwLjcvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanNcblx0Ly8gd2l0aCB0aGUgYWRkaXRpb24gb2YgdGhlIHRvdWNoIGV2ZW50c1xuXHRfaW5pdEludGVyYWN0aW9uTGVnYWN5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBUT0RPIHJlZmFjdG9yIGludG8gc29tZXRoaW5nIHNoYXJlZCB3aXRoIE1hcC9QYXRoL2V0Yy4gdG8gRFJZIGl0IHVwXG5cblx0XHR2YXIgaWNvbiA9IHRoaXMuX2ljb24sXG5cdFx0XHRldmVudHMgPSBbJ2RibGNsaWNrJyxcblx0XHRcdFx0J21vdXNlZG93bicsXG5cdFx0XHRcdCdtb3VzZW92ZXInLFxuXHRcdFx0XHQnbW91c2VvdXQnLFxuXHRcdFx0XHQnY29udGV4dG1lbnUnLFxuXHRcdFx0XHQndG91Y2hzdGFydCcsXG5cdFx0XHRcdCd0b3VjaGVuZCcsXG5cdFx0XHRcdCd0b3VjaG1vdmUnXTtcblx0XHRpZiAodGhpcy5fZGV0ZWN0SUUpIHtcblx0XHRcdGV2ZW50cy5jb25jYXQoWydNU1BvaW50ZXJEb3duJyxcblx0XHRcdFx0J01TUG9pbnRlclVwJyxcblx0XHRcdFx0J01TUG9pbnRlck1vdmUnLFxuXHRcdFx0XHQnTVNQb2ludGVyQ2FuY2VsJ10pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuY29uY2F0KFsndG91Y2hjYW5jZWwnXSk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdEwuRG9tRXZlbnQub24oaWNvbiwgJ2NsaWNrJywgdGhpcy5fb25Nb3VzZUNsaWNrLCB0aGlzKTtcblx0XHRMLkRvbUV2ZW50Lm9uKGljb24sICdrZXlwcmVzcycsIHRoaXMuX29uS2V5UHJlc3MsIHRoaXMpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdEwuRG9tRXZlbnQub24oaWNvbiwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKEwuSGFuZGxlci5NYXJrZXJEcmFnKSB7XG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpO1xuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZGV0ZWN0SUU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuXHRcdHZhciBtc2llID0gdWEuaW5kZXhPZignTVNJRSAnKTtcblx0XHRpZiAobXNpZSA+IDApIHtcblx0XHRcdC8vIElFIDEwIG9yIG9sZGVyID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuXHRcdFx0cmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuXHRcdH1cblxuXHRcdHZhciB0cmlkZW50ID0gdWEuaW5kZXhPZignVHJpZGVudC8nKTtcblx0XHRpZiAodHJpZGVudCA+IDApIHtcblx0XHRcdC8vIElFIDExID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuXHRcdFx0dmFyIHJ2ID0gdWEuaW5kZXhPZigncnY6Jyk7XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcblx0XHR9XG5cblx0XHR2YXIgZWRnZSA9IHVhLmluZGV4T2YoJ0VkZ2UvJyk7XG5cdFx0aWYgKGVkZ2UgPiAwKSB7XG5cdFx0XHQvLyBJRSAxMiA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcblx0XHRcdHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcblx0XHR9XG5cblx0XHQvLyBvdGhlciBicm93c2VyXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuTGF0TG5nVXRpbFxuICogQGFrYSBMYXRMbmdVdGlsXG4gKi9cbkwuTGF0TG5nVXRpbCA9IHtcblx0Ly8gQ2xvbmVzIGEgTGF0TG5nc1tdLCByZXR1cm5zIFtdW11cblxuXHQvLyBAbWV0aG9kIGNsb25lTGF0TG5ncyhMYXRMbmdzW10pOiBMLkxhdExuZ3NbXVxuXHQvLyBDbG9uZSB0aGUgbGF0TG5nIHBvaW50IG9yIHBvaW50cyBvciBuZXN0ZWQgcG9pbnRzIGFuZCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aG9zZSBwb2ludHNcblx0Y2xvbmVMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciBjbG9uZSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdC8vIENoZWNrIGZvciBuZXN0ZWQgYXJyYXkgKFBvbHlsaW5lL1BvbHlnb24pXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShsYXRsbmdzW2ldKSkge1xuXHRcdFx0XHRjbG9uZS5wdXNoKEwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZ3MobGF0bG5nc1tpXSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmUucHVzaCh0aGlzLmNsb25lTGF0TG5nKGxhdGxuZ3NbaV0pKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvbmVMYXRMbmcoTGF0TG5nKTogTC5MYXRMbmdcblx0Ly8gQ2xvbmUgdGhlIGxhdExuZyBhbmQgcmV0dXJuIGEgbmV3IExhdExuZyBvYmplY3QuXG5cdGNsb25lTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0cmV0dXJuIEwubGF0TG5nKGxhdGxuZy5sYXQsIGxhdGxuZy5sbmcpO1xuXHR9XG59O1xuXG5cblxuKGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgZGVmYXVsdFByZWNpc2lvbiA9IHtcblx0XHRrbTogMixcblx0XHRoYTogMixcblx0XHRtOiAwLFxuXHRcdG1pOiAyLFxuXHRcdGFjOiAyLFxuXHRcdHlkOiAwLFxuXHRcdGZ0OiAwLFxuXHRcdG5tOiAyXG5cdH07XG5cblxuXHQvKipcblx0ICogQGNsYXNzIEwuR2VvbWV0cnlVdGlsXG5cdCAqIEBha2EgR2VvbWV0cnlVdGlsXG5cdCAqL1xuXHRMLkdlb21ldHJ5VXRpbCA9IEwuZXh0ZW5kKEwuR2VvbWV0cnlVdGlsIHx8IHt9LCB7XG5cdFx0Ly8gUG9ydGVkIGZyb20gdGhlIE9wZW5MYXllcnMgaW1wbGVtZW50YXRpb24uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2Jsb2IvbWFzdGVyL2xpYi9PcGVuTGF5ZXJzL0dlb21ldHJ5L0xpbmVhclJpbmcuanMjTDI3MFxuXG5cdFx0Ly8gQG1ldGhvZCBnZW9kZXNpY0FyZWEoKTogbnVtYmVyXG5cdFx0Z2VvZGVzaWNBcmVhOiBmdW5jdGlvbiAobGF0TG5ncykge1xuXHRcdFx0dmFyIHBvaW50c0NvdW50ID0gbGF0TG5ncy5sZW5ndGgsXG5cdFx0XHRcdGFyZWEgPSAwLjAsXG5cdFx0XHRcdGQyciA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRcdHAxLCBwMjtcblxuXHRcdFx0aWYgKHBvaW50c0NvdW50ID4gMikge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0NvdW50OyBpKyspIHtcblx0XHRcdFx0XHRwMSA9IGxhdExuZ3NbaV07XG5cdFx0XHRcdFx0cDIgPSBsYXRMbmdzWyhpICsgMSkgJSBwb2ludHNDb3VudF07XG5cdFx0XHRcdFx0YXJlYSArPSAoKHAyLmxuZyAtIHAxLmxuZykgKiBkMnIpICpcblx0XHRcdFx0XHRcdCgyICsgTWF0aC5zaW4ocDEubGF0ICogZDJyKSArIE1hdGguc2luKHAyLmxhdCAqIGQycikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFyZWEgPSBhcmVhICogNjM3ODEzNy4wICogNjM3ODEzNy4wIC8gMi4wO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoYXJlYSk7XG5cdFx0fSxcblxuXHRcdC8vIEBtZXRob2QgZm9ybWF0dGVkTnVtYmVyKG4sIHByZWNpc2lvbik6IHN0cmluZ1xuXHRcdC8vIFJldHVybnMgbiBpbiBzcGVjaWZpZWQgbnVtYmVyIGZvcm1hdCAoaWYgZGVmaW5lZCkgYW5kIHByZWNpc2lvblxuXHRcdGZvcm1hdHRlZE51bWJlcjogZnVuY3Rpb24gKG4sIHByZWNpc2lvbikge1xuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHBhcnNlRmxvYXQobikudG9GaXhlZChwcmVjaXNpb24pLFxuXHRcdFx0XHRmb3JtYXQgPSBMLmRyYXdMb2NhbC5mb3JtYXQgJiYgTC5kcmF3TG9jYWwuZm9ybWF0Lm51bWVyaWMsXG5cdFx0XHRcdGRlbGltaXRlcnMgPSBmb3JtYXQgJiYgZm9ybWF0LmRlbGltaXRlcnMsXG5cdFx0XHRcdHRob3VzYW5kcyA9IGRlbGltaXRlcnMgJiYgZGVsaW1pdGVycy50aG91c2FuZHMsXG5cdFx0XHRcdGRlY2ltYWwgPSBkZWxpbWl0ZXJzICYmIGRlbGltaXRlcnMuZGVjaW1hbDtcblxuXHRcdFx0aWYgKHRob3VzYW5kcyB8fCBkZWNpbWFsKSB7XG5cdFx0XHRcdHZhciBzcGxpdFZhbHVlID0gZm9ybWF0dGVkLnNwbGl0KCcuJyk7XG5cdFx0XHRcdGZvcm1hdHRlZCA9IHRob3VzYW5kcyA/IHNwbGl0VmFsdWVbMF0ucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICsgdGhvdXNhbmRzKSA6IHNwbGl0VmFsdWVbMF07XG5cdFx0XHRcdGRlY2ltYWwgPSBkZWNpbWFsIHx8ICcuJztcblx0XHRcdFx0aWYgKHNwbGl0VmFsdWUubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGZvcm1hdHRlZCA9IGZvcm1hdHRlZCArIGRlY2ltYWwgKyBzcGxpdFZhbHVlWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3JtYXR0ZWQ7XG5cdFx0fSxcblxuXHRcdC8vIEBtZXRob2QgcmVhZGFibGVBcmVhKGFyZWEsIGlzTWV0cmljLCBwcmVjaXNpb24pOiBzdHJpbmdcblx0XHQvLyBSZXR1cm5zIGEgcmVhZGFibGUgYXJlYSBzdHJpbmcgaW4geWFyZHMgb3IgbWV0cmljLlxuXHRcdC8vIFRoZSB2YWx1ZSB3aWxsIGJlIHJvdW5kZWQgYXMgZGVmaW5lZCBieSB0aGUgcHJlY2lzaW9uIG9wdGlvbiBvYmplY3QuXG5cdFx0cmVhZGFibGVBcmVhOiBmdW5jdGlvbiAoYXJlYSwgaXNNZXRyaWMsIHByZWNpc2lvbikge1xuXHRcdFx0dmFyIGFyZWFTdHIsXG5cdFx0XHRcdHVuaXRzLFxuXHRcdFx0XHRwcmVjaXNpb24gPSBMLlV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0UHJlY2lzaW9uLCBwcmVjaXNpb24pO1xuXG5cdFx0XHRpZiAoaXNNZXRyaWMpIHtcblx0XHRcdFx0dW5pdHMgPSBbJ2hhJywgJ20nXTtcblx0XHRcdFx0dHlwZSA9IHR5cGVvZiBpc01ldHJpYztcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dW5pdHMgPSBbaXNNZXRyaWNdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdHVuaXRzID0gaXNNZXRyaWM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYXJlYSA+PSAxMDAwMDAwICYmIHVuaXRzLmluZGV4T2YoJ2ttJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0YXJlYVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihhcmVhICogMC4wMDAwMDEsIHByZWNpc2lvblsna20nXSkgKyAnIGttwrInO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZWEgPj0gMTAwMDAgJiYgdW5pdHMuaW5kZXhPZignaGEnKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRhcmVhU3RyID0gTC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGFyZWEgKiAwLjAwMDEsIHByZWNpc2lvblsnaGEnXSkgKyAnIGhhJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcmVhU3RyID0gTC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGFyZWEsIHByZWNpc2lvblsnbSddKSArICcgbcKyJztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJlYSAvPSAwLjgzNjEyNzsgLy8gU3F1YXJlIHlhcmRzIGluIDEgbWV0ZXJcblxuXHRcdFx0XHRpZiAoYXJlYSA+PSAzMDk3NjAwKSB7IC8vMzA5NzYwMCBzcXVhcmUgeWFyZHMgaW4gMSBzcXVhcmUgbWlsZVxuXHRcdFx0XHRcdGFyZWFTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoYXJlYSAvIDMwOTc2MDAsIHByZWNpc2lvblsnbWknXSkgKyAnIG1pwrInO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZWEgPj0gNDg0MCkgeyAvLzQ4NDAgc3F1YXJlIHlhcmRzIGluIDEgYWNyZVxuXHRcdFx0XHRcdGFyZWFTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoYXJlYSAvIDQ4NDAsIHByZWNpc2lvblsnYWMnXSkgKyAnIGFjcmVzJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcmVhU3RyID0gTC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGFyZWEsIHByZWNpc2lvblsneWQnXSkgKyAnIHlkwrInO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcmVhU3RyO1xuXHRcdH0sXG5cblx0XHQvLyBAbWV0aG9kIHJlYWRhYmxlRGlzdGFuY2UoZGlzdGFuY2UsIHVuaXRzKTogc3RyaW5nXG5cdFx0Ly8gQ29udmVydHMgYSBtZXRyaWMgZGlzdGFuY2UgdG8gb25lIG9mIFsgZmVldCwgbmF1dGljYWxNaWxlLCBtZXRyaWMgb3IgeWFyZHMgXSBzdHJpbmdcblx0XHQvL1xuXHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdC8vIEBtZXRob2QgcmVhZGFibGVEaXN0YW5jZShkaXN0YW5jZSwgaXNNZXRyaWMsIHVzZUZlZXQsIGlzTmF1dGljYWxNaWxlLCBwcmVjaXNpb24pOiBzdHJpbmdcblx0XHQvLyBDb252ZXJ0cyBtZXRyaWMgZGlzdGFuY2UgdG8gZGlzdGFuY2Ugc3RyaW5nLlxuXHRcdC8vIFRoZSB2YWx1ZSB3aWxsIGJlIHJvdW5kZWQgYXMgZGVmaW5lZCBieSB0aGUgcHJlY2lzaW9uIG9wdGlvbiBvYmplY3QuXG5cdFx0cmVhZGFibGVEaXN0YW5jZTogZnVuY3Rpb24gKGRpc3RhbmNlLCBpc01ldHJpYywgaXNGZWV0LCBpc05hdXRpY2FsTWlsZSwgcHJlY2lzaW9uKSB7XG5cdFx0XHR2YXIgZGlzdGFuY2VTdHIsXG5cdFx0XHRcdHVuaXRzLFxuXHRcdFx0XHRwcmVjaXNpb24gPSBMLlV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0UHJlY2lzaW9uLCBwcmVjaXNpb24pO1xuXG5cdFx0XHRpZiAoaXNNZXRyaWMpIHtcblx0XHRcdFx0dW5pdHMgPSB0eXBlb2YgaXNNZXRyaWMgPT0gJ3N0cmluZycgPyBpc01ldHJpYyA6ICdtZXRyaWMnO1xuXHRcdFx0fSBlbHNlIGlmIChpc0ZlZXQpIHtcblx0XHRcdFx0dW5pdHMgPSAnZmVldCc7XG5cdFx0XHR9IGVsc2UgaWYgKGlzTmF1dGljYWxNaWxlKSB7XG5cdFx0XHRcdHVuaXRzID0gJ25hdXRpY2FsTWlsZSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR1bml0cyA9ICd5YXJkcyc7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAodW5pdHMpIHtcblx0XHRcdFx0Y2FzZSAnbWV0cmljJzpcblx0XHRcdFx0XHQvLyBzaG93IG1ldHJlcyB3aGVuIGRpc3RhbmNlIGlzIDwgMWttLCB0aGVuIHNob3cga21cblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiAxMDAwKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSAvIDEwMDAsIHByZWNpc2lvblsna20nXSkgKyAnIGttJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2VTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoZGlzdGFuY2UsIHByZWNpc2lvblsnbSddKSArICcgbSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmZWV0Jzpcblx0XHRcdFx0XHRkaXN0YW5jZSAqPSAxLjA5MzYxICogMztcblx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSwgcHJlY2lzaW9uWydmdCddKSArICcgZnQnO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ25hdXRpY2FsTWlsZSc6XG5cdFx0XHRcdFx0ZGlzdGFuY2UgKj0gMC41Mzk5Njtcblx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSAvIDEwMDAsIHByZWNpc2lvblsnbm0nXSkgKyAnIG5tJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAneWFyZHMnOlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGRpc3RhbmNlICo9IDEuMDkzNjE7XG5cblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiAxNzYwKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSAvIDE3NjAsIHByZWNpc2lvblsnbWknXSkgKyAnIG1pbGVzJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2VTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoZGlzdGFuY2UsIHByZWNpc2lvblsneWQnXSkgKyAnIHlkJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGlzdGFuY2VTdHI7XG5cdFx0fSxcblxuXHRcdC8vIEBtZXRob2QgaXNWZXJzaW9uMDd4KCk6IGJvb2xlYW5cblx0XHQvLyBSZXR1cm5zIHRydWUgaWYgdGhlIExlYWZsZXQgdmVyc2lvbiBpcyAwLjcueCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdGlzVmVyc2lvbjA3eDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHZlcnNpb24gPSBMLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHRcdC8vSWYgVmVyc2lvbiBpcyA9PSAwLjcuKlxuXHRcdFx0cmV0dXJuIHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSA9PT0gMCAmJiBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCkgPT09IDc7XG5cdFx0fSxcblx0fSk7XG5cbn0pKCk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkxpbmVVdGlsXG4gKiBAYWthIFV0aWxcbiAqIEBha2EgTC5VdGlsc1xuICovXG5MLlV0aWwuZXh0ZW5kKEwuTGluZVV0aWwsIHtcblxuXHQvLyBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0KCk6IGJvb2xlYW5cblx0Ly8gQ2hlY2tzIHRvIHNlZSBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3QuIERvZXMgbm90IGhhbmRsZSBkZWdlbmVyYXRlIGNhc2VzLlxuXHQvLyBodHRwOi8vY29tcGdlb20uY3MudWl1Yy5lZHUvfmplZmZlL3RlYWNoaW5nLzM3My9ub3Rlcy94MDYtc3dlZXBsaW5lLnBkZlxuXHRzZWdtZW50c0ludGVyc2VjdDogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMiwgLypQb2ludCovIHAzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrQ291bnRlcmNsb2Nrd2lzZShwLCBwMiwgcDMpICE9PVxuXHRcdFx0dGhpcy5fY2hlY2tDb3VudGVyY2xvY2t3aXNlKHAxLCBwMiwgcDMpICYmXG5cdFx0XHR0aGlzLl9jaGVja0NvdW50ZXJjbG9ja3dpc2UocCwgcDEsIHAyKSAhPT1cblx0XHRcdHRoaXMuX2NoZWNrQ291bnRlcmNsb2Nrd2lzZShwLCBwMSwgcDMpO1xuXHR9LFxuXG5cdC8vIGNoZWNrIHRvIHNlZSBpZiBwb2ludHMgYXJlIGluIGNvdW50ZXJjbG9ja3dpc2Ugb3JkZXJcblx0X2NoZWNrQ291bnRlcmNsb2Nrd2lzZTogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMikge1xuXHRcdHJldHVybiAocDIueSAtIHAueSkgKiAocDEueCAtIHAueCkgPiAocDEueSAtIHAueSkgKiAocDIueCAtIHAueCk7XG5cdH1cbn0pO1xuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5Qb2x5bGluZVxuICogQGFrYSBQb2x5bGluZVxuICovXG5MLlBvbHlsaW5lLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cygpOiBib29sZWFuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIHBvbHlsaW5lIGhhcyBhbnkgbGluZXNlZ21lbnRzIHRoYXQgaW50ZXJzZWN0LlxuXHQvLyBOT1RFOiBkb2VzIG5vdCBzdXBwb3J0IGRldGVjdGluZyBpbnRlcnNlY3Rpb24gZm9yIGRlZ2VuZXJhdGUgY2FzZXMuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fZ2V0UHJvamVjdGVkUG9pbnRzKCksXG5cdFx0XHRsZW4gPSBwb2ludHMgPyBwb2ludHMubGVuZ3RoIDogMCxcblx0XHRcdGksIHAsIHAxO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb0Zld1BvaW50c0ZvckludGVyc2VjdGlvbigpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAzOyBpLS0pIHtcblx0XHRcdHAgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cblxuXHRcdFx0aWYgKHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShwLCBwMSwgaSAtIDIpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG5ld0xhdExuZ0ludGVyc2VjdHMoKTogYm9vbGVhblxuXHQvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIGlmIG5ldyBsYXRsbmcgd2FzIGFkZGVkIHRvIHRoaXMgcG9seWxpbmUuXG5cdC8vIE5PVEU6IGRvZXMgbm90IHN1cHBvcnQgZGV0ZWN0aW5nIGludGVyc2VjdGlvbiBmb3IgZGVnZW5lcmF0ZSBjYXNlcy5cblx0bmV3TGF0TG5nSW50ZXJzZWN0czogZnVuY3Rpb24gKGxhdGxuZywgc2tpcEZpcnN0KSB7XG5cdFx0Ly8gQ2Fubm90IGNoZWNrIGEgcG9seWxpbmUgZm9yIGludGVyc2VjdGluZyBsYXRzL2xuZ3Mgd2hlbiBub3QgYWRkZWQgdG8gdGhlIG1hcFxuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubmV3UG9pbnRJbnRlcnNlY3RzKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKSwgc2tpcEZpcnN0KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG5ld1BvaW50SW50ZXJzZWN0cygpOiBib29sZWFuXG5cdC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gaWYgbmV3IHBvaW50IHdhcyBhZGRlZCB0byB0aGlzIHBvbHlsaW5lLlxuXHQvLyBuZXdQb2ludCBtdXN0IGJlIGEgbGF5ZXIgcG9pbnQuXG5cdC8vIE5PVEU6IGRvZXMgbm90IHN1cHBvcnQgZGV0ZWN0aW5nIGludGVyc2VjdGlvbiBmb3IgZGVnZW5lcmF0ZSBjYXNlcy5cblx0bmV3UG9pbnRJbnRlcnNlY3RzOiBmdW5jdGlvbiAobmV3UG9pbnQsIHNraXBGaXJzdCkge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKSxcblx0XHRcdGxlbiA9IHBvaW50cyA/IHBvaW50cy5sZW5ndGggOiAwLFxuXHRcdFx0bGFzdFBvaW50ID0gcG9pbnRzID8gcG9pbnRzW2xlbiAtIDFdIDogbnVsbCxcblx0XHRcdC8vIFRoZSBwcmV2aW91cyBwcmV2aW91cyBsaW5lIHNlZ21lbnQuIFByZXZpb3VzIGxpbmUgc2VnbWVudCBkb2Vzbid0IG5lZWQgdGVzdGluZy5cblx0XHRcdG1heEluZGV4ID0gbGVuIC0gMjtcblxuXHRcdGlmICh0aGlzLl90b29GZXdQb2ludHNGb3JJbnRlcnNlY3Rpb24oMSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fbGluZVNlZ21lbnRzSW50ZXJzZWN0c1JhbmdlKGxhc3RQb2ludCwgbmV3UG9pbnQsIG1heEluZGV4LCBza2lwRmlyc3QgPyAxIDogMCk7XG5cdH0sXG5cblx0Ly8gUG9seWxpbmVzIHdpdGggMiBzaWRlcyBjYW4gb25seSBpbnRlcnNlY3QgaW4gY2FzZXMgd2hlcmUgcG9pbnRzIGFyZSBjb2xsaW5lYXIgKHdlIGRvbid0IHN1cHBvcnQgZGV0ZWN0aW5nIHRoZXNlKS5cblx0Ly8gQ2Fubm90IGhhdmUgaW50ZXJzZWN0aW9uIHdoZW4gPCAzIGxpbmUgc2VnbWVudHMgKDwgNCBwb2ludHMpXG5cdF90b29GZXdQb2ludHNGb3JJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChleHRyYVBvaW50cykge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKSxcblx0XHRcdGxlbiA9IHBvaW50cyA/IHBvaW50cy5sZW5ndGggOiAwO1xuXHRcdC8vIEluY3JlbWVudCBsZW5ndGggYnkgZXh0cmFQb2ludHMgaWYgcHJlc2VudFxuXHRcdGxlbiArPSBleHRyYVBvaW50cyB8fCAwO1xuXG5cdFx0cmV0dXJuICFwb2ludHMgfHwgbGVuIDw9IDM7XG5cdH0sXG5cblx0Ly8gQ2hlY2tzIGEgbGluZSBzZWdtZW50IGludGVyc2VjdGlvbnMgd2l0aCBhbnkgbGluZSBzZWdtZW50cyBiZWZvcmUgaXRzIHByZWRlY2Vzc29yLlxuXHQvLyBEb24ndCBuZWVkIHRvIGNoZWNrIHRoZSBwcmVkZWNlc3NvciBhcyB3aWxsIG5ldmVyIGludGVyc2VjdC5cblx0X2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZTogZnVuY3Rpb24gKHAsIHAxLCBtYXhJbmRleCwgbWluSW5kZXgpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fZ2V0UHJvamVjdGVkUG9pbnRzKCksXG5cdFx0XHRwMiwgcDM7XG5cblx0XHRtaW5JbmRleCA9IG1pbkluZGV4IHx8IDA7XG5cblx0XHQvLyBDaGVjayBhbGwgcHJldmlvdXMgbGluZSBzZWdtZW50cyAoYmVzaWRlIHRoZSBpbW1lZGlhdGVseSBwcmV2aW91cykgZm9yIGludGVyc2VjdGlvbnNcblx0XHRmb3IgKHZhciBqID0gbWF4SW5kZXg7IGogPiBtaW5JbmRleDsgai0tKSB7XG5cdFx0XHRwMiA9IHBvaW50c1tqIC0gMV07XG5cdFx0XHRwMyA9IHBvaW50c1tqXTtcblxuXHRcdFx0aWYgKEwuTGluZVV0aWwuc2VnbWVudHNJbnRlcnNlY3QocCwgcDEsIHAyLCBwMykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9nZXRQcm9qZWN0ZWRQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RlZmF1bHRTaGFwZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29yaWdpbmFsUG9pbnRzO1xuXHRcdH1cblx0XHR2YXIgcG9pbnRzID0gW10sXG5cdFx0XHRfc2hhcGUgPSB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgX3NoYXBlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRwb2ludHMucHVzaCh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KF9zaGFwZVtpXSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuUG9seWdvblxuICogQGFrYSBQb2x5Z29uXG4gKi9cbkwuUG9seWdvbi5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMoKTogYm9vbGVhblxuXHQvLyBDaGVja3MgYSBwb2x5Z29uIGZvciBhbnkgaW50ZXJzZWN0aW5nIGxpbmUgc2VnbWVudHMuIElnbm9yZXMgaG9sZXMuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9seWxpbmVJbnRlcnNlY3RzLFxuXHRcdFx0cG9pbnRzID0gdGhpcy5fZ2V0UHJvamVjdGVkUG9pbnRzKCksXG5cdFx0XHRsZW4sIGZpcnN0UG9pbnQsIGxhc3RQb2ludCwgbWF4SW5kZXg7XG5cblx0XHRpZiAodGhpcy5fdG9vRmV3UG9pbnRzRm9ySW50ZXJzZWN0aW9uKCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwb2x5bGluZUludGVyc2VjdHMgPSBMLlBvbHlsaW5lLnByb3RvdHlwZS5pbnRlcnNlY3RzLmNhbGwodGhpcyk7XG5cblx0XHQvLyBJZiBhbHJlYWR5IGZvdW5kIGFuIGludGVyc2VjdGlvbiBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBhbnkgbW9yZS5cblx0XHRpZiAocG9seWxpbmVJbnRlcnNlY3RzKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZW4gPSBwb2ludHMubGVuZ3RoO1xuXHRcdGZpcnN0UG9pbnQgPSBwb2ludHNbMF07XG5cdFx0bGFzdFBvaW50ID0gcG9pbnRzW2xlbiAtIDFdO1xuXHRcdG1heEluZGV4ID0gbGVuIC0gMjtcblxuXHRcdC8vIENoZWNrIHRoZSBsaW5lIHNlZ21lbnQgYmV0d2VlbiBsYXN0IGFuZCBmaXJzdCBwb2ludC4gRG9uJ3QgbmVlZCB0byBjaGVjayB0aGUgZmlyc3QgbGluZSBzZWdtZW50IChtaW5JbmRleCA9IDEpXG5cdFx0cmV0dXJuIHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShsYXN0UG9pbnQsIGZpcnN0UG9pbnQsIG1heEluZGV4LCAxKTtcblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkNvbnRyb2wuRHJhd1xuICogQGFrYSBMLkRyYXdcbiAqL1xuTC5Db250cm9sLkRyYXcgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblxuXHQvLyBPcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxuXHRcdGRyYXc6IHt9LFxuXHRcdGVkaXQ6IGZhbHNlXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0Ly8gSW5pdGlhbGl6ZXMgZHJhdyBjb250cm9sLCB0b29sYmFycyBmcm9tIHRoZSBvcHRpb25zXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0aWYgKEwudmVyc2lvbiA8ICcwLjcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0xlYWZsZXQuZHJhdyAwLjIuMysgcmVxdWlyZXMgTGVhZmxldCAwLjcuMCsuIERvd25sb2FkIGxhdGVzdCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvJyk7XG5cdFx0fVxuXG5cdFx0TC5Db250cm9sLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cblx0XHR2YXIgdG9vbGJhcjtcblxuXHRcdHRoaXMuX3Rvb2xiYXJzID0ge307XG5cblx0XHQvLyBJbml0aWFsaXplIHRvb2xiYXJzXG5cdFx0aWYgKEwuRHJhd1Rvb2xiYXIgJiYgdGhpcy5vcHRpb25zLmRyYXcpIHtcblx0XHRcdHRvb2xiYXIgPSBuZXcgTC5EcmF3VG9vbGJhcih0aGlzLm9wdGlvbnMuZHJhdyk7XG5cblx0XHRcdHRoaXMuX3Rvb2xiYXJzW0wuRHJhd1Rvb2xiYXIuVFlQRV0gPSB0b29sYmFyO1xuXG5cdFx0XHQvLyBMaXN0ZW4gZm9yIHdoZW4gdG9vbGJhciBpcyBlbmFibGVkXG5cdFx0XHR0aGlzLl90b29sYmFyc1tMLkRyYXdUb29sYmFyLlRZUEVdLm9uKCdlbmFibGUnLCB0aGlzLl90b29sYmFyRW5hYmxlZCwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKEwuRWRpdFRvb2xiYXIgJiYgdGhpcy5vcHRpb25zLmVkaXQpIHtcblx0XHRcdHRvb2xiYXIgPSBuZXcgTC5FZGl0VG9vbGJhcih0aGlzLm9wdGlvbnMuZWRpdCk7XG5cblx0XHRcdHRoaXMuX3Rvb2xiYXJzW0wuRWRpdFRvb2xiYXIuVFlQRV0gPSB0b29sYmFyO1xuXG5cdFx0XHQvLyBMaXN0ZW4gZm9yIHdoZW4gdG9vbGJhciBpcyBlbmFibGVkXG5cdFx0XHR0aGlzLl90b29sYmFyc1tMLkVkaXRUb29sYmFyLlRZUEVdLm9uKCdlbmFibGUnLCB0aGlzLl90b29sYmFyRW5hYmxlZCwgdGhpcyk7XG5cdFx0fVxuXHRcdEwudG9vbGJhciA9IHRoaXM7IC8vc2V0IGdsb2JhbCB2YXIgZm9yIGVkaXRpbmcgdGhlIHRvb2xiYXJcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9uQWRkKCk6IGNvbnRhaW5lclxuXHQvLyBBZGRzIHRoZSB0b29sYmFyIGNvbnRhaW5lciB0byB0aGUgbWFwXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWRyYXcnKSxcblx0XHRcdGFkZGVkVG9wQ2xhc3MgPSBmYWxzZSxcblx0XHRcdHRvcENsYXNzTmFtZSA9ICdsZWFmbGV0LWRyYXctdG9vbGJhci10b3AnLFxuXHRcdFx0dG9vbGJhckNvbnRhaW5lcjtcblxuXHRcdGZvciAodmFyIHRvb2xiYXJJZCBpbiB0aGlzLl90b29sYmFycykge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2xiYXJzLmhhc093blByb3BlcnR5KHRvb2xiYXJJZCkpIHtcblx0XHRcdFx0dG9vbGJhckNvbnRhaW5lciA9IHRoaXMuX3Rvb2xiYXJzW3Rvb2xiYXJJZF0uYWRkVG9vbGJhcihtYXApO1xuXG5cdFx0XHRcdGlmICh0b29sYmFyQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0Ly8gQWRkIGNsYXNzIHRvIHRoZSBmaXJzdCB0b29sYmFyIHRvIHJlbW92ZSB0aGUgbWFyZ2luXG5cdFx0XHRcdFx0aWYgKCFhZGRlZFRvcENsYXNzKSB7XG5cdFx0XHRcdFx0XHRpZiAoIUwuRG9tVXRpbC5oYXNDbGFzcyh0b29sYmFyQ29udGFpbmVyLCB0b3BDbGFzc05hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0b29sYmFyQ29udGFpbmVyLmNoaWxkTm9kZXNbMF0sIHRvcENsYXNzTmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhZGRlZFRvcENsYXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodG9vbGJhckNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb25SZW1vdmUoKTogdm9pZFxuXHQvLyBSZW1vdmVzIHRoZSB0b29sYmFycyBmcm9tIHRoZSBtYXAgdG9vbGJhciBjb250YWluZXJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB0b29sYmFySWQgaW4gdGhpcy5fdG9vbGJhcnMpIHtcblx0XHRcdGlmICh0aGlzLl90b29sYmFycy5oYXNPd25Qcm9wZXJ0eSh0b29sYmFySWQpKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2xiYXJzW3Rvb2xiYXJJZF0ucmVtb3ZlVG9vbGJhcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldERyYXdpbmdPcHRpb25zKG9wdGlvbnMpOiB2b2lkXG5cdC8vIFNldHMgb3B0aW9ucyB0byBhbGwgdG9vbGJhciBpbnN0YW5jZXNcblx0c2V0RHJhd2luZ09wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Zm9yICh2YXIgdG9vbGJhcklkIGluIHRoaXMuX3Rvb2xiYXJzKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbGJhcnNbdG9vbGJhcklkXSBpbnN0YW5jZW9mIEwuRHJhd1Rvb2xiYXIpIHtcblx0XHRcdFx0dGhpcy5fdG9vbGJhcnNbdG9vbGJhcklkXS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdG9vbGJhckVuYWJsZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGVuYWJsZWRUb29sYmFyID0gZS50YXJnZXQ7XG5cblx0XHRmb3IgKHZhciB0b29sYmFySWQgaW4gdGhpcy5fdG9vbGJhcnMpIHtcblx0XHRcdGlmICh0aGlzLl90b29sYmFyc1t0b29sYmFySWRdICE9PSBlbmFibGVkVG9vbGJhcikge1xuXHRcdFx0XHR0aGlzLl90b29sYmFyc1t0b29sYmFySWRdLmRpc2FibGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRkcmF3Q29udHJvbFRvb2x0aXBzOiB0cnVlLFxuXHRkcmF3Q29udHJvbDogZmFsc2Vcbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLm9wdGlvbnMuZHJhd0NvbnRyb2wpIHtcblx0XHR0aGlzLmRyYXdDb250cm9sID0gbmV3IEwuQ29udHJvbC5EcmF3KCk7XG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuZHJhd0NvbnRyb2wpO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRHJhdy5Ub29sYmFyXG4gKiBAYWthIFRvb2xiYXJcbiAqXG4gKiBUaGUgdG9vbGJhciBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdWlcbiAqIFRoaXMgd2lsbCBiZSBkZXByZWNpYXRlZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICAgIHZhciB0b29sYmFyID0gTC5Ub29sYmFyKCk7XG4gKiAgICB0b29sYmFyLmFkZFRvb2xiYXIobWFwKTtcbiAqIGBgYFxuICpcbiAqICMjIyBEaXNhYmxpbmcgYSB0b29sYmFyXG4gKlxuICogSWYgeW91IGRvIG5vdCB3YW50IGEgcGFydGljdWxhciB0b29sYmFyIGluIHlvdXIgYXBwIHlvdSBjYW4gdHVybiBpdCBvZmYgYnkgc2V0dGluZyB0aGUgdG9vbGJhciB0byBmYWxzZS5cbiAqXG4gKiBgYGBqc1xuICogICAgICB2YXIgZHJhd0NvbnRyb2wgPSBuZXcgTC5Db250cm9sLkRyYXcoe1xuICogICAgICAgICAgZHJhdzogZmFsc2UsXG4gKiAgICAgICAgICBlZGl0OiB7XG4gKiAgICAgICAgICAgICAgZmVhdHVyZUdyb3VwOiBlZGl0YWJsZUxheWVyc1xuICogICAgICAgICAgfVxuICogICAgICB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyBEaXNhYmxpbmcgYSB0b29sYmFyIGl0ZW1cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB0dXJuIG9mZiBhIHBhcnRpY3VsYXIgdG9vbGJhciBpdGVtLCBzZXQgaXQgdG8gZmFsc2UuIFRoZSBmb2xsb3dpbmcgZGlzYWJsZXMgZHJhd2luZyBwb2x5Z29ucyBhbmRcbiAqIG1hcmtlcnMuIEl0IGFsc28gdHVybnMgb2ZmIHRoZSBhYmlsaXR5IHRvIGVkaXQgbGF5ZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAgICAgIHZhciBkcmF3Q29udHJvbCA9IG5ldyBMLkNvbnRyb2wuRHJhdyh7XG4gKiAgICAgICAgICBkcmF3OiB7XG4gKiAgICAgICAgICAgICAgcG9seWdvbjogZmFsc2UsXG4gKiAgICAgICAgICAgICAgbWFya2VyOiBmYWxzZVxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIGVkaXQ6IHtcbiAqICAgICAgICAgICAgICBmZWF0dXJlR3JvdXA6IGVkaXRhYmxlTGF5ZXJzLFxuICogICAgICAgICAgICAgIGVkaXQ6IGZhbHNlXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH0pO1xuICogYGBgXG4gKi9cbkwuVG9vbGJhciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIHRoZSB0b29sYmFyXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKG9wdGlvbnMpOiB2b2lkXG5cdC8vIFRvb2xiYXIgY29uc3RydWN0b3Jcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9tb2RlcyA9IHt9O1xuXHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnMgPSBbXTtcblx0XHR0aGlzLl9hY3RpdmVNb2RlID0gbnVsbDtcblxuXHRcdHZhciB2ZXJzaW9uID0gTC52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0Ly9JZiBWZXJzaW9uIGlzID49IDEuMi4wXG5cdFx0aWYgKHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSA9PT0gMSAmJiBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCkgPj0gMikge1xuXHRcdFx0TC5Ub29sYmFyLmluY2x1ZGUoTC5FdmVudGVkLnByb3RvdHlwZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuVG9vbGJhci5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IGJvb2xlYW5cblx0Ly8gR2V0cyBhIHRydWUvZmFsc2Ugb2Ygd2hldGhlciB0aGUgdG9vbGJhciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlTW9kZSAhPT0gbnVsbDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdm9pZFxuXHQvLyBEaXNhYmxlcyB0aGUgdG9vbGJhclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5kaXNhYmxlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRUb29sYmFyKG1hcCk6IEwuRG9tVXRpbFxuXHQvLyBBZGRzIHRoZSB0b29sYmFyIHRvIHRoZSBtYXAgYW5kIHJldHVybnMgdGhlIHRvb2xiYXIgZG9tIGVsZW1lbnRcblx0YWRkVG9vbGJhcjogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1kcmF3LXNlY3Rpb24nKSxcblx0XHRcdGJ1dHRvbkluZGV4ID0gMCxcblx0XHRcdGJ1dHRvbkNsYXNzUHJlZml4ID0gdGhpcy5fdG9vbGJhckNsYXNzIHx8ICcnLFxuXHRcdFx0bW9kZUhhbmRsZXJzID0gdGhpcy5nZXRNb2RlSGFuZGxlcnMobWFwKSxcblx0XHRcdGk7XG5cblx0XHR0aGlzLl90b29sYmFyQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy10b29sYmFyIGxlYWZsZXQtYmFyJyk7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IG1vZGVIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKG1vZGVIYW5kbGVyc1tpXS5lbmFibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXRNb2RlSGFuZGxlcihcblx0XHRcdFx0XHRtb2RlSGFuZGxlcnNbaV0uaGFuZGxlcixcblx0XHRcdFx0XHR0aGlzLl90b29sYmFyQ29udGFpbmVyLFxuXHRcdFx0XHRcdGJ1dHRvbkluZGV4KyssXG5cdFx0XHRcdFx0YnV0dG9uQ2xhc3NQcmVmaXgsXG5cdFx0XHRcdFx0bW9kZUhhbmRsZXJzW2ldLnRpdGxlXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgbm8gYnV0dG9ucyB3ZXJlIGFkZGVkLCBkbyBub3QgYWRkIHRoZSB0b29sYmFyXG5cdFx0aWYgKCFidXR0b25JbmRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNhdmUgYnV0dG9uIGluZGV4IG9mIHRoZSBsYXN0IGJ1dHRvbiwgLTEgYXMgd2Ugd291bGQgaGF2ZSArKyBhZnRlciB0aGUgbGFzdCBidXR0b25cblx0XHR0aGlzLl9sYXN0QnV0dG9uSW5kZXggPSAtLWJ1dHRvbkluZGV4O1xuXG5cdFx0Ly8gQ3JlYXRlIGVtcHR5IGFjdGlvbnMgcGFydCBvZiB0aGUgdG9vbGJhclxuXHRcdHRoaXMuX2FjdGlvbnNDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCd1bCcsICdsZWFmbGV0LWRyYXctYWN0aW9ucycpO1xuXG5cdFx0Ly8gQWRkIGRyYXcgYW5kIGNhbmNlbCBjb250YWluZXJzIHRvIHRoZSBjb250cm9sIGNvbnRhaW5lclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl90b29sYmFyQ29udGFpbmVyKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYWN0aW9uc0NvbnRhaW5lcik7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlVG9vbGJhcigpOiB2b2lkXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2xiYXIgYW5kIGRyb3BzIHRoZSBoYW5kbGVyIGV2ZW50IGxpc3RlbmVyc1xuXHRyZW1vdmVUb29sYmFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRGlzcG9zZSBlYWNoIGhhbmRsZXJcblx0XHRmb3IgKHZhciBoYW5kbGVySWQgaW4gdGhpcy5fbW9kZXMpIHtcblx0XHRcdGlmICh0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eShoYW5kbGVySWQpKSB7XG5cdFx0XHRcdC8vIFVuYmluZCBoYW5kbGVyIGJ1dHRvblxuXHRcdFx0XHR0aGlzLl9kaXNwb3NlQnV0dG9uKFxuXHRcdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uYnV0dG9uLFxuXHRcdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uaGFuZGxlci5lbmFibGUsXG5cdFx0XHRcdFx0dGhpcy5fbW9kZXNbaGFuZGxlcklkXS5oYW5kbGVyXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIGlzIGRpc2FibGVkXG5cdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uaGFuZGxlci5kaXNhYmxlKCk7XG5cblx0XHRcdFx0Ly8gVW5iaW5kIGhhbmRsZXJcblx0XHRcdFx0dGhpcy5fbW9kZXNbaGFuZGxlcklkXS5oYW5kbGVyXG5cdFx0XHRcdFx0Lm9mZignZW5hYmxlZCcsIHRoaXMuX2hhbmRsZXJBY3RpdmF0ZWQsIHRoaXMpXG5cdFx0XHRcdFx0Lm9mZignZGlzYWJsZWQnLCB0aGlzLl9oYW5kbGVyRGVhY3RpdmF0ZWQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9tb2RlcyA9IHt9O1xuXG5cdFx0Ly8gRGlzcG9zZSB0aGUgYWN0aW9ucyB0b29sYmFyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9hY3Rpb25CdXR0b25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fZGlzcG9zZUJ1dHRvbihcblx0XHRcdFx0dGhpcy5fYWN0aW9uQnV0dG9uc1tpXS5idXR0b24sXG5cdFx0XHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnNbaV0uY2FsbGJhY2ssXG5cdFx0XHRcdHRoaXNcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnMgPSBbXTtcblx0XHR0aGlzLl9hY3Rpb25zQ29udGFpbmVyID0gbnVsbDtcblx0fSxcblxuXHRfaW5pdE1vZGVIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlciwgY29udGFpbmVyLCBidXR0b25JbmRleCwgY2xhc3NOYW1lUHJlZGl4LCBidXR0b25UaXRsZSkge1xuXHRcdHZhciB0eXBlID0gaGFuZGxlci50eXBlO1xuXG5cdFx0dGhpcy5fbW9kZXNbdHlwZV0gPSB7fTtcblxuXHRcdHRoaXMuX21vZGVzW3R5cGVdLmhhbmRsZXIgPSBoYW5kbGVyO1xuXG5cdFx0dGhpcy5fbW9kZXNbdHlwZV0uYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHR0aXRsZTogYnV0dG9uVGl0bGUsXG5cdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZVByZWRpeCArICctJyArIHR5cGUsXG5cdFx0XHRjb250YWluZXI6IGNvbnRhaW5lcixcblx0XHRcdGNhbGxiYWNrOiB0aGlzLl9tb2Rlc1t0eXBlXS5oYW5kbGVyLmVuYWJsZSxcblx0XHRcdGNvbnRleHQ6IHRoaXMuX21vZGVzW3R5cGVdLmhhbmRsZXJcblx0XHR9KTtcblxuXHRcdHRoaXMuX21vZGVzW3R5cGVdLmJ1dHRvbkluZGV4ID0gYnV0dG9uSW5kZXg7XG5cblx0XHR0aGlzLl9tb2Rlc1t0eXBlXS5oYW5kbGVyXG5cdFx0XHQub24oJ2VuYWJsZWQnLCB0aGlzLl9oYW5kbGVyQWN0aXZhdGVkLCB0aGlzKVxuXHRcdFx0Lm9uKCdkaXNhYmxlZCcsIHRoaXMuX2hhbmRsZXJEZWFjdGl2YXRlZCwgdGhpcyk7XG5cdH0sXG5cblx0LyogRGV0ZWN0IGlPUyBiYXNlZCBvbiBicm93c2VyIFVzZXIgQWdlbnQsIGJhc2VkIG9uOlxuXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85MDM5ODg1ICovXG5cdF9kZXRlY3RJT1M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaU9TID0gKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW0pO1xuXHRcdHJldHVybiBpT1M7XG5cdH0sXG5cblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuXHRcdHZhciBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnLCBvcHRpb25zLmNvbnRhaW5lcik7XG5cdFx0Ly8gU2NyZWVuIHJlYWRlciB0YWdcblx0XHR2YXIgc3IgPSBMLkRvbVV0aWwuY3JlYXRlKCdzcGFuJywgJ3NyLW9ubHknLCBvcHRpb25zLmNvbnRhaW5lcik7XG5cblx0XHRsaW5rLmhyZWYgPSAnIyc7XG5cdFx0bGluay5hcHBlbmRDaGlsZChzcik7XG5cblx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xuXHRcdFx0bGluay50aXRsZSA9IG9wdGlvbnMudGl0bGU7XG5cdFx0XHRzci5pbm5lckhUTUwgPSBvcHRpb25zLnRpdGxlO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnRleHQpIHtcblx0XHRcdGxpbmsuaW5uZXJIVE1MID0gb3B0aW9ucy50ZXh0O1xuXHRcdFx0c3IuaW5uZXJIVE1MID0gb3B0aW9ucy50ZXh0O1xuXHRcdH1cblxuXHRcdC8qIGlPUyBkb2VzIG5vdCB1c2UgY2xpY2sgZXZlbnRzICovXG5cdFx0dmFyIGJ1dHRvbkV2ZW50ID0gdGhpcy5fZGV0ZWN0SU9TKCkgPyAndG91Y2hzdGFydCcgOiAnY2xpY2snO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdFx0Lm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuXHRcdFx0Lm9uKGxpbmssICdtb3VzZWRvd24nLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vbihsaW5rLCAnZGJsY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vbihsaW5rLCAndG91Y2hzdGFydCcsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuXHRcdFx0Lm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpXG5cdFx0XHQub24obGluaywgYnV0dG9uRXZlbnQsIG9wdGlvbnMuY2FsbGJhY2ssIG9wdGlvbnMuY29udGV4dCk7XG5cblx0XHRyZXR1cm4gbGluaztcblx0fSxcblxuXHRfZGlzcG9zZUJ1dHRvbjogZnVuY3Rpb24gKGJ1dHRvbiwgY2FsbGJhY2spIHtcblx0XHQvKiBpT1MgZG9lcyBub3QgdXNlIGNsaWNrIGV2ZW50cyAqL1xuXHRcdHZhciBidXR0b25FdmVudCA9IHRoaXMuX2RldGVjdElPUygpID8gJ3RvdWNoc3RhcnQnIDogJ2NsaWNrJztcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vZmYoYnV0dG9uLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vZmYoYnV0dG9uLCAnbW91c2Vkb3duJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdFx0XHQub2ZmKGJ1dHRvbiwgJ2RibGNsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdFx0XHQub2ZmKGJ1dHRvbiwgJ3RvdWNoc3RhcnQnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vZmYoYnV0dG9uLCAnY2xpY2snLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KVxuXHRcdFx0Lm9mZihidXR0b24sIGJ1dHRvbkV2ZW50LCBjYWxsYmFjayk7XG5cdH0sXG5cblx0X2hhbmRsZXJBY3RpdmF0ZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gRGlzYWJsZSBhY3RpdmUgbW9kZSAoaWYgcHJlc2VudClcblx0XHR0aGlzLmRpc2FibGUoKTtcblxuXHRcdC8vIENhY2hlIG5ldyBhY3RpdmUgZmVhdHVyZVxuXHRcdHRoaXMuX2FjdGl2ZU1vZGUgPSB0aGlzLl9tb2Rlc1tlLmhhbmRsZXJdO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2FjdGl2ZU1vZGUuYnV0dG9uLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItYnV0dG9uLWVuYWJsZWQnKTtcblxuXHRcdHRoaXMuX3Nob3dBY3Rpb25zVG9vbGJhcigpO1xuXG5cdFx0dGhpcy5maXJlKCdlbmFibGUnKTtcblx0fSxcblxuXHRfaGFuZGxlckRlYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faGlkZUFjdGlvbnNUb29sYmFyKCk7XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fYWN0aXZlTW9kZS5idXR0b24sICdsZWFmbGV0LWRyYXctdG9vbGJhci1idXR0b24tZW5hYmxlZCcpO1xuXG5cdFx0dGhpcy5fYWN0aXZlTW9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmZpcmUoJ2Rpc2FibGUnKTtcblx0fSxcblxuXHRfY3JlYXRlQWN0aW9uczogZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fYWN0aW9uc0NvbnRhaW5lcixcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLmdldEFjdGlvbnMoaGFuZGxlciksXG5cdFx0XHRsID0gYnV0dG9ucy5sZW5ndGgsXG5cdFx0XHRsaSwgZGksIGRsLCBidXR0b247XG5cblx0XHQvLyBEaXNwb3NlIHRoZSBhY3Rpb25zIHRvb2xiYXIgKHRvZG86IGRpc3Bvc2Ugb25seSBub3QgdXNlZCBidXR0b25zKVxuXHRcdGZvciAoZGkgPSAwLCBkbCA9IHRoaXMuX2FjdGlvbkJ1dHRvbnMubGVuZ3RoOyBkaSA8IGRsOyBkaSsrKSB7XG5cdFx0XHR0aGlzLl9kaXNwb3NlQnV0dG9uKHRoaXMuX2FjdGlvbkJ1dHRvbnNbZGldLmJ1dHRvbiwgdGhpcy5fYWN0aW9uQnV0dG9uc1tkaV0uY2FsbGJhY2spO1xuXHRcdH1cblx0XHR0aGlzLl9hY3Rpb25CdXR0b25zID0gW107XG5cblx0XHQvLyBSZW1vdmUgYWxsIG9sZCBidXR0b25zXG5cdFx0d2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoJ2VuYWJsZWQnIGluIGJ1dHRvbnNbaV0gJiYgIWJ1dHRvbnNbaV0uZW5hYmxlZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bGkgPSBMLkRvbVV0aWwuY3JlYXRlKCdsaScsICcnLCBjb250YWluZXIpO1xuXG5cdFx0XHRidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oe1xuXHRcdFx0XHR0aXRsZTogYnV0dG9uc1tpXS50aXRsZSxcblx0XHRcdFx0dGV4dDogYnV0dG9uc1tpXS50ZXh0LFxuXHRcdFx0XHRjb250YWluZXI6IGxpLFxuXHRcdFx0XHRjYWxsYmFjazogYnV0dG9uc1tpXS5jYWxsYmFjayxcblx0XHRcdFx0Y29udGV4dDogYnV0dG9uc1tpXS5jb250ZXh0XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fYWN0aW9uQnV0dG9ucy5wdXNoKHtcblx0XHRcdFx0YnV0dG9uOiBidXR0b24sXG5cdFx0XHRcdGNhbGxiYWNrOiBidXR0b25zW2ldLmNhbGxiYWNrXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X3Nob3dBY3Rpb25zVG9vbGJhcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBidXR0b25JbmRleCA9IHRoaXMuX2FjdGl2ZU1vZGUuYnV0dG9uSW5kZXgsXG5cdFx0XHRsYXN0QnV0dG9uSW5kZXggPSB0aGlzLl9sYXN0QnV0dG9uSW5kZXgsXG5cdFx0XHR0b29sYmFyUG9zaXRpb24gPSB0aGlzLl9hY3RpdmVNb2RlLmJ1dHRvbi5vZmZzZXRUb3AgLSAxO1xuXG5cdFx0Ly8gUmVjcmVhdGUgYWN0aW9uIGJ1dHRvbnMgb24gZXZlcnkgY2xpY2tcblx0XHR0aGlzLl9jcmVhdGVBY3Rpb25zKHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlcik7XG5cblx0XHQvLyBDb3JyZWN0bHkgcG9zaXRpb24gdGhlIGNhbmNlbCBidXR0b25cblx0XHR0aGlzLl9hY3Rpb25zQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRvb2xiYXJQb3NpdGlvbiArICdweCc7XG5cblx0XHRpZiAoYnV0dG9uSW5kZXggPT09IDApIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm90b3AnKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMtdG9wJyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ1dHRvbkluZGV4ID09PSBsYXN0QnV0dG9uSW5kZXgpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm9ib3R0b20nKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMtYm90dG9tJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWN0aW9uc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuVE9PTEJBUk9QRU5FRCk7XG5cdH0sXG5cblx0X2hpZGVBY3Rpb25zVG9vbGJhcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2FjdGlvbnNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm90b3AnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbGJhckNvbnRhaW5lciwgJ2xlYWZsZXQtZHJhdy10b29sYmFyLW5vYm90dG9tJyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2FjdGlvbnNDb250YWluZXIsICdsZWFmbGV0LWRyYXctYWN0aW9ucy10b3AnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fYWN0aW9uc0NvbnRhaW5lciwgJ2xlYWZsZXQtZHJhdy1hY3Rpb25zLWJvdHRvbScpO1xuXHRcdHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5UT09MQkFSQ0xPU0VEKTtcblx0fVxufSk7XG5cblxuXG5MLkRyYXcgPSBMLkRyYXcgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkRyYXcuVG9vbHRpcFxuICogQGFrYSBUb29sdGlwXG4gKlxuICogVGhlIHRvb2x0aXAgY2xhc3Mg4oCUIGl0IGlzIHVzZWQgdG8gZGlzcGxheSB0aGUgdG9vbHRpcCB3aGlsZSBkcmF3aW5nXG4gKiBUaGlzIHdpbGwgYmUgZGVwcmVjaWF0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAgICB2YXIgdG9vbHRpcCA9IEwuRHJhdy5Ub29sdGlwKCk7XG4gKiBgYGBcbiAqXG4gKi9cbkwuRHJhdy5Ub29sdGlwID0gTC5DbGFzcy5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBkcmF3IHN0YXRlXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKG1hcCk6IHZvaWRcblx0Ly8gVG9vbHRpcCBjb25zdHJ1Y3RvclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3BvcHVwUGFuZSA9IG1hcC5fcGFuZXMucG9wdXBQYW5lO1xuXHRcdHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5vcHRpb25zLmRyYXdDb250cm9sVG9vbHRpcHMgP1xuXHRcdFx0TC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy10b29sdGlwJywgdGhpcy5fcG9wdXBQYW5lKSA6IG51bGw7XG5cdFx0dGhpcy5fc2luZ2xlTGluZUxhYmVsID0gZmFsc2U7XG5cblx0XHR0aGlzLl9tYXAub24oJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZU91dCwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNwb3NlKCk6IHZvaWRcblx0Ly8gUmVtb3ZlIFRvb2x0aXAgRE9NIGFuZCB1bmJpbmQgZXZlbnRzXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5fcG9wdXBQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZUNvbnRlbnQobGFiZWxUZXh0KTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSB0b29sdGlwIHRleHQgdG8gc3RyaW5nIGluIGZ1bmN0aW9uIGNhbGxcblx0dXBkYXRlQ29udGVudDogZnVuY3Rpb24gKGxhYmVsVGV4dCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0bGFiZWxUZXh0LnN1YnRleHQgPSBsYWJlbFRleHQuc3VidGV4dCB8fCAnJztcblxuXHRcdC8vIHVwZGF0ZSB0aGUgdmVydGljYWwgcG9zaXRpb24gKG9ubHkgaWYgY2hhbmdlZClcblx0XHRpZiAobGFiZWxUZXh0LnN1YnRleHQubGVuZ3RoID09PSAwICYmICF0aGlzLl9zaW5nbGVMaW5lTGFiZWwpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWRyYXctdG9vbHRpcC1zaW5nbGUnKTtcblx0XHRcdHRoaXMuX3NpbmdsZUxpbmVMYWJlbCA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGxhYmVsVGV4dC5zdWJ0ZXh0Lmxlbmd0aCA+IDAgJiYgdGhpcy5fc2luZ2xlTGluZUxhYmVsKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2x0aXAtc2luZ2xlJyk7XG5cdFx0XHR0aGlzLl9zaW5nbGVMaW5lTGFiZWwgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID1cblx0XHRcdChsYWJlbFRleHQuc3VidGV4dC5sZW5ndGggPiAwID9cblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwibGVhZmxldC1kcmF3LXRvb2x0aXAtc3VidGV4dFwiPicgKyBsYWJlbFRleHQuc3VidGV4dCArICc8L3NwYW4+JyArICc8YnIgLz4nIDogJycpICtcblx0XHRcdCc8c3Bhbj4nICsgbGFiZWxUZXh0LnRleHQgKyAnPC9zcGFuPic7XG5cblx0XHRpZiAoIWxhYmVsVGV4dC50ZXh0ICYmICFsYWJlbFRleHQuc3VidGV4dCkge1xuXHRcdFx0dGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdpbmhlcml0Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZVBvc2l0aW9uKGxhdGxuZyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgbG9jYXRpb24gb2YgdGhlIHRvb2x0aXBcblx0dXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLFxuXHRcdFx0dG9vbHRpcENvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdGlmICh0aGlzLl92aXNpYmxlKSB7XG5cdFx0XHRcdHRvb2x0aXBDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdpbmhlcml0Jztcblx0XHRcdH1cblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0b29sdGlwQ29udGFpbmVyLCBwb3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2hvd0FzRXJyb3IoKTogdGhpc1xuXHQvLyBBcHBsaWVzIGVycm9yIGNsYXNzIHRvIHRvb2x0aXBcblx0c2hvd0FzRXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1lcnJvci1kcmF3LXRvb2x0aXAnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVFcnJvcigpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGVycm9yIGNsYXNzIGZyb20gdGhlIHRvb2x0aXBcblx0cmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1lcnJvci1kcmF3LXRvb2x0aXAnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkRyYXdUb29sYmFyXG4gKiBAYWthIFRvb2xiYXJcbiAqL1xuTC5EcmF3VG9vbGJhciA9IEwuVG9vbGJhci5leHRlbmQoe1xuXG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnZHJhdydcblx0fSxcblxuXHRvcHRpb25zOiB7XG5cdFx0cG9seWxpbmU6IHt9LFxuXHRcdHBvbHlnb246IHt9LFxuXHRcdHJlY3RhbmdsZToge30sXG5cdFx0Y2lyY2xlOiB7fSxcblx0XHRtYXJrZXI6IHt9LFxuXHRcdGNpcmNsZW1hcmtlcjoge31cblx0fSxcblxuXHQvLyBAbWV0aG9kIGluaXRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEVuc3VyZSB0aGF0IHRoZSBvcHRpb25zIGFyZSBtZXJnZWQgY29ycmVjdGx5IHNpbmNlIEwuZXh0ZW5kIGlzIG9ubHkgc2hhbGxvd1xuXHRcdGZvciAodmFyIHR5cGUgaW4gdGhpcy5vcHRpb25zKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zW3R5cGVdKSB7XG5cdFx0XHRcdFx0b3B0aW9uc1t0eXBlXSA9IEwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnNbdHlwZV0sIG9wdGlvbnNbdHlwZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9vbGJhckNsYXNzID0gJ2xlYWZsZXQtZHJhdy1kcmF3Jztcblx0XHRMLlRvb2xiYXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldE1vZGVIYW5kbGVycygpOiBvYmplY3Rcblx0Ly8gR2V0IG1vZGUgaGFuZGxlcnMgaW5mb3JtYXRpb25cblx0Z2V0TW9kZUhhbmRsZXJzOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLnBvbHlsaW5lLFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5EcmF3LlBvbHlsaW5lKG1hcCwgdGhpcy5vcHRpb25zLnBvbHlsaW5lKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLnBvbHlsaW5lXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiB0aGlzLm9wdGlvbnMucG9seWdvbixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5Qb2x5Z29uKG1hcCwgdGhpcy5vcHRpb25zLnBvbHlnb24pLFxuXHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmJ1dHRvbnMucG9seWdvblxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLnJlY3RhbmdsZSxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5SZWN0YW5nbGUobWFwLCB0aGlzLm9wdGlvbnMucmVjdGFuZ2xlKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLnJlY3RhbmdsZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLmNpcmNsZSxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5DaXJjbGUobWFwLCB0aGlzLm9wdGlvbnMuY2lyY2xlKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLmNpcmNsZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLm1hcmtlcixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5NYXJrZXIobWFwLCB0aGlzLm9wdGlvbnMubWFya2VyKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLm1hcmtlclxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLmNpcmNsZW1hcmtlcixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5DaXJjbGVNYXJrZXIobWFwLCB0aGlzLm9wdGlvbnMuY2lyY2xlbWFya2VyKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLmNpcmNsZW1hcmtlclxuXHRcdFx0fVxuXHRcdF07XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBY3Rpb25zKCk6IG9iamVjdFxuXHQvLyBHZXQgYWN0aW9uIGluZm9ybWF0aW9uXG5cdGdldEFjdGlvbnM6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogaGFuZGxlci5jb21wbGV0ZVNoYXBlLFxuXHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmZpbmlzaC50aXRsZSxcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmZpbmlzaC50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogaGFuZGxlci5jb21wbGV0ZVNoYXBlLFxuXHRcdFx0XHRjb250ZXh0OiBoYW5kbGVyXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiBoYW5kbGVyLmRlbGV0ZUxhc3RWZXJ0ZXgsXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIudW5kby50aXRsZSxcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLnVuZG8udGV4dCxcblx0XHRcdFx0Y2FsbGJhY2s6IGhhbmRsZXIuZGVsZXRlTGFzdFZlcnRleCxcblx0XHRcdFx0Y29udGV4dDogaGFuZGxlclxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5hY3Rpb25zLnRpdGxlLFxuXHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuYWN0aW9ucy50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5kaXNhYmxlLFxuXHRcdFx0XHRjb250ZXh0OiB0aGlzXG5cdFx0XHR9XG5cdFx0XTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wdGlvbnMoKTogdm9pZFxuXHQvLyBTZXRzIHRoZSBvcHRpb25zIHRvIHRoZSB0b29sYmFyXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0aGlzLl9tb2Rlcykge1xuXHRcdFx0aWYgKHRoaXMuX21vZGVzLmhhc093blByb3BlcnR5KHR5cGUpICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcblx0XHRcdFx0dGhpcy5fbW9kZXNbdHlwZV0uaGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnNbdHlwZV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cblxuXG4vKkwuTWFwLm1lcmdlT3B0aW9ucyh7XG4gZWRpdENvbnRyb2w6IHRydWVcbiB9KTsqL1xuLyoqXG4gKiBAY2xhc3MgTC5FZGl0VG9vbGJhclxuICogQGFrYSBFZGl0VG9vbGJhclxuICovXG5MLkVkaXRUb29sYmFyID0gTC5Ub29sYmFyLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnZWRpdCdcblx0fSxcblxuXHRvcHRpb25zOiB7XG5cdFx0ZWRpdDoge1xuXHRcdFx0c2VsZWN0ZWRQYXRoT3B0aW9uczoge1xuXHRcdFx0XHRkYXNoQXJyYXk6ICcxMCwgMTAnLFxuXG5cdFx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRcdGZpbGxDb2xvcjogJyNmZTU3YTEnLFxuXHRcdFx0XHRmaWxsT3BhY2l0eTogMC4xLFxuXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gdXNlciB0aGUgZXhpc3RpbmcgbGF5ZXJzIGNvbG9yXG5cdFx0XHRcdG1haW50YWluQ29sb3I6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW1vdmU6IHt9LFxuXHRcdHBvbHk6IG51bGwsXG5cdFx0ZmVhdHVyZUdyb3VwOiBudWxsIC8qIFJFUVVJUkVEISBUT0RPOiBwZXJoYXBzIGlmIG5vdCBzZXQgdGhlbiBhbGwgbGF5ZXJzIG9uIHRoZSBtYXAgYXJlIHNlbGVjdGFibGU/ICovXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIE5lZWQgdG8gc2V0IHRoaXMgbWFudWFsbHkgc2luY2UgbnVsbCBpcyBhbiBhY2NlcHRhYmxlIHZhbHVlIGhlcmVcblx0XHRpZiAob3B0aW9ucy5lZGl0KSB7XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuZWRpdC5zZWxlY3RlZFBhdGhPcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRvcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnM7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuZWRpdC5zZWxlY3RlZFBhdGhPcHRpb25zLCBvcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMucmVtb3ZlKSB7XG5cdFx0XHRvcHRpb25zLnJlbW92ZSA9IEwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMucmVtb3ZlLCBvcHRpb25zLnJlbW92ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMucG9seSkge1xuXHRcdFx0b3B0aW9ucy5wb2x5ID0gTC5leHRlbmQoe30sIHRoaXMub3B0aW9ucy5wb2x5LCBvcHRpb25zLnBvbHkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Rvb2xiYXJDbGFzcyA9ICdsZWFmbGV0LWRyYXctZWRpdCc7XG5cdFx0TC5Ub29sYmFyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9zZWxlY3RlZEZlYXR1cmVDb3VudCA9IDA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRNb2RlSGFuZGxlcnMoKTogb2JqZWN0XG5cdC8vIEdldCBtb2RlIGhhbmRsZXJzIGluZm9ybWF0aW9uXG5cdGdldE1vZGVIYW5kbGVyczogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBmZWF0dXJlR3JvdXAgPSB0aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwO1xuXHRcdHJldHVybiBbXG5cdFx0XHR7XG5cdFx0XHRcdGVuYWJsZWQ6IHRoaXMub3B0aW9ucy5lZGl0LFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5FZGl0VG9vbGJhci5FZGl0KG1hcCwge1xuXHRcdFx0XHRcdGZlYXR1cmVHcm91cDogZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRcdHNlbGVjdGVkUGF0aE9wdGlvbnM6IHRoaXMub3B0aW9ucy5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnMsXG5cdFx0XHRcdFx0cG9seTogdGhpcy5vcHRpb25zLnBvbHlcblx0XHRcdFx0fSksXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5lZGl0XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiB0aGlzLm9wdGlvbnMucmVtb3ZlLFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5FZGl0VG9vbGJhci5EZWxldGUobWFwLCB7XG5cdFx0XHRcdFx0ZmVhdHVyZUdyb3VwOiBmZWF0dXJlR3JvdXBcblx0XHRcdFx0fSksXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5yZW1vdmVcblx0XHRcdH1cblx0XHRdO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QWN0aW9ucygpOiBvYmplY3Rcblx0Ly8gR2V0IGFjdGlvbnMgaW5mb3JtYXRpb25cblx0Z2V0QWN0aW9uczogZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHR2YXIgYWN0aW9ucyA9IFtcblx0XHRcdHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLnNhdmUudGl0bGUsXG5cdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLnNhdmUudGV4dCxcblx0XHRcdFx0Y2FsbGJhY2s6IHRoaXMuX3NhdmUsXG5cdFx0XHRcdGNvbnRleHQ6IHRoaXNcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYWN0aW9ucy5jYW5jZWwudGl0bGUsXG5cdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLmNhbmNlbC50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5kaXNhYmxlLFxuXHRcdFx0XHRjb250ZXh0OiB0aGlzXG5cdFx0XHR9XG5cdFx0XTtcblxuXHRcdGlmIChoYW5kbGVyLnJlbW92ZUFsbExheWVycykge1xuXHRcdFx0YWN0aW9ucy5wdXNoKHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLmNsZWFyQWxsLnRpdGxlLFxuXHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYWN0aW9ucy5jbGVhckFsbC50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5fY2xlYXJBbGxMYXllcnMsXG5cdFx0XHRcdGNvbnRleHQ6IHRoaXNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY3Rpb25zO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkVG9vbGJhcihtYXApOiBMLkRvbVV0aWxcblx0Ly8gQWRkcyB0aGUgdG9vbGJhciB0byB0aGUgbWFwXG5cdGFkZFRvb2xiYXI6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY29udGFpbmVyID0gTC5Ub29sYmFyLnByb3RvdHlwZS5hZGRUb29sYmFyLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWQoKTtcblxuXHRcdHRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXAub24oJ2xheWVyYWRkIGxheWVycmVtb3ZlJywgdGhpcy5fY2hlY2tEaXNhYmxlZCwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlVG9vbGJhcigpOiB2b2lkXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2xiYXIgZnJvbSB0aGUgbWFwXG5cdHJlbW92ZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwLm9mZignbGF5ZXJhZGQgbGF5ZXJyZW1vdmUnLCB0aGlzLl9jaGVja0Rpc2FibGVkLCB0aGlzKTtcblxuXHRcdEwuVG9vbGJhci5wcm90b3R5cGUucmVtb3ZlVG9vbGJhci5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB2b2lkXG5cdC8vIERpc2FibGVzIHRoZSB0b29sYmFyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuZW5hYmxlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWN0aXZlTW9kZS5oYW5kbGVyLnJldmVydExheWVycygpO1xuXG5cdFx0TC5Ub29sYmFyLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0X3NhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuc2F2ZSgpO1xuXHRcdGlmICh0aGlzLl9hY3RpdmVNb2RlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuZGlzYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2xlYXJBbGxMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIucmVtb3ZlQWxsTGF5ZXJzKCk7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZU1vZGUpIHtcblx0XHRcdHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGVja0Rpc2FibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGZlYXR1cmVHcm91cCA9IHRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXAsXG5cdFx0XHRoYXNMYXllcnMgPSBmZWF0dXJlR3JvdXAuZ2V0TGF5ZXJzKCkubGVuZ3RoICE9PSAwLFxuXHRcdFx0YnV0dG9uO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5lZGl0KSB7XG5cdFx0XHRidXR0b24gPSB0aGlzLl9tb2Rlc1tMLkVkaXRUb29sYmFyLkVkaXQuVFlQRV0uYnV0dG9uO1xuXG5cdFx0XHRpZiAoaGFzTGF5ZXJzKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhidXR0b24sICdsZWFmbGV0LWRpc2FibGVkJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoYnV0dG9uLCAnbGVhZmxldC1kaXNhYmxlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRidXR0b24uc2V0QXR0cmlidXRlKFxuXHRcdFx0XHQndGl0bGUnLFxuXHRcdFx0XHRoYXNMYXllcnMgP1xuXHRcdFx0XHRcdEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXRcblx0XHRcdFx0XHQ6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXREaXNhYmxlZFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnJlbW92ZSkge1xuXHRcdFx0YnV0dG9uID0gdGhpcy5fbW9kZXNbTC5FZGl0VG9vbGJhci5EZWxldGUuVFlQRV0uYnV0dG9uO1xuXG5cdFx0XHRpZiAoaGFzTGF5ZXJzKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhidXR0b24sICdsZWFmbGV0LWRpc2FibGVkJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoYnV0dG9uLCAnbGVhZmxldC1kaXNhYmxlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRidXR0b24uc2V0QXR0cmlidXRlKFxuXHRcdFx0XHQndGl0bGUnLFxuXHRcdFx0XHRoYXNMYXllcnMgP1xuXHRcdFx0XHRcdEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLnJlbW92ZVxuXHRcdFx0XHRcdDogTC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmJ1dHRvbnMucmVtb3ZlRGlzYWJsZWRcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRWRpdFRvb2xiYXIuRWRpdFxuICogQGFrYSBFZGl0VG9vbGJhci5FZGl0XG4gKi9cbkwuRWRpdFRvb2xiYXIuRWRpdCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRzdGF0aWNzOiB7XG5cdFx0VFlQRTogJ2VkaXQnXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHRcdC8vIFN0b3JlIHRoZSBzZWxlY3RhYmxlIGxheWVyIGdyb3VwIGZvciBlYXNlIG9mIGFjY2Vzc1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IG9wdGlvbnMuZmVhdHVyZUdyb3VwO1xuXG5cdFx0aWYgKCEodGhpcy5fZmVhdHVyZUdyb3VwIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuZmVhdHVyZUdyb3VwIG11c3QgYmUgYSBMLkZlYXR1cmVHcm91cCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkVkaXRUb29sYmFyLkVkaXQuVFlQRTtcblxuXHRcdHZhciB2ZXJzaW9uID0gTC52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0Ly9JZiBWZXJzaW9uIGlzID49IDEuMi4wXG5cdFx0aWYgKHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSA9PT0gMSAmJiBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCkgPj0gMikge1xuXHRcdFx0TC5FZGl0VG9vbGJhci5FZGl0LmluY2x1ZGUoTC5FdmVudGVkLnByb3RvdHlwZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRWRpdFRvb2xiYXIuRWRpdC5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdm9pZFxuXHQvLyBFbmFibGUgdGhlIGVkaXQgdG9vbGJhclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCAhdGhpcy5faGFzQXZhaWxhYmxlTGF5ZXJzKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5maXJlKCdlbmFibGVkJywge2hhbmRsZXI6IHRoaXMudHlwZX0pO1xuXHRcdC8vdGhpcyBkaXNhYmxlIG90aGVyIGhhbmRsZXJzXG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFNUQVJULCB7aGFuZGxlcjogdGhpcy50eXBlfSk7XG5cdFx0Ly9hbGxvdyBkcmF3TGF5ZXIgdG8gYmUgdXBkYXRlZCBiZWZvcmUgYmVnaW5uaW5nIGVkaXRpb24uXG5cblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cFxuXHRcdFx0Lm9uKCdsYXllcmFkZCcsIHRoaXMuX2VuYWJsZUxheWVyRWRpdCwgdGhpcylcblx0XHRcdC5vbignbGF5ZXJyZW1vdmUnLCB0aGlzLl9kaXNhYmxlTGF5ZXJFZGl0LCB0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdm9pZFxuXHQvLyBEaXNhYmxlIHRoZSBlZGl0IHRvb2xiYXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9mZWF0dXJlR3JvdXBcblx0XHRcdC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fZW5hYmxlTGF5ZXJFZGl0LCB0aGlzKVxuXHRcdFx0Lm9mZignbGF5ZXJyZW1vdmUnLCB0aGlzLl9kaXNhYmxlTGF5ZXJFZGl0LCB0aGlzKTtcblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFNUT1AsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblx0XHR0aGlzLmZpcmUoJ2Rpc2FibGVkJywge2hhbmRsZXI6IHRoaXMudHlwZX0pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKTogdm9pZFxuXHQvLyBBZGQgbGlzdGVuZXIgaG9va3MgZm9yIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRtYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcblxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcih0aGlzLl9lbmFibGVMYXllckVkaXQsIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwID0gbmV3IEwuRHJhdy5Ub29sdGlwKHRoaXMuX21hcCk7XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe1xuXHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLmVkaXQudG9vbHRpcC50ZXh0LFxuXHRcdFx0XHRzdWJ0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLmVkaXQudG9vbHRpcC5zdWJ0ZXh0XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUXVpY2tseSBhY2Nlc3MgdGhlIHRvb2x0aXAgdG8gdXBkYXRlIGZvciBpbnRlcnNlY3Rpb24gY2hlY2tpbmdcblx0XHRcdG1hcC5fZWRpdFRvb2x0aXAgPSB0aGlzLl90b29sdGlwO1xuXG5cdFx0XHR0aGlzLl91cGRhdGVUb29sdGlwKCk7XG5cblx0XHRcdHRoaXMuX21hcFxuXHRcdFx0XHQub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9uKEwuRHJhdy5FdmVudC5FRElUVkVSVEVYLCB0aGlzLl91cGRhdGVUb29sdGlwLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmb3IgdGhpcyBoYW5kbGVyXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0Ly8gQ2xlYW4gdXAgc2VsZWN0ZWQgbGF5ZXJzLlxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcih0aGlzLl9kaXNhYmxlTGF5ZXJFZGl0LCB0aGlzKTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGhlIGJhY2t1cHMgb2YgdGhlIG9yaWdpbmFsIGxheWVyc1xuXHRcdFx0dGhpcy5fdW5lZGl0ZWRMYXllclByb3BzID0ge307XG5cblx0XHRcdHRoaXMuX3Rvb2x0aXAuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cblx0XHRcdHRoaXMuX21hcFxuXHRcdFx0XHQub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpXG5cdFx0XHRcdC5vZmYoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZihMLkRyYXcuRXZlbnQuRURJVFZFUlRFWCwgdGhpcy5fdXBkYXRlVG9vbHRpcCwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmV2ZXJ0TGF5ZXJzKCk6IHZvaWRcblx0Ly8gUmV2ZXJ0IGVhY2ggbGF5ZXIncyBnZW9tZXRyeSBjaGFuZ2VzXG5cdHJldmVydExheWVyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9yZXZlcnRMYXllcihsYXllcik7XG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzYXZlKCk6IHZvaWRcblx0Ly8gU2F2ZSB0aGUgbGF5ZXIgZ2VvbWV0cmllc1xuXHRzYXZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVkaXRlZExheWVycyA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xuXHRcdFx0aWYgKGxheWVyLmVkaXRlZCkge1xuXHRcdFx0XHRlZGl0ZWRMYXllcnMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHRsYXllci5lZGl0ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVEVELCB7bGF5ZXJzOiBlZGl0ZWRMYXllcnN9KTtcblx0fSxcblxuXHRfYmFja3VwTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0pIHtcblx0XHRcdC8vIFBvbHlsaW5lLCBQb2x5Z29uIG9yIFJlY3RhbmdsZVxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5bGluZSB8fCBsYXllciBpbnN0YW5jZW9mIEwuUG9seWdvbiB8fCBsYXllciBpbnN0YW5jZW9mIEwuUmVjdGFuZ2xlKSB7XG5cdFx0XHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0gPSB7XG5cdFx0XHRcdFx0bGF0bG5nczogTC5MYXRMbmdVdGlsLmNsb25lTGF0TG5ncyhsYXllci5nZXRMYXRMbmdzKCkpXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGUpIHtcblx0XHRcdFx0dGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXSA9IHtcblx0XHRcdFx0XHRsYXRsbmc6IEwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZyhsYXllci5nZXRMYXRMbmcoKSksXG5cdFx0XHRcdFx0cmFkaXVzOiBsYXllci5nZXRSYWRpdXMoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyIHx8IGxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGVNYXJrZXIpIHsgLy8gTWFya2VyXG5cdFx0XHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0gPSB7XG5cdFx0XHRcdFx0bGF0bG5nOiBMLkxhdExuZ1V0aWwuY2xvbmVMYXRMbmcobGF5ZXIuZ2V0TGF0TG5nKCkpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUb29sdGlwVGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAoe1xuXHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxcblx0XHRcdHN1YnRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnN1YnRleHRcblx0XHR9KTtcblx0fSxcblxuXHRfdXBkYXRlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKTtcblx0fSxcblxuXHRfcmV2ZXJ0TGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuVXRpbC5zdGFtcChsYXllcik7XG5cdFx0bGF5ZXIuZWRpdGVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblx0XHRcdC8vIFBvbHlsaW5lLCBQb2x5Z29uIG9yIFJlY3RhbmdsZVxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5bGluZSB8fCBsYXllciBpbnN0YW5jZW9mIEwuUG9seWdvbiB8fCBsYXllciBpbnN0YW5jZW9mIEwuUmVjdGFuZ2xlKSB7XG5cdFx0XHRcdGxheWVyLnNldExhdExuZ3ModGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5sYXRsbmdzKTtcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkNpcmNsZSkge1xuXHRcdFx0XHRsYXllci5zZXRMYXRMbmcodGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5sYXRsbmcpO1xuXHRcdFx0XHRsYXllci5zZXRSYWRpdXModGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5yYWRpdXMpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyIHx8IGxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGVNYXJrZXIpIHsgLy8gTWFya2VyIG9yIENpcmNsZU1hcmtlclxuXHRcdFx0XHRsYXllci5zZXRMYXRMbmcodGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5sYXRsbmcpO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXllci5maXJlKCdyZXZlcnQtZWRpdGVkJywge2xheWVyOiBsYXllcn0pO1xuXHRcdH1cblx0fSxcblxuXHRfZW5hYmxlTGF5ZXJFZGl0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZSxcblx0XHRcdHBhdGhPcHRpb25zLCBwb2x5O1xuXG5cdFx0Ly8gQmFjayB1cCB0aGlzIGxheWVyIChpZiBoYXZlbid0IGJlZm9yZSlcblx0XHR0aGlzLl9iYWNrdXBMYXllcihsYXllcik7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnBvbHkpIHtcblx0XHRcdHBvbHkgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMucG9seSk7XG5cdFx0XHRsYXllci5vcHRpb25zLnBvbHkgPSBwb2x5O1xuXHRcdH1cblxuXHRcdC8vIFNldCBkaWZmZXJlbnQgc3R5bGUgZm9yIGVkaXRpbmcgbW9kZVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0ZWRQYXRoT3B0aW9ucykge1xuXHRcdFx0cGF0aE9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRQYXRoT3B0aW9ucyk7XG5cblx0XHRcdC8vIFVzZSB0aGUgZXhpc3RpbmcgY29sb3Igb2YgdGhlIGxheWVyXG5cdFx0XHRpZiAocGF0aE9wdGlvbnMubWFpbnRhaW5Db2xvcikge1xuXHRcdFx0XHRwYXRoT3B0aW9ucy5jb2xvciA9IGxheWVyLm9wdGlvbnMuY29sb3I7XG5cdFx0XHRcdHBhdGhPcHRpb25zLmZpbGxDb2xvciA9IGxheWVyLm9wdGlvbnMuZmlsbENvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXllci5vcHRpb25zLm9yaWdpbmFsID0gTC5leHRlbmQoe30sIGxheWVyLm9wdGlvbnMpO1xuXHRcdFx0bGF5ZXIub3B0aW9ucy5lZGl0aW5nID0gcGF0aE9wdGlvbnM7XG5cblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0aWYgKGxheWVyLmVkaXRpbmcpIHtcblx0XHRcdFx0bGF5ZXIuZWRpdGluZy5lbmFibGUoKTtcblx0XHRcdH1cblx0XHRcdGxheWVyLmRyYWdnaW5nLmVuYWJsZSgpO1xuXHRcdFx0bGF5ZXJcblx0XHRcdFx0Lm9uKCdkcmFnZW5kJywgdGhpcy5fb25NYXJrZXJEcmFnRW5kKVxuXHRcdFx0XHQvLyAjVE9ETzogcmVtb3ZlIHdoZW4gbGVhZmxldCBmaW5hbGx5IGZpeGVzIHRoZWlyIGRyYWdnYWJsZSBzbyBpdCdzIHRvdWNoIGZyaWVuZGx5IGFnYWluLlxuXHRcdFx0XHQub24oJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9uKCd0b3VjaGVuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcylcblx0XHRcdFx0Lm9uKCdNU1BvaW50ZXJVcCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLmVkaXRpbmcuZW5hYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kaXNhYmxlTGF5ZXJFZGl0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLmVkaXRlZCA9IGZhbHNlO1xuXHRcdGlmIChsYXllci5lZGl0aW5nKSB7XG5cdFx0XHRsYXllci5lZGl0aW5nLmRpc2FibGUoKTtcblx0XHR9XG5cblx0XHRkZWxldGUgbGF5ZXIub3B0aW9ucy5lZGl0aW5nO1xuXHRcdGRlbGV0ZSBsYXllci5vcHRpb25zLm9yaWdpbmFsO1xuXHRcdC8vIFJlc2V0IGxheWVyIHN0eWxlcyB0byB0aGF0IG9mIGJlZm9yZSBzZWxlY3Rcblx0XHRpZiAodGhpcy5fc2VsZWN0ZWRQYXRoT3B0aW9ucykge1xuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIpIHtcblx0XHRcdFx0dGhpcy5fdG9nZ2xlTWFya2VySGlnaGxpZ2h0KGxheWVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlc2V0IHRoZSBsYXllciBzdHlsZSB0byB3aGF0IGlzIHdhcyBiZWZvcmUgYmVpbmcgc2VsZWN0ZWRcblx0XHRcdFx0bGF5ZXIuc2V0U3R5bGUobGF5ZXIub3B0aW9ucy5wcmV2aW91c09wdGlvbnMpO1xuXHRcdFx0XHQvLyByZW1vdmUgdGhlIGNhY2hlZCBvcHRpb25zIGZvciB0aGUgbGF5ZXIgb2JqZWN0XG5cdFx0XHRcdGRlbGV0ZSBsYXllci5vcHRpb25zLnByZXZpb3VzT3B0aW9ucztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0bGF5ZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuXHRcdFx0bGF5ZXJcblx0XHRcdFx0Lm9mZignZHJhZ2VuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHRcdC5vZmYoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2hlbmQnLCB0aGlzLl9vbk1hcmtlckRyYWdFbmQsIHRoaXMpXG5cdFx0XHRcdC5vZmYoJ01TUG9pbnRlclVwJywgdGhpcy5fb25NYXJrZXJEcmFnRW5kLCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGF5ZXIuZWRpdGluZy5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGUubGF0bG5nKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUudGFyZ2V0O1xuXHRcdGxheWVyLmVkaXRlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRNT1ZFLCB7bGF5ZXI6IGxheWVyfSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciB0b3VjaEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KHRvdWNoRXZlbnQpLFxuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHRlLnRhcmdldC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fSxcblxuXHRfaGFzQXZhaWxhYmxlTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZlYXR1cmVHcm91cC5nZXRMYXllcnMoKS5sZW5ndGggIT09IDA7XG5cdH1cbn0pO1xuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5FZGl0VG9vbGJhci5EZWxldGVcbiAqIEBha2EgRWRpdFRvb2xiYXIuRGVsZXRlXG4gKi9cbkwuRWRpdFRvb2xiYXIuRGVsZXRlID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAncmVtb3ZlJyAvLyBub3QgZGVsZXRlIGFzIGRlbGV0ZSBpcyByZXNlcnZlZCBpbiBqc1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaW50aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHRMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHRcdC8vIFN0b3JlIHRoZSBzZWxlY3RhYmxlIGxheWVyIGdyb3VwIGZvciBlYXNlIG9mIGFjY2Vzc1xuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVycyA9IHRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXA7XG5cblx0XHRpZiAoISh0aGlzLl9kZWxldGFibGVMYXllcnMgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5mZWF0dXJlR3JvdXAgbXVzdCBiZSBhIEwuRmVhdHVyZUdyb3VwJyk7XG5cdFx0fVxuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkVkaXRUb29sYmFyLkRlbGV0ZS5UWVBFO1xuXG5cdFx0dmFyIHZlcnNpb24gPSBMLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHQvL0lmIFZlcnNpb24gaXMgPj0gMS4yLjBcblx0XHRpZiAocGFyc2VJbnQodmVyc2lvblswXSwgMTApID09PSAxICYmIHBhcnNlSW50KHZlcnNpb25bMV0sIDEwKSA+PSAyKSB7XG5cdFx0XHRMLkVkaXRUb29sYmFyLkRlbGV0ZS5pbmNsdWRlKEwuRXZlbnRlZC5wcm90b3R5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkVkaXRUb29sYmFyLkRlbGV0ZS5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB2b2lkXG5cdC8vIEVuYWJsZSB0aGUgZGVsZXRlIHRvb2xiYXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgIXRoaXMuX2hhc0F2YWlsYWJsZUxheWVycygpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZmlyZSgnZW5hYmxlZCcsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblxuXHRcdHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5ERUxFVEVTVEFSVCwge2hhbmRsZXI6IHRoaXMudHlwZX0pO1xuXG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVyc1xuXHRcdFx0Lm9uKCdsYXllcmFkZCcsIHRoaXMuX2VuYWJsZUxheWVyRGVsZXRlLCB0aGlzKVxuXHRcdFx0Lm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX2Rpc2FibGVMYXllckRlbGV0ZSwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHZvaWRcblx0Ly8gRGlzYWJsZSB0aGUgZGVsZXRlIHRvb2xiYXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVyc1xuXHRcdFx0Lm9mZignbGF5ZXJhZGQnLCB0aGlzLl9lbmFibGVMYXllckRlbGV0ZSwgdGhpcylcblx0XHRcdC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fZGlzYWJsZUxheWVyRGVsZXRlLCB0aGlzKTtcblxuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkRFTEVURVNUT1AsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblxuXHRcdHRoaXMuZmlyZSgnZGlzYWJsZWQnLCB7aGFuZGxlcjogdGhpcy50eXBlfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXJcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKG1hcCkge1xuXHRcdFx0bWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XG5cblx0XHRcdHRoaXMuX2RlbGV0YWJsZUxheWVycy5lYWNoTGF5ZXIodGhpcy5fZW5hYmxlTGF5ZXJEZWxldGUsIHRoaXMpO1xuXHRcdFx0dGhpcy5fZGVsZXRlZExheWVycyA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBMLkRyYXcuVG9vbHRpcCh0aGlzLl9tYXApO1xuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHt0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLnJlbW92ZS50b29sdGlwLnRleHR9KTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9kZWxldGFibGVMYXllcnMuZWFjaExheWVyKHRoaXMuX2Rpc2FibGVMYXllckRlbGV0ZSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9kZWxldGVkTGF5ZXJzID0gbnVsbDtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcC5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblxuXHRcdFx0dGhpcy5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHJldmVydExheWVycygpOiB2b2lkXG5cdC8vIFJldmVydCB0aGUgZGVsZXRlZCBsYXllcnMgYmFjayB0byB0aGVpciBwcmlvciBzdGF0ZS5cblx0cmV2ZXJ0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvZiB0aGUgZGVsZXRlZCBsYXllcnMgYW5kIGFkZCB0aGVtIGJhY2sgaW50byB0aGUgZmVhdHVyZUdyb3VwXG5cdFx0dGhpcy5fZGVsZXRlZExheWVycy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9kZWxldGFibGVMYXllcnMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmV2ZXJ0LWRlbGV0ZWQnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzYXZlKCk6IHZvaWRcblx0Ly8gU2F2ZSBkZWxldGVkIGxheWVyc1xuXHRzYXZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkRFTEVURUQsIHtsYXllcnM6IHRoaXMuX2RlbGV0ZWRMYXllcnN9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUFsbExheWVycygpOiB2b2lkXG5cdC8vIFJlbW92ZSBhbGwgZGVsYXRlYWJsZSBsYXllcnNcblx0cmVtb3ZlQWxsTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvZiB0aGUgZGVsYXRlYWJsZSBsYXllcnMgYW5kIGFkZCByZW1vdmUgdGhlbVxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVycy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVMYXllcih7bGF5ZXI6IGxheWVyfSk7XG5cdFx0fSwgdGhpcyk7XG5cdFx0dGhpcy5zYXZlKCk7XG5cdH0sXG5cblx0X2VuYWJsZUxheWVyRGVsZXRlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLm9uKCdjbGljaycsIHRoaXMuX3JlbW92ZUxheWVyLCB0aGlzKTtcblx0fSxcblxuXHRfZGlzYWJsZUxheWVyRGVsZXRlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLm9mZignY2xpY2snLCB0aGlzLl9yZW1vdmVMYXllciwgdGhpcyk7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSB0aGUgZGVsZXRlZCBsYXllcnMgc28gd2UgY2FuJ3QgYWNjaWRlbnRhbGx5IHJldmVydCBpZiB0aGUgdXNlciBwcmVzc2VzIGNhbmNlbFxuXHRcdHRoaXMuX2RlbGV0ZWRMYXllcnMucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVMYXllcjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0IHx8IGU7XG5cblx0XHR0aGlzLl9kZWxldGFibGVMYXllcnMucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXG5cdFx0dGhpcy5fZGVsZXRlZExheWVycy5hZGRMYXllcihsYXllcik7XG5cblx0XHRsYXllci5maXJlKCdkZWxldGVkJyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24oZS5sYXRsbmcpO1xuXHR9LFxuXG5cdF9oYXNBdmFpbGFibGVMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVsZXRhYmxlTGF5ZXJzLmdldExheWVycygpLmxlbmd0aCAhPT0gMDtcblx0fVxufSk7XG5cblxuXG59KHdpbmRvdywgZG9jdW1lbnQpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQuZHJhdy1zcmMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet-draw/dist/leaflet.draw-src.js\n");

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzVjN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxvQ0FBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUIsS0FBSyxNQUFNLEVBSU47QUFDTCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoZGVmYXVsdExldmVsLCBmYWxzZSk7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAoKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/loglevel/lib/loglevel.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/Common/CSS/GPgeneralWidget.css":
/*!********************************************!*\
  !*** ./src/Common/CSS/GPgeneralWidget.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL0NTUy9HUGdlbmVyYWxXaWRnZXQuY3NzP2YyZGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL0NTUy9HUGdlbmVyYWxXaWRnZXQuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Common/CSS/GPgeneralWidget.css\n");

/***/ }),

/***/ "./src/Common/CSS/GPreverseGeocoding.css":
/*!***********************************************!*\
  !*** ./src/Common/CSS/GPreverseGeocoding.css ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL0NTUy9HUHJldmVyc2VHZW9jb2RpbmcuY3NzPzk2YjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL0NTUy9HUHJldmVyc2VHZW9jb2RpbmcuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Common/CSS/GPreverseGeocoding.css\n");

/***/ }),

/***/ "./src/Common/Controls/ReverseGeocodingDOM.js":
/*!****************************************************!*\
  !*** ./src/Common/Controls/ReverseGeocodingDOM.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar ReverseGeocodingDOM = {\n  /**\n  * Add uuid to the tag ID\n  * @param {String} id - id selector\n  * @returns {String} uid - id selector with an unique id\n  */\n  _addUID: function _addUID(id) {\n    var uid = this._uid ? id + \"-\" + this._uid : id;\n    return uid;\n  },\n\n  /**\n   * Main container (DOM)\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createMainContainerElement: function _createMainContainerElement() {\n    var container = document.createElement(\"div\");\n    container.id = this._addUID(\"GPreverseGeocoding\");\n    container.className = \"GPwidget\";\n    return container;\n  },\n  // ################################################################### //\n  // ################### Methods of main container ##################### //\n  // ################################################################### //\n\n  /**\n   * Hidden checkbox for minimizing/maximizing\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createShowReverseGeocodingElement: function _createShowReverseGeocodingElement() {\n    var input = document.createElement(\"input\");\n    input.id = this._addUID(\"GPshowReverseGeocoding\");\n    input.type = \"checkbox\";\n    return input;\n  },\n\n  /**\n   * Show ReverseGeocoding\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createShowReverseGeocodingPictoElement: function _createShowReverseGeocodingPictoElement() {\n    // contexte d'execution\n    var self = this;\n    var label = document.createElement(\"label\");\n    label.id = this._addUID(\"GPshowReverseGeocodingPicto\");\n    label.className = \"GPshowAdvancedToolPicto\";\n    label.htmlFor = this._addUID(\"GPshowReverseGeocoding\");\n    label.title = \"Ouvrir la recherche inverse\"; // Close all results and panels when minimizing the widget\n\n    if (label.addEventListener) {\n      label.addEventListener(\"click\", function () {\n        self.onShowReverseGeocodingClick();\n      });\n    } else if (label.attachEvent) {\n      label.attachEvent(\"onclick\", function () {\n        self.onShowReverseGeocodingClick();\n      });\n    }\n\n    var spanOpen = document.createElement(\"span\");\n    spanOpen.id = this._addUID(\"GPshowReverseGeocodingOpen\");\n    spanOpen.className = \"GPshowAdvancedToolOpen\";\n    label.appendChild(spanOpen);\n    return label;\n  },\n\n  /**\n   * Create Waiting Panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingWaitingElement: function _createReverseGeocodingWaitingElement() {\n    var div = document.createElement(\"div\");\n    div.id = this._addUID(\"GPreverseGeocodingCalcWaitingContainer\");\n    div.className = \"GPreverseGeocodingCalcWaitingContainerHidden\";\n    var p = document.createElement(\"p\");\n    p.className = \"GPreverseGeocodingCalcWaiting\";\n    p.innerHTML = \"Recherche en cours...\";\n    div.appendChild(p);\n    return div;\n  },\n\n  /**\n   * Reverse geocoding results panel element.\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingResultsPanelElement: function _createReverseGeocodingResultsPanelElement() {\n    var resultsPanelDiv = document.createElement(\"div\");\n    resultsPanelDiv.id = this._addUID(\"GPreverseGeocodingResultsPanel\");\n    resultsPanelDiv.className = \"GPpanel GPreverseGeocodingComponentHidden\";\n    return resultsPanelDiv;\n  },\n\n  /**\n   * Reverse geocoding results list.\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingResultsListElement: function _createReverseGeocodingResultsListElement() {\n    var container = document.createElement(\"div\");\n    container.id = this._addUID(\"GPreverseGeocodingResultsList\"); // Results are dynamically filled in Javascript by reverse geocoding service\n\n    return container;\n  },\n\n  /**\n   *  Add Result\n   * (results dynamically generate !)\n   *\n   * @param {String} locationDescription - reverse geocoded location results\n   * @param {Number} id - ID\n   */\n  _createReverseGeocodingResultElement: function _createReverseGeocodingResultElement(locationDescription, id) {\n    // contexte\n    var context = this;\n    var container = document.getElementById(this._addUID(\"GPreverseGeocodingResultsList\"));\n    var div = document.createElement(\"div\");\n    div.id = this._addUID(\"ReverseGeocodedLocation_\" + id);\n    div.className = \"GPautoCompleteProposal\";\n    div.innerHTML = locationDescription;\n    div.title = locationDescription;\n\n    if (div.addEventListener) {\n      div.addEventListener(\"mouseover\", function (e) {\n        context.onReverseGeocodingResultMouseOver(e);\n      });\n      div.addEventListener(\"mouseout\", function (e) {\n        context.onReverseGeocodingResultMouseOut(e);\n      });\n      div.addEventListener(\"click\", function (e) {\n        if (typeof context.onReverseGeocodingResultClick === \"function\") {\n          context.onReverseGeocodingResultClick(e);\n        }\n      });\n    } else if (div.attachEvent) {\n      div.attachEvent(\"onmouseover\", function (e) {\n        context.onReverseGeocodingResultMouseOver(e);\n      });\n      div.attachEvent(\"onmouseout\", function (e) {\n        context.onReverseGeocodingResultMouseOut(e);\n      });\n      div.attachEvent(\"onclick\", function (e) {\n        if (typeof context.onReverseGeocodingResultClick === \"function\") {\n          context.onReverseGeocodingResultClick(e);\n        }\n      });\n    }\n\n    container.appendChild(div);\n  },\n  // ################################################################### //\n  // ######################### Inputs panel ############################ //\n  // ################################################################### //\n\n  /**\n   * Create Container Panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingPanelElement: function _createReverseGeocodingPanelElement() {\n    var div = document.createElement(\"div\");\n    div.id = this._addUID(\"GPreverseGeocodingPanel\");\n    div.className = \"GPpanel\";\n    return div;\n  },\n\n  /**\n   * Create Header Panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingPanelHeaderElement: function _createReverseGeocodingPanelHeaderElement() {\n    var container = document.createElement(\"div\");\n    container.className = \"GPpanelHeader\"; // info: on sépare les appels pour la création du picto de retour,\n    // du titre et de la croix de fermeture pour les récupérer dans le composant\n\n    return container;\n  },\n\n  /**\n   * Create return picto in panel header\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingPanelReturnPictoElement: function _createReverseGeocodingPanelReturnPictoElement() {\n    // contexte\n    var self = this;\n    var divNew = document.createElement(\"div\");\n    divNew.id = this._addUID(\"GPreverseGeocodingReturnPicto\");\n    divNew.title = \"Nouvelle recherche\";\n    divNew.className = \"GPreverseGeocodingReturnPictoHidden\";\n\n    if (divNew.addEventListener) {\n      divNew.addEventListener(\"click\", function (e) {\n        document.getElementById(self._addUID(\"GPreverseGeocodingResultsPanel\")).className = \"GProuteComponentHidden\";\n        document.getElementById(self._addUID(\"GPreverseGeocodingForm\")).className = \"\";\n        document.getElementById(self._addUID(\"GPreverseGeocodingHeaderTitle\")).innerHTML = \"Recherche inverse\";\n        document.getElementById(self._addUID(\"GPreverseGeocodingReturnPicto\")).className = \"GPreverseGeocodingReturnPictoHidden\";\n        self.onGPreverseGeocodingReturnPictoClick(e);\n      });\n    } else if (divNew.attachEvent) {\n      divNew.attachEvent(\"onclick\", function (e) {\n        document.getElementById(self._addUID(\"GPreverseGeocodingResultsPanel\")).className = \"GProuteComponentHidden\";\n        document.getElementById(self._addUID(\"GPreverseGeocodingForm\")).className = \"\";\n        document.getElementById(self._addUID(\"GPreverseGeocodingHeaderTitle\")).innerHTML = \"Recherche inverse\";\n        document.getElementById(self._addUID(\"GPreverseGeocodingReturnPicto\")).className = \"GPreverseGeocodingReturnPictoHidden\";\n        self.onGPreverseGeocodingReturnPictoClick(e);\n      });\n    }\n\n    return divNew;\n  },\n\n  /**\n   * Create Header Title Panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingPanelTitleElement: function _createReverseGeocodingPanelTitleElement() {\n    var div = document.createElement(\"div\");\n    div.className = \"GPpanelTitle\";\n    div.id = this._addUID(\"GPreverseGeocodingHeaderTitle\");\n    div.innerHTML = \"Recherche inverse\";\n    return div;\n  },\n\n  /**\n   * Create Header close div\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingPanelCloseElement: function _createReverseGeocodingPanelCloseElement() {\n    // contexte\n    var self = this;\n    var divClose = document.createElement(\"div\");\n    divClose.id = this._addUID(\"GPreverseGeocodingPanelClose\");\n    divClose.className = \"GPpanelClose\";\n    divClose.title = \"Fermer le panneau\"; // Link panel close / visibility checkbox\n\n    if (divClose.addEventListener) {\n      divClose.addEventListener(\"click\", function () {\n        document.getElementById(self._addUID(\"GPshowReverseGeocodingPicto\")).click();\n      }, false);\n    } else if (divClose.attachEvent) {\n      divClose.attachEvent(\"onclick\", function () {\n        document.getElementById(self._addUID(\"GPshowReverseGeocodingPicto\")).click();\n      });\n    }\n\n    return divClose;\n  },\n\n  /**\n   * Create Form\n   * see event !\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingPanelFormElement: function _createReverseGeocodingPanelFormElement() {\n    // contexte d'execution\n    var self = this;\n    var form = document.createElement(\"form\");\n    form.id = this._addUID(\"GPreverseGeocodingForm\");\n\n    if (form.addEventListener) {\n      form.addEventListener(\"submit\", function (e) {\n        e.preventDefault();\n        self.onReverseGeocodingSubmit();\n      });\n    } else if (form.attachEvent) {\n      form.attachEvent(\"onsubmit\", function (e) {\n        e.preventDefault();\n        self.onReverseGeocodingSubmit();\n      });\n    }\n\n    return form;\n  },\n  // ################################################################### //\n  // ####################### Choice mode into form ##################### //\n  // ################################################################### //\n\n  /**\n   * Create Container to Mode choice geocoding type\n   *\n   * @param {Array} resources - geocoding resources to be displayed (and used)\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingFormModeChoiceGeocodingTypeElement: function _createReverseGeocodingFormModeChoiceGeocodingTypeElement(resources) {\n    // contexte d'execution\n    var context = this;\n    var div = document.createElement(\"div\");\n    div.className = \"GPflexInput\";\n    var label = document.createElement(\"label\");\n    label.className = \"GPreverseGeocodingCodeLabel\";\n    label.innerHTML = \"Recherche par\";\n    label.title = \"Recherche par\";\n    div.appendChild(label);\n    var select = document.createElement(\"select\");\n    select.className = \"GPreverseGeocodingCode\"; // gestionnaire d'evenement : on stocke la valeur du type de geocodage,\n    // utilisé dans la requête de géocodage inverse\n\n    if (select.addEventListener) {\n      select.addEventListener(\"change\", function (e) {\n        context.onReverseGeocodingTypeChange(e);\n      });\n    } else if (select.attachEvent) {\n      select.attachEvent(\"onchange\", function (e) {\n        context.onReverseGeocodingTypeChange(e);\n      });\n    } // on prend soit les valeurs passées par l'utilisateur, soit des valeurs par défaut\n\n\n    if (!resources || !Array.isArray(resources)) {\n      resources = [\"StreetAddress\", \"PositionOfInterest\", \"CadastralParcel\"];\n    }\n\n    for (var i = 0; i < resources.length; i++) {\n      switch (resources[i]) {\n        case \"PositionOfInterest\":\n          var POIOption = document.createElement(\"option\");\n          POIOption.value = \"PositionOfInterest\";\n          POIOption.text = \"Lieux/toponymes\";\n          select.appendChild(POIOption);\n          break;\n\n        case \"StreetAddress\":\n          var SAOption = document.createElement(\"option\");\n          SAOption.value = \"StreetAddress\";\n          SAOption.text = \"Adresses\";\n          select.appendChild(SAOption);\n          break;\n\n        case \"CadastralParcel\":\n          var CPOption = document.createElement(\"option\");\n          CPOption.value = \"CadastralParcel\";\n          CPOption.text = \"Parcelles cadastrales\";\n          select.appendChild(CPOption);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    div.appendChild(select);\n    return div;\n  },\n\n  /**\n   * Create Container to Mode choice geocoding delimitation\n   *\n   * @param {Array} delimitations - geocoding delimitations to be displayed (and used)\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingFormModeChoiceGeocodingDelimitationElement: function _createReverseGeocodingFormModeChoiceGeocodingDelimitationElement(delimitations) {\n    // contexte d'execution\n    var context = this;\n    var div = document.createElement(\"div\");\n    div.className = \"GPflexInput\";\n    var label = document.createElement(\"label\");\n    label.className = \"GPreverseGeocodingCodeLabel\";\n    label.innerHTML = \"Délimitation\";\n    label.title = \"Délimitation\";\n    div.appendChild(label);\n    var select = document.createElement(\"select\");\n    select.className = \"GPreverseGeocodingCode\"; // gestionnaire d'evenement : on stocke la valeur du type de délimitation,\n    // et on modifie l'événement de pointage sur la carte en fonction\n\n    if (select.addEventListener) {\n      select.addEventListener(\"change\", function (e) {\n        context.onReverseGeocodingDelimitationChange(e);\n      });\n    } else if (select.attachEvent) {\n      select.attachEvent(\"onchange\", function (e) {\n        context.onReverseGeocodingDelimitationChange(e);\n      });\n    } // on prend soit les valeurs passées par l'utilisateur, soit des valeurs par défaut\n\n\n    if (!delimitations || !Array.isArray(delimitations)) {\n      delimitations = [\"Point\", \"Circle\", \"Extent\"];\n    }\n\n    for (var i = 0; i < delimitations.length; i++) {\n      switch (delimitations[i].toLowerCase()) {\n        case \"point\":\n          var pointOption = document.createElement(\"option\");\n          pointOption.value = \"point\";\n          pointOption.text = \"Pointer un lieu\";\n          select.appendChild(pointOption);\n          break;\n\n        case \"circle\":\n          var circleOption = document.createElement(\"option\");\n          circleOption.value = \"circle\";\n          circleOption.text = \"Dessiner un cercle\";\n          select.appendChild(circleOption);\n          break;\n\n        case \"extent\":\n          var extentOption = document.createElement(\"option\");\n          extentOption.value = \"extent\";\n          extentOption.text = \"Dessiner une emprise\";\n          select.appendChild(extentOption);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    div.appendChild(select);\n    return div;\n  },\n  // ################################################################### //\n  // ########################### Submit Form ########################### //\n  // ################################################################### //\n\n  /**\n   * Create Submit Form Element\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createReverseGeocodingSubmitFormElement: function _createReverseGeocodingSubmitFormElement() {\n    var input = document.createElement(\"input\");\n    input.id = this._addUID(\"GPreverseGeocodingSubmit\");\n    input.className = \"GPinputSubmit\";\n    input.type = \"submit\";\n    input.value = \"Rechercher\";\n    return input;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReverseGeocodingDOM);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL1JldmVyc2VHZW9jb2RpbmdET00uanM/YTM1NiJdLCJuYW1lcyI6WyJSZXZlcnNlR2VvY29kaW5nRE9NIiwiX2FkZFVJRCIsImlkIiwidWlkIiwiX3VpZCIsIl9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsIl9jcmVhdGVTaG93UmV2ZXJzZUdlb2NvZGluZ0VsZW1lbnQiLCJpbnB1dCIsInR5cGUiLCJfY3JlYXRlU2hvd1JldmVyc2VHZW9jb2RpbmdQaWN0b0VsZW1lbnQiLCJzZWxmIiwibGFiZWwiLCJodG1sRm9yIiwidGl0bGUiLCJhZGRFdmVudExpc3RlbmVyIiwib25TaG93UmV2ZXJzZUdlb2NvZGluZ0NsaWNrIiwiYXR0YWNoRXZlbnQiLCJzcGFuT3BlbiIsImFwcGVuZENoaWxkIiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdXYWl0aW5nRWxlbWVudCIsImRpdiIsInAiLCJpbm5lckhUTUwiLCJfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdHNQYW5lbEVsZW1lbnQiLCJyZXN1bHRzUGFuZWxEaXYiLCJfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdHNMaXN0RWxlbWVudCIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUmVzdWx0RWxlbWVudCIsImxvY2F0aW9uRGVzY3JpcHRpb24iLCJjb250ZXh0IiwiZ2V0RWxlbWVudEJ5SWQiLCJlIiwib25SZXZlcnNlR2VvY29kaW5nUmVzdWx0TW91c2VPdmVyIiwib25SZXZlcnNlR2VvY29kaW5nUmVzdWx0TW91c2VPdXQiLCJvblJldmVyc2VHZW9jb2RpbmdSZXN1bHRDbGljayIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxFbGVtZW50IiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdQYW5lbEhlYWRlckVsZW1lbnQiLCJfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1BhbmVsUmV0dXJuUGljdG9FbGVtZW50IiwiZGl2TmV3Iiwib25HUHJldmVyc2VHZW9jb2RpbmdSZXR1cm5QaWN0b0NsaWNrIiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdQYW5lbFRpdGxlRWxlbWVudCIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxDbG9zZUVsZW1lbnQiLCJkaXZDbG9zZSIsImNsaWNrIiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdQYW5lbEZvcm1FbGVtZW50IiwiZm9ybSIsInByZXZlbnREZWZhdWx0Iiwib25SZXZlcnNlR2VvY29kaW5nU3VibWl0IiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdGb3JtTW9kZUNob2ljZUdlb2NvZGluZ1R5cGVFbGVtZW50IiwicmVzb3VyY2VzIiwic2VsZWN0Iiwib25SZXZlcnNlR2VvY29kaW5nVHlwZUNoYW5nZSIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJsZW5ndGgiLCJQT0lPcHRpb24iLCJ2YWx1ZSIsInRleHQiLCJTQU9wdGlvbiIsIkNQT3B0aW9uIiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdGb3JtTW9kZUNob2ljZUdlb2NvZGluZ0RlbGltaXRhdGlvbkVsZW1lbnQiLCJkZWxpbWl0YXRpb25zIiwib25SZXZlcnNlR2VvY29kaW5nRGVsaW1pdGF0aW9uQ2hhbmdlIiwidG9Mb3dlckNhc2UiLCJwb2ludE9wdGlvbiIsImNpcmNsZU9wdGlvbiIsImV4dGVudE9wdGlvbiIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nU3VibWl0Rm9ybUVsZW1lbnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEsSUFBSUEsbUJBQW1CLEdBQUc7QUFFdEI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxTQUFPLEVBQUcsaUJBQVVDLEVBQVYsRUFBYztBQUNwQixRQUFJQyxHQUFHLEdBQUksS0FBS0MsSUFBTixHQUFjRixFQUFFLEdBQUcsR0FBTCxHQUFXLEtBQUtFLElBQTlCLEdBQXFDRixFQUEvQztBQUNBLFdBQU9D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QUFDSSxjQUFJQyxZQUFZLEdBQUcvRCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbkI7QUFDQThELHNCQUFZLENBQUNWLEtBQWIsR0FBcUIsUUFBckI7QUFDQVUsc0JBQVksQ0FBQ1QsSUFBYixHQUFvQixzQkFBcEI7QUFDQVIsZ0JBQU0sQ0FBQy9CLFdBQVAsQ0FBbUJnRCxZQUFuQjtBQUNBOztBQUNKO0FBQ0k7QUFwQlI7QUFzQkg7O0FBRUQ5QyxPQUFHLENBQUNGLFdBQUosQ0FBZ0IrQixNQUFoQjtBQUVBLFdBQU83QixHQUFQO0FBQ0gsR0FqYnFCO0FBbWJ0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNJK0MsMENBQXdDLEVBQUcsb0RBQVk7QUFDbkQsUUFBSTVELEtBQUssR0FBR0osUUFBUSxDQUFDQyxhQUFULENBQXVCLE9BQXZCLENBQVo7QUFDQUcsU0FBSyxDQUFDVCxFQUFOLEdBQVcsS0FBS0QsT0FBTCxDQUFhLDBCQUFiLENBQVg7QUFDQVUsU0FBSyxDQUFDRixTQUFOLEdBQWtCLGVBQWxCO0FBQ0FFLFNBQUssQ0FBQ0MsSUFBTixHQUFhLFFBQWI7QUFDQUQsU0FBSyxDQUFDaUQsS0FBTixHQUFjLFlBQWQ7QUFFQSxXQUFPakQsS0FBUDtBQUNIO0FBcGNxQixDQUExQjtBQXdjZVgsa0ZBQWYiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL0NvbnRyb2xzL1JldmVyc2VHZW9jb2RpbmdET00uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmV2ZXJzZUdlb2NvZGluZ0RPTSA9IHtcblxuICAgIC8qKlxuICAgICogQWRkIHV1aWQgdG8gdGhlIHRhZyBJRFxuICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gaWQgc2VsZWN0b3JcbiAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVpZCAtIGlkIHNlbGVjdG9yIHdpdGggYW4gdW5pcXVlIGlkXG4gICAgKi9cbiAgICBfYWRkVUlEIDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciB1aWQgPSAodGhpcy5fdWlkKSA/IGlkICsgXCItXCIgKyB0aGlzLl91aWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIHVpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFpbiBjb250YWluZXIgKERPTSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5pZCA9IHRoaXMuX2FkZFVJRChcIkdQcmV2ZXJzZUdlb2NvZGluZ1wiKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1B3aWRnZXRcIjtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMgTWV0aG9kcyBvZiBtYWluIGNvbnRhaW5lciAjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiBIaWRkZW4gY2hlY2tib3ggZm9yIG1pbmltaXppbmcvbWF4aW1pemluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZVNob3dSZXZlcnNlR2VvY29kaW5nRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBpbnB1dC5pZCA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd1JldmVyc2VHZW9jb2RpbmdcIik7XG4gICAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBSZXZlcnNlR2VvY29kaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlU2hvd1JldmVyc2VHZW9jb2RpbmdQaWN0b0VsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbnRleHRlIGQnZXhlY3V0aW9uXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgIGxhYmVsLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93UmV2ZXJzZUdlb2NvZGluZ1BpY3RvXCIpO1xuICAgICAgICBsYWJlbC5jbGFzc05hbWUgPSBcIkdQc2hvd0FkdmFuY2VkVG9vbFBpY3RvXCI7XG4gICAgICAgIGxhYmVsLmh0bWxGb3IgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dSZXZlcnNlR2VvY29kaW5nXCIpO1xuICAgICAgICBsYWJlbC50aXRsZSA9IFwiT3V2cmlyIGxhIHJlY2hlcmNoZSBpbnZlcnNlXCI7XG5cbiAgICAgICAgLy8gQ2xvc2UgYWxsIHJlc3VsdHMgYW5kIHBhbmVscyB3aGVuIG1pbmltaXppbmcgdGhlIHdpZGdldFxuICAgICAgICBpZiAobGFiZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uU2hvd1JldmVyc2VHZW9jb2RpbmdDbGljaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFiZWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGxhYmVsLmF0dGFjaEV2ZW50KFwib25jbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vblNob3dSZXZlcnNlR2VvY29kaW5nQ2xpY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYW5PcGVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW5PcGVuLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93UmV2ZXJzZUdlb2NvZGluZ09wZW5cIik7XG4gICAgICAgIHNwYW5PcGVuLmNsYXNzTmFtZSA9IFwiR1BzaG93QWR2YW5jZWRUb29sT3BlblwiO1xuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChzcGFuT3Blbik7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgV2FpdGluZyBQYW5lbFxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdXYWl0aW5nRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IHRoaXMuX2FkZFVJRChcIkdQcmV2ZXJzZUdlb2NvZGluZ0NhbGNXYWl0aW5nQ29udGFpbmVyXCIpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJHUHJldmVyc2VHZW9jb2RpbmdDYWxjV2FpdGluZ0NvbnRhaW5lckhpZGRlblwiO1xuXG4gICAgICAgIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgIHAuY2xhc3NOYW1lID0gXCJHUHJldmVyc2VHZW9jb2RpbmdDYWxjV2FpdGluZ1wiO1xuICAgICAgICBwLmlubmVySFRNTCA9IFwiUmVjaGVyY2hlIGVuIGNvdXJzLi4uXCI7XG5cbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHApO1xuXG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldmVyc2UgZ2VvY29kaW5nIHJlc3VsdHMgcGFuZWwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUmVzdWx0c1BhbmVsRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHNQYW5lbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHJlc3VsdHNQYW5lbERpdi5pZCA9IHRoaXMuX2FkZFVJRChcIkdQcmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdHNQYW5lbFwiKTtcbiAgICAgICAgcmVzdWx0c1BhbmVsRGl2LmNsYXNzTmFtZSA9IFwiR1BwYW5lbCBHUHJldmVyc2VHZW9jb2RpbmdDb21wb25lbnRIaWRkZW5cIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHNQYW5lbERpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZSBnZW9jb2RpbmcgcmVzdWx0cyBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdSZXN1bHRzTGlzdEVsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBjb250YWluZXIuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHJldmVyc2VHZW9jb2RpbmdSZXN1bHRzTGlzdFwiKTtcbiAgICAgICAgLy8gUmVzdWx0cyBhcmUgZHluYW1pY2FsbHkgZmlsbGVkIGluIEphdmFzY3JpcHQgYnkgcmV2ZXJzZSBnZW9jb2Rpbmcgc2VydmljZVxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAgQWRkIFJlc3VsdFxuICAgICAqIChyZXN1bHRzIGR5bmFtaWNhbGx5IGdlbmVyYXRlICEpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRpb25EZXNjcmlwdGlvbiAtIHJldmVyc2UgZ2VvY29kZWQgbG9jYXRpb24gcmVzdWx0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAtIElEXG4gICAgICovXG4gICAgX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdSZXN1bHRFbGVtZW50IDogZnVuY3Rpb24gKGxvY2F0aW9uRGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIC8vIGNvbnRleHRlXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1ByZXZlcnNlR2VvY29kaW5nUmVzdWx0c0xpc3RcIikpO1xuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaWQgPSB0aGlzLl9hZGRVSUQoXCJSZXZlcnNlR2VvY29kZWRMb2NhdGlvbl9cIiArIGlkKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiR1BhdXRvQ29tcGxldGVQcm9wb3NhbFwiO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gbG9jYXRpb25EZXNjcmlwdGlvbjtcbiAgICAgICAgZGl2LnRpdGxlID0gbG9jYXRpb25EZXNjcmlwdGlvbjtcblxuICAgICAgICBpZiAoZGl2LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vblJldmVyc2VHZW9jb2RpbmdSZXN1bHRNb3VzZU92ZXIoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdE1vdXNlT3V0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0Lm9uUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdENsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vblJldmVyc2VHZW9jb2RpbmdSZXN1bHRDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXYuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGRpdi5hdHRhY2hFdmVudChcIm9ubW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vblJldmVyc2VHZW9jb2RpbmdSZXN1bHRNb3VzZU92ZXIoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpdi5hdHRhY2hFdmVudChcIm9ubW91c2VvdXRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdE1vdXNlT3V0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXYuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0Lm9uUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdENsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vblJldmVyc2VHZW9jb2RpbmdSZXN1bHRDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBJbnB1dHMgcGFuZWwgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBDb250YWluZXIgUGFuZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxFbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1ByZXZlcnNlR2VvY29kaW5nUGFuZWxcIik7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIkdQcGFuZWxcIjtcblxuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgSGVhZGVyIFBhbmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1BhbmVsSGVhZGVyRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcIkdQcGFuZWxIZWFkZXJcIjtcbiAgICAgICAgLy8gaW5mbzogb24gc8OpcGFyZSBsZXMgYXBwZWxzIHBvdXIgbGEgY3LDqWF0aW9uIGR1IHBpY3RvIGRlIHJldG91cixcbiAgICAgICAgLy8gZHUgdGl0cmUgZXQgZGUgbGEgY3JvaXggZGUgZmVybWV0dXJlIHBvdXIgbGVzIHLDqWN1cMOpcmVyIGRhbnMgbGUgY29tcG9zYW50XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSByZXR1cm4gcGljdG8gaW4gcGFuZWwgaGVhZGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1BhbmVsUmV0dXJuUGljdG9FbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb250ZXh0ZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRpdk5ldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdk5ldy5pZCA9IHRoaXMuX2FkZFVJRChcIkdQcmV2ZXJzZUdlb2NvZGluZ1JldHVyblBpY3RvXCIpO1xuICAgICAgICBkaXZOZXcudGl0bGUgPSBcIk5vdXZlbGxlIHJlY2hlcmNoZVwiO1xuICAgICAgICBkaXZOZXcuY2xhc3NOYW1lID0gXCJHUHJldmVyc2VHZW9jb2RpbmdSZXR1cm5QaWN0b0hpZGRlblwiO1xuICAgICAgICBpZiAoZGl2TmV3LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRpdk5ldy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUHJldmVyc2VHZW9jb2RpbmdSZXN1bHRzUGFuZWxcIikpLmNsYXNzTmFtZSA9IFwiR1Byb3V0ZUNvbXBvbmVudEhpZGRlblwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuX2FkZFVJRChcIkdQcmV2ZXJzZUdlb2NvZGluZ0Zvcm1cIikpLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1ByZXZlcnNlR2VvY29kaW5nSGVhZGVyVGl0bGVcIikpLmlubmVySFRNTCA9IFwiUmVjaGVyY2hlIGludmVyc2VcIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUHJldmVyc2VHZW9jb2RpbmdSZXR1cm5QaWN0b1wiKSkuY2xhc3NOYW1lID0gXCJHUHJldmVyc2VHZW9jb2RpbmdSZXR1cm5QaWN0b0hpZGRlblwiO1xuICAgICAgICAgICAgICAgIHNlbGYub25HUHJldmVyc2VHZW9jb2RpbmdSZXR1cm5QaWN0b0NsaWNrKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2TmV3LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBkaXZOZXcuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1ByZXZlcnNlR2VvY29kaW5nUmVzdWx0c1BhbmVsXCIpKS5jbGFzc05hbWUgPSBcIkdQcm91dGVDb21wb25lbnRIaWRkZW5cIjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUHJldmVyc2VHZW9jb2RpbmdGb3JtXCIpKS5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuX2FkZFVJRChcIkdQcmV2ZXJzZUdlb2NvZGluZ0hlYWRlclRpdGxlXCIpKS5pbm5lckhUTUwgPSBcIlJlY2hlcmNoZSBpbnZlcnNlXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1ByZXZlcnNlR2VvY29kaW5nUmV0dXJuUGljdG9cIikpLmNsYXNzTmFtZSA9IFwiR1ByZXZlcnNlR2VvY29kaW5nUmV0dXJuUGljdG9IaWRkZW5cIjtcbiAgICAgICAgICAgICAgICBzZWxmLm9uR1ByZXZlcnNlR2VvY29kaW5nUmV0dXJuUGljdG9DbGljayhlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXZOZXc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBIZWFkZXIgVGl0bGUgUGFuZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxUaXRsZUVsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJHUHBhbmVsVGl0bGVcIjtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1ByZXZlcnNlR2VvY29kaW5nSGVhZGVyVGl0bGVcIik7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIlJlY2hlcmNoZSBpbnZlcnNlXCI7XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBIZWFkZXIgY2xvc2UgZGl2XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1BhbmVsQ2xvc2VFbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb250ZXh0ZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRpdkNsb3NlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2Q2xvc2UuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHJldmVyc2VHZW9jb2RpbmdQYW5lbENsb3NlXCIpO1xuICAgICAgICBkaXZDbG9zZS5jbGFzc05hbWUgPSBcIkdQcGFuZWxDbG9zZVwiO1xuICAgICAgICBkaXZDbG9zZS50aXRsZSA9IFwiRmVybWVyIGxlIHBhbm5lYXVcIjtcblxuICAgICAgICAvLyBMaW5rIHBhbmVsIGNsb3NlIC8gdmlzaWJpbGl0eSBjaGVja2JveFxuICAgICAgICBpZiAoZGl2Q2xvc2UuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZGl2Q2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUHNob3dSZXZlcnNlR2VvY29kaW5nUGljdG9cIikpLmNsaWNrKCk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2Q2xvc2UuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGRpdkNsb3NlLmF0dGFjaEV2ZW50KFwib25jbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1BzaG93UmV2ZXJzZUdlb2NvZGluZ1BpY3RvXCIpKS5jbGljaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGl2Q2xvc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBGb3JtXG4gICAgICogc2VlIGV2ZW50ICFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxGb3JtRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29udGV4dGUgZCdleGVjdXRpb25cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIik7XG4gICAgICAgIGZvcm0uaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHJldmVyc2VHZW9jb2RpbmdGb3JtXCIpO1xuXG4gICAgICAgIGlmIChmb3JtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLm9uUmV2ZXJzZUdlb2NvZGluZ1N1Ym1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybS5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgZm9ybS5hdHRhY2hFdmVudChcIm9uc3VibWl0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYub25SZXZlcnNlR2VvY29kaW5nU3VibWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgQ2hvaWNlIG1vZGUgaW50byBmb3JtICMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBDb250YWluZXIgdG8gTW9kZSBjaG9pY2UgZ2VvY29kaW5nIHR5cGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlc291cmNlcyAtIGdlb2NvZGluZyByZXNvdXJjZXMgdG8gYmUgZGlzcGxheWVkIChhbmQgdXNlZClcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ0Zvcm1Nb2RlQ2hvaWNlR2VvY29kaW5nVHlwZUVsZW1lbnQgOiBmdW5jdGlvbiAocmVzb3VyY2VzKSB7XG4gICAgICAgIC8vIGNvbnRleHRlIGQnZXhlY3V0aW9uXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiR1BmbGV4SW5wdXRcIjtcblxuICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgIGxhYmVsLmNsYXNzTmFtZSA9IFwiR1ByZXZlcnNlR2VvY29kaW5nQ29kZUxhYmVsXCI7XG4gICAgICAgIGxhYmVsLmlubmVySFRNTCA9IFwiUmVjaGVyY2hlIHBhclwiO1xuICAgICAgICBsYWJlbC50aXRsZSA9IFwiUmVjaGVyY2hlIHBhclwiO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgICAgICBzZWxlY3QuY2xhc3NOYW1lID0gXCJHUHJldmVyc2VHZW9jb2RpbmdDb2RlXCI7XG4gICAgICAgIC8vIGdlc3Rpb25uYWlyZSBkJ2V2ZW5lbWVudCA6IG9uIHN0b2NrZSBsYSB2YWxldXIgZHUgdHlwZSBkZSBnZW9jb2RhZ2UsXG4gICAgICAgIC8vIHV0aWxpc8OpIGRhbnMgbGEgcmVxdcOqdGUgZGUgZ8Opb2NvZGFnZSBpbnZlcnNlXG4gICAgICAgIGlmIChzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmV2ZXJzZUdlb2NvZGluZ1R5cGVDaGFuZ2UoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdC5hdHRhY2hFdmVudChcIm9uY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vblJldmVyc2VHZW9jb2RpbmdUeXBlQ2hhbmdlKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiBwcmVuZCBzb2l0IGxlcyB2YWxldXJzIHBhc3PDqWVzIHBhciBsJ3V0aWxpc2F0ZXVyLCBzb2l0IGRlcyB2YWxldXJzIHBhciBkw6lmYXV0XG4gICAgICAgIGlmICghcmVzb3VyY2VzIHx8ICFBcnJheS5pc0FycmF5KHJlc291cmNlcykpIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IFtcIlN0cmVldEFkZHJlc3NcIiwgXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJDYWRhc3RyYWxQYXJjZWxcIl07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzb3VyY2VzW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgUE9JT3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgUE9JT3B0aW9uLnZhbHVlID0gXCJQb3NpdGlvbk9mSW50ZXJlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgUE9JT3B0aW9uLnRleHQgPSBcIkxpZXV4L3RvcG9ueW1lc1wiO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQoUE9JT3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlN0cmVldEFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIFNBT3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgU0FPcHRpb24udmFsdWUgPSBcIlN0cmVldEFkZHJlc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgU0FPcHRpb24udGV4dCA9IFwiQWRyZXNzZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKFNBT3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkNhZGFzdHJhbFBhcmNlbFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgQ1BPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBDUE9wdGlvbi52YWx1ZSA9IFwiQ2FkYXN0cmFsUGFyY2VsXCI7XG4gICAgICAgICAgICAgICAgICAgIENQT3B0aW9uLnRleHQgPSBcIlBhcmNlbGxlcyBjYWRhc3RyYWxlc1wiO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQoQ1BPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChzZWxlY3QpO1xuXG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBDb250YWluZXIgdG8gTW9kZSBjaG9pY2UgZ2VvY29kaW5nIGRlbGltaXRhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGVsaW1pdGF0aW9ucyAtIGdlb2NvZGluZyBkZWxpbWl0YXRpb25zIHRvIGJlIGRpc3BsYXllZCAoYW5kIHVzZWQpXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdGb3JtTW9kZUNob2ljZUdlb2NvZGluZ0RlbGltaXRhdGlvbkVsZW1lbnQgOiBmdW5jdGlvbiAoZGVsaW1pdGF0aW9ucykge1xuICAgICAgICAvLyBjb250ZXh0ZSBkJ2V4ZWN1dGlvblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIkdQZmxleElucHV0XCI7XG5cbiAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICBsYWJlbC5jbGFzc05hbWUgPSBcIkdQcmV2ZXJzZUdlb2NvZGluZ0NvZGVMYWJlbFwiO1xuICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSBcIkTDqWxpbWl0YXRpb25cIjtcbiAgICAgICAgbGFiZWwudGl0bGUgPSBcIkTDqWxpbWl0YXRpb25cIjtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgICB2YXIgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9IFwiR1ByZXZlcnNlR2VvY29kaW5nQ29kZVwiO1xuICAgICAgICAvLyBnZXN0aW9ubmFpcmUgZCdldmVuZW1lbnQgOiBvbiBzdG9ja2UgbGEgdmFsZXVyIGR1IHR5cGUgZGUgZMOpbGltaXRhdGlvbixcbiAgICAgICAgLy8gZXQgb24gbW9kaWZpZSBsJ8OpdsOpbmVtZW50IGRlIHBvaW50YWdlIHN1ciBsYSBjYXJ0ZSBlbiBmb25jdGlvblxuICAgICAgICBpZiAoc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vblJldmVyc2VHZW9jb2RpbmdEZWxpbWl0YXRpb25DaGFuZ2UoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdC5hdHRhY2hFdmVudChcIm9uY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vblJldmVyc2VHZW9jb2RpbmdEZWxpbWl0YXRpb25DaGFuZ2UoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uIHByZW5kIHNvaXQgbGVzIHZhbGV1cnMgcGFzc8OpZXMgcGFyIGwndXRpbGlzYXRldXIsIHNvaXQgZGVzIHZhbGV1cnMgcGFyIGTDqWZhdXRcbiAgICAgICAgaWYgKCFkZWxpbWl0YXRpb25zIHx8ICFBcnJheS5pc0FycmF5KGRlbGltaXRhdGlvbnMpKSB7XG4gICAgICAgICAgICBkZWxpbWl0YXRpb25zID0gW1wiUG9pbnRcIiwgXCJDaXJjbGVcIiwgXCJFeHRlbnRcIl07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxpbWl0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRlbGltaXRhdGlvbnNbaV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludE9wdGlvbi52YWx1ZSA9IFwicG9pbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRPcHRpb24udGV4dCA9IFwiUG9pbnRlciB1biBsaWV1XCI7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdC5hcHBlbmRDaGlsZChwb2ludE9wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNpcmNsZU9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZU9wdGlvbi52YWx1ZSA9IFwiY2lyY2xlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZU9wdGlvbi50ZXh0ID0gXCJEZXNzaW5lciB1biBjZXJjbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKGNpcmNsZU9wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJleHRlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVudE9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudE9wdGlvbi52YWx1ZSA9IFwiZXh0ZW50XCI7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudE9wdGlvbi50ZXh0ID0gXCJEZXNzaW5lciB1bmUgZW1wcmlzZVwiO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQoZXh0ZW50T3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcblxuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFN1Ym1pdCBGb3JtICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBTdWJtaXQgRm9ybSBFbGVtZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1N1Ym1pdEZvcm1FbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGlucHV0LmlkID0gdGhpcy5fYWRkVUlEKFwiR1ByZXZlcnNlR2VvY29kaW5nU3VibWl0XCIpO1xuICAgICAgICBpbnB1dC5jbGFzc05hbWUgPSBcIkdQaW5wdXRTdWJtaXRcIjtcbiAgICAgICAgaW5wdXQudHlwZSA9IFwic3VibWl0XCI7XG4gICAgICAgIGlucHV0LnZhbHVlID0gXCJSZWNoZXJjaGVyXCI7XG5cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgUmV2ZXJzZUdlb2NvZGluZ0RPTTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Controls/ReverseGeocodingDOM.js\n");

/***/ }),

/***/ "./src/Common/Utils/CheckRightManagement.js":
/*!**************************************************!*\
  !*** ./src/Common/Utils/CheckRightManagement.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Config */ \"./src/Common/Utils/Config.js\");\n\n\n/**\n * @module CheckRightManagement\n * @alias [private] CheckRightManagement\n * @description\n * ...\n *\n * @example\n * check();\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  /**\n   * Contrôle des droits sur les ressources.\n   *\n   * @function check\n   * @param {Object} options - liste des options\n   * @param {String} options.key - clef API\n   * @param {Array} options.resources - liste des ressources\n   * @param {Array} options.services - liste des services\n   * @returns {Object} rightManagement - undefined ou {\n   *       key : \"\",\n   *       service-1 : [resource-1, resource-2],\n   *       service-2 : [resource-1, resource-2]\n   * }\n   */\n  check: function check(options) {\n    // logger\n    var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"checkrightmanagement\"); // si aucune option n'est renseignée...\n\n    if (!options) {\n      // message orienté pour le developpeur !\n      logger.error(\"WARNING : \" + \"no parameter specified !\");\n      return;\n    } // les options\n\n\n    var _key = options.key;\n\n    var _resources = options.resources || [];\n\n    var _services = options.services || []; // si aucune information sur les ressources,\n    // il est impossible de controler quelquechose !!!\n\n\n    if (_resources.length === 0) {\n      // message orienté pour le developpeur !\n      logger.error(\"WARNING : \" + \"no parameter 'resources' specified !\");\n      return;\n    } // si aucune information sur les services,\n    // il est impossible de controler quelquechose !!!\n\n\n    if (_services.length === 0) {\n      // message orienté pour le developpeur !\n      logger.error(\"WARNING : \" + \"no parameter 'services' specified !\");\n      return;\n    } // les ressources controlées :\n    // Ex.\n    // {\n    //   \"Itineraire\"     : [\"Pieton\", \"Voiture\"],\n    //   \"Geocode\"        : [\"PositionOfInterest\", \"StreetAddress\", \"CadastralParcel\"],\n    //   \"AutoCompletion\" : [\"PositionOfInterest\", \"StreetAddress\", \"CadastralParcel\"],\n    //   \"Elevation\"      : [\"SERVICE_CALCUL_ALTIMETRIQUE_RSC\"]\n    // }\n\n\n    var _rightManagement = {}; // la clef API n'est pas renseignée\n\n    if (!_key) {\n      // on verifie si l'autoconfiguration est disponible\n      if (!_Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isConfigLoaded()) {\n        // si l'autoconfiguration n'est pas chargée,\n        // aucune vérification des droits est possible...\n        logger.warn(\"WARNING : \" + \"The 'apiKey' parameter is missing, \" + \"and the contract key configuration has not been loaded, \" + \"so impossible to check yours rights !\");\n        return;\n      } else {\n        // si l'autoconfiguration est chargée,\n        // on recupere la/les clef(s) API, et on en profitera ensuite pour controler\n        // les droits sur les ressources.\n        _key = Object.keys(_Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].configuration.generalOptions.apiKeys);\n        logger.log(_key);\n      }\n    } // on verifie si l'autoconfiguration est disponible\n\n\n    if (!_Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isConfigLoaded()) {\n      // si l'autoconfiguration n'est pas chargée,\n      // il est toujours possible de requeter le service avec une clef API,\n      // mais les droits sur les ressources ne sont pas garantis, on risque\n      // d'obtenir des erreurs 403 forbidden...\n      // la responsabilité revient à l'utilisateur (message d'information)...\n      logger.warn(\"WARNING : \" + \"the contract key configuration has not been loaded, \" + \"so be carefull !\"); // les ressouces non controlées\n\n      var _noRightManagement = {};\n\n      for (var i = 0; i < _services.length; i++) {\n        var service = _services[i];\n        _noRightManagement[service] = [];\n\n        for (var j = 0; j < _resources.length; j++) {\n          var resource = _resources[j];\n\n          _noRightManagement[service].push(resource);\n        }\n      } // on ajoute la clef\n\n\n      _noRightManagement.key = _key;\n      logger.log(\"right management not checked\", _noRightManagement);\n      return _noRightManagement;\n    } else {\n      // si l'autoconf est chargée,\n      // on verifie la correspondance entre la clef et l'autoconfiguration,\n      // on previent l'utilisateur (message d'information) s'il n'a\n      // pas de droits sur certaines ressources ...\n      // doit on ecarter les ressources sans droit ?\n      // oui, si possible avec un message d'information pour l'utilisateur...\n      for (var k = 0; k < _resources.length; k++) {\n        var _resource = _resources[k];\n\n        for (var l = 0; l < _services.length; l++) {\n          var _service = _services[l];\n          var params = _Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getServiceParams(_resource, _service, _key);\n\n          if (!params || Object.keys(params).length === 0) {\n            logger.warn(\"WARNING : \" + \"The contract key configuration has no rights to load this geoportal \" + \"resource (\" + _resource + \") \" + \"for this service (\" + _service + \") \");\n            continue;\n          }\n\n          if (!_rightManagement[_service]) {\n            _rightManagement[_service] = [];\n          }\n\n          _rightManagement[_service].push(_resource);\n        }\n      }\n\n      if (Object.keys(_rightManagement).length === 0) {\n        logger.warn(\"WARNING : \" + \"The contract key configuration has been loaded, \" + \"and the 'apiKey' parameter has been set, \" + \"but, there is a problem on the mapping between the contract and the key !\");\n        return;\n      } // on ajoute la clef qui correspond à la ressource vérifiée\n\n\n      _rightManagement.key = params.key;\n      logger.log(\"right management checked\", _rightManagement);\n      return _rightManagement;\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL0NoZWNrUmlnaHRNYW5hZ2VtZW50LmpzPzRmMzQiXSwibmFtZXMiOlsiY2hlY2siLCJvcHRpb25zIiwibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiZXJyb3IiLCJfa2V5Iiwia2V5IiwiX3Jlc291cmNlcyIsInJlc291cmNlcyIsIl9zZXJ2aWNlcyIsInNlcnZpY2VzIiwibGVuZ3RoIiwiX3JpZ2h0TWFuYWdlbWVudCIsIkNvbmZpZyIsImlzQ29uZmlnTG9hZGVkIiwid2FybiIsIk9iamVjdCIsImtleXMiLCJjb25maWd1cmF0aW9uIiwiZ2VuZXJhbE9wdGlvbnMiLCJhcGlLZXlzIiwibG9nIiwiX25vUmlnaHRNYW5hZ2VtZW50IiwiaSIsInNlcnZpY2UiLCJqIiwicmVzb3VyY2UiLCJwdXNoIiwiayIsIl9yZXNvdXJjZSIsImwiLCJfc2VydmljZSIsInBhcmFtcyIsImdldFNlcnZpY2VQYXJhbXMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ2U7QUFDWDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lBLE9BQUssRUFBRyxlQUFVQyxPQUFWLEVBQW1CO0FBQ3ZCO0FBRUEsUUFBSUMsTUFBTSxHQUFHQyxxRUFBTSxDQUFDQyxTQUFQLENBQWlCLHNCQUFqQixDQUFiLENBSHVCLENBS3ZCOztBQUNBLFFBQUksQ0FBQ0gsT0FBTCxFQUFjO0FBQ1Y7QUFDQUMsWUFBTSxDQUFDRyxLQUFQLENBQWEsZUFDVCwwQkFESjtBQUVBO0FBQ0gsS0FYc0IsQ0FhdkI7OztBQUNBLFFBQUlDLElBQUksR0FBR0wsT0FBTyxDQUFDTSxHQUFuQjs7QUFDQSxRQUFJQyxVQUFVLEdBQUdQLE9BQU8sQ0FBQ1EsU0FBUixJ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Q0FBYjs7QUFDQSxjQUFJLENBQUMyQixNQUFELElBQVdoQixNQUFNLENBQUNDLElBQVAsQ0FBWWUsTUFBWixFQUFvQnJCLE1BQXBCLEtBQStCLENBQTlDLEVBQWlEO0FBQzdDVixrQkFBTSxDQUFDYyxJQUFQLENBQVksZUFDUixzRUFEUSxHQUVSLFlBRlEsR0FFT2MsU0FGUCxHQUVtQixJQUZuQixHQUdSLG9CQUhRLEdBR2VFLFFBSGYsR0FHMEIsSUFIdEM7QUFJQTtBQUNIOztBQUVELGNBQUksQ0FBQ25CLGdCQUFnQixDQUFDbUIsUUFBRCxDQUFyQixFQUFpQztBQUM3Qm5CLDRCQUFnQixDQUFDbUIsUUFBRCxDQUFoQixHQUE2QixFQUE3QjtBQUNIOztBQUVEbkIsMEJBQWdCLENBQUNtQixRQUFELENBQWhCLENBQTJCSixJQUEzQixDQUFnQ0UsU0FBaEM7QUFDSDtBQUNKOztBQUVELFVBQUliLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZTCxnQkFBWixFQUE4QkQsTUFBOUIsS0FBeUMsQ0FBN0MsRUFBZ0Q7QUFDNUNWLGNBQU0sQ0FBQ2MsSUFBUCxDQUFZLGVBQ1Isa0RBRFEsR0FFUiwyQ0FGUSxHQUdSLDJFQUhKO0FBSUE7QUFDSCxPQXRDRSxDQXdDSDs7O0FBQ0FILHNCQUFnQixDQUFDTixHQUFqQixHQUF1QjBCLE1BQU0sQ0FBQzFCLEdBQTlCO0FBRUFMLFlBQU0sQ0FBQ29CLEdBQVAsQ0FBVywwQkFBWCxFQUF1Q1QsZ0JBQXZDO0FBRUEsYUFBT0EsZ0JBQVA7QUFDSDtBQUNKO0FBcEtVLENBQWYiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL1V0aWxzL0NoZWNrUmlnaHRNYW5hZ2VtZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IENvbmZpZyBmcm9tIFwiLi9Db25maWdcIjtcblxuLyoqXG4gKiBAbW9kdWxlIENoZWNrUmlnaHRNYW5hZ2VtZW50XG4gKiBAYWxpYXMgW3ByaXZhdGVdIENoZWNrUmlnaHRNYW5hZ2VtZW50XG4gKiBAZGVzY3JpcHRpb25cbiAqIC4uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjaGVjaygpO1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogQ29udHLDtGxlIGRlcyBkcm9pdHMgc3VyIGxlcyByZXNzb3VyY2VzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGNoZWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsaXN0ZSBkZXMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmtleSAtIGNsZWYgQVBJXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5yZXNvdXJjZXMgLSBsaXN0ZSBkZXMgcmVzc291cmNlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2VydmljZXMgLSBsaXN0ZSBkZXMgc2VydmljZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByaWdodE1hbmFnZW1lbnQgLSB1bmRlZmluZWQgb3Uge1xuICAgICAqICAgICAgIGtleSA6IFwiXCIsXG4gICAgICogICAgICAgc2VydmljZS0xIDogW3Jlc291cmNlLTEsIHJlc291cmNlLTJdLFxuICAgICAqICAgICAgIHNlcnZpY2UtMiA6IFtyZXNvdXJjZS0xLCByZXNvdXJjZS0yXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBjaGVjayA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiY2hlY2tyaWdodG1hbmFnZW1lbnRcIik7XG5cbiAgICAgICAgLy8gc2kgYXVjdW5lIG9wdGlvbiBuJ2VzdCByZW5zZWlnbsOpZS4uLlxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIG1lc3NhZ2Ugb3JpZW50w6kgcG91ciBsZSBkZXZlbG9wcGV1ciAhXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJXQVJOSU5HIDogXCIgK1xuICAgICAgICAgICAgICAgIFwibm8gcGFyYW1ldGVyIHNwZWNpZmllZCAhXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVzIG9wdGlvbnNcbiAgICAgICAgdmFyIF9rZXkgPSBvcHRpb25zLmtleTtcbiAgICAgICAgdmFyIF9yZXNvdXJjZXMgPSBvcHRpb25zLnJlc291cmNlcyB8fCBbXTtcbiAgICAgICAgdmFyIF9zZXJ2aWNlcyA9IG9wdGlvbnMuc2VydmljZXMgfHwgW107XG5cbiAgICAgICAgLy8gc2kgYXVjdW5lIGluZm9ybWF0aW9uIHN1ciBsZXMgcmVzc291cmNlcyxcbiAgICAgICAgLy8gaWwgZXN0IGltcG9zc2libGUgZGUgY29udHJvbGVyIHF1ZWxxdWVjaG9zZSAhISFcbiAgICAgICAgaWYgKF9yZXNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBtZXNzYWdlIG9yaWVudMOpIHBvdXIgbGUgZGV2ZWxvcHBldXIgIVxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiV0FSTklORyA6IFwiICtcbiAgICAgICAgICAgICAgICBcIm5vIHBhcmFtZXRlciAncmVzb3VyY2VzJyBzcGVjaWZpZWQgIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpIGF1Y3VuZSBpbmZvcm1hdGlvbiBzdXIgbGVzIHNlcnZpY2VzLFxuICAgICAgICAvLyBpbCBlc3QgaW1wb3NzaWJsZSBkZSBjb250cm9sZXIgcXVlbHF1ZWNob3NlICEhIVxuICAgICAgICBpZiAoX3NlcnZpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gbWVzc2FnZSBvcmllbnTDqSBwb3VyIGxlIGRldmVsb3BwZXVyICFcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgXCJubyBwYXJhbWV0ZXIgJ3NlcnZpY2VzJyBzcGVjaWZpZWQgIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxlcyByZXNzb3VyY2VzIGNvbnRyb2zDqWVzIDpcbiAgICAgICAgLy8gRXguXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICBcIkl0aW5lcmFpcmVcIiAgICAgOiBbXCJQaWV0b25cIiwgXCJWb2l0dXJlXCJdLFxuICAgICAgICAvLyAgIFwiR2VvY29kZVwiICAgICAgICA6IFtcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiLCBcIlN0cmVldEFkZHJlc3NcIiwgXCJDYWRhc3RyYWxQYXJjZWxcIl0sXG4gICAgICAgIC8vICAgXCJBdXRvQ29tcGxldGlvblwiIDogW1wiUG9zaXRpb25PZkludGVyZXN0XCIsIFwiU3RyZWV0QWRkcmVzc1wiLCBcIkNhZGFzdHJhbFBhcmNlbFwiXSxcbiAgICAgICAgLy8gICBcIkVsZXZhdGlvblwiICAgICAgOiBbXCJTRVJWSUNFX0NBTENVTF9BTFRJTUVUUklRVUVfUlNDXCJdXG4gICAgICAgIC8vIH1cbiAgICAgICAgdmFyIF9yaWdodE1hbmFnZW1lbnQgPSB7fTtcblxuICAgICAgICAvLyBsYSBjbGVmIEFQSSBuJ2VzdCBwYXMgcmVuc2VpZ27DqWVcbiAgICAgICAgaWYgKCFfa2V5KSB7XG4gICAgICAgICAgICAvLyBvbiB2ZXJpZmllIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gZXN0IGRpc3BvbmlibGVcblxuICAgICAgICAgICAgaWYgKCFDb25maWcuaXNDb25maWdMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gbidlc3QgcGFzIGNoYXJnw6llLFxuICAgICAgICAgICAgICAgIC8vIGF1Y3VuZSB2w6lyaWZpY2F0aW9uIGRlcyBkcm9pdHMgZXN0IHBvc3NpYmxlLi4uXG5cbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlICdhcGlLZXknIHBhcmFtZXRlciBpcyBtaXNzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYW5kIHRoZSBjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgbm90IGJlZW4gbG9hZGVkLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic28gaW1wb3NzaWJsZSB0byBjaGVjayB5b3VycyByaWdodHMgIVwiKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2kgbCdhdXRvY29uZmlndXJhdGlvbiBlc3QgY2hhcmfDqWUsXG4gICAgICAgICAgICAgICAgLy8gb24gcmVjdXBlcmUgbGEvbGVzIGNsZWYocykgQVBJLCBldCBvbiBlbiBwcm9maXRlcmEgZW5zdWl0ZSBwb3VyIGNvbnRyb2xlclxuICAgICAgICAgICAgICAgIC8vIGxlcyBkcm9pdHMgc3VyIGxlcyByZXNzb3VyY2VzLlxuXG4gICAgICAgICAgICAgICAgX2tleSA9IE9iamVjdC5rZXlzKENvbmZpZy5jb25maWd1cmF0aW9uLmdlbmVyYWxPcHRpb25zLmFwaUtleXMpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiB2ZXJpZmllIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gZXN0IGRpc3BvbmlibGVcblxuICAgICAgICBpZiAoIUNvbmZpZy5pc0NvbmZpZ0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAvLyBzaSBsJ2F1dG9jb25maWd1cmF0aW9uIG4nZXN0IHBhcyBjaGFyZ8OpZSxcbiAgICAgICAgICAgIC8vIGlsIGVzdCB0b3Vqb3VycyBwb3NzaWJsZSBkZSByZXF1ZXRlciBsZSBzZXJ2aWNlIGF2ZWMgdW5lIGNsZWYgQVBJLFxuICAgICAgICAgICAgLy8gbWFpcyBsZXMgZHJvaXRzIHN1ciBsZXMgcmVzc291cmNlcyBuZSBzb250IHBhcyBnYXJhbnRpcywgb24gcmlzcXVlXG4gICAgICAgICAgICAvLyBkJ29idGVuaXIgZGVzIGVycmV1cnMgNDAzIGZvcmJpZGRlbi4uLlxuICAgICAgICAgICAgLy8gbGEgcmVzcG9uc2FiaWxpdMOpIHJldmllbnQgw6AgbCd1dGlsaXNhdGV1ciAobWVzc2FnZSBkJ2luZm9ybWF0aW9uKS4uLlxuXG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgXCJ0aGUgY29udHJhY3Qga2V5IGNvbmZpZ3VyYXRpb24gaGFzIG5vdCBiZWVuIGxvYWRlZCwgXCIgK1xuICAgICAgICAgICAgICAgIFwic28gYmUgY2FyZWZ1bGwgIVwiKTtcblxuICAgICAgICAgICAgLy8gbGVzIHJlc3NvdWNlcyBub24gY29udHJvbMOpZXNcbiAgICAgICAgICAgIHZhciBfbm9SaWdodE1hbmFnZW1lbnQgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2VydmljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VydmljZSA9IF9zZXJ2aWNlc1tpXTtcbiAgICAgICAgICAgICAgICBfbm9SaWdodE1hbmFnZW1lbnRbc2VydmljZV0gPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX3Jlc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBfcmVzb3VyY2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICBfbm9SaWdodE1hbmFnZW1lbnRbc2VydmljZV0ucHVzaChyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbiBham91dGUgbGEgY2xlZlxuICAgICAgICAgICAgX25vUmlnaHRNYW5hZ2VtZW50LmtleSA9IF9rZXk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJyaWdodCBtYW5hZ2VtZW50IG5vdCBjaGVja2VkXCIsIF9ub1JpZ2h0TWFuYWdlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiBfbm9SaWdodE1hbmFnZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaSBsJ2F1dG9jb25mIGVzdCBjaGFyZ8OpZSxcbiAgICAgICAgICAgIC8vIG9uIHZlcmlmaWUgbGEgY29ycmVzcG9uZGFuY2UgZW50cmUgbGEgY2xlZiBldCBsJ2F1dG9jb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgLy8gb24gcHJldmllbnQgbCd1dGlsaXNhdGV1ciAobWVzc2FnZSBkJ2luZm9ybWF0aW9uKSBzJ2lsIG4nYVxuICAgICAgICAgICAgLy8gcGFzIGRlIGRyb2l0cyBzdXIgY2VydGFpbmVzIHJlc3NvdXJjZXMgLi4uXG5cbiAgICAgICAgICAgIC8vIGRvaXQgb24gZWNhcnRlciBsZXMgcmVzc291cmNlcyBzYW5zIGRyb2l0ID9cbiAgICAgICAgICAgIC8vIG91aSwgc2kgcG9zc2libGUgYXZlYyB1biBtZXNzYWdlIGQnaW5mb3JtYXRpb24gcG91ciBsJ3V0aWxpc2F0ZXVyLi4uXG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgX3Jlc291cmNlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBfcmVzb3VyY2UgPSBfcmVzb3VyY2VzW2tdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBfc2VydmljZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zZXJ2aWNlID0gX3NlcnZpY2VzW2xdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBDb25maWcuZ2V0U2VydmljZVBhcmFtcyhfcmVzb3VyY2UsIF9zZXJ2aWNlLCBfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMgfHwgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0FSTklORyA6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgbm8gcmlnaHRzIHRvIGxvYWQgdGhpcyBnZW9wb3J0YWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVzb3VyY2UgKFwiICsgX3Jlc291cmNlICsgXCIpIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvciB0aGlzIHNlcnZpY2UgKFwiICsgX3NlcnZpY2UgKyBcIikgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9yaWdodE1hbmFnZW1lbnRbX3NlcnZpY2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmlnaHRNYW5hZ2VtZW50W19zZXJ2aWNlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX3JpZ2h0TWFuYWdlbWVudFtfc2VydmljZV0ucHVzaChfcmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKF9yaWdodE1hbmFnZW1lbnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0FSTklORyA6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJUaGUgY29udHJhY3Qga2V5IGNvbmZpZ3VyYXRpb24gaGFzIGJlZW4gbG9hZGVkLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYW5kIHRoZSAnYXBpS2V5JyBwYXJhbWV0ZXIgaGFzIGJlZW4gc2V0LCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYnV0LCB0aGVyZSBpcyBhIHByb2JsZW0gb24gdGhlIG1hcHBpbmcgYmV0d2VlbiB0aGUgY29udHJhY3QgYW5kIHRoZSBrZXkgIVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9uIGFqb3V0ZSBsYSBjbGVmIHF1aSBjb3JyZXNwb25kIMOgIGxhIHJlc3NvdXJjZSB2w6lyaWZpw6llXG4gICAgICAgICAgICBfcmlnaHRNYW5hZ2VtZW50LmtleSA9IHBhcmFtcy5rZXk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJyaWdodCBtYW5hZ2VtZW50IGNoZWNrZWRcIiwgX3JpZ2h0TWFuYWdlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiBfcmlnaHRNYW5hZ2VtZW50O1xuICAgICAgICB9XG4gICAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Utils/CheckRightManagement.js\n");

/***/ }),

/***/ "./src/Common/Utils/Config.js":
/*!************************************!*\
  !*** ./src/Common/Utils/Config.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n\nvar logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"config\");\n/**\n * @module Config\n * @alias [private] Config\n * @description\n * ...\n *\n * @example\n * isConfigLoaded();\n * getLayerId();\n * getLayerParams();\n * getServiceParams();\n * getResolutions();\n * getGlobalConstraints();\n * getTileMatrix();\n */\n\nvar Config = {\n  /**\n   * autoconf\n   *\n   * @public\n   * @type {Object}\n   */\n  configuration: null,\n\n  /**\n   * Controle du chargement de l'autoconf\n   *\n   * @function isConfigLoaded\n   * @this Config\n   * @public\n   * @returns {Boolean} True si l'autoconf a déjà été chargée, False sinon.\n   */\n  isConfigLoaded: function isConfigLoaded() {\n    var scope = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : {};\n\n    if (scope.Gp && scope.Gp.Config && Object.keys(scope.Gp.Config).length !== 0) {\n      /** ts-syntax */\n      this.configuration = scope.Gp.Config;\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Recuperation de l'identifiant d'une couche donnée\n   *\n   * @function getLayerId\n   * @public\n   * @param {String} layerName - nom de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n   * @param {String} service   - nom du service (par ex. \"WMS\" ou \"WMTS\")\n   * @returns {String} Identifiant de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS\")\n   */\n  getLayerId: function getLayerId(layerName, service) {\n    var layerId = null; // layer\n    // key : [layerName]$[contexte]:OGC:[service]\n    // ex : \"ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS\"\n    // service\n    // key : [layerName]$[contexte];[service]\n    // ex : PositionOfInterest$OGC:OPENLS;ReverseGeocode\n\n    if (this.configuration) {\n      var layers = this.configuration[\"layers\"];\n\n      for (var key in layers) {\n        if (layers.hasOwnProperty(key)) {\n          var parts = key.split(\"$\");\n\n          if (layerName === parts[0]) {\n            if (parts[1]) {\n              var servicePartsLayer = parts[1].split(\":\");\n              var servicePartsService = parts[1].split(\";\");\n\n              if (servicePartsService[1] === service) {\n                layerId = key;\n                break;\n              }\n\n              if (servicePartsLayer[2] === service) {\n                layerId = key;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (!layerId) {\n      logger.error(\"ERROR layer id (layer name: \" + layerName + \" / service: \" + service + \") was not found !?\");\n    }\n\n    return layerId;\n  },\n\n  /**\n   * Récupération des paramètres nécessaires à l'affichage d'une couche WMS ou WMTS\n   *\n   * @function getLayerParams\n   * @public\n   * @param {String} layerName - nom de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n   * @param {String} service   - nom du service (par ex. \"WMS\" ou \"WMTS\")\n   * @param {String} [apiKey]  - Clé de contrat API\n   * @returns {Object} params  - paramètres du service (WMS ou WMTS) pour la couche donnée\n   * @returns {String} params.url        - Url du service à requêter pour afficher la couche\n   * @returns {String} params.version    - Version du service\n   * @returns {String} params.styles     - Style par défaut de la couche\n   * @returns {String} params.format     - Format par défaut de la couche\n   * @returns {String} params.projection - Projection par défaut de la couche\n   * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche\n   * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche\n   * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche\n   * @returns {Array} params.legends     - Tableau des légendes associées à la couche\n   * @returns {Array} params.metadata    - Tableau des métadonnées associées à la couche\n   * @returns {Array} params.originators - Tableau des originators associés à la couche\n   * @returns {Array} params.title       - Nom de la resource, lisible par un humain.\n   * @returns {Array} params.description - Url de l'image d'aperçu rapide de la ressource.\n   * @returns {Array} params.quicklookUrl- Tableau des originators associés à la couche\n   * @returns {String} params.[TMSLink]          - Identifiant de la pyramide (TMS), dans le cas d'une couche WMTS\n   * @returns {Gp.Point} params.[matrixOrigin]   - Origine de la matrice (top left corner), dans le cas d'une couche WMTS\n   * @returns {Array} params.[nativeResolutions] - Tableau regroupant les résolutions de chaque niveau de la matrice, dans le cas d'une couche WMTS\n   * @returns {Array} params.[matrixIds]         - Tableau regroupant les identifiants de chaque niveau de la matrice, dans le cas d'une couche WMTS\n   */\n  getLayerParams: function getLayerParams(layerName, service, apiKey) {\n    var params = {};\n\n    if (this.configuration) {\n      // récupération de l'identifiant complet de la couche.\n      var layerId = this.getLayerId(layerName, service);\n\n      if (layerId) {\n        // récupération de l'objet de configuration de la couche\n        var layerConf = this.configuration.layers[layerId]; // controle de la clef\n\n        var key = layerConf.apiKeys[0];\n\n        if (apiKey) {\n          if (apiKey !== key) {\n            logger.error(\"ERROR different keys (\" + apiKey + \" !== \" + key + \") !?\");\n            return;\n          }\n        }\n\n        apiKey = apiKey || key;\n        params.key = apiKey; // récupération des paramètres du service\n\n        params.url = layerConf.getServerUrl(apiKey);\n        params.version = layerConf.getServiceParams().version;\n        params.styles = layerConf.getDefaultStyle();\n        params.format = layerConf.getDefaultFormat();\n        params.projection = layerConf.getDefaultProjection(); // récupération des infos de la couche\n\n        params.minScale = layerConf.getMinScaleDenominator();\n        params.maxScale = layerConf.getMaxScaleDenominator();\n        params.extent = layerConf.getBBOX();\n        params.legends = layerConf.getLegends();\n        params.metadata = layerConf.getMetadata();\n        params.originators = layerConf.getOriginators();\n        params.title = layerConf.getTitle();\n        params.description = layerConf.getDescription();\n        params.quicklookUrl = layerConf.getQuicklookUrl(); // WMTS : récupération des tileMatrixSetLimits\n\n        if (layerConf.wmtsOptions) {\n          params.tileMatrixSetLimits = layerConf.wmtsOptions.tileMatrixSetLimits;\n        } // WMTS : récupération des paramètres de la pyramide (TMS)\n\n\n        var TMSLink = layerConf.getTMSID();\n\n        if (TMSLink) {\n          params.TMSLink = TMSLink;\n          var tmsConf = this.configuration.getTMSConf(TMSLink); // Get matrix origin : Gp.Point = Object{x:Float, y:Float}\n\n          params.matrixOrigin = tmsConf.getTopLeftCorner();\n          params.nativeResolutions = tmsConf.nativeResolutions;\n          params.matrixIds = tmsConf.matrixIds;\n          params.tileMatrices = tmsConf.tileMatrices;\n        }\n      }\n    }\n\n    return params;\n  },\n\n  /**\n   * Recuperation des parametres d'un service\n   *\n   * @function getServiceParams\n   * @public\n   * @param {String} [resource] - \"PositionOfInterest\", \"StreetAddress\", \"Voiture\", \"Pieton\", ...\n   * @param {String} [service] - Geocode, Itineraire, ...\n   * @param {Array} [apiKeys]  - Clé(s) de contrat API\n   * @returns {Object} params - paramètres de la ressource\n   * @returns {String} params. -\n   * @returns {String} params. -\n   * @returns {String} params. -\n   */\n  getServiceParams: function getServiceParams(resource, service, apiKeys) {\n    var params = {};\n\n    if (this.configuration) {\n      // récupération de l'identifiant complet de la couche.\n      var layerId = this.getLayerId(resource, service);\n\n      if (layerId) {\n        // récupération de l'objet de configuration de la couche\n        var layerConf = this.configuration.layers[layerId]; // controle de la clef (on prend la première clé disponible qui est censée avoir accès à la ressource)\n\n        var key = layerConf.apiKeys[0];\n\n        if (apiKeys) {\n          if (!Array.isArray(apiKeys)) {\n            apiKeys = [apiKeys];\n          }\n\n          for (var i = 0; i < apiKeys.length; i++) {\n            if (apiKeys[i] === key) {\n              var keyIndex = i;\n              break;\n            }\n          } // si aucune clé du tableau apiKeys ne correspond, on retourne rien => pas de droits pour la ressource\n\n\n          if (typeof keyIndex === \"undefined\") {\n            return;\n          }\n        } // on retourne la première clé qui a effectivement accès à la ressource\n\n\n        var apiKey = apiKeys[keyIndex] || key;\n        params.key = apiKey; // récupération des paramètres du service\n\n        params.url = layerConf.getServerUrl(apiKey);\n        params.version = layerConf.getServiceParams().version; // récupération des infos de la couche\n\n        params.extent = layerConf.getBBOX();\n        params.title = layerConf.getTitle();\n        params.description = layerConf.getDescription();\n      }\n    }\n\n    return params;\n  },\n\n  /**\n   * Resolution en geographique\n   *\n   * @function getResolutions\n   * @public\n   * @returns {Array} resolutions\n   */\n  getResolutions: function getResolutions() {\n    var resolutions = [];\n\n    if (this.configuration) {\n      resolutions = this.configuration[\"generalOptions\"][\"wgs84Resolutions\"];\n    }\n\n    return resolutions;\n  },\n\n  /**\n   * Recuperation des parametres TMS de la configuration\n   *\n   * @function getTileMatrix\n   * @public\n   * @param {String} tmsName - tile matrix set name\n   * @returns {Object} tile matrix set\n   */\n  getTileMatrix: function getTileMatrix(tmsName) {\n    var tms = {};\n\n    if (this.configuration) {\n      if (tmsName) {\n        tms = this.configuration[\"tileMatrixSets\"][tmsName.toUpperCase()];\n      }\n    }\n\n    return tms;\n  },\n\n  /**\n   * Récupération des contraintes générales d'une couche donnée : extent, minScale, maxScale, projection\n   *\n   * @function getGlobalConstraints\n   * @public\n   * @param {String} layerId - identifiant de la couche\n   * @returns {Object} params - contraintes de la couche\n   * @returns {String} params.projection - Projection par défaut de la couche\n   * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche\n   * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche\n   * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche\n   */\n  getGlobalConstraints: function getGlobalConstraints(layerId) {\n    var params = {};\n\n    if (layerId) {\n      // récupération de l'objet de configuration de la couche\n      var layerConf = this.configuration.layers[layerId];\n      params.projection = layerConf.getDefaultProjection();\n      params.minScale = layerConf.getMinScaleDenominator();\n      params.maxScale = layerConf.getMaxScaleDenominator();\n      params.extent = layerConf.getBBOX();\n    }\n\n    return params;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Config);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL0NvbmZpZy5qcz83Zjk1Il0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIkNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJpc0NvbmZpZ0xvYWRlZCIsInNjb3BlIiwid2luZG93Iiwic2VsZiIsImdsb2JhbCIsIkdwIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImdldExheWVySWQiLCJsYXllck5hbWUiLCJzZXJ2aWNlIiwibGF5ZXJJZCIsImxheWVycyIsImtleSIsImhhc093blByb3BlcnR5IiwicGFydHMiLCJzcGxpdCIsInNlcnZpY2VQYXJ0c0xheWVyIiwic2VydmljZVBhcnRzU2VydmljZSIsImVycm9yIiwiZ2V0TGF5ZXJQYXJhbXMiLCJhcGlLZXkiLCJwYXJhbXMiLCJsYXllckNvbmYiLCJhcGlLZXlzIiwidXJsIiwiZ2V0U2VydmVyVXJsIiwidmVyc2lvbiIsImdldFNlcnZpY2VQYXJhbXMiLCJzdHlsZXMiLCJnZXREZWZhdWx0U3R5bGUiLCJmb3JtYXQiLCJnZXREZWZhdWx0Rm9ybWF0IiwicHJvamVjdGlvbiIsImdldERlZmF1bHRQcm9qZWN0aW9uIiwibWluU2NhbGUiLCJnZXRNaW5TY2FsZURlbm9taW5hdG9yIiwibWF4U2NhbGUiLCJnZXRNYXhTY2FsZURlbm9taW5hdG9yIiwiZXh0ZW50IiwiZ2V0QkJPWCIsImxlZ2VuZHMiLCJnZXRMZWdlbmRzIiwibWV0YWRhdGEiLCJnZXRNZXRhZGF0YSIsIm9yaWdpbmF0b3JzIiwiZ2V0T3JpZ2luYXRvcnMiLCJ0aXRsZSIsImdldFRpdGxlIiwiZGVzY3JpcHRpb24iLCJnZXREZXNjcmlwdGlvbiIsInF1aWNrbG9va1VybCIsImdldFF1aWNrbG9va1VybCIsIndtdHNPcHRpb25zIiwidGlsZU1hdHJpeFNldExpbWl0cyIsIlRNU0xpbmsiLCJnZXRUTVNJRCIsInRtc0NvbmYiLCJnZXRUTVNDb25mIiwibWF0cml4T3JpZ2luIiwiZ2V0VG9wTGVmdENvcm5lciIsIm5hdGl2ZVJlc29sdXRpb25zIiwibWF0cml4SWRzIiwidGlsZU1hdHJpY2VzIiwicmVzb3VyY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwia2V5SW5kZXgiLCJnZXRSZXNvbHV0aW9ucyIsInJlc29sdXRpb25zIiwiZ2V0VGlsZU1hdHJpeCIsInRtc05hbWUiLCJ0bXMiLCJ0b1VwcGVyQ2FzZSIsImdldEdsb2JhbENvbnN0cmFpbnRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFFQSxJQUFJQSxNQUFNLEdBQUdDLHFFQUFNLENBQUNDLFNBQVAsQ0FBaUIsUUFBakIsQ0FBYjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQyxNQUFNLEdBQUc7QUFFVDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsZUFBYSxFQUFHLElBUlA7O0FBVVQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxnQkFBYyxFQUFHLDBCQUFZO0FBQ3pCLFFBQUlDLEtBQUssR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxFQUFuSTs7QUFDQSxRQUFJSCxLQUFLLENBQUNJLEVBQU4sSUFBWUosS0FBSyxDQUFDSSxFQUFOLENBQVNQLE1BQXJCLElBQStCUSxNQUFNLENBQUNDLElBQVAsQ0FBWU4sS0FBSyxDQUFDSSxFQUFOLENBQVNQLE1BQXJCLEVBQTZCVSxNQUE3QixLQUF3QyxDQUEzRSxFQUE4RTtBQUMxRTtBQUFrQixXQUFLVCxhQUFOLEdBQXVCRSxLQUFLLENBQUNJLEVBQU4sQ0FBU1AsTUFBaEM7QUFDakIsYUFBTyxJQUFQO0FBQ0g7O0FBQ0QsV0FBTyxLQUFQO0FBQ0gsR0F6QlE7O0FBMkJUO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJVyxZQUFVLEVBQUcsb0JBQVVDLFNBQVYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQ3ZDLFFBQUlDLE9BQU8sR0FBRyxJQUFkLENBRHVDLENBR3ZDO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFJLEtBQUtiLGFBQVQsRUFBd0I7QUFDcEIsVUFBSWMsTUFBTSxHQUFHLEtBQUtkLGFBQUwsQ0FBbUIsUUFBbkIsQ0FBYjs7QUFDQSxXQUFLLElBQUllLEdBQVQsSUFBZ0JELE1BQWhCLEVBQXdCO0FBQ3BCLFlBQUlBLE1BQU0sQ0FBQ0UsY0FBUCxDQUFzQkQsR0FBdEIsQ0FBSixFQUFnQztBQUM1QixjQUFJRSxLQUFLLEdBQUdGLEdBQUcsQ0FBQ0csS0FBSixDQUFVLEdBQVYsQ0FBWjs7QUFDQSxjQUFJUCxTQUFTLEtBQUtNLEtBQUssQ0FBQyxDQUFELENBQXZCLEVBQTRCO0FBQ3hCLGdCQUFJQSxLQUFLLENBQUMsQ0FBRCxDQUFULEVBQWM7QUFDVixrQkFBSUUsaUJBQWlCLEdBQUdGLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU0MsS0FBVCxDQUFlLEdBQWYsQ0FBeEI7QUFDQSxrQkFBSUUsbUJBQW1CLEdBQUdILEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU0MsS0FBVCxDQUFlLEdBQWYsQ0FBMUI7O0FBRUEsa0JBQUlFLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsS0FBMkJSLE9BQS9CLEVBQXdDO0FBQ3BDQyx1QkFBTyxHQUFHRSxHQUFWO0FBQ0E7QUFDSDs7QUFDRCxrQkFBSUksaUJBQWlCLENBQUMsQ0FBRCxDQUFqQixLQUF5QlAsT0FBN0IsRUFBc0M7QUFDbENDLHVCQUFPLEdBQUdFLEdBQVY7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxRQUFJLENBQUNGLE9BQUwsRUFBYztBQUNWakIsWUFBTSxDQUFDeUIsS0FBUCxDQUFhLGlDQUFpQ1YsU0FBakMsR0FBNkMsY0FBN0MsR0FBOERDLE9BQTlELEdBQXdFLG9CQUFyRjtBQUNIOztBQUVELFdBQU9DLE9BQVA7QUFDSCxHQTNFUTs7QUE2RVQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSVMsZ0JBQWMsRUFBRyx3QkFBVVgsU0FBVixFQUFxQkMsT0FBckIsRUFBOEJXLE1BQTlCLEVBQXNDO0FBQ25ELFFBQUlDLE1BQU0sR0FBRyxFQUFiOztBQUVBLFFBQUksS0FBS3hCLGFBQVQsRUFBd0I7QUFDcEI7QUFDQSxVQUFJYSxPQUFPLEdBQUcsS0FBS0gsVUFBTCxDQUFnQkMsU0FBaEIsRUFBMkJDLE9BQTNCLENBQWQ7O0FBRUEsVUFBSUMsT0FBSixFQUFhO0FBQ1Q7QUFDQSxZQUFJWSxTQUFTLEdBQUcsS0FBS3pCLGFBQUwsQ0FBbUJjLE1BQW5CLENBQTBCRCxPQUExQixDQUFoQixDQUZTLENBSVQ7O0FBQ0EsWUFBSUUsR0FBRyxHQUFHVSxTQUFTLENBQUNDLE9BQVYsQ0FBa0IsQ0FBbEIsQ0FBVjs7QUFDQSxZQUFJSCxNQUFKLEVBQVk7QUFDUixjQUFJQSxNQUFNLEtBQUtSLEdBQWYsRUFBb0I7QUFDaEJuQixrQkFBTSxDQUFDeUIsS0FBUCxDQUFhLDJCQUEyQkUsTUFBM0IsR0FBb0MsT0FBcEMsR0FBOENSLEdBQTlDLEdBQW9ELE1BQWpFO0FBQ0E7QUFDSDtBQUNKOztBQUVEUSxjQUFNLEdBQUdBLE1BQU0sSUFBSVIsR0FBbkI7QUFDQVMsY0FBTSxDQUFDVCxHQUFQLEdBQWFRLE1BQWIsQ0FkUyxDQWVUOztBQUNBQyxjQUFNLENBQUNHLEdBQVAsR0FBYUYsU0FBUyxDQUFDRyxZQUFWLENBQXVCTCxNQUF2QixDQUFiO0FBQ0FDLGNBQU0sQ0FBQ0ssT0FBUCxHQUFpQkosU0FBUyxDQUFDSyxnQkFBVixHQUE2QkQsT0FBOUM7QUFDQUwsY0FBTSxDQUFDTyxNQUFQLEdBQWdCTixTQUFTLENBQUNPLGVBQVYsRUFBaEI7QUFDQVIsY0FBTSxDQUFDUyxNQUFQLEdBQWdCUixTQUFTLENBQUNTLGdCQUFWLEVBQWhCO0FBQ0FWLGNBQU0sQ0FBQ1csVUFBUCxHQUFvQlYsU0FBUyxDQUFDVyxvQkFBVixFQUFwQixDQXBCUyxDQXNCVDs7QUFDQVosY0FBTSxDQUFDYSxRQUFQLEdBQWtCWixTQUFTLENBQUNhLHNCQUFWLEVBQWxCO0FBQ0FkLGNBQU0sQ0FBQ2UsUUFBUCxHQUFrQmQsU0FBUyxDQUFDZSxzQkFBVixFQUFsQjtBQUNBaEIsY0FBTSxDQUFDaUIsTUFBUCxHQUFnQmhCLFNBQVMsQ0FBQ2lCLE9BQVYsRUFBaEI7QUFDQWxCLGNBQU0sQ0FBQ21CLE9BQVAsR0FBaUJsQixTQUFTLENBQUNtQixVQUFWLEVBQWpCO0FBQ0FwQixjQUFNLENBQUNxQixRQUFQLEdBQWtCcEIsU0FBUyxDQUFDcUIsV0FBVixFQUFsQjtBQUNBdEIsY0FBTSxDQUFDdUIsV0FBUCxHQUFxQnRCLFNBQVMsQ0FBQ3VCLGNBQVYsRUFBckI7QUFDQXhCLGNBQU0sQ0FBQ3lCLEtBQVAsR0FBZXhCLFNBQVMsQ0FBQ3lCLFFBQVYsRUFBZjtBQUNBMUIsY0FBTSxDQUFDMkIsV0FBUCxHQUFxQjFCLFNBQVMsQ0FBQzJCLGNBQVYsRUFBckI7QUFDQTVCLGNBQU0sQ0FBQzZCLFlBQVAsR0FBc0I1QixTQUFTLENBQUM2QixlQUFWLEVBQXRCLENBL0JTLENBaUNUOztBQUNBLFlBQUk3QixTQUFTLENBQUM4QixXQUFkLEVBQTJCO0FBQ3ZCL0IsZ0JBQU0sQ0FBQ2dDLG1CQUFQLEdBQTZCL0IsU0FBUyxDQUFDOEIsV0FBVixDQUFzQkMsbUJBQW5EO0FBQ0gsU0FwQ1EsQ0FzQ1Q7OztBQUNBLFlBQUlDLE9BQU8sR0FBR2hDLFNBQVMsQ0FBQ2lDLFFBQVYsRUFBZDs7QUFDQSxZQUFJRCxPQUFKLEVBQWE7QUFDVGpDLGdCQUFNLENBQUNpQyxPQUFQLEdBQWlCQSxPQUFqQjtBQUNBLGNBQUlFLE9BQU8sR0FBRyxLQUFLM0QsYUFBTCxDQUFtQjRELFVBQW5CLENBQThCSCxPQUE5QixDQUFkLENBRlMsQ0FHVDs7QUFDQWpDLGdCQUFNLENBQUNxQyxZQUFQLEdBQXNCRixPQUFPLENBQUNHLGdCQUFSLEVBQXRCO0FBQ0F0QyxnQkFBTSxDQUFDdUMsaUJBQVAsR0FBMkJKLE9BQU8sQ0FBQ0ksaUJBQW5DO0FBQ0F2QyxnQkFBTSxDQUFDd0MsU0FBUCxHQUFtQkwsT0FBTyxDQUFDSyxTQUEzQjtBQUNBeEMsZ0JBQU0sQ0FBQ3lDLFlBQVAsR0FBc0JOLE9BQU8sQ0FBQ00sWUFBOUI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsV0FBT3pDLE1BQVA7QUFDSCxHQXJLUTs7QUF1S1Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSU0sa0JBQWdCLEVBQUcsMEJBQVVvQyxRQUFWLEVBQW9CdEQsT0FBcEIsRUFBNkJjLE9BQTdCLEVBQXNDO0FBQ3JELFFBQUlGLE1BQU0sR0FBRyxFQUFiOztBQUVBLFFBQUksS0FBS3hCLGFBQVQsRUFBd0I7QUFDcEI7QUFDQSxVQUFJYSxPQUFPLEdBQUcsS0FBS0gsVUFBTCxDQUFnQndELFFBQWhCLEVBQTBCdEQsT0FBMUIsQ0FBZDs7QUFFQSxVQUFJQyxPQUFKLEVBQWE7QUFDVDtBQUNBLFlBQUlZLFNBQVMsR0FBRyxLQUFLekIsYUFBTCxDQUFtQmMsTUFBbkIsQ0FBMEJELE9BQTFCLENBQWhCLENBRlMsQ0FJVDs7QUFDQSxZQUFJRSxHQUFHLEdBQUdVLFNBQVMsQ0FBQ0MsT0FBVixDQUFrQixDQUFsQixDQUFWOztBQUNBLFlBQUlBLE9BQUosRUFBYTtBQUNULGNBQUksQ0FBQ3lDLEtBQUssQ0FBQ0MsT0FBTixDQUFjMUMsT0FBZCxDQUFMLEVBQTZCO0FBQ3pCQSxtQkFBTyxHQUFHLENBQUNBLE9BQUQsQ0FBVjtBQUNIOztBQUNELGVBQUssSUFBSTJDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUczQyxPQUFPLENBQUNqQixNQUE1QixFQUFvQzRELENBQUMsRUFBckMsRUFBeUM7QUFDckMsZ0JBQUkzQyxPQUFPLENBQUMyQyxDQUFELENBQVAsS0FBZXRELEdBQW5CLEVBQXdCO0FBQ3BCLGtCQUFJdUQsUUFBUSxHQUFHRCxDQUFmO0FBQ0E7QUFDSDtBQUNKLFdBVFEsQ0FVVDs7O0FBQ0EsY0FBSSxPQUFPQyxRQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ2pDO0FBQ0g7QUFDSixTQXBCUSxDQXNCVDs7O0FBQ0EsWUFBSS9DLE1BQU0sR0FBR0csT0FBTyxDQUFDNEMsUUFBRCxDQUFQLElBQXFCdkQsR0FBbEM7QUFDQVMsY0FBTSxDQUFDVCxHQUFQLEdBQWFRLE1BQWIsQ0F4QlMsQ0F5QlQ7O0FBQ0FDLGNBQU0sQ0FBQ0csR0FBUCxHQUFhRixTQUFTLENBQUNHLFlBQVYsQ0FBdUJMLE1BQXZCLENBQWI7QUFDQUMsY0FBTSxDQUFDSyxPQUFQLEdBQWlCSixTQUFTLENBQUNLLGdCQUFWLEdBQTZCRCxPQUE5QyxDQTNCUyxDQTZCVDs7QUFDQUwsY0FBTSxDQUFDaUIsTUFBUCxHQUFnQmhCLFNBQVMsQ0FBQ2lCLE9BQVYsRUFBaEI7QUFDQWxCLGNBQU0sQ0FBQ3lCLEtBQVAsR0FBZXhCLFNBQVMsQ0FBQ3lCLFFBQVYsRUFBZjtBQUNBMUIsY0FBTSxDQUFDMkIsV0FBUCxHQUFxQjFCLFNBQVMsQ0FBQzJCLGNBQVYsRUFBckI7QUFDSDtBQUNKOztBQUVELFdBQU81QixNQUFQO0FBQ0gsR0FoT1E7O0FBa09UO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0krQyxnQkFBYyxFQUFHLDBCQUFZO0FBQ3pCLFFBQUlDLFdBQVcsR0FBRyxFQUFsQjs7QUFFQSxRQUFJLEtBQUt4RSxhQUFULEVBQXdCO0FBQ3BCd0UsaUJBQVcsR0FBRyxLQUFLeEUsYUFBTCxDQUFtQixnQkFBbkIsRUFBcUMsa0JBQXJDLENBQWQ7QUFDSDs7QUFFRCxXQUFPd0UsV0FBUDtBQUNILEdBalBROztBQW1QVDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lDLGVBQWEsRUFBRyx1QkFBVUMsT0FBVixFQUFtQjtBQUMvQixRQUFJQyxHQUFHLEdBQUcsRUFBVjs7QUFFQSxRQUFJLEtBQUszRSxhQUFULEVBQXdCO0FBQ3BCLFVBQUkwRSxPQUFKLEVBQWE7QUFDVEMsV0FBRyxHQUFHLEtBQUszRSxhQUFMLENBQW1CLGdCQUFuQixFQUFxQzBFLE9BQU8sQ0FBQ0UsV0FBUixFQUFyQyxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxXQUFPRCxHQUFQO0FBQ0gsR0FyUVE7O0FBdVFUO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJRSxzQkFBb0IsRUFBRyw4QkFBVWhFLE9BQVYsRUFBbUI7QUFDdEMsUUFBSVcsTUFBTSxHQUFHLEVBQWI7O0FBRUEsUUFBSVgsT0FBSixFQUFhO0FBQ1Q7QUFDQSxVQUFJWSxTQUFTLEdBQUcsS0FBS3pCLGFBQUwsQ0FBbUJjLE1BQW5CLENBQTBCRCxPQUExQixDQUFoQjtBQUNBVyxZQUFNLENBQUNXLFVBQVAsR0FBb0JWLFNBQVMsQ0FBQ1csb0JBQVYsRUFBcEI7QUFDQVosWUFBTSxDQUFDYSxRQUFQLEdBQWtCWixTQUFTLENBQUNhLHNCQUFWLEVBQWxCO0FBQ0FkLFlBQU0sQ0FBQ2UsUUFBUCxHQUFrQmQsU0FBUyxDQUFDZSxzQkFBVixFQUFsQjtBQUNBaEIsWUFBTSxDQUFDaUIsTUFBUCxHQUFnQmhCLFNBQVMsQ0FBQ2lCLE9BQVYsRUFBaEI7QUFDSDs7QUFFRCxXQUFPbEIsTUFBUDtBQUNIO0FBaFNRLENBQWI7QUFtU2V6QixxRUFBZixFIiwiZmlsZSI6Ii4vc3JjL0NvbW1vbi9VdGlscy9Db25maWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cbnZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiY29uZmlnXCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgQ29uZmlnXG4gKiBAYWxpYXMgW3ByaXZhdGVdIENvbmZpZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAuLi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNDb25maWdMb2FkZWQoKTtcbiAqIGdldExheWVySWQoKTtcbiAqIGdldExheWVyUGFyYW1zKCk7XG4gKiBnZXRTZXJ2aWNlUGFyYW1zKCk7XG4gKiBnZXRSZXNvbHV0aW9ucygpO1xuICogZ2V0R2xvYmFsQ29uc3RyYWludHMoKTtcbiAqIGdldFRpbGVNYXRyaXgoKTtcbiAqL1xudmFyIENvbmZpZyA9IHtcblxuICAgIC8qKlxuICAgICAqIGF1dG9jb25mXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBjb25maWd1cmF0aW9uIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xlIGR1IGNoYXJnZW1lbnQgZGUgbCdhdXRvY29uZlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGlzQ29uZmlnTG9hZGVkXG4gICAgICogQHRoaXMgQ29uZmlnXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIHNpIGwnYXV0b2NvbmYgYSBkw6lqw6Agw6l0w6kgY2hhcmfDqWUsIEZhbHNlIHNpbm9uLlxuICAgICAqL1xuICAgIGlzQ29uZmlnTG9hZGVkIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xuICAgICAgICBpZiAoc2NvcGUuR3AgJiYgc2NvcGUuR3AuQ29uZmlnICYmIE9iamVjdC5rZXlzKHNjb3BlLkdwLkNvbmZpZykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvKiogdHMtc3ludGF4ICovICh0aGlzLmNvbmZpZ3VyYXRpb24pID0gc2NvcGUuR3AuQ29uZmlnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cGVyYXRpb24gZGUgbCdpZGVudGlmaWFudCBkJ3VuZSBjb3VjaGUgZG9ubsOpZVxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGdldExheWVySWRcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSAtIG5vbSBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZSAgIC0gbm9tIGR1IHNlcnZpY2UgKHBhciBleC4gXCJXTVNcIiBvdSBcIldNVFNcIilcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBJZGVudGlmaWFudCBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1MkR0VPUE9SVEFJTDpPR0M6V01UU1wiKVxuICAgICAqL1xuICAgIGdldExheWVySWQgOiBmdW5jdGlvbiAobGF5ZXJOYW1lLCBzZXJ2aWNlKSB7XG4gICAgICAgIHZhciBsYXllcklkID0gbnVsbDtcblxuICAgICAgICAvLyBsYXllclxuICAgICAgICAvLyBrZXkgOiBbbGF5ZXJOYW1lXSRbY29udGV4dGVdOk9HQzpbc2VydmljZV1cbiAgICAgICAgLy8gZXggOiBcIk9SVEhPSU1BR0VSWS5PUlRIT1BIT1RPUyRHRU9QT1JUQUlMOk9HQzpXTVRTXCJcblxuICAgICAgICAvLyBzZXJ2aWNlXG4gICAgICAgIC8vIGtleSA6IFtsYXllck5hbWVdJFtjb250ZXh0ZV07W3NlcnZpY2VdXG4gICAgICAgIC8vIGV4IDogUG9zaXRpb25PZkludGVyZXN0JE9HQzpPUEVOTFM7UmV2ZXJzZUdlb2NvZGVcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5jb25maWd1cmF0aW9uW1wibGF5ZXJzXCJdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGxheWVycykge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoXCIkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJOYW1lID09PSBwYXJ0c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZpY2VQYXJ0c0xheWVyID0gcGFydHNbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2aWNlUGFydHNTZXJ2aWNlID0gcGFydHNbMV0uc3BsaXQoXCI7XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VQYXJ0c1NlcnZpY2VbMV0gPT09IHNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlUGFydHNMYXllclsyXSA9PT0gc2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcklkID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXllcklkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFUlJPUiBsYXllciBpZCAobGF5ZXIgbmFtZTogXCIgKyBsYXllck5hbWUgKyBcIiAvIHNlcnZpY2U6IFwiICsgc2VydmljZSArIFwiKSB3YXMgbm90IGZvdW5kICE/XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVySWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBuw6ljZXNzYWlyZXMgw6AgbCdhZmZpY2hhZ2UgZCd1bmUgY291Y2hlIFdNUyBvdSBXTVRTXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gZ2V0TGF5ZXJQYXJhbXNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSAtIG5vbSBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZSAgIC0gbm9tIGR1IHNlcnZpY2UgKHBhciBleC4gXCJXTVNcIiBvdSBcIldNVFNcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FwaUtleV0gIC0gQ2zDqSBkZSBjb250cmF0IEFQSVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBhcmFtcyAgLSBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlIChXTVMgb3UgV01UUykgcG91ciBsYSBjb3VjaGUgZG9ubsOpZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy51cmwgICAgICAgIC0gVXJsIGR1IHNlcnZpY2Ugw6AgcmVxdcOqdGVyIHBvdXIgYWZmaWNoZXIgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcGFyYW1zLnZlcnNpb24gICAgLSBWZXJzaW9uIGR1IHNlcnZpY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuc3R5bGVzICAgICAtIFN0eWxlIHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5mb3JtYXQgICAgIC0gRm9ybWF0IHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5wcm9qZWN0aW9uIC0gUHJvamVjdGlvbiBwYXIgZMOpZmF1dCBkZSBsYSBjb3VjaGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBwYXJhbXMubWluU2NhbGUgICAtIETDqW5vbWluYXRldXIgZCfDqWNoZWxsZSBtaW5pbXVtIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBhcmFtcy5tYXhTY2FsZSAgIC0gRMOpbm9taW5hdGV1ciBkJ8OpY2hlbGxlIG1heGltdW0gZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0dwLkJCb3h9IHBhcmFtcy5leHRlbnQgICAgLSBFdGVuZHVlIGRlIGxhIGNvdWNoZSwgZGFucyBsYSBwcm9qZWN0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLmxlZ2VuZHMgICAgIC0gVGFibGVhdSBkZXMgbMOpZ2VuZGVzIGFzc29jacOpZXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMubWV0YWRhdGEgICAgLSBUYWJsZWF1IGRlcyBtw6l0YWRvbm7DqWVzIGFzc29jacOpZXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMub3JpZ2luYXRvcnMgLSBUYWJsZWF1IGRlcyBvcmlnaW5hdG9ycyBhc3NvY2nDqXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMudGl0bGUgICAgICAgLSBOb20gZGUgbGEgcmVzb3VyY2UsIGxpc2libGUgcGFyIHVuIGh1bWFpbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIFVybCBkZSBsJ2ltYWdlIGQnYXBlcsOndSByYXBpZGUgZGUgbGEgcmVzc291cmNlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLnF1aWNrbG9va1VybC0gVGFibGVhdSBkZXMgb3JpZ2luYXRvcnMgYXNzb2Npw6lzIMOgIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5bVE1TTGlua10gICAgICAgICAgLSBJZGVudGlmaWFudCBkZSBsYSBweXJhbWlkZSAoVE1TKSwgZGFucyBsZSBjYXMgZCd1bmUgY291Y2hlIFdNVFNcbiAgICAgKiBAcmV0dXJucyB7R3AuUG9pbnR9IHBhcmFtcy5bbWF0cml4T3JpZ2luXSAgIC0gT3JpZ2luZSBkZSBsYSBtYXRyaWNlICh0b3AgbGVmdCBjb3JuZXIpLCBkYW5zIGxlIGNhcyBkJ3VuZSBjb3VjaGUgV01UU1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLltuYXRpdmVSZXNvbHV0aW9uc10gLSBUYWJsZWF1IHJlZ3JvdXBhbnQgbGVzIHLDqXNvbHV0aW9ucyBkZSBjaGFxdWUgbml2ZWF1IGRlIGxhIG1hdHJpY2UsIGRhbnMgbGUgY2FzIGQndW5lIGNvdWNoZSBXTVRTXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMuW21hdHJpeElkc10gICAgICAgICAtIFRhYmxlYXUgcmVncm91cGFudCBsZXMgaWRlbnRpZmlhbnRzIGRlIGNoYXF1ZSBuaXZlYXUgZGUgbGEgbWF0cmljZSwgZGFucyBsZSBjYXMgZCd1bmUgY291Y2hlIFdNVFNcbiAgICAgKi9cbiAgICBnZXRMYXllclBhcmFtcyA6IGZ1bmN0aW9uIChsYXllck5hbWUsIHNlcnZpY2UsIGFwaUtleSkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCdpZGVudGlmaWFudCBjb21wbGV0IGRlIGxhIGNvdWNoZS5cbiAgICAgICAgICAgIHZhciBsYXllcklkID0gdGhpcy5nZXRMYXllcklkKGxheWVyTmFtZSwgc2VydmljZSk7XG5cbiAgICAgICAgICAgIGlmIChsYXllcklkKSB7XG4gICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCdvYmpldCBkZSBjb25maWd1cmF0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubGF5ZXJzW2xheWVySWRdO1xuXG4gICAgICAgICAgICAgICAgLy8gY29udHJvbGUgZGUgbGEgY2xlZlxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBsYXllckNvbmYuYXBpS2V5c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcGlLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRVJST1IgZGlmZmVyZW50IGtleXMgKFwiICsgYXBpS2V5ICsgXCIgIT09IFwiICsga2V5ICsgXCIpICE/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXBpS2V5ID0gYXBpS2V5IHx8IGtleTtcbiAgICAgICAgICAgICAgICBwYXJhbXMua2V5ID0gYXBpS2V5O1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IGxheWVyQ29uZi5nZXRTZXJ2ZXJVcmwoYXBpS2V5KTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmVyc2lvbiA9IGxheWVyQ29uZi5nZXRTZXJ2aWNlUGFyYW1zKCkudmVyc2lvbjtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3R5bGVzID0gbGF5ZXJDb25mLmdldERlZmF1bHRTdHlsZSgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSBsYXllckNvbmYuZ2V0RGVmYXVsdEZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wcm9qZWN0aW9uID0gbGF5ZXJDb25mLmdldERlZmF1bHRQcm9qZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZXMgaW5mb3MgZGUgbGEgY291Y2hlXG4gICAgICAgICAgICAgICAgcGFyYW1zLm1pblNjYWxlID0gbGF5ZXJDb25mLmdldE1pblNjYWxlRGVub21pbmF0b3IoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMubWF4U2NhbGUgPSBsYXllckNvbmYuZ2V0TWF4U2NhbGVEZW5vbWluYXRvcigpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5leHRlbnQgPSBsYXllckNvbmYuZ2V0QkJPWCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5sZWdlbmRzID0gbGF5ZXJDb25mLmdldExlZ2VuZHMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMubWV0YWRhdGEgPSBsYXllckNvbmYuZ2V0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMub3JpZ2luYXRvcnMgPSBsYXllckNvbmYuZ2V0T3JpZ2luYXRvcnMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudGl0bGUgPSBsYXllckNvbmYuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGVzY3JpcHRpb24gPSBsYXllckNvbmYuZ2V0RGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMucXVpY2tsb29rVXJsID0gbGF5ZXJDb25mLmdldFF1aWNrbG9va1VybCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gV01UUyA6IHLDqWN1cMOpcmF0aW9uIGRlcyB0aWxlTWF0cml4U2V0TGltaXRzXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyQ29uZi53bXRzT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGlsZU1hdHJpeFNldExpbWl0cyA9IGxheWVyQ29uZi53bXRzT3B0aW9ucy50aWxlTWF0cml4U2V0TGltaXRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdNVFMgOiByw6ljdXDDqXJhdGlvbiBkZXMgcGFyYW3DqHRyZXMgZGUgbGEgcHlyYW1pZGUgKFRNUylcbiAgICAgICAgICAgICAgICB2YXIgVE1TTGluayA9IGxheWVyQ29uZi5nZXRUTVNJRCgpO1xuICAgICAgICAgICAgICAgIGlmIChUTVNMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5UTVNMaW5rID0gVE1TTGluaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtc0NvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24uZ2V0VE1TQ29uZihUTVNMaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG1hdHJpeCBvcmlnaW4gOiBHcC5Qb2ludCA9IE9iamVjdHt4OkZsb2F0LCB5OkZsb2F0fVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubWF0cml4T3JpZ2luID0gdG1zQ29uZi5nZXRUb3BMZWZ0Q29ybmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5uYXRpdmVSZXNvbHV0aW9ucyA9IHRtc0NvbmYubmF0aXZlUmVzb2x1dGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5tYXRyaXhJZHMgPSB0bXNDb25mLm1hdHJpeElkcztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRpbGVNYXRyaWNlcyA9IHRtc0NvbmYudGlsZU1hdHJpY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlY3VwZXJhdGlvbiBkZXMgcGFyYW1ldHJlcyBkJ3VuIHNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBnZXRTZXJ2aWNlUGFyYW1zXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVzb3VyY2VdIC0gXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJTdHJlZXRBZGRyZXNzXCIsIFwiVm9pdHVyZVwiLCBcIlBpZXRvblwiLCAuLi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlcnZpY2VdIC0gR2VvY29kZSwgSXRpbmVyYWlyZSwgLi4uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FwaUtleXNdICAtIENsw6kocykgZGUgY29udHJhdCBBUElcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbcOodHJlcyBkZSBsYSByZXNzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlUGFyYW1zIDogZnVuY3Rpb24gKHJlc291cmNlLCBzZXJ2aWNlLCBhcGlLZXlzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZSBsJ2lkZW50aWZpYW50IGNvbXBsZXQgZGUgbGEgY291Y2hlLlxuICAgICAgICAgICAgdmFyIGxheWVySWQgPSB0aGlzLmdldExheWVySWQocmVzb3VyY2UsIHNlcnZpY2UpO1xuXG4gICAgICAgICAgICBpZiAobGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlIGwnb2JqZXQgZGUgY29uZmlndXJhdGlvbiBkZSBsYSBjb3VjaGVcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJDb25mID0gdGhpcy5jb25maWd1cmF0aW9uLmxheWVyc1tsYXllcklkXTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRyb2xlIGRlIGxhIGNsZWYgKG9uIHByZW5kIGxhIHByZW1pw6hyZSBjbMOpIGRpc3BvbmlibGUgcXVpIGVzdCBjZW5zw6llIGF2b2lyIGFjY8OocyDDoCBsYSByZXNzb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGxheWVyQ29uZi5hcGlLZXlzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcGlLZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5cyA9IFthcGlLZXlzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFwaUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcGlLZXlzW2ldID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHNpIGF1Y3VuZSBjbMOpIGR1IHRhYmxlYXUgYXBpS2V5cyBuZSBjb3JyZXNwb25kLCBvbiByZXRvdXJuZSByaWVuID0+IHBhcyBkZSBkcm9pdHMgcG91ciBsYSByZXNzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXlJbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb24gcmV0b3VybmUgbGEgcHJlbWnDqHJlIGNsw6kgcXVpIGEgZWZmZWN0aXZlbWVudCBhY2PDqHMgw6AgbGEgcmVzc291cmNlXG4gICAgICAgICAgICAgICAgdmFyIGFwaUtleSA9IGFwaUtleXNba2V5SW5kZXhdIHx8IGtleTtcbiAgICAgICAgICAgICAgICBwYXJhbXMua2V5ID0gYXBpS2V5O1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IGxheWVyQ29uZi5nZXRTZXJ2ZXJVcmwoYXBpS2V5KTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmVyc2lvbiA9IGxheWVyQ29uZi5nZXRTZXJ2aWNlUGFyYW1zKCkudmVyc2lvbjtcblxuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBpbmZvcyBkZSBsYSBjb3VjaGVcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXh0ZW50ID0gbGF5ZXJDb25mLmdldEJCT1goKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudGl0bGUgPSBsYXllckNvbmYuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGVzY3JpcHRpb24gPSBsYXllckNvbmYuZ2V0RGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc29sdXRpb24gZW4gZ2VvZ3JhcGhpcXVlXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbnNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge0FycmF5fSByZXNvbHV0aW9uc1xuICAgICAqL1xuICAgIGdldFJlc29sdXRpb25zIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXNvbHV0aW9ucyA9IHRoaXMuY29uZmlndXJhdGlvbltcImdlbmVyYWxPcHRpb25zXCJdW1wid2dzODRSZXNvbHV0aW9uc1wiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHV0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVjdXBlcmF0aW9uIGRlcyBwYXJhbWV0cmVzIFRNUyBkZSBsYSBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gZ2V0VGlsZU1hdHJpeFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG1zTmFtZSAtIHRpbGUgbWF0cml4IHNldCBuYW1lXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGlsZSBtYXRyaXggc2V0XG4gICAgICovXG4gICAgZ2V0VGlsZU1hdHJpeCA6IGZ1bmN0aW9uICh0bXNOYW1lKSB7XG4gICAgICAgIHZhciB0bXMgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodG1zTmFtZSkge1xuICAgICAgICAgICAgICAgIHRtcyA9IHRoaXMuY29uZmlndXJhdGlvbltcInRpbGVNYXRyaXhTZXRzXCJdW3Rtc05hbWUudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSw6ljdXDDqXJhdGlvbiBkZXMgY29udHJhaW50ZXMgZ8OpbsOpcmFsZXMgZCd1bmUgY291Y2hlIGRvbm7DqWUgOiBleHRlbnQsIG1pblNjYWxlLCBtYXhTY2FsZSwgcHJvamVjdGlvblxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGdldEdsb2JhbENvbnN0cmFpbnRzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gaWRlbnRpZmlhbnQgZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFyYW1zIC0gY29udHJhaW50ZXMgZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcGFyYW1zLnByb2plY3Rpb24gLSBQcm9qZWN0aW9uIHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBhcmFtcy5taW5TY2FsZSAgIC0gRMOpbm9taW5hdGV1ciBkJ8OpY2hlbGxlIG1pbmltdW0gZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge051bWJlcn0gcGFyYW1zLm1heFNjYWxlICAgLSBEw6lub21pbmF0ZXVyIGQnw6ljaGVsbGUgbWF4aW11bSBkZSBsYSBjb3VjaGVcbiAgICAgKiBAcmV0dXJucyB7R3AuQkJveH0gcGFyYW1zLmV4dGVudCAgICAtIEV0ZW5kdWUgZGUgbGEgY291Y2hlLCBkYW5zIGxhIHByb2plY3Rpb24gZGUgbGEgY291Y2hlXG4gICAgICovXG4gICAgZ2V0R2xvYmFsQ29uc3RyYWludHMgOiBmdW5jdGlvbiAobGF5ZXJJZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICAgICAgaWYgKGxheWVySWQpIHtcbiAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlIGwnb2JqZXQgZGUgY29uZmlndXJhdGlvbiBkZSBsYSBjb3VjaGVcbiAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubGF5ZXJzW2xheWVySWRdO1xuICAgICAgICAgICAgcGFyYW1zLnByb2plY3Rpb24gPSBsYXllckNvbmYuZ2V0RGVmYXVsdFByb2plY3Rpb24oKTtcbiAgICAgICAgICAgIHBhcmFtcy5taW5TY2FsZSA9IGxheWVyQ29uZi5nZXRNaW5TY2FsZURlbm9taW5hdG9yKCk7XG4gICAgICAgICAgICBwYXJhbXMubWF4U2NhbGUgPSBsYXllckNvbmYuZ2V0TWF4U2NhbGVEZW5vbWluYXRvcigpO1xuICAgICAgICAgICAgcGFyYW1zLmV4dGVudCA9IGxheWVyQ29uZi5nZXRCQk9YKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Utils/Config.js\n");

/***/ }),

/***/ "./src/Common/Utils/LoggerByDefault.js":
/*!*********************************************!*\
  !*** ./src/Common/Utils/LoggerByDefault.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * @module LoggerByDefault\n * @alias [private] LoggerByDefault\n * @description\n * ...\n *\n * @example\n * getLogger();\n * disableAll();\n * enableAll();\n */\n\nvar LoggerByDefault = {\n  /**\n   * creation d'un logger statique\n   *\n   * @function getLogger\n   * @param {String} [name=\"default\"] - the logger name\n   * @returns {Object} logger\n   */\n  getLogger: function getLogger(name) {\n    // INFO :\n    // à la compilation en mode production, on substitue false\n    // avec \"true\", ceci desactive les loggers !\n    //\n    // à la compilation en mode developpement, on substitue false\n    // avec \"false\", ceci permet d'avoir les loggers actifs !\n    //\n    // lors d'une utilisation en module es6, il n'y a pas de substitution de false,\n    // les loggers sont donc actifs par defaut !\n    //\n    // > Substitute global constants configured at compile time\n    // cf. webpack.config.js\n    // on masque cette constante afin d'eviter \"referenceerror not defined\"\n    \"false\".match(/true/) ? loglevel__WEBPACK_IMPORTED_MODULE_0__[\"disableAll\"]() : loglevel__WEBPACK_IMPORTED_MODULE_0__[\"enableAll\"]();\n    var logname = name || \"default\";\n    return loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"](logname);\n  },\n\n  /**\n   * desactive tous les loggers\n   * @function disableAll\n   */\n  disableAll: function disableAll() {\n    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLoggers\"]();\n\n    for (var key in loggers) {\n      if (Object.hasOwnProperty.call(loggers, key)) {\n        var logger = loggers[key];\n        logger.disableAll();\n      }\n    }\n  },\n\n  /**\n   * active tous les loggers\n   * @function enableAll\n   */\n  enableAll: function enableAll() {\n    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLoggers\"]();\n\n    for (var key in loggers) {\n      if (Object.hasOwnProperty.call(loggers, key)) {\n        var logger = loggers[key];\n        logger.enableAll();\n      }\n    }\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (LoggerByDefault);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcz81YzkwIl0sIm5hbWVzIjpbIkxvZ2dlckJ5RGVmYXVsdCIsImdldExvZ2dlciIsIm5hbWUiLCJtYXRjaCIsIkxvZyIsImxvZ25hbWUiLCJkaXNhYmxlQWxsIiwibG9nZ2VycyIsImtleSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImxvZ2dlciIsImVuYWJsZUFsbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQUlBLGVBQWUsR0FBRztBQUNsQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxXQUFTLEVBQUcsbUJBQVVDLElBQVYsRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQyxxQkFBaUJDLEtBQWpCLENBQXVCLE1BQXZCLENBQUQsR0FBbUNDLG1EQUFBLEVBQW5DLEdBQXNEQSxrREFBQSxFQUF0RDtBQUNBLFFBQUlDLE9BQU8sR0FBR0gsSUFBSSxJQUFJLFNBQXRCO0FBQ0EsV0FBT0Usa0RBQUEsQ0FBY0MsT0FBZCxDQUFQO0FBQ0gsR0F6QmlCOztBQTBCbEI7QUFDSjtBQUNBO0FBQ0E7QUFDSUMsWUFBVSxFQUFHLHNCQUFZO0FBQ3JCLFFBQUlDLE9BQU8sR0FBR0gsbURBQUEsRUFBZDs7QUFDQSxTQUFLLElBQU1JLEdBQVgsSUFBa0JELE9BQWxCLEVBQTJCO0FBQ3ZCLFVBQUlFLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsSUFBdEIsQ0FBMkJKLE9BQTNCLEVBQW9DQyxHQUFwQyxDQUFKLEVBQThDO0FBQzFDLFlBQU1JLE1BQU0sR0FBR0wsT0FBTyxDQUFDQyxHQUFELENBQXRCO0FBQ0FJLGNBQU0sQ0FBQ04sVUFBUDtBQUNIO0FBQ0o7QUFDSixHQXRDaUI7O0FBdUNsQjtBQUNKO0FBQ0E7QUFDQTtBQUNJTyxXQUFTLEVBQUcscUJBQVk7QUFDcEIsUUFBSU4sT0FBTyxHQUFHSCxtREFBQSxFQUFkOztBQUNBLFNBQUssSUFBTUksR0FBWCxJQUFrQkQsT0FBbEIsRUFBMkI7QUFDdkIsVUFBSUUsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxJQUF0QixDQUEyQkosT0FBM0IsRUFBb0NDLEdBQXBDLENBQUosRUFBOEM7QUFDMUMsWUFBTUksTUFBTSxHQUFHTCxPQUFPLENBQUNDLEdBQUQsQ0FBdEI7QUFDQUksY0FBTSxDQUFDQyxTQUFQO0FBQ0g7QUFDSjtBQUNKO0FBbkRpQixDQUF0QjtBQXNEZWIsOEVBQWYiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIExvZyBmcm9tIFwibG9nbGV2ZWxcIjtcblxuLyoqXG4gKiBAbW9kdWxlIExvZ2dlckJ5RGVmYXVsdFxuICogQGFsaWFzIFtwcml2YXRlXSBMb2dnZXJCeURlZmF1bHRcbiAqIEBkZXNjcmlwdGlvblxuICogLi4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGdldExvZ2dlcigpO1xuICogZGlzYWJsZUFsbCgpO1xuICogZW5hYmxlQWxsKCk7XG4gKi9cbnZhciBMb2dnZXJCeURlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogY3JlYXRpb24gZCd1biBsb2dnZXIgc3RhdGlxdWVcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBnZXRMb2dnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9XCJkZWZhdWx0XCJdIC0gdGhlIGxvZ2dlciBuYW1lXG4gICAgICogQHJldHVybnMge09iamVjdH0gbG9nZ2VyXG4gICAgICovXG4gICAgZ2V0TG9nZ2VyIDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgLy8gSU5GTyA6XG4gICAgICAgIC8vIMOgIGxhIGNvbXBpbGF0aW9uIGVuIG1vZGUgcHJvZHVjdGlvbiwgb24gc3Vic3RpdHVlIF9fUFJPRFVDVElPTl9fXG4gICAgICAgIC8vIGF2ZWMgXCJ0cnVlXCIsIGNlY2kgZGVzYWN0aXZlIGxlcyBsb2dnZXJzICFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gw6AgbGEgY29tcGlsYXRpb24gZW4gbW9kZSBkZXZlbG9wcGVtZW50LCBvbiBzdWJzdGl0dWUgX19QUk9EVUNUSU9OX19cbiAgICAgICAgLy8gYXZlYyBcImZhbHNlXCIsIGNlY2kgcGVybWV0IGQnYXZvaXIgbGVzIGxvZ2dlcnMgYWN0aWZzICFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9ycyBkJ3VuZSB1dGlsaXNhdGlvbiBlbiBtb2R1bGUgZXM2LCBpbCBuJ3kgYSBwYXMgZGUgc3Vic3RpdHV0aW9uIGRlIF9fUFJPRFVDVElPTl9fLFxuICAgICAgICAvLyBsZXMgbG9nZ2VycyBzb250IGRvbmMgYWN0aWZzIHBhciBkZWZhdXQgIVxuICAgICAgICAvL1xuICAgICAgICAvLyA+IFN1YnN0aXR1dGUgZ2xvYmFsIGNvbnN0YW50cyBjb25maWd1cmVkIGF0IGNvbXBpbGUgdGltZVxuICAgICAgICAvLyBjZi4gd2VicGFjay5jb25maWcuanNcbiAgICAgICAgLy8gb24gbWFzcXVlIGNldHRlIGNvbnN0YW50ZSBhZmluIGQnZXZpdGVyIFwicmVmZXJlbmNlZXJyb3Igbm90IGRlZmluZWRcIlxuICAgICAgICAoXCJfX1BST0RVQ1RJT05fX1wiLm1hdGNoKC90cnVlLykpID8gTG9nLmRpc2FibGVBbGwoKSA6IExvZy5lbmFibGVBbGwoKTtcbiAgICAgICAgdmFyIGxvZ25hbWUgPSBuYW1lIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICByZXR1cm4gTG9nLmdldExvZ2dlcihsb2duYW1lKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRlc2FjdGl2ZSB0b3VzIGxlcyBsb2dnZXJzXG4gICAgICogQGZ1bmN0aW9uIGRpc2FibGVBbGxcbiAgICAgKi9cbiAgICBkaXNhYmxlQWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nZ2VycyA9IExvZy5nZXRMb2dnZXJzKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGxvZ2dlcnMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChsb2dnZXJzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nZ2VyID0gbG9nZ2Vyc1trZXldO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kaXNhYmxlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGFjdGl2ZSB0b3VzIGxlcyBsb2dnZXJzXG4gICAgICogQGZ1bmN0aW9uIGVuYWJsZUFsbFxuICAgICAqL1xuICAgIGVuYWJsZUFsbCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvZ2dlcnMgPSBMb2cuZ2V0TG9nZ2VycygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBsb2dnZXJzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobG9nZ2Vycywga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGxvZ2dlcnNba2V5XTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZW5hYmxlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2dnZXJCeURlZmF1bHQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Common/Utils/LoggerByDefault.js\n");

/***/ }),

/***/ "./src/Common/Utils/SelectorID.js":
/*!****************************************!*\
  !*** ./src/Common/Utils/SelectorID.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @module SelectorID\n * @alias [private] SelectorID\n * @description\n * formalisme d'un tag ID :\n * -> NAME(_ORDER)-1460636385836\n *\n * @example\n * Ex.\n *   GProutePoints-1460636385836\n *   GProutePoint_10-1460636385836\n */\nvar SelectorID = {\n  /**\n   * Construction d'un identifiant statique basé sur le timestamp,\n   * et qui s'incremente de +1 à chaque appel\n   * @function generate\n   */\n  generate: function () {\n    var timestamp = Math.floor(Date.now());\n    return function () {\n      return timestamp++;\n    };\n  }(),\n\n  /**\n   * nom du tag\n   * @function name\n   * @param {String} id - the id\n   * @returns {String} index\n   */\n  name: function name(id) {\n    var name = null;\n    var i = id.lastIndexOf(\"-\");\n\n    if (i === -1) {\n      name = id;\n    } else {\n      name = id.substring(0, i);\n    }\n\n    return name;\n  },\n\n  /**\n   * numero d'identifiant du tag\n   *\n   * @function index\n   * @param {String} id - the id\n   * @returns {String} index\n   */\n  index: function index(id) {\n    var index = null;\n    var name = this.name(id); // if (name !== id) {\n\n    var i = name.lastIndexOf(\"_\");\n\n    if (i !== -1) {\n      index = name.substring(i + 1);\n    } // }\n\n\n    return index;\n  },\n\n  /**\n   * uuid du tag\n   *\n   * @function uuid\n   * @param {String} id - the id\n   * @returns {String} uuid\n   */\n  uuid: function uuid(id) {\n    var uuid = null;\n    var i = id.lastIndexOf(\"-\");\n\n    if (i !== -1) {\n      uuid = parseInt(id.substring(i + 1), 10);\n    }\n\n    return uuid;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (SelectorID);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL1NlbGVjdG9ySUQuanM/ZTZjNSJdLCJuYW1lcyI6WyJTZWxlY3RvcklEIiwiZ2VuZXJhdGUiLCJ0aW1lc3RhbXAiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwibmFtZSIsImlkIiwiaSIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwiaW5kZXgiLCJ1dWlkIiwicGFyc2VJbnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSUEsVUFBVSxHQUFHO0FBRWI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxVQUFRLEVBQUksWUFBWTtBQUNwQixRQUFJQyxTQUFTLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxJQUFJLENBQUNDLEdBQUwsRUFBWCxDQUFoQjtBQUNBLFdBQU8sWUFBWTtBQUNmLGFBQU9KLFNBQVMsRUFBaEI7QUFDSCxLQUZEO0FBR0gsR0FMVSxFQVBFOztBQWNiO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJSyxNQUFJLEVBQUcsY0FBVUMsRUFBVixFQUFjO0FBQ2pCLFFBQUlELElBQUksR0FBRyxJQUFYO0FBRUEsUUFBSUUsQ0FBQyxHQUFHRCxFQUFFLENBQUNFLFdBQUgsQ0FBZSxHQUFmLENBQVI7O0FBQ0EsUUFBSUQsQ0FBQyxLQUFLLENBQUMsQ0FBWCxFQUFjO0FBQ1ZGLFVBQUksR0FBR0MsRUFBUDtBQUNILEtBRkQsTUFFTztBQUNIRCxVQUFJLEdBQUdDLEVBQUUsQ0FBQ0csU0FBSCxDQUFhLENBQWIsRUFBZ0JGLENBQWhCLENBQVA7QUFDSDs7QUFFRCxXQUFPRixJQUFQO0FBQ0gsR0EvQlk7O0FBaUNiO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lLLE9BQUssRUFBRyxlQUFVSixFQUFWLEVBQWM7QUFDbEIsUUFBSUksS0FBSyxHQUFHLElBQVo7QUFFQSxRQUFJTCxJQUFJLEdBQUcsS0FBS0EsSUFBTCxDQUFVQyxFQUFWLENBQVgsQ0FIa0IsQ0FJbEI7O0FBQ0EsUUFBSUMsQ0FBQyxHQUFHRixJQUFJLENBQUNHLFdBQUwsQ0FBaUIsR0FBakIsQ0FBUjs7QUFDQSxRQUFJRCxDQUFDLEtBQUssQ0FBQyxDQUFYLEVBQWM7QUFDVkcsV0FBSyxHQUFHTCxJQUFJLENBQUNJLFNBQUwsQ0FBZUYsQ0FBQyxHQUFHLENBQW5CLENBQVI7QUFDSCxLQVJpQixDQVNsQjs7O0FBRUEsV0FBT0csS0FBUDtBQUNILEdBcERZOztBQXNEYjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxNQUFJLEVBQUcsY0FBVUwsRUFBVixFQUFjO0FBQ2pCLFFBQUlLLElBQUksR0FBRyxJQUFYO0FBRUEsUUFBSUosQ0FBQyxHQUFHRCxFQUFFLENBQUNFLFdBQUgsQ0FBZSxHQUFmLENBQVI7O0FBQ0EsUUFBSUQsQ0FBQyxLQUFLLENBQUMsQ0FBWCxFQUFjO0FBQ1ZJLFVBQUksR0FBR0MsUUFBUSxDQUFDTixFQUFFLENBQUNHLFNBQUgsQ0FBYUYsQ0FBQyxHQUFHLENBQWpCLENBQUQsRUFBc0IsRUFBdEIsQ0FBZjtBQUNIOztBQUVELFdBQU9JLElBQVA7QUFDSDtBQXRFWSxDQUFqQjtBQTBFZWIseUVBQWYiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL1V0aWxzL1NlbGVjdG9ySUQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgU2VsZWN0b3JJRFxuICogQGFsaWFzIFtwcml2YXRlXSBTZWxlY3RvcklEXG4gKiBAZGVzY3JpcHRpb25cbiAqIGZvcm1hbGlzbWUgZCd1biB0YWcgSUQgOlxuICogLT4gTkFNRShfT1JERVIpLTE0NjA2MzYzODU4MzZcbiAqXG4gKiBAZXhhbXBsZVxuICogRXguXG4gKiAgIEdQcm91dGVQb2ludHMtMTQ2MDYzNjM4NTgzNlxuICogICBHUHJvdXRlUG9pbnRfMTAtMTQ2MDYzNjM4NTgzNlxuICovXG52YXIgU2VsZWN0b3JJRCA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGlvbiBkJ3VuIGlkZW50aWZpYW50IHN0YXRpcXVlIGJhc8OpIHN1ciBsZSB0aW1lc3RhbXAsXG4gICAgICogZXQgcXVpIHMnaW5jcmVtZW50ZSBkZSArMSDDoCBjaGFxdWUgYXBwZWxcbiAgICAgKiBAZnVuY3Rpb24gZ2VuZXJhdGVcbiAgICAgKi9cbiAgICBnZW5lcmF0ZSA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcCsrO1xuICAgICAgICB9O1xuICAgIH0pKCksXG5cbiAgICAvKipcbiAgICAgKiBub20gZHUgdGFnXG4gICAgICogQGZ1bmN0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpbmRleFxuICAgICAqL1xuICAgIG5hbWUgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuXG4gICAgICAgIHZhciBpID0gaWQubGFzdEluZGV4T2YoXCItXCIpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5hbWUgPSBpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBpZC5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbnVtZXJvIGQnaWRlbnRpZmlhbnQgZHUgdGFnXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpbmRleFxuICAgICAqL1xuICAgIGluZGV4IDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG51bGw7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUoaWQpO1xuICAgICAgICAvLyBpZiAobmFtZSAhPT0gaWQpIHtcbiAgICAgICAgdmFyIGkgPSBuYW1lLmxhc3RJbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleCA9IG5hbWUuc3Vic3RyaW5nKGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1dWlkIGR1IHRhZ1xuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIHV1aWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1dWlkXG4gICAgICovXG4gICAgdXVpZCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgdXVpZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGkgPSBpZC5sYXN0SW5kZXhPZihcIi1cIik7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdXVpZCA9IHBhcnNlSW50KGlkLnN1YnN0cmluZyhpICsgMSksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dWlkO1xuICAgIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0b3JJRDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Utils/SelectorID.js\n");

/***/ }),

/***/ "./src/Leaflet/CSS/Controls/ReverseGeocoding/GPreverseGeocodingLeaflet.css":
/*!*********************************************************************************!*\
  !*** ./src/Leaflet/CSS/Controls/ReverseGeocoding/GPreverseGeocodingLeaflet.css ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9DU1MvQ29udHJvbHMvUmV2ZXJzZUdlb2NvZGluZy9HUHJldmVyc2VHZW9jb2RpbmdMZWFmbGV0LmNzcz9iNmMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vc3JjL0xlYWZsZXQvQ1NTL0NvbnRyb2xzL1JldmVyc2VHZW9jb2RpbmcvR1ByZXZlcnNlR2VvY29kaW5nTGVhZmxldC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Leaflet/CSS/Controls/ReverseGeocoding/GPreverseGeocodingLeaflet.css\n");

/***/ }),

/***/ "./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css":
/*!****************************************************!*\
  !*** ./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9DU1MvR1BnZW5lcmFsV2lkZ2V0TGVhZmxldC5jc3M/NjAxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuL3NyYy9MZWFmbGV0L0NTUy9HUGdlbmVyYWxXaWRnZXRMZWFmbGV0LmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css\n");

/***/ }),

/***/ "./src/Leaflet/Controls/ReverseGeocoding.js":
/*!**************************************************!*\
  !*** ./src/Leaflet/Controls/ReverseGeocoding.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var geoportal_access_lib_src_Services_Geocode_ReverseGeocode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! geoportal-access-lib/src/Services/Geocode/ReverseGeocode */ \"./node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet_draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet-draw */ \"./node_modules/leaflet-draw/dist/leaflet.draw-src.js\");\n/* harmony import */ var leaflet_draw__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet_draw__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_leaflet_draw_dist_leaflet_draw_src_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/leaflet-draw/dist/leaflet.draw-src.css */ \"./node_modules/leaflet-draw/dist/leaflet.draw-src.css\");\n/* harmony import */ var _node_modules_leaflet_draw_dist_leaflet_draw_src_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_leaflet_draw_dist_leaflet_draw_src_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Common_CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Common/CSS/GPgeneralWidget.css */ \"./src/Common/CSS/GPgeneralWidget.css\");\n/* harmony import */ var _Common_CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Common_CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Common_CSS_GPreverseGeocoding_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Common/CSS/GPreverseGeocoding.css */ \"./src/Common/CSS/GPreverseGeocoding.css\");\n/* harmony import */ var _Common_CSS_GPreverseGeocoding_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Common_CSS_GPreverseGeocoding_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _CSS_GPgeneralWidgetLeaflet_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../CSS/GPgeneralWidgetLeaflet.css */ \"./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css\");\n/* harmony import */ var _CSS_GPgeneralWidgetLeaflet_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPgeneralWidgetLeaflet_css__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _CSS_Controls_ReverseGeocoding_GPreverseGeocodingLeaflet_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../CSS/Controls/ReverseGeocoding/GPreverseGeocodingLeaflet.css */ \"./src/Leaflet/CSS/Controls/ReverseGeocoding/GPreverseGeocodingLeaflet.css\");\n/* harmony import */ var _CSS_Controls_ReverseGeocoding_GPreverseGeocodingLeaflet_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ReverseGeocoding_GPreverseGeocodingLeaflet_css__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Common/Utils/CheckRightManagement */ \"./src/Common/Utils/CheckRightManagement.js\");\n/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../Common/Utils/SelectorID */ \"./src/Common/Utils/SelectorID.js\");\n/* harmony import */ var _Utils_IconDefault__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Utils/IconDefault */ \"./src/Leaflet/Controls/Utils/IconDefault.js\");\n/* harmony import */ var _Common_Controls_ReverseGeocodingDOM__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../Common/Controls/ReverseGeocodingDOM */ \"./src/Common/Controls/ReverseGeocodingDOM.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getLogger(\"reversegeocoding\");\n/**\n * @classdesc\n *\n * Leaflet Control Class to find locations by clicking on a map using <a href=\"https://geoservices.ign.fr/documentation/geoservices/geocodage-inverse.html\" target=\"_blank\">reverse geocoding service</a> of the Geoportal platform.\n *\n * Use {@link module :Controls.ReverseGeocode L.geoportalControl.ReverseGeocode()} factory to create instances of that class.\n *\n * **Extends** Leaflet <a href=\"http://leafletjs.com/reference.html#control\" target=\"_blank\">L.Control</a> native class.\n *\n * @namespace\n * @alias L.geoportalControl.ReverseGeocode\n */\n\nvar ReverseGeocoding = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Control.extend(\n/** @lends L.geoportalControl.ReverseGeocode.prototype */\n{\n  includes: _Common_Controls_ReverseGeocodingDOM__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n\n  /**\n   * options by default\n   *\n   * @private\n   */\n  options: {\n    position: \"bottomleft\",\n    collapsed: true,\n    resources: [\"StreetAddress\", \"PositionOfInterest\", \"CadastralParcel\"],\n    delimitations: [\"Point\", \"Circle\", \"Extent\"],\n    reverseGeocodeOptions: {}\n  },\n\n  /**\n   * @constructor ReverseGeocode\n   * @param {Object} options - ReverseGeocoding control options\n   * @param {String}  [options.apiKey] - API key for services call (reverse geocode service), mandatory if autoconf service has not been charged in advance\n   * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)\n   * @param {String}  [options.position] - position of component into the map, 'topleft' by default\n   * @param {Boolean} [options.collapsed] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.\n   * @param {Array}  [options.resources] - resources for geocoding, by default : [\"StreetAddress\", \"PositionOfInterest\",\"CadastralParcel\"]\n   * @param {Array}  [options.delimitations] - delimitations for reverse geocoding, by default : [\"Point\", \"Circle\", \"Extent\"]\n   * @param {Object}  [options.reverseGeocodeOptions] - reverse geocode service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~ReverseGeocode Gp.Services.reverseGeocode()} to know all reverse geocode options.\n   * @example\n   *  var iso = L.geoportalControl.ReverseGeocode({\n   *      collapsed : false,\n   *      position : \"topright\",\n   *      resources : [\"StreetAddress\", \"PositionOfInterest\",\"CadastralParcel\"],\n   *      delimitations : [\"Point\", \"Circle\"],\n   *      reverseGeocodeOptions : {}\n   *  });\n   * @private\n   */\n  initialize: function initialize(options) {\n    // on merge les options avec celles par defaut\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(this.options, options);\n    /**\n     * Droit sur la ressource.\n     * Par defaut, on n'en s'occupe pas\n     * sauf si l'autoconfiguration est chargée !\n     */\n\n    this._noRightManagement = false; // ressources des services d'autocompletion et de geocodage\n\n    this._servicesRightManagement = {}; // gestion des droits sur les ressources/services\n\n    this._checkRightsManagement(); // check input options format (resources and delimitations arrays)\n\n\n    this._checkInputOptions();\n    /** uuid */\n\n\n    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__[\"default\"].generate(); // Type de géocodage sélectionné (StreetAddress, PositionOfInterest, ...)\n\n    this._currentGeocodingType = null;\n\n    this._initGeocodingType(); // Type de délimitation à utiliser pour la requête + pour sélection sur la containerDistance\n\n\n    this._currentGeocodingDelimitation = null;\n\n    this._initGeocodingDelimitation(); // ################################################################## //\n    // ################### Elements principaux du DOM ################### //\n    // containers principaux\n\n\n    this._showReverseGeocodingContainer = null; // header panel\n\n    this._panelHeaderContainer = null;\n    this._panelTitleContainer = null;\n    this._returnPictoContainer = null; // form\n\n    this._formContainer = null; // results\n\n    this._resultsContainer = null;\n    this._resultsListContainer = null; // waiting\n\n    this._waitingContainer = null; // ###################################################################### //\n    // ################### informations des points saisis ################### //\n    // couche vectorielle dans laquelle seront saisis les points (features ci-dessus)\n\n    this._inputFeaturesLayer = null;\n    this._inputResultsLayer = null;\n    this._lastIdLayer = 0;\n    this._currentIdLayer = 0; // interaction avec la carte (de type \"Point\", \"Circle\" ou \"Polygon\")\n\n    this._currentFeature = null; // #################################################################### //\n    // ################### informations pour la requête ################### //\n    // geometrie de recherche du géocodage inverse qui sera envoyée dans la requête\n\n    this._requestGeom = null; // pour savoir si un calcul est en cours ou non\n\n    this._waiting = false; // timer pour cacher la patience après un certain temps\n\n    this._timer = null; // #################################################################### //\n    // #################### informations des résultats #################### //\n\n    this._reverseGeocodingLocations = [];\n  },\n\n  /**\n   * this method is called by this.addTo(map) when the control is added on the map\n   * and fills variable 'this._container = this.onAdd(map)',\n   * and create events on map.\n   *\n   * @param {Object} map - the map\n   *\n   * @returns {DOMElement} DOM element\n   *\n   * @private\n   */\n  onAdd: function onAdd(map) {\n    // initialisation du DOM du composant\n    var container = this._container = this._initLayout(); // deactivate of events that may interfere with the map\n\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);\n\n    if (map) {\n      // lors de l'ajout à la map, on active la saisie du point,\n      // mais seulement si le widget est ouvert\n      if (!this.options.collapsed) {\n        this._activateMapInteraction(map);\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * this method is called when the control is removed from the map\n   * and removes events on map.\n   *\n   * @param {Object} map - the map\n   *\n   * @private\n   */\n  onRemove: function onRemove(map) {\n    this._clearLocations();\n\n    this._clearLocationsFeature(map);\n\n    this._clearInputRequest(); // on supprime l'éventuelle précédente interaction\n\n\n    this._removeMapInteraction(map);\n  },\n  // ################################################################### //\n  // ##################### init component ############################## //\n  // ################################################################### //\n\n  /**\n   * this method is called by constructor\n   * and check the rights to resources\n   *\n   * @private\n   */\n  _checkRightsManagement: function _checkRightsManagement() {\n    var _key = this.options.reverseGeocodeOptions.apiKey; // on récupère les éventuelles ressources passées en option, soit dans reverseGeocodeOptions :\n\n    var _resources = this.options.reverseGeocodeOptions.index ? this.options.reverseGeocodeOptions.index : \"\"; // soit directement dans options.resources :\n\n\n    if (!_resources || _resources.length === 0) {\n      _resources = this.options.resources;\n    } // ou celles par défaut sinon.\n\n\n    if (!_resources) {\n      _resources = \"location\";\n    }\n\n    if (_resources === \"location\") {\n      _resources = [\"StreetAddress\", \"PositionOfInterest\", \"CadastralParcel\"];\n    } else {\n      if (!Array.isArray(_resources)) _resources = [_resources];\n    }\n\n    var rightManagementGeocode = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_9__[\"default\"].check({\n      key: _key || this.options.apiKey,\n      resources: _resources,\n      services: [\"Geocode\"]\n    });\n    logger.log(\"rightManagementGeocode\", rightManagementGeocode); // aucun droit !\n\n    if (!rightManagementGeocode) {\n      this._noRightManagement = true;\n      return;\n    } // on recupère les informations utiles\n    // Ex. la clef API issue de l'autoconfiguration si elle n'a pas\n    // été renseignée.\n\n\n    if (!this.options.apiKey) {\n      this.options.apiKey = rightManagementGeocode.key;\n    }\n\n    this._servicesRightManagement[\"Geocode\"] = rightManagementGeocode[\"Geocode\"];\n  },\n\n  /**\n   * this method is called by this.initialize()\n   * and makes sure input options are correctly formated\n   *\n   * @private\n   */\n  _checkInputOptions: function _checkInputOptions() {\n    var i; // on vérifie le tableau des resources\n\n    if (this.options.resources) {\n      var resources = this.options.resources; // on vérifie que la liste des ressources de geocodage est bien un tableau\n\n      if (Array.isArray(resources)) {\n        var resourcesList = [\"StreetAddress\", \"PositionOfInterest\", \"CadastralParcel\", \"Administratif\"];\n\n        for (i = 0; i < resources.length; i++) {\n          if (resourcesList.indexOf(resources[i]) === -1) {\n            // si la resource n'est pas référencée, on l'enlève\n            // resources.splice(i, 1);\n            logger.log(\"[ReverseGeocoding] options.resources : \" + resources[i] + \" is not a resource for reverse geocode\");\n          }\n        }\n      } else {\n        logger.log(\"[ReverseGeocoding] 'options.resources' parameter should be an array\");\n        resources = null;\n      }\n    } // et le tableau des délimitations\n\n\n    if (this.options.delimitations) {\n      var delimitations = this.options.delimitations; // on vérifie que la liste des delimitations est bien un tableau\n\n      if (Array.isArray(delimitations)) {\n        var delimitationsList = [\"Circle\", \"Point\", \"Extent\"];\n\n        for (i = 0; i < delimitations.length; i++) {\n          if (delimitationsList.indexOf(delimitations[i]) === -1) {\n            // si la delimitations n'est pas référencée, on l'enlève\n            // resources.splice(i, 1);\n            logger.log(\"[ReverseGeocoding] options.delimitations : \" + delimitations[i] + \" is not a delimitation for reverse geocode\");\n          }\n        }\n      } else {\n        logger.log(\"[ReverseGeocoding] 'options.delimitations' parameter should be an array\");\n        delimitations = null;\n      }\n    }\n  },\n\n  /**\n   * this method is called by this.initialize() and initialize geocoding type (=resource)\n   * (\"StreetAddress\", \"PositionOfInterest\", \"CadastralParcel\")\n   *\n   * @private\n   */\n  _initGeocodingType: function _initGeocodingType() {\n    // Type de géocodage selectionné\n    this._currentGeocodingType = \"StreetAddress\"; // par defaut\n    // par defaut\n\n    var resources = this.options.resources;\n\n    if (!resources || resources.length === 0) {\n      this.options.resources = [\"StreetAddress\", \"PositionOfInterest\", \"CadastralParcel\"];\n    } // options utilisateur\n\n\n    if (Array.isArray(resources) && resources.length) {\n      // vérification des droits\n      var noRightsIndexes = [];\n\n      for (var i = 0; i < resources.length; i++) {\n        if (this._servicesRightManagement[\"Geocode\"].indexOf(resources[i]) < 0) {\n          // si on n'a pas les droits sur la ressource, on va la supprimer : on stocke son index\n          noRightsIndexes.push(i);\n          logger.log(\"[ReverseGeocode] no rights for options.resources : \" + resources[i]);\n        }\n      } // on retire les ressoures non autorisées qu'on a pu rencontrer\n\n\n      if (noRightsIndexes.length !== 0) {\n        for (var j = 0; j < noRightsIndexes.length; j++) {\n          resources.splice(noRightsIndexes[j], 1);\n        }\n      } // récupération du type par défaut\n\n\n      if (resources[0] === \"StreetAddress\" || resources[0] === \"PositionOfInterest\" || resources[0] === \"CadastralParcel\") {\n        this._currentGeocodingType = resources[0];\n      }\n    } // si l'utilisateur a spécifié au moins une ressource dans le service, on surcharge les options du widget\n\n\n    var serviceOptions = this.options.reverseGeocodeOptions;\n\n    if (serviceOptions.filterOptions && Array.isArray(serviceOptions.filterOptions.type) && serviceOptions.filterOptions.type.length !== 0) {\n      this._currentGeocodingType = serviceOptions.filterOptions.type[0];\n    }\n  },\n\n  /**\n   * this method is called by this.initialize() and initialize geocoding delimitation\n   * (\"Point\", \"Circle\", \"Extent\")\n   *\n   * @private\n   */\n  _initGeocodingDelimitation: function _initGeocodingDelimitation() {\n    // Type de délimitation selectionné\n    this._currentGeocodingDelimitation = \"Point\"; // par defaut\n    // par defaut\n\n    var delimitations = this.options.delimitations;\n\n    if (!delimitations || delimitations.length === 0) {\n      this.options.delimitations = [\"Point\", \"Circle\", \"Extent\"];\n    } // options utilisateur\n\n\n    if (Array.isArray(delimitations) && delimitations.length) {\n      var d = delimitations[0].toLowerCase();\n\n      if (d === \"point\" || d === \"circle\" || d === \"extent\") {\n        this._currentGeocodingDelimitation = delimitations[0];\n      }\n    }\n  },\n  // ################################################################### //\n  // ######################## methods handle dom ####################### //\n  // ################################################################### //\n\n  /**\n   * this method is called by this.onAdd(map)\n   * and initialize the container HTMLElement\n   *\n   * @returns {DOMElement} DOM element\n   *\n   * @private\n   */\n  _initLayout: function _initLayout() {\n    // create main container\n    var container = this._createMainContainerElement(); // create show ReverseGeocoding element\n\n\n    var inputShow = this._showReverseGeocodingContainer = this._createShowReverseGeocodingElement();\n\n    container.appendChild(inputShow); // mode \"collapsed\"\n\n    if (!this.options.collapsed) {\n      inputShow.checked = true;\n    } // create ReverseGeocoding picto\n\n\n    var picto = this._createShowReverseGeocodingPictoElement();\n\n    container.appendChild(picto); // panel\n\n    var reverseGeocodingPanel = this._createReverseGeocodingPanelElement(); // header\n\n\n    var panelHeader = this._panelHeaderContainer = this._createReverseGeocodingPanelHeaderElement(); // return picto (hidden at start)\n\n\n    var returnPicto = this._returnPictoContainer = this._createReverseGeocodingPanelReturnPictoElement();\n\n    panelHeader.appendChild(returnPicto); // pane title\n\n    var panelTitle = this._panelTitleContainer = this._createReverseGeocodingPanelTitleElement();\n\n    panelHeader.appendChild(panelTitle); // close picto\n\n    var closeDiv = this._createReverseGeocodingPanelCloseElement();\n\n    panelHeader.appendChild(closeDiv);\n    reverseGeocodingPanel.appendChild(panelHeader); // form\n\n    var reverseGeocodingForm = this._formContainer = this._createReverseGeocodingPanelFormElement(); // choices element\n\n\n    reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingTypeElement(this.options.resources));\n    reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingDelimitationElement(this.options.delimitations)); // submit (bouton \"Chercher\")\n\n    var submit = this._createReverseGeocodingSubmitFormElement();\n\n    reverseGeocodingForm.appendChild(submit);\n    reverseGeocodingPanel.appendChild(reverseGeocodingForm); // waiting\n\n    var waiting = this._waitingContainer = this._createReverseGeocodingWaitingElement();\n\n    reverseGeocodingPanel.appendChild(waiting); // results (dans le panel)\n\n    var resultsPanel = this._resultsContainer = this._createReverseGeocodingResultsPanelElement();\n\n    var reverseGeocodingResultsList = this._resultsListContainer = this._createReverseGeocodingResultsListElement();\n\n    resultsPanel.appendChild(reverseGeocodingResultsList);\n    reverseGeocodingPanel.appendChild(resultsPanel);\n    container.appendChild(reverseGeocodingPanel);\n    logger.log(container);\n    return container;\n  },\n  // ################################################################### //\n  // ################### Map interactions management ################### //\n  // ################################################################### //\n\n  /**\n   * this method is called by this.onAdd,\n   * or by this.onShowReverseGeocodingClick,\n   * and calls method corresponding to current delimitation, if widget is not collapsed.\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _activateMapInteraction: function _activateMapInteraction(map) {\n    logger.info(\"_activateMapInteraction()\"); // Creation de la couche vectorielle sur laquelle on va dessiner\n\n    if (this._inputFeaturesLayer === null) {\n      this._inputFeaturesLayer = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.FeatureGroup();\n      map.addLayer(this._inputFeaturesLayer);\n      var self = this;\n      /* evenement sur la carte lors d'une saisie,\n      on y ajoute le layer, et on y stocke les coordonnées */\n\n      map.on(\"draw:created\", function (e) {\n        var layer = e.layer;\n        var type = e.layerType;\n        logger.trace(\"draw:created\"); // TODO\n        // comment mettre en place un icone dynamiquement ?\n        // if (type === \"marker\") {}\n\n        self._setFeaturePosition(layer, type);\n\n        self._currentIdLayer = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.stamp(layer);\n\n        self._setFeatureLayer(layer);\n      });\n      /* evenements */\n\n      map.on(\"draw:drawstart\", function () {\n        logger.trace(\"draw:drawstart\");\n\n        self._removeFeatureLayer(self._lastIdLayer);\n\n        self._lastIdLayer = self._currentIdLayer;\n      });\n      /* evenements */\n\n      map.on(\"draw:drawstop\", function () {\n        logger.trace(\"draw:drawstop\");\n      });\n    } // Création de l'interaction de dessin, selon le type de délimitation sélectionné\n\n\n    var delimitation = this._currentGeocodingDelimitation.toLowerCase();\n\n    switch (delimitation) {\n      case \"point\":\n        this._activatePointInteraction(map);\n\n        break;\n\n      case \"circle\":\n        this._activateCircleInteraction(map);\n\n        break;\n\n      case \"extent\":\n        this._activateBoxInteraction(map);\n\n        break;\n\n      default:\n        break;\n    }\n  },\n\n  /**\n   * remove draw interaction from map (if exists)\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _removeMapInteraction: function _removeMapInteraction(map) {\n    if (!map) {\n      return;\n    }\n\n    if (this._inputFeaturesLayer !== null) {\n      map.off(\"draw:created\");\n      map.off(\"draw:drawstart\");\n      map.off(\"draw:drawstop\");\n      map.removeLayer(this._inputFeaturesLayer);\n      this._inputFeaturesLayer = null;\n    }\n\n    this._lastIdLayer = this._currentIdLayer = 0; // FIXME delete this._currentFeature ?\n\n    if (this._currentFeature) {\n      this._currentFeature.disable();\n    }\n  },\n\n  /**\n   * TODO this method is called by this._activateMapInteraction,\n   * and creates map point drawing interaction.\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _activatePointInteraction: function _activatePointInteraction(map) {\n    logger.info(\"_activatePointInteraction()\");\n\n    if (this._currentFeature) {\n      this._currentFeature.disable();\n    } // on modifie le tooltip du marker\n\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.drawLocal.draw.handlers.marker.tooltip.start = \"click map to place search point\"; // TODO styles des icones\n\n    var markerOptions = {\n      // icon : par defaut...\n      repeatMode: true\n    };\n    this._currentFeature = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Draw.Marker(map, markerOptions);\n\n    this._currentFeature.enable();\n  },\n\n  /**\n   * TODO this method is called by this._activateMapInteraction,\n   * and creates map circle drawing interaction.\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _activateCircleInteraction: function _activateCircleInteraction(map) {\n    logger.info(\"_activateCircleInteraction()\");\n\n    if (this._currentFeature) {\n      this._currentFeature.disable();\n    }\n\n    var circleOptions = {\n      repeatMode: true\n    }; // TODO styles\n\n    this._currentFeature = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Draw.Circle(map, circleOptions);\n\n    this._currentFeature.enable();\n  },\n\n  /**\n   * TODO this method is called by this._activateMapInteraction,\n   * and creates map box drawing interaction.\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _activateBoxInteraction: function _activateBoxInteraction(map) {\n    logger.info(\"_activateBoxInteraction()\");\n\n    if (this._currentFeature) {\n      this._currentFeature.disable();\n    }\n\n    var rectangleOptions = {\n      repeatMode: true\n    }; // TODO styles\n\n    this._currentFeature = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Draw.Rectangle(map, rectangleOptions);\n\n    this._currentFeature.enable();\n  },\n\n  /**\n   * set current position of feature\n   *\n   * @param {Object} layer - layer\n   * @param {String} type - type\n   *\n   * @private\n   */\n  _setFeaturePosition: function _setFeaturePosition(layer, type) {\n    // on transmet toujours des coordonnées au service en EPSG:4326\n    var oLatLng = null;\n\n    if (type === \"marker\") {\n      oLatLng = layer.getLatLng();\n      this._requestGeom = {\n        type: \"Point\",\n        coordinates: [oLatLng.lng, oLatLng.lat]\n      };\n    } else if (type === \"circle\") {\n      oLatLng = layer.getLatLng();\n      this._requestGeom = {\n        type: \"Circle\",\n        coordinates: [oLatLng.lng, oLatLng.lat],\n        radius: layer.getRadius()\n      };\n    } else if (type === \"rectangle\") {\n      oLatLng = layer.getBounds();\n      this._requestGeom = {\n        type: \"Polygon\",\n        coordinates: [[[oLatLng.getNorthWest().lng, oLatLng.getNorthWest().lat], [oLatLng.getNorthEast().lng, oLatLng.getNorthEast().lat], [oLatLng.getSouthEast().lng, oLatLng.getSouthEast().lat], [oLatLng.getSouthWest().lng, oLatLng.getSouthWest().lat], [oLatLng.getNorthWest().lng, oLatLng.getNorthWest().lat]]]\n      };\n    } else {\n      logger.warn(\"type geometric not defined !?\");\n    }\n\n    logger.log(oLatLng);\n  },\n\n  /**\n   * set current layer of feature\n   *\n   * @param {Object} layer - layer\n   *\n   * @private\n   */\n  _setFeatureLayer: function _setFeatureLayer(layer) {\n    if (!this._inputFeaturesLayer) {\n      return;\n    }\n\n    this._inputFeaturesLayer.addLayer(layer);\n  },\n\n  /**\n   * remove layer feature from group\n   * @param {Integer} id - id\n   *\n   * @private\n   */\n  _removeFeatureLayer: function _removeFeatureLayer(id) {\n    if (!this._inputFeaturesLayer) {\n      return;\n    }\n\n    if (id === 0) {\n      return;\n    }\n\n    if (!id) {\n      this._inputFeaturesLayer.clearLayers();\n    } else {\n      this._inputFeaturesLayer.removeLayer(id);\n    }\n  },\n  // ################################################################### //\n  // ##################### Reverse Geocoding request ################### //\n  // ################################################################### //\n\n  /**\n   * this methode is called by this.onReverseGeocodingSubmit method,\n   * it generates and sends reverse geocode request, then displays results\n   * @param {Object} settings - settings\n   *\n   * @private\n   */\n  _reverseGeocodingRequest: function _reverseGeocodingRequest(settings) {\n    // retrait de l'interaction sur la map pendant l'attente (et l'affichage des résultats)\n    var map = this._map;\n\n    this._removeMapInteraction(map); // on construit les options pour la requête\n\n\n    var options = {}; // on surcharge avec les options utilisateur\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, this.options.reverseGeocodeOptions); // la recherche et les callbacks\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, settings); // options par defaut\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, {\n      apiKey: this.options.apiKey,\n      // maximumResponses : 25, // on peut la surcharger !\n      timeOut: 30000,\n      protocol: \"XHR\"\n    }); // on récupère d'éventuels filtres\n\n    if (this._requestGeom.type.toLowerCase() === \"circle\") {\n      // FIXME : a confirmer !\n      if (this._requestGeom.radius > 1000) {\n        logger.log(\"INFO : initial circle radius (\" + this._requestGeom.radius + \") limited to 1000m.\");\n        this._requestGeom.radius = 1000;\n      }\n\n      options.searchGeometry = this._requestGeom;\n    } else if (this._requestGeom.type.toLowerCase() === \"polygon\") {\n      options.searchGeometry = this._requestGeom;\n    } else if (this._requestGeom.type.toLowerCase() === \"point\") {\n      if (this._currentGeocodingType === \"StreetAddress\") {\n        options.searchGeometry = {\n          type: \"Circle\",\n          radius: 50,\n          coordinates: this._requestGeom.coordinates\n        };\n        options.maximumResponses = 1;\n      } else {\n        options.searchGeometry = this._requestGeom;\n      }\n    }\n\n    logger.log(\"reverseGeocode request options : \", options); // affichage d'une patience pendant l'attente\n\n    this._displayWaitingContainer(); // envoi de la requête\n\n\n    var reverseGeocodeService = new geoportal_access_lib_src_Services_Geocode_ReverseGeocode__WEBPACK_IMPORTED_MODULE_0__[\"default\"](options);\n    reverseGeocodeService.call();\n  },\n  // ################################################################### //\n  // ############################# results list ######################## //\n  // ################################################################### //\n\n  /**\n   * this method is called by this._reverseGeocodingRequest() (in case of reverse geocode success)\n   * and display results : in both container list and map\n   *\n   * @param {Array} locations - array of geocoded locations (reverse geocode results)\n   * @private\n   */\n  _displayGeocodedLocations: function _displayGeocodedLocations(locations) {\n    var map = this._map; // 1. on vide les résultats précédents\n\n    this._clearLocations();\n\n    this._clearLocationsFeature(map);\n\n    this._reverseGeocodingLocations = locations;\n\n    if (!locations || locations.length === 0) {\n      this._clearInputRequest(); // FIXME pas sûr que se soit le bon endroit...\n\n\n      return;\n    } // 2. cache de la patience et du formulaire\n\n\n    this._formContainer.className = \"GPreverseGeocodingComponentHidden\";\n\n    this._hideWaitingContainer(); // affichage de la div des résultats (et changement du titre)\n\n\n    this._panelTitleContainer.innerHTML = \"Résultats de la recherche\";\n    this._returnPictoContainer.className = \"\";\n    this._resultsContainer.className = \"GPpanel\"; // 3. ajout de la liste des résultats dans le container des resultats\n\n    this._fillGeocodedLocationListContainer(locations); // 4. affichage des résultats sur la carte (+ zoom ?)\n\n\n    this._displayGeocodedLocationsOnMap(locations); // on zoom sur l'emprise des markers\n\n\n    map.fitBounds(this._inputResultsLayer.getBounds());\n  },\n\n  /**\n   * this method is called by this._displayGeocodedLocations()\n   * and fills the container with results list\n   *\n   * @param {Array} locations - array of geocoded locations (reverse geocode results)\n   * @private\n   */\n  _fillGeocodedLocationListContainer: function _fillGeocodedLocationListContainer(locations) {\n    //  ajout de la liste des résultats dans le container des resultats\n    for (var i = 0; i < locations.length; i++) {\n      var location = locations[i];\n      logger.log(location); // on récupère la description à afficher dans la liste\n\n      var locationDescription = this._fillGeocodedLocationDescription(location); // on ajoute chaque résutat à la liste\n\n\n      if (locationDescription.length !== 0) {\n        this._createReverseGeocodingResultElement(locationDescription, i);\n      }\n    }\n  },\n\n  /**\n   * this method is called by this._fillGeocodedLocationListContainer()\n   * and fills location description (String), depending on matchType\n   *\n   * @param {Object} location - geocoded location (from reverse geocode results)\n   * @returns {String} locationDescription - geocoded location description to be displayed\n   * @private\n   */\n  _fillGeocodedLocationDescription: function _fillGeocodedLocationDescription(location) {\n    if (!location || !location.placeAttributes) {\n      return;\n    }\n\n    var attr = location.placeAttributes;\n    var locationDescription = \"\"; // on sélectionne les infos à afficher selon le type\n\n    switch (location.type) {\n      case \"StreetAddress\":\n        if (attr.street) {\n          locationDescription += attr.housenumber ? attr.housenumber + \" \" : \"\";\n          locationDescription += attr.street + \", \";\n        }\n\n        locationDescription += attr.postcode + \" \" + attr.city;\n        break;\n\n      case \"PositionOfInterest\":\n        locationDescription += attr.toponym;\n\n        if (attr.postcode.length === 1) {\n          locationDescription += \", \" + attr.postcode[0];\n        }\n\n        locationDescription += \" (\" + attr.category.join(\",\") + \")\";\n        break;\n\n      case \"CadastralParcel\":\n        locationDescription += attr.id;\n        locationDescription += attr.city ? \" (\" + attr.city + \")\" : \"\";\n        break;\n\n      default:\n        locationDescription += attr.city ? attr.city : \"\";\n        break;\n    }\n\n    ;\n    return locationDescription;\n  },\n  // ################################################################### //\n  // ######################## map results (markers) #################### //\n  // ################################################################### //\n\n  /**\n   * this method is called by this._displayGeocodedLocations()\n   * and display locations in map (markers)\n   *\n   * @param {Object} locations - geocoded locations (reverse geocode result)\n   * @private\n   */\n  _displayGeocodedLocationsOnMap: function _displayGeocodedLocationsOnMap(locations) {\n    var map = this._map;\n    var self = this; // function set style Highlight for results\n\n    function _setHighLight(e) {\n      var layer = e.target;\n      layer.setIcon(new _Utils_IconDefault__WEBPACK_IMPORTED_MODULE_11__[\"default\"](\"red\"));\n      var div = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.DomUtil.get(\"ReverseGeocodedLocation_\" + layer.options.id + \"-\" + self._uid);\n      leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.DomUtil.addClass(div, \"GPreverseGeocodedLocationHighlight\");\n      div.scrollIntoView(false);\n    } // function reset style Highlight for results\n\n\n    function _resetHighLight(e) {\n      var layer = e.target;\n      layer.setIcon(new _Utils_IconDefault__WEBPACK_IMPORTED_MODULE_11__[\"default\"](\"green\"));\n      var div = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.DomUtil.get(\"ReverseGeocodedLocation_\" + layer.options.id + \"-\" + self._uid);\n      leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.DomUtil.removeClass(div, \"GPreverseGeocodedLocationHighlight\");\n    } // création de la couche où seront ajoutés les résultats\n\n\n    this._inputResultsLayer = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.FeatureGroup();\n    map.addLayer(this._inputResultsLayer); // ajout de chaque résultat à la couche (marker)\n\n    for (var i = 0; i < locations.length; i++) {\n      var location = locations[i];\n\n      if (!location) {\n        continue;\n      }\n\n      var options = {\n        id: i,\n        icon: new _Utils_IconDefault__WEBPACK_IMPORTED_MODULE_11__[\"default\"](\"green\"),\n        riseOnHover: true,\n        draggable: false,\n        clickable: true,\n        zIndexOffset: 1000\n      };\n\n      var _marker = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.marker(leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.latLng(location.position), options); // creation du contenu de la popup\n\n\n      var popupContent = \"<ul>\";\n      var attributes = location.placeAttributes;\n\n      for (var attr in attributes) {\n        if (attributes.hasOwnProperty(attr)) {\n          if (attr !== \"trueGeometry\" && attr !== \"extraFields\" && attr !== \"houseNumberInfos\" && attr !== \"_count\") {\n            popupContent += \"<li>\";\n            popupContent += \"<span class=\\\"gp-attname-others-span\\\">\" + attr.toUpperCase() + \" : </span>\";\n            popupContent += attributes[attr];\n            popupContent += \" </li>\";\n          }\n        }\n      }\n\n      popupContent += \" </ul>\";\n\n      _marker.bindPopup(popupContent);\n      /** evenement mouseover sur le marker */\n\n\n      _marker.on(\"mouseover\", _setHighLight);\n      /** evenement mouseout sur le marker */\n\n\n      _marker.on(\"mouseout\", _resetHighLight);\n\n      this._inputResultsLayer.addLayer(_marker);\n    }\n  },\n  // ################################################################### //\n  // ####################### handlers events to dom #################### //\n  // ################################################################### //\n\n  /**\n   * this method is called by event 'click' on 'GPshowReverseGeocodingPicto' tag label\n   * (cf. ReverseGeocodingDOM._createShowReverseGeocodingPictoElement), and it cleans the component\n   * when it's closed.\n   *\n   * @private\n   */\n  onShowReverseGeocodingClick: function onShowReverseGeocodingClick() {\n    var map = this._map; // interactions declenchées à l'ouverture/fermeture du panneau\n\n    if (this._showReverseGeocodingContainer.checked) {\n      this._removeMapInteraction(map);\n    } else {\n      if (!this._waiting && !this._reverseGeocodingLocations.length) {\n        this._activateMapInteraction(map);\n      }\n    }\n  },\n\n  /**\n   * this method is called by event 'change' on 'GPreverseGeocodingCode' tag select\n   * (cf. ReverseGeocodingDOM._createReverseGeocodingFormModeChoiceGeocodingTypeElement).\n   * this value is saved as a parameter for reverseGeocode service.\n   *\n   * @param {Object} e - HTMLElement\n   * @private\n   */\n  onReverseGeocodingTypeChange: function onReverseGeocodingTypeChange(e) {\n    var idx = e.target.selectedIndex;\n    var value = e.target.options[idx].value;\n\n    if (!value) {\n      return;\n    }\n\n    logger.log(value);\n    this._currentGeocodingType = value;\n  },\n\n  /**\n   * this method is called by event 'change' on 'GPreverseGeocodingCode' tag select\n   * (cf. ReverseGeocodingDOM._createReverseGeocodingFormModeChoiceGeocodingDelimitationElement).\n   * this value is saved as a parameter for reverseGeocode service.\n   *\n   * @param {Object} e - HTMLElement\n   * @private\n   */\n  onReverseGeocodingDelimitationChange: function onReverseGeocodingDelimitationChange(e) {\n    var idx = e.target.selectedIndex;\n    var value = e.target.options[idx].value;\n\n    if (!value) {\n      return;\n    }\n\n    logger.log(value);\n    this._currentGeocodingDelimitation = value; // on supprime l'interaction précédente,\n    // ainsi que les géométries et valeurs stockées (filtres, position)\n\n    this._clearInputRequest(); // on met à jour l'interaction de la map en fonction de la nouvelle délimitation\n\n\n    var map = this._map; // on supprime l'éventuelle précédente interaction\n\n    this._removeMapInteraction(map); // on crée une nouvelle interaction\n\n\n    this._activateMapInteraction(map);\n  },\n\n  /**\n   * TODO this method is called by event 'click' on 'GPreverseGeocodingReturnPicto' div\n   * (cf. ReverseGeocodingDOM._createReverseGeocodingPanelReturnPictoElement),\n   * and clear geocoded location (from both list container and map)\n   *\n   * @private\n   */\n  onGPreverseGeocodingReturnPictoClick: function onGPreverseGeocodingReturnPictoClick() {\n    var map = this._map; // suppression des résultats précédents\n\n    this._clearLocations();\n\n    this._clearLocationsFeature(map); // on efface les points qui ont pu être saisis précédemment\n\n\n    this._clearInputRequest(); // et on réactive l'interaction sur la map\n\n\n    this._activateMapInteraction(map);\n  },\n\n  /**\n   * TODO this methode is called by event 'submit' on reverseGeocoding form ('GPreverseGeocodingForm')\n   * (cf. ReverseGeocodingDOM._createReverseGeocodingPanelFormElement),\n   * it checks reverse geocode mandatory parameters,\n   * then call this._reverseGeocodingRequest() to generate and send request\n   *\n   * @private\n   */\n  onReverseGeocodingSubmit: function onReverseGeocodingSubmit() {\n    // le paramètre position est obligatoire\n    if (!this._requestGeom) {\n      logger.log(\"missing search geometry\");\n      return;\n    } // si on n'a trouvé aucun droit, on evite une requête inutile ...\n\n\n    if (this._noRightManagement) {\n      return;\n    }\n\n    var map = this._map;\n    var self = this;\n\n    this._reverseGeocodingRequest({\n      index: self._currentGeocodingType,\n      // callback onSuccess\n      onSuccess: function onSuccess(results) {\n        logger.log(results);\n\n        if (results) {\n          var locations = results.locations;\n\n          self._displayGeocodedLocations(locations);\n\n          self._hideWaitingContainer(); // et on réactive l'interaction sur la map\n\n\n          if (locations.length === 0) self._activateMapInteraction(map);\n        }\n      },\n      // callback onFailure\n      onFailure: function onFailure(error) {\n        self._hideWaitingContainer(); // suppression d'éventuels résultats précédents\n\n\n        self._clearLocations();\n\n        self._clearLocationsFeature(map); // on efface les points qui ont été saisis précédemment\n\n\n        self._clearInputRequest(); // et on réactive l'interaction sur la map\n\n\n        self._activateMapInteraction(map);\n\n        logger.log(error.message);\n      }\n    });\n  },\n\n  /**\n   * TODO this method is called by event 'click' on 'ReverseGeocodedLocation_' div\n   * (cf. ReverseGeocodingDOM._createReverseGeocodingResultElement),\n   * and zoom to location ?\n   * TODO\n   *\n   * @param {Object} e - HTMLElement\n   * @private\n   */\n  onReverseGeocodingResultClick: function onReverseGeocodingResultClick(e) {\n    logger.log(\"onReverseGeocodingResultClick\", e);\n  },\n\n  /**\n   * TODO this method is called by event 'mouseover' on 'ReverseGeocodedLocation_' div\n   * (cf. ReverseGeocodingDOM._createReverseGeocodingResultElement),\n   * and changes style of matching marker on map (selected)\n   *\n   * @param {Object} e - HTMLElement\n   * @private\n   */\n  onReverseGeocodingResultMouseOver: function onReverseGeocodingResultMouseOver(e) {\n    // récupération de l'id du résultat survolé\n    var idx = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__[\"default\"].index(e.target.id); // on passe le texte en gras\n\n    if (e.target.classList) {\n      e.target.classList.add(\"GPreverseGeocodedLocationHighlight\");\n    }\n\n    if (!this._inputResultsLayer) {\n      return;\n    }\n\n    this._inputResultsLayer.eachLayer(function (layer) {\n      if (layer.options.id === parseInt(idx, 10)) {\n        layer.fire(\"mouseover\");\n      }\n    });\n  },\n\n  /**\n   * TODO this method is called by event 'mouseout' on 'ReverseGeocodedLocation_' div\n   * (cf. ReverseGeocodingDOM._createReverseGeocodingResultElement),\n   * and changes style of matching marker on map (default)\n   *\n   * @param {Object} e - HTMLElement\n   * @private\n   */\n  onReverseGeocodingResultMouseOut: function onReverseGeocodingResultMouseOut(e) {\n    // récupération de l'id du résultat survolé\n    var idx = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__[\"default\"].index(e.target.id); // on repasse le texte en style normal\n\n    if (e.target.classList) {\n      e.target.classList.remove(\"GPreverseGeocodedLocationHighlight\");\n    }\n\n    if (!this._inputResultsLayer) {\n      return;\n    }\n\n    this._inputResultsLayer.eachLayer(function (layer) {\n      if (layer.options.id === parseInt(idx, 10)) {\n        layer.fire(\"mouseout\");\n      }\n    });\n  },\n  // ################################################################### //\n  // ################################ clean ############################ //\n  // ################################################################### //\n\n  /**\n   * TODO this method clears previous location results\n   *\n   * @private\n   */\n  _clearLocations: function _clearLocations() {\n    this._reverseGeocodingLocations = []; // on vide le container avec la liste des résultats\n\n    if (this._resultsListContainer) {\n      while (this._resultsListContainer.firstChild) {\n        this._resultsListContainer.removeChild(this._resultsListContainer.firstChild);\n      }\n    }\n  },\n\n  /**\n   * TODO this method clears previous location results marker\n   * @param {Object} map - the map\n   *\n   * @private\n   */\n  _clearLocationsFeature: function _clearLocationsFeature(map) {\n    // suppression des anciens resultats\n    if (this._inputResultsLayer !== null) {\n      map.removeLayer(this._inputResultsLayer);\n      this._inputResultsLayer = null;\n    }\n  },\n\n  /**\n   * TODO this method clears previous input features (features, position and filters)\n   *\n   * @private\n   */\n  _clearInputRequest: function _clearInputRequest() {\n    // on supprime les valeurs stockées (filtres, position)\n    this._requestPosition = null;\n    this._requestCircleFilter = null;\n    this._requestBboxFilter = null;\n  },\n  // ################################################################### //\n  // ############################ Patience ############################# //\n  // ################################################################### //\n\n  /**\n   * this method displays waiting container and sets a timeout\n   *\n   * @private\n   */\n  _displayWaitingContainer: function _displayWaitingContainer() {\n    this._waitingContainer.className = \"GPreverseGeocodingCalcWaitingContainerVisible\";\n    this._waiting = true; // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)\n    // si on est toujours en attente (si la requête est bloquée par exemple)\n\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n\n    var context = this;\n    this._timer = setTimeout(function () {\n      if (context._waiting === true) {\n        context._hideWaitingContainer();\n      } else {\n        if (context._timer) {\n          clearTimeout(context._timer);\n        }\n      }\n    }, 16000);\n  },\n\n  /**\n   * this method hides waiting container and clears timeout\n   *\n   * @private\n   */\n  _hideWaitingContainer: function _hideWaitingContainer() {\n    if (this._waiting) {\n      this._waitingContainer.className = \"GPreverseGeocodingCalcWaitingContainerHidden\";\n      this._waiting = false;\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReverseGeocoding); // Expose ReverseGeocoding as L.geoportalControl.ReverseGeocoding (for a build bundle)\n\nif (window.L) {\n  if (!window.L.geoportalControl) {\n    window.L.geoportalControl = {};\n  }\n\n  window.L.geoportalControl.ReverseGeocoding = ReverseGeocoding;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9Db250cm9scy9SZXZlcnNlR2VvY29kaW5nLmpzPzQ2N2UiXSwibmFtZXMiOlsibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiUmV2ZXJzZUdlb2NvZGluZyIsIkwiLCJDb250cm9sIiwiZXh0ZW5kIiwiaW5jbHVkZXMiLCJSZXZlcnNlR2VvY29kaW5nRE9NIiwib3B0aW9ucyIsInBvc2l0aW9uIiwiY29sbGFwc2VkIiwicmVzb3VyY2VzIiwiZGVsaW1pdGF0aW9ucyIsInJldmVyc2VHZW9jb2RlT3B0aW9ucyIsImluaXRpYWxpemUiLCJVdGlsIiwiX25vUmlnaHRNYW5hZ2VtZW50IiwiX3NlcnZpY2VzUmlnaHRNYW5hZ2VtZW50IiwiX2NoZWNrUmlnaHRzTWFuYWdlbWVudCIsIl9jaGVja0lucHV0T3B0aW9ucyIsIl91aWQiLCJJRCIsImdlbmVyYXRlIiwiX2N1cnJlbnRHZW9jb2RpbmdUeXBlIiwiX2luaXRHZW9jb2RpbmdUeXBlIiwiX2N1cnJlbnRHZW9jb2RpbmdEZWxpbWl0YXRpb24iLCJfaW5pdEdlb2NvZGluZ0RlbGltaXRhdGlvbiIsIl9zaG93UmV2ZXJzZUdlb2NvZGluZ0NvbnRhaW5lciIsIl9wYW5lbEhlYWRlckNvbnRhaW5lciIsIl9wYW5lbFRpdGxlQ29udGFpbmVyIiwiX3JldHVyblBpY3RvQ29udGFpbmVyIiwiX2Zvcm1Db250YWluZXIiLCJfcmVzdWx0c0NvbnRhaW5lciIsIl9yZXN1bHRzTGlzdENvbnRhaW5lciIsIl93YWl0aW5nQ29udGFpbmVyIiwiX2lucHV0RmVhdHVyZXNMYXllciIsIl9pbnB1dFJlc3VsdHNMYXllciIsIl9sYXN0SWRMYXllciIsIl9jdXJyZW50SWRMYXllciIsIl9jdXJyZW50RmVhdHVyZSIsIl9yZXF1ZXN0R2VvbSIsIl93YWl0aW5nIiwiX3RpbWVyIiwiX3JldmVyc2VHZW9jb2RpbmdMb2NhdGlvbnMiLCJvbkFkZCIsIm1hcCIsImNvbnRhaW5lciIsIl9jb250YWluZXIiLCJfaW5pdExheW91dCIsIkRvbUV2ZW50IiwiZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24iLCJkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24iLCJfYWN0aXZhdGVNYXBJbnRlcmFjdGlvbiIsIm9uUmVtb3ZlIiwiX2NsZWFyTG9jYXRpb25zIiwiX2NsZWFyTG9jYXRpb25zRmVhdHVyZSIsIl9jbGVhcklucHV0UmVxdWVzdCIsIl9yZW1vdmVNYXBJbnRlcmFjdGlvbiIsIl9rZXkiLCJhcGlLZXkiLCJfcmVzb3VyY2VzIiwiaW5kZXgiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJyaWdodE1hbmFnZW1lbnRHZW9jb2RlIiwiUmlnaHRNYW5hZ2VtZW50IiwiY2hlY2siLCJrZXkiLCJzZXJ2aWNlcyIsImxvZyIsImkiLCJyZXNvdXJjZXNMaXN0IiwiaW5kZXhPZiIsImRlbGltaXRhdGlvbnNMaXN0Iiwibm9SaWdodHNJbmRleGVzIiwicHVzaCIsImoiLCJzcGxpY2UiLCJzZXJ2aWNlT3B0aW9ucyIsImZpbHRlck9wdGlvbnMiLCJ0eXBlIiwiZCIsInRvTG93ZXJDYXNlIiwiX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50IiwiaW5wdXRTaG93IiwiX2NyZWF0ZVNob3dSZXZlcnNlR2VvY29kaW5nRWxlbWVudCIsImFwcGVuZENoaWxkIiwiY2hlY2tlZCIsInBpY3RvIiwiX2NyZWF0ZVNob3dSZXZlcnNlR2VvY29kaW5nUGljdG9FbGVtZW50IiwicmV2ZXJzZUdlb2NvZGluZ1BhbmVsIiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdQYW5lbEVsZW1lbnQiLCJwYW5lbEhlYWRlciIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxIZWFkZXJFbGVtZW50IiwicmV0dXJuUGljdG8iLCJfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1BhbmVsUmV0dXJuUGljdG9FbGVtZW50IiwicGFuZWxUaXRsZSIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxUaXRsZUVsZW1lbnQiLCJjbG9zZURpdiIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxDbG9zZUVsZW1lbnQiLCJyZXZlcnNlR2VvY29kaW5nRm9ybSIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxGb3JtRWxlbWVudCIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nRm9ybU1vZGVDaG9pY2VHZW9jb2RpbmdUeXBlRWxlbWVudCIsIl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nRm9ybU1vZGVDaG9pY2VHZW9jb2RpbmdEZWxpbWl0YXRpb25FbGVtZW50Iiwic3VibWl0IiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdTdWJtaXRGb3JtRWxlbWVudCIsIndhaXRpbmciLCJfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1dhaXRpbmdFbGVtZW50IiwicmVzdWx0c1BhbmVsIiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdSZXN1bHRzUGFuZWxFbGVtZW50IiwicmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdHNMaXN0IiwiX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdSZXN1bHRzTGlzdEVsZW1lbnQiLCJpbmZvIiwiRmVhdHVyZUdyb3VwIiwiYWRkTGF5ZXIiLCJzZWxmIiwib24iLCJlIiwibGF5ZXIiLCJsYXllclR5cGUiLCJ0cmFjZSIsIl9zZXRGZWF0dXJlUG9zaXRpb24iLCJzdGFtcCIsIl9zZXRGZWF0dXJlTGF5ZXIiLCJfcmVtb3ZlRmVhdHVyZUxheWVyIiwiZGVsaW1pdGF0aW9uIiwiX2FjdGl2YXRlUG9pbnRJbnRlcmFjdGlvbiIsIl9hY3RpdmF0ZUNpcmNsZUludGVyYWN0aW9uIiwiX2FjdGl2YXRlQm94SW50ZXJhY3Rpb24iLCJvZmYiLCJyZW1vdmVMYXllciIsImRpc2FibGUiLCJkcmF3TG9jYWwiLCJkcmF3IiwiaGFuZGxlcnMiLCJtYXJrZXIiLCJ0b29sdGlwIiwic3RhcnQiLCJtYXJrZXJPcHRpb25zIiwicmVwZWF0TW9kZSIsIkRyYXciLCJNYXJrZXIiLCJlbmFibGUiLCJjaXJjbGVPcHRpb25zIiwiQ2lyY2xlIiwicmVjdGFuZ2xlT3B0aW9ucyIsIlJlY3RhbmdsZSIsIm9MYXRMbmciLCJnZXRMYXRMbmciLCJjb29yZGluYXRlcyIsImxuZyIsImxhdCIsInJhZGl1cyIsImdldFJhZGl1cyIsImdldEJvdW5kcyIsImdldE5vcnRoV2VzdCIsImdldE5vcnRoRWFzdCIsImdldFNvdXRoRWFzdCIsImdldFNvdXRoV2VzdCIsIndhcm4iLCJpZCIsImNsZWFyTGF5ZXJzIiwiX3JldmVyc2VHZW9jb2RpbmdSZXF1ZXN0Iiwic2V0dGluZ3MiLCJfbWFwIiwidGltZU91dCIsInByb3RvY29sIiwic2VhcmNoR2VvbWV0cnkiLCJtYXhpbXVtUmVzcG9uc2VzIiwiX2Rpc3BsYXlXYWl0aW5nQ29udGFpbmVyIiwicmV2ZXJzZUdlb2NvZGVTZXJ2aWNlIiwiU2VydmljZVJldmVyc2VHZW9jb2RlIiwiY2FsbCIsIl9kaXNwbGF5R2VvY29kZWRMb2NhdGlvbnMiLCJsb2NhdGlvbnMiLCJjbGFzc05hbWUiLCJfaGlkZVdhaXRpbmdDb250YWluZXIiLCJpbm5lckhUTUwiLCJfZmlsbEdlb2NvZGVkTG9jYXRpb25MaXN0Q29udGFpbmVyIiwiX2Rpc3BsYXlHZW9jb2RlZExvY2F0aW9uc09uTWFwIiwiZml0Qm91bmRzIiwibG9jYXRpb24iLCJsb2NhdGlvbkRlc2NyaXB0aW9uIiwiX2ZpbGxHZW9jb2RlZExvY2F0aW9uRGVzY3JpcHRpb24iLCJfY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdEVsZW1lbnQiLCJwbGFjZUF0dHJpYnV0ZXMiLCJhdHRyIiwic3RyZWV0IiwiaG91c2VudW1iZXIiLCJwb3N0Y29kZSIsImNpdHkiLCJ0b3BvbnltIiwiY2F0ZWdvcnkiLCJqb2luIiwiX3NldEhpZ2hMaWdodCIsInRhcmdldCIsInNldEljb24iLCJJY29uRGVmYXVsdCIsImRpdiIsIkRvbVV0aWwiLCJnZXQiLCJhZGRDbGFzcyIsInNjcm9sbEludG9WaWV3IiwiX3Jlc2V0SGlnaExpZ2h0IiwicmVtb3ZlQ2xhc3MiLCJpY29uIiwicmlzZU9uSG92ZXIiLCJkcmFnZ2FibGUiLCJjbGlja2FibGUiLCJ6SW5kZXhPZmZzZXQiLCJfbWFya2VyIiwibGF0TG5nIiwicG9wdXBDb250ZW50IiwiYXR0cmlidXRlcyIsImhhc093blByb3BlcnR5IiwidG9VcHBlckNhc2UiLCJiaW5kUG9wdXAiLCJvblNob3dSZXZlcnNlR2VvY29kaW5nQ2xpY2siLCJvblJldmVyc2VHZW9jb2RpbmdUeXBlQ2hhbmdlIiwiaWR4Iiwic2VsZWN0ZWRJbmRleCIsInZhbHVlIiwib25SZXZlcnNlR2VvY29kaW5nRGVsaW1pdGF0aW9uQ2hhbmdlIiwib25HUHJldmVyc2VHZW9jb2RpbmdSZXR1cm5QaWN0b0NsaWNrIiwib25SZXZlcnNlR2VvY29kaW5nU3VibWl0Iiwib25TdWNjZXNzIiwicmVzdWx0cyIsIm9uRmFpbHVyZSIsImVycm9yIiwibWVzc2FnZSIsIm9uUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdENsaWNrIiwib25SZXZlcnNlR2VvY29kaW5nUmVzdWx0TW91c2VPdmVyIiwiY2xhc3NMaXN0IiwiYWRkIiwiZWFjaExheWVyIiwicGFyc2VJbnQiLCJmaXJlIiwib25SZXZlcnNlR2VvY29kaW5nUmVzdWx0TW91c2VPdXQiLCJyZW1vdmUiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJfcmVxdWVzdFBvc2l0aW9uIiwiX3JlcXVlc3RDaXJjbGVGaWx0ZXIiLCJfcmVxdWVzdEJib3hGaWx0ZXIiLCJjbGVhclRpbWVvdXQiLCJjb250ZXh0Iiwic2V0VGltZW91dCIsIndpbmRvdyIsImdlb3BvcnRhbENvbnRyb2wiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSUEsTUFBTSxHQUFHQyxxRUFBTSxD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LENBQVAsQ0FBU3NQLGdCQUFULENBQTBCdlAsZ0JBQTFCLEdBQTZDQSxnQkFBN0M7QUFDSCIsImZpbGUiOiIuL3NyYy9MZWFmbGV0L0NvbnRyb2xzL1JldmVyc2VHZW9jb2RpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2VydmljZVJldmVyc2VHZW9jb2RlIGZyb20gXCJnZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvR2VvY29kZS9SZXZlcnNlR2VvY29kZVwiO1xuaW1wb3J0IEwgZnJvbSBcImxlYWZsZXRcIjtcbmltcG9ydCBcImxlYWZsZXQtZHJhd1wiO1xuaW1wb3J0IFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtZHJhdy9kaXN0L2xlYWZsZXQuZHJhdy1zcmMuY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9Db21tb24vQ1NTL0dQZ2VuZXJhbFdpZGdldC5jc3NcIjtcbmltcG9ydCBcIi4uLy4uL0NvbW1vbi9DU1MvR1ByZXZlcnNlR2VvY29kaW5nLmNzc1wiO1xuaW1wb3J0IFwiLi4vQ1NTL0dQZ2VuZXJhbFdpZGdldExlYWZsZXQuY3NzXCI7XG5pbXBvcnQgXCIuLi9DU1MvQ29udHJvbHMvUmV2ZXJzZUdlb2NvZGluZy9HUHJldmVyc2VHZW9jb2RpbmdMZWFmbGV0LmNzc1wiO1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IFJpZ2h0TWFuYWdlbWVudCBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL0NoZWNrUmlnaHRNYW5hZ2VtZW50XCI7XG5pbXBvcnQgSUQgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9TZWxlY3RvcklEXCI7XG5pbXBvcnQgSWNvbkRlZmF1bHQgZnJvbSBcIi4vVXRpbHMvSWNvbkRlZmF1bHRcIjtcbmltcG9ydCBSZXZlcnNlR2VvY29kaW5nRE9NIGZyb20gXCIuLi8uLi9Db21tb24vQ29udHJvbHMvUmV2ZXJzZUdlb2NvZGluZ0RPTVwiO1xuXG52YXIgbG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcihcInJldmVyc2VnZW9jb2RpbmdcIik7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIExlYWZsZXQgQ29udHJvbCBDbGFzcyB0byBmaW5kIGxvY2F0aW9ucyBieSBjbGlja2luZyBvbiBhIG1hcCB1c2luZyA8YSBocmVmPVwiaHR0cHM6Ly9nZW9zZXJ2aWNlcy5pZ24uZnIvZG9jdW1lbnRhdGlvbi9nZW9zZXJ2aWNlcy9nZW9jb2RhZ2UtaW52ZXJzZS5odG1sXCIgdGFyZ2V0PVwiX2JsYW5rXCI+cmV2ZXJzZSBnZW9jb2Rpbmcgc2VydmljZTwvYT4gb2YgdGhlIEdlb3BvcnRhbCBwbGF0Zm9ybS5cbiAqXG4gKiBVc2Uge0BsaW5rIG1vZHVsZSA6Q29udHJvbHMuUmV2ZXJzZUdlb2NvZGUgTC5nZW9wb3J0YWxDb250cm9sLlJldmVyc2VHZW9jb2RlKCl9IGZhY3RvcnkgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiB0aGF0IGNsYXNzLlxuICpcbiAqICoqRXh0ZW5kcyoqIExlYWZsZXQgPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NvbnRyb2xcIiB0YXJnZXQ9XCJfYmxhbmtcIj5MLkNvbnRyb2w8L2E+IG5hdGl2ZSBjbGFzcy5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgTC5nZW9wb3J0YWxDb250cm9sLlJldmVyc2VHZW9jb2RlXG4gKi9cbnZhciBSZXZlcnNlR2VvY29kaW5nID0gTC5Db250cm9sLmV4dGVuZCgvKiogQGxlbmRzIEwuZ2VvcG9ydGFsQ29udHJvbC5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgaW5jbHVkZXMgOiBSZXZlcnNlR2VvY29kaW5nRE9NLFxuXG4gICAgLyoqXG4gICAgICogb3B0aW9ucyBieSBkZWZhdWx0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9wdGlvbnMgOiB7XG4gICAgICAgIHBvc2l0aW9uIDogXCJib3R0b21sZWZ0XCIsXG4gICAgICAgIGNvbGxhcHNlZCA6IHRydWUsXG4gICAgICAgIHJlc291cmNlcyA6IFtcIlN0cmVldEFkZHJlc3NcIiwgXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJDYWRhc3RyYWxQYXJjZWxcIl0sXG4gICAgICAgIGRlbGltaXRhdGlvbnMgOiBbXCJQb2ludFwiLCBcIkNpcmNsZVwiLCBcIkV4dGVudFwiXSxcbiAgICAgICAgcmV2ZXJzZUdlb2NvZGVPcHRpb25zIDoge31cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yIFJldmVyc2VHZW9jb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBSZXZlcnNlR2VvY29kaW5nIGNvbnRyb2wgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgW29wdGlvbnMuYXBpS2V5XSAtIEFQSSBrZXkgZm9yIHNlcnZpY2VzIGNhbGwgKHJldmVyc2UgZ2VvY29kZSBzZXJ2aWNlKSwgbWFuZGF0b3J5IGlmIGF1dG9jb25mIHNlcnZpY2UgaGFzIG5vdCBiZWVuIGNoYXJnZWQgaW4gYWR2YW5jZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3NsID0gdHJ1ZV0gLSB1c2Ugb2Ygc3NsIG9yIG5vdCAoZGVmYXVsdCB0cnVlLCBzZXJ2aWNlIHJlcXVlc3RlZCB1c2luZyBodHRwcyBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIFtvcHRpb25zLnBvc2l0aW9uXSAtIHBvc2l0aW9uIG9mIGNvbXBvbmVudCBpbnRvIHRoZSBtYXAsICd0b3BsZWZ0JyBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb2xsYXBzZWRdIC0gU3BlY2lmeSBpZiB3aWRnZXQgaGFzIHRvIGJlIGNvbGxhcHNlZCAodHJ1ZSkgb3Igbm90IChmYWxzZSkgb24gbWFwIGxvYWRpbmcuIERlZmF1bHQgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMucmVzb3VyY2VzXSAtIHJlc291cmNlcyBmb3IgZ2VvY29kaW5nLCBieSBkZWZhdWx0IDogW1wiU3RyZWV0QWRkcmVzc1wiLCBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiLFwiQ2FkYXN0cmFsUGFyY2VsXCJdXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmRlbGltaXRhdGlvbnNdIC0gZGVsaW1pdGF0aW9ucyBmb3IgcmV2ZXJzZSBnZW9jb2RpbmcsIGJ5IGRlZmF1bHQgOiBbXCJQb2ludFwiLCBcIkNpcmNsZVwiLCBcIkV4dGVudFwiXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnMucmV2ZXJzZUdlb2NvZGVPcHRpb25zXSAtIHJldmVyc2UgZ2VvY29kZSBzZXJ2aWNlIG9wdGlvbnMuIHNlZSB7QGxpbmsgaHR0cDovL2lnbmYuZ2l0aHViLmlvL2dlb3BvcnRhbC1hY2Nlc3MtbGliL2xhdGVzdC9qc2RvYy9tb2R1bGUtU2VydmljZXMuaHRtbCN+UmV2ZXJzZUdlb2NvZGUgR3AuU2VydmljZXMucmV2ZXJzZUdlb2NvZGUoKX0gdG8ga25vdyBhbGwgcmV2ZXJzZSBnZW9jb2RlIG9wdGlvbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGlzbyA9IEwuZ2VvcG9ydGFsQ29udHJvbC5SZXZlcnNlR2VvY29kZSh7XG4gICAgICogICAgICBjb2xsYXBzZWQgOiBmYWxzZSxcbiAgICAgKiAgICAgIHBvc2l0aW9uIDogXCJ0b3ByaWdodFwiLFxuICAgICAqICAgICAgcmVzb3VyY2VzIDogW1wiU3RyZWV0QWRkcmVzc1wiLCBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiLFwiQ2FkYXN0cmFsUGFyY2VsXCJdLFxuICAgICAqICAgICAgZGVsaW1pdGF0aW9ucyA6IFtcIlBvaW50XCIsIFwiQ2lyY2xlXCJdLFxuICAgICAqICAgICAgcmV2ZXJzZUdlb2NvZGVPcHRpb25zIDoge31cbiAgICAgKiAgfSk7XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gb24gbWVyZ2UgbGVzIG9wdGlvbnMgYXZlYyBjZWxsZXMgcGFyIGRlZmF1dFxuICAgICAgICBMLlV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyb2l0IHN1ciBsYSByZXNzb3VyY2UuXG4gICAgICAgICAqIFBhciBkZWZhdXQsIG9uIG4nZW4gcydvY2N1cGUgcGFzXG4gICAgICAgICAqIHNhdWYgc2kgbCdhdXRvY29uZmlndXJhdGlvbiBlc3QgY2hhcmfDqWUgIVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbm9SaWdodE1hbmFnZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICAvLyByZXNzb3VyY2VzIGRlcyBzZXJ2aWNlcyBkJ2F1dG9jb21wbGV0aW9uIGV0IGRlIGdlb2NvZGFnZVxuICAgICAgICB0aGlzLl9zZXJ2aWNlc1JpZ2h0TWFuYWdlbWVudCA9IHt9O1xuXG4gICAgICAgIC8vIGdlc3Rpb24gZGVzIGRyb2l0cyBzdXIgbGVzIHJlc3NvdXJjZXMvc2VydmljZXNcbiAgICAgICAgdGhpcy5fY2hlY2tSaWdodHNNYW5hZ2VtZW50KCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaW5wdXQgb3B0aW9ucyBmb3JtYXQgKHJlc291cmNlcyBhbmQgZGVsaW1pdGF0aW9ucyBhcnJheXMpXG4gICAgICAgIHRoaXMuX2NoZWNrSW5wdXRPcHRpb25zKCk7XG5cbiAgICAgICAgLyoqIHV1aWQgKi9cbiAgICAgICAgdGhpcy5fdWlkID0gSUQuZ2VuZXJhdGUoKTtcblxuICAgICAgICAvLyBUeXBlIGRlIGfDqW9jb2RhZ2Ugc8OpbGVjdGlvbm7DqSAoU3RyZWV0QWRkcmVzcywgUG9zaXRpb25PZkludGVyZXN0LCAuLi4pXG4gICAgICAgIHRoaXMuX2N1cnJlbnRHZW9jb2RpbmdUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5pdEdlb2NvZGluZ1R5cGUoKTtcblxuICAgICAgICAvLyBUeXBlIGRlIGTDqWxpbWl0YXRpb24gw6AgdXRpbGlzZXIgcG91ciBsYSByZXF1w6p0ZSArIHBvdXIgc8OpbGVjdGlvbiBzdXIgbGEgY29udGFpbmVyRGlzdGFuY2VcbiAgICAgICAgdGhpcy5fY3VycmVudEdlb2NvZGluZ0RlbGltaXRhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luaXRHZW9jb2RpbmdEZWxpbWl0YXRpb24oKTtcblxuICAgICAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAgICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyBFbGVtZW50cyBwcmluY2lwYXV4IGR1IERPTSAjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAgICAgLy8gY29udGFpbmVycyBwcmluY2lwYXV4XG4gICAgICAgIHRoaXMuX3Nob3dSZXZlcnNlR2VvY29kaW5nQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgLy8gaGVhZGVyIHBhbmVsXG4gICAgICAgIHRoaXMuX3BhbmVsSGVhZGVyQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFuZWxUaXRsZUNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JldHVyblBpY3RvQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgLy8gZm9ybVxuICAgICAgICB0aGlzLl9mb3JtQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgLy8gcmVzdWx0c1xuICAgICAgICB0aGlzLl9yZXN1bHRzQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzdWx0c0xpc3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICAvLyB3YWl0aW5nXG4gICAgICAgIHRoaXMuX3dhaXRpbmdDb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAgICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyBpbmZvcm1hdGlvbnMgZGVzIHBvaW50cyBzYWlzaXMgIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgICAgIC8vIGNvdWNoZSB2ZWN0b3JpZWxsZSBkYW5zIGxhcXVlbGxlIHNlcm9udCBzYWlzaXMgbGVzIHBvaW50cyAoZmVhdHVyZXMgY2ktZGVzc3VzKVxuICAgICAgICB0aGlzLl9pbnB1dEZlYXR1cmVzTGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnB1dFJlc3VsdHNMYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RJZExheWVyID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudElkTGF5ZXIgPSAwO1xuICAgICAgICAvLyBpbnRlcmFjdGlvbiBhdmVjIGxhIGNhcnRlIChkZSB0eXBlIFwiUG9pbnRcIiwgXCJDaXJjbGVcIiBvdSBcIlBvbHlnb25cIilcbiAgICAgICAgdGhpcy5fY3VycmVudEZlYXR1cmUgPSBudWxsO1xuXG4gICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMgaW5mb3JtYXRpb25zIHBvdXIgbGEgcmVxdcOqdGUgIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgICAgIC8vIGdlb21ldHJpZSBkZSByZWNoZXJjaGUgZHUgZ8Opb2NvZGFnZSBpbnZlcnNlIHF1aSBzZXJhIGVudm95w6llIGRhbnMgbGEgcmVxdcOqdGVcbiAgICAgICAgdGhpcy5fcmVxdWVzdEdlb20gPSBudWxsO1xuXG4gICAgICAgIC8vIHBvdXIgc2F2b2lyIHNpIHVuIGNhbGN1bCBlc3QgZW4gY291cnMgb3Ugbm9uXG4gICAgICAgIHRoaXMuX3dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gdGltZXIgcG91ciBjYWNoZXIgbGEgcGF0aWVuY2UgYXByw6hzIHVuIGNlcnRhaW4gdGVtcHNcbiAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuXG4gICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIGluZm9ybWF0aW9ucyBkZXMgcsOpc3VsdGF0cyAjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgICAgIHRoaXMuX3JldmVyc2VHZW9jb2RpbmdMb2NhdGlvbnMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoaXMuYWRkVG8obWFwKSB3aGVuIHRoZSBjb250cm9sIGlzIGFkZGVkIG9uIHRoZSBtYXBcbiAgICAgKiBhbmQgZmlsbHMgdmFyaWFibGUgJ3RoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKScsXG4gICAgICogYW5kIGNyZWF0ZSBldmVudHMgb24gbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCAtIHRoZSBtYXBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkFkZCA6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgLy8gaW5pdGlhbGlzYXRpb24gZHUgRE9NIGR1IGNvbXBvc2FudFxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5faW5pdExheW91dCgpO1xuXG4gICAgICAgIC8vIGRlYWN0aXZhdGUgb2YgZXZlbnRzIHRoYXQgbWF5IGludGVyZmVyZSB3aXRoIHRoZSBtYXBcbiAgICAgICAgTC5Eb21FdmVudFxuICAgICAgICAgICAgLmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcilcbiAgICAgICAgICAgIC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcblxuICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgICAvLyBsb3JzIGRlIGwnYWpvdXQgw6AgbGEgbWFwLCBvbiBhY3RpdmUgbGEgc2Fpc2llIGR1IHBvaW50LFxuICAgICAgICAgICAgLy8gbWFpcyBzZXVsZW1lbnQgc2kgbGUgd2lkZ2V0IGVzdCBvdXZlcnRcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlTWFwSW50ZXJhY3Rpb24obWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gICAgICogYW5kIHJlbW92ZXMgZXZlbnRzIG9uIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgLSB0aGUgbWFwXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUmVtb3ZlIDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB0aGlzLl9jbGVhckxvY2F0aW9ucygpO1xuICAgICAgICB0aGlzLl9jbGVhckxvY2F0aW9uc0ZlYXR1cmUobWFwKTtcbiAgICAgICAgdGhpcy5fY2xlYXJJbnB1dFJlcXVlc3QoKTtcblxuICAgICAgICAvLyBvbiBzdXBwcmltZSBsJ8OpdmVudHVlbGxlIHByw6ljw6lkZW50ZSBpbnRlcmFjdGlvblxuICAgICAgICB0aGlzLl9yZW1vdmVNYXBJbnRlcmFjdGlvbihtYXApO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIGluaXQgY29tcG9uZW50ICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBjb25zdHJ1Y3RvclxuICAgICAqIGFuZCBjaGVjayB0aGUgcmlnaHRzIHRvIHJlc291cmNlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tSaWdodHNNYW5hZ2VtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2tleSA9IHRoaXMub3B0aW9ucy5yZXZlcnNlR2VvY29kZU9wdGlvbnMuYXBpS2V5O1xuICAgICAgICAvLyBvbiByw6ljdXDDqHJlIGxlcyDDqXZlbnR1ZWxsZXMgcmVzc291cmNlcyBwYXNzw6llcyBlbiBvcHRpb24sIHNvaXQgZGFucyByZXZlcnNlR2VvY29kZU9wdGlvbnMgOlxuICAgICAgICB2YXIgX3Jlc291cmNlcyA9ICh0aGlzLm9wdGlvbnMucmV2ZXJzZUdlb2NvZGVPcHRpb25zLmluZGV4KSA/IHRoaXMub3B0aW9ucy5yZXZlcnNlR2VvY29kZU9wdGlvbnMuaW5kZXggOiBcIlwiO1xuICAgICAgICAvLyBzb2l0IGRpcmVjdGVtZW50IGRhbnMgb3B0aW9ucy5yZXNvdXJjZXMgOlxuICAgICAgICBpZiAoIV9yZXNvdXJjZXMgfHwgX3Jlc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIF9yZXNvdXJjZXMgPSB0aGlzLm9wdGlvbnMucmVzb3VyY2VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG91IGNlbGxlcyBwYXIgZMOpZmF1dCBzaW5vbi5cbiAgICAgICAgaWYgKCFfcmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBfcmVzb3VyY2VzID0gXCJsb2NhdGlvblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9yZXNvdXJjZXMgPT09IFwibG9jYXRpb25cIikge1xuICAgICAgICAgICAgX3Jlc291cmNlcyA9IFtcbiAgICAgICAgICAgICAgICBcIlN0cmVldEFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiLFxuICAgICAgICAgICAgICAgIFwiQ2FkYXN0cmFsUGFyY2VsXCJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3Jlc291cmNlcykpIF9yZXNvdXJjZXMgPSBbX3Jlc291cmNlc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmlnaHRNYW5hZ2VtZW50R2VvY29kZSA9IFJpZ2h0TWFuYWdlbWVudC5jaGVjayh7XG4gICAgICAgICAgICBrZXkgOiBfa2V5IHx8IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgICAgICByZXNvdXJjZXMgOiBfcmVzb3VyY2VzLFxuICAgICAgICAgICAgc2VydmljZXMgOiBbXCJHZW9jb2RlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIubG9nKFwicmlnaHRNYW5hZ2VtZW50R2VvY29kZVwiLCByaWdodE1hbmFnZW1lbnRHZW9jb2RlKTtcblxuICAgICAgICAvLyBhdWN1biBkcm9pdCAhXG4gICAgICAgIGlmICghcmlnaHRNYW5hZ2VtZW50R2VvY29kZSkge1xuICAgICAgICAgICAgdGhpcy5fbm9SaWdodE1hbmFnZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb24gcmVjdXDDqHJlIGxlcyBpbmZvcm1hdGlvbnMgdXRpbGVzXG4gICAgICAgIC8vIEV4LiBsYSBjbGVmIEFQSSBpc3N1ZSBkZSBsJ2F1dG9jb25maWd1cmF0aW9uIHNpIGVsbGUgbidhIHBhc1xuICAgICAgICAvLyDDqXTDqSByZW5zZWlnbsOpZS5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXBpS2V5ID0gcmlnaHRNYW5hZ2VtZW50R2VvY29kZS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXJ2aWNlc1JpZ2h0TWFuYWdlbWVudFtcIkdlb2NvZGVcIl0gPSByaWdodE1hbmFnZW1lbnRHZW9jb2RlW1wiR2VvY29kZVwiXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoaXMuaW5pdGlhbGl6ZSgpXG4gICAgICogYW5kIG1ha2VzIHN1cmUgaW5wdXQgb3B0aW9ucyBhcmUgY29ycmVjdGx5IGZvcm1hdGVkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja0lucHV0T3B0aW9ucyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIC8vIG9uIHbDqXJpZmllIGxlIHRhYmxlYXUgZGVzIHJlc291cmNlc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlcyA9IHRoaXMub3B0aW9ucy5yZXNvdXJjZXM7XG4gICAgICAgICAgICAvLyBvbiB2w6lyaWZpZSBxdWUgbGEgbGlzdGUgZGVzIHJlc3NvdXJjZXMgZGUgZ2VvY29kYWdlIGVzdCBiaWVuIHVuIHRhYmxlYXVcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc291cmNlcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzTGlzdCA9IFtcIlN0cmVldEFkZHJlc3NcIiwgXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJDYWRhc3RyYWxQYXJjZWxcIiwgXCJBZG1pbmlzdHJhdGlmXCJdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc291cmNlc0xpc3QuaW5kZXhPZihyZXNvdXJjZXNbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2kgbGEgcmVzb3VyY2Ugbidlc3QgcGFzIHLDqWbDqXJlbmPDqWUsIG9uIGwnZW5sw6h2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzb3VyY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJbUmV2ZXJzZUdlb2NvZGluZ10gb3B0aW9ucy5yZXNvdXJjZXMgOiBcIiArIHJlc291cmNlc1tpXSArIFwiIGlzIG5vdCBhIHJlc291cmNlIGZvciByZXZlcnNlIGdlb2NvZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJbUmV2ZXJzZUdlb2NvZGluZ10gJ29wdGlvbnMucmVzb3VyY2VzJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXQgbGUgdGFibGVhdSBkZXMgZMOpbGltaXRhdGlvbnNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWxpbWl0YXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZGVsaW1pdGF0aW9ucyA9IHRoaXMub3B0aW9ucy5kZWxpbWl0YXRpb25zO1xuICAgICAgICAgICAgLy8gb24gdsOpcmlmaWUgcXVlIGxhIGxpc3RlIGRlcyBkZWxpbWl0YXRpb25zIGVzdCBiaWVuIHVuIHRhYmxlYXVcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlbGltaXRhdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGltaXRhdGlvbnNMaXN0ID0gW1wiQ2lyY2xlXCIsIFwiUG9pbnRcIiwgXCJFeHRlbnRcIl07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbGltaXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGltaXRhdGlvbnNMaXN0LmluZGV4T2YoZGVsaW1pdGF0aW9uc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaSBsYSBkZWxpbWl0YXRpb25zIG4nZXN0IHBhcyByw6lmw6lyZW5jw6llLCBvbiBsJ2VubMOodmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc291cmNlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiW1JldmVyc2VHZW9jb2RpbmddIG9wdGlvbnMuZGVsaW1pdGF0aW9ucyA6IFwiICsgZGVsaW1pdGF0aW9uc1tpXSArIFwiIGlzIG5vdCBhIGRlbGltaXRhdGlvbiBmb3IgcmV2ZXJzZSBnZW9jb2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiW1JldmVyc2VHZW9jb2RpbmddICdvcHRpb25zLmRlbGltaXRhdGlvbnMnIHBhcmFtZXRlciBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICAgICAgZGVsaW1pdGF0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoaXMuaW5pdGlhbGl6ZSgpIGFuZCBpbml0aWFsaXplIGdlb2NvZGluZyB0eXBlICg9cmVzb3VyY2UpXG4gICAgICogKFwiU3RyZWV0QWRkcmVzc1wiLCBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiLCBcIkNhZGFzdHJhbFBhcmNlbFwiKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEdlb2NvZGluZ1R5cGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFR5cGUgZGUgZ8Opb2NvZGFnZSBzZWxlY3Rpb25uw6lcbiAgICAgICAgdGhpcy5fY3VycmVudEdlb2NvZGluZ1R5cGUgPSBcIlN0cmVldEFkZHJlc3NcIjsgLy8gcGFyIGRlZmF1dFxuXG4gICAgICAgIC8vIHBhciBkZWZhdXRcbiAgICAgICAgdmFyIHJlc291cmNlcyA9IHRoaXMub3B0aW9ucy5yZXNvdXJjZXM7XG4gICAgICAgIGlmICghcmVzb3VyY2VzIHx8IHJlc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgPSBbXCJTdHJlZXRBZGRyZXNzXCIsIFwiUG9zaXRpb25PZkludGVyZXN0XCIsIFwiQ2FkYXN0cmFsUGFyY2VsXCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3B0aW9ucyB1dGlsaXNhdGV1clxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNvdXJjZXMpICYmIHJlc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHbDqXJpZmljYXRpb24gZGVzIGRyb2l0c1xuICAgICAgICAgICAgdmFyIG5vUmlnaHRzSW5kZXhlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VydmljZXNSaWdodE1hbmFnZW1lbnRbXCJHZW9jb2RlXCJdLmluZGV4T2YocmVzb3VyY2VzW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2kgb24gbidhIHBhcyBsZXMgZHJvaXRzIHN1ciBsYSByZXNzb3VyY2UsIG9uIHZhIGxhIHN1cHByaW1lciA6IG9uIHN0b2NrZSBzb24gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgbm9SaWdodHNJbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJbUmV2ZXJzZUdlb2NvZGVdIG5vIHJpZ2h0cyBmb3Igb3B0aW9ucy5yZXNvdXJjZXMgOiBcIiArIHJlc291cmNlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb24gcmV0aXJlIGxlcyByZXNzb3VyZXMgbm9uIGF1dG9yaXPDqWVzIHF1J29uIGEgcHUgcmVuY29udHJlclxuICAgICAgICAgICAgaWYgKG5vUmlnaHRzSW5kZXhlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vUmlnaHRzSW5kZXhlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMuc3BsaWNlKG5vUmlnaHRzSW5kZXhlc1tqXSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkdSB0eXBlIHBhciBkw6lmYXV0XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VzWzBdID09PSBcIlN0cmVldEFkZHJlc3NcIiB8fCByZXNvdXJjZXNbMF0gPT09IFwiUG9zaXRpb25PZkludGVyZXN0XCIgfHwgcmVzb3VyY2VzWzBdID09PSBcIkNhZGFzdHJhbFBhcmNlbFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEdlb2NvZGluZ1R5cGUgPSByZXNvdXJjZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaSBsJ3V0aWxpc2F0ZXVyIGEgc3DDqWNpZmnDqSBhdSBtb2lucyB1bmUgcmVzc291cmNlIGRhbnMgbGUgc2VydmljZSwgb24gc3VyY2hhcmdlIGxlcyBvcHRpb25zIGR1IHdpZGdldFxuICAgICAgICB2YXIgc2VydmljZU9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZUdlb2NvZGVPcHRpb25zO1xuICAgICAgICBpZiAoc2VydmljZU9wdGlvbnMuZmlsdGVyT3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHNlcnZpY2VPcHRpb25zLmZpbHRlck9wdGlvbnMudHlwZSkgJiYgc2VydmljZU9wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEdlb2NvZGluZ1R5cGUgPSBzZXJ2aWNlT3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGVbMF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoaXMuaW5pdGlhbGl6ZSgpIGFuZCBpbml0aWFsaXplIGdlb2NvZGluZyBkZWxpbWl0YXRpb25cbiAgICAgKiAoXCJQb2ludFwiLCBcIkNpcmNsZVwiLCBcIkV4dGVudFwiKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEdlb2NvZGluZ0RlbGltaXRhdGlvbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVHlwZSBkZSBkw6lsaW1pdGF0aW9uIHNlbGVjdGlvbm7DqVxuICAgICAgICB0aGlzLl9jdXJyZW50R2VvY29kaW5nRGVsaW1pdGF0aW9uID0gXCJQb2ludFwiOyAvLyBwYXIgZGVmYXV0XG5cbiAgICAgICAgLy8gcGFyIGRlZmF1dFxuICAgICAgICB2YXIgZGVsaW1pdGF0aW9ucyA9IHRoaXMub3B0aW9ucy5kZWxpbWl0YXRpb25zO1xuICAgICAgICBpZiAoIWRlbGltaXRhdGlvbnMgfHwgZGVsaW1pdGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kZWxpbWl0YXRpb25zID0gW1wiUG9pbnRcIiwgXCJDaXJjbGVcIiwgXCJFeHRlbnRcIl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvcHRpb25zIHV0aWxpc2F0ZXVyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlbGltaXRhdGlvbnMpICYmIGRlbGltaXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGRlbGltaXRhdGlvbnNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChkID09PSBcInBvaW50XCIgfHwgZCA9PT0gXCJjaXJjbGVcIiB8fCBkID09PSBcImV4dGVudFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEdlb2NvZGluZ0RlbGltaXRhdGlvbiA9IGRlbGltaXRhdGlvbnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBtZXRob2RzIGhhbmRsZSBkb20gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5vbkFkZChtYXApXG4gICAgICogYW5kIGluaXRpYWxpemUgdGhlIGNvbnRhaW5lciBIVE1MRWxlbWVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0TGF5b3V0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjcmVhdGUgbWFpbiBjb250YWluZXJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50KCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHNob3cgUmV2ZXJzZUdlb2NvZGluZyBlbGVtZW50XG4gICAgICAgIHZhciBpbnB1dFNob3cgPSB0aGlzLl9zaG93UmV2ZXJzZUdlb2NvZGluZ0NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZVNob3dSZXZlcnNlR2VvY29kaW5nRWxlbWVudCgpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXRTaG93KTtcblxuICAgICAgICAvLyBtb2RlIFwiY29sbGFwc2VkXCJcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBpbnB1dFNob3cuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgUmV2ZXJzZUdlb2NvZGluZyBwaWN0b1xuICAgICAgICB2YXIgcGljdG8gPSB0aGlzLl9jcmVhdGVTaG93UmV2ZXJzZUdlb2NvZGluZ1BpY3RvRWxlbWVudCgpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocGljdG8pO1xuXG4gICAgICAgIC8vIHBhbmVsXG4gICAgICAgIHZhciByZXZlcnNlR2VvY29kaW5nUGFuZWwgPSB0aGlzLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxFbGVtZW50KCk7XG5cbiAgICAgICAgLy8gaGVhZGVyXG4gICAgICAgIHZhciBwYW5lbEhlYWRlciA9IHRoaXMuX3BhbmVsSGVhZGVyQ29udGFpbmVyID0gdGhpcy5fY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1BhbmVsSGVhZGVyRWxlbWVudCgpO1xuICAgICAgICAvLyByZXR1cm4gcGljdG8gKGhpZGRlbiBhdCBzdGFydClcbiAgICAgICAgdmFyIHJldHVyblBpY3RvID0gdGhpcy5fcmV0dXJuUGljdG9Db250YWluZXIgPSB0aGlzLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxSZXR1cm5QaWN0b0VsZW1lbnQoKTtcbiAgICAgICAgcGFuZWxIZWFkZXIuYXBwZW5kQ2hpbGQocmV0dXJuUGljdG8pO1xuICAgICAgICAvLyBwYW5lIHRpdGxlXG4gICAgICAgIHZhciBwYW5lbFRpdGxlID0gdGhpcy5fcGFuZWxUaXRsZUNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdQYW5lbFRpdGxlRWxlbWVudCgpO1xuICAgICAgICBwYW5lbEhlYWRlci5hcHBlbmRDaGlsZChwYW5lbFRpdGxlKTtcbiAgICAgICAgLy8gY2xvc2UgcGljdG9cbiAgICAgICAgdmFyIGNsb3NlRGl2ID0gdGhpcy5fY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1BhbmVsQ2xvc2VFbGVtZW50KCk7XG4gICAgICAgIHBhbmVsSGVhZGVyLmFwcGVuZENoaWxkKGNsb3NlRGl2KTtcbiAgICAgICAgcmV2ZXJzZUdlb2NvZGluZ1BhbmVsLmFwcGVuZENoaWxkKHBhbmVsSGVhZGVyKTtcblxuICAgICAgICAvLyBmb3JtXG4gICAgICAgIHZhciByZXZlcnNlR2VvY29kaW5nRm9ybSA9IHRoaXMuX2Zvcm1Db250YWluZXIgPSB0aGlzLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxGb3JtRWxlbWVudCgpO1xuICAgICAgICAvLyBjaG9pY2VzIGVsZW1lbnRcbiAgICAgICAgcmV2ZXJzZUdlb2NvZGluZ0Zvcm0uYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ0Zvcm1Nb2RlQ2hvaWNlR2VvY29kaW5nVHlwZUVsZW1lbnQodGhpcy5vcHRpb25zLnJlc291cmNlcykpO1xuICAgICAgICByZXZlcnNlR2VvY29kaW5nRm9ybS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nRm9ybU1vZGVDaG9pY2VHZW9jb2RpbmdEZWxpbWl0YXRpb25FbGVtZW50KHRoaXMub3B0aW9ucy5kZWxpbWl0YXRpb25zKSk7XG5cbiAgICAgICAgLy8gc3VibWl0IChib3V0b24gXCJDaGVyY2hlclwiKVxuICAgICAgICB2YXIgc3VibWl0ID0gdGhpcy5fY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1N1Ym1pdEZvcm1FbGVtZW50KCk7XG4gICAgICAgIHJldmVyc2VHZW9jb2RpbmdGb3JtLmFwcGVuZENoaWxkKHN1Ym1pdCk7XG5cbiAgICAgICAgcmV2ZXJzZUdlb2NvZGluZ1BhbmVsLmFwcGVuZENoaWxkKHJldmVyc2VHZW9jb2RpbmdGb3JtKTtcblxuICAgICAgICAvLyB3YWl0aW5nXG4gICAgICAgIHZhciB3YWl0aW5nID0gdGhpcy5fd2FpdGluZ0NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdXYWl0aW5nRWxlbWVudCgpO1xuICAgICAgICByZXZlcnNlR2VvY29kaW5nUGFuZWwuYXBwZW5kQ2hpbGQod2FpdGluZyk7XG5cbiAgICAgICAgLy8gcmVzdWx0cyAoZGFucyBsZSBwYW5lbClcbiAgICAgICAgdmFyIHJlc3VsdHNQYW5lbCA9IHRoaXMuX3Jlc3VsdHNDb250YWluZXIgPSB0aGlzLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUmVzdWx0c1BhbmVsRWxlbWVudCgpO1xuICAgICAgICB2YXIgcmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdHNMaXN0ID0gdGhpcy5fcmVzdWx0c0xpc3RDb250YWluZXIgPSB0aGlzLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUmVzdWx0c0xpc3RFbGVtZW50KCk7XG4gICAgICAgIHJlc3VsdHNQYW5lbC5hcHBlbmRDaGlsZChyZXZlcnNlR2VvY29kaW5nUmVzdWx0c0xpc3QpO1xuICAgICAgICByZXZlcnNlR2VvY29kaW5nUGFuZWwuYXBwZW5kQ2hpbGQocmVzdWx0c1BhbmVsKTtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmV2ZXJzZUdlb2NvZGluZ1BhbmVsKTtcblxuICAgICAgICBsb2dnZXIubG9nKGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMgTWFwIGludGVyYWN0aW9ucyBtYW5hZ2VtZW50ICMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5vbkFkZCxcbiAgICAgKiBvciBieSB0aGlzLm9uU2hvd1JldmVyc2VHZW9jb2RpbmdDbGljayxcbiAgICAgKiBhbmQgY2FsbHMgbWV0aG9kIGNvcnJlc3BvbmRpbmcgdG8gY3VycmVudCBkZWxpbWl0YXRpb24sIGlmIHdpZGdldCBpcyBub3QgY29sbGFwc2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCAtIGNvbnRyb2wgbWFwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FjdGl2YXRlTWFwSW50ZXJhY3Rpb24gOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiX2FjdGl2YXRlTWFwSW50ZXJhY3Rpb24oKVwiKTtcblxuICAgICAgICAvLyBDcmVhdGlvbiBkZSBsYSBjb3VjaGUgdmVjdG9yaWVsbGUgc3VyIGxhcXVlbGxlIG9uIHZhIGRlc3NpbmVyXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dEZlYXR1cmVzTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0RmVhdHVyZXNMYXllciA9IG5ldyBMLkZlYXR1cmVHcm91cCgpO1xuICAgICAgICAgICAgbWFwLmFkZExheWVyKHRoaXMuX2lucHV0RmVhdHVyZXNMYXllcik7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIC8qIGV2ZW5lbWVudCBzdXIgbGEgY2FydGUgbG9ycyBkJ3VuZSBzYWlzaWUsXG4gICAgICAgICAgICBvbiB5IGFqb3V0ZSBsZSBsYXllciwgZXQgb24geSBzdG9ja2UgbGVzIGNvb3Jkb25uw6llcyAqL1xuICAgICAgICAgICAgbWFwLm9uKFwiZHJhdzpjcmVhdGVkXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gZS5sYXllcjtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGUubGF5ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImRyYXc6Y3JlYXRlZFwiKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAvLyBjb21tZW50IG1ldHRyZSBlbiBwbGFjZSB1biBpY29uZSBkeW5hbWlxdWVtZW50ID9cbiAgICAgICAgICAgICAgICAvLyBpZiAodHlwZSA9PT0gXCJtYXJrZXJcIikge31cblxuICAgICAgICAgICAgICAgIHNlbGYuX3NldEZlYXR1cmVQb3NpdGlvbihsYXllciwgdHlwZSk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9jdXJyZW50SWRMYXllciA9IEwuVXRpbC5zdGFtcChsYXllcik7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2V0RmVhdHVyZUxheWVyKGxheWVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvKiBldmVuZW1lbnRzICovXG4gICAgICAgICAgICBtYXAub24oXCJkcmF3OmRyYXdzdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiZHJhdzpkcmF3c3RhcnRcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlRmVhdHVyZUxheWVyKHNlbGYuX2xhc3RJZExheWVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9sYXN0SWRMYXllciA9IHNlbGYuX2N1cnJlbnRJZExheWVyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8qIGV2ZW5lbWVudHMgKi9cbiAgICAgICAgICAgIG1hcC5vbihcImRyYXc6ZHJhd3N0b3BcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImRyYXc6ZHJhd3N0b3BcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyw6lhdGlvbiBkZSBsJ2ludGVyYWN0aW9uIGRlIGRlc3Npbiwgc2Vsb24gbGUgdHlwZSBkZSBkw6lsaW1pdGF0aW9uIHPDqWxlY3Rpb25uw6lcbiAgICAgICAgdmFyIGRlbGltaXRhdGlvbiA9IHRoaXMuX2N1cnJlbnRHZW9jb2RpbmdEZWxpbWl0YXRpb24udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBzd2l0Y2ggKGRlbGltaXRhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVQb2ludEludGVyYWN0aW9uKG1hcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVDaXJjbGVJbnRlcmFjdGlvbihtYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImV4dGVudFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlQm94SW50ZXJhY3Rpb24obWFwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBkcmF3IGludGVyYWN0aW9uIGZyb20gbWFwIChpZiBleGlzdHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIC0gY29udHJvbCBtYXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlTWFwSW50ZXJhY3Rpb24gOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5wdXRGZWF0dXJlc0xheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXAub2ZmKFwiZHJhdzpjcmVhdGVkXCIpO1xuICAgICAgICAgICAgbWFwLm9mZihcImRyYXc6ZHJhd3N0YXJ0XCIpO1xuICAgICAgICAgICAgbWFwLm9mZihcImRyYXc6ZHJhd3N0b3BcIik7XG4gICAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcy5faW5wdXRGZWF0dXJlc0xheWVyKTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0RmVhdHVyZXNMYXllciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0SWRMYXllciA9IHRoaXMuX2N1cnJlbnRJZExheWVyID0gMDtcblxuICAgICAgICAvLyBGSVhNRSBkZWxldGUgdGhpcy5fY3VycmVudEZlYXR1cmUgP1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEZlYXR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRGZWF0dXJlLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUT0RPIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGlzLl9hY3RpdmF0ZU1hcEludGVyYWN0aW9uLFxuICAgICAqIGFuZCBjcmVhdGVzIG1hcCBwb2ludCBkcmF3aW5nIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCAtIGNvbnRyb2wgbWFwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FjdGl2YXRlUG9pbnRJbnRlcmFjdGlvbiA6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJfYWN0aXZhdGVQb2ludEludGVyYWN0aW9uKClcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRGZWF0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RmVhdHVyZS5kaXNhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiBtb2RpZmllIGxlIHRvb2x0aXAgZHUgbWFya2VyXG4gICAgICAgIEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMubWFya2VyLnRvb2x0aXAuc3RhcnQgPSBcImNsaWNrIG1hcCB0byBwbGFjZSBzZWFyY2ggcG9pbnRcIjtcblxuICAgICAgICAvLyBUT0RPIHN0eWxlcyBkZXMgaWNvbmVzXG4gICAgICAgIHZhciBtYXJrZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgLy8gaWNvbiA6IHBhciBkZWZhdXQuLi5cbiAgICAgICAgICAgIHJlcGVhdE1vZGUgOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3VycmVudEZlYXR1cmUgPSBuZXcgTC5EcmF3Lk1hcmtlcihtYXAsIG1hcmtlck9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9jdXJyZW50RmVhdHVyZS5lbmFibGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5fYWN0aXZhdGVNYXBJbnRlcmFjdGlvbixcbiAgICAgKiBhbmQgY3JlYXRlcyBtYXAgY2lyY2xlIGRyYXdpbmcgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIC0gY29udHJvbCBtYXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWN0aXZhdGVDaXJjbGVJbnRlcmFjdGlvbiA6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJfYWN0aXZhdGVDaXJjbGVJbnRlcmFjdGlvbigpXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RmVhdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEZlYXR1cmUuZGlzYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNpcmNsZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZXBlYXRNb2RlIDogdHJ1ZVxuICAgICAgICB9OyAvLyBUT0RPIHN0eWxlc1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGZWF0dXJlID0gbmV3IEwuRHJhdy5DaXJjbGUobWFwLCBjaXJjbGVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY3VycmVudEZlYXR1cmUuZW5hYmxlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRPRE8gdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoaXMuX2FjdGl2YXRlTWFwSW50ZXJhY3Rpb24sXG4gICAgICogYW5kIGNyZWF0ZXMgbWFwIGJveCBkcmF3aW5nIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCAtIGNvbnRyb2wgbWFwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FjdGl2YXRlQm94SW50ZXJhY3Rpb24gOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiX2FjdGl2YXRlQm94SW50ZXJhY3Rpb24oKVwiKTtcblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEZlYXR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRGZWF0dXJlLmRpc2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0YW5nbGVPcHRpb25zID0ge1xuICAgICAgICAgICAgcmVwZWF0TW9kZSA6IHRydWVcbiAgICAgICAgfTsgLy8gVE9ETyBzdHlsZXNcblxuICAgICAgICB0aGlzLl9jdXJyZW50RmVhdHVyZSA9IG5ldyBMLkRyYXcuUmVjdGFuZ2xlKG1hcCwgcmVjdGFuZ2xlT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGZWF0dXJlLmVuYWJsZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgY3VycmVudCBwb3NpdGlvbiBvZiBmZWF0dXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgLSBsYXllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gdHlwZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RmVhdHVyZVBvc2l0aW9uIDogZnVuY3Rpb24gKGxheWVyLCB0eXBlKSB7XG4gICAgICAgIC8vIG9uIHRyYW5zbWV0IHRvdWpvdXJzIGRlcyBjb29yZG9ubsOpZXMgYXUgc2VydmljZSBlbiBFUFNHOjQzMjZcbiAgICAgICAgdmFyIG9MYXRMbmcgPSBudWxsO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJtYXJrZXJcIikge1xuICAgICAgICAgICAgb0xhdExuZyA9IGxheWVyLmdldExhdExuZygpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEdlb20gPSB7XG4gICAgICAgICAgICAgICAgdHlwZSA6IFwiUG9pbnRcIixcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA6IFtvTGF0TG5nLmxuZywgb0xhdExuZy5sYXRdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgICAgICAgIG9MYXRMbmcgPSBsYXllci5nZXRMYXRMbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RHZW9tID0ge1xuICAgICAgICAgICAgICAgIHR5cGUgOiBcIkNpcmNsZVwiLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzIDogW29MYXRMbmcubG5nLCBvTGF0TG5nLmxhdF0sXG4gICAgICAgICAgICAgICAgcmFkaXVzIDogbGF5ZXIuZ2V0UmFkaXVzKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICAgICAgb0xhdExuZyA9IGxheWVyLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEdlb20gPSB7XG4gICAgICAgICAgICAgICAgdHlwZSA6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzIDogW1tcbiAgICAgICAgICAgICAgICAgICAgW29MYXRMbmcuZ2V0Tm9ydGhXZXN0KCkubG5nLCBvTGF0TG5nLmdldE5vcnRoV2VzdCgpLmxhdF0sXG4gICAgICAgICAgICAgICAgICAgIFtvTGF0TG5nLmdldE5vcnRoRWFzdCgpLmxuZywgb0xhdExuZy5nZXROb3J0aEVhc3QoKS5sYXRdLFxuICAgICAgICAgICAgICAgICAgICBbb0xhdExuZy5nZXRTb3V0aEVhc3QoKS5sbmcsIG9MYXRMbmcuZ2V0U291dGhFYXN0KCkubGF0XSxcbiAgICAgICAgICAgICAgICAgICAgW29MYXRMbmcuZ2V0U291dGhXZXN0KCkubG5nLCBvTGF0TG5nLmdldFNvdXRoV2VzdCgpLmxhdF0sXG4gICAgICAgICAgICAgICAgICAgIFtvTGF0TG5nLmdldE5vcnRoV2VzdCgpLmxuZywgb0xhdExuZy5nZXROb3J0aFdlc3QoKS5sYXRdXG4gICAgICAgICAgICAgICAgXV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcInR5cGUgZ2VvbWV0cmljIG5vdCBkZWZpbmVkICE/XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLmxvZyhvTGF0TG5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnQgbGF5ZXIgb2YgZmVhdHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gbGF5ZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEZlYXR1cmVMYXllciA6IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAoIXRoaXMuX2lucHV0RmVhdHVyZXNMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lucHV0RmVhdHVyZXNMYXllci5hZGRMYXllcihsYXllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBsYXllciBmZWF0dXJlIGZyb20gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGlkIC0gaWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUZlYXR1cmVMYXllciA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lucHV0RmVhdHVyZXNMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlkID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dEZlYXR1cmVzTGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0RmVhdHVyZXNMYXllci5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyBSZXZlcnNlIEdlb2NvZGluZyByZXF1ZXN0ICMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZGUgaXMgY2FsbGVkIGJ5IHRoaXMub25SZXZlcnNlR2VvY29kaW5nU3VibWl0IG1ldGhvZCxcbiAgICAgKiBpdCBnZW5lcmF0ZXMgYW5kIHNlbmRzIHJldmVyc2UgZ2VvY29kZSByZXF1ZXN0LCB0aGVuIGRpc3BsYXlzIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgLSBzZXR0aW5nc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmV2ZXJzZUdlb2NvZGluZ1JlcXVlc3QgOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gcmV0cmFpdCBkZSBsJ2ludGVyYWN0aW9uIHN1ciBsYSBtYXAgcGVuZGFudCBsJ2F0dGVudGUgKGV0IGwnYWZmaWNoYWdlIGRlcyByw6lzdWx0YXRzKVxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICB0aGlzLl9yZW1vdmVNYXBJbnRlcmFjdGlvbihtYXApO1xuXG4gICAgICAgIC8vIG9uIGNvbnN0cnVpdCBsZXMgb3B0aW9ucyBwb3VyIGxhIHJlcXXDqnRlXG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIC8vIG9uIHN1cmNoYXJnZSBhdmVjIGxlcyBvcHRpb25zIHV0aWxpc2F0ZXVyXG4gICAgICAgIEwuVXRpbC5leHRlbmQob3B0aW9ucywgdGhpcy5vcHRpb25zLnJldmVyc2VHZW9jb2RlT3B0aW9ucyk7XG4gICAgICAgIC8vIGxhIHJlY2hlcmNoZSBldCBsZXMgY2FsbGJhY2tzXG4gICAgICAgIEwuVXRpbC5leHRlbmQob3B0aW9ucywgc2V0dGluZ3MpO1xuICAgICAgICAvLyBvcHRpb25zIHBhciBkZWZhdXRcbiAgICAgICAgTC5VdGlsLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICAgICAgICBhcGlLZXkgOiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICAgICAgLy8gbWF4aW11bVJlc3BvbnNlcyA6IDI1LCAvLyBvbiBwZXV0IGxhIHN1cmNoYXJnZXIgIVxuICAgICAgICAgICAgdGltZU91dCA6IDMwMDAwLFxuICAgICAgICAgICAgcHJvdG9jb2wgOiBcIlhIUlwiXG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb24gcsOpY3Vww6hyZSBkJ8OpdmVudHVlbHMgZmlsdHJlc1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEdlb20udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcImNpcmNsZVwiKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSA6IGEgY29uZmlybWVyICFcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0R2VvbS5yYWRpdXMgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIklORk8gOiBpbml0aWFsIGNpcmNsZSByYWRpdXMgKFwiICsgdGhpcy5fcmVxdWVzdEdlb20ucmFkaXVzICsgXCIpIGxpbWl0ZWQgdG8gMTAwMG0uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RHZW9tLnJhZGl1cyA9IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnNlYXJjaEdlb21ldHJ5ID0gdGhpcy5fcmVxdWVzdEdlb207XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcmVxdWVzdEdlb20udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInBvbHlnb25cIikge1xuICAgICAgICAgICAgb3B0aW9ucy5zZWFyY2hHZW9tZXRyeSA9IHRoaXMuX3JlcXVlc3RHZW9tO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3JlcXVlc3RHZW9tLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJwb2ludFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEdlb2NvZGluZ1R5cGUgPT09IFwiU3RyZWV0QWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWFyY2hHZW9tZXRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA6IFwiQ2lyY2xlXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA6IDUwLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA6IHRoaXMuX3JlcXVlc3RHZW9tLmNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heGltdW1SZXNwb25zZXMgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlYXJjaEdlb21ldHJ5ID0gdGhpcy5fcmVxdWVzdEdlb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2dnZXIubG9nKFwicmV2ZXJzZUdlb2NvZGUgcmVxdWVzdCBvcHRpb25zIDogXCIsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGFmZmljaGFnZSBkJ3VuZSBwYXRpZW5jZSBwZW5kYW50IGwnYXR0ZW50ZVxuICAgICAgICB0aGlzLl9kaXNwbGF5V2FpdGluZ0NvbnRhaW5lcigpO1xuXG4gICAgICAgIC8vIGVudm9pIGRlIGxhIHJlcXXDqnRlXG4gICAgICAgIHZhciByZXZlcnNlR2VvY29kZVNlcnZpY2UgPSBuZXcgU2VydmljZVJldmVyc2VHZW9jb2RlKG9wdGlvbnMpO1xuICAgICAgICByZXZlcnNlR2VvY29kZVNlcnZpY2UuY2FsbCgpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgcmVzdWx0cyBsaXN0ICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGlzLl9yZXZlcnNlR2VvY29kaW5nUmVxdWVzdCgpIChpbiBjYXNlIG9mIHJldmVyc2UgZ2VvY29kZSBzdWNjZXNzKVxuICAgICAqIGFuZCBkaXNwbGF5IHJlc3VsdHMgOiBpbiBib3RoIGNvbnRhaW5lciBsaXN0IGFuZCBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxvY2F0aW9ucyAtIGFycmF5IG9mIGdlb2NvZGVkIGxvY2F0aW9ucyAocmV2ZXJzZSBnZW9jb2RlIHJlc3VsdHMpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzcGxheUdlb2NvZGVkTG9jYXRpb25zIDogZnVuY3Rpb24gKGxvY2F0aW9ucykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIDEuIG9uIHZpZGUgbGVzIHLDqXN1bHRhdHMgcHLDqWPDqWRlbnRzXG4gICAgICAgIHRoaXMuX2NsZWFyTG9jYXRpb25zKCk7XG4gICAgICAgIHRoaXMuX2NsZWFyTG9jYXRpb25zRmVhdHVyZShtYXApO1xuXG4gICAgICAgIHRoaXMuX3JldmVyc2VHZW9jb2RpbmdMb2NhdGlvbnMgPSBsb2NhdGlvbnM7XG5cbiAgICAgICAgaWYgKCFsb2NhdGlvbnMgfHwgbG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJJbnB1dFJlcXVlc3QoKTsgLy8gRklYTUUgcGFzIHPDu3IgcXVlIHNlIHNvaXQgbGUgYm9uIGVuZHJvaXQuLi5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIGNhY2hlIGRlIGxhIHBhdGllbmNlIGV0IGR1IGZvcm11bGFpcmVcbiAgICAgICAgdGhpcy5fZm9ybUNvbnRhaW5lci5jbGFzc05hbWUgPSBcIkdQcmV2ZXJzZUdlb2NvZGluZ0NvbXBvbmVudEhpZGRlblwiO1xuICAgICAgICB0aGlzLl9oaWRlV2FpdGluZ0NvbnRhaW5lcigpO1xuXG4gICAgICAgIC8vIGFmZmljaGFnZSBkZSBsYSBkaXYgZGVzIHLDqXN1bHRhdHMgKGV0IGNoYW5nZW1lbnQgZHUgdGl0cmUpXG4gICAgICAgIHRoaXMuX3BhbmVsVGl0bGVDb250YWluZXIuaW5uZXJIVE1MID0gXCJSw6lzdWx0YXRzIGRlIGxhIHJlY2hlcmNoZVwiO1xuICAgICAgICB0aGlzLl9yZXR1cm5QaWN0b0NvbnRhaW5lci5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLl9yZXN1bHRzQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1BwYW5lbFwiO1xuXG4gICAgICAgIC8vIDMuIGFqb3V0IGRlIGxhIGxpc3RlIGRlcyByw6lzdWx0YXRzIGRhbnMgbGUgY29udGFpbmVyIGRlcyByZXN1bHRhdHNcbiAgICAgICAgdGhpcy5fZmlsbEdlb2NvZGVkTG9jYXRpb25MaXN0Q29udGFpbmVyKGxvY2F0aW9ucyk7XG5cbiAgICAgICAgLy8gNC4gYWZmaWNoYWdlIGRlcyByw6lzdWx0YXRzIHN1ciBsYSBjYXJ0ZSAoKyB6b29tID8pXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlHZW9jb2RlZExvY2F0aW9uc09uTWFwKGxvY2F0aW9ucyk7XG5cbiAgICAgICAgLy8gb24gem9vbSBzdXIgbCdlbXByaXNlIGRlcyBtYXJrZXJzXG4gICAgICAgIG1hcC5maXRCb3VuZHModGhpcy5faW5wdXRSZXN1bHRzTGF5ZXIuZ2V0Qm91bmRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5fZGlzcGxheUdlb2NvZGVkTG9jYXRpb25zKClcbiAgICAgKiBhbmQgZmlsbHMgdGhlIGNvbnRhaW5lciB3aXRoIHJlc3VsdHMgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbG9jYXRpb25zIC0gYXJyYXkgb2YgZ2VvY29kZWQgbG9jYXRpb25zIChyZXZlcnNlIGdlb2NvZGUgcmVzdWx0cylcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maWxsR2VvY29kZWRMb2NhdGlvbkxpc3RDb250YWluZXIgOiBmdW5jdGlvbiAobG9jYXRpb25zKSB7XG4gICAgICAgIC8vICBham91dCBkZSBsYSBsaXN0ZSBkZXMgcsOpc3VsdGF0cyBkYW5zIGxlIGNvbnRhaW5lciBkZXMgcmVzdWx0YXRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBsb2NhdGlvbnNbaV07XG4gICAgICAgICAgICBsb2dnZXIubG9nKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIC8vIG9uIHLDqWN1cMOocmUgbGEgZGVzY3JpcHRpb24gw6AgYWZmaWNoZXIgZGFucyBsYSBsaXN0ZVxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uRGVzY3JpcHRpb24gPSB0aGlzLl9maWxsR2VvY29kZWRMb2NhdGlvbkRlc2NyaXB0aW9uKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIC8vIG9uIGFqb3V0ZSBjaGFxdWUgcsOpc3V0YXQgw6AgbGEgbGlzdGVcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbkRlc2NyaXB0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdSZXN1bHRFbGVtZW50KGxvY2F0aW9uRGVzY3JpcHRpb24sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGlzLl9maWxsR2VvY29kZWRMb2NhdGlvbkxpc3RDb250YWluZXIoKVxuICAgICAqIGFuZCBmaWxscyBsb2NhdGlvbiBkZXNjcmlwdGlvbiAoU3RyaW5nKSwgZGVwZW5kaW5nIG9uIG1hdGNoVHlwZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9uIC0gZ2VvY29kZWQgbG9jYXRpb24gKGZyb20gcmV2ZXJzZSBnZW9jb2RlIHJlc3VsdHMpXG4gICAgICogQHJldHVybnMge1N0cmluZ30gbG9jYXRpb25EZXNjcmlwdGlvbiAtIGdlb2NvZGVkIGxvY2F0aW9uIGRlc2NyaXB0aW9uIHRvIGJlIGRpc3BsYXllZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbGxHZW9jb2RlZExvY2F0aW9uRGVzY3JpcHRpb24gOiBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgaWYgKCFsb2NhdGlvbiB8fCAhbG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHIgPSBsb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXM7XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uRGVzY3JpcHRpb24gPSBcIlwiO1xuICAgICAgICAvLyBvbiBzw6lsZWN0aW9ubmUgbGVzIGluZm9zIMOgIGFmZmljaGVyIHNlbG9uIGxlIHR5cGVcbiAgICAgICAgc3dpdGNoIChsb2NhdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiU3RyZWV0QWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIGlmIChhdHRyLnN0cmVldCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbkRlc2NyaXB0aW9uICs9IGF0dHIuaG91c2VudW1iZXIgPyBhdHRyLmhvdXNlbnVtYmVyICsgXCIgXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbkRlc2NyaXB0aW9uICs9IGF0dHIuc3RyZWV0ICsgXCIsIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhdGlvbkRlc2NyaXB0aW9uICs9IGF0dHIucG9zdGNvZGUgKyBcIiBcIiArIGF0dHIuY2l0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiOlxuICAgICAgICAgICAgICAgIGxvY2F0aW9uRGVzY3JpcHRpb24gKz0gYXR0ci50b3BvbnltO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLnBvc3Rjb2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbkRlc2NyaXB0aW9uICs9IFwiLCBcIiArIGF0dHIucG9zdGNvZGVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2F0aW9uRGVzY3JpcHRpb24gKz0gXCIgKFwiICsgYXR0ci5jYXRlZ29yeS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiQ2FkYXN0cmFsUGFyY2VsXCI6XG4gICAgICAgICAgICAgICAgbG9jYXRpb25EZXNjcmlwdGlvbiArPSBhdHRyLmlkO1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uRGVzY3JpcHRpb24gKz0gYXR0ci5jaXR5ID8gXCIgKFwiICsgYXR0ci5jaXR5ICsgXCIpXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvY2F0aW9uRGVzY3JpcHRpb24gKz0gYXR0ci5jaXR5ID8gYXR0ci5jaXR5IDogXCJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9jYXRpb25EZXNjcmlwdGlvbjtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBtYXAgcmVzdWx0cyAobWFya2VycykgIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5fZGlzcGxheUdlb2NvZGVkTG9jYXRpb25zKClcbiAgICAgKiBhbmQgZGlzcGxheSBsb2NhdGlvbnMgaW4gbWFwIChtYXJrZXJzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9ucyAtIGdlb2NvZGVkIGxvY2F0aW9ucyAocmV2ZXJzZSBnZW9jb2RlIHJlc3VsdClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNwbGF5R2VvY29kZWRMb2NhdGlvbnNPbk1hcCA6IGZ1bmN0aW9uIChsb2NhdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHNldCBzdHlsZSBIaWdobGlnaHQgZm9yIHJlc3VsdHNcbiAgICAgICAgZnVuY3Rpb24gX3NldEhpZ2hMaWdodCAoZSkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gZS50YXJnZXQ7XG5cbiAgICAgICAgICAgIGxheWVyLnNldEljb24obmV3IEljb25EZWZhdWx0KFwicmVkXCIpKTtcblxuICAgICAgICAgICAgdmFyIGRpdiA9IEwuRG9tVXRpbC5nZXQoXCJSZXZlcnNlR2VvY29kZWRMb2NhdGlvbl9cIiArIGxheWVyLm9wdGlvbnMuaWQgKyBcIi1cIiArIHNlbGYuX3VpZCk7XG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoZGl2LCBcIkdQcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb25IaWdobGlnaHRcIik7XG4gICAgICAgICAgICBkaXYuc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gcmVzZXQgc3R5bGUgSGlnaGxpZ2h0IGZvciByZXN1bHRzXG4gICAgICAgIGZ1bmN0aW9uIF9yZXNldEhpZ2hMaWdodCAoZSkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gZS50YXJnZXQ7XG5cbiAgICAgICAgICAgIGxheWVyLnNldEljb24obmV3IEljb25EZWZhdWx0KFwiZ3JlZW5cIikpO1xuXG4gICAgICAgICAgICB2YXIgZGl2ID0gTC5Eb21VdGlsLmdldChcIlJldmVyc2VHZW9jb2RlZExvY2F0aW9uX1wiICsgbGF5ZXIub3B0aW9ucy5pZCArIFwiLVwiICsgc2VsZi5fdWlkKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhkaXYsIFwiR1ByZXZlcnNlR2VvY29kZWRMb2NhdGlvbkhpZ2hsaWdodFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyw6lhdGlvbiBkZSBsYSBjb3VjaGUgb8O5IHNlcm9udCBham91dMOpcyBsZXMgcsOpc3VsdGF0c1xuICAgICAgICB0aGlzLl9pbnB1dFJlc3VsdHNMYXllciA9IG5ldyBMLkZlYXR1cmVHcm91cCgpO1xuICAgICAgICBtYXAuYWRkTGF5ZXIodGhpcy5faW5wdXRSZXN1bHRzTGF5ZXIpO1xuXG4gICAgICAgIC8vIGFqb3V0IGRlIGNoYXF1ZSByw6lzdWx0YXQgw6AgbGEgY291Y2hlIChtYXJrZXIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBsb2NhdGlvbnNbaV07XG5cbiAgICAgICAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaWQgOiBpLFxuICAgICAgICAgICAgICAgIGljb24gOiBuZXcgSWNvbkRlZmF1bHQoXCJncmVlblwiKSxcbiAgICAgICAgICAgICAgICByaXNlT25Ib3ZlciA6IHRydWUsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6SW5kZXhPZmZzZXQgOiAxMDAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgX21hcmtlciA9IEwubWFya2VyKEwubGF0TG5nKGxvY2F0aW9uLnBvc2l0aW9uKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0aW9uIGR1IGNvbnRlbnUgZGUgbGEgcG9wdXBcbiAgICAgICAgICAgIHZhciBwb3B1cENvbnRlbnQgPSBcIjx1bD5cIjtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIgIT09IFwidHJ1ZUdlb21ldHJ5XCIgJiYgYXR0ciAhPT0gXCJleHRyYUZpZWxkc1wiICYmIGF0dHIgIT09IFwiaG91c2VOdW1iZXJJbmZvc1wiICYmIGF0dHIgIT09IFwiX2NvdW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwQ29udGVudCArPSBcIjxsaT5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwQ29udGVudCArPSBcIjxzcGFuIGNsYXNzPVxcXCJncC1hdHRuYW1lLW90aGVycy1zcGFuXFxcIj5cIiArIGF0dHIudG9VcHBlckNhc2UoKSArIFwiIDogPC9zcGFuPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBDb250ZW50ICs9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1cENvbnRlbnQgKz0gXCIgPC9saT5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcHVwQ29udGVudCArPSBcIiA8L3VsPlwiO1xuXG4gICAgICAgICAgICBfbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpO1xuXG4gICAgICAgICAgICAvKiogZXZlbmVtZW50IG1vdXNlb3ZlciBzdXIgbGUgbWFya2VyICovXG4gICAgICAgICAgICBfbWFya2VyLm9uKFwibW91c2VvdmVyXCIsIF9zZXRIaWdoTGlnaHQpO1xuXG4gICAgICAgICAgICAvKiogZXZlbmVtZW50IG1vdXNlb3V0IHN1ciBsZSBtYXJrZXIgKi9cbiAgICAgICAgICAgIF9tYXJrZXIub24oXCJtb3VzZW91dFwiLCBfcmVzZXRIaWdoTGlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dFJlc3VsdHNMYXllci5hZGRMYXllcihfbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgaGFuZGxlcnMgZXZlbnRzIHRvIGRvbSAjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBldmVudCAnY2xpY2snIG9uICdHUHNob3dSZXZlcnNlR2VvY29kaW5nUGljdG8nIHRhZyBsYWJlbFxuICAgICAqIChjZi4gUmV2ZXJzZUdlb2NvZGluZ0RPTS5fY3JlYXRlU2hvd1JldmVyc2VHZW9jb2RpbmdQaWN0b0VsZW1lbnQpLCBhbmQgaXQgY2xlYW5zIHRoZSBjb21wb25lbnRcbiAgICAgKiB3aGVuIGl0J3MgY2xvc2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblNob3dSZXZlcnNlR2VvY29kaW5nQ2xpY2sgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgLy8gaW50ZXJhY3Rpb25zIGRlY2xlbmNow6llcyDDoCBsJ291dmVydHVyZS9mZXJtZXR1cmUgZHUgcGFubmVhdVxuICAgICAgICBpZiAodGhpcy5fc2hvd1JldmVyc2VHZW9jb2RpbmdDb250YWluZXIuY2hlY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTWFwSW50ZXJhY3Rpb24obWFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2FpdGluZyAmJiAhdGhpcy5fcmV2ZXJzZUdlb2NvZGluZ0xvY2F0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZU1hcEludGVyYWN0aW9uKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGV2ZW50ICdjaGFuZ2UnIG9uICdHUHJldmVyc2VHZW9jb2RpbmdDb2RlJyB0YWcgc2VsZWN0XG4gICAgICogKGNmLiBSZXZlcnNlR2VvY29kaW5nRE9NLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nRm9ybU1vZGVDaG9pY2VHZW9jb2RpbmdUeXBlRWxlbWVudCkuXG4gICAgICogdGhpcyB2YWx1ZSBpcyBzYXZlZCBhcyBhIHBhcmFtZXRlciBmb3IgcmV2ZXJzZUdlb2NvZGUgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gSFRNTEVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUmV2ZXJzZUdlb2NvZGluZ1R5cGVDaGFuZ2UgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaWR4ID0gZS50YXJnZXQuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgdmFyIHZhbHVlID0gZS50YXJnZXQub3B0aW9uc1tpZHhdLnZhbHVlO1xuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY3VycmVudEdlb2NvZGluZ1R5cGUgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGV2ZW50ICdjaGFuZ2UnIG9uICdHUHJldmVyc2VHZW9jb2RpbmdDb2RlJyB0YWcgc2VsZWN0XG4gICAgICogKGNmLiBSZXZlcnNlR2VvY29kaW5nRE9NLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nRm9ybU1vZGVDaG9pY2VHZW9jb2RpbmdEZWxpbWl0YXRpb25FbGVtZW50KS5cbiAgICAgKiB0aGlzIHZhbHVlIGlzIHNhdmVkIGFzIGEgcGFyYW1ldGVyIGZvciByZXZlcnNlR2VvY29kZSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBIVE1MRWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25SZXZlcnNlR2VvY29kaW5nRGVsaW1pdGF0aW9uQ2hhbmdlIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGlkeCA9IGUudGFyZ2V0LnNlbGVjdGVkSW5kZXg7XG4gICAgICAgIHZhciB2YWx1ZSA9IGUudGFyZ2V0Lm9wdGlvbnNbaWR4XS52YWx1ZTtcblxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsb2dnZXIubG9nKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY3VycmVudEdlb2NvZGluZ0RlbGltaXRhdGlvbiA9IHZhbHVlO1xuXG4gICAgICAgIC8vIG9uIHN1cHByaW1lIGwnaW50ZXJhY3Rpb24gcHLDqWPDqWRlbnRlLFxuICAgICAgICAvLyBhaW5zaSBxdWUgbGVzIGfDqW9tw6l0cmllcyBldCB2YWxldXJzIHN0b2Nrw6llcyAoZmlsdHJlcywgcG9zaXRpb24pXG4gICAgICAgIHRoaXMuX2NsZWFySW5wdXRSZXF1ZXN0KCk7XG5cbiAgICAgICAgLy8gb24gbWV0IMOgIGpvdXIgbCdpbnRlcmFjdGlvbiBkZSBsYSBtYXAgZW4gZm9uY3Rpb24gZGUgbGEgbm91dmVsbGUgZMOpbGltaXRhdGlvblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIG9uIHN1cHByaW1lIGwnw6l2ZW50dWVsbGUgcHLDqWPDqWRlbnRlIGludGVyYWN0aW9uXG4gICAgICAgIHRoaXMuX3JlbW92ZU1hcEludGVyYWN0aW9uKG1hcCk7XG4gICAgICAgIC8vIG9uIGNyw6llIHVuZSBub3V2ZWxsZSBpbnRlcmFjdGlvblxuICAgICAgICB0aGlzLl9hY3RpdmF0ZU1hcEludGVyYWN0aW9uKG1hcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRPRE8gdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGV2ZW50ICdjbGljaycgb24gJ0dQcmV2ZXJzZUdlb2NvZGluZ1JldHVyblBpY3RvJyBkaXZcbiAgICAgKiAoY2YuIFJldmVyc2VHZW9jb2RpbmdET00uX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdQYW5lbFJldHVyblBpY3RvRWxlbWVudCksXG4gICAgICogYW5kIGNsZWFyIGdlb2NvZGVkIGxvY2F0aW9uIChmcm9tIGJvdGggbGlzdCBjb250YWluZXIgYW5kIG1hcClcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25HUHJldmVyc2VHZW9jb2RpbmdSZXR1cm5QaWN0b0NsaWNrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIHN1cHByZXNzaW9uIGRlcyByw6lzdWx0YXRzIHByw6ljw6lkZW50c1xuICAgICAgICB0aGlzLl9jbGVhckxvY2F0aW9ucygpO1xuICAgICAgICB0aGlzLl9jbGVhckxvY2F0aW9uc0ZlYXR1cmUobWFwKTtcblxuICAgICAgICAvLyBvbiBlZmZhY2UgbGVzIHBvaW50cyBxdWkgb250IHB1IMOqdHJlIHNhaXNpcyBwcsOpY8OpZGVtbWVudFxuICAgICAgICB0aGlzLl9jbGVhcklucHV0UmVxdWVzdCgpO1xuXG4gICAgICAgIC8vIGV0IG9uIHLDqWFjdGl2ZSBsJ2ludGVyYWN0aW9uIHN1ciBsYSBtYXBcbiAgICAgICAgdGhpcy5fYWN0aXZhdGVNYXBJbnRlcmFjdGlvbihtYXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUT0RPIHRoaXMgbWV0aG9kZSBpcyBjYWxsZWQgYnkgZXZlbnQgJ3N1Ym1pdCcgb24gcmV2ZXJzZUdlb2NvZGluZyBmb3JtICgnR1ByZXZlcnNlR2VvY29kaW5nRm9ybScpXG4gICAgICogKGNmLiBSZXZlcnNlR2VvY29kaW5nRE9NLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUGFuZWxGb3JtRWxlbWVudCksXG4gICAgICogaXQgY2hlY2tzIHJldmVyc2UgZ2VvY29kZSBtYW5kYXRvcnkgcGFyYW1ldGVycyxcbiAgICAgKiB0aGVuIGNhbGwgdGhpcy5fcmV2ZXJzZUdlb2NvZGluZ1JlcXVlc3QoKSB0byBnZW5lcmF0ZSBhbmQgc2VuZCByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUmV2ZXJzZUdlb2NvZGluZ1N1Ym1pdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbGUgcGFyYW3DqHRyZSBwb3NpdGlvbiBlc3Qgb2JsaWdhdG9pcmVcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0R2VvbSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIm1pc3Npbmcgc2VhcmNoIGdlb21ldHJ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2kgb24gbidhIHRyb3V2w6kgYXVjdW4gZHJvaXQsIG9uIGV2aXRlIHVuZSByZXF1w6p0ZSBpbnV0aWxlIC4uLlxuICAgICAgICBpZiAodGhpcy5fbm9SaWdodE1hbmFnZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fcmV2ZXJzZUdlb2NvZGluZ1JlcXVlc3Qoe1xuICAgICAgICAgICAgaW5kZXggOiBzZWxmLl9jdXJyZW50R2VvY29kaW5nVHlwZSxcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIG9uU3VjY2Vzc1xuICAgICAgICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbnMgPSByZXN1bHRzLmxvY2F0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGlzcGxheUdlb2NvZGVkTG9jYXRpb25zKGxvY2F0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hpZGVXYWl0aW5nQ29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXQgb24gcsOpYWN0aXZlIGwnaW50ZXJhY3Rpb24gc3VyIGxhIG1hcFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA9PT0gMCkgc2VsZi5fYWN0aXZhdGVNYXBJbnRlcmFjdGlvbihtYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBjYWxsYmFjayBvbkZhaWx1cmVcbiAgICAgICAgICAgIG9uRmFpbHVyZSA6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbGYuX2hpZGVXYWl0aW5nQ29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdXBwcmVzc2lvbiBkJ8OpdmVudHVlbHMgcsOpc3VsdGF0cyBwcsOpY8OpZGVudHNcbiAgICAgICAgICAgICAgICBzZWxmLl9jbGVhckxvY2F0aW9ucygpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NsZWFyTG9jYXRpb25zRmVhdHVyZShtYXApO1xuXG4gICAgICAgICAgICAgICAgLy8gb24gZWZmYWNlIGxlcyBwb2ludHMgcXVpIG9udCDDqXTDqSBzYWlzaXMgcHLDqWPDqWRlbW1lbnRcbiAgICAgICAgICAgICAgICBzZWxmLl9jbGVhcklucHV0UmVxdWVzdCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXQgb24gcsOpYWN0aXZlIGwnaW50ZXJhY3Rpb24gc3VyIGxhIG1hcFxuICAgICAgICAgICAgICAgIHNlbGYuX2FjdGl2YXRlTWFwSW50ZXJhY3Rpb24obWFwKTtcblxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUT0RPIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBldmVudCAnY2xpY2snIG9uICdSZXZlcnNlR2VvY29kZWRMb2NhdGlvbl8nIGRpdlxuICAgICAqIChjZi4gUmV2ZXJzZUdlb2NvZGluZ0RPTS5fY3JlYXRlUmV2ZXJzZUdlb2NvZGluZ1Jlc3VsdEVsZW1lbnQpLFxuICAgICAqIGFuZCB6b29tIHRvIGxvY2F0aW9uID9cbiAgICAgKiBUT0RPXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIEhUTUxFbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblJldmVyc2VHZW9jb2RpbmdSZXN1bHRDbGljayA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJvblJldmVyc2VHZW9jb2RpbmdSZXN1bHRDbGlja1wiLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgZXZlbnQgJ21vdXNlb3Zlcicgb24gJ1JldmVyc2VHZW9jb2RlZExvY2F0aW9uXycgZGl2XG4gICAgICogKGNmLiBSZXZlcnNlR2VvY29kaW5nRE9NLl9jcmVhdGVSZXZlcnNlR2VvY29kaW5nUmVzdWx0RWxlbWVudCksXG4gICAgICogYW5kIGNoYW5nZXMgc3R5bGUgb2YgbWF0Y2hpbmcgbWFya2VyIG9uIG1hcCAoc2VsZWN0ZWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIEhUTUxFbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblJldmVyc2VHZW9jb2RpbmdSZXN1bHRNb3VzZU92ZXIgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZSBsJ2lkIGR1IHLDqXN1bHRhdCBzdXJ2b2zDqVxuICAgICAgICB2YXIgaWR4ID0gSUQuaW5kZXgoZS50YXJnZXQuaWQpO1xuXG4gICAgICAgIC8vIG9uIHBhc3NlIGxlIHRleHRlIGVuIGdyYXNcbiAgICAgICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgZS50YXJnZXQuY2xhc3NMaXN0LmFkZChcIkdQcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb25IaWdobGlnaHRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lucHV0UmVzdWx0c0xheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dFJlc3VsdHNMYXllci5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIub3B0aW9ucy5pZCA9PT0gcGFyc2VJbnQoaWR4LCAxMCkpIHtcbiAgICAgICAgICAgICAgICBsYXllci5maXJlKFwibW91c2VvdmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgZXZlbnQgJ21vdXNlb3V0JyBvbiAnUmV2ZXJzZUdlb2NvZGVkTG9jYXRpb25fJyBkaXZcbiAgICAgKiAoY2YuIFJldmVyc2VHZW9jb2RpbmdET00uX2NyZWF0ZVJldmVyc2VHZW9jb2RpbmdSZXN1bHRFbGVtZW50KSxcbiAgICAgKiBhbmQgY2hhbmdlcyBzdHlsZSBvZiBtYXRjaGluZyBtYXJrZXIgb24gbWFwIChkZWZhdWx0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBIVE1MRWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25SZXZlcnNlR2VvY29kaW5nUmVzdWx0TW91c2VPdXQgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZSBsJ2lkIGR1IHLDqXN1bHRhdCBzdXJ2b2zDqVxuICAgICAgICB2YXIgaWR4ID0gSUQuaW5kZXgoZS50YXJnZXQuaWQpO1xuXG4gICAgICAgIC8vIG9uIHJlcGFzc2UgbGUgdGV4dGUgZW4gc3R5bGUgbm9ybWFsXG4gICAgICAgIGlmIChlLnRhcmdldC5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoXCJHUHJldmVyc2VHZW9jb2RlZExvY2F0aW9uSGlnaGxpZ2h0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dFJlc3VsdHNMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXRSZXN1bHRzTGF5ZXIuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgaWYgKGxheWVyLm9wdGlvbnMuaWQgPT09IHBhcnNlSW50KGlkeCwgMTApKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZmlyZShcIm1vdXNlb3V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIGNsZWFuICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiBUT0RPIHRoaXMgbWV0aG9kIGNsZWFycyBwcmV2aW91cyBsb2NhdGlvbiByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhckxvY2F0aW9ucyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmV2ZXJzZUdlb2NvZGluZ0xvY2F0aW9ucyA9IFtdO1xuICAgICAgICAvLyBvbiB2aWRlIGxlIGNvbnRhaW5lciBhdmVjIGxhIGxpc3RlIGRlcyByw6lzdWx0YXRzXG4gICAgICAgIGlmICh0aGlzLl9yZXN1bHRzTGlzdENvbnRhaW5lcikge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3Jlc3VsdHNMaXN0Q29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHRzTGlzdENvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9yZXN1bHRzTGlzdENvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUT0RPIHRoaXMgbWV0aG9kIGNsZWFycyBwcmV2aW91cyBsb2NhdGlvbiByZXN1bHRzIG1hcmtlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgLSB0aGUgbWFwXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhckxvY2F0aW9uc0ZlYXR1cmUgOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIC8vIHN1cHByZXNzaW9uIGRlcyBhbmNpZW5zIHJlc3VsdGF0c1xuICAgICAgICBpZiAodGhpcy5faW5wdXRSZXN1bHRzTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1hcC5yZW1vdmVMYXllcih0aGlzLl9pbnB1dFJlc3VsdHNMYXllcik7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dFJlc3VsdHNMYXllciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETyB0aGlzIG1ldGhvZCBjbGVhcnMgcHJldmlvdXMgaW5wdXQgZmVhdHVyZXMgKGZlYXR1cmVzLCBwb3NpdGlvbiBhbmQgZmlsdGVycylcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFySW5wdXRSZXF1ZXN0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBvbiBzdXBwcmltZSBsZXMgdmFsZXVycyBzdG9ja8OpZXMgKGZpbHRyZXMsIHBvc2l0aW9uKVxuICAgICAgICB0aGlzLl9yZXF1ZXN0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0Q2lyY2xlRmlsdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEJib3hGaWx0ZXIgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBQYXRpZW5jZSAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGRpc3BsYXlzIHdhaXRpbmcgY29udGFpbmVyIGFuZCBzZXRzIGEgdGltZW91dFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzcGxheVdhaXRpbmdDb250YWluZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dhaXRpbmdDb250YWluZXIuY2xhc3NOYW1lID0gXCJHUHJldmVyc2VHZW9jb2RpbmdDYWxjV2FpdGluZ0NvbnRhaW5lclZpc2libGVcIjtcbiAgICAgICAgdGhpcy5fd2FpdGluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gbWlzZSBlbiBwbGFjZSBkJ3VuIHRpbWVvdXQgcG91ciByw6lpbml0aWFsaXNlciBsZSBwYW5lbCAoY2FjaGVyIGxhIHBhdGllbmNlKVxuICAgICAgICAvLyBzaSBvbiBlc3QgdG91am91cnMgZW4gYXR0ZW50ZSAoc2kgbGEgcmVxdcOqdGUgZXN0IGJsb3F1w6llIHBhciBleGVtcGxlKVxuICAgICAgICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuX3dhaXRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9oaWRlV2FpdGluZ0NvbnRhaW5lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5fdGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDE2MDAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaGlkZXMgd2FpdGluZyBjb250YWluZXIgYW5kIGNsZWFycyB0aW1lb3V0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlV2FpdGluZ0NvbnRhaW5lciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdDb250YWluZXIuY2xhc3NOYW1lID0gXCJHUHJldmVyc2VHZW9jb2RpbmdDYWxjV2FpdGluZ0NvbnRhaW5lckhpZGRlblwiO1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJldmVyc2VHZW9jb2Rpbmc7XG5cbi8vIEV4cG9zZSBSZXZlcnNlR2VvY29kaW5nIGFzIEwuZ2VvcG9ydGFsQ29udHJvbC5SZXZlcnNlR2VvY29kaW5nIChmb3IgYSBidWlsZCBidW5kbGUpXG5pZiAod2luZG93LkwpIHtcbiAgICBpZiAoIXdpbmRvdy5MLmdlb3BvcnRhbENvbnRyb2wpIHtcbiAgICAgICAgd2luZG93LkwuZ2VvcG9ydGFsQ29udHJvbCA9IHt9O1xuICAgIH1cbiAgICB3aW5kb3cuTC5nZW9wb3J0YWxDb250cm9sLlJldmVyc2VHZW9jb2RpbmcgPSBSZXZlcnNlR2VvY29kaW5nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Leaflet/Controls/ReverseGeocoding.js\n");

/***/ }),

/***/ "./src/Leaflet/Controls/Utils/IconDefault.js":
/*!***************************************************!*\
  !*** ./src/Leaflet/Controls/Utils/IconDefault.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n\n\nvar logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLogger(\"icondefault\");\n/**  cf. http://leafletjs.com/reference.html#icon */\n\nvar IconDefault = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Icon.Default.extend(\n/** @lends IconDefault.prototype */\n{\n  /**\n  * Liste des icones\n  *   TODO : image retina à convertir en x2...\n  */\n  images: {\n    retina: {\n      shadow: \"data:image/png;base64,...\",\n      color: {\n        blue: \"data:image/png;base64,...\",\n        orange: \"data:image/png;base64,...\",\n        red: \"data:image/png;base64,...\",\n        green: \"data:image/png;base64,...\"\n      }\n    },\n    shadow: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=\",\n    color: {\n      blue: \"data:image/png;base64,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\",\n      orange: \"data:image/png;base64,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\",\n      red: \"data:image/png;base64,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\",\n      green: \"data:image/png;base64,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\"\n    }\n  },\n\n  /**\n   * constructor\n   * (extend to L.Icon.Default)\n   *\n   * @param {String} color - blue, green or red, blue by default.\n   * @param {Object} options - options of L.Icon\n   */\n  initialize: function initialize(color, options) {\n    // on merge les options avec celles par defaut\n    leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Util.extend(this.options, options);\n    var _color = null;\n    var _images =\n    /* (L.Browser.retina) ? this.images.retina : */\n    this.images;\n\n    switch (color) {\n      case \"red\":\n        _color = _images.color.red;\n        break;\n\n      case \"green\":\n        _color = _images.color.green;\n        break;\n\n      case \"orange\":\n        _color = _images.color.orange;\n        break;\n\n      case \"blue\":\n        _color = _images.color.blue;\n        break;\n\n      default:\n        _color = _images.color.blue;\n    } // icones classiques\n\n\n    this.options.iconUrl = _color;\n    this.options.shadowUrl = _images.shadow; // icones pour écran Retina\n\n    if (leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Browser.retina) {\n      this.options.iconRetinaUrl = _color;\n      this.options.shadowRetinaUrl = _images.shadow;\n    }\n  },\n\n  /**\n   * Overload function to ensure compatibility between versions 0.7.X and 1.0.X\n   * (extend to L.Icon._getIconUrl)\n   *\n   * @param {String} name - name\n   *\n   * @returns {String} url\n   *\n   */\n  _getIconUrl: function _getIconUrl(name) {\n    logger.trace(\"OVERWRITTEN L.Icon.Default._getIconUrl(\" + name + \")\");\n    return leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Icon.prototype._getIconUrl.call(this, name);\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (IconDefault);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9Db250cm9scy9VdGlscy9JY29uRGVmYXVsdC5qcz9kYWIzIl0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIkljb25EZWZhdWx0IiwiTCIsIkljb24iLCJEZWZhdWx0IiwiZXh0ZW5kIiwiaW1hZ2VzIiwicmV0aW5hIiwic2hhZG93IiwiY29sb3IiLCJibHVlIiwib3JhbmdlIiwicmVkIiwiZ3JlZW4iLCJpbml0aWFsaXplIiwib3B0aW9ucyIsIlV0aWwiLCJfY29sb3IiLCJfaW1hZ2VzIiwiaWNvblVybCIsInNoYWRvd1VybCIsIkJyb3dzZXIiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93UmV0aW5hVXJsIiwiX2dldEljb25VcmwiLCJuYW1lIiwidHJhY2UiLCJwcm90b3R5cGUiLCJjYWxsIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQSxJQUFJQSxNQUFNLEdBQUdDLHFFQUFNLENBQUNDLFNBQVAsQ0FBaUIsYUFBakIsQ0FBYjtBQUVBOztBQUNBLElBQUlDLFdBQVcsR0FBR0MsOENBQUMsQ0FBQ0MsSUFBRixDQUFPQyxPQUFQLENBQWVDLE1BQWY7QUFBc0I7QUFBb0M7QUFFeEU7QUFDSjtBQUNBO0FBQ0E7QUFDSUMsUUFBTSxFQUFHO0FBQ0xDLFVBQU0sRUFBRztBQUNMQyxZQUFNLEVBQUcsMkJBREo7QUFFTEMsV0FBSyxFQUFHO0FBQ0pDLFlBQUksRUFBRywyQkFESDtBQUVKQyxjQUFNLEVBQUcsMkJBRkw7QUFHSkMsV0FBRyxFQUFHLDJCQUhGO0FBSUpDLGFBQUssRUFBRztBQUpKO0FBRkgsS0FESjtBQVVMTCxVQUFNLEVBQUcsZ2tDQVZKO0FBV0xDLFNBQUssRUFBRztBQUNKQyxVQUFJLEVBQUcsb3pFQURIO0FBRUpDLFlBQU0sRUFBRyx3N0VBRkw7QUFHSkMsU0FBRyxFQUFHLHc1RUFIRjtBQUlKQyxXQUFLLEVBQUc7QUFKSjtBQVhILEdBTitEOztBQXlCeEU7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsWUFBVSxFQUFHLG9CQUFVTCxLQUFWLEVBQWlCTSxPQUFqQixFQUEwQjtBQUNuQztBQUNBYixrREFBQyxDQUFDYyxJQUFGLENBQU9YLE1BQVAsQ0FBYyxLQUFLVSxPQUFuQixFQUE0QkEsT0FBNUI7QUFFQSxRQUFJRSxNQUFNLEdBQUcsSUFBYjtBQUNBLFFBQUlDLE9BQU87QUFBRztBQUFnRCxTQUFLWixNQUFuRTs7QUFDQSxZQUFRRyxLQUFSO0FBQ0ksV0FBSyxLQUFMO0FBQ0lRLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNHLEdBQXZCO0FBQ0E7O0FBQ0osV0FBSyxPQUFMO0FBQ0lLLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNJLEtBQXZCO0FBQ0E7O0FBQ0osV0FBSyxRQUFMO0FBQ0lJLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNFLE1BQXZCO0FBQ0E7O0FBQ0osV0FBSyxNQUFMO0FBQ0lNLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNDLElBQXZCO0FBQ0E7O0FBQ0o7QUFDSU8sY0FBTSxHQUFHQyxPQUFPLENBQUNULEtBQVIsQ0FBY0MsSUFBdkI7QUFkUixLQU5tQyxDQXVCbkM7OztBQUNBLFNBQUtLLE9BQUwsQ0FBYUksT0FBYixHQUF1QkYsTUFBdkI7QUFDQSxTQUFLRixPQUFMLENBQWFLLFNBQWIsR0FBeUJGLE9BQU8sQ0FBQ1YsTUFBakMsQ0F6Qm1DLENBMkJuQzs7QUFDQSxRQUFJTiw4Q0FBQyxDQUFDbUIsT0FBRixDQUFVZCxNQUFkLEVBQXNCO0FBQ2xCLFdBQUtRLE9BQUwsQ0FBYU8sYUFBYixHQUE2QkwsTUFBN0I7QUFDQSxXQUFLRixPQUFMLENBQWFRLGVBQWIsR0FBK0JMLE9BQU8sQ0FBQ1YsTUFBdkM7QUFDSDtBQUNKLEdBaEV1RTs7QUFrRXhFO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJZ0IsYUFBVyxFQUFHLHFCQUFVQyxJQUFWLEVBQWdCO0FBQzFCM0IsVUFBTSxDQUFDNEIsS0FBUCxDQUFhLDRDQUE0Q0QsSUFBNUMsR0FBbUQsR0FBaEU7QUFDQSxXQUFPdkIsOENBQUMsQ0FBQ0MsSUFBRixDQUFPd0IsU0FBUCxDQUFpQkgsV0FBakIsQ0FBNkJJLElBQTdCLENBQWtDLElBQWxDLEVBQXdDSCxJQUF4QyxDQUFQO0FBQ0g7QUE5RXVFLENBQTFELENBQWxCO0FBaUZleEIsMEVBQWYiLCJmaWxlIjoiLi9zcmMvTGVhZmxldC9Db250cm9scy9VdGlscy9JY29uRGVmYXVsdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMIGZyb20gXCJsZWFmbGV0XCI7XG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi9Db21tb24vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cbnZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiaWNvbmRlZmF1bHRcIik7XG5cbi8qKiAgY2YuIGh0dHA6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2ljb24gKi9cbnZhciBJY29uRGVmYXVsdCA9IEwuSWNvbi5EZWZhdWx0LmV4dGVuZCgvKiogQGxlbmRzIEljb25EZWZhdWx0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAqIExpc3RlIGRlcyBpY29uZXNcbiAgICAqICAgVE9ETyA6IGltYWdlIHJldGluYSDDoCBjb252ZXJ0aXIgZW4geDIuLi5cbiAgICAqL1xuICAgIGltYWdlcyA6IHtcbiAgICAgICAgcmV0aW5hIDoge1xuICAgICAgICAgICAgc2hhZG93IDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICBjb2xvciA6IHtcbiAgICAgICAgICAgICAgICBibHVlIDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICAgICAgb3JhbmdlIDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICAgICAgcmVkIDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICAgICAgZ3JlZW4gOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwuLi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3cgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ2tBQUFBcENBWUFBQUNvWUFEMkFBQUM1RWxFUVZSWXcrMllXNC9UTUJDRjQ1UzBTMWx1WFpDQUJ5NUNnTFFnd2YvL1M0QllCTFRkSkxheDBmRnFtQjA3bm5RZkVHcWtJeWRwVkg4NU0rTkxqUGUrK2RjUGM0UThRaDRoajVEL0FhUUp4NkgvNFRNd0IwUGVCTndVN0VHUUFtQXRzTmZBem9aa2dJYTBaZ0xNYTRBajZDeElBc2poak9Db0w1ejdHbGcxSkFPa2FpY2d2UUJYdW5jd0pBV2prc0x0QlRXWmUwNENuWVJrdFVHZGlsQUxwcFpCT2dIR1pjQnpMNk9DbEFCdk1TVkl6eUJqYXpPZ3J2QUNmMXlkQzVtZ3VxQVZnNlJoZGtTV1FGajJ1eGZhcS9CcklaT0xFV2daZEFMSUR2Y01jWkxEOFpiTEM5ZGU0eVIxc1lNaTRHMjBTNFEvUFdlSll4VE9abjV6SlhBTlpISXhBZDRKV2hQSWxvVEpaaHpNUWR1TTg5V1EzTVVWQUUvUm5oQVhwVHljcXlzM05aQUxPQmJCN2tGcmdMZXNRbDJoNDVGY2o4TDF0VFNvaFV3dXhoeThIL1FnNks3Z0lzKzNra2FpZ1FDT2N5RVhDSE4wN3d5UWF6aHJtSXVsdktNUUF3TWNtTE5xeUNWeU1BSStCdXhTTWVUazNPUGlrTFkySjF1RStWSFFrNkFOcmhkcyt0TkFScUJlYUdjNzJjSzU1MEZQNFdoWG1GbWNNR2hUd0FSMWlmT2UzRXZQcUllZ0ZtRitDOGdWeTBPZkFhV1FQTVI3Z0YxT1FLcUdvQmpxOTBIUE1QMDFCVWpQT3FHRmtzQzRlbUU0OHRXUUFIMFltdk9nRjNEU1Q2eGllSmdIQVd4UEFITXVOaHJJbUlkdm9OT0tOV0lPY0UrVVhFMHBZQW5rWDZ1aFdzZ1ZYRHhIZFRmQ21yRUVtTUIyek1GaW1MVk90aWlhanhpR1dyYlU1MkVlQ2R5T3dQRVFEOExxeVBIOVRpMmtnWU1mNE9oU0tCN3FZSUxiQnYzQ3VWVEoxMVk4MG9hc2VpTVdPT05jL1k3a0pZZTB4TDJmMEJhaUZUeGtuSE81SGFNR011YmxLd3hGR3pZZFdzQkYxNzRIL1FEa25oVEhtSEhOMzlpV0Zua1p4OGxQeU04V0hmWUVMbWxMS3RnV05tRk56UWNDMWI0N2dKNGhMMTlpN282NWRoSDBOZWdiY2E4dk9OWm9QN2RvSWVPQzl6WG04Ump1TDBHZjRkNE9ZYVU1bGpvM0dZaXF6cldRSGZKeEE2QUxoRHBWS3Y5cVllWkE4ZU0zRWhmUFNDbXB1RDBBQUFBQVNVVk9SSzVDWUlJPVwiLFxuICAgICAgICBjb2xvciA6IHtcbiAgICAgICAgICAgIGJsdWUgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUdta2xFUVZSWXc3VlhlVXlUWnhqdk5uZkVMRnV5SXpPYWJlcm1NWkVlUUMvT2Nsa080OUNwT0hYT0xKbC9DQVVSdVliUWkzS0xnRWhicmhaMWFEd21hb0dxS0lJNm9kQVRtSC9zY0RGYmRDN0x2RnFPQ2MrZTk1czJWRzUwWC9MTG0vZjQvWjduZVkvbmUxOGFBTkNtQXI1RS94WmYxdURPa1RjR2NXUjZobDkyNDd0VDVVN1k2U052V3NLVDYzUDU4cWJmZUxKRzhNNXFjZ1RrbnJ2dnJkRGJzVDdNbCt0djgyWDZ2VnhKRTMzYVJtZ1N5WXRjV1ZNcVg5N1l2Mkp2VzM5VWhSRTJIdXlCTCt0K2dLMTExNmx5MDZFZVdGTmxBbUh4bFFFME9NaVY2bVFDU2N1c0tSbGhTM1FMZVZKZGwxKzIzaDVkWTRGTkIzdGhyYllib3FwdEVGbHBoVEMxaFNwSm5iUnZ4UDROV2dzRTVKeXo4NlFOTmkvNXFTVVRHdUZrMWd1NTR0Tjl3dUsyd2MzbytXYzEzUkNtc29Cd0VxekdjWnN4c3ZDU3kvOXdKS2Y3VVdmMW1FWThKV2Zld2M2N1VVb0RiRGpRQytGcUs0UXFMVk1HR1I5ZDJ3dXJLenFCazNucUlULzl6THhSUmpnWjlicVFndWIrRGRvZUNDMDNROGorMFFoRmhCSFIvZVAzVS96Q2xuN1V1K2hpaEoxK2JCTmZmTEl2bWt5UDBncEJaV1lYaEt1c3NLNm1CejVIVDZNMU5xcGNwK21CQ1BYb3NZUWZyZWtHdnJqZXdkNTkvR3ZLQ0U3VGJLLzA0L1pWNVFaWVZXbUR3SDFtRjN4YTJRM3JhM0RCQzV2QlQxb1A3UFRqNEMwK0NjTDhjN0MyQ3RlanFodUNudUlRSGFLSHp2Y1JmWnBueWxGZlhzWUp4M3BOTHdoS3pSQXdBaEVxRzBTcHVzQkhmQUtreHczdzQ2MjdNUGhvQ0g3OTh6N3MwWm5CSi9NRUpiWlNiWFBoRVIyaWg3cDJvay96U2oyY0VKRGQ0Q0FlKzVXWW5CQ2dSMnVydXlFdzZ6Um9XNi9EV0ovT2VBUDhwZC9CR3R6T1pLcEc4b2tlMFNYNkdNbVJrNkdGbHlBYzU5SzMyT1RFaW5JTFJKUmNoYWg4SFF3TkQ4TjQzNVo5WjBGWTFFcXR4VWcrMFNPNlJKL21tWHo0VnVTK0RweFhDM2dYbVp3SUw3ZEJTSDR6S0U1MHdFU2Y4cXdWZ3JQMUVJbFRPNUpQOUlndTBhZXhkaDI4RjFsbUFFR0pHZmg3akU2RWx5TTVSdy9GRGNZSmpXaGJlaUJZb1lOSXBjMkZUL1NJTGl2cDBGMWlwRFdrNEJJRW8yVnVvZEVKVWlmaGJpbHRuTkJJWFBVRkNNcHRodEF5cXdzL0JQbEVGL1ZiYUl4RXJkeFBwaHNVN3JjQ3A4RG9oQytHdkJJUEpTL3RXMmp0dlRtbUFldU5POEJOT1lRZUc4Ry8yT3pDSjNxK3NvWUI1aTZOaE1hS3IxN0ZTYWw3R0lIaGV1VjN1U0NZOHFZVnVFbTFjT3pxZFdyN2t1L1IwQkRvVFQrRFQrb2hDTTYvQ0N2S0xLTzRSSStkWFBlQXVhTXFrc2FLclo3TDNGRTVGSUZia0ljZWVPWjJPY0hPNndJaFRrTm8wZmZnalJHeEVxb2dYSFlVUEhmV0FDL2xBRHB3R2NMUlkzYWVLNC9vUkdDS1ljWlhQVm9lWC9rZWxWWVk4ZFVHZjhWNUVCUmJnSlhUNVFJUGhQOWVQSmk0MjhKS09pRVloWVhGQnFvdTJHdWgrcC9tRUIxL1JmTXc2clk3Y3hjalRybmVJMUZyRHl1elVTUm05bWl3RUp4OEUvZ1VtcWx5dkhHa25laXdFclIyMUYzdE5PSzVUZjB5WGFUK083RGdDdkFMVFVCWGRNNFloQy9JYXdQVSsyUGR1cU12dWFSNmVveFN3VWs3NWdncXNZSjdWaWNzbndHSWtaQlNYS09Vd3c3M1dHWHlxUCtKMi9iOWMrZ2kxWUFnL3hwd2NrM2dKdXVjTnJoNUp2RFB2UXIwV0ZYZjBwaXl0OGY4L1dJMGhWNHBSeHhrUVpkSkRmREpOT0FtTTBBZzhqeVQ2aHowV0dYV3VQOTRZaDJqY2ZqbVhBR3ZIQ01zbFJpbURIWXVIdURzeTJRdEh1SWF2em5oYllVUnE1UjU3S3B6QkJSWktQSmk4ZVFnNDhoNGo4U0Rkb3dpZmRJckVWZFUrZ2JPNlFOdlJSdDRaQnRoVWFaaFVuamxZT2JOYWdWM2tlb2VydTNyVTdyY3VjZXFVMW1KQnh5K0JXWllsTkVCSCswZUg0dlJpQitPWXliVTJobmJsWWxUdmtIaW5NNG01NFlueFN5YVpZU0Y2UjNqd2dQN3VkS0xHSVg2ci9sYk5hOU42eTVNRnlualdEdHJIZDc1WnZUWUFQTy82UmdGMGs3Nm1RbGEzRkdxN2RPK2NIOHNLbjBWbzduRGxsd0FocXdMUGt4ckh3V21ISk9vK0FLSjRyYWI1T2dyTTdyVnU4ZVdiMlB1MERoNGVEZ1hvT2Z2cDdZN1FlcWtuUm12Y1RCRXlxOW0vSFFRU0NTejZMSHEzejB5enNOeVNSZk1TMjUzd2wyS3lSRGJjWlBjZkpLalptU0VPamN4eWkrWThkVU90c0lFSDZSMndOeWtkcXJrWUowUlY5MkgwVzU4cGtmUWs3Y0tldnNMSzEwUHk4U2RNR2ZYTlhBVFkrcFBieUpSL0VUNm45bklmenROdFpZUlY5WG5pUXU5SUEydk9WZ3k0aXI3R0NMVm1tZCt6amtIMGVBRjlQbzZLNjFwbUNYSHhVNXJITVlkMWZ0YzNvd2p3UlNWUnpMakt2cVpFdHk2Y1JVRDdqR3FpT2R1NUhHNk1kSGpOY05ZR3FmRG01WVJ6TEJCQ0NEbC8yYms4YThnZGJxY2Z3RUN1NjJGZy9IcmdnQUFBQUJKUlU1RXJrSmdnZz09XCIsXG4gICAgICAgICAgICBvcmFuZ2UgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBRnpVa2RDQUs3T0hPa0FBQUFnWTBoU1RRQUFlaVlBQUlDRUFBRDZBQUFBZ09nQUFIVXdBQURxWUFBQU9wZ0FBQmR3bkxwUlBBQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUFTQUFBQUVnQVJzbHJQZ0FBQmdoSlJFRlVXTU9kbDF1SW5HY2R4bi9mZVdhK21mbG1KbVpicVZxS2lnZXdLSzVnb0hnUlNFbThFQzg4RjZ0QkZMZmdaYnpKblZkUllXRXhyVkJvWGF6V2xBWUwwZFZpc0xCWXpFVVVTYmVOalpRbXhHWjNOak83YzU3di9QNjltTm5EN016dXp2ckNBOFBNKy8rZTkzbitoL2NiN2M5UHpYS0U5UkhBRzM2K0JYUlBQMzM5MENEdFQzTUhrbFNBN3dLbmdWT1diYU9oQTVBa0VVcXBLbkFGZVBITU05ZVg5eWVack1RQXpnSG5pMTRsbjgyNlpMTHUyS1kwVGZEN1hYcTlOb0hmZnhYNDhabW5yNitNa1N5Tks2a0FsNHFsOHFsaXNZeHBXYWdvSkExNmdJeHMxRTBiSTFjQW9OTnVzbEZiOTRFbnYvak05Y3NqKzBTRVhhaUl5Tis5Y3VWVTVkaHhkRW1JMjNYU29BT29JY2tPVkJJU3QrdkU3UTBLUlk4SDN2K0JiTTdOdjd3ME56czNRckxIb3BkTDVjckh5cVVLU2JkQjZuZEExQlJJaVZzMU1vNU55U3NEL0dKcGJ2YmtqcEtkczUwckZMMlQ1VktacE5kQWttamlBelhESE95ZThGdlMyY0MyTFdabUhqQUVMdjF4YnJZeUlGR0NLS21Ja3ZNbHI0aUsrMGdhRGUwWlFIY3lXSVV5VnFHTW1EWld2b1JWS0dPNjNzZytVTVNkR3E2Ym8rUjV4MFhKdVlGZEdxRHhMYTlVekp1bVFScDBSM3kzQ2hVMDAyWmpjNVBiZCs2d0dlbThlL3NPNit2ckJHR0lWYWdNVGRtSlNjTWVwWklIR2ovNHd3OC9hNWpEZXZsNjNzMmg0bkFnZmJoTTF5T01RdDY3VitXalo4N3krVk5QWW1YekFOejd4MTlZdWZRemlsRkl5U3NUdCt2YmNTcnNZVGxabkV5bUVnVEJDVjJVNUVYSmlVekdKZzFhSTlJMXc2RFpiUEhvRStmNStKZWUyaVlBZUdqMmNSNDc5enlOam8rU0ZOMTJ4cXpMWlJ4RXlXbGQ0RU9XYlJtSUFwVnVKMUUzTGFJd1JMa3pQUHpZbDhjYVVVUndaejdJdzEvNENxMVdHOFBPakJTQkN2dll0b25BSjNVUnFlaWFObFlwdXVYZyt3SGxSejQxa1FCQUtVWDV3NSttMS9QSEtrN1NCRjBERWZGTWdVakpNR25hcm83V0ZHaWcwbmhmQWhFaGpRSTBUUnVMMXd3TkZTa0VmRjJFZTNHU2pwMGtEWHE0V1p2N2IxOUhKZU5FV3lTck4vNUczblVRbGV6cEo0TWtUUkhobmk0aTFUaE91aXBOQnlmYWtoc0htSVpHUm5WNTY1V0xZeW9BMXQ2OFJ1T05xM2o1REtuZkhpWFJkS0lvUmtUdUdsLzl6SU1DZkM3ckdKL0k1dk9vY0dzUUNvaVF6N3ZjLzgrL1dIMzdCcm5LZ3pqRlk3UldiL1B1OG1WV0x2MlVtVW9PeHpZR0pGdHhtb2JoWkZtcmQwaFM5U1B0cGJPUEFweDBzL1pmSDNtb1JOeXVqVTVhTzRlUmNXbDJBalpiUG42WVlGc0dYdDZoNG1VeERYMHN4aW9lcDlrSmVHKzlmZlZyejk5NGZLc1pYK3Y2MGJWdVB6emhGbzZSZEhZMVZ0UkRFcDlTNFJpbGdqUHlNQlgyaVh1OTBkSWJGc0ZtMjBmZ0p3Q203QlRFenpkYS91L3pyalZzcGwySlZvcTR2YzQweXlyTzBPcUdkUHZ4YTkvNDFZM1hZZlErdWRMc2hPOEVRWXlaSzA0NTRpZEFLVFlhZlVUa3dyYmx1MFo5S2pCZmIvcG91dmwvRVpodW1hNGYwZTdILy96bTRodFh0MG4yM0hhTDlWWlFTNUlVM2M0ZW1VVFROT29OSDloUnNWY0pBcjdBczdWV2dKSEpEVHA0U3BpRk12MG9vZEdMYndtOE1rb3llc2NqSWd0cm00R3ZsRUkzN1NPbzBLazFBa1Rrd2hPTEsra2VFdGlEbWdndjFGc2hScll3RllHUkxSSkVLZlYyZkZlRUYvZFczRjY3dGpCL3R4YW1Jb0ttNjVOMzdJSnUyZFJhRVFMejMvNzFtOUU0eWJoZGlNZ3RFVm5hN0VRWStRb2lhbC9vVG80b1RxazJvcHFJUERlcGQvUUR6amgvdnhtRE90Z3EzY3F5M29nUXVQaWRGOTdxVGlhWnJBUVJXVzc3NmJWT2tHSVczamZaSmlkSHFvVFZSdHdWa1lYOXBzQ2t4Ty9Hd25valJodk1sdkdFMnptcXpSZ1Jmbm4yTnpkYis1TWNuTmJMOWE1Nng0OEZJK3Z0U2JhRGFQRGZqU1FTbUQ5b25oMWtGeUtTaXNoQ3RabWdXL1pZMmE1dHhvakk0dmQrZTdONkNNbUJkaUhDNGxvanJjV3BvRHN1SUdpbWhZaHdwNWFtSWx6Z2tLVWYxZ01nWFpCbnE0MEV3OGtOQm1HdXhIb3pBZVNsNy8vdTM3Y1BKVG1VWW9DTGR6ZFZKTU5jZ0xEV0ZvVERWVXhyRnlKVVJWaXNOaFZHenFQV1Z2UUNXUkpoWlNxUzRRdjNORmhZYXcxMHJiVUVOQzRNYW5zYUpZTy9EdFBnWmkrUUs3VzIwT3JMc2loNVhaUk1TVEpkVHJaSHpXcHprSXV0NzZhejYyaHJ1ZVh6SFBEcVVZTCtCOFhWS1V6dVVpbWZBQUFBSlhSRldIUmtZWFJsT21OeVpXRjBaUUF5TURFeUxUQTRMVEU0VkRFME9qVXdPalUyS3pBeE9qQXdGbENrWHdBQUFDVjBSVmgwWkdGMFpUcHRiMlJwWm5rQU1qQXhNaTB3T0MweE9GUXhORG8xTURvMU5pc3dNVG93TUdjTkhPTUFBQUFaZEVWWWRGTnZablIzWVhKbEFFRmtiMkpsSUVsdFlXZGxVbVZoWkhseHlXVThBQUFBQUVsRlRrU3VRbUNDXCIsXG4gICAgICAgICAgICByZWQgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBRnpVa2RDQUs3T0hPa0FBQUFnWTBoU1RRQUFlaVlBQUlDRUFBRDZBQUFBZ09nQUFIVXdBQURxWUFBQU9wZ0FBQmR3bkxwUlBBQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUFTQUFBQUVnQVJzbHJQZ0FBQmU1SlJFRlVXTU9kbFd1SVhHY1p4My9uUGJlNVpXYk8yYzBhOFZJRXBTcTBpbzJRQlQ4RlVsSUZFYnpmb2tVVUtmZ3hJdVNibitKdFlURVFxRlFDUW1reFZJaU5GaGNMd1pvVnRyRk50NDBFU3JQRUpqdTdzL2VaTStmK1BuNlkyWFZuWjNabjAvZndjQTd2ZVovemU1Ly84N3pQTWY1NmZKSUhHQjhGYXIzbjIwRDc5Tnoxa1U3R1h3NkcrTUQzZ2RQQUtkdHhNSlFGUUpaRWFLMGJ3QlhnMlNmbXJsODdBSEppMkx3Sm5BWE9WZjN4U3JGY29WQXVEeXpLczR5dzNTTFkyaVRxQkM4QlAzMWliblorQUhKMU1CSWZlSzdxZWFlcW5vOWwyK2c0SVE4NklMcHZvWEljekNNVkFGb2I2Nnd1TFlYQW1jL1BYYi9jQjNueHNSTjdBZGZyWTJNUGUrUGo2Q2p1Zm55azZBYTJYeWZzaExRMjFnbGFyYWUrOE9yc3haM043SkhvajNYZmY5anp4OGpXTjhoYmJkQjZ0T1U1YVhPVmd1TlE5OFlBZm52MStPVEpIWWdBUFR0N3BGWTc2WGsrMmZvNmtpU2c4d0V6TExNcjI1QjMyZW9xam0weDhiNWpwc0J6THg2ZjlMc1FBUkY4RWM3VnExVjBKMENTdU05WkZWeHNyNDd0MVJISHhxN1hzTDA2VnEwNkFFcWJ5NVJMUmVxMTJsRVJ6dmJrRWtDK1ZhdFdLcGFweU50dDZKRVJ3Zlk5RE1kbWRXMk5Pd3NMckNtRGR4WVdXRnBhSW9wamJOL3JhckxMSnc4QzZyVXFJRC82ODJNblRFc1FnSzlYU2lWMG5IUTE3ZzJyVmlXT0k5NXRMUE94Sjg5dzRzeDNzQ3ZkYXJyM3R4bm1mL2ticW5GRTNhdVRycXp1K09rZ3dDNFdjQXV1SDBYUnBCS2hJc0prd2JISk45Zjc5VGNWRzV0YlBIcnVaM3o4cVIvdkFBQSs4UGdwUHZmNzM3RWVodWc4UmJuMmdIUWwxMFdFMDByZ3c3WnRtZHRWc3BNSDJ5S0pZL1RFQkE5OTZZc0RWU3NpbEQvMFFSNzZ5cGZaM0dwaEZncDlBTjNwNEZnbUFwOVVJdUlyUXcyVXBYSmR3aWpHZStTUm9RQUFyVFhlcHo5RkVFYmRmT3p5bHl4SGRkZldMRUVTTGJwYmxydFB0TTRBUWFmSnZnQVJJWThpRE1NWThEY002YTVCUWlVWTk5SThIOWhKSGdTVUhadmx1VmZSYVRvQTJvYmMvOGMvcWJnMmtxVjkvb2FweVBJY3diaW5SS1NSWm5sYjUzbDNSOXZoUmpHV0FZVjJpN2N1WEJ5SUFtQng5bCtzejh4UUs3amtXMXY5RUtWSTBoUVJ1V3QrOWRqN0JmaHMwVlNmS0ZaSzZDRG9xL2xLdWNUeWE2OXgvK1k4cFdQSGNNZDhOdThzOE03bEY1ai94YStaS0JWd1RkV0ZiUHNaQm1heHdHSXJJTlA2SjhiemozNEc0R1RaY2Y3K2tYcUZ0Tm5zNzdTbE1tYTV4RWFVc0JiR2hGbUdZNXJVWEJ1LzZHSXBOZUJqSHozS1JwVHc3bFo3NW1zM2J6eHVkUVhnNVhhU3pMYmpaTEk4TmthMnNyTHJZTFdScUVQZEg2UHUybjBmMDUwT2FSRDBsNTR5UUlTMU1FTGc1d0RiRUlCZnJZYlJDeFczTXZEZmtFeVRMaStOYXZqZEtNWW4ySXhpMm1uMjhqZHUzbmlsMXlDRm5sM1ppTk8zb3pqdE5iNUR0UGloYlYrejJva1JrZlBEV24wdU1MVVN4aGltOVo0QWx1ZlJUaEsyMHV6R045LzQ5OHdPaE4wSFVmU2xsU2h1Wm5tT0toWFo4MjZrR1liQlNpY0cwZWQzUzdnN0VnUkNnYWViWVl4Wkx2Vy9HV0dXNzlISk05YlQ3TGJBbi9vaC84L0p0azB2Umttb3RVWTV6cUdsTXBTaTJjdkZ0K2Rmei9kRVlyREhtb0x4aDVVd3hqeHk1RkFBczFvbHluSldVbjFYTUo3ZFczRktHSHBOM1kyeVhFUXdURFZTS3VVNk5LTUVRYWErKyticnlTQmtVQzVFNUxhSVhGMkxFMHpmUjdUZTExU3BSSkxsTkpLOEtTTFBERHM3Nm9BOVRpM0grVWlwVkxISVVwZ2djT0Y3YjczUkhnNFpIZ2tpY20wcjE3T3RMTWM2T2o1Y3BuS0pYQXYzVTkwV2tlbjl1b0FhVVp6VFMxR0dJUXhQZUxGRUkwNFJ1UGprcmZuTjl3cTV2S0o1T3hUQnJOYjJKTnRGRlB3M2xVUmc2cUIrZHBCY2lFZ3VJdE9OT0VPNXprRFpMb1lwSW5McEI3Zm1Hd2REUnAvblM0c1p6VlFFVlM2RENJWmpJeUlzcE9RQzV4a3gxTzYvNEQ3V1J1VHBScFJobGtyZFJsaXJzeFJuSVBMOEQvL3o1cDJSa0gwTzQ5N3J3dDJjUkJCVXdRV0V4VndRWkdRVVBjaEFXeGxtRGNHNDFFZzBacTFHTTlFRW9xNEt4dnloSUEvUWFhY1hzKzV6NzM2K08zK1lTRWFtWk1kdUJhS3VORk5oVTlRMUVWNlJ3ekVPblpPZHhuay83ZVppZSthUWNqM1F1TGFKZWdaNDZVR2MvZ2NVZVR0ekRnL280d0FBQUNWMFJWaDBaR0YwWlRwamNtVmhkR1VBTWpBeE1pMHdPQzB4T0ZReE5EbzFNRG8xTmlzd01Ub3dNQlpRcEY4QUFBQWxkRVZZZEdSaGRHVTZiVzlrYVdaNUFESXdNVEl0TURndE1UaFVNVFE2TlRBNk5UWXJNREU2TURCbkRSempBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUFCSlJVNUVya0pnZ2c9PVwiLFxuICAgICAgICAgICAgZ3JlZW4gOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFaaVMwZEVBUDhBL3dEL29MMm5rd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBZDBTVTFGQjl3SkNnb0REZ3FIRC9NQUFBWlZTVVJCVkZqRHBaWnRpRnhYR2NkL2MrNjlNN1B6dXJ2ZFRUWk5HdnhRVENKcUZTb2srTW1GUVBTRFVsc1FoQmF4V05ob3JRbFdQeFNLVFlxc0ZMWUdBOFZDSVNERVNJcENJTFlRVzR4Sk50SEdHQm9vWnRsMTZVcktOck12TTdOM1h1NjU1NXpIRDdPWjdPenNXL0JlL25Cbnpubk8venpQODMvT2N4S1B2L0lPVzMyS1h6ajJLRkJjL25tN2N1dmw4SU9YRDIxcWwzajhsVDl2c09qeGZ1Qjd3Q0hnb0FvVUNWOEJZSnNXUkdhQmM4RHB2end4Zm5GOWtsOTBreFErZjl3RFhnUmV5ZzlrYzhWa0g0V2cyRFV2ZHBxeVhxUmNLeE9INWwzZ1orODlPWDVyRFpMenF3aGU3UWZPWkFjeUI0ZlNPMGg2S2JTTnFOdDZGMGxTSmNuNFdRQStiY3l5Y0hlaEFUenozcFBqYjYrY3AwU0VlOGp2T2RZdnNSdlBEbVFPUHBMWmpSWExZalJQellTSXVDNUV0c2xpTkU5Wkw3SXR2WTJkRCsvc1NSYURzOE5uOW85MGtMUTkySHZjQTg3bWR1VDI3TXc4UWlXdVVETWhWdXltTUM1bVBwb2o0MlVZeXUwQStNM3dtZjNEOTBsRVFBVGd4ZlQyOVBERFBUdXA2akt4MDhnYXI2K0NOZjhYaEVXOVFFcWxHTncxNkFGbmhzL3M3MitGQzZHdzc5Vis0S1h0UFVQVWJaM0lSUjA3RFZTU1FsQ2tFQlJSQ2RYK3p2bjVMcS9tb2hLRm9FaDJLRE80TEI0VUxVZStteHBJNVJTS01BNXhJbTBVZzE2U0tza25qVHRNZlR4RkdJZE1mVHpGek9JTW9WbWlHUFFDZE5qVVRZM0I5SFpFZU81cnY5L3YrWWdnd25jSzZRS3h4QjNxeVFVNWFpYms3aWNsdnYzWVV6ejkxV2ZKK3dVQUxzeSt3K3NmL29wR3VzRmdhaHVMZXJGdDE3Qk4wbDRQUWM3djEwdm1nSi9mOThzY2NDRGpaNW1QNWpwSXZJVEhZbGptK1FOSCtOYXVwenJHRGc1OW5jL205L0tEQzA4VEQ4VUV5cWRoRysxeGg4UFArZWdsYzBqaFpMZVhVcDRWMnlGUFB4RlFOeld5bVd3WEFZQWc3TTUraG0vcyt5Wnp6UklwTDkxaFh6YzFraW9BSjU5VFFIOUMzV09YTmxKZWl0Q0VmTEgzUzJzU0FGZ3hQTmI3WlhRbDdySjNJaVJhQ3hkOWNhTEZnWFVHY2RKZXlEaURpS0JkdEM2QkU2RmhHeWd2MFdVdm5zT0tSWncwRkhESFJnNkhkQ3pXdEhYeVFaNGJuMTdIckJLRUZkTmFBTWVsMGwveGN6NVdiT2Q1aGNJNEEzQkhpV1BXYVJlS3VOWU9qRU9NdzJoRGdnUXVkcHljZUwzREM5Y3FYc1pMbDdnKzlROEtRWUVsczlTMkZlUHdFZ3Jic0loanh1dmIrMnRKRFl4L1JYSnVYemJJMGRSUit4Qnd5cER0eVhMcnZ4OXlMYnpDOXZSMkhrb084Sjl3a3JNenAvbnQrQnYwREtid1ZVQ2owVnh4ZUVBUUpLbmVEUkVyei9zaUFrNU9OdWVpSnpJN01yQWlycm9lNHpKQzcwTkZwaGVtK1Bua1VXemtVSDZDWkc5QTM2NGlYc0tqdWxUcHJLOThucVY2RmRlMEYvNzIvUTgrOGhHaDh1K2Z2bC9ZODlyVlduL3RRRGFYSTZ3dTNlOFpZWXp4TGZsc2pseW1VMlVOMnlBTzR6VWJWWE5lSXlMSEFIenVKL3cxWFk3L21ON21XS1VCSkhaVXk5VXR0ZWhzTVV0WUQ3RU44LzZsWjY5ZkJtaUZDeERMdVdoQlQwYjkwYU4rem05ci8wRWZFZGZ5d2pMYWRkUlhKNDVhWUN4YTBQaktwNTNGQjBDcU4wbXpHV0ZDODgvTHoxMi9zS0l6cnBqbjVGUnpMaW9aWi9CNmZNVHhRRkFraUJZMDRtUzBzek91WUtsT0hHMGc4bWF6Rk9HbEZHSmx5MGptZlhROVJwZjFiVVQrdEc2UFg4N1BpV2crYWlEZ3BieVdwTGVBUktDSXlqSEE2SldSRzNaVmp4ZFdvakp4cEFUOHJqa1g0V2U5TFNVN0tBVFloaVd1NkJuZzlPcHh0VllDeFRIV0xFWDJYbUU2dHpHVW55QXF4NGhqN01ySURkMUZzanBjSWtKbDRvWGJZdVc4cmhxU2ZVa2tkdXZDU3ltc2RrUnpVVW1zdkxXV3AybzlPWXFUc1doUmI2cGNQK3VqeXpIaTVPVFZILzhyWEpOa0xVOUVoT3JVQ3hkTnpWdzFOVU42SUxsbXN2Mk1oeGhIY3k0S2dSUHI1YXdyOFozZ2hDN3I1VXJ1M29pZjhZZ1dOTUFiMTM1eXM3SSt5WWJ4NE8yNGFpWnQ1RWoySmpzdkdTa1BCS0o1clJIR05sTGZ1dUVTRVNxVFA3SWlMVytVcnhCTEcwRSthRlczY09yYWtadXpHNUpzSEM0Qk9LVXJwdVJNNjRvalRsQitBaEdoT2E4dE1McFpIYW5OMUZPWi9HRUl2QmxYWXZ3ZUJTSWsrd0owcTdyLzhQZWpONmMzSmRuU0NldmtaTFNndGRoV0xzU0JMbXRZZFJEK0grRVNLbE9IWjhYSnFiZ2FFeFFDNGlXRDArNThaZXJ3cmEyUmJNN0I4cVg4aEs3RWlCTjBXU1BDNk9vT3VuNU8yTnBiblQ3OGtkWHVuS2xiYk9RdVZxY1BYNVl0c3FnSDYzNk02YklHWWJUai9yTjVUcmIrVktkSEx0cW1lNnM2UGZMdWc5ajlEL0ZDYzFnMnFmN1ZBQUFBQUVsRlRrU3VRbUNDXCJcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb25zdHJ1Y3RvclxuICAgICAqIChleHRlbmQgdG8gTC5JY29uLkRlZmF1bHQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgLSBibHVlLCBncmVlbiBvciByZWQsIGJsdWUgYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2YgTC5JY29uXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICAvLyBvbiBtZXJnZSBsZXMgb3B0aW9ucyBhdmVjIGNlbGxlcyBwYXIgZGVmYXV0XG4gICAgICAgIEwuVXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgX2NvbG9yID0gbnVsbDtcbiAgICAgICAgdmFyIF9pbWFnZXMgPSAvKiAoTC5Ccm93c2VyLnJldGluYSkgPyB0aGlzLmltYWdlcy5yZXRpbmEgOiAqLyB0aGlzLmltYWdlcztcbiAgICAgICAgc3dpdGNoIChjb2xvcikge1xuICAgICAgICAgICAgY2FzZSBcInJlZFwiOlxuICAgICAgICAgICAgICAgIF9jb2xvciA9IF9pbWFnZXMuY29sb3IucmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdyZWVuXCI6XG4gICAgICAgICAgICAgICAgX2NvbG9yID0gX2ltYWdlcy5jb2xvci5ncmVlbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcmFuZ2VcIjpcbiAgICAgICAgICAgICAgICBfY29sb3IgPSBfaW1hZ2VzLmNvbG9yLm9yYW5nZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJibHVlXCI6XG4gICAgICAgICAgICAgICAgX2NvbG9yID0gX2ltYWdlcy5jb2xvci5ibHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfY29sb3IgPSBfaW1hZ2VzLmNvbG9yLmJsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpY29uZXMgY2xhc3NpcXVlc1xuICAgICAgICB0aGlzLm9wdGlvbnMuaWNvblVybCA9IF9jb2xvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNoYWRvd1VybCA9IF9pbWFnZXMuc2hhZG93O1xuXG4gICAgICAgIC8vIGljb25lcyBwb3VyIMOpY3JhbiBSZXRpbmFcbiAgICAgICAgaWYgKEwuQnJvd3Nlci5yZXRpbmEpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pY29uUmV0aW5hVXJsID0gX2NvbG9yO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNoYWRvd1JldGluYVVybCA9IF9pbWFnZXMuc2hhZG93O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkIGZ1bmN0aW9uIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IGJldHdlZW4gdmVyc2lvbnMgMC43LlggYW5kIDEuMC5YXG4gICAgICogKGV4dGVuZCB0byBMLkljb24uX2dldEljb25VcmwpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAqXG4gICAgICovXG4gICAgX2dldEljb25VcmwgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJPVkVSV1JJVFRFTiBMLkljb24uRGVmYXVsdC5fZ2V0SWNvblVybChcIiArIG5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiBMLkljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEljb25EZWZhdWx0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Leaflet/Controls/Utils/IconDefault.js\n");

/***/ }),

/***/ "leaflet":
/*!********************!*\
  !*** external "L" ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = L;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwgXCJMXCI/ZmEyYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJsZWFmbGV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBMOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///leaflet\n");

/***/ }),

/***/ "node-fetch":
/*!***********************************************************************************!*\
  !*** external {"commonjs2":"node-fetch","commonjs":"node-fetch","amd":"require"} ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = undefined;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJub2RlLWZldGNoXCIsXCJjb21tb25qc1wiOlwibm9kZS1mZXRjaFwiLFwiYW1kXCI6XCJyZXF1aXJlXCJ9P2FiYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoibm9kZS1mZXRjaC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///node-fetch\n");

/***/ }),

/***/ "xmldom":
/*!***************************************************************************!*\
  !*** external {"commonjs2":"xmldom","commonjs":"xmldom","amd":"require"} ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = undefined;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJ4bWxkb21cIixcImNvbW1vbmpzXCI6XCJ4bWxkb21cIixcImFtZFwiOlwicmVxdWlyZVwifT9hNmJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InhtbGRvbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///xmldom\n");

/***/ })

/******/ })["default"];