/*!
 * @brief French Geoportal Extension for Leaflet
 *
 * This software is released under the licence CeCILL-B (Free BSD compatible)
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt
 * @see http://www.cecill.info/
 *
 * @copyright copyright (c) IGN 
 * @license CeCILL-B
 * @author IGN
 * @version 2.2.7
 * @date 18/11/2022
 *
 */

ElevationPath =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Leaflet/Controls/ElevationPath.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcz8xMzY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLFNBQytCO0FBQ2hDLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMseUNBQXlDLFVBQWM7QUFDeEQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgdjQuMi44KzFlNjhkY2U2XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB4O1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cblxuXG52YXIgX2lzQXJyYXkgPSB2b2lkIDA7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdm9pZCAwO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdm9pZCAwO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZlcnR4ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKS5yZXF1aXJlKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB2b2lkIDA7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cblxuICBpZiAoX3N0YXRlKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciB0aGVuJCQxID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICB0aGVuJCQxID0gdmFsdWUudGhlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgdGhlbiQkMSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdm9pZCAwLFxuICAgICAgZXJyb3IgPSB2b2lkIDAsXG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzdWNjZWVkZWQgPT09IGZhbHNlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG52YXIgRW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gICAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgIH1cbiAgfVxuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiBfZW51bWVyYXRlKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIF9lYWNoRW50cnkoZW50cnksIGkpIHtcbiAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cblxuICAgIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICAgIHZhciBfdGhlbiA9IHZvaWQgMDtcbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoZW4gPSBlbnRyeS50aGVuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0oKTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZS50aGVuID0gdGhlbjtcblByb21pc2UkMS5hbGwgPSBhbGw7XG5Qcm9taXNlJDEucmFjZSA9IHJhY2U7XG5Qcm9taXNlJDEucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMS5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQxLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMS5fYXNhcCA9IGFzYXA7XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICBpZiAoUCkge1xuICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cbnJldHVybiBQcm9taXNlJDE7XG5cbn0pKSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es6-promise/dist/es6-promise.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/package.json":
/*!********************************************************!*\
  !*** ./node_modules/geoportal-access-lib/package.json ***!
  \********************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, date, dependencies, deprecated, description, devDependencies, homepage, keywords, license, main, module, name, nyc, optionalDependencies, peerDependencies, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"_id\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-914Yk0C3mnYI+X56Y40t4OJwBiZ1nEbW8D9Dse4WcS54Au8ZpkZ9Ep1efNYMxC5618zqn7r4VvzF58Xa+BqzEQ==\\\",\\\"_location\\\":\\\"/geoportal-access-lib\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"name\\\":\\\"geoportal-access-lib\\\",\\\"escapedName\\\":\\\"geoportal-access-lib\\\",\\\"rawSpec\\\":\\\"3.2.0\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"3.2.0\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/geoportal-access-lib/-/geoportal-access-lib-3.2.0.tgz\\\",\\\"_shasum\\\":\\\"7a707b75743f01b5465cc72d1316f13f8b87df7a\\\",\\\"_spec\\\":\\\"geoportal-access-lib@3.2.0\\\",\\\"_where\\\":\\\"/home/JPBazonnais/Projets/API/geoportal-extensions\\\",\\\"author\\\":{\\\"name\\\":\\\"IGNF\\\"},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/IGNF/geoportal-access-lib/issues\\\"},\\\"bundleDependencies\\\":false,\\\"date\\\":\\\"04/10/2022\\\",\\\"dependencies\\\":{\\\"es6-promise\\\":\\\"^4.2.4\\\",\\\"node-fetch\\\":\\\"^2.6.1\\\",\\\"xmldom\\\":\\\"^0.1.27\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"French Geoportal resources access library\\\",\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.12.10\\\",\\\"@babel/plugin-transform-template-literals\\\":\\\"^7.12.1\\\",\\\"@babel/preset-env\\\":\\\"^7.12.11\\\",\\\"babel-loader\\\":\\\"^8.2.2\\\",\\\"chai\\\":\\\"^4.1.2\\\",\\\"clean-webpack-plugin\\\":\\\"^3.0.0\\\",\\\"copy-webpack-plugin\\\":\\\"^5.1.2\\\",\\\"eslint\\\":\\\"^7.18.0\\\",\\\"eslint-config-standard\\\":\\\"^16.0.2\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"eslint-plugin-import\\\":\\\"^2.22.1\\\",\\\"eslint-plugin-node\\\":\\\"^11.1.0\\\",\\\"eslint-plugin-promise\\\":\\\"^4.2.1\\\",\\\"eslint-plugin-standard\\\":\\\"^5.0.0\\\",\\\"glob\\\":\\\"^7.1.2\\\",\\\"handlebars-layouts\\\":\\\"^3.1.4\\\",\\\"handlebars-webpack-plugin\\\":\\\"^1.4.1\\\",\\\"html-webpack-plugin\\\":\\\"^4.5.1\\\",\\\"istanbul-instrumenter-loader\\\":\\\"^3.0.1\\\",\\\"jsdoc-webpack-plugin\\\":\\\"^0.3.0\\\",\\\"loglevel\\\":\\\"^1.6.1\\\",\\\"mocha\\\":\\\"^7.2.0\\\",\\\"mocha-loader\\\":\\\"^5.1.5\\\",\\\"mocha-webpack\\\":\\\"^2.0.0-beta.0\\\",\\\"mochawesome\\\":\\\"^6.2.1\\\",\\\"nyc\\\":\\\"^15.1.0\\\",\\\"path\\\":\\\"^0.12.7\\\",\\\"replace-bundle-webpack-plugin\\\":\\\"^1.0.0\\\",\\\"sinon\\\":\\\"^9.2.4\\\",\\\"sinon-es6\\\":\\\"0.0.3\\\",\\\"speed-measure-webpack-plugin\\\":\\\"^1.4.2\\\",\\\"string-template\\\":\\\"^1.0.0\\\",\\\"terser-webpack-plugin\\\":\\\"^2.3.8\\\",\\\"webpack\\\":\\\"^4.46.0\\\",\\\"webpack-cli\\\":\\\"^3.3.12\\\",\\\"webpack-dev-server\\\":\\\"^3.11.2\\\",\\\"webpack-node-externals\\\":\\\"^2.5.2\\\",\\\"webpack-shell-plugin\\\":\\\"^0.5.0\\\"},\\\"homepage\\\":\\\"https://github.com/IGNF/geoportal-access-lib#readme\\\",\\\"keywords\\\":[\\\"geoportail\\\",\\\"webservice\\\",\\\"javascript\\\",\\\"es6\\\"],\\\"license\\\":\\\"CECILL-B\\\",\\\"main\\\":\\\"dist/GpServices-src.js\\\",\\\"module\\\":\\\"src/Gp.js\\\",\\\"name\\\":\\\"geoportal-access-lib\\\",\\\"nyc\\\":{\\\"include\\\":[\\\"src/**/*.js\\\"],\\\"instrument\\\":false,\\\"sourceMap\\\":false},\\\"optionalDependencies\\\":{},\\\"peerDependencies\\\":{},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/IGNF/geoportal-access-lib.git\\\"},\\\"scripts\\\":{\\\"build\\\":\\\"webpack --mode=none\\\",\\\"build:dev\\\":\\\"webpack --mode=development\\\",\\\"build:prod\\\":\\\"webpack --mode=production\\\",\\\"clean\\\":\\\"echo \\\\\\\"Warning: no yet implemented!\\\\\\\" && exit 0\\\",\\\"cover\\\":\\\"nyc --reporter=lcov --reporter=text npm run test\\\",\\\"doc\\\":\\\"npm run doc:serve\\\",\\\"doc:serve\\\":\\\"webpack-dev-server --content-base jsdoc --port 9001 --open\\\",\\\"eslint\\\":\\\"eslint src/\\\",\\\"sample\\\":\\\"npm run sample:serve\\\",\\\"sample:serve\\\":\\\"webpack-dev-server --mode=none --open-page samples/index-src.html --https --content-base . --output-public-path '/dist/' --port 9001 --open\\\",\\\"sample:serve:dev\\\":\\\"webpack-dev-server --mode=development --open-page samples/index-map.html --content-base . --output-public-path '/dist/' --port 9001 --open\\\",\\\"sample:serve:prod\\\":\\\"webpack-dev-server --mode=production --open-page samples/index-prod.html --content-base . --output-public-path '/dist/' --port 9001 --open\\\",\\\"setup\\\":\\\"npm install\\\",\\\"test\\\":\\\"mocha-webpack --reporter mochawesome --reporter-options reportDir=test-report,reportFilename=index --webpack-config ./test/webpack/webpack.test.js --glob \\\\\\\"test_*.js\\\\\\\" test/spec/\\\",\\\"test:end-to-end:serve\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.js\\\",\\\"test:end-to-end:serve:docker\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.docker.js\\\",\\\"test:serve\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.js\\\",\\\"test:serve:docker\\\":\\\"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.docker.js\\\"},\\\"version\\\":\\\"3.2.0\\\"}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9wYWNrYWdlLmpzb24uanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/package.json\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js":
/*!**************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Errors raised by API for one among three reasons : wrong API usage, underlying service error or unknown reason.\n *\n * @property {String} message - Error message\n * @property {Number} status - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} ; -1 otherwise.\n * @property {String} type - Error type ({@link Gp.Error.TYPE_SRVERR}, {@link Gp.Error.TYPE_USEERR} or {@link Gp.Error.TYPE_UNKERR}).\n *\n * @namespace\n * @alias Gp.Error\n * @param {Object|String} error - Options for creating error object. Can be a String (message) or an Object.\n * @param {String} error.message - Error message to return to user.\n * @param {enum} [error.type=TYPE_UNKERR] - Error type\n * @param {status} [error.status=-1] - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}.\n *\n */\nfunction ErrorService (error) {\n    if (!(this instanceof ErrorService)) {\n        throw new TypeError(\"ErrorService constructor cannot be called as a function.\");\n    }\n\n    var e = error;\n    if (typeof error === \"string\" || error instanceof String) {\n        this.message = error;\n        this.status = -1;\n        this.type = ErrorService.TYPE_UNKERR;\n    } else {\n        this.message = e.message || \"undefined!?\";\n        this.type = e.type;\n        this.status = e.status || -1;\n    }\n\n    this.name = \"ErrorService\";\n    this.stack = (new Error()).stack;\n}\n\n/**\n * Error raised when underlying geoportal service answers on error.\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_SRVERR = \"SERVICE_ERROR\";\n/**\n * Error raised when funcion use is inappropriate\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_USEERR = \"USAGE_ERROR\";\n/**\n * Error raised when API can't perform the job for a reason other than the two other ones.\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_UNKERR = \"UNKNOWN_ERROR\";\n\n/**\n * @lends module:ErrorService\n */\nErrorService.prototype = Object.create(Error.prototype, {\n    constructor : {\n        value : ErrorService,\n        writable : true,\n        configurable : true\n    }\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ErrorService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL0V4Y2VwdGlvbnMvRXJyb3JTZXJ2aWNlLmpzPzg0YmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPLCtCQUErQiwyQkFBMkIsaUVBQWlFLDhEQUE4RCxFQUFFO0FBQ2hOLGNBQWMsT0FBTyxxQkFBcUIsMkJBQTJCLEdBQUcsMkJBQTJCLEtBQUssMkJBQTJCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTywwQ0FBMEMsMkJBQTJCLGlFQUFpRSw4REFBOEQ7QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVjLDJFQUFZLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL0V4Y2VwdGlvbnMvRXJyb3JTZXJ2aWNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFcnJvcnMgcmFpc2VkIGJ5IEFQSSBmb3Igb25lIGFtb25nIHRocmVlIHJlYXNvbnMgOiB3cm9uZyBBUEkgdXNhZ2UsIHVuZGVybHlpbmcgc2VydmljZSBlcnJvciBvciB1bmtub3duIHJlYXNvbi5cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGF0dXMgLSBFcnJvciBzdGF0dXMgOiB3aGVuIHtAbGluayBHcC5FcnJvci5UWVBFX1NSVkVSUn0sIGdpdmVzIHRoZSBbSFRUUCBzdGF0dXMgb2YgdGhlIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UgcmVzcG9uc2Vde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfSFRUUF9zdGF0dXNfY29kZXN9IDsgLTEgb3RoZXJ3aXNlLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgLSBFcnJvciB0eXBlICh7QGxpbmsgR3AuRXJyb3IuVFlQRV9TUlZFUlJ9LCB7QGxpbmsgR3AuRXJyb3IuVFlQRV9VU0VFUlJ9IG9yIHtAbGluayBHcC5FcnJvci5UWVBFX1VOS0VSUn0pLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5FcnJvclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBlcnJvciAtIE9wdGlvbnMgZm9yIGNyZWF0aW5nIGVycm9yIG9iamVjdC4gQ2FuIGJlIGEgU3RyaW5nIChtZXNzYWdlKSBvciBhbiBPYmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gZXJyb3IubWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gcmV0dXJuIHRvIHVzZXIuXG4gKiBAcGFyYW0ge2VudW19IFtlcnJvci50eXBlPVRZUEVfVU5LRVJSXSAtIEVycm9yIHR5cGVcbiAqIEBwYXJhbSB7c3RhdHVzfSBbZXJyb3Iuc3RhdHVzPS0xXSAtIEVycm9yIHN0YXR1cyA6IHdoZW4ge0BsaW5rIEdwLkVycm9yLlRZUEVfU1JWRVJSfSwgZ2l2ZXMgdGhlIFtIVFRQIHN0YXR1cyBvZiB0aGUgdW5kZXJseWluZyB3ZWIgc2VydmljZSByZXNwb25zZV17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9IVFRQX3N0YXR1c19jb2Rlc30uXG4gKlxuICovXG5mdW5jdGlvbiBFcnJvclNlcnZpY2UgKGVycm9yKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVycm9yU2VydmljZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVycm9yU2VydmljZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBlID0gZXJyb3I7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiB8fCBlcnJvciBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAtMTtcbiAgICAgICAgdGhpcy50eXBlID0gRXJyb3JTZXJ2aWNlLlRZUEVfVU5LRVJSO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZSB8fCBcInVuZGVmaW5lZCE/XCI7XG4gICAgICAgIHRoaXMudHlwZSA9IGUudHlwZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBlLnN0YXR1cyB8fCAtMTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSBcIkVycm9yU2VydmljZVwiO1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xufVxuXG4vKipcbiAqIEVycm9yIHJhaXNlZCB3aGVuIHVuZGVybHlpbmcgZ2VvcG9ydGFsIHNlcnZpY2UgYW5zd2VycyBvbiBlcnJvci5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGNvbnN0YW50XG4gKiBAc3RhdGljXG4gKi9cbkVycm9yU2VydmljZS5UWVBFX1NSVkVSUiA9IFwiU0VSVklDRV9FUlJPUlwiO1xuLyoqXG4gKiBFcnJvciByYWlzZWQgd2hlbiBmdW5jaW9uIHVzZSBpcyBpbmFwcHJvcHJpYXRlXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBjb25zdGFudFxuICogQHN0YXRpY1xuICovXG5FcnJvclNlcnZpY2UuVFlQRV9VU0VFUlIgPSBcIlVTQUdFX0VSUk9SXCI7XG4vKipcbiAqIEVycm9yIHJhaXNlZCB3aGVuIEFQSSBjYW4ndCBwZXJmb3JtIHRoZSBqb2IgZm9yIGEgcmVhc29uIG90aGVyIHRoYW4gdGhlIHR3byBvdGhlciBvbmVzLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqL1xuRXJyb3JTZXJ2aWNlLlRZUEVfVU5LRVJSID0gXCJVTktOT1dOX0VSUk9SXCI7XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpFcnJvclNlcnZpY2VcbiAqL1xuRXJyb3JTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3IgOiB7XG4gICAgICAgIHZhbHVlIDogRXJyb3JTZXJ2aWNlLFxuICAgICAgICB3cml0YWJsZSA6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZSA6IHRydWVcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRXJyb3JTZXJ2aWNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Formats/WPS.js":
/*!**************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Formats/WPS.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n\n\n/**\n * @classdesc\n * Standard WPS\n *\n * @constructor\n * @alias Gp.Formats.WPS\n * @param {Object} options - options\n * @param {Object}   options.data - objet\n * @param {String}   options.method - POST|GET\n * @param {String}   options.param.service - \"WPS\"\n * @param {String}   options.param.version - \"1.0.0\"\n * @param {String}   options.param.identifier - \"gs:WPSElevation|gs:WPSLineElevation\"\n * @param {String}   options.param.rawdataoutput - \"result\"\n * @param {String}   options.param.request - \"Execute\"\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n * @private\n */\nfunction WPS (options) {\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger();\n    this.logger.trace(\"[Constructeur WPS()]\");\n\n    if (!(this instanceof WPS)) {\n        throw new TypeError(\"WPS constructor cannot be called as a function.\");\n    }\n\n    this.options = options || {};\n\n    /**\n     * Objet DATA\n     */\n    this.DataObject = this.options.data;\n\n    if (!this.DataObject) {\n        throw new TypeError(\"This data object is not defined !\");\n    }\n\n    /**\n     * param service.\n     * Par defaut, \"WPS\".\n     */\n    this.paramservice = this.options.param.service || \"WPS\";\n\n    /**\n     * param version.\n     * Par defaut, \"1.0.0\".\n     */\n    this.paramversion = this.options.param.version || \"1.0.0\";\n\n    /**\n     * param identifier\n     * Par defaut, \"gs:WPS\"\n     */\n    this.paramidentifier = this.options.param.identifier || \"gs:WPS\";\n\n    /**\n     * param rawdataoutput\n     * Par defaut, \"result\".\n     */\n    this.paramrawdataoutput = this.options.param.rawdataoutput || \"result\";\n\n    /**\n     * param request\n     * Par defaut, \"Execute\".\n     */\n    this.paramrequest = this.options.param.request || \"Execute\";\n\n    /**\n     * methode.\n     * Par defaut, \"GET\".\n     */\n    this.method = this.options.method || \"GET\";\n}\n\nWPS.prototype = {\n\n    /**\n     * @lends module:WPS#\n     */\n\n    /**\n     * request\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : WPS,\n\n    /**\n     * Template de la requête.\n     */\n    template : {\n        get : {\n            value : \"service=__SERVICE__\" +\n                \"&version=__VERSION__\" +\n                \"&rawdataoutput=__RAWDATAOUTPUT__\" +\n                \"&identifier=__IDENTIFIER__\" +\n                \"&request=__REQUEST__\" +\n                \"&datainputs=<!-- __DATAINPUTS__ -->\",\n\n            input : \"__KEY__=__DATA__\"\n\n        },\n        post : {\n\n            value : \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" +\n                \"<wps:__REQUEST__ version=\\\"__VERSION__\\\" service=\\\"__SERVICE__\\\" \" +\n                \"__NAMESPACE__ __SCHEMALOCATION__>\" +\n                \"<ows:Identifier>__IDENTIFIER__</ows:Identifier>\" +\n                \"<wps:DataInputs>\" +\n                \"<!-- __DATAINPUTS__ -->\" +\n                \"</wps:DataInputs>\" +\n                \"<wps:ResponseForm>\" +\n                \"<wps:RawDataOutput>\" +\n                \"<ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>\" +\n                \"</wps:RawDataOutput>\" +\n                \"</wps:ResponseForm>\" +\n                \"</wps:__REQUEST__>\",\n\n            input : \"<wps:Input>\" +\n                \"<ows:Identifier>__KEY__</ows:Identifier>\" +\n                \"<wps:Data>\" +\n                \"<wps:LiteralData>__DATA__</wps:LiteralData>\" +\n                \"</wps:Data>\" +\n                \"</wps:Input>\"\n        }\n    },\n\n    /**\n     * Namespace par defaut de la requete POST.\n     *\n     * @returns {String} namespace\n     */\n    namespaceByDefault : function () {\n        var ns = [\n            \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\",\n            \"xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\"\",\n            \"xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\",\n            \"xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\"\",\n            \"xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\"\",\n            \"xmlns:gml=\\\"http://www.opengis.net/gml\\\"\",\n            \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\"\",\n            \"xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\"\",\n            \"xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\"\n        ];\n\n        return ns.join(\" \");\n    },\n\n    /**\n     * Schemalocation par defaut.\n     *\n     * @returns {String} schemaLocation\n     */\n    schemaLocationByDefault : function () {\n        return \"xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\"\";\n    },\n\n    /**\n     * Construction de la requête.\n     *\n     * @example\n     * // GET  out :\n     * //  service=__SERVICE__\n     * //  &version=__VERSION__\n     * //  &rawdataoutput=__RAWDATAOUTPUT__\n     * //  &identifier=__IDENTIFIER__\n     * //  &request=__REQUEST__\n     * //  &datainputs=\"__DATAINPUTS__\"\n     * //  avec __DATAINPUTS__ = __KEY__=__DATA__;...\n     *\n     * // POST out :\n     * //      <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n     * //      <wps:__REQUEST__ version=\\\"__VERSION__\\\" service=\\\"__SERVICE__\\\"\n     * //         __NAMESPACE__ __SCHEMALOCATION__>\n     * //          <ows:Identifier>__IDENTIFIER__</ows:Identifier>\n     * //          <wps:DataInputs>\n     * //              <!-- __DATAINPUTS__ -->\n     * //          </wps:DataInputs>\n     * //          <wps:ResponseForm>\n     * //              <wps:RawDataOutput>\n     * //              <ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>\n     * //              </wps:RawDataOutput>\n     * //          </wps:ResponseForm>\n     * //      </wps:__REQUEST__>\",\n     * //      avec __DATAINPUTS__\n     * //             <wps:Input>\n     * //                  <ows:Identifier>__KEY__</ows:Identifier>\n     * //                  <wps:Data>\n     * //                    <wps:LiteralData>__DATA__</wps:LiteralData>\n     * //                  </wps:Data>\n     * //              </wps:Input>\n     *\n     * @returns {Boolean} validation de la construction de la requete\n     */\n    processRequestString : function () {\n        this.logger.trace(\"WPS::processRequestString ()\");\n\n        var template = \"\";\n        if (this.method === \"POST\") {\n            template = this.template.post.value;\n        } else if (this.method === \"GET\") {\n            template = this.template.get.value;\n        } else {\n            this.logger.error(\"No other method supported by the service !\");\n            return false;\n        }\n\n        template = template.replace(/__SERVICE__/g, this.paramservice);\n        template = template.replace(/__VERSION__/g, this.paramversion);\n        template = template.replace(/__RAWDATAOUTPUT__/g, this.paramrawdataoutput);\n        template = template.replace(/__IDENTIFIER__/g, this.paramidentifier);\n        template = template.replace(/__REQUEST__/g, this.paramrequest);\n\n        // ajout +\n        if (this.method === \"POST\") {\n            template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);\n            template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);\n        }\n\n        // ajout des datainputs\n        template = template.replace(/<!-- __DATAINPUTS__ -->/g, this.__addDataInputs());\n\n        if (!template) {\n            this.logger.warn(\"traduction tmpl : empty request !?\");\n            return false;\n        }\n\n        this.requestString = template;\n        this.logger.trace(\"traduction tmpl\", template);\n\n        return true;\n    },\n\n    /**\n     * Ajout des données\n     *\n     * @returns {String} Données concaténées dans une chaine\n     */\n    __addDataInputs : function () {\n        this.logger.trace(\"WPS::__addDataInputs ()\");\n\n        // c'est un peu grossier...\n        var tmpl = this.method === \"GET\" ? this.template.get.input : this.template.post.input;\n        var sep = this.method === \"GET\" ? \";\" : \"\";\n\n        var result = \"\";\n        var that = this;\n        var map = this.DataObject.getData();\n        for (var i = 0; i < map.length; i++) {\n            // FIXME closure ?\n            (function (j) {\n                if (sep) {\n                    sep = (j === map.length - 1) ? \"\" : \";\";\n                }\n                result = result.concat(that.__addDataInput(tmpl, map[j].k, map[j].v), sep);\n            })(i);\n        }\n\n        return result;\n    },\n\n    /**\n     * Ajout d'une donnée.\n     *\n     * @param {String} tmpl - template\n     * @param {String} key - clef\n     * @param {String} data - valeur\n     * @returns {String} chaine avec les substitutions clef/valeur\n     */\n    __addDataInput : function (tmpl, key, data) {\n        var tmp = tmpl;\n        tmp = tmp.replace(/__KEY__/g, key);\n        tmp = tmp.replace(/__DATA__/g, data);\n        return tmp;\n    },\n\n    /**\n     * Definir le mode de requête\n     *\n     * @param {String} method - GET|POST\n     */\n    setMethod : function (method) {\n        if (method === \"GET\" || method === \"POST\") {\n            this.method = method;\n        } else {\n            this.logger.warn(\"support only GET and POST method !\");\n        }\n    },\n\n    /**\n     * Retourne le mode de requete (GET|POST).\n     *\n     * @returns {AltiRequest.options.mode|String} methode (GET|POST)\n     */\n    getMethod : function () {\n        return this.method;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (WPS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL0Zvcm1hdHMvV1BTLmpzPzIyMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBTTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxrRUFBRyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2dlb3BvcnRhbC1hY2Nlc3MtbGliL3NyYy9Gb3JtYXRzL1dQUy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFN0YW5kYXJkIFdQU1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLkZvcm1hdHMuV1BTXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMuZGF0YSAtIG9iamV0XG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLm1ldGhvZCAtIFBPU1R8R0VUXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLnNlcnZpY2UgLSBcIldQU1wiXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLnZlcnNpb24gLSBcIjEuMC4wXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucGFyYW0uaWRlbnRpZmllciAtIFwiZ3M6V1BTRWxldmF0aW9ufGdzOldQU0xpbmVFbGV2YXRpb25cIlxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5wYXJhbS5yYXdkYXRhb3V0cHV0IC0gXCJyZXN1bHRcIlxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5wYXJhbS5yZXF1ZXN0IC0gXCJFeGVjdXRlXCJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25zdWNjZXNzIC0gZnVuY3Rpb24gY2FsbGJhY2sgc3VjY2VzcyAoVE9ETylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25lcnJvciAgIC0gZnVuY3Rpb24gY2FsbGJhY2sgZXJyb3IgICAoVE9ETylcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFdQUyAob3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBXUFMoKV1cIik7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV1BTKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiV1BTIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIE9iamV0IERBVEFcbiAgICAgKi9cbiAgICB0aGlzLkRhdGFPYmplY3QgPSB0aGlzLm9wdGlvbnMuZGF0YTtcblxuICAgIGlmICghdGhpcy5EYXRhT2JqZWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIGRhdGEgb2JqZWN0IGlzIG5vdCBkZWZpbmVkICFcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGFyYW0gc2VydmljZS5cbiAgICAgKiBQYXIgZGVmYXV0LCBcIldQU1wiLlxuICAgICAqL1xuICAgIHRoaXMucGFyYW1zZXJ2aWNlID0gdGhpcy5vcHRpb25zLnBhcmFtLnNlcnZpY2UgfHwgXCJXUFNcIjtcblxuICAgIC8qKlxuICAgICAqIHBhcmFtIHZlcnNpb24uXG4gICAgICogUGFyIGRlZmF1dCwgXCIxLjAuMFwiLlxuICAgICAqL1xuICAgIHRoaXMucGFyYW12ZXJzaW9uID0gdGhpcy5vcHRpb25zLnBhcmFtLnZlcnNpb24gfHwgXCIxLjAuMFwiO1xuXG4gICAgLyoqXG4gICAgICogcGFyYW0gaWRlbnRpZmllclxuICAgICAqIFBhciBkZWZhdXQsIFwiZ3M6V1BTXCJcbiAgICAgKi9cbiAgICB0aGlzLnBhcmFtaWRlbnRpZmllciA9IHRoaXMub3B0aW9ucy5wYXJhbS5pZGVudGlmaWVyIHx8IFwiZ3M6V1BTXCI7XG5cbiAgICAvKipcbiAgICAgKiBwYXJhbSByYXdkYXRhb3V0cHV0XG4gICAgICogUGFyIGRlZmF1dCwgXCJyZXN1bHRcIi5cbiAgICAgKi9cbiAgICB0aGlzLnBhcmFtcmF3ZGF0YW91dHB1dCA9IHRoaXMub3B0aW9ucy5wYXJhbS5yYXdkYXRhb3V0cHV0IHx8IFwicmVzdWx0XCI7XG5cbiAgICAvKipcbiAgICAgKiBwYXJhbSByZXF1ZXN0XG4gICAgICogUGFyIGRlZmF1dCwgXCJFeGVjdXRlXCIuXG4gICAgICovXG4gICAgdGhpcy5wYXJhbXJlcXVlc3QgPSB0aGlzLm9wdGlvbnMucGFyYW0ucmVxdWVzdCB8fCBcIkV4ZWN1dGVcIjtcblxuICAgIC8qKlxuICAgICAqIG1ldGhvZGUuXG4gICAgICogUGFyIGRlZmF1dCwgXCJHRVRcIi5cbiAgICAgKi9cbiAgICB0aGlzLm1ldGhvZCA9IHRoaXMub3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIjtcbn1cblxuV1BTLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBsZW5kcyBtb2R1bGU6V1BTI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogV1BTLFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiB7XG4gICAgICAgIGdldCA6IHtcbiAgICAgICAgICAgIHZhbHVlIDogXCJzZXJ2aWNlPV9fU0VSVklDRV9fXCIgK1xuICAgICAgICAgICAgICAgIFwiJnZlcnNpb249X19WRVJTSU9OX19cIiArXG4gICAgICAgICAgICAgICAgXCImcmF3ZGF0YW91dHB1dD1fX1JBV0RBVEFPVVRQVVRfX1wiICtcbiAgICAgICAgICAgICAgICBcIiZpZGVudGlmaWVyPV9fSURFTlRJRklFUl9fXCIgK1xuICAgICAgICAgICAgICAgIFwiJnJlcXVlc3Q9X19SRVFVRVNUX19cIiArXG4gICAgICAgICAgICAgICAgXCImZGF0YWlucHV0cz08IS0tIF9fREFUQUlOUFVUU19fIC0tPlwiLFxuXG4gICAgICAgICAgICBpbnB1dCA6IFwiX19LRVlfXz1fX0RBVEFfX1wiXG5cbiAgICAgICAgfSxcbiAgICAgICAgcG9zdCA6IHtcblxuICAgICAgICAgICAgdmFsdWUgOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIj8+XCIgK1xuICAgICAgICAgICAgICAgIFwiPHdwczpfX1JFUVVFU1RfXyB2ZXJzaW9uPVxcXCJfX1ZFUlNJT05fX1xcXCIgc2VydmljZT1cXFwiX19TRVJWSUNFX19cXFwiIFwiICtcbiAgICAgICAgICAgICAgICBcIl9fTkFNRVNQQUNFX18gX19TQ0hFTUFMT0NBVElPTl9fPlwiICtcbiAgICAgICAgICAgICAgICBcIjxvd3M6SWRlbnRpZmllcj5fX0lERU5USUZJRVJfXzwvb3dzOklkZW50aWZpZXI+XCIgK1xuICAgICAgICAgICAgICAgIFwiPHdwczpEYXRhSW5wdXRzPlwiICtcbiAgICAgICAgICAgICAgICBcIjwhLS0gX19EQVRBSU5QVVRTX18gLS0+XCIgK1xuICAgICAgICAgICAgICAgIFwiPC93cHM6RGF0YUlucHV0cz5cIiArXG4gICAgICAgICAgICAgICAgXCI8d3BzOlJlc3BvbnNlRm9ybT5cIiArXG4gICAgICAgICAgICAgICAgXCI8d3BzOlJhd0RhdGFPdXRwdXQ+XCIgK1xuICAgICAgICAgICAgICAgIFwiPG93czpJZGVudGlmaWVyPl9fUkFXREFUQU9VVFBVVF9fPC9vd3M6SWRlbnRpZmllcj5cIiArXG4gICAgICAgICAgICAgICAgXCI8L3dwczpSYXdEYXRhT3V0cHV0PlwiICtcbiAgICAgICAgICAgICAgICBcIjwvd3BzOlJlc3BvbnNlRm9ybT5cIiArXG4gICAgICAgICAgICAgICAgXCI8L3dwczpfX1JFUVVFU1RfXz5cIixcblxuICAgICAgICAgICAgaW5wdXQgOiBcIjx3cHM6SW5wdXQ+XCIgK1xuICAgICAgICAgICAgICAgIFwiPG93czpJZGVudGlmaWVyPl9fS0VZX188L293czpJZGVudGlmaWVyPlwiICtcbiAgICAgICAgICAgICAgICBcIjx3cHM6RGF0YT5cIiArXG4gICAgICAgICAgICAgICAgXCI8d3BzOkxpdGVyYWxEYXRhPl9fREFUQV9fPC93cHM6TGl0ZXJhbERhdGE+XCIgK1xuICAgICAgICAgICAgICAgIFwiPC93cHM6RGF0YT5cIiArXG4gICAgICAgICAgICAgICAgXCI8L3dwczpJbnB1dD5cIlxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBwYXIgZGVmYXV0IGRlIGxhIHJlcXVldGUgUE9TVC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqL1xuICAgIG5hbWVzcGFjZUJ5RGVmYXVsdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5zID0gW1xuICAgICAgICAgICAgXCJ4bWxuczp4c2k9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlXFxcIlwiLFxuICAgICAgICAgICAgXCJ4bWxucz1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93cHMvMS4wLjBcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zOndmcz1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnNcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zOndwcz1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93cHMvMS4wLjBcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zOm93cz1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vd3MvMS4xXFxcIlwiLFxuICAgICAgICAgICAgXCJ4bWxuczpnbWw9XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXFxcIlwiLFxuICAgICAgICAgICAgXCJ4bWxuczpvZ2M9XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXFxcIlwiLFxuICAgICAgICAgICAgXCJ4bWxuczp3Y3M9XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvd2NzLzEuMS4xXFxcIlwiLFxuICAgICAgICAgICAgXCJ4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCJcIlxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBucy5qb2luKFwiIFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NoZW1hbG9jYXRpb24gcGFyIGRlZmF1dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHNjaGVtYUxvY2F0aW9uXG4gICAgICovXG4gICAgc2NoZW1hTG9jYXRpb25CeURlZmF1bHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcInhzaTpzY2hlbWFMb2NhdGlvbj1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93cHMvMS4wLjAgaHR0cDovL3NjaGVtYXMub3Blbmdpcy5uZXQvd3BzLzEuMC4wL3dwc0FsbC54c2RcXFwiXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGlvbiBkZSBsYSByZXF1w6p0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gR0VUICBvdXQgOlxuICAgICAqIC8vICBzZXJ2aWNlPV9fU0VSVklDRV9fXG4gICAgICogLy8gICZ2ZXJzaW9uPV9fVkVSU0lPTl9fXG4gICAgICogLy8gICZyYXdkYXRhb3V0cHV0PV9fUkFXREFUQU9VVFBVVF9fXG4gICAgICogLy8gICZpZGVudGlmaWVyPV9fSURFTlRJRklFUl9fXG4gICAgICogLy8gICZyZXF1ZXN0PV9fUkVRVUVTVF9fXG4gICAgICogLy8gICZkYXRhaW5wdXRzPVwiX19EQVRBSU5QVVRTX19cIlxuICAgICAqIC8vICBhdmVjIF9fREFUQUlOUFVUU19fID0gX19LRVlfXz1fX0RBVEFfXzsuLi5cbiAgICAgKlxuICAgICAqIC8vIFBPU1Qgb3V0IDpcbiAgICAgKiAvLyAgICAgIDw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIj8+XG4gICAgICogLy8gICAgICA8d3BzOl9fUkVRVUVTVF9fIHZlcnNpb249XFxcIl9fVkVSU0lPTl9fXFxcIiBzZXJ2aWNlPVxcXCJfX1NFUlZJQ0VfX1xcXCJcbiAgICAgKiAvLyAgICAgICAgIF9fTkFNRVNQQUNFX18gX19TQ0hFTUFMT0NBVElPTl9fPlxuICAgICAqIC8vICAgICAgICAgIDxvd3M6SWRlbnRpZmllcj5fX0lERU5USUZJRVJfXzwvb3dzOklkZW50aWZpZXI+XG4gICAgICogLy8gICAgICAgICAgPHdwczpEYXRhSW5wdXRzPlxuICAgICAqIC8vICAgICAgICAgICAgICA8IS0tIF9fREFUQUlOUFVUU19fIC0tPlxuICAgICAqIC8vICAgICAgICAgIDwvd3BzOkRhdGFJbnB1dHM+XG4gICAgICogLy8gICAgICAgICAgPHdwczpSZXNwb25zZUZvcm0+XG4gICAgICogLy8gICAgICAgICAgICAgIDx3cHM6UmF3RGF0YU91dHB1dD5cbiAgICAgKiAvLyAgICAgICAgICAgICAgPG93czpJZGVudGlmaWVyPl9fUkFXREFUQU9VVFBVVF9fPC9vd3M6SWRlbnRpZmllcj5cbiAgICAgKiAvLyAgICAgICAgICAgICAgPC93cHM6UmF3RGF0YU91dHB1dD5cbiAgICAgKiAvLyAgICAgICAgICA8L3dwczpSZXNwb25zZUZvcm0+XG4gICAgICogLy8gICAgICA8L3dwczpfX1JFUVVFU1RfXz5cIixcbiAgICAgKiAvLyAgICAgIGF2ZWMgX19EQVRBSU5QVVRTX19cbiAgICAgKiAvLyAgICAgICAgICAgICA8d3BzOklucHV0PlxuICAgICAqIC8vICAgICAgICAgICAgICAgICAgPG93czpJZGVudGlmaWVyPl9fS0VZX188L293czpJZGVudGlmaWVyPlxuICAgICAqIC8vICAgICAgICAgICAgICAgICAgPHdwczpEYXRhPlxuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICA8d3BzOkxpdGVyYWxEYXRhPl9fREFUQV9fPC93cHM6TGl0ZXJhbERhdGE+XG4gICAgICogLy8gICAgICAgICAgICAgICAgICA8L3dwczpEYXRhPlxuICAgICAqIC8vICAgICAgICAgICAgICA8L3dwczpJbnB1dD5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB2YWxpZGF0aW9uIGRlIGxhIGNvbnN0cnVjdGlvbiBkZSBsYSByZXF1ZXRlXG4gICAgICovXG4gICAgcHJvY2Vzc1JlcXVlc3RTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiV1BTOjpwcm9jZXNzUmVxdWVzdFN0cmluZyAoKVwiKTtcblxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUucG9zdC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLmdldC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiTm8gb3RoZXIgbWV0aG9kIHN1cHBvcnRlZCBieSB0aGUgc2VydmljZSAhXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX1NFUlZJQ0VfXy9nLCB0aGlzLnBhcmFtc2VydmljZSk7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19WRVJTSU9OX18vZywgdGhpcy5wYXJhbXZlcnNpb24pO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUkFXREFUQU9VVFBVVF9fL2csIHRoaXMucGFyYW1yYXdkYXRhb3V0cHV0KTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0lERU5USUZJRVJfXy9nLCB0aGlzLnBhcmFtaWRlbnRpZmllcik7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19SRVFVRVNUX18vZywgdGhpcy5wYXJhbXJlcXVlc3QpO1xuXG4gICAgICAgIC8vIGFqb3V0ICtcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX05BTUVTUEFDRV9fL2csIHRoaXMubmFtZXNwYWNlQnlEZWZhdWx0KTtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19TQ0hFTUFMT0NBVElPTl9fL2csIHRoaXMuc2NoZW1hTG9jYXRpb25CeURlZmF1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWpvdXQgZGVzIGRhdGFpbnB1dHNcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC88IS0tIF9fREFUQUlOUFVUU19fIC0tPi9nLCB0aGlzLl9fYWRkRGF0YUlucHV0cygpKTtcblxuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidHJhZHVjdGlvbiB0bXBsIDogZW1wdHkgcmVxdWVzdCAhP1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVxdWVzdFN0cmluZyA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcInRyYWR1Y3Rpb24gdG1wbFwiLCB0ZW1wbGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFqb3V0IGRlcyBkb25uw6llc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gRG9ubsOpZXMgY29uY2F0w6luw6llcyBkYW5zIHVuZSBjaGFpbmVcbiAgICAgKi9cbiAgICBfX2FkZERhdGFJbnB1dHMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiV1BTOjpfX2FkZERhdGFJbnB1dHMgKClcIik7XG5cbiAgICAgICAgLy8gYydlc3QgdW4gcGV1IGdyb3NzaWVyLi4uXG4gICAgICAgIHZhciB0bXBsID0gdGhpcy5tZXRob2QgPT09IFwiR0VUXCIgPyB0aGlzLnRlbXBsYXRlLmdldC5pbnB1dCA6IHRoaXMudGVtcGxhdGUucG9zdC5pbnB1dDtcbiAgICAgICAgdmFyIHNlcCA9IHRoaXMubWV0aG9kID09PSBcIkdFVFwiID8gXCI7XCIgOiBcIlwiO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLkRhdGFPYmplY3QuZ2V0RGF0YSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gRklYTUUgY2xvc3VyZSA/XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGopIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IChqID09PSBtYXAubGVuZ3RoIC0gMSkgPyBcIlwiIDogXCI7XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhhdC5fX2FkZERhdGFJbnB1dCh0bXBsLCBtYXBbal0uaywgbWFwW2pdLnYpLCBzZXApO1xuICAgICAgICAgICAgfSkoaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBam91dCBkJ3VuZSBkb25uw6llLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRtcGwgLSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBjbGVmXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSB2YWxldXJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBjaGFpbmUgYXZlYyBsZXMgc3Vic3RpdHV0aW9ucyBjbGVmL3ZhbGV1clxuICAgICAqL1xuICAgIF9fYWRkRGF0YUlucHV0IDogZnVuY3Rpb24gKHRtcGwsIGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgdG1wID0gdG1wbDtcbiAgICAgICAgdG1wID0gdG1wLnJlcGxhY2UoL19fS0VZX18vZywga2V5KTtcbiAgICAgICAgdG1wID0gdG1wLnJlcGxhY2UoL19fREFUQV9fL2csIGRhdGEpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmlyIGxlIG1vZGUgZGUgcmVxdcOqdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBHRVR8UE9TVFxuICAgICAqL1xuICAgIHNldE1ldGhvZCA6IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJHRVRcIiB8fCBtZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJzdXBwb3J0IG9ubHkgR0VUIGFuZCBQT1NUIG1ldGhvZCAhXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldG91cm5lIGxlIG1vZGUgZGUgcmVxdWV0ZSAoR0VUfFBPU1QpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FsdGlSZXF1ZXN0Lm9wdGlvbnMubW9kZXxTdHJpbmd9IG1ldGhvZGUgKEdFVHxQT1NUKVxuICAgICAqL1xuICAgIGdldE1ldGhvZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdQUztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Formats/WPS.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Formats/XML.js":
/*!**************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Formats/XML.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* global require */\n\n\n// import __xmldom from \"xmldom\";\n\n/**\n * @classdesc\n *\n * Classe permettant d'écrire ou de lire du XML, sous forme de document DOM,\n * éventuellement selon des clés de lecture (readers) ou d'écriture (writers) spécifiques.\n *\n * @constructor\n * @alias Gp.Formats.XML\n *\n * @param {Object} [options] - options du format XML\n *\n * @param {Object} [options.reader] - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)\n *      utile pour interpréter le XML lorsque sa structure est connue.\n *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.\n *\n * @param {Object} [options.writers] - writers\n *\n * @param {String} [options.xmlString] - chaîne de caractère contenant du XML à interpréter.\n *\n * @private\n */\nfunction XML (options) {\n    if (!(this instanceof XML)) {\n        throw new TypeError(\"XML constructor cannot be called as a function.\");\n    }\n\n    // FIXME : notion de singleton\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger();\n    this.logger.trace(\"[Constructeur XML ()]\");\n\n    /**\n     * Chaîne de caractères contenant le texte XML\n     * @type {String}\n     */\n    this.xmlString = null;\n\n    /**\n     * DOM Element correspondant à la structure du XML.\n     * @type {DOMElement}\n     */\n    this.xmlDoc = null;\n\n    /**\n     * Objet contenant des fonctions de lecture des différentes balises XML.\n     * @type {Object}\n     */\n    this.reader = null;\n\n    // traitement des paramètres d'options s'il y en a\n    if (options) {\n        if (options.xmlString && typeof options.xmlString === \"string\") {\n            this.xmlString = options.xmlString;\n            // Si une chaine de caractère a été passée en entrée : on la transforme aussi en XML document\n            this.xmlDoc = __getXMLDOC(options.xmlString);\n        }\n        if (options.reader) {\n            this.setReader(options.reader);\n        }\n    }\n}\n\nXML.prototype = {\n\n    /**\n     * @lends module:XML\n     */\n\n    /*\n     * Constructeur (alias)\n     */\n    constructor : XML,\n\n    /**\n     * Méthode permettant de récupérer la chaîne de caractères associée au format XML\n     *\n     * @returns {String} xmlString - la chaîne de caractères correspondant au format XML\n     */\n    getXMLString : function () {\n        return this.xmlString;\n    },\n\n    /**\n     * Méthode permettant d'attribuer une chaîne de caractères au format XML (attribut xmlString).\n     * La méthode va aussi transformer cette chaîne de caractères en document XML,\n     * afin de remplir l'attribut xmlDoc.\n     *\n     * @param {String} xmlString - la chaîne de caractères correspondant au format XML\n     */\n    setXMLString : function (xmlString) {\n        if (xmlString && typeof xmlString === \"string\") {\n            this.xmlString = xmlString;\n            this.xmlDoc = __getXMLDOC(xmlString);\n        }\n    },\n\n    /**\n     * Méthode permettant de récupérer les readers associés au format XML, s'ils ont été définis\n     *\n     * @return {Object} readers - les readers associés au format XML, s'ils existent,\n     *      sous forme d'une collection de fonctions\n     */\n    getReader : function () {\n        return this.reader;\n    },\n\n    /**\n     * Méthode permettant d'attribuer des readers, sous la forme d'un objet de fonctions (node, data),\n     *      lorsqu'ils n'ont pas été définis lors de l'instanciation par exemple (new XML (options)).\n     *\n     * @param {Object} reader - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)\n     *      utile pour interpréter le XML lorsque sa structure est connue.\n     *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.\n     */\n    setReader : function (reader) {\n        if (reader && reader.read && typeof reader.read === \"function\") {\n            this.reader = reader;\n        }\n    },\n\n    /**\n     * Méthode permettant de récupérer le document XML associé au format, s'il existe.\n     *\n     * @return {DOMElement} xmlDoc - le document XML (DOM document node) s'il existe\n     */\n    getXMLDoc : function () {\n        return this.xmlDoc;\n    },\n\n    /**\n     * Setter\n     */\n    setXMLDoc : function (doc) {\n        this.xmlDoc = doc;\n    },\n    /**\n     * Méthode initialisant la lecture du XML, à partir d'un XML Document :\n     *      création d'un objet JavaScript contenant les informations du XML,\n     *      sauf dans le cas où il n'existe pas de XML Document à interpréter (retourne un objet vide).\n     *\n     * @return {Object} [parserOutput] - un objet JavaScript contenant les informations du XML :\n     * - soit toutes les informations si aucun reader n'a été spécifié à la création du format\n     * - soit les informations spécifiées dans le reader.\n     */\n    parse : function () {\n        // build xml document from xmlString\n        if (!this.xmlDoc && this.xmlString) {\n            this.xmlDoc = __getXMLDOC(this.xmlString);\n        }\n        if (this.xmlDoc) {\n            var root = __getRootNode(this.xmlDoc);\n            if (root) {\n                var parserOutput;\n                // call reader if exists\n                if (this.reader && this.reader.read) {\n                    parserOutput = this.reader.read(root);\n                } else {\n                    parserOutput = {};\n                    parserOutput[root.nodeName] = __readDefault(root);\n                }\n                return parserOutput;\n            } else {\n                return {};\n            }\n        }\n    }\n\n};\n\n/**\n * Méthode de la classe (privée) permettant de créer un XML Document à partir d'une chaîne de caractères XML,\n *      en utilisant DOMParser () lorsque c'est possible.\n *      For more information, see: https://dvcs.w3.org/hg/innerhtml/raw-file/tip/index.html#the-domparser-interface\n *\n * @private\n * @memberof XML\n * @method __getXMLDOC\n * @param {String} xmlString - xml string to be converted into DOM element\n * @return {DOMElement} - the corresponding XML Document\n */\nfunction __getXMLDOC (xmlString) {\n    if (typeof window === \"undefined\") {\n        // env. nodejs\n        var DOMParser = __webpack_require__(/*! xmldom */ \"xmldom\").DOMParser; // __xmldom.DOMParser;\n        return new DOMParser().parseFromString(xmlString, \"text/xml\");\n    } else {\n        // env. browser\n\n        var parser;\n        var xmlDoc;\n        var errorMsg = \"Erreur lors du parsing de la réponse du service : XML non conforme\";\n\n        if (window.ActiveXObject) {\n            // Internet Explorer < 9\n            xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = false;\n            xmlDoc.loadXML(xmlString);\n            var parseError = xmlDoc.parseError;\n            if (parseError.errorCode) {\n                if (parseError.line && parseError.linepos) {\n                    errorMsg += \"( ligne \" + parseError.line + \", colonne \" + parseError.linepos;\n                }\n                if (parseError.reason) {\n                    errorMsg += \":  \" + parseError.reason + \")\";\n                }\n                throw new Error(errorMsg);\n            }\n            return xmlDoc;\n        } else if (window.DOMParser) {\n            // les autres (Chrome, Mozilla, IE >= 9)\n            parser = new window.DOMParser();\n            try {\n                xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n            } catch (e) {\n                // Internet Explorer browser raises exception if xmlString is not valid XML\n                if (e.message === \"SyntaxError\") {\n                    throw new Error(errorMsg);\n                } else {\n                    throw new Error(\"Erreur lors du parsing de la réponse du service : \" + e.message);\n                }\n            }\n            // look for parsing error in case no exception was raised\n            if (xmlDoc.getElementsByTagName(\"parsererror\").length > 0) {\n                var parsererror = xmlDoc.getElementsByTagName(\"parsererror\");\n                for (var i = 0; i < parsererror.length; i++) {\n                    var content = parsererror[i].innerHTML;\n                    // except in case parsererror is just because of huge xml, but parsing is done.\n                    if (content.indexOf(\"Huge input lookup\") === -1) {\n                        errorMsg += \"(\" + content + \")\";\n                        throw new Error(errorMsg);\n                    }\n                }\n            } else if (!xmlDoc.documentElement) { // may happen in chrome browser\n                throw new Error(errorMsg);\n            }\n            return xmlDoc;\n        } else {\n            // FIXME\n            throw new Error(\"Incompatible DOM Parser pour ce navigateur !\");\n        }\n    }\n}\n\n/**\n * Méthode de la classe (privée) permettant de récupérer le noeud racine du document,\n *      à partir d'un document node (nodeType=9), puis lecture de ce noeud (readNode)\n *\n * @private\n * @memberof XML\n * @method __getRootNode\n * @param {DOMElement} [xmlDoc] - a Document Node\n * @return {DOMElement} root - the document root node\n */\nfunction __getRootNode (xmlDoc) {\n    var root;\n    if (xmlDoc.nodeType === 9) {\n        // INFO : nodeType 9 represents the entire document (the root-node of the DOM tree)\n        root = xmlDoc.documentElement;\n    } else if (xmlDoc.nodeType === 1) {\n        root = xmlDoc;\n    }\n    return root;\n}\n\n/**\n * Méthode de la classe (privée) permettant de lire automatiquement un noeud XML,\n *      lorsqu'aucun reader spécifique n'a été spécifié (parser brut)\n *\n * @private\n * @memberof XML\n * @method readDefault\n * @param {DOMElement} node - a DOM element node\n * @example final data object looks like :\n *          data = {\n *              attributeName: attributeValue,\n *              childName: {\n *                  attributeName: attributeValue,\n *                  attributeName: attributeValue,\n *                  childName: {\n *                      \"textContent\": textContent\n *                  },\n *                  childName: {\n *                      childName: {\n *                          attributeName:attributeValue\n *                      }\n *                  }\n *              }\n *          }\n */\nfunction __readDefault (node) {\n    var data = {};\n\n    // if element node has attributes, set their values to data\n    if (node.attributes.length > 0) {\n        var dataAttributes = __getAttributes(node);\n        data[\"attributes\"] = dataAttributes;\n    }\n\n    // if element node has childNodes, read them and set them to data\n    if (node.hasChildNodes()) {\n        var childData = {};\n        var child;\n        var children = node.childNodes;\n\n        for (var i = 0; i < children.length; i++) {\n            child = children[i];\n\n            if (child.nodeType === 3) { // TEXT_NODE\n                data[\"textContent\"] = child.nodeValue;\n            } else if (child.nodeType === 1) {\n                childData = __readDefault(child);\n\n                if (!data[child.nodeName]) {\n                    // store childData in an object\n                    data[child.nodeName] = childData;\n                } else {\n                    // in case several childNodes has the same name : store them in an array.\n                    // if data[nodeName] already exists but is not an array\n                    if (!Array.isArray(data[child.nodeName])) {\n                        var old = data[child.nodeName];\n                        data[child.nodeName] = [];\n                        data[child.nodeName].push(old);\n                    }\n                    data[child.nodeName].push(childData);\n                }\n            }\n            // TODO : manage other node types (4=CDATA, etc)\n        }\n    }\n\n    return data;\n}\n\n/**\n * Méthode de la classe (privée) permettant de récupérer les attributs d'un noeud élément\n *\n * @private\n * @memberof XML\n * @method __getAttributes\n * @param {DOMElement} node - noeud contenant l'attribut recherché\n * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs\n */\nfunction __getAttributes (node) {\n    if (node.attributes.length > 0) {\n        var nodeAttributes = {};\n        var attributes = node.attributes;\n        for (var i = 0; i < attributes.length; i++) {\n            var attribute = attributes[i];\n            nodeAttributes[attribute.nodeName] = attribute.nodeValue;\n        }\n        return nodeAttributes;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (XML);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL0Zvcm1hdHMvWE1MLmpzPzRjMWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUU4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQiw4REFBTTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxzQkFBUSxZQUFZO0FBQ3BEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1Qzs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsa0VBQUcsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvRm9ybWF0cy9YTUwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgcmVxdWlyZSAqL1xuXG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbi8vIGltcG9ydCBfX3htbGRvbSBmcm9tIFwieG1sZG9tXCI7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIENsYXNzZSBwZXJtZXR0YW50IGQnw6ljcmlyZSBvdSBkZSBsaXJlIGR1IFhNTCwgc291cyBmb3JtZSBkZSBkb2N1bWVudCBET00sXG4gKiDDqXZlbnR1ZWxsZW1lbnQgc2Vsb24gZGVzIGNsw6lzIGRlIGxlY3R1cmUgKHJlYWRlcnMpIG91IGQnw6ljcml0dXJlICh3cml0ZXJzKSBzcMOpY2lmaXF1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTUxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBkdSBmb3JtYXQgWE1MXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJlYWRlcl0gLSBJbnN0YW5jZSBkJ3VuIFJlYWRlciBkZSBzZXJ2aWNlIChBbHRpUmVzcG9uc2VSZWFkZXIsIEdlb2NvZGVSZXF1ZXN0UmVhZGVyLCBldGMuKVxuICogICAgICB1dGlsZSBwb3VyIGludGVycHLDqXRlciBsZSBYTUwgbG9yc3F1ZSBzYSBzdHJ1Y3R1cmUgZXN0IGNvbm51ZS5cbiAqICAgICAgQ2UgcmVhZGVyIGRvaXQgY29tcG9ydGVyIGF1IG1vaW5zIHVuZSBmb25jdGlvbiBzdGF0aXF1ZSByZWFkIChyb290KSBwZXJtZXR0YW50IGQnaW5pdGlhbGlzZXIgbGEgbGVjdHVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVyc10gLSB3cml0ZXJzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnhtbFN0cmluZ10gLSBjaGHDrm5lIGRlIGNhcmFjdMOocmUgY29udGVuYW50IGR1IFhNTCDDoCBpbnRlcnByw6l0ZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gWE1MIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFhNTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlhNTCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FIDogbm90aW9uIGRlIHNpbmdsZXRvblxuXG4gICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFhNTCAoKV1cIik7XG5cbiAgICAvKipcbiAgICAgKiBDaGHDrm5lIGRlIGNhcmFjdMOocmVzIGNvbnRlbmFudCBsZSB0ZXh0ZSBYTUxcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMueG1sU3RyaW5nID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERPTSBFbGVtZW50IGNvcnJlc3BvbmRhbnQgw6AgbGEgc3RydWN0dXJlIGR1IFhNTC5cbiAgICAgKiBAdHlwZSB7RE9NRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnhtbERvYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBPYmpldCBjb250ZW5hbnQgZGVzIGZvbmN0aW9ucyBkZSBsZWN0dXJlIGRlcyBkaWZmw6lyZW50ZXMgYmFsaXNlcyBYTUwuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWRlciA9IG51bGw7XG5cbiAgICAvLyB0cmFpdGVtZW50IGRlcyBwYXJhbcOodHJlcyBkJ29wdGlvbnMgcydpbCB5IGVuIGFcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy54bWxTdHJpbmcgJiYgdHlwZW9mIG9wdGlvbnMueG1sU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnhtbFN0cmluZyA9IG9wdGlvbnMueG1sU3RyaW5nO1xuICAgICAgICAgICAgLy8gU2kgdW5lIGNoYWluZSBkZSBjYXJhY3TDqHJlIGEgw6l0w6kgcGFzc8OpZSBlbiBlbnRyw6llIDogb24gbGEgdHJhbnNmb3JtZSBhdXNzaSBlbiBYTUwgZG9jdW1lbnRcbiAgICAgICAgICAgIHRoaXMueG1sRG9jID0gX19nZXRYTUxET0Mob3B0aW9ucy54bWxTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFkZXIob3B0aW9ucy5yZWFkZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5YTUwucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpYTUxcbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IFhNTCxcblxuICAgIC8qKlxuICAgICAqIE3DqXRob2RlIHBlcm1ldHRhbnQgZGUgcsOpY3Vww6lyZXIgbGEgY2hhw65uZSBkZSBjYXJhY3TDqHJlcyBhc3NvY2nDqWUgYXUgZm9ybWF0IFhNTFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30geG1sU3RyaW5nIC0gbGEgY2hhw65uZSBkZSBjYXJhY3TDqHJlcyBjb3JyZXNwb25kYW50IGF1IGZvcm1hdCBYTUxcbiAgICAgKi9cbiAgICBnZXRYTUxTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhtbFN0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTcOpdGhvZGUgcGVybWV0dGFudCBkJ2F0dHJpYnVlciB1bmUgY2hhw65uZSBkZSBjYXJhY3TDqHJlcyBhdSBmb3JtYXQgWE1MIChhdHRyaWJ1dCB4bWxTdHJpbmcpLlxuICAgICAqIExhIG3DqXRob2RlIHZhIGF1c3NpIHRyYW5zZm9ybWVyIGNldHRlIGNoYcOubmUgZGUgY2FyYWN0w6hyZXMgZW4gZG9jdW1lbnQgWE1MLFxuICAgICAqIGFmaW4gZGUgcmVtcGxpciBsJ2F0dHJpYnV0IHhtbERvYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB4bWxTdHJpbmcgLSBsYSBjaGHDrm5lIGRlIGNhcmFjdMOocmVzIGNvcnJlc3BvbmRhbnQgYXUgZm9ybWF0IFhNTFxuICAgICAqL1xuICAgIHNldFhNTFN0cmluZyA6IGZ1bmN0aW9uICh4bWxTdHJpbmcpIHtcbiAgICAgICAgaWYgKHhtbFN0cmluZyAmJiB0eXBlb2YgeG1sU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnhtbFN0cmluZyA9IHhtbFN0cmluZztcbiAgICAgICAgICAgIHRoaXMueG1sRG9jID0gX19nZXRYTUxET0MoeG1sU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIHLDqWN1cMOpcmVyIGxlcyByZWFkZXJzIGFzc29jacOpcyBhdSBmb3JtYXQgWE1MLCBzJ2lscyBvbnQgw6l0w6kgZMOpZmluaXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcmVhZGVycyAtIGxlcyByZWFkZXJzIGFzc29jacOpcyBhdSBmb3JtYXQgWE1MLCBzJ2lscyBleGlzdGVudCxcbiAgICAgKiAgICAgIHNvdXMgZm9ybWUgZCd1bmUgY29sbGVjdGlvbiBkZSBmb25jdGlvbnNcbiAgICAgKi9cbiAgICBnZXRSZWFkZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTcOpdGhvZGUgcGVybWV0dGFudCBkJ2F0dHJpYnVlciBkZXMgcmVhZGVycywgc291cyBsYSBmb3JtZSBkJ3VuIG9iamV0IGRlIGZvbmN0aW9ucyAobm9kZSwgZGF0YSksXG4gICAgICogICAgICBsb3JzcXUnaWxzIG4nb250IHBhcyDDqXTDqSBkw6lmaW5pcyBsb3JzIGRlIGwnaW5zdGFuY2lhdGlvbiBwYXIgZXhlbXBsZSAobmV3IFhNTCAob3B0aW9ucykpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlYWRlciAtIEluc3RhbmNlIGQndW4gUmVhZGVyIGRlIHNlcnZpY2UgKEFsdGlSZXNwb25zZVJlYWRlciwgR2VvY29kZVJlcXVlc3RSZWFkZXIsIGV0Yy4pXG4gICAgICogICAgICB1dGlsZSBwb3VyIGludGVycHLDqXRlciBsZSBYTUwgbG9yc3F1ZSBzYSBzdHJ1Y3R1cmUgZXN0IGNvbm51ZS5cbiAgICAgKiAgICAgIENlIHJlYWRlciBkb2l0IGNvbXBvcnRlciBhdSBtb2lucyB1bmUgZm9uY3Rpb24gc3RhdGlxdWUgcmVhZCAocm9vdCkgcGVybWV0dGFudCBkJ2luaXRpYWxpc2VyIGxhIGxlY3R1cmUuXG4gICAgICovXG4gICAgc2V0UmVhZGVyIDogZnVuY3Rpb24gKHJlYWRlcikge1xuICAgICAgICBpZiAocmVhZGVyICYmIHJlYWRlci5yZWFkICYmIHR5cGVvZiByZWFkZXIucmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIHLDqWN1cMOpcmVyIGxlIGRvY3VtZW50IFhNTCBhc3NvY2nDqSBhdSBmb3JtYXQsIHMnaWwgZXhpc3RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RE9NRWxlbWVudH0geG1sRG9jIC0gbGUgZG9jdW1lbnQgWE1MIChET00gZG9jdW1lbnQgbm9kZSkgcydpbCBleGlzdGVcbiAgICAgKi9cbiAgICBnZXRYTUxEb2MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhtbERvYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyXG4gICAgICovXG4gICAgc2V0WE1MRG9jIDogZnVuY3Rpb24gKGRvYykge1xuICAgICAgICB0aGlzLnhtbERvYyA9IGRvYztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE3DqXRob2RlIGluaXRpYWxpc2FudCBsYSBsZWN0dXJlIGR1IFhNTCwgw6AgcGFydGlyIGQndW4gWE1MIERvY3VtZW50IDpcbiAgICAgKiAgICAgIGNyw6lhdGlvbiBkJ3VuIG9iamV0IEphdmFTY3JpcHQgY29udGVuYW50IGxlcyBpbmZvcm1hdGlvbnMgZHUgWE1MLFxuICAgICAqICAgICAgc2F1ZiBkYW5zIGxlIGNhcyBvw7kgaWwgbidleGlzdGUgcGFzIGRlIFhNTCBEb2N1bWVudCDDoCBpbnRlcnByw6l0ZXIgKHJldG91cm5lIHVuIG9iamV0IHZpZGUpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBbcGFyc2VyT3V0cHV0XSAtIHVuIG9iamV0IEphdmFTY3JpcHQgY29udGVuYW50IGxlcyBpbmZvcm1hdGlvbnMgZHUgWE1MIDpcbiAgICAgKiAtIHNvaXQgdG91dGVzIGxlcyBpbmZvcm1hdGlvbnMgc2kgYXVjdW4gcmVhZGVyIG4nYSDDqXTDqSBzcMOpY2lmacOpIMOgIGxhIGNyw6lhdGlvbiBkdSBmb3JtYXRcbiAgICAgKiAtIHNvaXQgbGVzIGluZm9ybWF0aW9ucyBzcMOpY2lmacOpZXMgZGFucyBsZSByZWFkZXIuXG4gICAgICovXG4gICAgcGFyc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGJ1aWxkIHhtbCBkb2N1bWVudCBmcm9tIHhtbFN0cmluZ1xuICAgICAgICBpZiAoIXRoaXMueG1sRG9jICYmIHRoaXMueG1sU3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnhtbERvYyA9IF9fZ2V0WE1MRE9DKHRoaXMueG1sU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy54bWxEb2MpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX19nZXRSb290Tm9kZSh0aGlzLnhtbERvYyk7XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXJPdXRwdXQ7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCByZWFkZXIgaWYgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZGVyICYmIHRoaXMucmVhZGVyLnJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyT3V0cHV0ID0gdGhpcy5yZWFkZXIucmVhZChyb290KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJPdXRwdXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyT3V0cHV0W3Jvb3Qubm9kZU5hbWVdID0gX19yZWFkRGVmYXVsdChyb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlck91dHB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIE3DqXRob2RlIGRlIGxhIGNsYXNzZSAocHJpdsOpZSkgcGVybWV0dGFudCBkZSBjcsOpZXIgdW4gWE1MIERvY3VtZW50IMOgIHBhcnRpciBkJ3VuZSBjaGHDrm5lIGRlIGNhcmFjdMOocmVzIFhNTCxcbiAqICAgICAgZW4gdXRpbGlzYW50IERPTVBhcnNlciAoKSBsb3JzcXVlIGMnZXN0IHBvc3NpYmxlLlxuICogICAgICBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2R2Y3MudzMub3JnL2hnL2lubmVyaHRtbC9yYXctZmlsZS90aXAvaW5kZXguaHRtbCN0aGUtZG9tcGFyc2VyLWludGVyZmFjZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgWE1MXG4gKiBAbWV0aG9kIF9fZ2V0WE1MRE9DXG4gKiBAcGFyYW0ge1N0cmluZ30geG1sU3RyaW5nIC0geG1sIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgaW50byBET00gZWxlbWVudFxuICogQHJldHVybiB7RE9NRWxlbWVudH0gLSB0aGUgY29ycmVzcG9uZGluZyBYTUwgRG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gX19nZXRYTUxET0MgKHhtbFN0cmluZykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVudi4gbm9kZWpzXG4gICAgICAgIHZhciBET01QYXJzZXIgPSByZXF1aXJlKFwieG1sZG9tXCIpLkRPTVBhcnNlcjsgLy8gX194bWxkb20uRE9NUGFyc2VyO1xuICAgICAgICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsIFwidGV4dC94bWxcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW52LiBicm93c2VyXG5cbiAgICAgICAgdmFyIHBhcnNlcjtcbiAgICAgICAgdmFyIHhtbERvYztcbiAgICAgICAgdmFyIGVycm9yTXNnID0gXCJFcnJldXIgbG9ycyBkdSBwYXJzaW5nIGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UgOiBYTUwgbm9uIGNvbmZvcm1lXCI7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciA8IDlcbiAgICAgICAgICAgIHhtbERvYyA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgICAgICB4bWxEb2MuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIHhtbERvYy5sb2FkWE1MKHhtbFN0cmluZyk7XG4gICAgICAgICAgICB2YXIgcGFyc2VFcnJvciA9IHhtbERvYy5wYXJzZUVycm9yO1xuICAgICAgICAgICAgaWYgKHBhcnNlRXJyb3IuZXJyb3JDb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRXJyb3IubGluZSAmJiBwYXJzZUVycm9yLmxpbmVwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgKz0gXCIoIGxpZ25lIFwiICsgcGFyc2VFcnJvci5saW5lICsgXCIsIGNvbG9ubmUgXCIgKyBwYXJzZUVycm9yLmxpbmVwb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUVycm9yLnJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPSBcIjogIFwiICsgcGFyc2VFcnJvci5yZWFzb24gKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LkRPTVBhcnNlcikge1xuICAgICAgICAgICAgLy8gbGVzIGF1dHJlcyAoQ2hyb21lLCBNb3ppbGxhLCBJRSA+PSA5KVxuICAgICAgICAgICAgcGFyc2VyID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsIFwidGV4dC94bWxcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlciByYWlzZXMgZXhjZXB0aW9uIGlmIHhtbFN0cmluZyBpcyBub3QgdmFsaWQgWE1MXG4gICAgICAgICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gXCJTeW50YXhFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyZXVyIGxvcnMgZHUgcGFyc2luZyBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIDogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIHBhcnNpbmcgZXJyb3IgaW4gY2FzZSBubyBleGNlcHRpb24gd2FzIHJhaXNlZFxuICAgICAgICAgICAgaWYgKHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyZXJyb3IgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnNlcmVycm9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gcGFyc2VyZXJyb3JbaV0uaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICAvLyBleGNlcHQgaW4gY2FzZSBwYXJzZXJlcnJvciBpcyBqdXN0IGJlY2F1c2Ugb2YgaHVnZSB4bWwsIGJ1dCBwYXJzaW5nIGlzIGRvbmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmluZGV4T2YoXCJIdWdlIGlucHV0IGxvb2t1cFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9IFwiKFwiICsgY29udGVudCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXhtbERvYy5kb2N1bWVudEVsZW1lbnQpIHsgLy8gbWF5IGhhcHBlbiBpbiBjaHJvbWUgYnJvd3NlclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGF0aWJsZSBET00gUGFyc2VyIHBvdXIgY2UgbmF2aWdhdGV1ciAhXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIE3DqXRob2RlIGRlIGxhIGNsYXNzZSAocHJpdsOpZSkgcGVybWV0dGFudCBkZSByw6ljdXDDqXJlciBsZSBub2V1ZCByYWNpbmUgZHUgZG9jdW1lbnQsXG4gKiAgICAgIMOgIHBhcnRpciBkJ3VuIGRvY3VtZW50IG5vZGUgKG5vZGVUeXBlPTkpLCBwdWlzIGxlY3R1cmUgZGUgY2Ugbm9ldWQgKHJlYWROb2RlKVxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgWE1MXG4gKiBAbWV0aG9kIF9fZ2V0Um9vdE5vZGVcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gW3htbERvY10gLSBhIERvY3VtZW50IE5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHJvb3QgLSB0aGUgZG9jdW1lbnQgcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIF9fZ2V0Um9vdE5vZGUgKHhtbERvYykge1xuICAgIHZhciByb290O1xuICAgIGlmICh4bWxEb2Mubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgLy8gSU5GTyA6IG5vZGVUeXBlIDkgcmVwcmVzZW50cyB0aGUgZW50aXJlIGRvY3VtZW50ICh0aGUgcm9vdC1ub2RlIG9mIHRoZSBET00gdHJlZSlcbiAgICAgICAgcm9vdCA9IHhtbERvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh4bWxEb2Mubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgcm9vdCA9IHhtbERvYztcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5cbi8qKlxuICogTcOpdGhvZGUgZGUgbGEgY2xhc3NlIChwcml2w6llKSBwZXJtZXR0YW50IGRlIGxpcmUgYXV0b21hdGlxdWVtZW50IHVuIG5vZXVkIFhNTCxcbiAqICAgICAgbG9yc3F1J2F1Y3VuIHJlYWRlciBzcMOpY2lmaXF1ZSBuJ2Egw6l0w6kgc3DDqWNpZmnDqSAocGFyc2VyIGJydXQpXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBYTUxcbiAqIEBtZXRob2QgcmVhZERlZmF1bHRcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIGEgRE9NIGVsZW1lbnQgbm9kZVxuICogQGV4YW1wbGUgZmluYWwgZGF0YSBvYmplY3QgbG9va3MgbGlrZSA6XG4gKiAgICAgICAgICBkYXRhID0ge1xuICogICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IGF0dHJpYnV0ZVZhbHVlLFxuICogICAgICAgICAgICAgIGNoaWxkTmFtZToge1xuICogICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiBhdHRyaWJ1dGVWYWx1ZSxcbiAqICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogYXR0cmlidXRlVmFsdWUsXG4gKiAgICAgICAgICAgICAgICAgIGNoaWxkTmFtZToge1xuICogICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0Q29udGVudFwiOiB0ZXh0Q29udGVudFxuICogICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgICAgICBjaGlsZE5hbWU6IHtcbiAqICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTmFtZToge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6YXR0cmlidXRlVmFsdWVcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgIH1cbiAqICAgICAgICAgIH1cbiAqL1xuZnVuY3Rpb24gX19yZWFkRGVmYXVsdCAobm9kZSkge1xuICAgIHZhciBkYXRhID0ge307XG5cbiAgICAvLyBpZiBlbGVtZW50IG5vZGUgaGFzIGF0dHJpYnV0ZXMsIHNldCB0aGVpciB2YWx1ZXMgdG8gZGF0YVxuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZGF0YUF0dHJpYnV0ZXMgPSBfX2dldEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgICAgIGRhdGFbXCJhdHRyaWJ1dGVzXCJdID0gZGF0YUF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gaWYgZWxlbWVudCBub2RlIGhhcyBjaGlsZE5vZGVzLCByZWFkIHRoZW0gYW5kIHNldCB0aGVtIHRvIGRhdGFcbiAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdmFyIGNoaWxkRGF0YSA9IHt9O1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMpIHsgLy8gVEVYVF9OT0RFXG4gICAgICAgICAgICAgICAgZGF0YVtcInRleHRDb250ZW50XCJdID0gY2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoaWxkRGF0YSA9IF9fcmVhZERlZmF1bHQoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhW2NoaWxkLm5vZGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBjaGlsZERhdGEgaW4gYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbY2hpbGQubm9kZU5hbWVdID0gY2hpbGREYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugc2V2ZXJhbCBjaGlsZE5vZGVzIGhhcyB0aGUgc2FtZSBuYW1lIDogc3RvcmUgdGhlbSBpbiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGF0YVtub2RlTmFtZV0gYWxyZWFkeSBleGlzdHMgYnV0IGlzIG5vdCBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YVtjaGlsZC5ub2RlTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkID0gZGF0YVtjaGlsZC5ub2RlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2NoaWxkLm5vZGVOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtjaGlsZC5ub2RlTmFtZV0ucHVzaChvbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbY2hpbGQubm9kZU5hbWVdLnB1c2goY2hpbGREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIDogbWFuYWdlIG90aGVyIG5vZGUgdHlwZXMgKDQ9Q0RBVEEsIGV0YylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE3DqXRob2RlIGRlIGxhIGNsYXNzZSAocHJpdsOpZSkgcGVybWV0dGFudCBkZSByw6ljdXDDqXJlciBsZXMgYXR0cmlidXRzIGQndW4gbm9ldWQgw6lsw6ltZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBYTUxcbiAqIEBtZXRob2QgX19nZXRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCBjb250ZW5hbnQgbCdhdHRyaWJ1dCByZWNoZXJjaMOpXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5vZGVBdHRyaWJ1dGVzIC0gb2JqZXQgY29udGVuYW50IGxlcyBub21zIGV0IHZhbGV1cnMgZGVzIGRpZmbDqXJlbnRzIGF0dHJpYnV0c1xuICovXG5mdW5jdGlvbiBfX2dldEF0dHJpYnV0ZXMgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGVBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgbm9kZUF0dHJpYnV0ZXNbYXR0cmlidXRlLm5vZGVOYW1lXSA9IGF0dHJpYnV0ZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVBdHRyaWJ1dGVzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWE1MO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Formats/XML.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/JSONP.js":
/*!******************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/JSONP.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/**\n * JSONP : Implémentation du protocole JSONP de la plateforme Géoportail\n *\n * @module JSONP\n * @private\n * @alias Gp.Protocols.JSONP\n */\n\n\n// cf. https://github.com/sobstel/jsonp.js\nvar JSONP = {\n\n    /**\n     * Construction d'un identifiant statique basé sur le timestamp,\n     * et qui s'incremente de +1 à chaque appel\n     */\n    uuid : (function () {\n        var id = Math.floor(Date.now());\n        return function () {\n            return id++;\n        };\n    })(),\n\n    /**\n     * Cette fonction réalise l'appel du service fourni via le paramètre \"options.url\"\n     * en mettant en œuvre le protocole JSONP.\n     *\n     * @method call\n     * @static\n     * @param {Object} options - parametres d'invocation du service en JSONP\n     * @param {String} options.url - URL du service à invoquer (indépendamment du protocole JSONP).\n     *  Cette URL contient déjà les paramètres du service.\n     *  Si le paramètre dédié à la mise en oeuvre du protocole JSONP (callback=xxx) n'est pas présent, il est rajouté par la fonction ;\n     *  sa valeur est déterminée en fonction du paramètre callbackName.\n     * @param {Number} [options.timeOut = 0] - Nombre de ms au bout duquel on considère que le service n'a pas répondu.\n     *  Une valeur de 0 pour ce paramètre permet de désactiver la gestion du timeOut.\n     * @param {String} [options.callbackSuffix = null] - Suffixe de la fonction de callback à rajouter sur l'URL.\n     *  Si aucun suffixe n'est spécifié (cas par défaut), on utilisera l'identifiant this.uuid () comme suffixe. Ex: \"callback1458574396582 ()\"\n     * @param {String} [options.callbackName = gp.protocol.jsonp] - Valeur du paramètre callback à rajouter sur l'URL.\n     *  Si l'URL fournie contient déjà le paramètre callback, le paramètre callbackName ne sera pas pris en compte.\n     *  La fonction de callback est créée dynamiquement par la fonction JSONP ;\n     *  elle a deux fonctions :\n     *    elle annule la condition de timeOut\n     *    puis appelle la fonction fournie par l'utilisateur via le paramètre onResponse.\n     * @param {Function} options.onResponse - Nom de la fonction qui sera appelée lors de la réception des résultats du service.\n     *  Ce paramètre sera ignoré si l'URL contient déjà le paramètre callback.\n     *  La fonction de rappel appelée sera alors celle ayant pour nom la valeur de ce paramètre.\n     * @param {Function} [options.onTimeOut] - Nom de la fonction qui sera appelée en cas de non réponse du service.\n     *  Le temps au bout duquel on considère que le service n'a pas répondu est déterminé par le paramètre timeOut.\n     *  @example\n     *  var options = {\n     *      url : 'http://localhost/some/test.json&callback=myResults',\n     *      timeOut : 100,\n     *      callbackName : 'myResults',\n     *      callbackSuffix : \"\",\n     *      onResponse : function (response) {\n     *          console.log('results : ', response);\n     *      },\n     *\n     *   };\n     *   JSONP.call(options);\n     */\n    call : function (options) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"JSONP\");\n        logger.trace(\"[JSONP::call ()]\");\n\n        // analyse parametres\n\n        if (!options) {\n            logger.error(\"missing parameter : options !\");\n            throw new Error(\"missing parameter : options !\");\n        }\n\n        if (!options.url) {\n            logger.error(\"missing parameter : options.url !\");\n            throw new Error(\"missing parameter : options.url !\");\n        }\n\n        if (!options.timeOut) {\n            logger.info(\"setting 'options.timeOut' default value\");\n            options.timeOut = 0;\n        }\n\n        // FIXME si un callback coté client a été mis en place,\n        // cette condition sur cette methode n'a pas de sens !?\n        if (!options.onResponse) {\n            logger.error(\"missing parameter : options.onResponse !\");\n            throw new Error(\"missing parameter : options.onResponse !\");\n            // FIXME doit on definir un callback interne par defaut !?\n            // options.onResponse = function (data) {\n            //    console.log(\"response callback (inner) : \", data);\n            // };\n        }\n\n        // ID du callback à utiliser : null ou string.\n        // si l'utilisateur a spécifié un suffixe pour le callback, on le récupère comme un ID (ex: options.callbackSuffix = \"\")\n        // sinon, on utilise un timestamp : this.uuid ()\n        var callbackId = (typeof options.callbackSuffix === \"string\") ? options.callbackSuffix : this.uuid();\n\n        // on recherche le parametre callback et son nom de fonction dans l'url\n        var urlHasCallbackKey = false;\n        var urlHasCallbackName = false;\n\n        var idx = options.url.indexOf(\"callback=\");\n\n        if (idx !== -1) {\n            urlHasCallbackKey = true;\n            // extraction callbackName de l'url : entre \"callback=\" et \"&\" ou fin de ligne\n            var j = options.url.indexOf(\"&\", idx);\n            if (j === -1) {\n                j = options.url.length;\n            }\n\n            // on ecrase le parametre options.callbackName s'il avait été défini\n            var callbackName = options.url.substring(idx + 9, j);\n\n            if (callbackName) {\n                urlHasCallbackName = true;\n                options.callbackName = callbackName;\n                logger.info(\"setting 'options.callbackName' value (\" + options.callbackName + \") from 'options.url' parameter\");\n            }\n        }\n\n        // on ajoute le parametre callback dans l'URL s'il n'existe pas\n        if (!urlHasCallbackKey) {\n            // gestion des autres param. et \"?\"\n            var k = options.url.indexOf(\"?\");\n            if (k === -1) {\n                // aucun param., ni de '?'\n                options.url = options.url + \"?\" + \"callback=\";\n            } else if (k === options.url.length) {\n                // uniquement le '?'\n                options.url = options.url + \"callback=\";\n            } else {\n                // le '?' et les param. existent\n                options.url = options.url + \"&\" + \"callback=\";\n            }\n            logger.info(\"setting callback default key in 'options.url' : \" + options.url);\n        }\n\n        // utilisation de la fonction callback coté client ?\n        var HasCallbackName = options.callbackName ? true : urlHasCallbackName;\n\n        // on ajoute le nom de la fonction callback dans l'URL si elle n'existe pas\n        if (!urlHasCallbackName) {\n            // fonction callback par defaut\n            if (!options.callbackName) {\n                logger.info(\"setting 'options.callbackName' default value\");\n                options.callbackName = \"callback\"; // ou \"gp.protocol.jsonp\" ?\n                // info : si on ne veut pas gerer d'ID dans le callback,\n                // options.callbackSuffix = \"\"\n                if (callbackId || callbackId === \"\") {\n                    options.callbackName += callbackId;\n                }\n            }\n            options.url = options.url.replace(\"callback=\", \"callback=\" + options.callbackName);\n            logger.info(\"setting callback function name in 'options.url' : \" + options.url);\n        }\n\n        // timeOut par defaut\n        if (!options.onTimeOut) {\n            logger.info(\"setting 'options.onTimeOut' default value\");\n            /** callback timeout par defaut */\n            options.onTimeOut = function (/* error */) {\n                console.log(\"TimeOut while invoking url : \" + options.url);\n            };\n        }\n\n        if (!HasCallbackName) {\n            var self = this;\n\n            // event du timeout\n            var onTimeOutTrigger = null;\n\n            // declenche le timeout si > à 0 !\n            if (options.timeOut > 0) {\n                onTimeOutTrigger = window.setTimeout(\n                    function () {\n                        /** fonction de reponse du service */\n                        window[options.callbackName] = function () {};\n                        options.onTimeOut();\n                        self._deleteScript(callbackId);\n                    }, options.timeOut);\n            }\n\n            // FIXME le nom de la fonction n'accepte pas de namespace !\n            // ex. Gp.Function.callback\n            /**\n            * fonction de reponse du service\n            * @param {Object} data - data\n            * @private\n            */\n            window[options.callbackName] = function (data) {\n                window.clearTimeout(onTimeOutTrigger);\n                options.onResponse(data);\n                self._deleteScript(callbackId);\n            };\n        }\n\n        this._createScript(callbackId, options.url);\n    },\n\n    /**\n    * create Script\n    * @param {String} callbackId - callback Id\n    * @param {String} url - url\n    * @private\n    */\n    _createScript : function (callbackId, url) {\n        var scriptu;\n        var scripto = document.getElementById(\"results\" + callbackId);\n\n        scriptu = document.createElement(\"script\");\n        scriptu.setAttribute(\"type\", \"text/javascript\");\n        scriptu.setAttribute(\"src\", url);\n        scriptu.setAttribute(\"charset\", \"UTF-8\");\n        scriptu.setAttribute(\"id\", \"results\" + callbackId);\n        scriptu.setAttribute(\"async\", \"true\"); // FIXME async ?\n        // head ou body ou autres ?\n        var node = document.documentElement || document.getElementsByTagName(\"head\")[0];\n        if (scripto === null) {\n            node.appendChild(scriptu);\n        } else {\n            // s'il existe déjà, on le remplace !\n            node.replaceChild(scriptu, scripto);\n        }\n    },\n\n    /**\n    * delete Script\n    * @param {String} callbackId - callback Id\n    * @private\n    */\n    _deleteScript : function (callbackId) {\n        var script = document.getElementById(\"results\" + callbackId);\n        if (script) {\n            var node = script.parentNode || document.documentElement;\n            if (!node) {\n                return;\n            }\n            node.removeChild(script);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (JSONP);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9KU09OUC5qcz8zYjE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFNO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxvRUFBSyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2dlb3BvcnRhbC1hY2Nlc3MtbGliL3NyYy9Qcm90b2NvbHMvSlNPTlAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEpTT05QIDogSW1wbMOpbWVudGF0aW9uIGR1IHByb3RvY29sZSBKU09OUCBkZSBsYSBwbGF0ZWZvcm1lIEfDqW9wb3J0YWlsXG4gKlxuICogQG1vZHVsZSBKU09OUFxuICogQHByaXZhdGVcbiAqIEBhbGlhcyBHcC5Qcm90b2NvbHMuSlNPTlBcbiAqL1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cbi8vIGNmLiBodHRwczovL2dpdGh1Yi5jb20vc29ic3RlbC9qc29ucC5qc1xudmFyIEpTT05QID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0aW9uIGQndW4gaWRlbnRpZmlhbnQgc3RhdGlxdWUgYmFzw6kgc3VyIGxlIHRpbWVzdGFtcCxcbiAgICAgKiBldCBxdWkgcydpbmNyZW1lbnRlIGRlICsxIMOgIGNoYXF1ZSBhcHBlbFxuICAgICAqL1xuICAgIHV1aWQgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSBNYXRoLmZsb29yKERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKys7XG4gICAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIC8qKlxuICAgICAqIENldHRlIGZvbmN0aW9uIHLDqWFsaXNlIGwnYXBwZWwgZHUgc2VydmljZSBmb3VybmkgdmlhIGxlIHBhcmFtw6h0cmUgXCJvcHRpb25zLnVybFwiXG4gICAgICogZW4gbWV0dGFudCBlbiDFk3V2cmUgbGUgcHJvdG9jb2xlIEpTT05QLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjYWxsXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gcGFyYW1ldHJlcyBkJ2ludm9jYXRpb24gZHUgc2VydmljZSBlbiBKU09OUFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIFVSTCBkdSBzZXJ2aWNlIMOgIGludm9xdWVyIChpbmTDqXBlbmRhbW1lbnQgZHUgcHJvdG9jb2xlIEpTT05QKS5cbiAgICAgKiAgQ2V0dGUgVVJMIGNvbnRpZW50IGTDqWrDoCBsZXMgcGFyYW3DqHRyZXMgZHUgc2VydmljZS5cbiAgICAgKiAgU2kgbGUgcGFyYW3DqHRyZSBkw6lkacOpIMOgIGxhIG1pc2UgZW4gb2V1dnJlIGR1IHByb3RvY29sZSBKU09OUCAoY2FsbGJhY2s9eHh4KSBuJ2VzdCBwYXMgcHLDqXNlbnQsIGlsIGVzdCByYWpvdXTDqSBwYXIgbGEgZm9uY3Rpb24gO1xuICAgICAqICBzYSB2YWxldXIgZXN0IGTDqXRlcm1pbsOpZSBlbiBmb25jdGlvbiBkdSBwYXJhbcOodHJlIGNhbGxiYWNrTmFtZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZU91dCA9IDBdIC0gTm9tYnJlIGRlIG1zIGF1IGJvdXQgZHVxdWVsIG9uIGNvbnNpZMOocmUgcXVlIGxlIHNlcnZpY2UgbidhIHBhcyByw6lwb25kdS5cbiAgICAgKiAgVW5lIHZhbGV1ciBkZSAwIHBvdXIgY2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgZMOpc2FjdGl2ZXIgbGEgZ2VzdGlvbiBkdSB0aW1lT3V0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9IG51bGxdIC0gU3VmZml4ZSBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayDDoCByYWpvdXRlciBzdXIgbCdVUkwuXG4gICAgICogIFNpIGF1Y3VuIHN1ZmZpeGUgbidlc3Qgc3DDqWNpZmnDqSAoY2FzIHBhciBkw6lmYXV0KSwgb24gdXRpbGlzZXJhIGwnaWRlbnRpZmlhbnQgdGhpcy51dWlkICgpIGNvbW1lIHN1ZmZpeGUuIEV4OiBcImNhbGxiYWNrMTQ1ODU3NDM5NjU4MiAoKVwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNhbGxiYWNrTmFtZSA9IGdwLnByb3RvY29sLmpzb25wXSAtIFZhbGV1ciBkdSBwYXJhbcOodHJlIGNhbGxiYWNrIMOgIHJham91dGVyIHN1ciBsJ1VSTC5cbiAgICAgKiAgU2kgbCdVUkwgZm91cm5pZSBjb250aWVudCBkw6lqw6AgbGUgcGFyYW3DqHRyZSBjYWxsYmFjaywgbGUgcGFyYW3DqHRyZSBjYWxsYmFja05hbWUgbmUgc2VyYSBwYXMgcHJpcyBlbiBjb21wdGUuXG4gICAgICogIExhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIGVzdCBjcsOpw6llIGR5bmFtaXF1ZW1lbnQgcGFyIGxhIGZvbmN0aW9uIEpTT05QIDtcbiAgICAgKiAgZWxsZSBhIGRldXggZm9uY3Rpb25zIDpcbiAgICAgKiAgICBlbGxlIGFubnVsZSBsYSBjb25kaXRpb24gZGUgdGltZU91dFxuICAgICAqICAgIHB1aXMgYXBwZWxsZSBsYSBmb25jdGlvbiBmb3VybmllIHBhciBsJ3V0aWxpc2F0ZXVyIHZpYSBsZSBwYXJhbcOodHJlIG9uUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblJlc3BvbnNlIC0gTm9tIGRlIGxhIGZvbmN0aW9uIHF1aSBzZXJhIGFwcGVsw6llIGxvcnMgZGUgbGEgcsOpY2VwdGlvbiBkZXMgcsOpc3VsdGF0cyBkdSBzZXJ2aWNlLlxuICAgICAqICBDZSBwYXJhbcOodHJlIHNlcmEgaWdub3LDqSBzaSBsJ1VSTCBjb250aWVudCBkw6lqw6AgbGUgcGFyYW3DqHRyZSBjYWxsYmFjay5cbiAgICAgKiAgTGEgZm9uY3Rpb24gZGUgcmFwcGVsIGFwcGVsw6llIHNlcmEgYWxvcnMgY2VsbGUgYXlhbnQgcG91ciBub20gbGEgdmFsZXVyIGRlIGNlIHBhcmFtw6h0cmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25UaW1lT3V0XSAtIE5vbSBkZSBsYSBmb25jdGlvbiBxdWkgc2VyYSBhcHBlbMOpZSBlbiBjYXMgZGUgbm9uIHLDqXBvbnNlIGR1IHNlcnZpY2UuXG4gICAgICogIExlIHRlbXBzIGF1IGJvdXQgZHVxdWVsIG9uIGNvbnNpZMOocmUgcXVlIGxlIHNlcnZpY2UgbidhIHBhcyByw6lwb25kdSBlc3QgZMOpdGVybWluw6kgcGFyIGxlIHBhcmFtw6h0cmUgdGltZU91dC5cbiAgICAgKiAgQGV4YW1wbGVcbiAgICAgKiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAgICB1cmwgOiAnaHR0cDovL2xvY2FsaG9zdC9zb21lL3Rlc3QuanNvbiZjYWxsYmFjaz1teVJlc3VsdHMnLFxuICAgICAqICAgICAgdGltZU91dCA6IDEwMCxcbiAgICAgKiAgICAgIGNhbGxiYWNrTmFtZSA6ICdteVJlc3VsdHMnLFxuICAgICAqICAgICAgY2FsbGJhY2tTdWZmaXggOiBcIlwiLFxuICAgICAqICAgICAgb25SZXNwb25zZSA6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzIDogJywgcmVzcG9uc2UpO1xuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgfTtcbiAgICAgKiAgIEpTT05QLmNhbGwob3B0aW9ucyk7XG4gICAgICovXG4gICAgY2FsbCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuICAgICAgICB2YXIgbG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcihcIkpTT05QXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJbSlNPTlA6OmNhbGwgKCldXCIpO1xuXG4gICAgICAgIC8vIGFuYWx5c2UgcGFyYW1ldHJlc1xuXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwibWlzc2luZyBwYXJhbWV0ZXIgOiBvcHRpb25zICFcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHBhcmFtZXRlciA6IG9wdGlvbnMgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogb3B0aW9ucy51cmwgIVwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogb3B0aW9ucy51cmwgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy50aW1lT3V0KSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgJ29wdGlvbnMudGltZU91dCcgZGVmYXVsdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIG9wdGlvbnMudGltZU91dCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBzaSB1biBjYWxsYmFjayBjb3TDqSBjbGllbnQgYSDDqXTDqSBtaXMgZW4gcGxhY2UsXG4gICAgICAgIC8vIGNldHRlIGNvbmRpdGlvbiBzdXIgY2V0dGUgbWV0aG9kZSBuJ2EgcGFzIGRlIHNlbnMgIT9cbiAgICAgICAgaWYgKCFvcHRpb25zLm9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogb3B0aW9ucy5vblJlc3BvbnNlICFcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHBhcmFtZXRlciA6IG9wdGlvbnMub25SZXNwb25zZSAhXCIpO1xuICAgICAgICAgICAgLy8gRklYTUUgZG9pdCBvbiBkZWZpbmlyIHVuIGNhbGxiYWNrIGludGVybmUgcGFyIGRlZmF1dCAhP1xuICAgICAgICAgICAgLy8gb3B0aW9ucy5vblJlc3BvbnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2UgY2FsbGJhY2sgKGlubmVyKSA6IFwiLCBkYXRhKTtcbiAgICAgICAgICAgIC8vIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRCBkdSBjYWxsYmFjayDDoCB1dGlsaXNlciA6IG51bGwgb3Ugc3RyaW5nLlxuICAgICAgICAvLyBzaSBsJ3V0aWxpc2F0ZXVyIGEgc3DDqWNpZmnDqSB1biBzdWZmaXhlIHBvdXIgbGUgY2FsbGJhY2ssIG9uIGxlIHLDqWN1cMOocmUgY29tbWUgdW4gSUQgKGV4OiBvcHRpb25zLmNhbGxiYWNrU3VmZml4ID0gXCJcIilcbiAgICAgICAgLy8gc2lub24sIG9uIHV0aWxpc2UgdW4gdGltZXN0YW1wIDogdGhpcy51dWlkICgpXG4gICAgICAgIHZhciBjYWxsYmFja0lkID0gKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrU3VmZml4ID09PSBcInN0cmluZ1wiKSA/IG9wdGlvbnMuY2FsbGJhY2tTdWZmaXggOiB0aGlzLnV1aWQoKTtcblxuICAgICAgICAvLyBvbiByZWNoZXJjaGUgbGUgcGFyYW1ldHJlIGNhbGxiYWNrIGV0IHNvbiBub20gZGUgZm9uY3Rpb24gZGFucyBsJ3VybFxuICAgICAgICB2YXIgdXJsSGFzQ2FsbGJhY2tLZXkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVybEhhc0NhbGxiYWNrTmFtZSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBpZHggPSBvcHRpb25zLnVybC5pbmRleE9mKFwiY2FsbGJhY2s9XCIpO1xuXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICB1cmxIYXNDYWxsYmFja0tleSA9IHRydWU7XG4gICAgICAgICAgICAvLyBleHRyYWN0aW9uIGNhbGxiYWNrTmFtZSBkZSBsJ3VybCA6IGVudHJlIFwiY2FsbGJhY2s9XCIgZXQgXCImXCIgb3UgZmluIGRlIGxpZ25lXG4gICAgICAgICAgICB2YXIgaiA9IG9wdGlvbnMudXJsLmluZGV4T2YoXCImXCIsIGlkeCk7XG4gICAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBqID0gb3B0aW9ucy51cmwubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbiBlY3Jhc2UgbGUgcGFyYW1ldHJlIG9wdGlvbnMuY2FsbGJhY2tOYW1lIHMnaWwgYXZhaXQgw6l0w6kgZMOpZmluaVxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrTmFtZSA9IG9wdGlvbnMudXJsLnN1YnN0cmluZyhpZHggKyA5LCBqKTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrTmFtZSkge1xuICAgICAgICAgICAgICAgIHVybEhhc0NhbGxiYWNrTmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFja05hbWUgPSBjYWxsYmFja05hbWU7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nICdvcHRpb25zLmNhbGxiYWNrTmFtZScgdmFsdWUgKFwiICsgb3B0aW9ucy5jYWxsYmFja05hbWUgKyBcIikgZnJvbSAnb3B0aW9ucy51cmwnIHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uIGFqb3V0ZSBsZSBwYXJhbWV0cmUgY2FsbGJhY2sgZGFucyBsJ1VSTCBzJ2lsIG4nZXhpc3RlIHBhc1xuICAgICAgICBpZiAoIXVybEhhc0NhbGxiYWNrS2V5KSB7XG4gICAgICAgICAgICAvLyBnZXN0aW9uIGRlcyBhdXRyZXMgcGFyYW0uIGV0IFwiP1wiXG4gICAgICAgICAgICB2YXIgayA9IG9wdGlvbnMudXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gYXVjdW4gcGFyYW0uLCBuaSBkZSAnPydcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgXCI/XCIgKyBcImNhbGxiYWNrPVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrID09PSBvcHRpb25zLnVybC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmlxdWVtZW50IGxlICc/J1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBcImNhbGxiYWNrPVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsZSAnPycgZXQgbGVzIHBhcmFtLiBleGlzdGVudFxuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBcIiZcIiArIFwiY2FsbGJhY2s9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgY2FsbGJhY2sgZGVmYXVsdCBrZXkgaW4gJ29wdGlvbnMudXJsJyA6IFwiICsgb3B0aW9ucy51cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXRpbGlzYXRpb24gZGUgbGEgZm9uY3Rpb24gY2FsbGJhY2sgY290w6kgY2xpZW50ID9cbiAgICAgICAgdmFyIEhhc0NhbGxiYWNrTmFtZSA9IG9wdGlvbnMuY2FsbGJhY2tOYW1lID8gdHJ1ZSA6IHVybEhhc0NhbGxiYWNrTmFtZTtcblxuICAgICAgICAvLyBvbiBham91dGUgbGUgbm9tIGRlIGxhIGZvbmN0aW9uIGNhbGxiYWNrIGRhbnMgbCdVUkwgc2kgZWxsZSBuJ2V4aXN0ZSBwYXNcbiAgICAgICAgaWYgKCF1cmxIYXNDYWxsYmFja05hbWUpIHtcbiAgICAgICAgICAgIC8vIGZvbmN0aW9uIGNhbGxiYWNrIHBhciBkZWZhdXRcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jYWxsYmFja05hbWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgJ29wdGlvbnMuY2FsbGJhY2tOYW1lJyBkZWZhdWx0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tOYW1lID0gXCJjYWxsYmFja1wiOyAvLyBvdSBcImdwLnByb3RvY29sLmpzb25wXCIgP1xuICAgICAgICAgICAgICAgIC8vIGluZm8gOiBzaSBvbiBuZSB2ZXV0IHBhcyBnZXJlciBkJ0lEIGRhbnMgbGUgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9IFwiXCJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tJZCB8fCBjYWxsYmFja0lkID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tOYW1lICs9IGNhbGxiYWNrSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybC5yZXBsYWNlKFwiY2FsbGJhY2s9XCIsIFwiY2FsbGJhY2s9XCIgKyBvcHRpb25zLmNhbGxiYWNrTmFtZSk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldHRpbmcgY2FsbGJhY2sgZnVuY3Rpb24gbmFtZSBpbiAnb3B0aW9ucy51cmwnIDogXCIgKyBvcHRpb25zLnVybCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lT3V0IHBhciBkZWZhdXRcbiAgICAgICAgaWYgKCFvcHRpb25zLm9uVGltZU91dCkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nICdvcHRpb25zLm9uVGltZU91dCcgZGVmYXVsdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIC8qKiBjYWxsYmFjayB0aW1lb3V0IHBhciBkZWZhdXQgKi9cbiAgICAgICAgICAgIG9wdGlvbnMub25UaW1lT3V0ID0gZnVuY3Rpb24gKC8qIGVycm9yICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUaW1lT3V0IHdoaWxlIGludm9raW5nIHVybCA6IFwiICsgb3B0aW9ucy51cmwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghSGFzQ2FsbGJhY2tOYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50IGR1IHRpbWVvdXRcbiAgICAgICAgICAgIHZhciBvblRpbWVPdXRUcmlnZ2VyID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gZGVjbGVuY2hlIGxlIHRpbWVvdXQgc2kgPiDDoCAwICFcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgb25UaW1lT3V0VHJpZ2dlciA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogZm9uY3Rpb24gZGUgcmVwb25zZSBkdSBzZXJ2aWNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dbb3B0aW9ucy5jYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uVGltZU91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGVsZXRlU2NyaXB0KGNhbGxiYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVPdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRSBsZSBub20gZGUgbGEgZm9uY3Rpb24gbidhY2NlcHRlIHBhcyBkZSBuYW1lc3BhY2UgIVxuICAgICAgICAgICAgLy8gZXguIEdwLkZ1bmN0aW9uLmNhbGxiYWNrXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogZm9uY3Rpb24gZGUgcmVwb25zZSBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZGF0YVxuICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHdpbmRvd1tvcHRpb25zLmNhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQob25UaW1lT3V0VHJpZ2dlcik7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlc3BvbnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2RlbGV0ZVNjcmlwdChjYWxsYmFja0lkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jcmVhdGVTY3JpcHQoY2FsbGJhY2tJZCwgb3B0aW9ucy51cmwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIGNyZWF0ZSBTY3JpcHRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWxsYmFja0lkIC0gY2FsbGJhY2sgSWRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSB1cmxcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfY3JlYXRlU2NyaXB0IDogZnVuY3Rpb24gKGNhbGxiYWNrSWQsIHVybCkge1xuICAgICAgICB2YXIgc2NyaXB0dTtcbiAgICAgICAgdmFyIHNjcmlwdG8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc3VsdHNcIiArIGNhbGxiYWNrSWQpO1xuXG4gICAgICAgIHNjcmlwdHUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHR1LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2phdmFzY3JpcHRcIik7XG4gICAgICAgIHNjcmlwdHUuc2V0QXR0cmlidXRlKFwic3JjXCIsIHVybCk7XG4gICAgICAgIHNjcmlwdHUuc2V0QXR0cmlidXRlKFwiY2hhcnNldFwiLCBcIlVURi04XCIpO1xuICAgICAgICBzY3JpcHR1LnNldEF0dHJpYnV0ZShcImlkXCIsIFwicmVzdWx0c1wiICsgY2FsbGJhY2tJZCk7XG4gICAgICAgIHNjcmlwdHUuc2V0QXR0cmlidXRlKFwiYXN5bmNcIiwgXCJ0cnVlXCIpOyAvLyBGSVhNRSBhc3luYyA/XG4gICAgICAgIC8vIGhlYWQgb3UgYm9keSBvdSBhdXRyZXMgP1xuICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gICAgICAgIGlmIChzY3JpcHRvID09PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHNjcmlwdHUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcydpbCBleGlzdGUgZMOpasOgLCBvbiBsZSByZW1wbGFjZSAhXG4gICAgICAgICAgICBub2RlLnJlcGxhY2VDaGlsZChzY3JpcHR1LCBzY3JpcHRvKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIGRlbGV0ZSBTY3JpcHRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWxsYmFja0lkIC0gY2FsbGJhY2sgSWRcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfZGVsZXRlU2NyaXB0IDogZnVuY3Rpb24gKGNhbGxiYWNrSWQpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzdWx0c1wiICsgY2FsbGJhY2tJZCk7XG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2NyaXB0LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgSlNPTlA7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Protocols/JSONP.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/Protocol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/Protocol.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/Helper */ \"./node_modules/geoportal-access-lib/src/Utils/Helper.js\");\n/* harmony import */ var _XHR__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XHR */ \"./node_modules/geoportal-access-lib/src/Protocols/XHR.js\");\n/* harmony import */ var _JSONP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JSONP */ \"./node_modules/geoportal-access-lib/src/Protocols/JSONP.js\");\n/**\n * Interface de dialogue avec les webservices\n *\n * @module Protocols\n * @private\n * @alias Gp.Protocols\n */\n\n\n\n\nvar Protocol = {\n\n    /**\n     * Interface unique d\"envoi d\"une requête.\n     *\n     * @method send\n     * @static\n     * @param {Object} options - options generales\n     * @param {String} options.url      - url du service\n     * @param {String} options.method   - GET, POST, PUT, DELETE\n     * @param {String} options.protocol - XHR | JSONP\n     * @param {String} options.format   - format de la reponse du service : json, xml ou null (brute)...\n     * @param {String} options.wrap     - encapsuler la reponse du service dans du JSON : true|false (true par defaut sur le protocole JSONP)\n     * @param {String} options.callbackSuffix - suffixe de la fonction de callback (JSONP uniquement) (ex: si callbackSuffix=\"\", la fonction s'appellera \"callback\")\n     * @param {String} options.timeOut  - 0 ms\n     * @param {Boolean} options.nocache  - true|false\n     * @param {Object|String} options.data        - content (post) ou param (get)\n     * @param {Object|String} options.headers     - (post) ex. referer\n     * @param {Object|String} options.content - (post) ex. \"application/json\"\n     * @param {String} options.scope       - this (TODO)\n     * @param {Function} options.onResponse - callback\n     * @param {Function} options.onFailure - callback\n     * @param {Function} options.onTimeOut - callback\n     * @param {String} options.proxyUrl -  (TODO)\n     */\n    send : function (options) {\n        // INFO\n        // \"output\" - param est interne à la classe \"Protocol\" (parametrable via \"wrap\"), et à ajouter à l\"url\n        //      ce param est independant du service car il est géré par le filtre LUA :\n        //          ex. json|xml (json par defaut).\n        //          Ce param. permet d\"encapsuler du XML dans du JSON :\n        //              {http : {status:200, error:null},xml :\"réponse du service\"}\n        //          Utile pour les services qui ne repondent que du XML (ex. Geocodage)\n        //\n        // |-------------------------------------------------|\n        // |      \\service |      |     |                    |\n        // | output\\ format| json | xml |     remarques      |\n        // |--------\\------|------|-----|--------------------|\n        // |    json       | json | json| json/xml encapsulé |\n        // |    xml        | json | xml | param inactif      |\n        // |-------------------------------------------------|\n        // ex. le service demande une reponse native au \"format\" json et avec un \"output\" json.\n        // on a donc une reponse json encapsulé dans un json : ce qu'on ne souhaite pas !\n        // dans ce cas on ne renseigne pas output=json\n\n        // INFO\n        // \"wrap\" - choix d\"encapsuler ou non les reponses dans du JSON.\n        //      Par defaut, on encapsule uniquement les reponses sur le protocole JSONP (et qui sont en xml) !\n\n        // INFO\n        // \"callback\" - param est interne à la classe \"Protocol\" (non parametrable), et à ajouter à l\"url\n        //      ce param est independant du service car il est géré aussi par le filtre LUA :\n        //          ex. callback|null\n        //          Ce param. permet de renvoyer une reponse javascript :\n        //              callback ({http : {status:200, error:null},xml :\"réponse du service\"})\n        //          Ce param. est non renseigné par defaut car pour du JSONP, on utilise le\n        //          le protocol JSONP, et ce dernier implemente déjà le callback !\n\n        // settings par defaut\n        var settings = options || {\n            method : \"GET\",\n            // protocol : \"JSONP\",\n            protocol : \"XHR\",\n            timeOut : 0,\n            format : null,\n            wrap : true,\n            nocache : true,\n            output : \"json\",\n            callback : null,\n            callbackSuffix : null\n        };\n\n        // on determine l'environnement d'execution : browser ou non ?\n        // et on stoppe pour nodeJS... sur un protocole JSONP !\n        if (typeof window === \"undefined\" && options.protocol === \"JSONP\") {\n            console.log(\"Value (s) for parameter (s) 'protocol=JSONP (instead use XHR)' not supported to NodeJS\");\n            return;\n        }\n\n        if (options.protocol === \"XHR\" || options.format === \"json\") {\n            settings.wrap = false;\n        } else if (options.protocol === \"JSONP\" && options.format === \"xml\") {\n            settings.wrap = true;\n        }\n\n        settings.callback = null; // FIXME non géré !?\n        settings.output = settings.wrap ? \"json\" : null;\n\n        // on encapsule les reponses dans un objet JSON\n        if (settings.wrap) {\n            var params = {};\n            params.output = settings.output;\n            params.callback = settings.callback;\n            delete params.callback; // FIXME non géré !?\n            settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalyzeUrl(options.url, params);\n        }\n\n        // choix de l\"implementation :\n        // XHR ou JSONP\n        switch (settings.protocol) {\n            case \"XHR\":\n                // on normalise l'url (gestion du cache)\n                if (options.method === \"GET\" && options.nocache) {\n                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalyzeUrl(settings.url, {\n                        t : new Date().getTime()\n                    });\n                }\n                // appel du service en XHR\n                _XHR__WEBPACK_IMPORTED_MODULE_1__[\"default\"].call(settings);\n                break;\n            case \"JSONP\":\n\n                // on normalise l'url si les params. sont renseignés dans la string|object \"data\"\n                if (settings.data) {\n                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalyzeUrl(settings.url, settings.data);\n                }\n\n                // appel du service en JSONP\n                _JSONP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].call(settings);\n                break;\n            default:\n                throw new Error(\"protocol not supported (XHR|JSONP) !\");\n        }\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Protocol);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9Qcm90b2NvbC5qcz8yMjYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDYjtBQUNJOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUSx1QkFBdUIsMkJBQTJCO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQkFBMkIscURBQU07QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFNO0FBQ3pDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQUc7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFNO0FBQ3pDOztBQUVBO0FBQ0EsZ0JBQWdCLDhDQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsdUVBQVEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvUHJvdG9jb2xzL1Byb3RvY29sLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcmZhY2UgZGUgZGlhbG9ndWUgYXZlYyBsZXMgd2Vic2VydmljZXNcbiAqXG4gKiBAbW9kdWxlIFByb3RvY29sc1xuICogQHByaXZhdGVcbiAqIEBhbGlhcyBHcC5Qcm90b2NvbHNcbiAqL1xuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi4vVXRpbHMvSGVscGVyXCI7XG5pbXBvcnQgWEhSIGZyb20gXCIuL1hIUlwiO1xuaW1wb3J0IEpTT05QIGZyb20gXCIuL0pTT05QXCI7XG5cbnZhciBQcm90b2NvbCA9IHtcblxuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB1bmlxdWUgZFwiZW52b2kgZFwidW5lIHJlcXXDqnRlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZW5kXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBnZW5lcmFsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgICAgICAtIHVybCBkdSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubWV0aG9kICAgLSBHRVQsIFBPU1QsIFBVVCwgREVMRVRFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvdG9jb2wgLSBYSFIgfCBKU09OUFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZvcm1hdCAgIC0gZm9ybWF0IGRlIGxhIHJlcG9uc2UgZHUgc2VydmljZSA6IGpzb24sIHhtbCBvdSBudWxsIChicnV0ZSkuLi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy53cmFwICAgICAtIGVuY2Fwc3VsZXIgbGEgcmVwb25zZSBkdSBzZXJ2aWNlIGRhbnMgZHUgSlNPTiA6IHRydWV8ZmFsc2UgKHRydWUgcGFyIGRlZmF1dCBzdXIgbGUgcHJvdG9jb2xlIEpTT05QKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrU3VmZml4IC0gc3VmZml4ZSBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayAoSlNPTlAgdW5pcXVlbWVudCkgKGV4OiBzaSBjYWxsYmFja1N1ZmZpeD1cIlwiLCBsYSBmb25jdGlvbiBzJ2FwcGVsbGVyYSBcImNhbGxiYWNrXCIpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltZU91dCAgLSAwIG1zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm5vY2FjaGUgIC0gdHJ1ZXxmYWxzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0aW9ucy5kYXRhICAgICAgICAtIGNvbnRlbnQgKHBvc3QpIG91IHBhcmFtIChnZXQpXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zLmhlYWRlcnMgICAgIC0gKHBvc3QpIGV4LiByZWZlcmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zLmNvbnRlbnQgLSAocG9zdCkgZXguIFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2NvcGUgICAgICAgLSB0aGlzIChUT0RPKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25SZXNwb25zZSAtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbkZhaWx1cmUgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25UaW1lT3V0IC0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcm94eVVybCAtICAoVE9ETylcbiAgICAgKi9cbiAgICBzZW5kIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICAvLyBcIm91dHB1dFwiIC0gcGFyYW0gZXN0IGludGVybmUgw6AgbGEgY2xhc3NlIFwiUHJvdG9jb2xcIiAocGFyYW1ldHJhYmxlIHZpYSBcIndyYXBcIiksIGV0IMOgIGFqb3V0ZXIgw6AgbFwidXJsXG4gICAgICAgIC8vICAgICAgY2UgcGFyYW0gZXN0IGluZGVwZW5kYW50IGR1IHNlcnZpY2UgY2FyIGlsIGVzdCBnw6lyw6kgcGFyIGxlIGZpbHRyZSBMVUEgOlxuICAgICAgICAvLyAgICAgICAgICBleC4ganNvbnx4bWwgKGpzb24gcGFyIGRlZmF1dCkuXG4gICAgICAgIC8vICAgICAgICAgIENlIHBhcmFtLiBwZXJtZXQgZFwiZW5jYXBzdWxlciBkdSBYTUwgZGFucyBkdSBKU09OIDpcbiAgICAgICAgLy8gICAgICAgICAgICAgIHtodHRwIDoge3N0YXR1czoyMDAsIGVycm9yOm51bGx9LHhtbCA6XCJyw6lwb25zZSBkdSBzZXJ2aWNlXCJ9XG4gICAgICAgIC8vICAgICAgICAgIFV0aWxlIHBvdXIgbGVzIHNlcnZpY2VzIHF1aSBuZSByZXBvbmRlbnQgcXVlIGR1IFhNTCAoZXguIEdlb2NvZGFnZSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgIC8vIHwgICAgICBcXHNlcnZpY2UgfCAgICAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgLy8gfCBvdXRwdXRcXCBmb3JtYXR8IGpzb24gfCB4bWwgfCAgICAgcmVtYXJxdWVzICAgICAgfFxuICAgICAgICAvLyB8LS0tLS0tLS1cXC0tLS0tLXwtLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgIC8vIHwgICAganNvbiAgICAgICB8IGpzb24gfCBqc29ufCBqc29uL3htbCBlbmNhcHN1bMOpIHxcbiAgICAgICAgLy8gfCAgICB4bWwgICAgICAgIHwganNvbiB8IHhtbCB8IHBhcmFtIGluYWN0aWYgICAgICB8XG4gICAgICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAvLyBleC4gbGUgc2VydmljZSBkZW1hbmRlIHVuZSByZXBvbnNlIG5hdGl2ZSBhdSBcImZvcm1hdFwiIGpzb24gZXQgYXZlYyB1biBcIm91dHB1dFwiIGpzb24uXG4gICAgICAgIC8vIG9uIGEgZG9uYyB1bmUgcmVwb25zZSBqc29uIGVuY2Fwc3Vsw6kgZGFucyB1biBqc29uIDogY2UgcXUnb24gbmUgc291aGFpdGUgcGFzICFcbiAgICAgICAgLy8gZGFucyBjZSBjYXMgb24gbmUgcmVuc2VpZ25lIHBhcyBvdXRwdXQ9anNvblxuXG4gICAgICAgIC8vIElORk9cbiAgICAgICAgLy8gXCJ3cmFwXCIgLSBjaG9peCBkXCJlbmNhcHN1bGVyIG91IG5vbiBsZXMgcmVwb25zZXMgZGFucyBkdSBKU09OLlxuICAgICAgICAvLyAgICAgIFBhciBkZWZhdXQsIG9uIGVuY2Fwc3VsZSB1bmlxdWVtZW50IGxlcyByZXBvbnNlcyBzdXIgbGUgcHJvdG9jb2xlIEpTT05QIChldCBxdWkgc29udCBlbiB4bWwpICFcblxuICAgICAgICAvLyBJTkZPXG4gICAgICAgIC8vIFwiY2FsbGJhY2tcIiAtIHBhcmFtIGVzdCBpbnRlcm5lIMOgIGxhIGNsYXNzZSBcIlByb3RvY29sXCIgKG5vbiBwYXJhbWV0cmFibGUpLCBldCDDoCBham91dGVyIMOgIGxcInVybFxuICAgICAgICAvLyAgICAgIGNlIHBhcmFtIGVzdCBpbmRlcGVuZGFudCBkdSBzZXJ2aWNlIGNhciBpbCBlc3QgZ8OpcsOpIGF1c3NpIHBhciBsZSBmaWx0cmUgTFVBIDpcbiAgICAgICAgLy8gICAgICAgICAgZXguIGNhbGxiYWNrfG51bGxcbiAgICAgICAgLy8gICAgICAgICAgQ2UgcGFyYW0uIHBlcm1ldCBkZSByZW52b3llciB1bmUgcmVwb25zZSBqYXZhc2NyaXB0IDpcbiAgICAgICAgLy8gICAgICAgICAgICAgIGNhbGxiYWNrICh7aHR0cCA6IHtzdGF0dXM6MjAwLCBlcnJvcjpudWxsfSx4bWwgOlwicsOpcG9uc2UgZHUgc2VydmljZVwifSlcbiAgICAgICAgLy8gICAgICAgICAgQ2UgcGFyYW0uIGVzdCBub24gcmVuc2VpZ27DqSBwYXIgZGVmYXV0IGNhciBwb3VyIGR1IEpTT05QLCBvbiB1dGlsaXNlIGxlXG4gICAgICAgIC8vICAgICAgICAgIGxlIHByb3RvY29sIEpTT05QLCBldCBjZSBkZXJuaWVyIGltcGxlbWVudGUgZMOpasOgIGxlIGNhbGxiYWNrICFcblxuICAgICAgICAvLyBzZXR0aW5ncyBwYXIgZGVmYXV0XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgbWV0aG9kIDogXCJHRVRcIixcbiAgICAgICAgICAgIC8vIHByb3RvY29sIDogXCJKU09OUFwiLFxuICAgICAgICAgICAgcHJvdG9jb2wgOiBcIlhIUlwiLFxuICAgICAgICAgICAgdGltZU91dCA6IDAsXG4gICAgICAgICAgICBmb3JtYXQgOiBudWxsLFxuICAgICAgICAgICAgd3JhcCA6IHRydWUsXG4gICAgICAgICAgICBub2NhY2hlIDogdHJ1ZSxcbiAgICAgICAgICAgIG91dHB1dCA6IFwianNvblwiLFxuICAgICAgICAgICAgY2FsbGJhY2sgOiBudWxsLFxuICAgICAgICAgICAgY2FsbGJhY2tTdWZmaXggOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb24gZGV0ZXJtaW5lIGwnZW52aXJvbm5lbWVudCBkJ2V4ZWN1dGlvbiA6IGJyb3dzZXIgb3Ugbm9uID9cbiAgICAgICAgLy8gZXQgb24gc3RvcHBlIHBvdXIgbm9kZUpTLi4uIHN1ciB1biBwcm90b2NvbGUgSlNPTlAgIVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmFsdWUgKHMpIGZvciBwYXJhbWV0ZXIgKHMpICdwcm90b2NvbD1KU09OUCAoaW5zdGVhZCB1c2UgWEhSKScgbm90IHN1cHBvcnRlZCB0byBOb2RlSlNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PT0gXCJYSFJcIiB8fCBvcHRpb25zLmZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLndyYXAgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIgJiYgb3B0aW9ucy5mb3JtYXQgPT09IFwieG1sXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLndyYXAgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuY2FsbGJhY2sgPSBudWxsOyAvLyBGSVhNRSBub24gZ8OpcsOpICE/XG4gICAgICAgIHNldHRpbmdzLm91dHB1dCA9IHNldHRpbmdzLndyYXAgPyBcImpzb25cIiA6IG51bGw7XG5cbiAgICAgICAgLy8gb24gZW5jYXBzdWxlIGxlcyByZXBvbnNlcyBkYW5zIHVuIG9iamV0IEpTT05cbiAgICAgICAgaWYgKHNldHRpbmdzLndyYXApIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5vdXRwdXQgPSBzZXR0aW5ncy5vdXRwdXQ7XG4gICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2sgPSBzZXR0aW5ncy5jYWxsYmFjaztcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuY2FsbGJhY2s7IC8vIEZJWE1FIG5vbiBnw6lyw6kgIT9cbiAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IEhlbHBlci5ub3JtYWx5emVVcmwob3B0aW9ucy51cmwsIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaG9peCBkZSBsXCJpbXBsZW1lbnRhdGlvbiA6XG4gICAgICAgIC8vIFhIUiBvdSBKU09OUFxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLnByb3RvY29sKSB7XG4gICAgICAgICAgICBjYXNlIFwiWEhSXCI6XG4gICAgICAgICAgICAgICAgLy8gb24gbm9ybWFsaXNlIGwndXJsIChnZXN0aW9uIGR1IGNhY2hlKVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBvcHRpb25zLm5vY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudXJsID0gSGVscGVyLm5vcm1hbHl6ZVVybChzZXR0aW5ncy51cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwZWwgZHUgc2VydmljZSBlbiBYSFJcbiAgICAgICAgICAgICAgICBYSFIuY2FsbChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSlNPTlBcIjpcblxuICAgICAgICAgICAgICAgIC8vIG9uIG5vcm1hbGlzZSBsJ3VybCBzaSBsZXMgcGFyYW1zLiBzb250IHJlbnNlaWduw6lzIGRhbnMgbGEgc3RyaW5nfG9iamVjdCBcImRhdGFcIlxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IEhlbHBlci5ub3JtYWx5emVVcmwoc2V0dGluZ3MudXJsLCBzZXR0aW5ncy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhcHBlbCBkdSBzZXJ2aWNlIGVuIEpTT05QXG4gICAgICAgICAgICAgICAgSlNPTlAuY2FsbChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb3RvY29sIG5vdCBzdXBwb3J0ZWQgKFhIUnxKU09OUCkgIVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvdG9jb2w7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Protocols/Protocol.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/XHR.js":
/*!****************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/XHR.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/Helper */ \"./node_modules/geoportal-access-lib/src/Utils/Helper.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(es6_promise__WEBPACK_IMPORTED_MODULE_2__);\n/* global Promise, require, XDomainRequest */\n\n\n\n\n// import __request from \"request\";\n// import __xmldom from \"xmldom\";\n\n/**\n * Ajax Request (use of Promises)\n *\n * @module XHR\n * @alias Gp.Protocols.XHR\n * @see dependance 'es6-promise'\n */\n\n// cf. https://xhr.spec.whatwg.org/\n// cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\nvar XHR = {\n\n    /**\n     * Interface unique d'envoi d'une requête.\n     *\n     * @method call\n     * @static\n     * @param {Object} settings - options generales\n     * @param {String} settings.url    - url du service\n     * @param {String} settings.method - GET, POST, PUT, DELETE\n     * @param {String} settings.format - format de la reponse du service : json, xml ou null (brute)\n     * @param {String} settings.data   - content (post) ou param (get)\n     * @param {String} settings.proxy  - proxy url\n     * @param {Object|String} settings.headers - (post) ex. referer\n     * @param {Object|String} settings.content - (post) ex. 'application/json'\n     * @param {String} settings.timeOut - timeout = 0 par defaut\n     * @param {String} settings.scope - this\n     * @param {Function} settings.onResponse - callback\n     * @param {Function} settings.onFailure  - callback\n     */\n    call : function (settings) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"XHR\");\n        logger.trace(\"[XHR::call()]\");\n\n        // FIXME\n        // To polyfill the global environment\n        es6_promise__WEBPACK_IMPORTED_MODULE_2___default.a.polyfill();\n\n        // test sur les settings obligatoires\n        if (!settings.url) {\n            throw new Error(\"missing parameter : url is not defined !\");\n        }\n\n        if (!settings.method) {\n            throw new Error(\"missing parameter : method is not defined !\");\n        }\n\n        if (!settings.format) {\n            settings.format = \"text\"; // reponse brute !\n        }\n\n        var options = {};\n        options.url = settings.url;\n        options.data = settings.data ? settings.data : null;\n        options.method = settings.method;\n        options.timeOut = settings.timeOut || 0;\n        options.scope = settings.scope || this;\n        options.proxy = settings.proxy || null;\n        options.content = settings.content || null;\n        options.headers = settings.headers || {\n            referer : \"http://localhost\"\n        };\n\n        // test sur les valeurs de 'settings.method'\n        switch (settings.method) {\n            case \"DELETE\":\n            case \"GET\":\n                break;\n            case \"PUT\":\n            case \"POST\":\n                // on force sur ces params spécifiques au mode POST\n                options.content = settings.content ? settings.content : \"application/x-www-form-urlencoded\"; // FIXME en attente des services : bascule en \"application/xml\" ou \"application/json\"\n                options.headers = settings.headers ? settings.headers : { referer : \"http://localhost\" }; // FIXME parametrable...\n                break;\n            case \"HEAD\":\n            case \"OPTIONS\":\n                throw new Error(\"HTTP method not yet supported !\");\n            default:\n                throw new Error(\"HTTP method unknown !\");\n        }\n\n        // test sur les valeurs de 'settings.format'\n        switch (settings.format) {\n            case \"text\":\n                this.__call(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            case \"json\":\n                this.__callJSON(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            case \"xml\":\n                this.__callXML(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            default:\n                throw new Error(\"This output Format is not yet supported !\");\n        }\n    },\n\n    /**\n     * Requete\n     *\n     * @method __call\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __call : function (options) {\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"XHR\");\n        logger.trace(\"[XHR::__call()]\");\n\n        var promise = new Promise(\n            function (resolve, reject) {\n                // traitement du corps de la requête\n                var corps = (options.method === \"POST\" || options.method === \"PUT\") ? 1 : 0;\n\n                // seulement si options.data n'est pas vide (peut être un objet ou une chaine de caractères)\n                if (options.data && ((typeof options.data === \"object\" && Object.keys(options.data).length) || (typeof options.data === \"string\" && options.data.length)) && !corps) {\n                    if (options.scope.CLASSNAME === \"Geocode\" || options.scope.CLASSNAME === \"ReverseGeocode\") {\n                        options.url = options.url + options.data;\n                    } else {\n                        options.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(options.url, options.data);\n                    }\n                }\n\n                logger.trace(\"URL = \", options.url);\n\n                var hXHR = null;\n\n                // test on env. nodejs or browser\n                if (typeof window === \"undefined\") {\n                    var nodefetch = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n\n                    var opts = {\n                        headers : {\n                            Referer : \"https://localhost\"\n                        }\n                    };\n\n                    if (options.data && typeof options.data === \"string\" && corps) {\n                        opts = {\n                            method : options.method,\n                            body : options.data,\n                            headers : {\n                                \"Content-Type\" : options.content,\n                                Referer : \"https://localhost\"\n                            }\n                        };\n                    }\n\n                    return nodefetch(options.url, opts)\n                        .then(function (response) {\n                            if (response.ok) { // res.status >= 200 && res.status < 300\n                                resolve(response.text());\n                            } else {\n                                var message = \"Errors Occured on Http Request (status : '\" + response.statusText + \"' | url : '\" + response.url + \"')\";\n                                var status = response.status;\n                                reject({\n                                    message : message,\n                                    status : status\n                                });\n                            }\n                        })\n                        .catch(function (e) {\n                            reject({\n                                message : e,\n                                status : -1\n                            });\n                        });\n                } else {\n                    if (window.XMLHttpRequest) {\n                        logger.trace(\"XMLHttpRequest\");\n\n                        hXHR = new XMLHttpRequest();\n                        hXHR.open(options.method, options.url, true); // async\n                        hXHR.overrideMimeType = options.content;\n\n                        // gestion du timeout\n                        var onTimeOutTrigger = null;\n                        if (options.timeOut > 0) {\n                            // FIXME le timeout interne ne me permet pas de declencher le bon message...\n                            // hXHR.timeout = options.timeOut;\n                            logger.trace(\"XHR - TimeOut actif !\");\n                            /**\n                             * Description\n                             *\n                             * @method onTimeOutTrigger\n                             * @private\n                             */\n                            onTimeOutTrigger = window.setTimeout(\n                                function () {\n                                    var message = \"TimeOut Occured on Http Request with XMLHttpRequest !\";\n                                    reject({\n                                        message : message,\n                                        status : -1\n                                    });\n                                }, options.timeOut);\n                        }\n\n                        if (corps) {\n                            // headers, data, content of data\n                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader\n                            logger.trace(\"data = \", options.data);\n                            hXHR.setRequestHeader(\"Content-type\", options.content);\n                            // FIXME refused to set unsafe header content-length javascript\n                            // hXHR.setRequestHeader (\"Content-length\", options.data.length);\n                            // hXHR.setRequestHeader (\"Referer\", options.headers.referer);\n                        }\n\n                        /**\n                         * On Error\n                         * FIXME ne se declenche pas !?\n                         *\n                         * @param {Object} e - Event\n                         * @method onerror\n                         * @private\n                         */\n                        hXHR.onerror = function (e) {\n                            console.log(e);\n                            reject(new Error(\"Errors Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * On Timeout\n                         * FIXME ne se declenche pas !?\n                         *\n                         * @param {Object} e - Event\n                         * @method ontimeout\n                         * @private\n                         */\n                        hXHR.ontimeout = function (e) {\n                            console.log(e);\n                            reject(new Error(\"TimeOut Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * Description\n                         *\n                         * @method onreadystatechange\n                         * @private\n                         */\n                        hXHR.onreadystatechange = function (e) {\n                            if (hXHR.readyState === 4) { // DONE\n                                if (hXHR.status === 200) {\n                                    window.clearTimeout(onTimeOutTrigger);\n                                    resolve(hXHR.response);\n                                } else {\n                                    var message = \"Errors Occured on Http Request (status : '\" + e.target.statusText + \"' | url : '\" + e.target.responseURL + \"' | response : '\" + e.target.response + \"')\";\n                                    var status = e.target.status;\n                                    reject({\n                                        message : message,\n                                        status : status\n                                    });\n                                }\n                            }\n                        };\n\n                        // gestion du content data\n                        var data4xhr = (options.data && corps) ? options.data : null;\n\n                        hXHR.send(data4xhr);\n                    } else if (window.XDomainRequest) {\n                        // worked in Internet Explorer 8–10 only !\n                        logger.trace(\"XDomainRequest\");\n\n                        hXHR = new XDomainRequest();\n                        hXHR.open(options.method, options.url);\n\n                        hXHR.overrideMimeType = options.content;\n\n                        if (options.timeOut > 0) {\n                            hXHR.timeout = options.timeout;\n                            logger.trace(\"XHR - TimeOut actif !\");\n                        }\n\n                        if (corps) {\n                            // headers, data, content of data\n                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader\n                            hXHR.setRequestHeader(\"Content-type\", options.content);\n                            // FIXME refused to set unsafe header content-length javascript\n                            // hXHR.setRequestHeader (\"Content-length\", options.data.length);\n                            // hXHR.setRequestHeader (\"Referer\", options.headers.referer);\n                        }\n\n                        /**\n                         * Description\n                         *\n                         * @method onerror\n                         * @private\n                         */\n                        hXHR.onerror = function () {\n                            reject(new Error(\"Errors Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * Description\n                         *\n                         * @method ontimeout\n                         * @private\n                         */\n                        hXHR.ontimeout = function () {\n                            reject(new Error(\"TimeOut Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * On Load\n                         *\n                         * @method onload\n                         * @private\n                         */\n                        hXHR.onload = function (e) {\n                            if (hXHR.status === 200) {\n                                resolve(hXHR.responseText);\n                            } else {\n                                var message = \"Errors Occured on Http Request (status : '\" + e.target.statusText + \"' | url : '\" + e.target.responseURL + \"')\";\n                                var status = e.target.status;\n                                reject({\n                                    message : message,\n                                    status : status\n                                });\n                            }\n                        };\n\n                        var data4xdr = (options.data && corps) ? options.data : null;\n\n                        hXHR.send(data4xdr);\n                    } else {\n                        throw new Error(\"CORS not supported\");\n                    }\n                }\n            }\n        );\n\n        return promise;\n    },\n\n    /**\n     * Requete avec parser JSON\n     *\n     * @method __callJSON\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __callJSON : function (options) {\n        return this.__call(options)\n            .then(JSON.parse)\n            .catch(function (error) {\n                console.log(\"_callJSON failed on : \", options.url, error);\n                // FIXME pas d'exception, laissons le fil se derouler...\n                // throw error;\n            });\n    },\n\n    /**\n     * Requete avec parser XML\n     *\n     * @method __callXML\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __callXML : function (options) {\n        return this.__call(options)\n            .then(function (response) {\n                var xmlDoc;\n\n                // test on env. nodejs or browser\n                if (typeof window === \"undefined\") {\n                    var DOMParser = __webpack_require__(/*! xmldom */ \"xmldom\").DOMParser; // __xmldom.DOMParser\n                    xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n                } else {\n                    if (window.DOMParser) {\n                        var parser = new window.DOMParser();\n                        xmlDoc = parser.parseFromString(response, \"text/xml\");\n                    } else { // IE\n                        xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n                        xmlDoc.async = false;\n                        xmlDoc.loadXML(response);\n                    }\n                }\n\n                return xmlDoc;\n            })\n            .catch(function (error) {\n                console.log(\"__callXML failed on : \", options.url, error);\n                // FIXME pas d'exception, laissons le fil se derouler...\n                // throw error;\n            });\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (XHR);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9YSFIuanM/MGM1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRThDO0FBQ1Q7QUFDQTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBTTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxrREFBVTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1Ryx5RUFBeUUsZ0NBQWdDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtB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QUVBOztBQUVlLGtFQUFHLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1Byb3RvY29scy9YSFIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgUHJvbWlzZSwgcmVxdWlyZSwgWERvbWFpblJlcXVlc3QgKi9cblxuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgSGVscGVyIGZyb20gXCIuLi9VdGlscy9IZWxwZXJcIjtcbmltcG9ydCBFUzZQcm9taXNlIGZyb20gXCJlczYtcHJvbWlzZVwiO1xuLy8gaW1wb3J0IF9fcmVxdWVzdCBmcm9tIFwicmVxdWVzdFwiO1xuLy8gaW1wb3J0IF9feG1sZG9tIGZyb20gXCJ4bWxkb21cIjtcblxuLyoqXG4gKiBBamF4IFJlcXVlc3QgKHVzZSBvZiBQcm9taXNlcylcbiAqXG4gKiBAbW9kdWxlIFhIUlxuICogQGFsaWFzIEdwLlByb3RvY29scy5YSFJcbiAqIEBzZWUgZGVwZW5kYW5jZSAnZXM2LXByb21pc2UnXG4gKi9cblxuLy8gY2YuIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy9cbi8vIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3RcblxudmFyIFhIUiA9IHtcblxuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB1bmlxdWUgZCdlbnZvaSBkJ3VuZSByZXF1w6p0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2FsbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgLSBvcHRpb25zIGdlbmVyYWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy51cmwgICAgLSB1cmwgZHUgc2VydmljZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5tZXRob2QgLSBHRVQsIFBPU1QsIFBVVCwgREVMRVRFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmZvcm1hdCAtIGZvcm1hdCBkZSBsYSByZXBvbnNlIGR1IHNlcnZpY2UgOiBqc29uLCB4bWwgb3UgbnVsbCAoYnJ1dGUpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmRhdGEgICAtIGNvbnRlbnQgKHBvc3QpIG91IHBhcmFtIChnZXQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnByb3h5ICAtIHByb3h5IHVybFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2V0dGluZ3MuaGVhZGVycyAtIChwb3N0KSBleC4gcmVmZXJlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2V0dGluZ3MuY29udGVudCAtIChwb3N0KSBleC4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnRpbWVPdXQgLSB0aW1lb3V0ID0gMCBwYXIgZGVmYXV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnNjb3BlIC0gdGhpc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm9uUmVzcG9uc2UgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm9uRmFpbHVyZSAgLSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNhbGwgOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiWEhSXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJbWEhSOjpjYWxsKCldXCIpO1xuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIFRvIHBvbHlmaWxsIHRoZSBnbG9iYWwgZW52aXJvbm1lbnRcbiAgICAgICAgRVM2UHJvbWlzZS5wb2x5ZmlsbCgpO1xuXG4gICAgICAgIC8vIHRlc3Qgc3VyIGxlcyBzZXR0aW5ncyBvYmxpZ2F0b2lyZXNcbiAgICAgICAgaWYgKCFzZXR0aW5ncy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogdXJsIGlzIG5vdCBkZWZpbmVkICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNldHRpbmdzLm1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwYXJhbWV0ZXIgOiBtZXRob2QgaXMgbm90IGRlZmluZWQgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2V0dGluZ3MuZm9ybWF0KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5mb3JtYXQgPSBcInRleHRcIjsgLy8gcmVwb25zZSBicnV0ZSAhXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgb3B0aW9ucy5kYXRhID0gc2V0dGluZ3MuZGF0YSA/IHNldHRpbmdzLmRhdGEgOiBudWxsO1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IHNldHRpbmdzLm1ldGhvZDtcbiAgICAgICAgb3B0aW9ucy50aW1lT3V0ID0gc2V0dGluZ3MudGltZU91dCB8fCAwO1xuICAgICAgICBvcHRpb25zLnNjb3BlID0gc2V0dGluZ3Muc2NvcGUgfHwgdGhpcztcbiAgICAgICAgb3B0aW9ucy5wcm94eSA9IHNldHRpbmdzLnByb3h5IHx8IG51bGw7XG4gICAgICAgIG9wdGlvbnMuY29udGVudCA9IHNldHRpbmdzLmNvbnRlbnQgfHwgbnVsbDtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycyB8fCB7XG4gICAgICAgICAgICByZWZlcmVyIDogXCJodHRwOi8vbG9jYWxob3N0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0ZXN0IHN1ciBsZXMgdmFsZXVycyBkZSAnc2V0dGluZ3MubWV0aG9kJ1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcIkRFTEVURVwiOlxuICAgICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICAgICAgY2FzZSBcIlBPU1RcIjpcbiAgICAgICAgICAgICAgICAvLyBvbiBmb3JjZSBzdXIgY2VzIHBhcmFtcyBzcMOpY2lmaXF1ZXMgYXUgbW9kZSBQT1NUXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50ID0gc2V0dGluZ3MuY29udGVudCA/IHNldHRpbmdzLmNvbnRlbnQgOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiOyAvLyBGSVhNRSBlbiBhdHRlbnRlIGRlcyBzZXJ2aWNlcyA6IGJhc2N1bGUgZW4gXCJhcHBsaWNhdGlvbi94bWxcIiBvdSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHNldHRpbmdzLmhlYWRlcnMgPyBzZXR0aW5ncy5oZWFkZXJzIDogeyByZWZlcmVyIDogXCJodHRwOi8vbG9jYWxob3N0XCIgfTsgLy8gRklYTUUgcGFyYW1ldHJhYmxlLi4uXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSEVBRFwiOlxuICAgICAgICAgICAgY2FzZSBcIk9QVElPTlNcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIVFRQIG1ldGhvZCBub3QgeWV0IHN1cHBvcnRlZCAhXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIVFRQIG1ldGhvZCB1bmtub3duICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXN0IHN1ciBsZXMgdmFsZXVycyBkZSAnc2V0dGluZ3MuZm9ybWF0J1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FsbChvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblJlc3BvbnNlLmNhbGwodGhpcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbkZhaWx1cmUuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FsbEpTT04ob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25SZXNwb25zZS5jYWxsKHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25GYWlsdXJlLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ4bWxcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FsbFhNTChvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblJlc3BvbnNlLmNhbGwodGhpcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbkZhaWx1cmUuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG91dHB1dCBGb3JtYXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgIVwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXRlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9fY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvbWlzZVxuICAgICAqL1xuICAgIF9fY2FsbCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiWEhSXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJbWEhSOjpfX2NhbGwoKV1cIik7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmFpdGVtZW50IGR1IGNvcnBzIGRlIGxhIHJlcXXDqnRlXG4gICAgICAgICAgICAgICAgdmFyIGNvcnBzID0gKG9wdGlvbnMubWV0aG9kID09PSBcIlBPU1RcIiB8fCBvcHRpb25zLm1ldGhvZCA9PT0gXCJQVVRcIikgPyAxIDogMDtcblxuICAgICAgICAgICAgICAgIC8vIHNldWxlbWVudCBzaSBvcHRpb25zLmRhdGEgbidlc3QgcGFzIHZpZGUgKHBldXQgw6p0cmUgdW4gb2JqZXQgb3UgdW5lIGNoYWluZSBkZSBjYXJhY3TDqHJlcylcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhICYmICgodHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhvcHRpb25zLmRhdGEpLmxlbmd0aCkgfHwgKHR5cGVvZiBvcHRpb25zLmRhdGEgPT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5kYXRhLmxlbmd0aCkpICYmICFjb3Jwcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zY29wZS5DTEFTU05BTUUgPT09IFwiR2VvY29kZVwiIHx8IG9wdGlvbnMuc2NvcGUuQ0xBU1NOQU1FID09PSBcIlJldmVyc2VHZW9jb2RlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgKyBvcHRpb25zLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IEhlbHBlci5ub3JtYWx5emVVcmwob3B0aW9ucy51cmwsIG9wdGlvbnMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJVUkwgPSBcIiwgb3B0aW9ucy51cmwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhYSFIgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBvbiBlbnYuIG5vZGVqcyBvciBicm93c2VyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVmZXRjaCA9IHJlcXVpcmUoXCJub2RlLWZldGNoXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWZlcmVyIDogXCJodHRwczovL2xvY2FsaG9zdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiB0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSBcInN0cmluZ1wiICYmIGNvcnBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIiA6IG9wdGlvbnMuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVmZXJlciA6IFwiaHR0cHM6Ly9sb2NhbGhvc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZWZldGNoKG9wdGlvbnMudXJsLCBvcHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7IC8vIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJFcnJvcnMgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3QgKHN0YXR1cyA6ICdcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQgKyBcIicgfCB1cmwgOiAnXCIgKyByZXNwb25zZS51cmwgKyBcIicpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJYTUxIdHRwUmVxdWVzdFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUiA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCwgdHJ1ZSk7IC8vIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm92ZXJyaWRlTWltZVR5cGUgPSBvcHRpb25zLmNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdlc3Rpb24gZHUgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uVGltZU91dFRyaWdnZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZU91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBsZSB0aW1lb3V0IGludGVybmUgbmUgbWUgcGVybWV0IHBhcyBkZSBkZWNsZW5jaGVyIGxlIGJvbiBtZXNzYWdlLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaFhIUi50aW1lb3V0ID0gb3B0aW9ucy50aW1lT3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlhIUiAtIFRpbWVPdXQgYWN0aWYgIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1ldGhvZCBvblRpbWVPdXRUcmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblRpbWVPdXRUcmlnZ2VyID0gd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJUaW1lT3V0IE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IHdpdGggWE1MSHR0cFJlcXVlc3QgIVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3Jwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlYWRlcnMsIGRhdGEsIGNvbnRlbnQgb2YgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNmLiBodHRwczovL2R2Y3MudzMub3JnL2hnL3hoci9yYXctZmlsZS90aXAvT3ZlcnZpZXcuaHRtbCNkb20teG1saHR0cHJlcXVlc3Qtc2V0cmVxdWVzdGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImRhdGEgPSBcIiwgb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgb3B0aW9ucy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSByZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIGNvbnRlbnQtbGVuZ3RoIGphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoWEhSLnNldFJlcXVlc3RIZWFkZXIgKFwiQ29udGVudC1sZW5ndGhcIiwgb3B0aW9ucy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaFhIUi5zZXRSZXF1ZXN0SGVhZGVyIChcIlJlZmVyZXJcIiwgb3B0aW9ucy5oZWFkZXJzLnJlZmVyZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIE9uIEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGSVhNRSBuZSBzZSBkZWNsZW5jaGUgcGFzICE/XG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1ldGhvZCBvbmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvcnMgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogT24gVGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICogRklYTUUgbmUgc2UgZGVjbGVuY2hlIHBhcyAhP1xuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb250aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9udGltZW91dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVPdXQgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoWEhSLnJlYWR5U3RhdGUgPT09IDQpIHsgLy8gRE9ORVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaFhIUi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChvblRpbWVPdXRUcmlnZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaFhIUi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXJyb3JzIE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IChzdGF0dXMgOiAnXCIgKyBlLnRhcmdldC5zdGF0dXNUZXh0ICsgXCInIHwgdXJsIDogJ1wiICsgZS50YXJnZXQucmVzcG9uc2VVUkwgKyBcIicgfCByZXNwb25zZSA6ICdcIiArIGUudGFyZ2V0LnJlc3BvbnNlICsgXCInKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGUudGFyZ2V0LnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdlc3Rpb24gZHUgY29udGVudCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YTR4aHIgPSAob3B0aW9ucy5kYXRhICYmIGNvcnBzKSA/IG9wdGlvbnMuZGF0YSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIuc2VuZChkYXRhNHhocik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOOKAkzEwIG9ubHkgIVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiWERvbWFpblJlcXVlc3RcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIub3BlbihvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm92ZXJyaWRlTWltZVR5cGUgPSBvcHRpb25zLmNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlhIUiAtIFRpbWVPdXQgYWN0aWYgIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVycywgZGF0YSwgY29udGVudCBvZiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vZHZjcy53My5vcmcvaGcveGhyL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2RvbS14bWxodHRwcmVxdWVzdC1zZXRyZXF1ZXN0aGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIG9wdGlvbnMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgcmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBjb250ZW50LWxlbmd0aCBqYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaFhIUi5zZXRSZXF1ZXN0SGVhZGVyIChcIkNvbnRlbnQtbGVuZ3RoXCIsIG9wdGlvbnMuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhYSFIuc2V0UmVxdWVzdEhlYWRlciAoXCJSZWZlcmVyXCIsIG9wdGlvbnMuaGVhZGVycy5yZWZlcmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb25lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvcnMgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIG9udGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVPdXQgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogT24gTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb25sb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhYSFIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShoWEhSLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkVycm9ycyBPY2N1cmVkIG9uIEh0dHAgUmVxdWVzdCAoc3RhdHVzIDogJ1wiICsgZS50YXJnZXQuc3RhdHVzVGV4dCArIFwiJyB8IHVybCA6ICdcIiArIGUudGFyZ2V0LnJlc3BvbnNlVVJMICsgXCInKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gZS50YXJnZXQuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGE0eGRyID0gKG9wdGlvbnMuZGF0YSAmJiBjb3JwcykgPyBvcHRpb25zLmRhdGEgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLnNlbmQoZGF0YTR4ZHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ09SUyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXRlIGF2ZWMgcGFyc2VyIEpTT05cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX19jYWxsSlNPTlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvbWlzZVxuICAgICAqL1xuICAgIF9fY2FsbEpTT04gOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhbGwob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKEpTT04ucGFyc2UpXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJfY2FsbEpTT04gZmFpbGVkIG9uIDogXCIsIG9wdGlvbnMudXJsLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgcGFzIGQnZXhjZXB0aW9uLCBsYWlzc29ucyBsZSBmaWwgc2UgZGVyb3VsZXIuLi5cbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXRlIGF2ZWMgcGFyc2VyIFhNTFxuICAgICAqXG4gICAgICogQG1ldGhvZCBfX2NhbGxYTUxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHByb21pc2VcbiAgICAgKi9cbiAgICBfX2NhbGxYTUwgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhbGwob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciB4bWxEb2M7XG5cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IG9uIGVudi4gbm9kZWpzIG9yIGJyb3dzZXJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRE9NUGFyc2VyID0gcmVxdWlyZShcInhtbGRvbVwiKS5ET01QYXJzZXI7IC8vIF9feG1sZG9tLkRPTVBhcnNlclxuICAgICAgICAgICAgICAgICAgICB4bWxEb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHJlc3BvbnNlLCBcInRleHQveG1sXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcocmVzcG9uc2UsIFwidGV4dC94bWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIElFXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxEb2MgPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sRG9jLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxEb2MubG9hZFhNTChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIl9fY2FsbFhNTCBmYWlsZWQgb24gOiBcIiwgb3B0aW9ucy51cmwsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBwYXMgZCdleGNlcHRpb24sIGxhaXNzb25zIGxlIGZpbCBzZSBkZXJvdWxlci4uLlxuICAgICAgICAgICAgICAgIC8vIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBYSFI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Protocols/XHR.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Alti.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Alti.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CommonService */ \"./node_modules/geoportal-access-lib/src/Services/CommonService.js\");\n/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DefaultUrlService */ \"./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js\");\n/* harmony import */ var _Request_AltiRequestFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request/AltiRequestFactory */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js\");\n/* harmony import */ var _Response_AltiResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Response/AltiResponseFactory */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js\");\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n *\n * Appel du service d'altimétrie du Géoportail\n *\n * @todo gestion du parma. output et callback\n * @todo outputFormat (REST) et format (WPS)\n * @todo La reponse JSON peut encapsuler un XML !\n *\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.Alti\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {Array.<Object>} options.positions - Tableau ({lon:float,lat:float}) contenant les coordonnées des points (CRS:84)\n *      dont on veut connaître les altitudes (ou à partir desquelles on va calculer le profil).\n *      Chaque élément du tableau est un objet JavaScript avec deux attributs : lon et lat, qui sont des flottants.\n *      Minimum 2 éléments si on souhaite calculer un profil altimétrique (ElevationLine).\n *      Maximum 50 éléments.\n *\n * @param {String} options.outputFormat - Le format de la réponse du service alti : 'xml' ou 'json'.\n *      Ce paramètre déterminera l'extension '.xml' ou '.json' du service dans le cas de l'API REST,\n *      ou la valeur du paramètre 'format' dans le cas de la norme WPS.\n *      Nécessaire si serverUrl est renseigné, et qu'on souhaite passer par l'API REST,\n *      pour connaître le format dans lequel sera fournie la réponse (pour son traitement).\n *      Non nécessaire pour la norme WPS. Par défaut, ce paramètre vaut 'json'.\n *\n * @param {Number} [options.sampling] - Nombre de points à utiliser pour déterminer le tracé d'un profil altimétrique, compris entre 2 et 5000.\n *      A spécifier lorsqu'on souhaite accéder à cette fonctionnalité.\n *      Dans ce cas, les points fournis en entrée (au minimum de deux) servent à déterminer l'axe planimétrique\n *      le long duquel le profil doit être calculé.\n *      Si le paramètre sampling n'est pas spécifié ou moins de deux points sont fournis,\n *      c'est le service Elevation qui sera interrogé (altitudes simples calculées pour les points fournis).\n *      Une valeur de sampling strictement inférieure à 2 déclenchera un échantillonnage avec la valeur par défaut du service (3 points).\n *\n * @param {String} [options.api] - Manière d'accéder au service : 'REST' (via l'API REST) ou 'WPS' (via la norme WPS).\n *      Par défaut, on utilise l'API REST.\n *\n * @param {Boolean} [options.zonly] - Permet de ne récupérer que les altitudes en sortie s'il vaut 'true'.\n *      Vaut 'false' par défaut.\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      proxyURL : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      positions : [{lon:, lat:}, {lon:, lat:}],\n *      outputFormat : 'json' // json|xml\n *      sampling : 3,\n *      api : 'REST', // REST|WPS\n *      zonly : false // false|true\n *   };\n *\n * @private\n */\nfunction Alti (options) {\n    if (!(this instanceof Alti)) {\n        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"CLASS_CONSTRUCTOR\", \"Alti\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"Alti\";\n\n    // appel du constructeur par heritage\n    _CommonService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].apply(this, arguments);\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"Gp.Services.Alti\");\n    this.logger.trace(\"[Constructeur Alti (options)]\");\n\n    // #####################\n    // analyse des options\n    // #####################\n\n    if (!options.positions) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_MISSING\", \"positions\"));\n    }\n\n    if (options.positions.length === 0) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_EMPTY\", \"positions\"));\n    }\n\n    // ajout des options spécifiques au service\n    this.options.positions = options.positions;\n\n    // format de réponse du service : \"json\" ou \"xml\" (valeur par défaut), en minuscule !\n    this.options.outputFormat = (typeof options.outputFormat === \"string\") ? options.outputFormat.toLowerCase() : \"xml\";\n\n    // sampling\n    this.options.sampling = options.sampling || null;\n\n    // type d'api utilisé pour requeter le service, en majuscule !\n    this.options.api = (typeof options.api === \"string\") ? options.api.toUpperCase() : \"REST\";\n\n    // l'api ne peut être interrogée qu'en GET.\n    if (this.options.api === \"REST\") {\n        this.options.httpMethod = \"GET\";\n    }\n\n    // param. zonly\n    this.options.zonly = options.zonly || false;\n\n    // gestion de l'url du service par defaut\n    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n    // en fonction du type d'api, REST ou WPS, du format de reponse demandé (outputFormat)\n    // ainsi que sur le type de service (profil ou elevation)\n    if (!this.options.serverUrl) {\n        var lstUrlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Alti.url(this.options.apiKey);\n        var urlFound = null;\n        switch (this.options.api) {\n            case \"WPS\":\n                urlFound = lstUrlByDefault.wps;\n                break;\n            case \"REST\":\n                var key = (options.sampling ? \"profil\" : \"elevation\") + \"-\" + this.options.outputFormat;\n                urlFound = lstUrlByDefault[key];\n                break;\n            default:\n                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_UNKNOWN\", \"api\"));\n        }\n\n        if (!urlFound) {\n            throw new Error(\"Url by default not found !\");\n        }\n        this.options.serverUrl = urlFound;\n        this.logger.trace(\"Server URL by default : \" + this.options.serverUrl);\n    }\n\n    // gestion du type de service\n    // si l'extension de l'url est .json ou .xml, on surcharge le format de sortie (outputFormat)\n    var idx = this.options.serverUrl.lastIndexOf(\".\");\n    if (idx !== -1) {\n        var extension = this.options.serverUrl.substring(idx + 1);\n        if (extension && extension.length < 5) { // FIXME extension de moins de 4 car. ...\n            this.logger.trace(\"Server Extension URL : \" + extension);\n            switch (extension.toLowerCase()) {\n                case \"json\":\n                case \"xml\":\n                    this.options.outputFormat = extension.toLowerCase();\n                    break;\n                default:\n                    throw new Error(\"type of service : unknown or unsupported (json or xml) !\");\n            }\n        }\n    }\n}\n\n/**\n * @lends module:Alti#\n */\nAlti.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype, {\n    // todo\n    // getter/setter\n});\n\n/**\n * Constructeur (alias)\n */\nAlti.prototype.constructor = Alti;\n\n/**\n * Création de la requête (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nAlti.prototype.buildRequest = function (error, success) {\n    // utilisation en mode callback\n    var options = {\n        httpMethod : this.options.httpMethod,\n        // callback\n        onSuccess : function (result) {\n            // sauvegarde de la requete !\n            this.request = result;\n            success.call(this, this.request);\n        },\n        onError : error,\n        scope : this,\n        // spécifique au service :\n        positions : this.options.positions,\n        outputFormat : this.options.outputFormat,\n        sampling : this.options.sampling,\n        api : this.options.api,\n        zonly : this.options.zonly\n    };\n\n    _Request_AltiRequestFactory__WEBPACK_IMPORTED_MODULE_5__[\"default\"].build(options);\n};\n\n/**\n * Analyse de la reponse (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nAlti.prototype.analyzeResponse = function (error, success) {\n    // INFO\n    // Factory pour masquer la complexité du retour du service qui renvoie soit\n    //  - une 'string' qui contient du XML ou JSON natif en mode XHR\n    //  - un objet JSON qui est natif ou encapsulé\n\n    if (this.response) {\n        var options = {\n            response : this.response,\n            outputFormat : this.options.outputFormat, // utile pour parser la string en mode XHR : JSON ou XML !\n            rawResponse : this.options.rawResponse,\n            onError : error,\n            onSuccess : success,\n            scope : this\n        };\n\n        _Response_AltiResponseFactory__WEBPACK_IMPORTED_MODULE_6__[\"default\"].build(options);\n    } else {\n        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Alti);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvQWx0aS5qcz8yZTQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNpRDtBQUNIO0FBQ1c7QUFDWjtBQUNRO0FBQ1M7QUFDRzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLGVBQWUsK0JBQStCLG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQSxzQkFBc0IsV0FBVyxHQUFHLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQUM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksc0RBQWE7O0FBRWpCLGtCQUFrQiw4REFBTTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0VBQUM7QUFDekI7O0FBRUE7QUFDQSx3QkFBd0IsZ0VBQUM7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0RBQWE7QUFDNUM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxtRUFBa0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEscUVBQW1CO0FBQzNCLEtBQUs7QUFDTCw2QkFBNkIsZ0VBQVksQ0FBQyxnRUFBQztBQUMzQztBQUNBOztBQUVlLG1FQUFJLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvQWx0aS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBFcnJvclNlcnZpY2UgZnJvbSBcIi4uLy4uL0V4Y2VwdGlvbnMvRXJyb3JTZXJ2aWNlXCI7XG5pbXBvcnQgQ29tbW9uU2VydmljZSBmcm9tIFwiLi4vQ29tbW9uU2VydmljZVwiO1xuaW1wb3J0IERlZmF1bHRVcmxTZXJ2aWNlIGZyb20gXCIuLi9EZWZhdWx0VXJsU2VydmljZVwiO1xuaW1wb3J0IEFsdGlSZXF1ZXN0RmFjdG9yeSBmcm9tIFwiLi9SZXF1ZXN0L0FsdGlSZXF1ZXN0RmFjdG9yeVwiO1xuaW1wb3J0IEFsdGlSZXNwb25zZUZhY3RvcnkgZnJvbSBcIi4vUmVzcG9uc2UvQWx0aVJlc3BvbnNlRmFjdG9yeVwiO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBcHBlbCBkdSBzZXJ2aWNlIGQnYWx0aW3DqXRyaWUgZHUgR8Opb3BvcnRhaWxcbiAqXG4gKiBAdG9kbyBnZXN0aW9uIGR1IHBhcm1hLiBvdXRwdXQgZXQgY2FsbGJhY2tcbiAqIEB0b2RvIG91dHB1dEZvcm1hdCAoUkVTVCkgZXQgZm9ybWF0IChXUFMpXG4gKiBAdG9kbyBMYSByZXBvbnNlIEpTT04gcGV1dCBlbmNhcHN1bGVyIHVuIFhNTCAhXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7R3AuU2VydmljZXMuQ29tbW9uU2VydmljZX1cbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BbHRpXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2UgKCsgbGVzIG9wdGlvbnMgaGVyaXTDqWVzKVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IG9wdGlvbnMucG9zaXRpb25zIC0gVGFibGVhdSAoe2xvbjpmbG9hdCxsYXQ6ZmxvYXR9KSBjb250ZW5hbnQgbGVzIGNvb3Jkb25uw6llcyBkZXMgcG9pbnRzIChDUlM6ODQpXG4gKiAgICAgIGRvbnQgb24gdmV1dCBjb25uYcOudHJlIGxlcyBhbHRpdHVkZXMgKG91IMOgIHBhcnRpciBkZXNxdWVsbGVzIG9uIHZhIGNhbGN1bGVyIGxlIHByb2ZpbCkuXG4gKiAgICAgIENoYXF1ZSDDqWzDqW1lbnQgZHUgdGFibGVhdSBlc3QgdW4gb2JqZXQgSmF2YVNjcmlwdCBhdmVjIGRldXggYXR0cmlidXRzIDogbG9uIGV0IGxhdCwgcXVpIHNvbnQgZGVzIGZsb3R0YW50cy5cbiAqICAgICAgTWluaW11bSAyIMOpbMOpbWVudHMgc2kgb24gc291aGFpdGUgY2FsY3VsZXIgdW4gcHJvZmlsIGFsdGltw6l0cmlxdWUgKEVsZXZhdGlvbkxpbmUpLlxuICogICAgICBNYXhpbXVtIDUwIMOpbMOpbWVudHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMub3V0cHV0Rm9ybWF0IC0gTGUgZm9ybWF0IGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UgYWx0aSA6ICd4bWwnIG91ICdqc29uJy5cbiAqICAgICAgQ2UgcGFyYW3DqHRyZSBkw6l0ZXJtaW5lcmEgbCdleHRlbnNpb24gJy54bWwnIG91ICcuanNvbicgZHUgc2VydmljZSBkYW5zIGxlIGNhcyBkZSBsJ0FQSSBSRVNULFxuICogICAgICBvdSBsYSB2YWxldXIgZHUgcGFyYW3DqHRyZSAnZm9ybWF0JyBkYW5zIGxlIGNhcyBkZSBsYSBub3JtZSBXUFMuXG4gKiAgICAgIE7DqWNlc3NhaXJlIHNpIHNlcnZlclVybCBlc3QgcmVuc2VpZ27DqSwgZXQgcXUnb24gc291aGFpdGUgcGFzc2VyIHBhciBsJ0FQSSBSRVNULFxuICogICAgICBwb3VyIGNvbm5hw650cmUgbGUgZm9ybWF0IGRhbnMgbGVxdWVsIHNlcmEgZm91cm5pZSBsYSByw6lwb25zZSAocG91ciBzb24gdHJhaXRlbWVudCkuXG4gKiAgICAgIE5vbiBuw6ljZXNzYWlyZSBwb3VyIGxhIG5vcm1lIFdQUy4gUGFyIGTDqWZhdXQsIGNlIHBhcmFtw6h0cmUgdmF1dCAnanNvbicuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhbXBsaW5nXSAtIE5vbWJyZSBkZSBwb2ludHMgw6AgdXRpbGlzZXIgcG91ciBkw6l0ZXJtaW5lciBsZSB0cmFjw6kgZCd1biBwcm9maWwgYWx0aW3DqXRyaXF1ZSwgY29tcHJpcyBlbnRyZSAyIGV0IDUwMDAuXG4gKiAgICAgIEEgc3DDqWNpZmllciBsb3JzcXUnb24gc291aGFpdGUgYWNjw6lkZXIgw6AgY2V0dGUgZm9uY3Rpb25uYWxpdMOpLlxuICogICAgICBEYW5zIGNlIGNhcywgbGVzIHBvaW50cyBmb3VybmlzIGVuIGVudHLDqWUgKGF1IG1pbmltdW0gZGUgZGV1eCkgc2VydmVudCDDoCBkw6l0ZXJtaW5lciBsJ2F4ZSBwbGFuaW3DqXRyaXF1ZVxuICogICAgICBsZSBsb25nIGR1cXVlbCBsZSBwcm9maWwgZG9pdCDDqnRyZSBjYWxjdWzDqS5cbiAqICAgICAgU2kgbGUgcGFyYW3DqHRyZSBzYW1wbGluZyBuJ2VzdCBwYXMgc3DDqWNpZmnDqSBvdSBtb2lucyBkZSBkZXV4IHBvaW50cyBzb250IGZvdXJuaXMsXG4gKiAgICAgIGMnZXN0IGxlIHNlcnZpY2UgRWxldmF0aW9uIHF1aSBzZXJhIGludGVycm9nw6kgKGFsdGl0dWRlcyBzaW1wbGVzIGNhbGN1bMOpZXMgcG91ciBsZXMgcG9pbnRzIGZvdXJuaXMpLlxuICogICAgICBVbmUgdmFsZXVyIGRlIHNhbXBsaW5nIHN0cmljdGVtZW50IGluZsOpcmlldXJlIMOgIDIgZMOpY2xlbmNoZXJhIHVuIMOpY2hhbnRpbGxvbm5hZ2UgYXZlYyBsYSB2YWxldXIgcGFyIGTDqWZhdXQgZHUgc2VydmljZSAoMyBwb2ludHMpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hcGldIC0gTWFuacOocmUgZCdhY2PDqWRlciBhdSBzZXJ2aWNlIDogJ1JFU1QnICh2aWEgbCdBUEkgUkVTVCkgb3UgJ1dQUycgKHZpYSBsYSBub3JtZSBXUFMpLlxuICogICAgICBQYXIgZMOpZmF1dCwgb24gdXRpbGlzZSBsJ0FQSSBSRVNULlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuem9ubHldIC0gUGVybWV0IGRlIG5lIHLDqWN1cMOpcmVyIHF1ZSBsZXMgYWx0aXR1ZGVzIGVuIHNvcnRpZSBzJ2lsIHZhdXQgJ3RydWUnLlxuICogICAgICBWYXV0ICdmYWxzZScgcGFyIGTDqWZhdXQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgdmFyIG9wdGlvbnMgPSB7XG4gKiAgICAgIGFwaUtleSA6IG51bGwsXG4gKiAgICAgIHNlcnZlclVybCA6ICdodHRwOi8vbG9jYWxob3N0L3NlcnZpY2UvJyxcbiAqICAgICAgcHJvdG9jb2wgOiAnSlNPTlAnLCAvLyBKU09OUHxYSFJcbiAqICAgICAgcHJveHlVUkwgOiBudWxsLFxuICogICAgICBodHRwTWV0aG9kIDogJ0dFVCcsIC8vIEdFVHxQT1NUXG4gKiAgICAgIHRpbWVPdXQgOiAxMDAwMCwgLy8gbXNcbiAqICAgICAgcmF3UmVzcG9uc2UgOiBmYWxzZSwgLy8gdHJ1ZXxmYWxzZVxuICogICAgICBzY29wZSA6IG51bGwsIC8vIHRoaXNcbiAqICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7fSxcbiAqICAgICAgb25GYWlsdXJlIDogZnVuY3Rpb24gKGVycm9yKSB7fSxcbiAqICAgICAgLy8gc3DDqWNpZmlxdWUgYXUgc2VydmljZVxuICogICAgICBwb3NpdGlvbnMgOiBbe2xvbjosIGxhdDp9LCB7bG9uOiwgbGF0On1dLFxuICogICAgICBvdXRwdXRGb3JtYXQgOiAnanNvbicgLy8ganNvbnx4bWxcbiAqICAgICAgc2FtcGxpbmcgOiAzLFxuICogICAgICBhcGkgOiAnUkVTVCcsIC8vIFJFU1R8V1BTXG4gKiAgICAgIHpvbmx5IDogZmFsc2UgLy8gZmFsc2V8dHJ1ZVxuICogICB9O1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFsdGkgKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWx0aSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihfLmdldE1lc3NhZ2UoXCJDTEFTU19DT05TVFJVQ1RPUlwiLCBcIkFsdGlcIikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vbSBkZSBsYSBjbGFzc2UgKGhlcml0YWdlKVxuICAgICAqIEZJWE1FIGluc3RhbmNlIG91IGNsYXNzZSA/XG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIkFsdGlcIjtcblxuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBwYXIgaGVyaXRhZ2VcbiAgICBDb21tb25TZXJ2aWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJHcC5TZXJ2aWNlcy5BbHRpXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBBbHRpIChvcHRpb25zKV1cIik7XG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAvLyBhbmFseXNlIGRlcyBvcHRpb25zXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiAgICBpZiAoIW9wdGlvbnMucG9zaXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9NSVNTSU5HXCIsIFwicG9zaXRpb25zXCIpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9FTVBUWVwiLCBcInBvc2l0aW9uc1wiKSk7XG4gICAgfVxuXG4gICAgLy8gYWpvdXQgZGVzIG9wdGlvbnMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2VcbiAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25zID0gb3B0aW9ucy5wb3NpdGlvbnM7XG5cbiAgICAvLyBmb3JtYXQgZGUgcsOpcG9uc2UgZHUgc2VydmljZSA6IFwianNvblwiIG91IFwieG1sXCIgKHZhbGV1ciBwYXIgZMOpZmF1dCksIGVuIG1pbnVzY3VsZSAhXG4gICAgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCA9ICh0eXBlb2Ygb3B0aW9ucy5vdXRwdXRGb3JtYXQgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5vdXRwdXRGb3JtYXQudG9Mb3dlckNhc2UoKSA6IFwieG1sXCI7XG5cbiAgICAvLyBzYW1wbGluZ1xuICAgIHRoaXMub3B0aW9ucy5zYW1wbGluZyA9IG9wdGlvbnMuc2FtcGxpbmcgfHwgbnVsbDtcblxuICAgIC8vIHR5cGUgZCdhcGkgdXRpbGlzw6kgcG91ciByZXF1ZXRlciBsZSBzZXJ2aWNlLCBlbiBtYWp1c2N1bGUgIVxuICAgIHRoaXMub3B0aW9ucy5hcGkgPSAodHlwZW9mIG9wdGlvbnMuYXBpID09PSBcInN0cmluZ1wiKSA/IG9wdGlvbnMuYXBpLnRvVXBwZXJDYXNlKCkgOiBcIlJFU1RcIjtcblxuICAgIC8vIGwnYXBpIG5lIHBldXQgw6p0cmUgaW50ZXJyb2fDqWUgcXUnZW4gR0VULlxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXBpID09PSBcIlJFU1RcIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCA9IFwiR0VUXCI7XG4gICAgfVxuXG4gICAgLy8gcGFyYW0uIHpvbmx5XG4gICAgdGhpcy5vcHRpb25zLnpvbmx5ID0gb3B0aW9ucy56b25seSB8fCBmYWxzZTtcblxuICAgIC8vIGdlc3Rpb24gZGUgbCd1cmwgZHUgc2VydmljZSBwYXIgZGVmYXV0XG4gICAgLy8gc2kgbCd1cmwgbidlc3QgcGFzIHJlbnNlaWduw6llLCBpbCBmYXV0IHV0aWxpc2VyIGxlcyB1cmxzIHBhciBkZWZhdXRcbiAgICAvLyBlbiBmb25jdGlvbiBkdSB0eXBlIGQnYXBpLCBSRVNUIG91IFdQUywgZHUgZm9ybWF0IGRlIHJlcG9uc2UgZGVtYW5kw6kgKG91dHB1dEZvcm1hdClcbiAgICAvLyBhaW5zaSBxdWUgc3VyIGxlIHR5cGUgZGUgc2VydmljZSAocHJvZmlsIG91IGVsZXZhdGlvbilcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAgICAgdmFyIGxzdFVybEJ5RGVmYXVsdCA9IERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKHRoaXMub3B0aW9ucy5hcGlLZXkpO1xuICAgICAgICB2YXIgdXJsRm91bmQgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5hcGkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJXUFNcIjpcbiAgICAgICAgICAgICAgICB1cmxGb3VuZCA9IGxzdFVybEJ5RGVmYXVsdC53cHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUkVTVFwiOlxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAob3B0aW9ucy5zYW1wbGluZyA/IFwicHJvZmlsXCIgOiBcImVsZXZhdGlvblwiKSArIFwiLVwiICsgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdDtcbiAgICAgICAgICAgICAgICB1cmxGb3VuZCA9IGxzdFVybEJ5RGVmYXVsdFtrZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fVU5LTk9XTlwiLCBcImFwaVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcmwgYnkgZGVmYXVsdCBub3QgZm91bmQgIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2VydmVyVXJsID0gdXJsRm91bmQ7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2VydmVyIFVSTCBieSBkZWZhdWx0IDogXCIgKyB0aGlzLm9wdGlvbnMuc2VydmVyVXJsKTtcbiAgICB9XG5cbiAgICAvLyBnZXN0aW9uIGR1IHR5cGUgZGUgc2VydmljZVxuICAgIC8vIHNpIGwnZXh0ZW5zaW9uIGRlIGwndXJsIGVzdCAuanNvbiBvdSAueG1sLCBvbiBzdXJjaGFyZ2UgbGUgZm9ybWF0IGRlIHNvcnRpZSAob3V0cHV0Rm9ybWF0KVxuICAgIHZhciBpZHggPSB0aGlzLm9wdGlvbnMuc2VydmVyVXJsLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLnNlcnZlclVybC5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgZXh0ZW5zaW9uLmxlbmd0aCA8IDUpIHsgLy8gRklYTUUgZXh0ZW5zaW9uIGRlIG1vaW5zIGRlIDQgY2FyLiAuLi5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2VydmVyIEV4dGVuc2lvbiBVUkwgOiBcIiArIGV4dGVuc2lvbik7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwieG1sXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vdXRwdXRGb3JtYXQgPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBvZiBzZXJ2aWNlIDogdW5rbm93biBvciB1bnN1cHBvcnRlZCAoanNvbiBvciB4bWwpICFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpBbHRpI1xuICovXG5BbHRpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tbW9uU2VydmljZS5wcm90b3R5cGUsIHtcbiAgICAvLyB0b2RvXG4gICAgLy8gZ2V0dGVyL3NldHRlclxufSk7XG5cbi8qKlxuICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAqL1xuQWx0aS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbHRpO1xuXG4vKipcbiAqIENyw6lhdGlvbiBkZSBsYSByZXF1w6p0ZSAob3ZlcndyaXRlKVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yICAgLSBjYWxsYmFjayBkZXMgZXJyZXVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gKi9cbkFsdGkucHJvdG90eXBlLmJ1aWxkUmVxdWVzdCA9IGZ1bmN0aW9uIChlcnJvciwgc3VjY2Vzcykge1xuICAgIC8vIHV0aWxpc2F0aW9uIGVuIG1vZGUgY2FsbGJhY2tcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cE1ldGhvZCA6IHRoaXMub3B0aW9ucy5odHRwTWV0aG9kLFxuICAgICAgICAvLyBjYWxsYmFja1xuICAgICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBzYXV2ZWdhcmRlIGRlIGxhIHJlcXVldGUgIVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVzdWx0O1xuICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3IgOiBlcnJvcixcbiAgICAgICAgc2NvcGUgOiB0aGlzLFxuICAgICAgICAvLyBzcMOpY2lmaXF1ZSBhdSBzZXJ2aWNlIDpcbiAgICAgICAgcG9zaXRpb25zIDogdGhpcy5vcHRpb25zLnBvc2l0aW9ucyxcbiAgICAgICAgb3V0cHV0Rm9ybWF0IDogdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCxcbiAgICAgICAgc2FtcGxpbmcgOiB0aGlzLm9wdGlvbnMuc2FtcGxpbmcsXG4gICAgICAgIGFwaSA6IHRoaXMub3B0aW9ucy5hcGksXG4gICAgICAgIHpvbmx5IDogdGhpcy5vcHRpb25zLnpvbmx5XG4gICAgfTtcblxuICAgIEFsdGlSZXF1ZXN0RmFjdG9yeS5idWlsZChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQW5hbHlzZSBkZSBsYSByZXBvbnNlIChvdmVyd3JpdGUpXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgICAtIGNhbGxiYWNrIGRlcyBlcnJldXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIC0gY2FsbGJhY2tcbiAqL1xuQWx0aS5wcm90b3R5cGUuYW5hbHl6ZVJlc3BvbnNlID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgLy8gSU5GT1xuICAgIC8vIEZhY3RvcnkgcG91ciBtYXNxdWVyIGxhIGNvbXBsZXhpdMOpIGR1IHJldG91ciBkdSBzZXJ2aWNlIHF1aSByZW52b2llIHNvaXRcbiAgICAvLyAgLSB1bmUgJ3N0cmluZycgcXVpIGNvbnRpZW50IGR1IFhNTCBvdSBKU09OIG5hdGlmIGVuIG1vZGUgWEhSXG4gICAgLy8gIC0gdW4gb2JqZXQgSlNPTiBxdWkgZXN0IG5hdGlmIG91IGVuY2Fwc3Vsw6lcblxuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmVzcG9uc2UgOiB0aGlzLnJlc3BvbnNlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0IDogdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCwgLy8gdXRpbGUgcG91ciBwYXJzZXIgbGEgc3RyaW5nIGVuIG1vZGUgWEhSIDogSlNPTiBvdSBYTUwgIVxuICAgICAgICAgICAgcmF3UmVzcG9uc2UgOiB0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UsXG4gICAgICAgICAgICBvbkVycm9yIDogZXJyb3IsXG4gICAgICAgICAgICBvblN1Y2Nlc3MgOiBzdWNjZXNzLFxuICAgICAgICAgICAgc2NvcGUgOiB0aGlzXG4gICAgICAgIH07XG5cbiAgICAgICAgQWx0aVJlc3BvbnNlRmFjdG9yeS5idWlsZChvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5jYWxsKHRoaXMsIG5ldyBFcnJvclNlcnZpY2UoXy5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFsdGk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Alti.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Response/model/AltiResponse */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js\");\n/* harmony import */ var _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Response/model/Elevation */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js\");\n\n/**\n * Fonction retournant un objet contenant des clés de lecture (readers)\n *      qui permettent de parser des réponses XML du service Altimétrique du Géoportail\n *      (calcul altimétrique simple ou profil altimétrique d'une courbe),\n *      lorsque le paramètre output = xml,\n *      afin de récupérer les élévations retournées.\n *\n * @module AltiResponseReader\n * @alias Gp.Services.Alti.Formats.AltiResponseReader\n * @private\n */\n\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n/**\n *\n * Objet AltiResponseReader\n *\n * @member {Object} AltiResponseReader\n *\n * @property {Object} AltiResponseReader.READERS - Objet contenant des fonctions de lecture, appelées \"readers\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n *\n * @property {Method} AltiResponseReader.READERS.elevations -  Lecture d'un noeud \"elevations\" de la réponse XML\n *      du service alti, correspondant logiquement à la racine du document\n *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)\n *\n * @property {Method} AltiResponseReader.READERS.elevation - ecture d'un noeud \"elevation\" de la réponse xml du service alti.\n *      (contient un ou 4 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, et acc)\n *\n * @property {Method} AltiResponseReader.READERS.lat - Lecture d'un noeud \"lat\" de la réponse xml du service alti.\n *      (contient une valeur de latitude, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.lon - Lecture d'un noeud \"lon\" de la réponse xml du service alti.\n *      (contient une valeur de longitude, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.z - Lecture d'un noeud \"z\" de la réponse xml du service alti.\n *      (contient une valeur d'altitude, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.acc - Lecture d'un noeud \"acc\" de la réponse xml du service alti.\n *      (contient une valeur de précision, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.exceptionreport - Lecture d'un noeud \"ExceptionReport\" de la réponse xml du service alti.\n *\n * @property {Method} AltiResponseReader.READERS.exception - Lecture d'un noeud \"Exception\" de la réponse xml du service alti.\n *\n * @property {Method} AltiResponseReader.read - Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,\n *      à l'aide des readers de la classe.\n *\n */\nvar AltiResponseReader = {};\n\nAltiResponseReader.READERS = {\n\n    /**\n     * Lecture d'un noeud \"elevations\" de la réponse XML du service alti, correspondant logiquement à la racine du document\n     *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)\n     *\n     * @param {DOMElement} root - racine de la réponse XML\n     * @static\n     * @memberof AltiResponseReader\n     * @returns {Object} Retourne un objet de type AltiResponse\n     */\n    elevations : function (root) {\n        // INFO : on passe en paramètre l'objet en entrée elevations, vide, à remplir.\n        var altiResponse = new _Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n        if (root.hasChildNodes()) {\n            var children = root.childNodes;\n            var child;\n            var elevation;\n\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n\n                if (AltiResponseReader.READERS[child.nodeName]) {\n                    elevation = AltiResponseReader.READERS[child.nodeName](child);\n                    altiResponse.elevations.push(elevation);\n                }\n            }\n        }\n\n        return altiResponse;\n    },\n\n    /**\n     * Lecture d'un noeud \"elevation\" de la réponse xml du service alti.\n     *      (contient un ou 4 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, et acc)\n     *\n     * @param {DOMElement} node - noeud elevation à lire pour récupérer les informations de l'élévation retournée (z [, lon, lat, acc])\n     * @return {Array} elevationResponse - format de la réponse en sortie, instance de AltiResponse\n     * @static\n     * @memberof AltiResponseReader\n     */\n    elevation : function (node) {\n        var elevation = new _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (AltiResponseReader.READERS[child.nodeName]) {\n                    // INFO : on passe en paramètre l'objet en entrée elevation, vide, à remplir.\n                    AltiResponseReader.READERS[child.nodeName](child, elevation);\n                }\n            }\n        }\n        return elevation;\n    },\n\n    /**\n     * Lecture d'un noeud \"lat\" de la réponse xml du service alti.\n     *      (contient une valeur de latitude, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer la latitude\n     * @param {Object} elevation - objet dans lequel stocker la latitude retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    lat : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            elevation.lat = parseFloat(textNode.nodeValue);\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : latitude attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"lon\" de la réponse xml du service alti.\n     *      (contient une valeur de longitude, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer la longitude\n     * @param {Object} elevation - objet dans lequel stocker la longitude retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    lon : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            elevation.lon = parseFloat(textNode.nodeValue);\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : longitude attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"z\" de la réponse xml du service alti.\n     *      (contient une valeur d'altitude, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'altitude\n     * @param {Object} elevation - objet dans lequel stocker l'altitude retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    z : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            if (elevation) {\n                elevation.z = parseFloat(textNode.nodeValue);\n            } else {\n                elevation = new _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n                elevation.z = parseFloat(textNode.nodeValue);\n                return elevation;\n            }\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : altitude attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"acc\" de la réponse xml du service alti.\n     *      (contient une valeur de précision, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer la précision\n     * @param {Object} elevation - objet dans lequel stocker la précision retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    acc : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            elevation.acc = parseFloat(textNode.nodeValue);\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : précision (acc) attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"ExceptionReport\" de la réponse xml du service alti.\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'exception\n     * @return {Object} exceptionReport - objet contenant l'exception\n     * @static\n     * @memberof AltiResponseReader\n     */\n    exceptionreport : function (node) {\n        var response = {};\n\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (child.nodeName === \"Exception\") {\n                    response.exceptionReport = AltiResponseReader.READERS.exception(child);\n                }\n            }\n        }\n\n        return response;\n    },\n\n    /**\n     * Lecture d'un noeud \"Exception\" de la réponse xml du service alti.\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'exception\n     * @return {Object} exceptionReport - objet contenant l'exception, avec deux attributs :\n     *      {String} exceptionReport.exceptionCode - qui contient l'identifiant du code de l'exception\n     *      {String} exceptionReport.exception - qui contient le message de l'exception\n     * @static\n     * @memberof AltiResponseReader\n     */\n    exception : function (node) {\n        var exceptionReport = {};\n\n        // get exception code\n        var exceptionCode = node.getAttribute(\"exceptionCode\");\n        if (exceptionCode) {\n            exceptionReport.exceptionCode = exceptionCode;\n        }\n\n        // get exception message\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            exceptionReport.exception = textNode.nodeValue;\n        }\n\n        return exceptionReport;\n    },\n\n    /**\n     * Lecture d'un noeud \"Error\" de la réponse xml du service alti.\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'exception\n     * @return {Object} error - objet contenant l'exception\n     * @static\n     */\n    error : function (node) {\n        var response = {\n            error : {}\n        };\n        // get error code and description\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                var textNode;\n                // get error code\n                if (child.nodeType === 1 && child.nodeName === \"code\") { // 1 === node.ELEMENT_NODE\n                    textNode = child.firstChild;\n                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n                        response.error.code = textNode.nodeValue;\n                    }\n                }\n                // get error description\n                if (child.nodeType === 1 && child.nodeName === \"description\") { // 1 === node.ELEMENT_NODE\n                    textNode = child.firstChild;\n                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n                        response.error.description = textNode.nodeValue;\n                    }\n                }\n            }\n        }\n        return response;\n    }\n\n};\n\n/**\n * Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,\n *      à l'aide des readers de la classe.\n *\n * @method AltiResponseReader.read\n * @param {DOMElement} root - racine de la réponse XML à lire\n * @static\n * @memberof AltiResponseReader\n */\nAltiResponseReader.read = function (root) {\n    if (root.nodeName === \"elevations\") {\n        var altiResponse = AltiResponseReader.READERS.elevations(root);\n        return altiResponse;\n    } else if (root.nodeName === \"ExceptionReport\") {\n        var exceptionReport = AltiResponseReader.READERS.exceptionreport(root);\n        return exceptionReport;\n    } else if (root.nodeName === \"error\") {\n        var error = AltiResponseReader.READERS.error(root);\n        return error;\n    } else {\n        throw new Error(\"Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.\");\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiResponseReader);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvRm9ybWF0cy9BbHRpUmVzcG9uc2VSZWFkZXIuanM/MTc1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwRDtBQUNOOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvRUFBWTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHFCQUFxQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlFQUFTOztBQUVyQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDLGlFQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVlLGlGQUFrQixFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2dlb3BvcnRhbC1hY2Nlc3MtbGliL3NyYy9TZXJ2aWNlcy9BbHRpL0Zvcm1hdHMvQWx0aVJlc3BvbnNlUmVhZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEZvbmN0aW9uIHJldG91cm5hbnQgdW4gb2JqZXQgY29udGVuYW50IGRlcyBjbMOpcyBkZSBsZWN0dXJlIChyZWFkZXJzKVxuICogICAgICBxdWkgcGVybWV0dGVudCBkZSBwYXJzZXIgZGVzIHLDqXBvbnNlcyBYTUwgZHUgc2VydmljZSBBbHRpbcOpdHJpcXVlIGR1IEfDqW9wb3J0YWlsXG4gKiAgICAgIChjYWxjdWwgYWx0aW3DqXRyaXF1ZSBzaW1wbGUgb3UgcHJvZmlsIGFsdGltw6l0cmlxdWUgZCd1bmUgY291cmJlKSxcbiAqICAgICAgbG9yc3F1ZSBsZSBwYXJhbcOodHJlIG91dHB1dCA9IHhtbCxcbiAqICAgICAgYWZpbiBkZSByw6ljdXDDqXJlciBsZXMgw6lsw6l2YXRpb25zIHJldG91cm7DqWVzLlxuICpcbiAqIEBtb2R1bGUgQWx0aVJlc3BvbnNlUmVhZGVyXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQWx0aS5Gb3JtYXRzLkFsdGlSZXNwb25zZVJlYWRlclxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbmltcG9ydCBBbHRpUmVzcG9uc2UgZnJvbSBcIi4uL1Jlc3BvbnNlL21vZGVsL0FsdGlSZXNwb25zZVwiO1xuaW1wb3J0IEVsZXZhdGlvbiBmcm9tIFwiLi4vUmVzcG9uc2UvbW9kZWwvRWxldmF0aW9uXCI7XG5cbi8qKlxuICpcbiAqIE9iamV0IEFsdGlSZXNwb25zZVJlYWRlclxuICpcbiAqIEBtZW1iZXIge09iamVjdH0gQWx0aVJlc3BvbnNlUmVhZGVyXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTIC0gT2JqZXQgY29udGVuYW50IGRlcyBmb25jdGlvbnMgZGUgbGVjdHVyZSwgYXBwZWzDqWVzIFwicmVhZGVyc1wiXG4gKiAgICAgIGRvbnQgY2hhcXVlIGNsw6kgY29ycmVzcG9uZCBhdSBub20gZCd1biB0YWcgZHUgWE1MIHF1ZSBsJ29uIHNvdWhhaXRlIGxpcmVcbiAqICAgICAgZXQgbGEgdmFsZXVyIGFzc29jacOpZSBlc3QgdW5lIGZvbmN0aW9uIChub2RlLCBkYXRhKVxuICogICAgICBvw7kgbm9kZSBlc3QgdW4gbm9ldWQgZHUgZG9jdW1lbnQgRE9NXG4gKiAgICAgIGV0IGRhdGEgZXN0IHVuIG9iamV0IG/DuSBsJ29uIHN0b2NrZSBsZXMgaW5mb3JtYXRpb25zIGx1ZXMgZGFucyBsZSBYTUwuXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmVsZXZhdGlvbnMgLSAgTGVjdHVyZSBkJ3VuIG5vZXVkIFwiZWxldmF0aW9uc1wiIGRlIGxhIHLDqXBvbnNlIFhNTFxuICogICAgICBkdSBzZXJ2aWNlIGFsdGksIGNvcnJlc3BvbmRhbnQgbG9naXF1ZW1lbnQgw6AgbGEgcmFjaW5lIGR1IGRvY3VtZW50XG4gKiAgICAgIChjb250aWVudCB1biBvdSBwbHVzaWV1cnMgY2hpbGROb2RlcyBjb3JyZXNwb25kYW50IGNoYWN1biDDoCB1bmUgw6lsw6l2YXRpb24gcmV0b3VybsOpZSlcbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMuZWxldmF0aW9uIC0gZWN0dXJlIGQndW4gbm9ldWQgXCJlbGV2YXRpb25cIiBkZSBsYSByw6lwb25zZSB4bWwgZHUgc2VydmljZSBhbHRpLlxuICogICAgICAoY29udGllbnQgdW4gb3UgNCBjaGlsZE5vZGUgKHMpIGNvcnJlc3BvbmRhbnQgw6AgbCdhbHRpdHVkZSAoeikgZXQgw6l2ZW50dWVsbGVtZW50IGxhdCwgbG9uLCBldCBhY2MpXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmxhdCAtIExlY3R1cmUgZCd1biBub2V1ZCBcImxhdFwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gKiAgICAgIChjb250aWVudCB1bmUgdmFsZXVyIGRlIGxhdGl0dWRlLCBxdWkgZXN0IHVuIGZsb3R0YW50KVxuICpcbiAqIEBwcm9wZXJ0eSB7TWV0aG9kfSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUy5sb24gLSBMZWN0dXJlIGQndW4gbm9ldWQgXCJsb25cIiBkZSBsYSByw6lwb25zZSB4bWwgZHUgc2VydmljZSBhbHRpLlxuICogICAgICAoY29udGllbnQgdW5lIHZhbGV1ciBkZSBsb25naXR1ZGUsIHF1aSBlc3QgdW4gZmxvdHRhbnQpXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLnogLSBMZWN0dXJlIGQndW4gbm9ldWQgXCJ6XCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAqICAgICAgKGNvbnRpZW50IHVuZSB2YWxldXIgZCdhbHRpdHVkZSwgcXVpIGVzdCB1biBmbG90dGFudClcbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMuYWNjIC0gTGVjdHVyZSBkJ3VuIG5vZXVkIFwiYWNjXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAqICAgICAgKGNvbnRpZW50IHVuZSB2YWxldXIgZGUgcHLDqWNpc2lvbiwgcXVpIGVzdCB1biBmbG90dGFudClcbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMuZXhjZXB0aW9ucmVwb3J0IC0gTGVjdHVyZSBkJ3VuIG5vZXVkIFwiRXhjZXB0aW9uUmVwb3J0XCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMuZXhjZXB0aW9uIC0gTGVjdHVyZSBkJ3VuIG5vZXVkIFwiRXhjZXB0aW9uXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gQWx0aVJlc3BvbnNlUmVhZGVyLnJlYWQgLSBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIGxhbmNlciBsYSBsZWN0dXJlIGQndW5lIHLDqXBvbnNlIFhNTCBkdSBzZXJ2aWNlIGFsdGltw6l0cmlxdWUsXG4gKiAgICAgIMOgIGwnYWlkZSBkZXMgcmVhZGVycyBkZSBsYSBjbGFzc2UuXG4gKlxuICovXG52YXIgQWx0aVJlc3BvbnNlUmVhZGVyID0ge307XG5cbkFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTID0ge1xuXG4gICAgLyoqXG4gICAgICogTGVjdHVyZSBkJ3VuIG5vZXVkIFwiZWxldmF0aW9uc1wiIGRlIGxhIHLDqXBvbnNlIFhNTCBkdSBzZXJ2aWNlIGFsdGksIGNvcnJlc3BvbmRhbnQgbG9naXF1ZW1lbnQgw6AgbGEgcmFjaW5lIGR1IGRvY3VtZW50XG4gICAgICogICAgICAoY29udGllbnQgdW4gb3UgcGx1c2lldXJzIGNoaWxkTm9kZXMgY29ycmVzcG9uZGFudCBjaGFjdW4gw6AgdW5lIMOpbMOpdmF0aW9uIHJldG91cm7DqWUpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3QgLSByYWNpbmUgZGUgbGEgcsOpcG9uc2UgWE1MXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBBbHRpUmVzcG9uc2VSZWFkZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXRvdXJuZSB1biBvYmpldCBkZSB0eXBlIEFsdGlSZXNwb25zZVxuICAgICAqL1xuICAgIGVsZXZhdGlvbnMgOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAvLyBJTkZPIDogb24gcGFzc2UgZW4gcGFyYW3DqHRyZSBsJ29iamV0IGVuIGVudHLDqWUgZWxldmF0aW9ucywgdmlkZSwgw6AgcmVtcGxpci5cbiAgICAgICAgdmFyIGFsdGlSZXNwb25zZSA9IG5ldyBBbHRpUmVzcG9uc2UoKTtcblxuICAgICAgICBpZiAocm9vdC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHJvb3QuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIHZhciBlbGV2YXRpb247XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTW2NoaWxkLm5vZGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBlbGV2YXRpb24gPSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tjaGlsZC5ub2RlTmFtZV0oY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBhbHRpUmVzcG9uc2UuZWxldmF0aW9ucy5wdXNoKGVsZXZhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsdGlSZXNwb25zZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGVjdHVyZSBkJ3VuIG5vZXVkIFwiZWxldmF0aW9uXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAgICAgKiAgICAgIChjb250aWVudCB1biBvdSA0IGNoaWxkTm9kZSAocykgY29ycmVzcG9uZGFudCDDoCBsJ2FsdGl0dWRlICh6KSBldCDDqXZlbnR1ZWxsZW1lbnQgbGF0LCBsb24sIGV0IGFjYylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIGVsZXZhdGlvbiDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbGVzIGluZm9ybWF0aW9ucyBkZSBsJ8OpbMOpdmF0aW9uIHJldG91cm7DqWUgKHogWywgbG9uLCBsYXQsIGFjY10pXG4gICAgICogQHJldHVybiB7QXJyYXl9IGVsZXZhdGlvblJlc3BvbnNlIC0gZm9ybWF0IGRlIGxhIHLDqXBvbnNlIGVuIHNvcnRpZSwgaW5zdGFuY2UgZGUgQWx0aVJlc3BvbnNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBBbHRpUmVzcG9uc2VSZWFkZXJcbiAgICAgKi9cbiAgICBlbGV2YXRpb24gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZWxldmF0aW9uID0gbmV3IEVsZXZhdGlvbigpO1xuXG4gICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTW2NoaWxkLm5vZGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJTkZPIDogb24gcGFzc2UgZW4gcGFyYW3DqHRyZSBsJ29iamV0IGVuIGVudHLDqWUgZWxldmF0aW9uLCB2aWRlLCDDoCByZW1wbGlyLlxuICAgICAgICAgICAgICAgICAgICBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tjaGlsZC5ub2RlTmFtZV0oY2hpbGQsIGVsZXZhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGV2YXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcImxhdFwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gICAgICogICAgICAoY29udGllbnQgdW5lIHZhbGV1ciBkZSBsYXRpdHVkZSwgcXVpIGVzdCB1biBmbG90dGFudClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIMOgIGxpcmUgcG91ciByw6ljdXDDqXJlciBsYSBsYXRpdHVkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGV2YXRpb24gLSBvYmpldCBkYW5zIGxlcXVlbCBzdG9ja2VyIGxhIGxhdGl0dWRlIHJldG91cm7DqWVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIEFsdGlSZXNwb25zZVJlYWRlclxuICAgICAqL1xuICAgIGxhdCA6IGZ1bmN0aW9uIChub2RlLCBlbGV2YXRpb24pIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIGVsZXZhdGlvbi5sYXQgPSBwYXJzZUZsb2F0KHRleHROb2RlLm5vZGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJldXIgZGFucyBsYSBsZWN0dXJlIGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UgOiBsYXRpdHVkZSBhdHRlbmR1ZSBtYWlzIGFic2VudGVcIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGVjdHVyZSBkJ3VuIG5vZXVkIFwibG9uXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAgICAgKiAgICAgIChjb250aWVudCB1bmUgdmFsZXVyIGRlIGxvbmdpdHVkZSwgcXVpIGVzdCB1biBmbG90dGFudClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIMOgIGxpcmUgcG91ciByw6ljdXDDqXJlciBsYSBsb25naXR1ZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxldmF0aW9uIC0gb2JqZXQgZGFucyBsZXF1ZWwgc3RvY2tlciBsYSBsb25naXR1ZGUgcmV0b3VybsOpZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgQWx0aVJlc3BvbnNlUmVhZGVyXG4gICAgICovXG4gICAgbG9uIDogZnVuY3Rpb24gKG5vZGUsIGVsZXZhdGlvbikge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZSAmJiB0ZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMykgeyAvLyAzID09PSBub2RlLlRFWFRfTk9ERVxuICAgICAgICAgICAgZWxldmF0aW9uLmxvbiA9IHBhcnNlRmxvYXQodGV4dE5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycmV1ciBkYW5zIGxhIGxlY3R1cmUgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSA6IGxvbmdpdHVkZSBhdHRlbmR1ZSBtYWlzIGFic2VudGVcIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGVjdHVyZSBkJ3VuIG5vZXVkIFwielwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gICAgICogICAgICAoY29udGllbnQgdW5lIHZhbGV1ciBkJ2FsdGl0dWRlLCBxdWkgZXN0IHVuIGZsb3R0YW50KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gbm9ldWQgw6AgbGlyZSBwb3VyIHLDqWN1cMOpcmVyIGwnYWx0aXR1ZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxldmF0aW9uIC0gb2JqZXQgZGFucyBsZXF1ZWwgc3RvY2tlciBsJ2FsdGl0dWRlIHJldG91cm7DqWVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIEFsdGlSZXNwb25zZVJlYWRlclxuICAgICAqL1xuICAgIHogOiBmdW5jdGlvbiAobm9kZSwgZWxldmF0aW9uKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLm5vZGVUeXBlID09PSAzKSB7IC8vIDMgPT09IG5vZGUuVEVYVF9OT0RFXG4gICAgICAgICAgICBpZiAoZWxldmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZWxldmF0aW9uLnogPSBwYXJzZUZsb2F0KHRleHROb2RlLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZXZhdGlvbiA9IG5ldyBFbGV2YXRpb24oKTtcbiAgICAgICAgICAgICAgICBlbGV2YXRpb24ueiA9IHBhcnNlRmxvYXQodGV4dE5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxldmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyZXVyIGRhbnMgbGEgbGVjdHVyZSBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIDogYWx0aXR1ZGUgYXR0ZW5kdWUgbWFpcyBhYnNlbnRlXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcImFjY1wiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gICAgICogICAgICAoY29udGllbnQgdW5lIHZhbGV1ciBkZSBwcsOpY2lzaW9uLCBxdWkgZXN0IHVuIGZsb3R0YW50KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gbm9ldWQgw6AgbGlyZSBwb3VyIHLDqWN1cMOpcmVyIGxhIHByw6ljaXNpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxldmF0aW9uIC0gb2JqZXQgZGFucyBsZXF1ZWwgc3RvY2tlciBsYSBwcsOpY2lzaW9uIHJldG91cm7DqWVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIEFsdGlSZXNwb25zZVJlYWRlclxuICAgICAqL1xuICAgIGFjYyA6IGZ1bmN0aW9uIChub2RlLCBlbGV2YXRpb24pIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIGVsZXZhdGlvbi5hY2MgPSBwYXJzZUZsb2F0KHRleHROb2RlLm5vZGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJldXIgZGFucyBsYSBsZWN0dXJlIGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UgOiBwcsOpY2lzaW9uIChhY2MpIGF0dGVuZHVlIG1haXMgYWJzZW50ZVwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMZWN0dXJlIGQndW4gbm9ldWQgXCJFeGNlcHRpb25SZXBvcnRcIiBkZSBsYSByw6lwb25zZSB4bWwgZHUgc2VydmljZSBhbHRpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gbm9ldWQgw6AgbGlyZSBwb3VyIHLDqWN1cMOpcmVyIGwnZXhjZXB0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBleGNlcHRpb25SZXBvcnQgLSBvYmpldCBjb250ZW5hbnQgbCdleGNlcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIEFsdGlSZXNwb25zZVJlYWRlclxuICAgICAqL1xuICAgIGV4Y2VwdGlvbnJlcG9ydCA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xuXG4gICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVOYW1lID09PSBcIkV4Y2VwdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmV4Y2VwdGlvblJlcG9ydCA9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmV4Y2VwdGlvbihjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMZWN0dXJlIGQndW4gbm9ldWQgXCJFeGNlcHRpb25cIiBkZSBsYSByw6lwb25zZSB4bWwgZHUgc2VydmljZSBhbHRpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gbm9ldWQgw6AgbGlyZSBwb3VyIHLDqWN1cMOpcmVyIGwnZXhjZXB0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBleGNlcHRpb25SZXBvcnQgLSBvYmpldCBjb250ZW5hbnQgbCdleGNlcHRpb24sIGF2ZWMgZGV1eCBhdHRyaWJ1dHMgOlxuICAgICAqICAgICAge1N0cmluZ30gZXhjZXB0aW9uUmVwb3J0LmV4Y2VwdGlvbkNvZGUgLSBxdWkgY29udGllbnQgbCdpZGVudGlmaWFudCBkdSBjb2RlIGRlIGwnZXhjZXB0aW9uXG4gICAgICogICAgICB7U3RyaW5nfSBleGNlcHRpb25SZXBvcnQuZXhjZXB0aW9uIC0gcXVpIGNvbnRpZW50IGxlIG1lc3NhZ2UgZGUgbCdleGNlcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIEFsdGlSZXNwb25zZVJlYWRlclxuICAgICAqL1xuICAgIGV4Y2VwdGlvbiA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25SZXBvcnQgPSB7fTtcblxuICAgICAgICAvLyBnZXQgZXhjZXB0aW9uIGNvZGVcbiAgICAgICAgdmFyIGV4Y2VwdGlvbkNvZGUgPSBub2RlLmdldEF0dHJpYnV0ZShcImV4Y2VwdGlvbkNvZGVcIik7XG4gICAgICAgIGlmIChleGNlcHRpb25Db2RlKSB7XG4gICAgICAgICAgICBleGNlcHRpb25SZXBvcnQuZXhjZXB0aW9uQ29kZSA9IGV4Y2VwdGlvbkNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZXhjZXB0aW9uIG1lc3NhZ2VcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIGV4Y2VwdGlvblJlcG9ydC5leGNlcHRpb24gPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhjZXB0aW9uUmVwb3J0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMZWN0dXJlIGQndW4gbm9ldWQgXCJFcnJvclwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbCdleGNlcHRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGVycm9yIC0gb2JqZXQgY29udGVuYW50IGwnZXhjZXB0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgZXJyb3IgOiB7fVxuICAgICAgICB9O1xuICAgICAgICAvLyBnZXQgZXJyb3IgY29kZSBhbmQgZGVzY3JpcHRpb25cbiAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGU7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGVycm9yIGNvZGVcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEgJiYgY2hpbGQubm9kZU5hbWUgPT09IFwiY29kZVwiKSB7IC8vIDEgPT09IG5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlID0gY2hpbGQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLm5vZGVUeXBlID09PSAzKSB7IC8vIDMgPT09IG5vZGUuVEVYVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lcnJvci5jb2RlID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldCBlcnJvciBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZC5ub2RlTmFtZSA9PT0gXCJkZXNjcmlwdGlvblwiKSB7IC8vIDEgPT09IG5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlID0gY2hpbGQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLm5vZGVUeXBlID09PSAzKSB7IC8vIDMgPT09IG5vZGUuVEVYVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lcnJvci5kZXNjcmlwdGlvbiA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIE3DqXRob2RlIHBlcm1ldHRhbnQgZGUgbGFuY2VyIGxhIGxlY3R1cmUgZCd1bmUgcsOpcG9uc2UgWE1MIGR1IHNlcnZpY2UgYWx0aW3DqXRyaXF1ZSxcbiAqICAgICAgw6AgbCdhaWRlIGRlcyByZWFkZXJzIGRlIGxhIGNsYXNzZS5cbiAqXG4gKiBAbWV0aG9kIEFsdGlSZXNwb25zZVJlYWRlci5yZWFkXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3QgLSByYWNpbmUgZGUgbGEgcsOpcG9uc2UgWE1MIMOgIGxpcmVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBBbHRpUmVzcG9uc2VSZWFkZXJcbiAqL1xuQWx0aVJlc3BvbnNlUmVhZGVyLnJlYWQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgIGlmIChyb290Lm5vZGVOYW1lID09PSBcImVsZXZhdGlvbnNcIikge1xuICAgICAgICB2YXIgYWx0aVJlc3BvbnNlID0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMuZWxldmF0aW9ucyhyb290KTtcbiAgICAgICAgcmV0dXJuIGFsdGlSZXNwb25zZTtcbiAgICB9IGVsc2UgaWYgKHJvb3Qubm9kZU5hbWUgPT09IFwiRXhjZXB0aW9uUmVwb3J0XCIpIHtcbiAgICAgICAgdmFyIGV4Y2VwdGlvblJlcG9ydCA9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmV4Y2VwdGlvbnJlcG9ydChyb290KTtcbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvblJlcG9ydDtcbiAgICB9IGVsc2UgaWYgKHJvb3Qubm9kZU5hbWUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB2YXIgZXJyb3IgPSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUy5lcnJvcihyb290KTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycmV1ciBsb3JzIGRlIGxhIGxlY3R1cmUgZGUgbGEgcsOpcG9uc2UgOiBlbGxlIG4nZXN0IHBhcyBhdSBmb3JtYXQgYXR0ZW5kdS5cIik7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQWx0aVJlc3BvbnNlUmVhZGVyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _AltiRequestREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AltiRequestREST */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js\");\n/* harmony import */ var _AltiRequestWPS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AltiRequestWPS */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js\");\n/**\n * Creation d'une requête en REST ou WPS\n * (Factory)\n *\n * @module AltiRequestFactory\n * @alias Gp.Services.Alti.Request.AltiRequestFactory\n * @private\n */\n\n\n\n\n\nvar AltiRequestFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Alti\n     *\n     * @example\n     *   var options = {\n     *      httpMethod : 'GET', // GET|POST\n     *      onSuccess : function (response) {},\n     *      onError : function (error) {},\n     *      scope : this,\n     *      positions : [{lon:, lat:}, {lon:, lat:}],\n     *      outputFormat : 'json' // json|xml\n     *      sampling : 3,\n     *      api : 'REST', // REST|WPS\n     *      zonly : false // false|true\n     *   };\n     *\n     */\n    build : function (options) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"AltiRequestFactory\");\n        logger.trace([\"AltiRequestFactory::build()\"]);\n\n        var request = null;\n\n        // on factorise les options par groupe;\n        // - global,\n        // - param, les params pour les data inputs\n        // - wps, les param du service\n        // - callback\n\n        var settings = {\n            // ajout des valeurs par defaut spécifiques au service\n            type : options.sampling ? \"Profil\" : \"Elevation\",\n            method : options.httpMethod,\n            param : {\n                positions : null,\n                delimiter : null, // FIXME par defaut, on ne le met pas en place car ça fait planter la requête !?\n                indent : null, // par defaut\n                crs : null, // par defaut\n                format : null, // (only to POST)\n                sampling : null, // (only use by Profil)\n                zonly : null // (only use by Elevation)\n            }\n        };\n\n        // surcharge des valeurs obligatoires\n        settings.param.positions = options.positions;\n        settings.param.format = options.outputFormat;\n        settings.param.sampling = options.sampling;\n        settings.param.zonly = options.zonly;\n\n        // gestion des callback\n        var bOnError = !!(options.onError !== null && typeof options.onError === \"function\"); // cast variable to boolean\n        var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === \"function\");\n\n        var message = null;\n        switch (options.api) {\n            case \"REST\":\n                // FIXME les exceptions ne sont pas 'catchées' sur le constructeur !\n                var myReq = new _AltiRequestREST__WEBPACK_IMPORTED_MODULE_2__[\"default\"](settings);\n                if (!myReq.processRequestString()) {\n                    message = \"Error in process request (rest) !\";\n                    if (bOnError) {\n                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__[\"default\"](message));\n                        return;\n                    }\n                    throw new Error(message);\n                }\n                request = myReq.requestString;\n                break;\n            case \"WPS\":\n                // ajout des valeurs par defaut spécifiques au service WPS\n                settings.wps = {\n                    service : null, // par defaut\n                    version : null, // par defaut\n                    identifier : null, // par defaut\n                    rawdataoutput : null, // par defaut\n                    request : null // par defaut\n                };\n\n                request = _AltiRequestWPS__WEBPACK_IMPORTED_MODULE_3__[\"default\"].build(settings);\n                if (!request) {\n                    message = \"Error in process request (wps) !\";\n                    if (bOnError) {\n                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__[\"default\"](message));\n                        return;\n                    }\n                    throw new Error(message);\n                }\n                break;\n            default:\n                message = \"Type of API is not supported by service (REST or WPS) !\";\n                if (bOnError) {\n                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__[\"default\"](message));\n                    return;\n                }\n                throw new Error(message);\n        }\n\n        if (bOnSuccess) {\n            options.onSuccess.call(options.scope, request);\n        }\n\n        return request;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiRequestFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9BbHRpUmVxdWVzdEZhY3RvcnkuanM/ZGQxNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRDtBQUNRO0FBQ1o7QUFDRjs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyx5Q0FBeUM7QUFDekM7QUFDQSwwQkFBMEIsV0FBVyxHQUFHLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFNO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQTZGO0FBQzdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnRUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHVEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnRUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdFQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsaUZBQWtCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9BbHRpUmVxdWVzdEZhY3RvcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0aW9uIGQndW5lIHJlcXXDqnRlIGVuIFJFU1Qgb3UgV1BTXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIEFsdGlSZXF1ZXN0RmFjdG9yeVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdEZhY3RvcnlcbiAqIEBwcml2YXRlXG4gKi9cbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uLy4uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IEVycm9yU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vRXhjZXB0aW9ucy9FcnJvclNlcnZpY2VcIjtcbmltcG9ydCBBbHRpUmVxdWVzdFJFU1QgZnJvbSBcIi4vQWx0aVJlcXVlc3RSRVNUXCI7XG5pbXBvcnQgQWx0aVJlcXVlc3RXUFMgZnJvbSBcIi4vQWx0aVJlcXVlc3RXUFNcIjtcblxudmFyIEFsdGlSZXF1ZXN0RmFjdG9yeSA9IHtcblxuICAgIC8qKlxuICAgICAqIGludGVyZmFjZSB1bmlxdWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IEFsdGlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAgICAgKiAgICAgIG9uU3VjY2VzcyA6IGZ1bmN0aW9uIChyZXNwb25zZSkge30sXG4gICAgICogICAgICBvbkVycm9yIDogZnVuY3Rpb24gKGVycm9yKSB7fSxcbiAgICAgKiAgICAgIHNjb3BlIDogdGhpcyxcbiAgICAgKiAgICAgIHBvc2l0aW9ucyA6IFt7bG9uOiwgbGF0On0sIHtsb246LCBsYXQ6fV0sXG4gICAgICogICAgICBvdXRwdXRGb3JtYXQgOiAnanNvbicgLy8ganNvbnx4bWxcbiAgICAgKiAgICAgIHNhbXBsaW5nIDogMyxcbiAgICAgKiAgICAgIGFwaSA6ICdSRVNUJywgLy8gUkVTVHxXUFNcbiAgICAgKiAgICAgIHpvbmx5IDogZmFsc2UgLy8gZmFsc2V8dHJ1ZVxuICAgICAqICAgfTtcbiAgICAgKlxuICAgICAqL1xuICAgIGJ1aWxkIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiQWx0aVJlcXVlc3RGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiQWx0aVJlcXVlc3RGYWN0b3J5OjpidWlsZCgpXCJdKTtcblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gb24gZmFjdG9yaXNlIGxlcyBvcHRpb25zIHBhciBncm91cGU7XG4gICAgICAgIC8vIC0gZ2xvYmFsLFxuICAgICAgICAvLyAtIHBhcmFtLCBsZXMgcGFyYW1zIHBvdXIgbGVzIGRhdGEgaW5wdXRzXG4gICAgICAgIC8vIC0gd3BzLCBsZXMgcGFyYW0gZHUgc2VydmljZVxuICAgICAgICAvLyAtIGNhbGxiYWNrXG5cbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgLy8gYWpvdXQgZGVzIHZhbGV1cnMgcGFyIGRlZmF1dCBzcMOpY2lmaXF1ZXMgYXUgc2VydmljZVxuICAgICAgICAgICAgdHlwZSA6IG9wdGlvbnMuc2FtcGxpbmcgPyBcIlByb2ZpbFwiIDogXCJFbGV2YXRpb25cIixcbiAgICAgICAgICAgIG1ldGhvZCA6IG9wdGlvbnMuaHR0cE1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtIDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyIDogbnVsbCwgLy8gRklYTUUgcGFyIGRlZmF1dCwgb24gbmUgbGUgbWV0IHBhcyBlbiBwbGFjZSBjYXIgw6dhIGZhaXQgcGxhbnRlciBsYSByZXF1w6p0ZSAhP1xuICAgICAgICAgICAgICAgIGluZGVudCA6IG51bGwsIC8vIHBhciBkZWZhdXRcbiAgICAgICAgICAgICAgICBjcnMgOiBudWxsLCAvLyBwYXIgZGVmYXV0XG4gICAgICAgICAgICAgICAgZm9ybWF0IDogbnVsbCwgLy8gKG9ubHkgdG8gUE9TVClcbiAgICAgICAgICAgICAgICBzYW1wbGluZyA6IG51bGwsIC8vIChvbmx5IHVzZSBieSBQcm9maWwpXG4gICAgICAgICAgICAgICAgem9ubHkgOiBudWxsIC8vIChvbmx5IHVzZSBieSBFbGV2YXRpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3VyY2hhcmdlIGRlcyB2YWxldXJzIG9ibGlnYXRvaXJlc1xuICAgICAgICBzZXR0aW5ncy5wYXJhbS5wb3NpdGlvbnMgPSBvcHRpb25zLnBvc2l0aW9ucztcbiAgICAgICAgc2V0dGluZ3MucGFyYW0uZm9ybWF0ID0gb3B0aW9ucy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgIHNldHRpbmdzLnBhcmFtLnNhbXBsaW5nID0gb3B0aW9ucy5zYW1wbGluZztcbiAgICAgICAgc2V0dGluZ3MucGFyYW0uem9ubHkgPSBvcHRpb25zLnpvbmx5O1xuXG4gICAgICAgIC8vIGdlc3Rpb24gZGVzIGNhbGxiYWNrXG4gICAgICAgIHZhciBiT25FcnJvciA9ICEhKG9wdGlvbnMub25FcnJvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy5vbkVycm9yID09PSBcImZ1bmN0aW9uXCIpOyAvLyBjYXN0IHZhcmlhYmxlIHRvIGJvb2xlYW5cbiAgICAgICAgdmFyIGJPblN1Y2Nlc3MgPSAhIShvcHRpb25zLm9uU3VjY2VzcyAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy5vblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIik7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuYXBpKSB7XG4gICAgICAgICAgICBjYXNlIFwiUkVTVFwiOlxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIGxlcyBleGNlcHRpb25zIG5lIHNvbnQgcGFzICdjYXRjaMOpZXMnIHN1ciBsZSBjb25zdHJ1Y3RldXIgIVxuICAgICAgICAgICAgICAgIHZhciBteVJlcSA9IG5ldyBBbHRpUmVxdWVzdFJFU1Qoc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghbXlSZXEucHJvY2Vzc1JlcXVlc3RTdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJFcnJvciBpbiBwcm9jZXNzIHJlcXVlc3QgKHJlc3QpICFcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgRXJyb3JTZXJ2aWNlKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBteVJlcS5yZXF1ZXN0U3RyaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldQU1wiOlxuICAgICAgICAgICAgICAgIC8vIGFqb3V0IGRlcyB2YWxldXJzIHBhciBkZWZhdXQgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2UgV1BTXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mud3BzID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlIDogbnVsbCwgLy8gcGFyIGRlZmF1dFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uIDogbnVsbCwgLy8gcGFyIGRlZmF1dFxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyIDogbnVsbCwgLy8gcGFyIGRlZmF1dFxuICAgICAgICAgICAgICAgICAgICByYXdkYXRhb3V0cHV0IDogbnVsbCwgLy8gcGFyIGRlZmF1dFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0IDogbnVsbCAvLyBwYXIgZGVmYXV0XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBBbHRpUmVxdWVzdFdQUy5idWlsZChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkVycm9yIGluIHByb2Nlc3MgcmVxdWVzdCAod3BzKSAhXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IEVycm9yU2VydmljZShtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiVHlwZSBvZiBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSBzZXJ2aWNlIChSRVNUIG9yIFdQUykgIVwiO1xuICAgICAgICAgICAgICAgIGlmIChiT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgRXJyb3JTZXJ2aWNlKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYk9uU3VjY2Vzcykge1xuICAgICAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MuY2FsbChvcHRpb25zLnNjb3BlLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFsdGlSZXF1ZXN0RmFjdG9yeTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/AltiElevationRequest */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js\");\n/* harmony import */ var _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/AltiProfilRequest */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js\");\n/* jshint multistr : true */\n\n\n\n\n\n\n/**\n * @classdesc\n * Classe de gestion des requêtes de type REST sur le service altimetrique.\n *\n * @todo Le service Alti n'implemente pas le POST !?\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiRequestREST\n * @param {Object} options - options\n * @param {Object}   options.param.positions - tableau de coordonnées lon/lat\n * @param {String}   options.param.delimiter - '|'\n * @param {Boolean}  options.param.indent - false|true\n * @param {String}   options.param.crs - 'CRS:84'\n * @param {String}   options.param.sampling - 3\n * @param {Boolean}  options.param.zonly - false|true\n * @param {String}   options.param.format - \"JSON|XML\"\n * @param {String}   options.type - \"Profil|Elevation\"\n * @param {String}   options.method - GET|POST\n *\n * @example\n *      var options = {\n *           type : 'Profil', // Elevation\n *           method : 'GET',  // par defaut\n *           param : {\n *               positions : [\n *                   {lon:'1.11', lat:'1.11'},\n *                   {lon:'1.10', lat:'1.10'},\n *                   {lon:'1.12', lat:'1.12'}\n *               ],\n *               delimiter : \";\",         // par defaut\n *               indent    : true,        // par defaut\n *               crs       : 'EPSG:4326', // par defaut\n *               format    : 'json',      // par defaut (only to POST)\n *               sampling  : 3 ,          // par defaut (only use by Profil)\n *               zonly     : false        // par defaut (only use by Elevation)\n *           }\n *      };\n *\n *      var result;\n *      try {\n *          var obj = new AltiRequestREST (options);\n *          if (! obj.processRequestString ()) {\n *              throw new Error(\"Request empty !?\")\n *          }\n *          result = obj.requestString;\n *      } catch (e) {\n *          // exceptions...\n *      }\n * @private\n */\nfunction AltiRequestREST (options) {\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"AltiRequestREST\");\n    this.logger.trace(\"[Constructeur AltiRequestREST ()]\");\n\n    if (!(this instanceof AltiRequestREST)) {\n        throw new TypeError(\"AltiRequestREST constructor cannot be called as a function.\");\n    }\n\n    this.options = options || {};\n\n    // existance des options\n    if (!this.options) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_EMPTY\", \"options\"));\n    }\n\n    // type de requete : Altitude ou Profil\n    // (param. à determiner en fonction des parametres d'entrée)\n    if (!this.options.type) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_EMPTY\", \"type (Elevation or Profil)\"));\n    }\n\n    // construction du modele de requête\n    // (test du type d'objet candidat)\n    this.DataObject = null;\n    switch (this.options.type) {\n        case \"Elevation\":\n            this.DataObject = new _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.options.param);\n            break;\n        case \"Profil\":\n            this.DataObject = new _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.options.param);\n            break;\n        default:\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_TYPE\", \"type (Elevation or Profil)\"));\n    }\n\n    /**\n     * methode.\n     * Par defaut, \"GET\".\n     */\n    this.method = this.options.method || \"GET\";\n}\n\nAltiRequestREST.prototype = {\n\n    /**\n     * request\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : AltiRequestREST,\n\n    /**\n     * Template de la requête.\n     */\n    template : {\n        get : {\n            // FIXME on retire le param 'delimiter' : &delimiter='__DELIMITER__'\n            value : \"lon=__LON__&lat=__LAT__&indent=__INDENT__&crs='__CRS__'\",\n            input : {\n                point : \"&zonly=__ZONLY__\",\n                profil : \"&sampling=__SAMPLING__\"\n            }\n        },\n        post : {\n            // FIXME on retire le param 'delimiter' : delimiter='__DELIMITER__'\\n\\\n            value : \"lon=__LON__\\n\" +\n                \"lat=__LAT__\\n\" +\n                \"indent=__INDENT__\\n\" +\n                \"crs='__CRS__'\\n\",\n            input : {\n                point : \"zonly=__ZONLY__\",\n                profil : \"sampling=__SAMPLING__\"\n            }\n        }\n    },\n\n    /**\n     * Construction de la requête.\n     *\n     * @example\n     * // GET  out : lon=0.2367,2.1570&lat=48.0551,46.6077&delimiter=,&indent=true&zonly=true&crs='CRS:84'\n     * // POST out : Not yet supported method POST !\n     * @returns {String}\n     */\n    processRequestString : function () {\n        this.logger.trace(\"AltiRequestREST::processRequestString ()\");\n\n        var template = \"\";\n        if (this.method === \"POST\") {\n            template = this.template.post.value;\n        } else if (this.method === \"GET\") {\n            template = this.template.get.value;\n        }\n\n        template = template.replace(/__LON__/g, this.DataObject.getLon());\n        template = template.replace(/__LAT__/g, this.DataObject.getLat());\n        // FIXME on retire le param 'delimiter'\n        // template = template.replace(/__DELIMITER__/g, this.DataObject.delimiter);\n        template = template.replace(/__INDENT__/g, this.DataObject.indent);\n        template = template.replace(/__CRS__/g, this.DataObject.crs);\n\n        // ajout +\n        template = template + this.__addDataInputs();\n        this.logger.trace(\"traduction tmpl\", template);\n\n        // sauvegarde\n        this.requestString = template;\n\n        return this.requestString;\n    },\n\n    /**\n     * Ajout de parametres spécifiques (ex. zonly)\n     *\n     * @returns {String}\n     */\n    __addDataInputs : function () {\n        this.logger.trace(\"AltiRequestREST::addDataInput ()\");\n\n        var myTemplate;\n        if (this.method === \"POST\") {\n            myTemplate = this.template.post;\n        } else if (this.method === \"GET\") {\n            myTemplate = this.template.get;\n        } else {\n            throw new Error(\"No other HTTP method supported by the service !\");\n        }\n\n        var tmpl = null;\n        if (this.DataObject.CLASSNAME === \"AltiElevationRequest\") {\n            tmpl = myTemplate.input.point;\n            return tmpl.replace(/__ZONLY__/g, this.DataObject.zonly);\n        } else if (this.DataObject.CLASSNAME === \"AltiProfilRequest\") {\n            tmpl = myTemplate.input.profil;\n            return tmpl.replace(/__SAMPLING__/g, this.DataObject.sampling);\n        } else {\n            throw new Error(\"No other object supported than elevation or profil !?\");\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiRequestREST);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9BbHRpUmVxdWVzdFJFU1QuanM/ZDc0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRW9EO0FBQ0g7QUFDZTtBQUNOOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0Msc0JBQXNCLHVCQUF1QjtBQUM3QyxzQkFBc0I7QUFDdEI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOERBQU07QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQUM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFDO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUVBQW9CO0FBQ3REO0FBQ0E7QUFDQSxrQ0FBa0MsZ0VBQWlCO0FBQ25EO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQUM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsOEVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvQWx0aS9SZXF1ZXN0L0FsdGlSZXF1ZXN0UkVTVC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGpzaGludCBtdWx0aXN0ciA6IHRydWUgKi9cblxuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBBbHRpRWxldmF0aW9uUmVxdWVzdCBmcm9tIFwiLi9tb2RlbC9BbHRpRWxldmF0aW9uUmVxdWVzdFwiO1xuaW1wb3J0IEFsdGlQcm9maWxSZXF1ZXN0IGZyb20gXCIuL21vZGVsL0FsdGlQcm9maWxSZXF1ZXN0XCI7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3NlIGRlIGdlc3Rpb24gZGVzIHJlcXXDqnRlcyBkZSB0eXBlIFJFU1Qgc3VyIGxlIHNlcnZpY2UgYWx0aW1ldHJpcXVlLlxuICpcbiAqIEB0b2RvIExlIHNlcnZpY2UgQWx0aSBuJ2ltcGxlbWVudGUgcGFzIGxlIFBPU1QgIT9cbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdFJFU1RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5wYXJhbS5wb3NpdGlvbnMgLSB0YWJsZWF1IGRlIGNvb3Jkb25uw6llcyBsb24vbGF0XG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLmRlbGltaXRlciAtICd8J1xuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy5wYXJhbS5pbmRlbnQgLSBmYWxzZXx0cnVlXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLmNycyAtICdDUlM6ODQnXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLnNhbXBsaW5nIC0gM1xuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy5wYXJhbS56b25seSAtIGZhbHNlfHRydWVcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucGFyYW0uZm9ybWF0IC0gXCJKU09OfFhNTFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnR5cGUgLSBcIlByb2ZpbHxFbGV2YXRpb25cIlxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5tZXRob2QgLSBHRVR8UE9TVFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBvcHRpb25zID0ge1xuICogICAgICAgICAgIHR5cGUgOiAnUHJvZmlsJywgLy8gRWxldmF0aW9uXG4gKiAgICAgICAgICAgbWV0aG9kIDogJ0dFVCcsICAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgcGFyYW0gOiB7XG4gKiAgICAgICAgICAgICAgIHBvc2l0aW9ucyA6IFtcbiAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTEnLCBsYXQ6JzEuMTEnfSxcbiAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTAnLCBsYXQ6JzEuMTAnfSxcbiAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTInLCBsYXQ6JzEuMTInfVxuICogICAgICAgICAgICAgICBdLFxuICogICAgICAgICAgICAgICBkZWxpbWl0ZXIgOiBcIjtcIiwgICAgICAgICAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgICAgIGluZGVudCAgICA6IHRydWUsICAgICAgICAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgICAgIGNycyAgICAgICA6ICdFUFNHOjQzMjYnLCAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgICAgIGZvcm1hdCAgICA6ICdqc29uJywgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHRvIFBPU1QpXG4gKiAgICAgICAgICAgICAgIHNhbXBsaW5nICA6IDMgLCAgICAgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHVzZSBieSBQcm9maWwpXG4gKiAgICAgICAgICAgICAgIHpvbmx5ICAgICA6IGZhbHNlICAgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHVzZSBieSBFbGV2YXRpb24pXG4gKiAgICAgICAgICAgfVxuICogICAgICB9O1xuICpcbiAqICAgICAgdmFyIHJlc3VsdDtcbiAqICAgICAgdHJ5IHtcbiAqICAgICAgICAgIHZhciBvYmogPSBuZXcgQWx0aVJlcXVlc3RSRVNUIChvcHRpb25zKTtcbiAqICAgICAgICAgIGlmICghIG9iai5wcm9jZXNzUmVxdWVzdFN0cmluZyAoKSkge1xuICogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3QgZW1wdHkgIT9cIilcbiAqICAgICAgICAgIH1cbiAqICAgICAgICAgIHJlc3VsdCA9IG9iai5yZXF1ZXN0U3RyaW5nO1xuICogICAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgICAgICAvLyBleGNlcHRpb25zLi4uXG4gKiAgICAgIH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFsdGlSZXF1ZXN0UkVTVCAob3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcihcIkFsdGlSZXF1ZXN0UkVTVFwiKTtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIltDb25zdHJ1Y3RldXIgQWx0aVJlcXVlc3RSRVNUICgpXVwiKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbHRpUmVxdWVzdFJFU1QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBbHRpUmVxdWVzdFJFU1QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gZXhpc3RhbmNlIGRlcyBvcHRpb25zXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF8uZ2V0TWVzc2FnZShcIlBBUkFNX0VNUFRZXCIsIFwib3B0aW9uc1wiKSk7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBkZSByZXF1ZXRlIDogQWx0aXR1ZGUgb3UgUHJvZmlsXG4gICAgLy8gKHBhcmFtLiDDoCBkZXRlcm1pbmVyIGVuIGZvbmN0aW9uIGRlcyBwYXJhbWV0cmVzIGQnZW50csOpZSlcbiAgICBpZiAoIXRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9FTVBUWVwiLCBcInR5cGUgKEVsZXZhdGlvbiBvciBQcm9maWwpXCIpKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3Rpb24gZHUgbW9kZWxlIGRlIHJlcXXDqnRlXG4gICAgLy8gKHRlc3QgZHUgdHlwZSBkJ29iamV0IGNhbmRpZGF0KVxuICAgIHRoaXMuRGF0YU9iamVjdCA9IG51bGw7XG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgICBjYXNlIFwiRWxldmF0aW9uXCI6XG4gICAgICAgICAgICB0aGlzLkRhdGFPYmplY3QgPSBuZXcgQWx0aUVsZXZhdGlvblJlcXVlc3QodGhpcy5vcHRpb25zLnBhcmFtKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUHJvZmlsXCI6XG4gICAgICAgICAgICB0aGlzLkRhdGFPYmplY3QgPSBuZXcgQWx0aVByb2ZpbFJlcXVlc3QodGhpcy5vcHRpb25zLnBhcmFtKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF8uZ2V0TWVzc2FnZShcIlBBUkFNX1RZUEVcIiwgXCJ0eXBlIChFbGV2YXRpb24gb3IgUHJvZmlsKVwiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWV0aG9kZS5cbiAgICAgKiBQYXIgZGVmYXV0LCBcIkdFVFwiLlxuICAgICAqL1xuICAgIHRoaXMubWV0aG9kID0gdGhpcy5vcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiO1xufVxuXG5BbHRpUmVxdWVzdFJFU1QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogQWx0aVJlcXVlc3RSRVNULFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiB7XG4gICAgICAgIGdldCA6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FIG9uIHJldGlyZSBsZSBwYXJhbSAnZGVsaW1pdGVyJyA6ICZkZWxpbWl0ZXI9J19fREVMSU1JVEVSX18nXG4gICAgICAgICAgICB2YWx1ZSA6IFwibG9uPV9fTE9OX18mbGF0PV9fTEFUX18maW5kZW50PV9fSU5ERU5UX18mY3JzPSdfX0NSU19fJ1wiLFxuICAgICAgICAgICAgaW5wdXQgOiB7XG4gICAgICAgICAgICAgICAgcG9pbnQgOiBcIiZ6b25seT1fX1pPTkxZX19cIixcbiAgICAgICAgICAgICAgICBwcm9maWwgOiBcIiZzYW1wbGluZz1fX1NBTVBMSU5HX19cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwb3N0IDoge1xuICAgICAgICAgICAgLy8gRklYTUUgb24gcmV0aXJlIGxlIHBhcmFtICdkZWxpbWl0ZXInIDogZGVsaW1pdGVyPSdfX0RFTElNSVRFUl9fJ1xcblxcXG4gICAgICAgICAgICB2YWx1ZSA6IFwibG9uPV9fTE9OX19cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJsYXQ9X19MQVRfX1xcblwiICtcbiAgICAgICAgICAgICAgICBcImluZGVudD1fX0lOREVOVF9fXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiY3JzPSdfX0NSU19fJ1xcblwiLFxuICAgICAgICAgICAgaW5wdXQgOiB7XG4gICAgICAgICAgICAgICAgcG9pbnQgOiBcInpvbmx5PV9fWk9OTFlfX1wiLFxuICAgICAgICAgICAgICAgIHByb2ZpbCA6IFwic2FtcGxpbmc9X19TQU1QTElOR19fXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdFVCAgb3V0IDogbG9uPTAuMjM2NywyLjE1NzAmbGF0PTQ4LjA1NTEsNDYuNjA3NyZkZWxpbWl0ZXI9LCZpbmRlbnQ9dHJ1ZSZ6b25seT10cnVlJmNycz0nQ1JTOjg0J1xuICAgICAqIC8vIFBPU1Qgb3V0IDogTm90IHlldCBzdXBwb3J0ZWQgbWV0aG9kIFBPU1QgIVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgcHJvY2Vzc1JlcXVlc3RTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQWx0aVJlcXVlc3RSRVNUOjpwcm9jZXNzUmVxdWVzdFN0cmluZyAoKVwiKTtcblxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUucG9zdC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLmdldC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19MT05fXy9nLCB0aGlzLkRhdGFPYmplY3QuZ2V0TG9uKCkpO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fTEFUX18vZywgdGhpcy5EYXRhT2JqZWN0LmdldExhdCgpKTtcbiAgICAgICAgLy8gRklYTUUgb24gcmV0aXJlIGxlIHBhcmFtICdkZWxpbWl0ZXInXG4gICAgICAgIC8vIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19ERUxJTUlURVJfXy9nLCB0aGlzLkRhdGFPYmplY3QuZGVsaW1pdGVyKTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0lOREVOVF9fL2csIHRoaXMuRGF0YU9iamVjdC5pbmRlbnQpO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fQ1JTX18vZywgdGhpcy5EYXRhT2JqZWN0LmNycyk7XG5cbiAgICAgICAgLy8gYWpvdXQgK1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlICsgdGhpcy5fX2FkZERhdGFJbnB1dHMoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJ0cmFkdWN0aW9uIHRtcGxcIiwgdGVtcGxhdGUpO1xuXG4gICAgICAgIC8vIHNhdXZlZ2FyZGVcbiAgICAgICAgdGhpcy5yZXF1ZXN0U3RyaW5nID0gdGVtcGxhdGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZGUgcGFyYW1ldHJlcyBzcMOpY2lmaXF1ZXMgKGV4LiB6b25seSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgX19hZGREYXRhSW5wdXRzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkFsdGlSZXF1ZXN0UkVTVDo6YWRkRGF0YUlucHV0ICgpXCIpO1xuXG4gICAgICAgIHZhciBteVRlbXBsYXRlO1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICBteVRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5wb3N0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICBteVRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5nZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdGhlciBIVFRQIG1ldGhvZCBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZpY2UgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXBsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuRGF0YU9iamVjdC5DTEFTU05BTUUgPT09IFwiQWx0aUVsZXZhdGlvblJlcXVlc3RcIikge1xuICAgICAgICAgICAgdG1wbCA9IG15VGVtcGxhdGUuaW5wdXQucG9pbnQ7XG4gICAgICAgICAgICByZXR1cm4gdG1wbC5yZXBsYWNlKC9fX1pPTkxZX18vZywgdGhpcy5EYXRhT2JqZWN0Lnpvbmx5KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLkRhdGFPYmplY3QuQ0xBU1NOQU1FID09PSBcIkFsdGlQcm9maWxSZXF1ZXN0XCIpIHtcbiAgICAgICAgICAgIHRtcGwgPSBteVRlbXBsYXRlLmlucHV0LnByb2ZpbDtcbiAgICAgICAgICAgIHJldHVybiB0bXBsLnJlcGxhY2UoL19fU0FNUExJTkdfXy9nLCB0aGlzLkRhdGFPYmplY3Quc2FtcGxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3RoZXIgb2JqZWN0IHN1cHBvcnRlZCB0aGFuIGVsZXZhdGlvbiBvciBwcm9maWwgIT9cIik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBbHRpUmVxdWVzdFJFU1Q7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Formats_WPS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Formats/WPS */ \"./node_modules/geoportal-access-lib/src/Formats/WPS.js\");\n/* harmony import */ var _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/AltiElevationRequest */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js\");\n/* harmony import */ var _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/AltiProfilRequest */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js\");\n/**\n * Classe d'interface des requêtes de type WPS sur le service altimetrique.\n * (Factory)\n *\n * @module Gp.Services.Alti.Request.AltiRequestWPS\n * @alias Gp.Services.Alti.Request.AltiRequestWPS\n * @private\n */\n\n\n\n\n\n\nvar AltiRequestWPS = {\n\n    /**\n     * Interface unique de construction de la requête.\n     *\n     * @method build\n     * @param {Object} options - options\n     * @param {Object}   options.param.positions - tableau de coordonnées lon/lat\n     * @param {String}   options.param.delimiter - '|'\n     * @param {Boolean}  options.param.indent - false|true\n     * @param {String}   options.param.crs - 'CRS:84'\n     * @param {String}   options.param.sampling - 3\n     * @param {Boolean}  options.param.zonly - false|true\n     * @param {String}   options.param.format - \"JSON|XML\" (only to POST)\n     * @param {String}   options.wps.service - \"WPS\"\n     * @param {String}   options.wps.version - \"1.0.0\"\n     * @param {String}   options.wps.identifier - \"gs:WPSElevation|gs:WPSLineElevation\"\n     * @param {String}   options.wps.rawdataoutput - \"result\"\n     * @param {String}   options.wps.request - \"Execute\"\n     * @param {String}   options.type - \"Profil|Elevation\"\n     * @param {String}   options.method - GET|POST\n     * @example\n     *      var options = {\n     *           type : 'Profil', // Elevation\n     *           method : 'GET',  // par defaut\n     *           param : {\n     *               positions : [\n     *                   {lon:'1.11', lat:'1.11'},\n     *                   {lon:'1.10', lat:'1.10'},\n     *                   {lon:'1.12', lat:'1.12'}\n     *               ],\n     *               delimiter : \";\",         // par defaut\n     *               indent    : true,        // par defaut\n     *               crs       : 'EPSG:4326', // par defaut\n     *               format    : 'json',      // par defaut (only to POST)\n     *               sampling  : 3 ,          // par defaut (only use by Profil)\n     *               zonly     : false,       // par defaut (only use by Elevation)\n     *           },\n     *           wps : {\n     *                 service : 'WPS',         // par defaut\n     *                 version : '1.0.0',       // par defaut\n     *                 identifier : 'gs:WPS',   // par defaut, Elevation = gs:WPSElevation, Profil = gs:WPSLineElevation\n     *                 rawdataoutput : 'result',// par defaut\n     *                 request : 'Execute'      // par defaut\n     *           }\n     *       };\n     */\n    build : function (options) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"AltiRequestWPS\");\n        logger.trace([\"AltiRequestWPS::build()\"]);\n\n        // existance des options\n        if (!options) {\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_EMPTY\", \"options\"));\n        }\n\n        // type de requete : Altitude ou Profil\n        // (param. à determiner en fonction des parametres d'entrée)\n        if (!options.type) {\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_EMPTY\", \"type (Elevation or Profil)\"));\n        }\n\n        // construction du modele de requête\n        // (test du type d'objet candidat)\n        var DataObject = null;\n        switch (options.type) {\n            case \"Elevation\":\n                // surcharge\n                options.wps.identifier = \"gs:WPSElevation\";\n                DataObject = new _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_3__[\"default\"](options.param);\n                break;\n            case \"Profil\":\n                // surcharge\n                options.wps.identifier = \"gs:WPSLineElevation\";\n                DataObject = new _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_4__[\"default\"](options.param);\n                break;\n            default:\n                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"PARAM_TYPE\", \"type (Elevation or Profil)\"));\n        }\n\n        // construction de la requête WPS\n        var settings = {\n            data : DataObject,\n            method : options.method,\n            param : options.wps\n        };\n\n        var rqstWPS = new _Formats_WPS__WEBPACK_IMPORTED_MODULE_2__[\"default\"](settings);\n\n        if (!rqstWPS.processRequestString()) {\n            throw new Error(\"Enable to process request !\");\n        }\n\n        return rqstWPS.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiRequestWPS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9BbHRpUmVxdWVzdFdQUy5qcz80MzcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDSDtBQUNWO0FBQ3lCO0FBQ047O0FBRTFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRCwwQkFBMEIsdUJBQXVCO0FBQ2pELDBCQUEwQjtBQUMxQjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQU07QUFDM0I7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixnRUFBQztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQUM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUVBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdFQUFpQjtBQUNsRDtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsb0RBQUc7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsNkVBQWMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvQWx0aS9SZXF1ZXN0L0FsdGlSZXF1ZXN0V1BTLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGFzc2UgZCdpbnRlcmZhY2UgZGVzIHJlcXXDqnRlcyBkZSB0eXBlIFdQUyBzdXIgbGUgc2VydmljZSBhbHRpbWV0cmlxdWUuXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdFdQU1xuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdFdQU1xuICogQHByaXZhdGVcbiAqL1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBXUFMgZnJvbSBcIi4uLy4uLy4uL0Zvcm1hdHMvV1BTXCI7XG5pbXBvcnQgQWx0aUVsZXZhdGlvblJlcXVlc3QgZnJvbSBcIi4vbW9kZWwvQWx0aUVsZXZhdGlvblJlcXVlc3RcIjtcbmltcG9ydCBBbHRpUHJvZmlsUmVxdWVzdCBmcm9tIFwiLi9tb2RlbC9BbHRpUHJvZmlsUmVxdWVzdFwiO1xuXG52YXIgQWx0aVJlcXVlc3RXUFMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcmZhY2UgdW5pcXVlIGRlIGNvbnN0cnVjdGlvbiBkZSBsYSByZXF1w6p0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLnBhcmFtLnBvc2l0aW9ucyAtIHRhYmxlYXUgZGUgY29vcmRvbm7DqWVzIGxvbi9sYXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLmRlbGltaXRlciAtICd8J1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gIG9wdGlvbnMucGFyYW0uaW5kZW50IC0gZmFsc2V8dHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucGFyYW0uY3JzIC0gJ0NSUzo4NCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLnNhbXBsaW5nIC0gM1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gIG9wdGlvbnMucGFyYW0uem9ubHkgLSBmYWxzZXx0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5wYXJhbS5mb3JtYXQgLSBcIkpTT058WE1MXCIgKG9ubHkgdG8gUE9TVClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLndwcy5zZXJ2aWNlIC0gXCJXUFNcIlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMud3BzLnZlcnNpb24gLSBcIjEuMC4wXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLndwcy5pZGVudGlmaWVyIC0gXCJnczpXUFNFbGV2YXRpb258Z3M6V1BTTGluZUVsZXZhdGlvblwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy53cHMucmF3ZGF0YW91dHB1dCAtIFwicmVzdWx0XCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLndwcy5yZXF1ZXN0IC0gXCJFeGVjdXRlXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnR5cGUgLSBcIlByb2ZpbHxFbGV2YXRpb25cIlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMubWV0aG9kIC0gR0VUfFBPU1RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAgICAgICAgIHR5cGUgOiAnUHJvZmlsJywgLy8gRWxldmF0aW9uXG4gICAgICogICAgICAgICAgIG1ldGhvZCA6ICdHRVQnLCAgLy8gcGFyIGRlZmF1dFxuICAgICAqICAgICAgICAgICBwYXJhbSA6IHtcbiAgICAgKiAgICAgICAgICAgICAgIHBvc2l0aW9ucyA6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICB7bG9uOicxLjExJywgbGF0OicxLjExJ30sXG4gICAgICogICAgICAgICAgICAgICAgICAge2xvbjonMS4xMCcsIGxhdDonMS4xMCd9LFxuICAgICAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTInLCBsYXQ6JzEuMTInfVxuICAgICAqICAgICAgICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgICAgICAgIGRlbGltaXRlciA6IFwiO1wiLCAgICAgICAgIC8vIHBhciBkZWZhdXRcbiAgICAgKiAgICAgICAgICAgICAgIGluZGVudCAgICA6IHRydWUsICAgICAgICAvLyBwYXIgZGVmYXV0XG4gICAgICogICAgICAgICAgICAgICBjcnMgICAgICAgOiAnRVBTRzo0MzI2JywgLy8gcGFyIGRlZmF1dFxuICAgICAqICAgICAgICAgICAgICAgZm9ybWF0ICAgIDogJ2pzb24nLCAgICAgIC8vIHBhciBkZWZhdXQgKG9ubHkgdG8gUE9TVClcbiAgICAgKiAgICAgICAgICAgICAgIHNhbXBsaW5nICA6IDMgLCAgICAgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHVzZSBieSBQcm9maWwpXG4gICAgICogICAgICAgICAgICAgICB6b25seSAgICAgOiBmYWxzZSwgICAgICAgLy8gcGFyIGRlZmF1dCAob25seSB1c2UgYnkgRWxldmF0aW9uKVxuICAgICAqICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICB3cHMgOiB7XG4gICAgICogICAgICAgICAgICAgICAgIHNlcnZpY2UgOiAnV1BTJywgICAgICAgICAvLyBwYXIgZGVmYXV0XG4gICAgICogICAgICAgICAgICAgICAgIHZlcnNpb24gOiAnMS4wLjAnLCAgICAgICAvLyBwYXIgZGVmYXV0XG4gICAgICogICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgOiAnZ3M6V1BTJywgICAvLyBwYXIgZGVmYXV0LCBFbGV2YXRpb24gPSBnczpXUFNFbGV2YXRpb24sIFByb2ZpbCA9IGdzOldQU0xpbmVFbGV2YXRpb25cbiAgICAgKiAgICAgICAgICAgICAgICAgcmF3ZGF0YW91dHB1dCA6ICdyZXN1bHQnLC8vIHBhciBkZWZhdXRcbiAgICAgKiAgICAgICAgICAgICAgICAgcmVxdWVzdCA6ICdFeGVjdXRlJyAgICAgIC8vIHBhciBkZWZhdXRcbiAgICAgKiAgICAgICAgICAgfVxuICAgICAqICAgICAgIH07XG4gICAgICovXG4gICAgYnVpbGQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBsb2dnZXJcbiAgICAgICAgdmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJBbHRpUmVxdWVzdFdQU1wiKTtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFtcIkFsdGlSZXF1ZXN0V1BTOjpidWlsZCgpXCJdKTtcblxuICAgICAgICAvLyBleGlzdGFuY2UgZGVzIG9wdGlvbnNcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fRU1QVFlcIiwgXCJvcHRpb25zXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHR5cGUgZGUgcmVxdWV0ZSA6IEFsdGl0dWRlIG91IFByb2ZpbFxuICAgICAgICAvLyAocGFyYW0uIMOgIGRldGVybWluZXIgZW4gZm9uY3Rpb24gZGVzIHBhcmFtZXRyZXMgZCdlbnRyw6llKVxuICAgICAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF8uZ2V0TWVzc2FnZShcIlBBUkFNX0VNUFRZXCIsIFwidHlwZSAoRWxldmF0aW9uIG9yIFByb2ZpbClcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RydWN0aW9uIGR1IG1vZGVsZSBkZSByZXF1w6p0ZVxuICAgICAgICAvLyAodGVzdCBkdSB0eXBlIGQnb2JqZXQgY2FuZGlkYXQpXG4gICAgICAgIHZhciBEYXRhT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJFbGV2YXRpb25cIjpcbiAgICAgICAgICAgICAgICAvLyBzdXJjaGFyZ2VcbiAgICAgICAgICAgICAgICBvcHRpb25zLndwcy5pZGVudGlmaWVyID0gXCJnczpXUFNFbGV2YXRpb25cIjtcbiAgICAgICAgICAgICAgICBEYXRhT2JqZWN0ID0gbmV3IEFsdGlFbGV2YXRpb25SZXF1ZXN0KG9wdGlvbnMucGFyYW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlByb2ZpbFwiOlxuICAgICAgICAgICAgICAgIC8vIHN1cmNoYXJnZVxuICAgICAgICAgICAgICAgIG9wdGlvbnMud3BzLmlkZW50aWZpZXIgPSBcImdzOldQU0xpbmVFbGV2YXRpb25cIjtcbiAgICAgICAgICAgICAgICBEYXRhT2JqZWN0ID0gbmV3IEFsdGlQcm9maWxSZXF1ZXN0KG9wdGlvbnMucGFyYW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fVFlQRVwiLCBcInR5cGUgKEVsZXZhdGlvbiBvciBQcm9maWwpXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0cnVjdGlvbiBkZSBsYSByZXF1w6p0ZSBXUFNcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgZGF0YSA6IERhdGFPYmplY3QsXG4gICAgICAgICAgICBtZXRob2QgOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtIDogb3B0aW9ucy53cHNcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcnFzdFdQUyA9IG5ldyBXUFMoc2V0dGluZ3MpO1xuXG4gICAgICAgIGlmICghcnFzdFdQUy5wcm9jZXNzUmVxdWVzdFN0cmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmFibGUgdG8gcHJvY2VzcyByZXF1ZXN0ICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnFzdFdQUy5yZXF1ZXN0U3RyaW5nO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFsdGlSZXF1ZXN0V1BTO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _AltiRequest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AltiRequest */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js\");\n\n\n\n\n/**\n * @classdesc\n *\n * Classe de gestion des param. des requêtes de type POINT du service altimetrique.\n *\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiElevationRequest\n * @param {Object} options - options\n * @param {Boolean}  options.zonly - false|true\n *\n * @private\n */\nfunction AltiElevationRequest (options) {\n    if (!(this instanceof AltiElevationRequest)) {\n        throw new TypeError(\"AltiElevationRequest constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"AltiElevationRequest\";\n\n    // appel du constructeur par heritage\n    _AltiRequest__WEBPACK_IMPORTED_MODULE_1__[\"default\"].apply(this, arguments);\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger();\n    this.logger.trace(\"[Constructeur AltiElevationRequest ()]\");\n\n    /**\n     * Z uniquement.\n     * true|false\n     */\n    this.zonly = this.options.zonly || false; // test des options héritées !\n}\n\n/**\n * @lends module:AltiElevationRequest#\n */\n\nAltiElevationRequest.prototype = Object.create(_AltiRequest__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype, {\n\n    /**\n     * Setter/getter pour \"zonly\"\n     */\n    zonly : {\n        /** getter */\n        get : function () {\n            return this._zonly;\n        },\n        /** setter */\n        set : function (z) {\n            this._zonly = z;\n        }\n    }\n\n});\n\n/**\n * Constructeur (alias)\n */\nAltiElevationRequest.prototype.constructor = AltiElevationRequest;\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Array}\n */\nAltiElevationRequest.prototype.getData = function () {\n    // par glop..., appel de AltiRequest::getData () !\n    var map = [];\n    map.push({\n        k : \"lon\",\n        v : this.getLon()\n    });\n    map.push({\n        k : \"lat\",\n        v : this.getLat()\n    });\n    // map.push({k : \"delimiter\", v : this.delimiter}); // FIXME on retire le param \"delimiter\"\n    map.push({\n        k : \"indent\",\n        v : this.indent\n    });\n    map.push({\n        k : \"crs\",\n        v : this.crs\n    });\n    map.push({\n        k : \"zonly\",\n        v : this.zonly\n    });\n    map.push({\n        k : \"format\",\n        v : this.format\n    });\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiElevationRequest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9tb2RlbC9BbHRpRWxldmF0aW9uUmVxdWVzdC5qcz8zZDNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDdUQ7QUFDZjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxvREFBVzs7QUFFZixrQkFBa0IsOERBQU07QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxvREFBVzs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLG9DQUFvQyxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFZSxtRkFBb0IsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvQWx0aS9SZXF1ZXN0L21vZGVsL0FsdGlFbGV2YXRpb25SZXF1ZXN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbmltcG9ydCBBbHRpUmVxdWVzdCBmcm9tIFwiLi9BbHRpUmVxdWVzdFwiO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgcGFyYW0uIGRlcyByZXF1w6p0ZXMgZGUgdHlwZSBQT0lOVCBkdSBzZXJ2aWNlIGFsdGltZXRyaXF1ZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BbHRpLlJlcXVlc3QuQWx0aUVsZXZhdGlvblJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy56b25seSAtIGZhbHNlfHRydWVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBBbHRpRWxldmF0aW9uUmVxdWVzdCAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbHRpRWxldmF0aW9uUmVxdWVzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFsdGlFbGV2YXRpb25SZXF1ZXN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIkFsdGlFbGV2YXRpb25SZXF1ZXN0XCI7XG5cbiAgICAvLyBhcHBlbCBkdSBjb25zdHJ1Y3RldXIgcGFyIGhlcml0YWdlXG4gICAgQWx0aVJlcXVlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMubG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBBbHRpRWxldmF0aW9uUmVxdWVzdCAoKV1cIik7XG5cbiAgICAvKipcbiAgICAgKiBaIHVuaXF1ZW1lbnQuXG4gICAgICogdHJ1ZXxmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuem9ubHkgPSB0aGlzLm9wdGlvbnMuem9ubHkgfHwgZmFsc2U7IC8vIHRlc3QgZGVzIG9wdGlvbnMgaMOpcml0w6llcyAhXG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpBbHRpRWxldmF0aW9uUmVxdWVzdCNcbiAqL1xuXG5BbHRpRWxldmF0aW9uUmVxdWVzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFsdGlSZXF1ZXN0LnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogU2V0dGVyL2dldHRlciBwb3VyIFwiem9ubHlcIlxuICAgICAqL1xuICAgIHpvbmx5IDoge1xuICAgICAgICAvKiogZ2V0dGVyICovXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25seTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIHNldHRlciAqL1xuICAgICAgICBzZXQgOiBmdW5jdGlvbiAoeikge1xuICAgICAgICAgICAgdGhpcy5fem9ubHkgPSB6O1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICovXG5BbHRpRWxldmF0aW9uUmVxdWVzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbHRpRWxldmF0aW9uUmVxdWVzdDtcblxuLyoqXG4gKiBUYWJsZWF1IGRlIGNsZWZzL3ZhbGV1cnMgcG91ciBwYXJhbS5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbkFsdGlFbGV2YXRpb25SZXF1ZXN0LnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHBhciBnbG9wLi4uLCBhcHBlbCBkZSBBbHRpUmVxdWVzdDo6Z2V0RGF0YSAoKSAhXG4gICAgdmFyIG1hcCA9IFtdO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwibG9uXCIsXG4gICAgICAgIHYgOiB0aGlzLmdldExvbigpXG4gICAgfSk7XG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJsYXRcIixcbiAgICAgICAgdiA6IHRoaXMuZ2V0TGF0KClcbiAgICB9KTtcbiAgICAvLyBtYXAucHVzaCh7ayA6IFwiZGVsaW1pdGVyXCIsIHYgOiB0aGlzLmRlbGltaXRlcn0pOyAvLyBGSVhNRSBvbiByZXRpcmUgbGUgcGFyYW0gXCJkZWxpbWl0ZXJcIlxuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiaW5kZW50XCIsXG4gICAgICAgIHYgOiB0aGlzLmluZGVudFxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiY3JzXCIsXG4gICAgICAgIHYgOiB0aGlzLmNyc1xuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiem9ubHlcIixcbiAgICAgICAgdiA6IHRoaXMuem9ubHlcbiAgICB9KTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImZvcm1hdFwiLFxuICAgICAgICB2IDogdGhpcy5mb3JtYXRcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXA7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBbHRpRWxldmF0aW9uUmVxdWVzdDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _AltiRequest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AltiRequest */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js\");\n\n\n\n\n/**\n * @classdesc\n * Classe de gestion des param. des requêtes de type PROFIL du service altimetrique.\n *\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiProfilRequest\n * @param {Object}   options - options\n * @param {String}   options.sampling - 3\n *\n * @private\n */\nfunction AltiProfilRequest (options) {\n    if (!(this instanceof AltiProfilRequest)) {\n        throw new TypeError(\"AltiProfilRequest constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"AltiProfilRequest\";\n\n    // appel du constructeur par heritage\n    _AltiRequest__WEBPACK_IMPORTED_MODULE_1__[\"default\"].apply(this, arguments);\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger();\n    this.logger.trace(\"[Constructeur AltiProfilRequest ()]\");\n\n    /**\n     * Sampling\n     * Par defaut, 3\n     */\n    this.sampling = this.options.sampling || 3; // test des options héritées !\n}\n\n/**\n * @lends module:AltiProfilRequest#\n */\n\nAltiProfilRequest.prototype = Object.create(_AltiRequest__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype, {\n\n    /**\n     * Setter/getter pour \"sampling\"\n     */\n    sampling : {\n        /** getter */\n        get : function () {\n            return this._sampling;\n        },\n        /** setter */\n        set : function (value) {\n            this._sampling = value;\n        }\n    }\n});\n\n/**\n * Constructeur (alias)\n */\nAltiProfilRequest.prototype.constructor = AltiProfilRequest;\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Object[]}\n */\nAltiProfilRequest.prototype.getData = function () {\n    // par glop..., appel de AltiRequest::getData () !\n    var map = [];\n    map.push({\n        k : \"lon\",\n        v : this.getLon()\n    });\n    map.push({\n        k : \"lat\",\n        v : this.getLat()\n    });\n    // map.push({k : \"delimiter\", v : this.delimiter}); // FIXME on retire le param \"delimiter\"\n    map.push({\n        k : \"indent\",\n        v : this.indent\n    });\n    map.push({\n        k : \"crs\",\n        v : this.crs\n    });\n    map.push({\n        k : \"sampling\",\n        v : this.sampling\n    });\n    map.push({\n        k : \"format\",\n        v : this.format\n    });\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiProfilRequest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9tb2RlbC9BbHRpUHJvZmlsUmVxdWVzdC5qcz9hZmY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDdUQ7QUFDZjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksb0RBQVc7O0FBRWYsa0JBQWtCLDhEQUFNO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsb0RBQVc7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLG9DQUFvQyxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFZSxnRkFBaUIsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvQWx0aS9SZXF1ZXN0L21vZGVsL0FsdGlQcm9maWxSZXF1ZXN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbmltcG9ydCBBbHRpUmVxdWVzdCBmcm9tIFwiLi9BbHRpUmVxdWVzdFwiO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzZSBkZSBnZXN0aW9uIGRlcyBwYXJhbS4gZGVzIHJlcXXDqnRlcyBkZSB0eXBlIFBST0ZJTCBkdSBzZXJ2aWNlIGFsdGltZXRyaXF1ZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BbHRpLlJlcXVlc3QuQWx0aVByb2ZpbFJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnNhbXBsaW5nIC0gM1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFsdGlQcm9maWxSZXF1ZXN0IChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFsdGlQcm9maWxSZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWx0aVByb2ZpbFJlcXVlc3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiQWx0aVByb2ZpbFJlcXVlc3RcIjtcblxuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBwYXIgaGVyaXRhZ2VcbiAgICBBbHRpUmVxdWVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEFsdGlQcm9maWxSZXF1ZXN0ICgpXVwiKTtcblxuICAgIC8qKlxuICAgICAqIFNhbXBsaW5nXG4gICAgICogUGFyIGRlZmF1dCwgM1xuICAgICAqL1xuICAgIHRoaXMuc2FtcGxpbmcgPSB0aGlzLm9wdGlvbnMuc2FtcGxpbmcgfHwgMzsgLy8gdGVzdCBkZXMgb3B0aW9ucyBow6lyaXTDqWVzICFcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkFsdGlQcm9maWxSZXF1ZXN0I1xuICovXG5cbkFsdGlQcm9maWxSZXF1ZXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQWx0aVJlcXVlc3QucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBTZXR0ZXIvZ2V0dGVyIHBvdXIgXCJzYW1wbGluZ1wiXG4gICAgICovXG4gICAgc2FtcGxpbmcgOiB7XG4gICAgICAgIC8qKiBnZXR0ZXIgKi9cbiAgICAgICAgZ2V0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsaW5nO1xuICAgICAgICB9LFxuICAgICAgICAvKiogc2V0dGVyICovXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2FtcGxpbmcgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cbkFsdGlQcm9maWxSZXF1ZXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFsdGlQcm9maWxSZXF1ZXN0O1xuXG4vKipcbiAqIFRhYmxlYXUgZGUgY2xlZnMvdmFsZXVycyBwb3VyIHBhcmFtLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAqL1xuQWx0aVByb2ZpbFJlcXVlc3QucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcGFyIGdsb3AuLi4sIGFwcGVsIGRlIEFsdGlSZXF1ZXN0OjpnZXREYXRhICgpICFcbiAgICB2YXIgbWFwID0gW107XG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJsb25cIixcbiAgICAgICAgdiA6IHRoaXMuZ2V0TG9uKClcbiAgICB9KTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImxhdFwiLFxuICAgICAgICB2IDogdGhpcy5nZXRMYXQoKVxuICAgIH0pO1xuICAgIC8vIG1hcC5wdXNoKHtrIDogXCJkZWxpbWl0ZXJcIiwgdiA6IHRoaXMuZGVsaW1pdGVyfSk7IC8vIEZJWE1FIG9uIHJldGlyZSBsZSBwYXJhbSBcImRlbGltaXRlclwiXG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJpbmRlbnRcIixcbiAgICAgICAgdiA6IHRoaXMuaW5kZW50XG4gICAgfSk7XG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJjcnNcIixcbiAgICAgICAgdiA6IHRoaXMuY3JzXG4gICAgfSk7XG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJzYW1wbGluZ1wiLFxuICAgICAgICB2IDogdGhpcy5zYW1wbGluZ1xuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiZm9ybWF0XCIsXG4gICAgICAgIHYgOiB0aGlzLmZvcm1hdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFsdGlQcm9maWxSZXF1ZXN0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n\n\n\n/**\n * @classdesc\n * Classe de gestion des param. des requêtes du service altimetrique.\n *\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiRequest\n * @param {Object} options - options\n * @param {Object}   options.positions - tableau de coordonnées lon/lat\n * @param {String}   options.delimiter - \"|\"\n * @param {Boolean}  options.indent - false|true\n * @param {String}   options.crs - \"CRS:84\"\n * @param {String}   options.format - \"JSON|XML\"\n *\n * @private\n */\nfunction AltiRequest (options) {\n    if (!(this instanceof AltiRequest)) {\n        throw new TypeError(\"AltiRequest constructor cannot be called as a function.\");\n    }\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger();\n    this.logger.trace(\"[Constructeur AltiRequest ()]\");\n\n    /**\n     * Options en paramêtres du constructeur.\n     */\n    this.options = options || {};\n\n    /**\n     * Liste des coordonnées.\n     * @example\n     * var c = [{lon : \"\", lat : \"\"}, {lon : \"\", lat : \"\"}];\n     */\n    this.positions = this.options.positions || [];\n\n    /**\n     * Caractère de séparation.\n     * Par defaut, \"|\".\n     */\n    this.delimiter = this.options.delimiter || \"|\";\n\n    /**\n     * Indentation.\n     * true|false\n     */\n    this.indent = this.options.indent || false;\n\n    /**\n     * Projection.\n     * Par defaut, CRS:84.\n     */\n    this.crs = this.options.crs || \"CRS:84\";\n\n    /**\n     * format de sortie.\n     * Par defaut, \"json\".\n     */\n    this.format = this.options.format || \"json\";\n}\n\n/**\n * CLASSNAME\n */\nAltiRequest.CLASSNAME = \"AltiRequest\";\n\nAltiRequest.prototype = {\n\n    /**\n     * @lends module:AltiRequest#\n     */\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : AltiRequest,\n\n    /**\n     * Ajout d\"une liste de coordonnées.\n     *\n     * @param {Object[]} lstPosition - liste de positions\n     * @example\n     * obj.setPositions ([{lon : \"0.15\", lat : \"0.15\"}, {lon : \"1.15\", lat : \"1.15\"}]);\n     */\n    setPositions : function (lstPosition) {\n        var positions = [];\n        for (var i = 0; i < lstPosition.length; i++) {\n            var o = lstPosition[i];\n            if (o.lon && o.lat) {\n                positions.push(o);\n            }\n        }\n\n        this.positions = positions;\n    },\n\n    /**\n     * Liste des coordonnées.\n     *\n     * @param {Int} pos - position\n     * @returns {positions}\n     * @example\n     * obj.getPositions ();  // [{lon : \"\", lat : \"\"}, {lon : \"\", lat : \"\"}]\n     * obj.getPositions (0); // [{lon : \"\", lat : \"\"}]\n     */\n    getPositions : function (pos) {\n        // FIXME test if not a number !?\n        if (!pos) {\n            return this.positions;\n        }\n\n        var index = this.positions.length - 1;\n        if (pos > index || pos < index) {\n            this.logger.warn(\"index out of range !\");\n            return this.positions;\n        }\n\n        return this.positions[pos];\n    },\n\n    /**\n     * Ajout d\"une liste de coordonnées.\n     *\n     * @param {Object[]} lstPosition - liste de positions\n     * @example\n     * obj.addPositions ([{lon : \"0.15\", lat : \"0.15\"}, {lon : \"1.15\", lat : \"1.15\"}]);\n     */\n    addPositions : function (lstPosition) {\n        for (var i = 0; i < lstPosition.length; i++) {\n            var o = lstPosition[i];\n            if (o.lon && o.lat) {\n                this.positions.push(lstPosition[i]);\n            }\n        }\n    },\n\n    /**\n     * Retourne la liste des longitudes avec un caractère de séparation.\n     *\n     * @returns {String} - une liste de longitudes\n     * @example\n     * // out : 0.2367|2.1570|43.789|...\n     */\n    getLon : function () {\n        var lstLon = [];\n        for (var i = 0; i < this.positions.length; i++) {\n            lstLon.push(this.positions[i].lon);\n        }\n        this.logger.trace(lstLon);\n        return lstLon.join(this.delimiter);\n    },\n\n    /**\n     * Retourne la liste des lattitudes avec un caractère de séparation.\n     *\n     * @returns {String} - une liste de lattitudes\n     * @example\n     * // out : 0.2367|2.1570|43.789|...\n     */\n    getLat : function () {\n        var lstLat = [];\n        for (var i = 0; i < this.positions.length; i++) {\n            lstLat.push(this.positions[i].lat);\n        }\n        this.logger.trace(lstLat);\n        return lstLat.join(this.delimiter);\n    }\n\n};\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Object[]}\n */\nAltiRequest.prototype.getData = function () {\n    var map = [];\n\n    map.push({\n        k : \"lon\",\n        v : this.getLon()\n    });\n    map.push({\n        k : \"lat\",\n        v : this.getLat()\n    });\n    map.push({\n        k : \"delimiter\",\n        v : this.delimiter\n    });\n    map.push({\n        k : \"indent\",\n        v : this.indent\n    });\n    map.push({\n        k : \"crs\",\n        v : this.crs\n    });\n    map.push({\n        k : \"format\",\n        v : this.format\n    });\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiRequest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9tb2RlbC9BbHRpUmVxdWVzdC5qcz8wMjJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUN1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDhEQUFNO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsR0FBRyxtQkFBbUI7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLDJCQUEyQiwyQkFBMkIsR0FBRywyQkFBMkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLE9BQU8sbUJBQW1CLEdBQUcsbUJBQW1CO0FBQzNFLDRCQUE0QixNQUFNLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsMkJBQTJCLDJCQUEyQixHQUFHLDJCQUEyQjtBQUNwRjtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVlLDBFQUFXLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVxdWVzdC9tb2RlbC9BbHRpUmVxdWVzdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3NlIGRlIGdlc3Rpb24gZGVzIHBhcmFtLiBkZXMgcmVxdcOqdGVzIGR1IHNlcnZpY2UgYWx0aW1ldHJpcXVlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLnBvc2l0aW9ucyAtIHRhYmxlYXUgZGUgY29vcmRvbm7DqWVzIGxvbi9sYXRcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMuZGVsaW1pdGVyIC0gXCJ8XCJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIG9wdGlvbnMuaW5kZW50IC0gZmFsc2V8dHJ1ZVxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5jcnMgLSBcIkNSUzo4NFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLmZvcm1hdCAtIFwiSlNPTnxYTUxcIlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFsdGlSZXF1ZXN0IChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFsdGlSZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWx0aVJlcXVlc3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoKTtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIltDb25zdHJ1Y3RldXIgQWx0aVJlcXVlc3QgKCldXCIpO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBlbiBwYXJhbcOqdHJlcyBkdSBjb25zdHJ1Y3RldXIuXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIExpc3RlIGRlcyBjb29yZG9ubsOpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYyA9IFt7bG9uIDogXCJcIiwgbGF0IDogXCJcIn0sIHtsb24gOiBcIlwiLCBsYXQgOiBcIlwifV07XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25zIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2FyYWN0w6hyZSBkZSBzw6lwYXJhdGlvbi5cbiAgICAgKiBQYXIgZGVmYXV0LCBcInxcIi5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGltaXRlciA9IHRoaXMub3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCJ8XCI7XG5cbiAgICAvKipcbiAgICAgKiBJbmRlbnRhdGlvbi5cbiAgICAgKiB0cnVlfGZhbHNlXG4gICAgICovXG4gICAgdGhpcy5pbmRlbnQgPSB0aGlzLm9wdGlvbnMuaW5kZW50IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUHJvamVjdGlvbi5cbiAgICAgKiBQYXIgZGVmYXV0LCBDUlM6ODQuXG4gICAgICovXG4gICAgdGhpcy5jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IFwiQ1JTOjg0XCI7XG5cbiAgICAvKipcbiAgICAgKiBmb3JtYXQgZGUgc29ydGllLlxuICAgICAqIFBhciBkZWZhdXQsIFwianNvblwiLlxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdCB8fCBcImpzb25cIjtcbn1cblxuLyoqXG4gKiBDTEFTU05BTUVcbiAqL1xuQWx0aVJlcXVlc3QuQ0xBU1NOQU1FID0gXCJBbHRpUmVxdWVzdFwiO1xuXG5BbHRpUmVxdWVzdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAbGVuZHMgbW9kdWxlOkFsdGlSZXF1ZXN0I1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IEFsdGlSZXF1ZXN0LFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZFwidW5lIGxpc3RlIGRlIGNvb3Jkb25uw6llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGxzdFBvc2l0aW9uIC0gbGlzdGUgZGUgcG9zaXRpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvYmouc2V0UG9zaXRpb25zIChbe2xvbiA6IFwiMC4xNVwiLCBsYXQgOiBcIjAuMTVcIn0sIHtsb24gOiBcIjEuMTVcIiwgbGF0IDogXCIxLjE1XCJ9XSk7XG4gICAgICovXG4gICAgc2V0UG9zaXRpb25zIDogZnVuY3Rpb24gKGxzdFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3RQb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBsc3RQb3NpdGlvbltpXTtcbiAgICAgICAgICAgIGlmIChvLmxvbiAmJiBvLmxhdCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3RlIGRlcyBjb29yZG9ubsOpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ludH0gcG9zIC0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7cG9zaXRpb25zfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogb2JqLmdldFBvc2l0aW9ucyAoKTsgIC8vIFt7bG9uIDogXCJcIiwgbGF0IDogXCJcIn0sIHtsb24gOiBcIlwiLCBsYXQgOiBcIlwifV1cbiAgICAgKiBvYmouZ2V0UG9zaXRpb25zICgwKTsgLy8gW3tsb24gOiBcIlwiLCBsYXQgOiBcIlwifV1cbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbnMgOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIC8vIEZJWE1FIHRlc3QgaWYgbm90IGEgbnVtYmVyICE/XG4gICAgICAgIGlmICghcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBvc2l0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAocG9zID4gaW5kZXggfHwgcG9zIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJpbmRleCBvdXQgb2YgcmFuZ2UgIVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uc1twb3NdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBam91dCBkXCJ1bmUgbGlzdGUgZGUgY29vcmRvbm7DqWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbHN0UG9zaXRpb24gLSBsaXN0ZSBkZSBwb3NpdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG9iai5hZGRQb3NpdGlvbnMgKFt7bG9uIDogXCIwLjE1XCIsIGxhdCA6IFwiMC4xNVwifSwge2xvbiA6IFwiMS4xNVwiLCBsYXQgOiBcIjEuMTVcIn1dKTtcbiAgICAgKi9cbiAgICBhZGRQb3NpdGlvbnMgOiBmdW5jdGlvbiAobHN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3RQb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBsc3RQb3NpdGlvbltpXTtcbiAgICAgICAgICAgIGlmIChvLmxvbiAmJiBvLmxhdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gobHN0UG9zaXRpb25baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldG91cm5lIGxhIGxpc3RlIGRlcyBsb25naXR1ZGVzIGF2ZWMgdW4gY2FyYWN0w6hyZSBkZSBzw6lwYXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5lIGxpc3RlIGRlIGxvbmdpdHVkZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG91dCA6IDAuMjM2N3wyLjE1NzB8NDMuNzg5fC4uLlxuICAgICAqL1xuICAgIGdldExvbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxzdExvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsc3RMb24ucHVzaCh0aGlzLnBvc2l0aW9uc1tpXS5sb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGxzdExvbik7XG4gICAgICAgIHJldHVybiBsc3RMb24uam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldG91cm5lIGxhIGxpc3RlIGRlcyBsYXR0aXR1ZGVzIGF2ZWMgdW4gY2FyYWN0w6hyZSBkZSBzw6lwYXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5lIGxpc3RlIGRlIGxhdHRpdHVkZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG91dCA6IDAuMjM2N3wyLjE1NzB8NDMuNzg5fC4uLlxuICAgICAqL1xuICAgIGdldExhdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxzdExhdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsc3RMYXQucHVzaCh0aGlzLnBvc2l0aW9uc1tpXS5sYXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGxzdExhdCk7XG4gICAgICAgIHJldHVybiBsc3RMYXQuam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFRhYmxlYXUgZGUgY2xlZnMvdmFsZXVycyBwb3VyIHBhcmFtLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAqL1xuQWx0aVJlcXVlc3QucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJsb25cIixcbiAgICAgICAgdiA6IHRoaXMuZ2V0TG9uKClcbiAgICB9KTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImxhdFwiLFxuICAgICAgICB2IDogdGhpcy5nZXRMYXQoKVxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiZGVsaW1pdGVyXCIsXG4gICAgICAgIHYgOiB0aGlzLmRlbGltaXRlclxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiaW5kZW50XCIsXG4gICAgICAgIHYgOiB0aGlzLmluZGVudFxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiY3JzXCIsXG4gICAgICAgIHYgOiB0aGlzLmNyc1xuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiZm9ybWF0XCIsXG4gICAgICAgIHYgOiB0aGlzLmZvcm1hdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFsdGlSZXF1ZXN0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _Formats_XML__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Formats/XML */ \"./node_modules/geoportal-access-lib/src/Formats/XML.js\");\n/* harmony import */ var _Formats_AltiResponseReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Formats/AltiResponseReader */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js\");\n/* harmony import */ var _model_AltiResponse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./model/AltiResponse */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js\");\n/* harmony import */ var _model_Elevation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./model/Elevation */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js\");\n/**\n * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON\n * (Factory)\n *\n * @module AltiResponseFactory\n * @private\n * @alias Gp.Services.Alti.Response.AltiResponseFactory\n */\n\n\n\n\n\n\n\n\nvar AltiResponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Alti\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      outputFormat :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // logger\n        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"AltiResponseFactory\");\n        logger.trace([\"AltiResponseFactory::build()\"]);\n\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                logger.trace(\"analyze response : raw\");\n                data = options.response;\n            } else {\n                switch (options.outputFormat) {\n                    case \"xml\":\n                        logger.trace(\"analyze response : xml\");\n\n                        try {\n                            var p = new _Formats_XML__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n                                reader : _Formats_AltiResponseReader__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n                            });\n\n                            if (typeof options.response === \"string\") {\n                                p.setXMLString(options.response);\n                            } else {\n                                p.setXMLDoc(options.response);\n                            }\n\n                            data = p.parse();\n\n                            if (!data) {\n                                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EXCEPTION_2\"));\n                            }\n                        } catch (e) {\n                            var message = e.message;\n                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", message),\n                                status : 200,\n                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TYPE_SRVERR\n                            }));\n                            return;\n                        }\n\n                        break;\n\n                    case \"json\":\n                        logger.trace(\"analyze response : json\");\n                        logger.trace(\"analyze response : \", typeof options.response);\n\n                        var JSONResponse = null;\n                        if (typeof options.response === \"string\") {\n                            JSONResponse = JSON.parse(options.response);\n                        } else {\n                            JSONResponse = options.response;\n                        }\n\n                        // le service renvoie t il une erreur ?\n                        if (JSONResponse && JSONResponse.error) {\n                            // ex. {\"error\": {\"code\": \"BAD_PARAMETER\",\"description\": \"The values () cannot be parsed as a valid longitude (double value such as -180 < lat < 180).\"}}\n                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", JSONResponse.error.description),\n                                status : 200,\n                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TYPE_SRVERR\n                            }));\n                            return;\n                        }\n\n                        // analyse de la reponse\n                        if (JSONResponse) {\n                            var elevations = JSONResponse.elevations;\n                            var altiResponse = new _model_AltiResponse__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n                            var elevation;\n                            if (Array.isArray(elevations) && elevations.length) {\n                                for (var i = 0; i < elevations.length; i++) {\n                                    elevation = new _model_Elevation__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n\n                                    if (typeof elevations[i] === \"object\") {\n                                        // elevations[i] est un objet elevation\n                                        if (elevations[i].lon) {\n                                            elevation.lon = elevations[i].lon;\n                                        }\n                                        if (elevations[i].lat) {\n                                            elevation.lat = elevations[i].lat;\n                                        }\n                                        if (elevations[i].z) {\n                                            elevation.z = elevations[i].z;\n                                        }\n                                        if (elevations[i].acc) {\n                                            elevation.acc = elevations[i].acc;\n                                        }\n                                    } else if (typeof elevations[i] === \"number\") {\n                                        // elevations[i] est un nombre, dans le cas de zonly=true notamment\n                                        elevation.z = elevations[i];\n                                    }\n\n                                    if (Array.isArray(altiResponse.elevations)) {\n                                        altiResponse.elevations.push(elevation);\n                                    }\n                                }\n                            }\n                            data = altiResponse;\n                        }\n\n                        if (!data) {\n                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_ANALYSE_2\"),\n                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TYPE_UNKERR,\n                                status : -1\n                            }));\n                            return;\n                        }\n                        break;\n\n                    default:\n                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                            message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_FORMAT_2\"),\n                            type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TYPE_UNKERR,\n                            status : -1\n                        }));\n                        return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service\n                if (data.exceptionReport) {\n                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                } else if (data.error) {\n                    var errorMess = data.error.description;\n                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", errorMess),\n                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                }\n            }\n        } else {\n            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n            return;\n        }\n\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiResponseFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVzcG9uc2UvQWx0aVJlc3BvbnNlRmFjdG9yeS5qcz9kMGVmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29EO0FBQ0E7QUFDUTtBQUNyQjtBQUN3QjtBQUNmO0FBQ047O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBTTtBQUMzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0Msb0RBQUc7QUFDM0MseUNBQXlDLG1FQUFrQjtBQUMzRCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRCxnRUFBSTtBQUNwRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLG9FQUFvRSxnRUFBWTtBQUNoRiwwQ0FBMEMsZ0VBQUk7QUFDOUM7QUFDQSx1Q0FBdUMsZ0VBQVk7QUFDbkQsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QyxvRUFBb0UsZ0VBQVk7QUFDaEYsMENBQTBDLGdFQUFJO0FBQzlDO0FBQ0EsdUNBQXVDLGdFQUFZO0FBQ25ELDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwyREFBWTtBQUMvRDtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QjtBQUN0RSxvREFBb0Qsd0RBQVM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLGdFQUFZO0FBQ2hGLDBDQUEwQyxnRUFBSTtBQUM5Qyx1Q0FBdUMsZ0VBQVk7QUFDbkQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLGdFQUFZO0FBQzVFLHNDQUFzQyxnRUFBSTtBQUMxQyxtQ0FBbUMsZ0VBQVk7QUFDL0M7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTRELGdFQUFZO0FBQ3hFLGtDQUFrQyxnRUFBSTtBQUN0QywrQkFBK0IsZ0VBQVk7QUFDM0M7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0REFBNEQsZ0VBQVk7QUFDeEUsa0NBQWtDLGdFQUFJO0FBQ3RDLCtCQUErQixnRUFBWTtBQUMzQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0RBQW9ELGdFQUFZLENBQUMsZ0VBQUk7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsa0ZBQW1CLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVzcG9uc2UvQWx0aVJlc3BvbnNlRmFjdG9yeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmFjdG9yeSBwb3VyIGfDqW7DqXJlciB1bmUgcmVwb25zZSBKU09OIMOgIHBhcnRpciBkJ3VuIFhNTCBvdSBkJ3VuIEpTT05cbiAqIChGYWN0b3J5KVxuICpcbiAqIEBtb2R1bGUgQWx0aVJlc3BvbnNlRmFjdG9yeVxuICogQHByaXZhdGVcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BbHRpLlJlc3BvbnNlLkFsdGlSZXNwb25zZUZhY3RvcnlcbiAqL1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgTVJlcyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBFcnJvclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL0V4Y2VwdGlvbnMvRXJyb3JTZXJ2aWNlXCI7XG5pbXBvcnQgWE1MIGZyb20gXCIuLi8uLi8uLi9Gb3JtYXRzL1hNTFwiO1xuaW1wb3J0IEFsdGlSZXNwb25zZVJlYWRlciBmcm9tIFwiLi4vRm9ybWF0cy9BbHRpUmVzcG9uc2VSZWFkZXJcIjtcbmltcG9ydCBBbHRpUmVzcG9uc2UgZnJvbSBcIi4vbW9kZWwvQWx0aVJlc3BvbnNlXCI7XG5pbXBvcnQgRWxldmF0aW9uIGZyb20gXCIuL21vZGVsL0VsZXZhdGlvblwiO1xuXG52YXIgQWx0aVJlc3BvbnNlRmFjdG9yeSA9IHtcblxuICAgIC8qKlxuICAgICAqIGludGVyZmFjZSB1bmlxdWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IEFsdGlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIHJlc3BvbnNlIDpcbiAgICAgKiAgICAgIG91dHB1dEZvcm1hdCA6XG4gICAgICogICAgICByYXdSZXNwb25zZSA6XG4gICAgICogICAgICBzY29wZSA6XG4gICAgICogICAgICBvblN1Y2Nlc3MgOlxuICAgICAqICAgICAgb25FcnJvciA6XG4gICAgICogICB9O1xuICAgICAqXG4gICAgICovXG4gICAgYnVpbGQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBsb2dnZXJcbiAgICAgICAgdmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJBbHRpUmVzcG9uc2VGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiQWx0aVJlc3BvbnNlRmFjdG9yeTo6YnVpbGQoKVwiXSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yYXdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImFuYWx5emUgcmVzcG9uc2UgOiByYXdcIik7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5vdXRwdXRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInhtbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiYW5hbHl6ZSByZXNwb25zZSA6IHhtbFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBYTUwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgOiBBbHRpUmVzcG9uc2VSZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNldFhNTFN0cmluZyhvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNldFhNTERvYyhvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcC5wYXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNUmVzLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTl8yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IEVycm9yU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBNUmVzLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogRXJyb3JTZXJ2aWNlLlRZUEVfU1JWRVJSXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImFuYWx5emUgcmVzcG9uc2UgOiBqc29uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiYW5hbHl6ZSByZXNwb25zZSA6IFwiLCB0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBKU09OUmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTlJlc3BvbnNlID0gSlNPTi5wYXJzZShvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTlJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGUgc2VydmljZSByZW52b2llIHQgaWwgdW5lIGVycmV1ciA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSlNPTlJlc3BvbnNlICYmIEpTT05SZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4LiB7XCJlcnJvclwiOiB7XCJjb2RlXCI6IFwiQkFEX1BBUkFNRVRFUlwiLFwiZGVzY3JpcHRpb25cIjogXCJUaGUgdmFsdWVzICgpIGNhbm5vdCBiZSBwYXJzZWQgYXMgYSB2YWxpZCBsb25naXR1ZGUgKGRvdWJsZSB2YWx1ZSBzdWNoIGFzIC0xODAgPCBsYXQgPCAxODApLlwifX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgRXJyb3JTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IE1SZXMuZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRVhDRVBUSU9OXCIsIEpTT05SZXNwb25zZS5lcnJvci5kZXNjcmlwdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IEVycm9yU2VydmljZS5UWVBFX1NSVkVSUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuYWx5c2UgZGUgbGEgcmVwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEpTT05SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGV2YXRpb25zID0gSlNPTlJlc3BvbnNlLmVsZXZhdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGlSZXNwb25zZSA9IG5ldyBBbHRpUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxldmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZXZhdGlvbnMpICYmIGVsZXZhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxldmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uID0gbmV3IEVsZXZhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZXZhdGlvbnNbaV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGV2YXRpb25zW2ldIGVzdCB1biBvYmpldCBlbGV2YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS5sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLmxvbiA9IGVsZXZhdGlvbnNbaV0ubG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS5sYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLmxhdCA9IGVsZXZhdGlvbnNbaV0ubGF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS56KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZXZhdGlvbi56ID0gZWxldmF0aW9uc1tpXS56O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS5hY2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLmFjYyA9IGVsZXZhdGlvbnNbaV0uYWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZXZhdGlvbnNbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGV2YXRpb25zW2ldIGVzdCB1biBub21icmUsIGRhbnMgbGUgY2FzIGRlIHpvbmx5PXRydWUgbm90YW1tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLnogPSBlbGV2YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbHRpUmVzcG9uc2UuZWxldmF0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRpUmVzcG9uc2UuZWxldmF0aW9ucy5wdXNoKGVsZXZhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGFsdGlSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IEVycm9yU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBNUmVzLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0VfMlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IEVycm9yU2VydmljZS5UWVBFX1VOS0VSUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBFcnJvclNlcnZpY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBNUmVzLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0ZPUk1BVF8yXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBFcnJvclNlcnZpY2UuVFlQRV9VTktFUlIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogLTFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTaSBsYSByw6lwb25zZSBjb250ZW5haXQgdW5lIGV4Y2VwdGlvbiByZW52b3nDqWUgcGFyIGxlIHNlcnZpY2VcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5leGNlcHRpb25SZXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IEVycm9yU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogTVJlcy5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgZGF0YS5leGNlcHRpb25SZXBvcnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IEVycm9yU2VydmljZS5UWVBFX1NSVkVSUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IDIwMFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzcyA9IGRhdGEuZXJyb3IuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBFcnJvclNlcnZpY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IE1SZXMuZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRVhDRVBUSU9OXCIsIGVycm9yTWVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogRXJyb3JTZXJ2aWNlLlRZUEVfU1JWRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogMjAwXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBFcnJvclNlcnZpY2UoTVJlcy5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MuY2FsbChvcHRpb25zLnNjb3BlLCBkYXRhKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBbHRpUmVzcG9uc2VGYWN0b3J5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Response object for {@link module:Services~getAltitude Gp.Services.getAltitude ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Array.<Gp.Services.Alti.Elevation>} elevations - Elevations array.\n *\n * @namespace\n * @alias Gp.Services.AltiResponse\n */\nfunction AltiResponse () {\n    if (!(this instanceof AltiResponse)) {\n        throw new TypeError(\"AltiResponse constructor cannot be called as a function.\");\n    }\n\n    this.elevations = [];\n}\n\nAltiResponse.prototype = {\n\n    constructor : AltiResponse\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AltiResponse);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVzcG9uc2UvbW9kZWwvQWx0aVJlc3BvbnNlLmpzPzZmNjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBLHdCQUF3Qiw2REFBNkQ7QUFDckY7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRWUsMkVBQVksRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvQWx0aS9SZXNwb25zZS9tb2RlbC9BbHRpUmVzcG9uc2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlc3BvbnNlIG9iamVjdCBmb3Ige0BsaW5rIG1vZHVsZTpTZXJ2aWNlc35nZXRBbHRpdHVkZSBHcC5TZXJ2aWNlcy5nZXRBbHRpdHVkZSAoKX0gaW52b2NhdGlvbiB3aGVuIHN1Y2Nlc3NmdWwuIFJlY2VpdmVkIGFzIHRoZSBhcmd1bWVudCBvZiBvblN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48R3AuU2VydmljZXMuQWx0aS5FbGV2YXRpb24+fSBlbGV2YXRpb25zIC0gRWxldmF0aW9ucyBhcnJheS5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQWx0aVJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIEFsdGlSZXNwb25zZSAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFsdGlSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFsdGlSZXNwb25zZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZWxldmF0aW9ucyA9IFtdO1xufVxuXG5BbHRpUmVzcG9uc2UucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3IgOiBBbHRpUmVzcG9uc2VcblxufTtcblxuZXhwb3J0IGRlZmF1bHQgQWx0aVJlc3BvbnNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n/**\n * Single elevation object returned by underlying web service. Contains at least, one elevation (z). May also contain point coordinates and elevation accuracy if \"zonly\" parameter wasn't set to true.\n *\n * @property {Float} lat - Point latitude. (only if zonly=false)\n * @property {Float} lon - Point longitude. (only if zonly=false)\n * @property {Float} z - Point elevation.\n * @property {Float} acc - Accuracy of elevation for this point. (only if zonly=false)\n *\n * @namespace\n * @alias Gp.Services.Alti.Elevation\n */\nfunction Elevation () {\n    if (!(this instanceof Elevation)) {\n        throw new TypeError(\"Elevation constructor cannot be called as a function.\");\n    }\n\n    this.z = null;\n}\n\nElevation.prototype = {\n\n    constructor : Elevation\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Elevation);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVzcG9uc2UvbW9kZWwvRWxldmF0aW9uLmpzP2M2NjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVlLHdFQUFTLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0FsdGkvUmVzcG9uc2UvbW9kZWwvRWxldmF0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFNpbmdsZSBlbGV2YXRpb24gb2JqZWN0IHJldHVybmVkIGJ5IHVuZGVybHlpbmcgd2ViIHNlcnZpY2UuIENvbnRhaW5zIGF0IGxlYXN0LCBvbmUgZWxldmF0aW9uICh6KS4gTWF5IGFsc28gY29udGFpbiBwb2ludCBjb29yZGluYXRlcyBhbmQgZWxldmF0aW9uIGFjY3VyYWN5IGlmIFwiem9ubHlcIiBwYXJhbWV0ZXIgd2Fzbid0IHNldCB0byB0cnVlLlxuICpcbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IGxhdCAtIFBvaW50IGxhdGl0dWRlLiAob25seSBpZiB6b25seT1mYWxzZSlcbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IGxvbiAtIFBvaW50IGxvbmdpdHVkZS4gKG9ubHkgaWYgem9ubHk9ZmFsc2UpXG4gKiBAcHJvcGVydHkge0Zsb2F0fSB6IC0gUG9pbnQgZWxldmF0aW9uLlxuICogQHByb3BlcnR5IHtGbG9hdH0gYWNjIC0gQWNjdXJhY3kgb2YgZWxldmF0aW9uIGZvciB0aGlzIHBvaW50LiAob25seSBpZiB6b25seT1mYWxzZSlcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQWx0aS5FbGV2YXRpb25cbiAqL1xuZnVuY3Rpb24gRWxldmF0aW9uICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRWxldmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRWxldmF0aW9uIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy56ID0gbnVsbDtcbn1cblxuRWxldmF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogRWxldmF0aW9uXG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVsZXZhdGlvbjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/CommonService.js":
/*!*************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/CommonService.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ \"./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/Helper */ \"./node_modules/geoportal-access-lib/src/Utils/Helper.js\");\n/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Utils/MessagesResources */ \"./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\");\n/* harmony import */ var _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Protocols/Protocol */ \"./node_modules/geoportal-access-lib/src/Protocols/Protocol.js\");\n/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Exceptions/ErrorService */ \"./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js\");\n/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DefaultUrlService */ \"./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js\");\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../package.json */ \"./node_modules/geoportal-access-lib/package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_6___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../package.json */ \"./node_modules/geoportal-access-lib/package.json\", 1);\n\n\n\n\n\n\n// package.json (extract version)\n\n\n/**\n * @classdesc\n * Composant Service\n *\n * @constructor\n * @alias Gp.Services.CommonService\n * @param {Object} options - options communes à tous les services\n *\n * @param {String} options.apiKey - Clef d'accès à la plateforme Géoportail,\n *      nécessaire pour franchir la couche de contrôle des accès pour avoir une réponse du service invoqué.\n *      Plusieurs clefs peuvent être passées dans le cas de l'invocation du service d'autoconfiguration.\n *      Si ce paramètre n'est pas renseigné, alors le paramètre serverUrl doit être renseigné (comprenant alors, si nécessaire la clef API).\n *\n * @param {String} options.serverUrl - URL d'accès au service.\n *      Permet de forcer l'utilisation d'un service équivalent déployé derrière une éventuelle autre URL d'accès.\n *      Si ce paramètre est renseigné alors, le paramètre apiKey est ignoré.\n *\n * @param {String} [options.protocol] - Le protocole à utiliser pour récupérer les informations du service :\n *      peut valoir 'JSONP' ou 'XHR'.\n *      Par défaut, c'est le protocole XHR qui sera utilisé.\n *      Attention, le protocole JSONP n'est pas valide dans un environnement NodeJS (Utilisation du mode XHR).\n *\n * @param {Boolean} [options.ssl] - Indique si l'on souhaite intérroger les services en https.\n *      Ce paramètre ne fonctionne que pour une utilisation hors navigateur (ex. NodeJS).\n *      Sur un navigateur, le protocole est automatiquement extrait de l'url du site...\n *      Par défaut, on utilise le protocole http (ssl=false).\n *\n * @param {String} [options.proxyURL] - Le proxy à utiliser pour pallier au problème de cross-domain dans le cas d'une requête XHR.\n *      Utile si le paramètre 'protocol' vaut 'XHR', il ne sera pas pris en compte si protocol vaut JSONP.\n *\n * @param {String} [options.callbackSuffix] - Suffixe de la fonction de callback à utiliser, dans le cas du protocole JSONP.\n *      Par défaut, la fonction de callback portera un nom du type \"callback\"+ID, où ID est soit un identifiant unique généré à chaque requête,\n *      soit le paramètre callbackSuffix s'il est spécifié. Par exemple, si callbackSuffix=\"_2\", la fonction sera \"callback_2 ()\".\n *      Utile pour utiliser une réponse déjà encapsulée dans une fonction de callback, dont le nom est connu (ex : chargement de l'autoconfiguration en local)\n *      Utile seulement si le paramètre 'protocol' vaut 'JSONP', il ne sera pas pris en compte si protocol vaut 'XHR'.\n *\n * @param {String} [options.httpMethod] - La méthode HTTP\n *      à utiliser dans le cas d'une requête XHR : peut valoir 'GET' ou 'POST'.\n *      Non pris en compte si 'protocol' vaut JSONP qui fonctionne obligatoirement en GET.\n *      Par défaut, c'est la méthode GET qui est utilisée.\n *\n * @param {String} [options.contentType] - Content-Type de la requete\n *      à utiliser dans le cas d'une requête XHR en mode POST.\n *      Non pris en compte si 'protocol' vaut JSONP et/ou la méthode HTTP vaut GET.\n *      Par défaut, c'est la méthode GET qui est utilisée donc on n'utilise pas de Content-Type.\n *\n * @param {Number} [options.timeOut] - Délai d'attente maximal (en ms) de la réponse du service (à partir de l'envoi de la requête).\n *      Par défaut, aucun timeOut n'est pris en compte (timeoutDelay= 0).\n *\n * @param {Boolean} [options.rawResponse] - Indique si l'on souhaite que la réponse du service ne soit pas parsée par l'API avant d'être restituée.\n *      (Cf. paramètre « onSuccess » pour plus de détails).\n *\n * @param {Function} [options.onSuccess] - Fonction appelée lorsque le service répond correctement à la requête\n *      (code HTTP 200, sans message d'erreur).\n *      Cette fonction prend en paramètre la réponse du service,\n *      soit sous la forme d'un Object Javascript formaté par le parseur dédié à la syntaxe du service (comportement par défaut) ;\n *      soit brute au format String non prétraité si le paramètre « rawResponse » a été précisé avec la valeur « true ».\n *\n * @param {Function} [options.onFailure] - Fonction appelée lorsque le service ne répond pas correctement\n *      (code HTTP de retour différent de 200 ou pas de réponse).\n *\n * @param {Function} [options.onBeforeParse] - Fonction appelée avant le parsing de la réponse\n *      Permet de modifier la réponse avant parsing et la fonction doit retourner une String.\n *      Cette fonction prend en paramètre la réponse telle que renvoyée par le service\n *      (cad au format json ou xml).\n *      Pour le JSONP, si le paramètre \"rawResponse\" a été précisé avec la valeur \"true\",\n *      la fonction prend en paramètre un Object JavaScript contenant la réponse XML.\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      ssl : false,\n *      proxyURL : null,\n *      callbackName : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      onBeforeParse : function (rawResponse) {}\n *   };\n * @private\n */\nfunction CommonService (options) {\n    if (!(this instanceof CommonService)) {\n        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"CLASS_CONSTRUCTOR\"));\n    }\n\n    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"CommonService\");\n    this.logger.trace(\"[Constructeur CommonService (options)]\");\n\n    // #####################\n    // récupération des options par défaut pour les paramètres optionnels\n    // #####################\n\n    /**\n     * Options du service\n     * @type {Object}\n     */\n    this.options = {\n        // protocol : \"JSONP\",\n        protocol : \"XHR\",\n        ssl : true,\n        proxyURL : \"\",\n        // callbackName : \"\",\n        callbackSuffix : null,\n        httpMethod : \"GET\",\n        timeOut : 0,\n        rawResponse : false,\n        scope : this,\n        /**\n        * callback par defaut pour la reponse\n        * @param {Object} response - response\n        * @private\n        */\n        onSuccess : function (response) {\n            console.log(\"onSuccess - la reponse est la suivante : \", response);\n        },\n        /**\n        * callback par defaut pour les erreurs\n        * @param {Object} error - error\n        * @private\n        */\n        onFailure : function (error) {\n            if (error.status === 200 || !error.status) {\n                console.log(\"onFailure : \", error.message);\n            } else {\n                console.log(\"onFailure - Erreur (\", error.status, \") : \", error.message);\n            }\n        }\n    };\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n\n    // #####################\n    // analyse des options\n    // #####################\n\n    // gestion des clefs API\n    if (!this.options.apiKey && !this.options.serverUrl) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_MISSING\", \"apiKey\", \"serverUrl\"));\n    }\n\n    // modification de la fonction de callback onSuccess dans le cas où la réponse brute est demandée\n    if (this.options.rawResponse && !this.options.onSuccess) {\n        /**\n        * callback par defaut pour la reponse\n        * @param {Object} response - response\n        * @private\n        */\n        this.options.onSuccess = function (response) {\n            console.log(\"onSuccess - la réponse brute du service est la suivante : \", response);\n        };\n    }\n\n    // gestion du callback onSuccess\n    var bOnSuccess = !!(this.options.onSuccess !== null && typeof this.options.onSuccess === \"function\");\n    if (!bOnSuccess) {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_MISSING\", \"onSuccess()\"));\n    }\n\n    // gestion de l'url du service par defaut\n    if (!this.options.serverUrl) {\n        // INFO\n        // gestion de l'url du service par defaut pour les services qui ne possèdent qu'une seul url par defaut\n        // les cas particuliers des services avec plusieurs urls (ex. Alti) devront être traité dans la classe du composant\n        // donc si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n        _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ssl = this.options.ssl;\n        var urlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_5__[\"default\"][this.CLASSNAME].url(this.options.apiKey);\n        if (typeof urlByDefault === \"string\") {\n            this.options.serverUrl = urlByDefault;\n        } else {\n            this.logger.trace(\"URL par defaut à determiner au niveau du composant...\");\n        }\n    }\n\n    // FIXME nettoyage des KVP dans l'url du service\n    // if (this.options.serverUrl) {\n    //     // INFO\n    //     // si l'url est renseignée, il faut la nettoyer de tous ses KVP\n    //     // ex. on ne veut pas de params. 'callback' ou 'output' car ceci declencherait\n    //     // des opérations d'encapsulations des reponses légèrement farfelues ...\n    //     var urlsource = this.options.serverUrl;\n    //     var urlparts = urlsource.split(\"?\");\n    //     this.options.serverUrl = urlparts[0];\n    // }\n\n    // gestion de la methode HTTP\n    this.options.httpMethod = (typeof options.httpMethod === \"string\") ? options.httpMethod.toUpperCase() : \"GET\";\n\n    switch (this.options.httpMethod) {\n        case \"POST\":\n        case \"GET\":\n            break;\n        case \"PUT\":\n        case \"DELETE\":\n        case \"HEAD\":\n        case \"OPTIONS\":\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_NOT_SUPPORT\", \"httpMethod\"));\n        default:\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_UNKNOWN\", \"httpMethod\"));\n    }\n\n    // gestion du protocole\n    // this.options.protocol = (typeof options.protocol === \"string\" ) ? options.protocol.toUpperCase() : \"JSONP\";\n    this.options.protocol = (typeof options.protocol === \"string\") ? options.protocol.toUpperCase() : \"XHR\";\n\n    switch (this.options.protocol) {\n        case \"JSONP\":\n        case \"XHR\":\n            break;\n        default:\n            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_UNKNOWN\", \"protocol\"));\n    }\n\n    // on determine l'environnement d'execution : browser ou non ?\n    // et on lance une exception sur l'utilisation du protocole JSONP pour nodeJS...\n    if (typeof window === \"undefined\" && this.options.protocol === \"JSONP\") {\n        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getMessage(\"PARAM_NOT_SUPPORT_NODEJS\", \"protocol=JSONP (instead use XHR)\"));\n    }\n\n    // le protocole JSONP ne fonctionne qu'en GET.\n    if (this.options.protocol === \"JSONP\") {\n        this.options.httpMethod = \"GET\";\n    }\n\n    // gestion du cache\n    this.options.nocache = options.nocache || false;\n\n    // #####################\n    // attributs d'instances\n    // #####################\n\n    /**\n     * Format de réponse du service\n     */\n    this.options.outputFormat = null;\n    /**\n     * Requête envoyée au service\n     */\n    this.request = null;\n    /**\n     * Reponse du service\n     */\n    this.response = null;\n}\n\n/**\n * @lends module:CommonService\n */\nCommonService.prototype = {\n\n    /*\n     * Constructeur (alias)\n     */\n    constructor : CommonService,\n\n    /**\n     * Appel du service Géoportail\n     */\n    call : function () {\n        /* jshint validthis : true */\n        this.logger.trace(\"CommonService::call ()\");\n\n        var context = this;\n        /** fonction d'execution */\n        function run () {\n            this.logger.trace(\"CommonService::run ()\");\n            this.buildRequest.call(context, onError, onBuildRequest);\n        }\n\n        run.call(context);\n\n        // callback de fin de construction de la requête\n        function onBuildRequest (result) {\n            this.logger.trace(\"CommonService::onBuildRequest : \", result);\n            this.callService.call(context, onError, onCallService);\n        }\n\n        // callback de fin d'appel au service\n        function onCallService (result) {\n            this.logger.trace(\"CommonService::onCallService : \", result);\n            this.analyzeResponse.call(context, onError, onAnalyzeResponse);\n        }\n\n        // callback de fin de lecture de la reponse\n        function onAnalyzeResponse (result) {\n            this.logger.trace(\"CommonService::onAnalyzeResponse : \", result);\n            if (result) {\n                this.options.onSuccess.call(this, result);\n            } else {\n                return onError.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"Analyse de la reponse en échec !?\"));\n            }\n        }\n\n        // callback de gestion des erreurs : renvoit un objet de type ErrorService\n        function onError (error) {\n            this.logger.trace(\"CommonService::onError()\");\n            // error : l'objet est du type ErrorService ou Error\n            var e = error;\n            if (!(e instanceof _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"])) {\n                e = new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](error.message);\n            }\n            this.options.onFailure.call(this, e);\n        }\n    },\n\n    /**\n     * Création de la requête\n     * @param {Function} error - callback\n     * @param {Function} success - callback\n     */\n    buildRequest : function (error, success) {\n        // INFO\n        this.logger.error(\"overwritten method !\");\n        // retourne l'objet 'this.request'\n        if (error) {\n            error.call(this, \"This method must be overwritten !\");\n        }\n        success.call(this, \"This method must be overwritten !\");\n    },\n\n    /**\n     * Appel du service\n     * @param {Function} error - callback\n     * @param {Function} success - callback\n     */\n    callService : function (error, success) {\n        // INFO\n        // retourne l'objet 'this.response'\n\n        // NOTES\n        //  Pour le mode XHR, on recupère une reponse sous forme d'un json ou xml (#document).\n        //  Pour le mode JSONP, on a toujours un objet JSON mais sous 2 formes :\n        //      - natif\n        //      - XML encapsulé :\n        //          {http : {status:200, error:null},xml :'réponse du service'}\n        //          {http : {status:400, error:'reponse du service'},xml :null}\n        //  En XHR, la reponse est directement sauvegardée dans 'this.response'.\n        //  Par contre, en JSONP, on doit analyser la reponse (status ou non vide),\n        //  et ne renvoyer que le contenu (xml ou l'objet)\n\n        // gestion de la proxification du service\n        var strUrlProxified = null;\n        var strData = this.request;\n\n        // a t on mis en place un proxy ?\n        // la proxyfication est valable uniquement en mode XHR !\n        var bUrlProxified = !!(this.options.proxyURL && this.options.protocol === \"XHR\");\n\n        // rajout de l'option gpbibaccess\n        // INFO : acces au numero de version de package.conf aprés compilation !\n        if (this.CLASSNAME !== \"Geocode\" && this.CLASSNAME !== \"ReverseGeocode\" && this.CLASSNAME !== \"AutoComplete\") {\n            this.options.serverUrl = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(this.options.serverUrl, {\n                \"gp-access-lib\" : _package_json__WEBPACK_IMPORTED_MODULE_6__.version\n            }, false);\n        }\n\n        // si le proxy est renseigné, on proxifie l'url du service\n        if (bUrlProxified) {\n            if (this.options.httpMethod === \"GET\") {\n                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(this.options.serverUrl, this.request, true);\n                strData = null;\n            }\n\n            if (this.options.httpMethod === \"POST\") {\n                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalyzeUrl(this.options.serverUrl, null, true);\n                strData = this.request;\n            }\n        }\n\n        // contexte du composant spécifique !\n        var self = this;\n\n        var options = {\n            url : strUrlProxified || this.options.serverUrl,\n            method : this.options.httpMethod,\n            protocol : this.options.protocol,\n            timeOut : this.options.timeOut || 0,\n            format : this.options.outputFormat, // ceci declenche le parsing de la reponse du service, mais on souhaite toujours une reponse brute (string) !\n            nocache : this.options.nocache || false, // ceci permet d'ajouter un timestamp dans la requête\n            wrap : this.options.protocol !== \"XHR\", // ceci declenche l'encapsulation de la reponse XML du service dans du JSON, mais pas en mode XHR !\n            callbackSuffix : this.options.callbackSuffix,\n            // callbackName : this.options.callbackName || null,\n            data : strData,\n            headers : null, // TODO...\n            content : this.options.contentType || \"application/xml\",\n            scope : this.options.scope || this,\n            // callback de reponse\n            onResponse : function (response) {\n                self.logger.trace(\"callService::onResponse()\");\n\n                // le contenu de la reponse à renvoyer !\n                var content = null;\n\n                // XHR : on renvoie toujours la reponse brute du service (json ou xml)\n                // au parser du composant...\n                if (self.options.protocol === \"XHR\") {\n                    self.logger.trace(\"Response XHR\", response);\n                    content = response; // par defaut, la reponse du service  !\n                }\n\n                // JSONP : on pre-analyse la reponse brute du service (encapsuler ou pas)\n                // avant de l'envoyer au parser du composant...\n                if (self.options.protocol === \"JSONP\") {\n                    self.logger.trace(\"Response JSON\", response);\n                    if (response) {\n                        if (response.http) {\n                            // reponse encapsulée :\n                            // ex. reponse du service en xml\n                            // > {http : {status:200, error:null},xml :'réponse du service'}\n                            if (response.http.status !== 200) {\n                                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n                                    status : response.http.status,\n                                    message : response.http.error,\n                                    type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"].TYPE_SRVERR\n                                }));\n                                return;\n                            } else {\n                                content = response.xml; // par defaut !\n                                if (self.options.rawResponse) {\n                                    content = response;\n                                }\n                            }\n                        } else {\n                            // reponse non encapsulée :\n                            // ex. reponse du service en json ou xml\n                            content = response;\n                        }\n                    } else {\n                        error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"Le contenu de la reponse est vide !?\"));\n                        return;\n                    }\n                }\n\n                // si on souhaite parser la reponse du service\n                if (typeof self.options.onBeforeParse === \"function\") {\n                    var newResponse = self.options.onBeforeParse(content);\n                    if (typeof newResponse === \"string\") {\n                        // la reponse parsée par l'utilisateur est retournée sous\n                        // forme de string !\n                        content = newResponse;\n                    }\n                }\n                // sauvegarde de la reponse dans l'objet parent (CommonService)\n                self.response = content;\n                // on renvoie la reponse...\n                success.call(self, content);\n            },\n            // callback des erreurs\n            onFailure : function (e) {\n                self.logger.trace(\"callService::onFailure()\");\n                // on est forcement sur une erreur levée par un service !\n                e.type = _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"].TYPE_SRVERR;\n                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](e));\n            },\n            // callback de timeOut\n            onTimeOut : function () {\n                self.logger.trace(\"callService::onTimeOut()\");\n                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"TimeOut!\"));\n            }\n        };\n\n        _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__[\"default\"].send(options);\n    },\n\n    /**\n     * Analyse de la réponse\n     * @param {Function} error - callback\n     * @param {Function} success - callback\n     */\n    analyzeResponse : function (error, success) {\n        // INFO\n        this.logger.error(\"overwritten method !\");\n        // retourne l'objet spécifique au type de composant (json)\n        if (error) {\n            error.call(this, \"This method must be overwritten !\");\n        }\n        success.call(this, \"This method must be overwritten !\");\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CommonService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0NvbW1vblNlcnZpY2UuanM/MWIyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBOEM7QUFDVDtBQUNNO0FBQ0U7QUFDUztBQUNGO0FBQ3BEO0FBQ3FDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFDO0FBQzdCOztBQUVBLGtCQUFrQiw4REFBTTtBQUN4Qjs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSx1QkFBdUI7QUFDakU7QUFDQSxxREFBcUQsZ0VBQVk7QUFDakU7QUFDQTtBQUNBLDJDQUEyQyxnRUFBWTtBQUN2RCxpQ0FBaUM7QUFDakM7QUFDQSw2QkFBNkI7QUFDN0IsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDZDQUE2QyxnRUFBWTtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQVk7QUFDckMscUNBQXFDLGdFQUFZO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0VBQVk7QUFDakQ7QUFDQTs7QUFFQSxRQUFRLDJEQUFRO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsNEVBQWEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvU2VydmljZXMvQ29tbW9uU2VydmljZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi4vVXRpbHMvSGVscGVyXCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vVXRpbHMvTWVzc2FnZXNSZXNvdXJjZXNcIjtcbmltcG9ydCBQcm90b2NvbCBmcm9tIFwiLi4vUHJvdG9jb2xzL1Byb3RvY29sXCI7XG5pbXBvcnQgRXJyb3JTZXJ2aWNlIGZyb20gXCIuLi9FeGNlcHRpb25zL0Vycm9yU2VydmljZVwiO1xuaW1wb3J0IERlZmF1bHRVcmxTZXJ2aWNlIGZyb20gXCIuL0RlZmF1bHRVcmxTZXJ2aWNlXCI7XG4vLyBwYWNrYWdlLmpzb24gKGV4dHJhY3QgdmVyc2lvbilcbmltcG9ydCBQa2cgZnJvbSBcIi4uLy4uL3BhY2thZ2UuanNvblwiO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbXBvc2FudCBTZXJ2aWNlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQ29tbW9uU2VydmljZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGNvbW11bmVzIMOgIHRvdXMgbGVzIHNlcnZpY2VzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gQ2xlZiBkJ2FjY8OocyDDoCBsYSBwbGF0ZWZvcm1lIEfDqW9wb3J0YWlsLFxuICogICAgICBuw6ljZXNzYWlyZSBwb3VyIGZyYW5jaGlyIGxhIGNvdWNoZSBkZSBjb250csO0bGUgZGVzIGFjY8OocyBwb3VyIGF2b2lyIHVuZSByw6lwb25zZSBkdSBzZXJ2aWNlIGludm9xdcOpLlxuICogICAgICBQbHVzaWV1cnMgY2xlZnMgcGV1dmVudCDDqnRyZSBwYXNzw6llcyBkYW5zIGxlIGNhcyBkZSBsJ2ludm9jYXRpb24gZHUgc2VydmljZSBkJ2F1dG9jb25maWd1cmF0aW9uLlxuICogICAgICBTaSBjZSBwYXJhbcOodHJlIG4nZXN0IHBhcyByZW5zZWlnbsOpLCBhbG9ycyBsZSBwYXJhbcOodHJlIHNlcnZlclVybCBkb2l0IMOqdHJlIHJlbnNlaWduw6kgKGNvbXByZW5hbnQgYWxvcnMsIHNpIG7DqWNlc3NhaXJlIGxhIGNsZWYgQVBJKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5zZXJ2ZXJVcmwgLSBVUkwgZCdhY2PDqHMgYXUgc2VydmljZS5cbiAqICAgICAgUGVybWV0IGRlIGZvcmNlciBsJ3V0aWxpc2F0aW9uIGQndW4gc2VydmljZSDDqXF1aXZhbGVudCBkw6lwbG95w6kgZGVycmnDqHJlIHVuZSDDqXZlbnR1ZWxsZSBhdXRyZSBVUkwgZCdhY2PDqHMuXG4gKiAgICAgIFNpIGNlIHBhcmFtw6h0cmUgZXN0IHJlbnNlaWduw6kgYWxvcnMsIGxlIHBhcmFtw6h0cmUgYXBpS2V5IGVzdCBpZ25vcsOpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm90b2NvbF0gLSBMZSBwcm90b2NvbGUgw6AgdXRpbGlzZXIgcG91ciByw6ljdXDDqXJlciBsZXMgaW5mb3JtYXRpb25zIGR1IHNlcnZpY2UgOlxuICogICAgICBwZXV0IHZhbG9pciAnSlNPTlAnIG91ICdYSFInLlxuICogICAgICBQYXIgZMOpZmF1dCwgYydlc3QgbGUgcHJvdG9jb2xlIFhIUiBxdWkgc2VyYSB1dGlsaXPDqS5cbiAqICAgICAgQXR0ZW50aW9uLCBsZSBwcm90b2NvbGUgSlNPTlAgbidlc3QgcGFzIHZhbGlkZSBkYW5zIHVuIGVudmlyb25uZW1lbnQgTm9kZUpTIChVdGlsaXNhdGlvbiBkdSBtb2RlIFhIUikuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zc2xdIC0gSW5kaXF1ZSBzaSBsJ29uIHNvdWhhaXRlIGludMOpcnJvZ2VyIGxlcyBzZXJ2aWNlcyBlbiBodHRwcy5cbiAqICAgICAgQ2UgcGFyYW3DqHRyZSBuZSBmb25jdGlvbm5lIHF1ZSBwb3VyIHVuZSB1dGlsaXNhdGlvbiBob3JzIG5hdmlnYXRldXIgKGV4LiBOb2RlSlMpLlxuICogICAgICBTdXIgdW4gbmF2aWdhdGV1ciwgbGUgcHJvdG9jb2xlIGVzdCBhdXRvbWF0aXF1ZW1lbnQgZXh0cmFpdCBkZSBsJ3VybCBkdSBzaXRlLi4uXG4gKiAgICAgIFBhciBkw6lmYXV0LCBvbiB1dGlsaXNlIGxlIHByb3RvY29sZSBodHRwIChzc2w9ZmFsc2UpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm94eVVSTF0gLSBMZSBwcm94eSDDoCB1dGlsaXNlciBwb3VyIHBhbGxpZXIgYXUgcHJvYmzDqG1lIGRlIGNyb3NzLWRvbWFpbiBkYW5zIGxlIGNhcyBkJ3VuZSByZXF1w6p0ZSBYSFIuXG4gKiAgICAgIFV0aWxlIHNpIGxlIHBhcmFtw6h0cmUgJ3Byb3RvY29sJyB2YXV0ICdYSFInLCBpbCBuZSBzZXJhIHBhcyBwcmlzIGVuIGNvbXB0ZSBzaSBwcm90b2NvbCB2YXV0IEpTT05QLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeF0gLSBTdWZmaXhlIGRlIGxhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIMOgIHV0aWxpc2VyLCBkYW5zIGxlIGNhcyBkdSBwcm90b2NvbGUgSlNPTlAuXG4gKiAgICAgIFBhciBkw6lmYXV0LCBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayBwb3J0ZXJhIHVuIG5vbSBkdSB0eXBlIFwiY2FsbGJhY2tcIitJRCwgb8O5IElEIGVzdCBzb2l0IHVuIGlkZW50aWZpYW50IHVuaXF1ZSBnw6luw6lyw6kgw6AgY2hhcXVlIHJlcXXDqnRlLFxuICogICAgICBzb2l0IGxlIHBhcmFtw6h0cmUgY2FsbGJhY2tTdWZmaXggcydpbCBlc3Qgc3DDqWNpZmnDqS4gUGFyIGV4ZW1wbGUsIHNpIGNhbGxiYWNrU3VmZml4PVwiXzJcIiwgbGEgZm9uY3Rpb24gc2VyYSBcImNhbGxiYWNrXzIgKClcIi5cbiAqICAgICAgVXRpbGUgcG91ciB1dGlsaXNlciB1bmUgcsOpcG9uc2UgZMOpasOgIGVuY2Fwc3Vsw6llIGRhbnMgdW5lIGZvbmN0aW9uIGRlIGNhbGxiYWNrLCBkb250IGxlIG5vbSBlc3QgY29ubnUgKGV4IDogY2hhcmdlbWVudCBkZSBsJ2F1dG9jb25maWd1cmF0aW9uIGVuIGxvY2FsKVxuICogICAgICBVdGlsZSBzZXVsZW1lbnQgc2kgbGUgcGFyYW3DqHRyZSAncHJvdG9jb2wnIHZhdXQgJ0pTT05QJywgaWwgbmUgc2VyYSBwYXMgcHJpcyBlbiBjb21wdGUgc2kgcHJvdG9jb2wgdmF1dCAnWEhSJy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaHR0cE1ldGhvZF0gLSBMYSBtw6l0aG9kZSBIVFRQXG4gKiAgICAgIMOgIHV0aWxpc2VyIGRhbnMgbGUgY2FzIGQndW5lIHJlcXXDqnRlIFhIUiA6IHBldXQgdmFsb2lyICdHRVQnIG91ICdQT1NUJy5cbiAqICAgICAgTm9uIHByaXMgZW4gY29tcHRlIHNpICdwcm90b2NvbCcgdmF1dCBKU09OUCBxdWkgZm9uY3Rpb25uZSBvYmxpZ2F0b2lyZW1lbnQgZW4gR0VULlxuICogICAgICBQYXIgZMOpZmF1dCwgYydlc3QgbGEgbcOpdGhvZGUgR0VUIHF1aSBlc3QgdXRpbGlzw6llLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb250ZW50VHlwZV0gLSBDb250ZW50LVR5cGUgZGUgbGEgcmVxdWV0ZVxuICogICAgICDDoCB1dGlsaXNlciBkYW5zIGxlIGNhcyBkJ3VuZSByZXF1w6p0ZSBYSFIgZW4gbW9kZSBQT1NULlxuICogICAgICBOb24gcHJpcyBlbiBjb21wdGUgc2kgJ3Byb3RvY29sJyB2YXV0IEpTT05QIGV0L291IGxhIG3DqXRob2RlIEhUVFAgdmF1dCBHRVQuXG4gKiAgICAgIFBhciBkw6lmYXV0LCBjJ2VzdCBsYSBtw6l0aG9kZSBHRVQgcXVpIGVzdCB1dGlsaXPDqWUgZG9uYyBvbiBuJ3V0aWxpc2UgcGFzIGRlIENvbnRlbnQtVHlwZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZU91dF0gLSBEw6lsYWkgZCdhdHRlbnRlIG1heGltYWwgKGVuIG1zKSBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlICjDoCBwYXJ0aXIgZGUgbCdlbnZvaSBkZSBsYSByZXF1w6p0ZSkuXG4gKiAgICAgIFBhciBkw6lmYXV0LCBhdWN1biB0aW1lT3V0IG4nZXN0IHByaXMgZW4gY29tcHRlICh0aW1lb3V0RGVsYXk9IDApLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzcG9uc2VdIC0gSW5kaXF1ZSBzaSBsJ29uIHNvdWhhaXRlIHF1ZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIG5lIHNvaXQgcGFzIHBhcnPDqWUgcGFyIGwnQVBJIGF2YW50IGQnw6p0cmUgcmVzdGl0dcOpZS5cbiAqICAgICAgKENmLiBwYXJhbcOodHJlIMKrIG9uU3VjY2VzcyDCuyBwb3VyIHBsdXMgZGUgZMOpdGFpbHMpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uU3VjY2Vzc10gLSBGb25jdGlvbiBhcHBlbMOpZSBsb3JzcXVlIGxlIHNlcnZpY2UgcsOpcG9uZCBjb3JyZWN0ZW1lbnQgw6AgbGEgcmVxdcOqdGVcbiAqICAgICAgKGNvZGUgSFRUUCAyMDAsIHNhbnMgbWVzc2FnZSBkJ2VycmV1cikuXG4gKiAgICAgIENldHRlIGZvbmN0aW9uIHByZW5kIGVuIHBhcmFtw6h0cmUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSxcbiAqICAgICAgc29pdCBzb3VzIGxhIGZvcm1lIGQndW4gT2JqZWN0IEphdmFzY3JpcHQgZm9ybWF0w6kgcGFyIGxlIHBhcnNldXIgZMOpZGnDqSDDoCBsYSBzeW50YXhlIGR1IHNlcnZpY2UgKGNvbXBvcnRlbWVudCBwYXIgZMOpZmF1dCkgO1xuICogICAgICBzb2l0IGJydXRlIGF1IGZvcm1hdCBTdHJpbmcgbm9uIHByw6l0cmFpdMOpIHNpIGxlIHBhcmFtw6h0cmUgwqsgcmF3UmVzcG9uc2UgwrsgYSDDqXTDqSBwcsOpY2lzw6kgYXZlYyBsYSB2YWxldXIgwqsgdHJ1ZSDCuy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZhaWx1cmVdIC0gRm9uY3Rpb24gYXBwZWzDqWUgbG9yc3F1ZSBsZSBzZXJ2aWNlIG5lIHLDqXBvbmQgcGFzIGNvcnJlY3RlbWVudFxuICogICAgICAoY29kZSBIVFRQIGRlIHJldG91ciBkaWZmw6lyZW50IGRlIDIwMCBvdSBwYXMgZGUgcsOpcG9uc2UpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQmVmb3JlUGFyc2VdIC0gRm9uY3Rpb24gYXBwZWzDqWUgYXZhbnQgbGUgcGFyc2luZyBkZSBsYSByw6lwb25zZVxuICogICAgICBQZXJtZXQgZGUgbW9kaWZpZXIgbGEgcsOpcG9uc2UgYXZhbnQgcGFyc2luZyBldCBsYSBmb25jdGlvbiBkb2l0IHJldG91cm5lciB1bmUgU3RyaW5nLlxuICogICAgICBDZXR0ZSBmb25jdGlvbiBwcmVuZCBlbiBwYXJhbcOodHJlIGxhIHLDqXBvbnNlIHRlbGxlIHF1ZSByZW52b3nDqWUgcGFyIGxlIHNlcnZpY2VcbiAqICAgICAgKGNhZCBhdSBmb3JtYXQganNvbiBvdSB4bWwpLlxuICogICAgICBQb3VyIGxlIEpTT05QLCBzaSBsZSBwYXJhbcOodHJlIFwicmF3UmVzcG9uc2VcIiBhIMOpdMOpIHByw6ljaXPDqSBhdmVjIGxhIHZhbGV1ciBcInRydWVcIixcbiAqICAgICAgbGEgZm9uY3Rpb24gcHJlbmQgZW4gcGFyYW3DqHRyZSB1biBPYmplY3QgSmF2YVNjcmlwdCBjb250ZW5hbnQgbGEgcsOpcG9uc2UgWE1MLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHZhciBvcHRpb25zID0ge1xuICogICAgICBhcGlLZXkgOiBudWxsLFxuICogICAgICBzZXJ2ZXJVcmwgOiAnaHR0cDovL2xvY2FsaG9zdC9zZXJ2aWNlLycsXG4gKiAgICAgIHByb3RvY29sIDogJ0pTT05QJywgLy8gSlNPTlB8WEhSXG4gKiAgICAgIHNzbCA6IGZhbHNlLFxuICogICAgICBwcm94eVVSTCA6IG51bGwsXG4gKiAgICAgIGNhbGxiYWNrTmFtZSA6IG51bGwsXG4gKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAqICAgICAgdGltZU91dCA6IDEwMDAwLCAvLyBtc1xuICogICAgICByYXdSZXNwb25zZSA6IGZhbHNlLCAvLyB0cnVlfGZhbHNlXG4gKiAgICAgIHNjb3BlIDogbnVsbCwgLy8gdGhpc1xuICogICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHt9LFxuICogICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICogICAgICBvbkJlZm9yZVBhcnNlIDogZnVuY3Rpb24gKHJhd1Jlc3BvbnNlKSB7fVxuICogICB9O1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29tbW9uU2VydmljZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21tb25TZXJ2aWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKF8uZ2V0TWVzc2FnZShcIkNMQVNTX0NPTlNUUlVDVE9SXCIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJDb21tb25TZXJ2aWNlXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBDb21tb25TZXJ2aWNlIChvcHRpb25zKV1cIik7XG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAvLyByw6ljdXDDqXJhdGlvbiBkZXMgb3B0aW9ucyBwYXIgZMOpZmF1dCBwb3VyIGxlcyBwYXJhbcOodHJlcyBvcHRpb25uZWxzXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIGR1IHNlcnZpY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgLy8gcHJvdG9jb2wgOiBcIkpTT05QXCIsXG4gICAgICAgIHByb3RvY29sIDogXCJYSFJcIixcbiAgICAgICAgc3NsIDogdHJ1ZSxcbiAgICAgICAgcHJveHlVUkwgOiBcIlwiLFxuICAgICAgICAvLyBjYWxsYmFja05hbWUgOiBcIlwiLFxuICAgICAgICBjYWxsYmFja1N1ZmZpeCA6IG51bGwsXG4gICAgICAgIGh0dHBNZXRob2QgOiBcIkdFVFwiLFxuICAgICAgICB0aW1lT3V0IDogMCxcbiAgICAgICAgcmF3UmVzcG9uc2UgOiBmYWxzZSxcbiAgICAgICAgc2NvcGUgOiB0aGlzLFxuICAgICAgICAvKipcbiAgICAgICAgKiBjYWxsYmFjayBwYXIgZGVmYXV0IHBvdXIgbGEgcmVwb25zZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSAtIHJlc3BvbnNlXG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uU3VjY2VzcyAtIGxhIHJlcG9uc2UgZXN0IGxhIHN1aXZhbnRlIDogXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogY2FsbGJhY2sgcGFyIGRlZmF1dCBwb3VyIGxlcyBlcnJldXJzXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIC0gZXJyb3JcbiAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDIwMCB8fCAhZXJyb3Iuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJvbkZhaWx1cmUgOiBcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib25GYWlsdXJlIC0gRXJyZXVyIChcIiwgZXJyb3Iuc3RhdHVzLCBcIikgOiBcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXQgb24gYWpvdXRlIGxlcyBvcHRpb25zIGVuIHBhcmFtw6h0cmUgYXV4IG9wdGlvbnMgcGFyIGTDqWZhdXRcbiAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgIC8vIGFuYWx5c2UgZGVzIG9wdGlvbnNcbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICAgIC8vIGdlc3Rpb24gZGVzIGNsZWZzIEFQSVxuICAgIGlmICghdGhpcy5vcHRpb25zLmFwaUtleSAmJiAhdGhpcy5vcHRpb25zLnNlcnZlclVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcImFwaUtleVwiLCBcInNlcnZlclVybFwiKSk7XG4gICAgfVxuXG4gICAgLy8gbW9kaWZpY2F0aW9uIGRlIGxhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIG9uU3VjY2VzcyBkYW5zIGxlIGNhcyBvw7kgbGEgcsOpcG9uc2UgYnJ1dGUgZXN0IGRlbWFuZMOpZVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UgJiYgIXRoaXMub3B0aW9ucy5vblN1Y2Nlc3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogY2FsbGJhY2sgcGFyIGRlZmF1dCBwb3VyIGxhIHJlcG9uc2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSByZXNwb25zZVxuICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib25TdWNjZXNzIC0gbGEgcsOpcG9uc2UgYnJ1dGUgZHUgc2VydmljZSBlc3QgbGEgc3VpdmFudGUgOiBcIiwgcmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGdlc3Rpb24gZHUgY2FsbGJhY2sgb25TdWNjZXNzXG4gICAgdmFyIGJPblN1Y2Nlc3MgPSAhISh0aGlzLm9wdGlvbnMub25TdWNjZXNzICE9PSBudWxsICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMub25TdWNjZXNzID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIGlmICghYk9uU3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcIm9uU3VjY2VzcygpXCIpKTtcbiAgICB9XG5cbiAgICAvLyBnZXN0aW9uIGRlIGwndXJsIGR1IHNlcnZpY2UgcGFyIGRlZmF1dFxuICAgIGlmICghdGhpcy5vcHRpb25zLnNlcnZlclVybCkge1xuICAgICAgICAvLyBJTkZPXG4gICAgICAgIC8vIGdlc3Rpb24gZGUgbCd1cmwgZHUgc2VydmljZSBwYXIgZGVmYXV0IHBvdXIgbGVzIHNlcnZpY2VzIHF1aSBuZSBwb3Nzw6hkZW50IHF1J3VuZSBzZXVsIHVybCBwYXIgZGVmYXV0XG4gICAgICAgIC8vIGxlcyBjYXMgcGFydGljdWxpZXJzIGRlcyBzZXJ2aWNlcyBhdmVjIHBsdXNpZXVycyB1cmxzIChleC4gQWx0aSkgZGV2cm9udCDDqnRyZSB0cmFpdMOpIGRhbnMgbGEgY2xhc3NlIGR1IGNvbXBvc2FudFxuICAgICAgICAvLyBkb25jIHNpIGwndXJsIG4nZXN0IHBhcyByZW5zZWlnbsOpZSwgaWwgZmF1dCB1dGlsaXNlciBsZXMgdXJscyBwYXIgZGVmYXV0XG4gICAgICAgIERlZmF1bHRVcmxTZXJ2aWNlLnNzbCA9IHRoaXMub3B0aW9ucy5zc2w7XG4gICAgICAgIHZhciB1cmxCeURlZmF1bHQgPSBEZWZhdWx0VXJsU2VydmljZVt0aGlzLkNMQVNTTkFNRV0udXJsKHRoaXMub3B0aW9ucy5hcGlLZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHVybEJ5RGVmYXVsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlcnZlclVybCA9IHVybEJ5RGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiVVJMIHBhciBkZWZhdXQgw6AgZGV0ZXJtaW5lciBhdSBuaXZlYXUgZHUgY29tcG9zYW50Li4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYTUUgbmV0dG95YWdlIGRlcyBLVlAgZGFucyBsJ3VybCBkdSBzZXJ2aWNlXG4gICAgLy8gaWYgKHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAvLyAgICAgLy8gSU5GT1xuICAgIC8vICAgICAvLyBzaSBsJ3VybCBlc3QgcmVuc2VpZ27DqWUsIGlsIGZhdXQgbGEgbmV0dG95ZXIgZGUgdG91cyBzZXMgS1ZQXG4gICAgLy8gICAgIC8vIGV4LiBvbiBuZSB2ZXV0IHBhcyBkZSBwYXJhbXMuICdjYWxsYmFjaycgb3UgJ291dHB1dCcgY2FyIGNlY2kgZGVjbGVuY2hlcmFpdFxuICAgIC8vICAgICAvLyBkZXMgb3DDqXJhdGlvbnMgZCdlbmNhcHN1bGF0aW9ucyBkZXMgcmVwb25zZXMgbMOpZ8OocmVtZW50IGZhcmZlbHVlcyAuLi5cbiAgICAvLyAgICAgdmFyIHVybHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmw7XG4gICAgLy8gICAgIHZhciB1cmxwYXJ0cyA9IHVybHNvdXJjZS5zcGxpdChcIj9cIik7XG4gICAgLy8gICAgIHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwgPSB1cmxwYXJ0c1swXTtcbiAgICAvLyB9XG5cbiAgICAvLyBnZXN0aW9uIGRlIGxhIG1ldGhvZGUgSFRUUFxuICAgIHRoaXMub3B0aW9ucy5odHRwTWV0aG9kID0gKHR5cGVvZiBvcHRpb25zLmh0dHBNZXRob2QgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5odHRwTWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiO1xuXG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCkge1xuICAgICAgICBjYXNlIFwiUE9TVFwiOlxuICAgICAgICBjYXNlIFwiR0VUXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICBjYXNlIFwiREVMRVRFXCI6XG4gICAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICAgIGNhc2UgXCJPUFRJT05TXCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTk9UX1NVUFBPUlRcIiwgXCJodHRwTWV0aG9kXCIpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9VTktOT1dOXCIsIFwiaHR0cE1ldGhvZFwiKSk7XG4gICAgfVxuXG4gICAgLy8gZ2VzdGlvbiBkdSBwcm90b2NvbGVcbiAgICAvLyB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPSAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09IFwic3RyaW5nXCIgKSA/IG9wdGlvbnMucHJvdG9jb2wudG9VcHBlckNhc2UoKSA6IFwiSlNPTlBcIjtcbiAgICB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPSAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5wcm90b2NvbC50b1VwcGVyQ2FzZSgpIDogXCJYSFJcIjtcblxuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnByb3RvY29sKSB7XG4gICAgICAgIGNhc2UgXCJKU09OUFwiOlxuICAgICAgICBjYXNlIFwiWEhSXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfLmdldE1lc3NhZ2UoXCJQQVJBTV9VTktOT1dOXCIsIFwicHJvdG9jb2xcIikpO1xuICAgIH1cblxuICAgIC8vIG9uIGRldGVybWluZSBsJ2Vudmlyb25uZW1lbnQgZCdleGVjdXRpb24gOiBicm93c2VyIG91IG5vbiA/XG4gICAgLy8gZXQgb24gbGFuY2UgdW5lIGV4Y2VwdGlvbiBzdXIgbCd1dGlsaXNhdGlvbiBkdSBwcm90b2NvbGUgSlNPTlAgcG91ciBub2RlSlMuLi5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPT09IFwiSlNPTlBcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXy5nZXRNZXNzYWdlKFwiUEFSQU1fTk9UX1NVUFBPUlRfTk9ERUpTXCIsIFwicHJvdG9jb2w9SlNPTlAgKGluc3RlYWQgdXNlIFhIUilcIikpO1xuICAgIH1cblxuICAgIC8vIGxlIHByb3RvY29sZSBKU09OUCBuZSBmb25jdGlvbm5lIHF1J2VuIEdFVC5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmh0dHBNZXRob2QgPSBcIkdFVFwiO1xuICAgIH1cblxuICAgIC8vIGdlc3Rpb24gZHUgY2FjaGVcbiAgICB0aGlzLm9wdGlvbnMubm9jYWNoZSA9IG9wdGlvbnMubm9jYWNoZSB8fCBmYWxzZTtcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgIC8vIGF0dHJpYnV0cyBkJ2luc3RhbmNlc1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGRlIHLDqXBvbnNlIGR1IHNlcnZpY2VcbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBSZXF1w6p0ZSBlbnZvecOpZSBhdSBzZXJ2aWNlXG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBSZXBvbnNlIGR1IHNlcnZpY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkNvbW1vblNlcnZpY2VcbiAqL1xuQ29tbW9uU2VydmljZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBDb21tb25TZXJ2aWNlLFxuXG4gICAgLyoqXG4gICAgICogQXBwZWwgZHUgc2VydmljZSBHw6lvcG9ydGFpbFxuICAgICAqL1xuICAgIGNhbGwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXMgOiB0cnVlICovXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQ29tbW9uU2VydmljZTo6Y2FsbCAoKVwiKTtcblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIC8qKiBmb25jdGlvbiBkJ2V4ZWN1dGlvbiAqL1xuICAgICAgICBmdW5jdGlvbiBydW4gKCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpydW4gKClcIik7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUmVxdWVzdC5jYWxsKGNvbnRleHQsIG9uRXJyb3IsIG9uQnVpbGRSZXF1ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bi5jYWxsKGNvbnRleHQpO1xuXG4gICAgICAgIC8vIGNhbGxiYWNrIGRlIGZpbiBkZSBjb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGVcbiAgICAgICAgZnVuY3Rpb24gb25CdWlsZFJlcXVlc3QgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpvbkJ1aWxkUmVxdWVzdCA6IFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5jYWxsU2VydmljZS5jYWxsKGNvbnRleHQsIG9uRXJyb3IsIG9uQ2FsbFNlcnZpY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZGUgZmluIGQnYXBwZWwgYXUgc2VydmljZVxuICAgICAgICBmdW5jdGlvbiBvbkNhbGxTZXJ2aWNlIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQ29tbW9uU2VydmljZTo6b25DYWxsU2VydmljZSA6IFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5hbmFseXplUmVzcG9uc2UuY2FsbChjb250ZXh0LCBvbkVycm9yLCBvbkFuYWx5emVSZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFjayBkZSBmaW4gZGUgbGVjdHVyZSBkZSBsYSByZXBvbnNlXG4gICAgICAgIGZ1bmN0aW9uIG9uQW5hbHl6ZVJlc3BvbnNlIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQ29tbW9uU2VydmljZTo6b25BbmFseXplUmVzcG9uc2UgOiBcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IuY2FsbCh0aGlzLCBuZXcgRXJyb3JTZXJ2aWNlKFwiQW5hbHlzZSBkZSBsYSByZXBvbnNlIGVuIMOpY2hlYyAhP1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFjayBkZSBnZXN0aW9uIGRlcyBlcnJldXJzIDogcmVudm9pdCB1biBvYmpldCBkZSB0eXBlIEVycm9yU2VydmljZVxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpvbkVycm9yKClcIik7XG4gICAgICAgICAgICAvLyBlcnJvciA6IGwnb2JqZXQgZXN0IGR1IHR5cGUgRXJyb3JTZXJ2aWNlIG91IEVycm9yXG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yO1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yU2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICBlID0gbmV3IEVycm9yU2VydmljZShlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkZhaWx1cmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gICAgICovXG4gICAgYnVpbGRSZXF1ZXN0IDogZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgICAgIC8vIElORk9cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJvdmVyd3JpdHRlbiBtZXRob2QgIVwiKTtcbiAgICAgICAgLy8gcmV0b3VybmUgbCdvYmpldCAndGhpcy5yZXF1ZXN0J1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcywgXCJUaGlzIG1ldGhvZCBtdXN0IGJlIG92ZXJ3cml0dGVuICFcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMsIFwiVGhpcyBtZXRob2QgbXVzdCBiZSBvdmVyd3JpdHRlbiAhXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbCBkdSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNhbGxTZXJ2aWNlIDogZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgICAgIC8vIElORk9cbiAgICAgICAgLy8gcmV0b3VybmUgbCdvYmpldCAndGhpcy5yZXNwb25zZSdcblxuICAgICAgICAvLyBOT1RFU1xuICAgICAgICAvLyAgUG91ciBsZSBtb2RlIFhIUiwgb24gcmVjdXDDqHJlIHVuZSByZXBvbnNlIHNvdXMgZm9ybWUgZCd1biBqc29uIG91IHhtbCAoI2RvY3VtZW50KS5cbiAgICAgICAgLy8gIFBvdXIgbGUgbW9kZSBKU09OUCwgb24gYSB0b3Vqb3VycyB1biBvYmpldCBKU09OIG1haXMgc291cyAyIGZvcm1lcyA6XG4gICAgICAgIC8vICAgICAgLSBuYXRpZlxuICAgICAgICAvLyAgICAgIC0gWE1MIGVuY2Fwc3Vsw6kgOlxuICAgICAgICAvLyAgICAgICAgICB7aHR0cCA6IHtzdGF0dXM6MjAwLCBlcnJvcjpudWxsfSx4bWwgOidyw6lwb25zZSBkdSBzZXJ2aWNlJ31cbiAgICAgICAgLy8gICAgICAgICAge2h0dHAgOiB7c3RhdHVzOjQwMCwgZXJyb3I6J3JlcG9uc2UgZHUgc2VydmljZSd9LHhtbCA6bnVsbH1cbiAgICAgICAgLy8gIEVuIFhIUiwgbGEgcmVwb25zZSBlc3QgZGlyZWN0ZW1lbnQgc2F1dmVnYXJkw6llIGRhbnMgJ3RoaXMucmVzcG9uc2UnLlxuICAgICAgICAvLyAgUGFyIGNvbnRyZSwgZW4gSlNPTlAsIG9uIGRvaXQgYW5hbHlzZXIgbGEgcmVwb25zZSAoc3RhdHVzIG91IG5vbiB2aWRlKSxcbiAgICAgICAgLy8gIGV0IG5lIHJlbnZveWVyIHF1ZSBsZSBjb250ZW51ICh4bWwgb3UgbCdvYmpldClcblxuICAgICAgICAvLyBnZXN0aW9uIGRlIGxhIHByb3hpZmljYXRpb24gZHUgc2VydmljZVxuICAgICAgICB2YXIgc3RyVXJsUHJveGlmaWVkID0gbnVsbDtcbiAgICAgICAgdmFyIHN0ckRhdGEgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICAgICAgLy8gYSB0IG9uIG1pcyBlbiBwbGFjZSB1biBwcm94eSA/XG4gICAgICAgIC8vIGxhIHByb3h5ZmljYXRpb24gZXN0IHZhbGFibGUgdW5pcXVlbWVudCBlbiBtb2RlIFhIUiAhXG4gICAgICAgIHZhciBiVXJsUHJveGlmaWVkID0gISEodGhpcy5vcHRpb25zLnByb3h5VVJMICYmIHRoaXMub3B0aW9ucy5wcm90b2NvbCA9PT0gXCJYSFJcIik7XG5cbiAgICAgICAgLy8gcmFqb3V0IGRlIGwnb3B0aW9uIGdwYmliYWNjZXNzXG4gICAgICAgIC8vIElORk8gOiBhY2NlcyBhdSBudW1lcm8gZGUgdmVyc2lvbiBkZSBwYWNrYWdlLmNvbmYgYXByw6lzIGNvbXBpbGF0aW9uICFcbiAgICAgICAgaWYgKHRoaXMuQ0xBU1NOQU1FICE9PSBcIkdlb2NvZGVcIiAmJiB0aGlzLkNMQVNTTkFNRSAhPT0gXCJSZXZlcnNlR2VvY29kZVwiICYmIHRoaXMuQ0xBU1NOQU1FICE9PSBcIkF1dG9Db21wbGV0ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VydmVyVXJsID0gSGVscGVyLm5vcm1hbHl6ZVVybCh0aGlzLm9wdGlvbnMuc2VydmVyVXJsLCB7XG4gICAgICAgICAgICAgICAgXCJncC1hY2Nlc3MtbGliXCIgOiBQa2cudmVyc2lvblxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2kgbGUgcHJveHkgZXN0IHJlbnNlaWduw6ksIG9uIHByb3hpZmllIGwndXJsIGR1IHNlcnZpY2VcbiAgICAgICAgaWYgKGJVcmxQcm94aWZpZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgICAgIHN0clVybFByb3hpZmllZCA9IHRoaXMub3B0aW9ucy5wcm94eVVSTCArIEhlbHBlci5ub3JtYWx5emVVcmwodGhpcy5vcHRpb25zLnNlcnZlclVybCwgdGhpcy5yZXF1ZXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzdHJEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5odHRwTWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgICAgIHN0clVybFByb3hpZmllZCA9IHRoaXMub3B0aW9ucy5wcm94eVVSTCArIEhlbHBlci5ub3JtYWx5emVVcmwodGhpcy5vcHRpb25zLnNlcnZlclVybCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RyRGF0YSA9IHRoaXMucmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRleHRlIGR1IGNvbXBvc2FudCBzcMOpY2lmaXF1ZSAhXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybCA6IHN0clVybFByb3hpZmllZCB8fCB0aGlzLm9wdGlvbnMuc2VydmVyVXJsLFxuICAgICAgICAgICAgbWV0aG9kIDogdGhpcy5vcHRpb25zLmh0dHBNZXRob2QsXG4gICAgICAgICAgICBwcm90b2NvbCA6IHRoaXMub3B0aW9ucy5wcm90b2NvbCxcbiAgICAgICAgICAgIHRpbWVPdXQgOiB0aGlzLm9wdGlvbnMudGltZU91dCB8fCAwLFxuICAgICAgICAgICAgZm9ybWF0IDogdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCwgLy8gY2VjaSBkZWNsZW5jaGUgbGUgcGFyc2luZyBkZSBsYSByZXBvbnNlIGR1IHNlcnZpY2UsIG1haXMgb24gc291aGFpdGUgdG91am91cnMgdW5lIHJlcG9uc2UgYnJ1dGUgKHN0cmluZykgIVxuICAgICAgICAgICAgbm9jYWNoZSA6IHRoaXMub3B0aW9ucy5ub2NhY2hlIHx8IGZhbHNlLCAvLyBjZWNpIHBlcm1ldCBkJ2Fqb3V0ZXIgdW4gdGltZXN0YW1wIGRhbnMgbGEgcmVxdcOqdGVcbiAgICAgICAgICAgIHdyYXAgOiB0aGlzLm9wdGlvbnMucHJvdG9jb2wgIT09IFwiWEhSXCIsIC8vIGNlY2kgZGVjbGVuY2hlIGwnZW5jYXBzdWxhdGlvbiBkZSBsYSByZXBvbnNlIFhNTCBkdSBzZXJ2aWNlIGRhbnMgZHUgSlNPTiwgbWFpcyBwYXMgZW4gbW9kZSBYSFIgIVxuICAgICAgICAgICAgY2FsbGJhY2tTdWZmaXggOiB0aGlzLm9wdGlvbnMuY2FsbGJhY2tTdWZmaXgsXG4gICAgICAgICAgICAvLyBjYWxsYmFja05hbWUgOiB0aGlzLm9wdGlvbnMuY2FsbGJhY2tOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBkYXRhIDogc3RyRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnMgOiBudWxsLCAvLyBUT0RPLi4uXG4gICAgICAgICAgICBjb250ZW50IDogdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlIHx8IFwiYXBwbGljYXRpb24veG1sXCIsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXMub3B0aW9ucy5zY29wZSB8fCB0aGlzLFxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgZGUgcmVwb25zZVxuICAgICAgICAgICAgb25SZXNwb25zZSA6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiY2FsbFNlcnZpY2U6Om9uUmVzcG9uc2UoKVwiKTtcblxuICAgICAgICAgICAgICAgIC8vIGxlIGNvbnRlbnUgZGUgbGEgcmVwb25zZSDDoCByZW52b3llciAhXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gWEhSIDogb24gcmVudm9pZSB0b3Vqb3VycyBsYSByZXBvbnNlIGJydXRlIGR1IHNlcnZpY2UgKGpzb24gb3UgeG1sKVxuICAgICAgICAgICAgICAgIC8vIGF1IHBhcnNlciBkdSBjb21wb3NhbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnByb3RvY29sID09PSBcIlhIUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiUmVzcG9uc2UgWEhSXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHJlc3BvbnNlOyAvLyBwYXIgZGVmYXV0LCBsYSByZXBvbnNlIGR1IHNlcnZpY2UgICFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBKU09OUCA6IG9uIHByZS1hbmFseXNlIGxhIHJlcG9uc2UgYnJ1dGUgZHUgc2VydmljZSAoZW5jYXBzdWxlciBvdSBwYXMpXG4gICAgICAgICAgICAgICAgLy8gYXZhbnQgZGUgbCdlbnZveWVyIGF1IHBhcnNlciBkdSBjb21wb3NhbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIudHJhY2UoXCJSZXNwb25zZSBKU09OXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaHR0cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcG9uc2UgZW5jYXBzdWzDqWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4LiByZXBvbnNlIGR1IHNlcnZpY2UgZW4geG1sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPiB7aHR0cCA6IHtzdGF0dXM6MjAwLCBlcnJvcjpudWxsfSx4bWwgOidyw6lwb25zZSBkdSBzZXJ2aWNlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaHR0cC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHNlbGYsIG5ldyBFcnJvclNlcnZpY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogcmVzcG9uc2UuaHR0cC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogcmVzcG9uc2UuaHR0cC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBFcnJvclNlcnZpY2UuVFlQRV9TUlZFUlJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHJlc3BvbnNlLnhtbDsgLy8gcGFyIGRlZmF1dCAhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMucmF3UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb25zZSBub24gZW5jYXBzdWzDqWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4LiByZXBvbnNlIGR1IHNlcnZpY2UgZW4ganNvbiBvdSB4bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHNlbGYsIG5ldyBFcnJvclNlcnZpY2UoXCJMZSBjb250ZW51IGRlIGxhIHJlcG9uc2UgZXN0IHZpZGUgIT9cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2kgb24gc291aGFpdGUgcGFyc2VyIGxhIHJlcG9uc2UgZHUgc2VydmljZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLm9uQmVmb3JlUGFyc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UmVzcG9uc2UgPSBzZWxmLm9wdGlvbnMub25CZWZvcmVQYXJzZShjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdSZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGEgcmVwb25zZSBwYXJzw6llIHBhciBsJ3V0aWxpc2F0ZXVyIGVzdCByZXRvdXJuw6llIHNvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcm1lIGRlIHN0cmluZyAhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gbmV3UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2F1dmVnYXJkZSBkZSBsYSByZXBvbnNlIGRhbnMgbCdvYmpldCBwYXJlbnQgKENvbW1vblNlcnZpY2UpXG4gICAgICAgICAgICAgICAgc2VsZi5yZXNwb25zZSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgLy8gb24gcmVudm9pZSBsYSByZXBvbnNlLi4uXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHNlbGYsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGRlcyBlcnJldXJzXG4gICAgICAgICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiY2FsbFNlcnZpY2U6Om9uRmFpbHVyZSgpXCIpO1xuICAgICAgICAgICAgICAgIC8vIG9uIGVzdCBmb3JjZW1lbnQgc3VyIHVuZSBlcnJldXIgbGV2w6llIHBhciB1biBzZXJ2aWNlICFcbiAgICAgICAgICAgICAgICBlLnR5cGUgPSBFcnJvclNlcnZpY2UuVFlQRV9TUlZFUlI7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2FsbChzZWxmLCBuZXcgRXJyb3JTZXJ2aWNlKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBjYWxsYmFjayBkZSB0aW1lT3V0XG4gICAgICAgICAgICBvblRpbWVPdXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIudHJhY2UoXCJjYWxsU2VydmljZTo6b25UaW1lT3V0KClcIik7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2FsbChzZWxmLCBuZXcgRXJyb3JTZXJ2aWNlKFwiVGltZU91dCFcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIFByb3RvY29sLnNlbmQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuYWx5c2UgZGUgbGEgcsOpcG9uc2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5hbHl6ZVJlc3BvbnNlIDogZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgICAgIC8vIElORk9cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJvdmVyd3JpdHRlbiBtZXRob2QgIVwiKTtcbiAgICAgICAgLy8gcmV0b3VybmUgbCdvYmpldCBzcMOpY2lmaXF1ZSBhdSB0eXBlIGRlIGNvbXBvc2FudCAoanNvbilcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5jYWxsKHRoaXMsIFwiVGhpcyBtZXRob2QgbXVzdCBiZSBvdmVyd3JpdHRlbiAhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzLCBcIlRoaXMgbWV0aG9kIG11c3QgYmUgb3ZlcndyaXR0ZW4gIVwiKTtcbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbW1vblNlcnZpY2U7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/CommonService.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// cette classe contient les URLs par defaut des services.\n//  DefaultUrlService.Alti.url(key)[elevation-json]\n//  DefaultUrlService.Alti.url(key)[elevation-xml]\n//  DefaultUrlService.Alti.url(key)[profil-json]\n//  DefaultUrlService.Alti.url(key)[profil-xml]\n//  DefaultUrlService.Alti.url(key)[wps]\n//  DefaultUrlService.ProcessIsoCurve.url(key)\n//  DefaultUrlService.AutoComplete.url(key)\n//  DefaultUrlService.ReverseGeocode.url(key)\n//  DefaultUrlService.AutoConf.url(key)[apiKey]\n//  DefaultUrlService.AutoConf.url(key)[apiKeys]\n//  DefaultUrlService.AutoConf.url(key)[aggregate]\n//  DefaultUrlService.Geocode.url(key)\n//  DefaultUrlService.Route.url(key)\n\n// Example :\n//\n// DefaultUrlService.Alti.url('alti')[elevation-json]\n//  output {String} -> http://wxs.ign.fr/calcul/alti/rest/elevation.json\n//\n// DefaultUrlService.Alti.url('calcul')\n// output {Object|String}\n// -> http://wxs.ign.fr/calcul/alti/rest/elevation.json\n// -> http://wxs.ign.fr/calcul/alti/rest/elevation.xml\n// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.json\n// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.xml\n// -> http://wxs.ign.fr/calcul/alti/wps\n//\n// ssl by default.\n//\n// Force to not do ssl :\n// DefaultUrlService.ssl = false;\n//\n// DefaultUrlService.AutoComplete.url('calcul')\n// output {Object|String}\n// -> https://wxs.ign.fr/calcul/ols/apis/completion\n\n// constantes internes\nvar HOSTNAME = \"wxs.ign.fr\";\n\n/**\n * Default Geoportal web services URLs access.\n *\n * @namespace\n * @alias Gp.Services.DefaultUrl\n */\nvar DefaultUrlService = {\n\n    /** if set true, require the use of https protocol */\n    ssl : true,\n\n    /**\n    * base url of services (ssl protocol management)\n    * @param {String} key - key\n    * @param {String} path - path\n    * @returns {String} url\n    */\n    url : function (key, path) {\n        // comportement par défaut => https\n        // sinon, il est fixé par l'option 'ssl' (false => http)\n        var _protocol;\n        if (DefaultUrlService.ssl === false) {\n            _protocol = \"http://\";\n        } else {\n            _protocol = \"https://\";\n        }\n\n        return _protocol + HOSTNAME.concat(\"/\", key, path);\n    },\n\n    /**\n     * Elevation web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns elevation service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols (\"elevation-json\", \"elevation-xml\", \"profil-json\" or \"profil-xml\").\n     */\n    Alti : {\n        _key : {\n            // rest\n            \"elevation-json\" : \"/alti/rest/elevation.json\",\n            \"elevation-xml\" : \"/alti/rest/elevation.xml\",\n            \"profil-json\" : \"/alti/rest/elevationLine.json\",\n            \"profil-xml\" : \"/alti/rest/elevationLine.xml\",\n            // other\n            wps : \"/alti/wps\"\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return {\n                // rest\n                \"elevation-json\" : DefaultUrlService.url(key, this._key[\"elevation-json\"]),\n                \"elevation-xml\" : DefaultUrlService.url(key, this._key[\"elevation-xml\"]),\n                \"profil-json\" : DefaultUrlService.url(key, this._key[\"profil-json\"]),\n                \"profil-xml\" : DefaultUrlService.url(key, this._key[\"profil-xml\"]),\n                // other\n                wps : DefaultUrlService.url(key, this._key[\"wps\"])\n            };\n        }\n    },\n    /**\n     * IsoCurve web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns isocurve service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols (\"iso-json\" or \"iso-xml\").\n     */\n    ProcessIsoCurve : {\n        _key : \"/geoportail/isochrone/rest/1.0.0/isochrone\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Autocompletion web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns autocomplete service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    AutoComplete : {\n        _key : \"/ols/apis/completion\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Reverse geocoding web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns reverse geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    ReverseGeocode : {\n        _key : \"/geoportail/ols\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Autoconfiguration web service access\n     *\n     * @member {Object}\n     * @property {Function} url ([key1,...]) - Returns autoconfiguration service default urls with geoportal access key (s) given as a String array parameter. The result is a javascript object with different urls given the access mode (\"apiKey\", \"apiKeys\" or \"aggregate\").\n     */\n    AutoConf : {\n        _key : {\n            apiKey : \"/autoconf\",\n            apiKeys : \"/autoconf?keys=%KEYS%\",\n            aggregate : \"/autoconf/id/\"\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            var keys = \"\";\n            if (Array.isArray(key) && key.length > 0) {\n                keys = key[0];\n                for (var i = 1; i < key.length; i++) {\n                    keys += \",\" + key[i];\n                }\n            }\n            return {\n                apiKey : DefaultUrlService.url(key, this._key[\"apiKey\"]), // une seule clé\n                apiKeys : DefaultUrlService.url(key[0], this._key[\"apiKeys\"]).replace(\"%KEYS%\", keys), // autoconf de plusieurs clés\n                aggregate : DefaultUrlService.url(key, this._key[\"aggregate\"])\n            };\n        }\n    },\n    /**\n     * Geocoding web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    Geocode : {\n        _key : \"/geoportail/ols\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Routing web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns routing service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols.\n     */\n    Route : {\n        _key : \"/geoportail/itineraire/rest/1.0.0/route\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (DefaultUrlService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0RlZmF1bHRVcmxTZXJ2aWNlLmpzPzMxOTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsZ0ZBQWlCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1NlcnZpY2VzL0RlZmF1bHRVcmxTZXJ2aWNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gY2V0dGUgY2xhc3NlIGNvbnRpZW50IGxlcyBVUkxzIHBhciBkZWZhdXQgZGVzIHNlcnZpY2VzLlxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbZWxldmF0aW9uLWpzb25dXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoa2V5KVtlbGV2YXRpb24teG1sXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbcHJvZmlsLWpzb25dXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoa2V5KVtwcm9maWwteG1sXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbd3BzXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLlByb2Nlc3NJc29DdXJ2ZS51cmwoa2V5KVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db21wbGV0ZS51cmwoa2V5KVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLlJldmVyc2VHZW9jb2RlLnVybChrZXkpXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQXV0b0NvbmYudXJsKGtleSlbYXBpS2V5XVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db25mLnVybChrZXkpW2FwaUtleXNdXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQXV0b0NvbmYudXJsKGtleSlbYWdncmVnYXRlXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkdlb2NvZGUudXJsKGtleSlcbi8vICBEZWZhdWx0VXJsU2VydmljZS5Sb3V0ZS51cmwoa2V5KVxuXG4vLyBFeGFtcGxlIDpcbi8vXG4vLyBEZWZhdWx0VXJsU2VydmljZS5BbHRpLnVybCgnYWx0aScpW2VsZXZhdGlvbi1qc29uXVxuLy8gIG91dHB1dCB7U3RyaW5nfSAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXG4vL1xuLy8gRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoJ2NhbGN1bCcpXG4vLyBvdXRwdXQge09iamVjdHxTdHJpbmd9XG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbi54bWxcbi8vIC0+IGh0dHA6Ly93eHMuaWduLmZyL2NhbGN1bC9hbHRpL3Jlc3QvZWxldmF0aW9uTGluZS5qc29uXG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS9yZXN0L2VsZXZhdGlvbkxpbmUueG1sXG4vLyAtPiBodHRwOi8vd3hzLmlnbi5mci9jYWxjdWwvYWx0aS93cHNcbi8vXG4vLyBzc2wgYnkgZGVmYXVsdC5cbi8vXG4vLyBGb3JjZSB0byBub3QgZG8gc3NsIDpcbi8vIERlZmF1bHRVcmxTZXJ2aWNlLnNzbCA9IGZhbHNlO1xuLy9cbi8vIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db21wbGV0ZS51cmwoJ2NhbGN1bCcpXG4vLyBvdXRwdXQge09iamVjdHxTdHJpbmd9XG4vLyAtPiBodHRwczovL3d4cy5pZ24uZnIvY2FsY3VsL29scy9hcGlzL2NvbXBsZXRpb25cblxuLy8gY29uc3RhbnRlcyBpbnRlcm5lc1xudmFyIEhPU1ROQU1FID0gXCJ3eHMuaWduLmZyXCI7XG5cbi8qKlxuICogRGVmYXVsdCBHZW9wb3J0YWwgd2ViIHNlcnZpY2VzIFVSTHMgYWNjZXNzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5EZWZhdWx0VXJsXG4gKi9cbnZhciBEZWZhdWx0VXJsU2VydmljZSA9IHtcblxuICAgIC8qKiBpZiBzZXQgdHJ1ZSwgcmVxdWlyZSB0aGUgdXNlIG9mIGh0dHBzIHByb3RvY29sICovXG4gICAgc3NsIDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICogYmFzZSB1cmwgb2Ygc2VydmljZXMgKHNzbCBwcm90b2NvbCBtYW5hZ2VtZW50KVxuICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAqL1xuICAgIHVybCA6IGZ1bmN0aW9uIChrZXksIHBhdGgpIHtcbiAgICAgICAgLy8gY29tcG9ydGVtZW50IHBhciBkw6lmYXV0ID0+IGh0dHBzXG4gICAgICAgIC8vIHNpbm9uLCBpbCBlc3QgZml4w6kgcGFyIGwnb3B0aW9uICdzc2wnIChmYWxzZSA9PiBodHRwKVxuICAgICAgICB2YXIgX3Byb3RvY29sO1xuICAgICAgICBpZiAoRGVmYXVsdFVybFNlcnZpY2Uuc3NsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgX3Byb3RvY29sID0gXCJodHRwOi8vXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcHJvdG9jb2wgPSBcImh0dHBzOi8vXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3Byb3RvY29sICsgSE9TVE5BTUUuY29uY2F0KFwiL1wiLCBrZXksIHBhdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbGV2YXRpb24gd2ViIHNlcnZpY2UgYWNjZXNzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXJsIChrZXkpIC0gUmV0dXJucyBlbGV2YXRpb24gc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB1c2VkIHByb3RvY29scyAoXCJlbGV2YXRpb24tanNvblwiLCBcImVsZXZhdGlvbi14bWxcIiwgXCJwcm9maWwtanNvblwiIG9yIFwicHJvZmlsLXhtbFwiKS5cbiAgICAgKi9cbiAgICBBbHRpIDoge1xuICAgICAgICBfa2V5IDoge1xuICAgICAgICAgICAgLy8gcmVzdFxuICAgICAgICAgICAgXCJlbGV2YXRpb24tanNvblwiIDogXCIvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXCIsXG4gICAgICAgICAgICBcImVsZXZhdGlvbi14bWxcIiA6IFwiL2FsdGkvcmVzdC9lbGV2YXRpb24ueG1sXCIsXG4gICAgICAgICAgICBcInByb2ZpbC1qc29uXCIgOiBcIi9hbHRpL3Jlc3QvZWxldmF0aW9uTGluZS5qc29uXCIsXG4gICAgICAgICAgICBcInByb2ZpbC14bWxcIiA6IFwiL2FsdGkvcmVzdC9lbGV2YXRpb25MaW5lLnhtbFwiLFxuICAgICAgICAgICAgLy8gb3RoZXJcbiAgICAgICAgICAgIHdwcyA6IFwiL2FsdGkvd3BzXCJcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogdXJsXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAgICAqL1xuICAgICAgICB1cmwgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIHJlc3RcbiAgICAgICAgICAgICAgICBcImVsZXZhdGlvbi1qc29uXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJlbGV2YXRpb24tanNvblwiXSksXG4gICAgICAgICAgICAgICAgXCJlbGV2YXRpb24teG1sXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJlbGV2YXRpb24teG1sXCJdKSxcbiAgICAgICAgICAgICAgICBcInByb2ZpbC1qc29uXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJwcm9maWwtanNvblwiXSksXG4gICAgICAgICAgICAgICAgXCJwcm9maWwteG1sXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJwcm9maWwteG1sXCJdKSxcbiAgICAgICAgICAgICAgICAvLyBvdGhlclxuICAgICAgICAgICAgICAgIHdwcyA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcIndwc1wiXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzb0N1cnZlIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoa2V5KSAtIFJldHVybnMgaXNvY3VydmUgc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB1c2VkIHByb3RvY29scyAoXCJpc28tanNvblwiIG9yIFwiaXNvLXhtbFwiKS5cbiAgICAgKi9cbiAgICBQcm9jZXNzSXNvQ3VydmUgOiB7XG4gICAgICAgIF9rZXkgOiBcIi9nZW9wb3J0YWlsL2lzb2Nocm9uZS9yZXN0LzEuMC4wL2lzb2Nocm9uZVwiLFxuICAgICAgICAvKipcbiAgICAgICAgKiB1cmxcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5XG4gICAgICAgICogQHJldHVybnMge1N0cmluZ30gdXJsXG4gICAgICAgICovXG4gICAgICAgIHVybCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBdXRvY29tcGxldGlvbiB3ZWIgc2VydmljZSBhY2Nlc3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cmwgKGtleSkgLSBSZXR1cm5zIGF1dG9jb21wbGV0ZSBzZXJ2aWNlIGRlZmF1bHQgdXJscyB3aXRoIG9yIHdpdGhvdXQgZ2VvcG9ydGFsIGFjY2VzcyBrZXkgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXN1bHQgaXMgYSBTdHJpbmcuXG4gICAgICovXG4gICAgQXV0b0NvbXBsZXRlIDoge1xuICAgICAgICBfa2V5IDogXCIvb2xzL2FwaXMvY29tcGxldGlvblwiLFxuICAgICAgICAvKipcbiAgICAgICAgKiB1cmxcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5XG4gICAgICAgICogQHJldHVybnMge1N0cmluZ30gdXJsXG4gICAgICAgICovXG4gICAgICAgIHVybCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXZlcnNlIGdlb2NvZGluZyB3ZWIgc2VydmljZSBhY2Nlc3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cmwgKGtleSkgLSBSZXR1cm5zIHJldmVyc2UgZ2VvY29kaW5nIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggb3Igd2l0aG91dCBnZW9wb3J0YWwgYWNjZXNzIGtleSBnaXZlbiBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIFN0cmluZy5cbiAgICAgKi9cbiAgICBSZXZlcnNlR2VvY29kZSA6IHtcbiAgICAgICAgX2tleSA6IFwiL2dlb3BvcnRhaWwvb2xzXCIsXG4gICAgICAgIC8qKlxuICAgICAgICAqIHVybFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgICAgKi9cbiAgICAgICAgdXJsIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEF1dG9jb25maWd1cmF0aW9uIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoW2tleTEsLi4uXSkgLSBSZXR1cm5zIGF1dG9jb25maWd1cmF0aW9uIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggZ2VvcG9ydGFsIGFjY2VzcyBrZXkgKHMpIGdpdmVuIGFzIGEgU3RyaW5nIGFycmF5IHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggZGlmZmVyZW50IHVybHMgZ2l2ZW4gdGhlIGFjY2VzcyBtb2RlIChcImFwaUtleVwiLCBcImFwaUtleXNcIiBvciBcImFnZ3JlZ2F0ZVwiKS5cbiAgICAgKi9cbiAgICBBdXRvQ29uZiA6IHtcbiAgICAgICAgX2tleSA6IHtcbiAgICAgICAgICAgIGFwaUtleSA6IFwiL2F1dG9jb25mXCIsXG4gICAgICAgICAgICBhcGlLZXlzIDogXCIvYXV0b2NvbmY/a2V5cz0lS0VZUyVcIixcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZSA6IFwiL2F1dG9jb25mL2lkL1wiXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHVybFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgICAgKi9cbiAgICAgICAgdXJsIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSAmJiBrZXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGtleXMgPSBrZXlbMF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyArPSBcIixcIiArIGtleVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFwaUtleSA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcImFwaUtleVwiXSksIC8vIHVuZSBzZXVsZSBjbMOpXG4gICAgICAgICAgICAgICAgYXBpS2V5cyA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXlbMF0sIHRoaXMuX2tleVtcImFwaUtleXNcIl0pLnJlcGxhY2UoXCIlS0VZUyVcIiwga2V5cyksIC8vIGF1dG9jb25mIGRlIHBsdXNpZXVycyBjbMOpc1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZSA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcImFnZ3JlZ2F0ZVwiXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlb2NvZGluZyB3ZWIgc2VydmljZSBhY2Nlc3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cmwgKGtleSkgLSBSZXR1cm5zIGdlb2NvZGluZyBzZXJ2aWNlIGRlZmF1bHQgdXJscyB3aXRoIG9yIHdpdGhvdXQgZ2VvcG9ydGFsIGFjY2VzcyBrZXkgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXN1bHQgaXMgYSBTdHJpbmcuXG4gICAgICovXG4gICAgR2VvY29kZSA6IHtcbiAgICAgICAgX2tleSA6IFwiL2dlb3BvcnRhaWwvb2xzXCIsXG4gICAgICAgIC8qKlxuICAgICAgICAqIHVybFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgICAgKi9cbiAgICAgICAgdXJsIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJvdXRpbmcgd2ViIHNlcnZpY2UgYWNjZXNzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXJsIChrZXkpIC0gUmV0dXJucyByb3V0aW5nIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggb3Igd2l0aG91dCBnZW9wb3J0YWwgYWNjZXNzIGtleSBnaXZlbiBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggZGlmZmVyZW50IHVybHMgZ2l2ZW4gdXNlZCBwcm90b2NvbHMuXG4gICAgICovXG4gICAgUm91dGUgOiB7XG4gICAgICAgIF9rZXkgOiBcIi9nZW9wb3J0YWlsL2l0aW5lcmFpcmUvcmVzdC8xLjAuMC9yb3V0ZVwiLFxuICAgICAgICAvKipcbiAgICAgICAgKiB1cmxcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5XG4gICAgICAgICogQHJldHVybnMge1N0cmluZ30gdXJsXG4gICAgICAgICovXG4gICAgICAgIHVybCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdFVybFNlcnZpY2U7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/Helper.js":
/*!***************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/Helper.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Classe utilitaire\n *\n * @module Helper\n * @alias Gp.Helper\n */\nvar Helper = {\n\n    /**\n     * concatenation des parametres key/value dans les urls\n     *\n     * @method normalyzeParameters\n     * @static\n     * @param {Object} params - tableau de clef/valeur\n     *\n     * @example\n     *  Gp.Utils.Helper.normalyzeParameters ({\n     *         key1:value1,\n     *         key2:value2,\n     *         key3:value3\n     *  });\n     *  // out : \"key1=value1&key2=value2&key3=value3\"\n     *\n     * @returns {String} retourne les paramètres concaténés\n     */\n    normalyzeParameters : function (params) {\n        var myParams = null;\n\n        if (params) {\n            var tabParams = [];\n            for (var key in params) {\n                if (params.hasOwnProperty(key)) {\n                    var value = params[key];\n                    if (!value) {\n                        value = \"\";\n                    }\n                    tabParams.push(key + \"=\" + value);\n                }\n            }\n\n            myParams = tabParams.join(\"&\");\n        }\n\n        return myParams;\n    },\n\n    /**\n     * Concaténation et encodage des urls.\n     *\n     * @method normalyzeUrl\n     * @static\n     * @param {String} url - url\n     * @param {Object|String} params - tableau de clef/valeur ou string\n     * @param {Boolean} encode - true|false, false par defaut\n     *\n     * @example\n     *  Gp.Utils.Helper.normalyzeUrl (url, {\n     *         key1:value1,\n     *         key2=:value2,\n     *         key3:value3\n     *  });\n     *  // out : \"url?key1=value1&key2=value2&key3=value3\"\n     *\n     * @returns {String} retourne une url normalisée\n     */\n    normalyzeUrl : function (url, params, encode) {\n        var myUrl = url;\n\n        if (url) {\n            var k = url.indexOf(\"?\");\n            if (k === -1) { // pas de ? et KVP\n                myUrl += \"?\";\n            }\n\n            if (k !== -1 && k !== url.length - 1) { // KVP\n                myUrl += \"&\";\n            }\n        }\n\n        if (params) {\n            if (typeof params === \"string\") {\n                myUrl += params;\n            } else {\n                myUrl += this.normalyzeParameters(params);\n            }\n        }\n\n        if (encode) {\n            // FIXME bonne idée ?\n            myUrl = encodeURIComponent(myUrl);\n        }\n\n        return myUrl;\n    },\n\n    /**\n     * Indentation d'une chaine\n     *\n     * @method indent\n     * @static\n     * @param {Number} n - nombre de tabulation\n     * @param {String} msg - chaine\n     *\n     * @example\n     * Gp.Utils.Helper.indent (2, \"message à indenter\")\n     * // out\n     * // ........message à indenter\n     *\n     * @returns {String} retourne une chaine indentée\n     */\n    indent : function (n, msg) {\n        var num = n || 0;\n        return new Array(num + 1).join(\"\\t\") + msg;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Helper);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL0hlbHBlci5qcz8wYmQwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUscUVBQU0sRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvVXRpbHMvSGVscGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGFzc2UgdXRpbGl0YWlyZVxuICpcbiAqIEBtb2R1bGUgSGVscGVyXG4gKiBAYWxpYXMgR3AuSGVscGVyXG4gKi9cbnZhciBIZWxwZXIgPSB7XG5cbiAgICAvKipcbiAgICAgKiBjb25jYXRlbmF0aW9uIGRlcyBwYXJhbWV0cmVzIGtleS92YWx1ZSBkYW5zIGxlcyB1cmxzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5vcm1hbHl6ZVBhcmFtZXRlcnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHRhYmxlYXUgZGUgY2xlZi92YWxldXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIEdwLlV0aWxzLkhlbHBlci5ub3JtYWx5emVQYXJhbWV0ZXJzICh7XG4gICAgICogICAgICAgICBrZXkxOnZhbHVlMSxcbiAgICAgKiAgICAgICAgIGtleTI6dmFsdWUyLFxuICAgICAqICAgICAgICAga2V5Mzp2YWx1ZTNcbiAgICAgKiAgfSk7XG4gICAgICogIC8vIG91dCA6IFwia2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTNcIlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgbGVzIHBhcmFtw6h0cmVzIGNvbmNhdMOpbsOpc1xuICAgICAqL1xuICAgIG5vcm1hbHl6ZVBhcmFtZXRlcnMgOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBteVBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHRhYlBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhYlBhcmFtcy5wdXNoKGtleSArIFwiPVwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXlQYXJhbXMgPSB0YWJQYXJhbXMuam9pbihcIiZcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXlQYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdMOpbmF0aW9uIGV0IGVuY29kYWdlIGRlcyB1cmxzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBub3JtYWx5emVVcmxcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIHVybFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcGFyYW1zIC0gdGFibGVhdSBkZSBjbGVmL3ZhbGV1ciBvdSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZSAtIHRydWV8ZmFsc2UsIGZhbHNlIHBhciBkZWZhdXRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIEdwLlV0aWxzLkhlbHBlci5ub3JtYWx5emVVcmwgKHVybCwge1xuICAgICAqICAgICAgICAga2V5MTp2YWx1ZTEsXG4gICAgICogICAgICAgICBrZXkyPTp2YWx1ZTIsXG4gICAgICogICAgICAgICBrZXkzOnZhbHVlM1xuICAgICAqICB9KTtcbiAgICAgKiAgLy8gb3V0IDogXCJ1cmw/a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTNcIlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgdW5lIHVybCBub3JtYWxpc8OpZVxuICAgICAqL1xuICAgIG5vcm1hbHl6ZVVybCA6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgZW5jb2RlKSB7XG4gICAgICAgIHZhciBteVVybCA9IHVybDtcblxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgayA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgICAgIGlmIChrID09PSAtMSkgeyAvLyBwYXMgZGUgPyBldCBLVlBcbiAgICAgICAgICAgICAgICBteVVybCArPSBcIj9cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGsgIT09IC0xICYmIGsgIT09IHVybC5sZW5ndGggLSAxKSB7IC8vIEtWUFxuICAgICAgICAgICAgICAgIG15VXJsICs9IFwiJlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBteVVybCArPSBwYXJhbXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG15VXJsICs9IHRoaXMubm9ybWFseXplUGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuY29kZSkge1xuICAgICAgICAgICAgLy8gRklYTUUgYm9ubmUgaWTDqWUgP1xuICAgICAgICAgICAgbXlVcmwgPSBlbmNvZGVVUklDb21wb25lbnQobXlVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG15VXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRlbnRhdGlvbiBkJ3VuZSBjaGFpbmVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5kZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gbm9tYnJlIGRlIHRhYnVsYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gY2hhaW5lXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEdwLlV0aWxzLkhlbHBlci5pbmRlbnQgKDIsIFwibWVzc2FnZSDDoCBpbmRlbnRlclwiKVxuICAgICAqIC8vIG91dFxuICAgICAqIC8vIC4uLi4uLi4ubWVzc2FnZSDDoCBpbmRlbnRlclxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgdW5lIGNoYWluZSBpbmRlbnTDqWVcbiAgICAgKi9cbiAgICBpbmRlbnQgOiBmdW5jdGlvbiAobiwgbXNnKSB7XG4gICAgICAgIHZhciBudW0gPSBuIHx8IDA7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkobnVtICsgMSkuam9pbihcIlxcdFwiKSArIG1zZztcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIZWxwZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Utils/Helper.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js":
/*!************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar LoggerByDefault = {\n    /**\n     * logger statique\n     *\n     * @static\n     * @param {String} name - nom du logger\n     * @returns {Object} retourne un logger\n     */\n    getLogger : function (name) {\n        // Substitute global constants configured at compile time\n        // cf. webpack.config.js\n        // FIXME howtodo !? DefineWebpackPlugin ? EnvironmentWebpackPlugin ?\n        (\"false\".match(/true/)) ? loglevel__WEBPACK_IMPORTED_MODULE_0__[\"disableAll\"]() : loglevel__WEBPACK_IMPORTED_MODULE_0__[\"enableAll\"]();\n        var logname = name || \"default\";\n        return loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"](logname);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LoggerByDefault);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcz8wNjVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1EQUFjLEtBQUssa0RBQWE7QUFDM0U7QUFDQSxlQUFlLGtEQUFhO0FBQzVCO0FBQ0E7O0FBRWUsOEVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9nZW9wb3J0YWwtYWNjZXNzLWxpYi9zcmMvVXRpbHMvTG9nZ2VyQnlEZWZhdWx0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgTG9nIGZyb20gXCJsb2dsZXZlbFwiO1xuXG52YXIgTG9nZ2VyQnlEZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIGxvZ2dlciBzdGF0aXF1ZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbm9tIGR1IGxvZ2dlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJldG91cm5lIHVuIGxvZ2dlclxuICAgICAqL1xuICAgIGdldExvZ2dlciA6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgZ2xvYmFsIGNvbnN0YW50cyBjb25maWd1cmVkIGF0IGNvbXBpbGUgdGltZVxuICAgICAgICAvLyBjZi4gd2VicGFjay5jb25maWcuanNcbiAgICAgICAgLy8gRklYTUUgaG93dG9kbyAhPyBEZWZpbmVXZWJwYWNrUGx1Z2luID8gRW52aXJvbm1lbnRXZWJwYWNrUGx1Z2luID9cbiAgICAgICAgKFwiX19QUk9EVUNUSU9OX19cIi5tYXRjaCgvdHJ1ZS8pKSA/IExvZy5kaXNhYmxlQWxsKCkgOiBMb2cuZW5hYmxlQWxsKCk7XG4gICAgICAgIHZhciBsb2duYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgcmV0dXJuIExvZy5nZXRMb2dnZXIobG9nbmFtZSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9nZ2VyQnlEZWZhdWx0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js\n");

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js":
/*!**************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Classe de gestion des erreurs qui permer d'associer un message d'erreur à l'exception lancée.\n *\n * @example\n * MessagesResources.getMessage(\"ERROR_PARAM_MISSING\", \"x\", \"y\", \"z\")));\n * // --> output : Parameter(s) 'x - y - z' missing\n *\n * @module MessagesResources\n * @alias Gp.Utils.MessagesResources\n * @private\n */\nvar MessagesResources = {\n\n    // Paramètres\n    PARAM_MISSING : \"Parameter(s) '%var%' missing\",\n    PARAM_EMPTY : \"Parameter(s) '%var%' empty\",\n    PARAM_TYPE : \"Wrong type(s) for parameter(s) '%var%'\",\n    PARAM_FORMAT : \"Parameter(s) '%var%' not correctly formatted\",\n    PARAM_NOT_SUPPORT : \"Value(s) for parameter(s) '%var%' not supported\",\n    PARAM_NOT_SUPPORT_NODEJS : \"Value(s) for parameter(s) '%var%' not supported to NodeJS\",\n    PARAM_UNKNOWN : \"Value(s) for parameter(s) '%var%' unknown\",\n\n    // Services\n    // Requête\n    SERVICE_REQUEST_BUILD : \"An error occurred during the request building of the service\",\n    SERVICE_REQUEST_EMPTY : \"The request sent to the service is empty\",\n\n    // Réponse\n    SERVICE_RESPONSE_EXCEPTION : \"The service returned an exception : '%var%'\",\n    SERVICE_RESPONSE_EXCEPTION_2 : \"The service returned an exception\",\n    SERVICE_RESPONSE_ANALYSE : \"An error occurred while parsing the response '%var%' of the service\",\n    SERVICE_RESPONSE_ANALYSE_2 : \"An unknown error occurred while parsing the response\",\n    SERVICE_RESPONSE_EMPTY : \"The response of the service is empty\",\n    SERVICE_RESPONSE_EMPTY_2 : \"The response from the service could not be analyzed or is empty\",\n    SERVICE_RESPONSE_FORMAT : \"The format of the service response is not supported (handled format(s) : '%var%')\",\n    SERVICE_RESPONSE_FORMAT_2 : \"The format of the service response is not supported\",\n    SERVICE_RESPONSE_FORMAT_3 : \"No suggestion matching the search\",\n\n    // Classes\n    CLASS_CONSTRUCTOR : \"'%var%' constructor cannot be called as a function.\",\n\n    /**\n     * Fonction qui va retourner le message d'erreur associé à la clé donnée\n     *\n     * @method getMessage\n     * @param {String} clef - Clef de l'erreur (ex : ERROR_PARAM)\n     * @param {String[]} parametres - Paramètres/variables concernés par le message d'erreur associé à la clef donnée\n     * @return {String} message - String contenant le message de l'exception\n     */\n    getMessage : function (clef, parametres) {\n        // param de la fonction uniquement pour la documentation...\n\n        if (Object.keys(arguments).length === 0) {\n            return \"Message indefined !\";\n        }\n\n        var params = Array.prototype.slice.call(arguments);\n        var key = params.shift();\n        var args = params;\n\n        var message = this[key];\n\n        try {\n            if (Array.isArray(args) && args.length > 0) {\n                message = message.replace(\"%var%\", args.join(\" - \"));\n            } else {\n                message = message.replace(\"%var%\", \"%var% (not specified)\");\n            }\n        } catch (e) {\n            // error de string.replace()\n\n        }\n\n        return message;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MessagesResources);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL01lc3NhZ2VzUmVzb3VyY2VzLmpzP2NlYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsZ0ZBQWlCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvc3JjL1V0aWxzL01lc3NhZ2VzUmVzb3VyY2VzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgZXJyZXVycyBxdWkgcGVybWVyIGQnYXNzb2NpZXIgdW4gbWVzc2FnZSBkJ2VycmV1ciDDoCBsJ2V4Y2VwdGlvbiBsYW5jw6llLlxuICpcbiAqIEBleGFtcGxlXG4gKiBNZXNzYWdlc1Jlc291cmNlcy5nZXRNZXNzYWdlKFwiRVJST1JfUEFSQU1fTUlTU0lOR1wiLCBcInhcIiwgXCJ5XCIsIFwielwiKSkpO1xuICogLy8gLS0+IG91dHB1dCA6IFBhcmFtZXRlcihzKSAneCAtIHkgLSB6JyBtaXNzaW5nXG4gKlxuICogQG1vZHVsZSBNZXNzYWdlc1Jlc291cmNlc1xuICogQGFsaWFzIEdwLlV0aWxzLk1lc3NhZ2VzUmVzb3VyY2VzXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTWVzc2FnZXNSZXNvdXJjZXMgPSB7XG5cbiAgICAvLyBQYXJhbcOodHJlc1xuICAgIFBBUkFNX01JU1NJTkcgOiBcIlBhcmFtZXRlcihzKSAnJXZhciUnIG1pc3NpbmdcIixcbiAgICBQQVJBTV9FTVBUWSA6IFwiUGFyYW1ldGVyKHMpICcldmFyJScgZW1wdHlcIixcbiAgICBQQVJBTV9UWVBFIDogXCJXcm9uZyB0eXBlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJ1wiLFxuICAgIFBBUkFNX0ZPUk1BVCA6IFwiUGFyYW1ldGVyKHMpICcldmFyJScgbm90IGNvcnJlY3RseSBmb3JtYXR0ZWRcIixcbiAgICBQQVJBTV9OT1RfU1VQUE9SVCA6IFwiVmFsdWUocykgZm9yIHBhcmFtZXRlcihzKSAnJXZhciUnIG5vdCBzdXBwb3J0ZWRcIixcbiAgICBQQVJBTV9OT1RfU1VQUE9SVF9OT0RFSlMgOiBcIlZhbHVlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJyBub3Qgc3VwcG9ydGVkIHRvIE5vZGVKU1wiLFxuICAgIFBBUkFNX1VOS05PV04gOiBcIlZhbHVlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJyB1bmtub3duXCIsXG5cbiAgICAvLyBTZXJ2aWNlc1xuICAgIC8vIFJlcXXDqnRlXG4gICAgU0VSVklDRV9SRVFVRVNUX0JVSUxEIDogXCJBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIHJlcXVlc3QgYnVpbGRpbmcgb2YgdGhlIHNlcnZpY2VcIixcbiAgICBTRVJWSUNFX1JFUVVFU1RfRU1QVFkgOiBcIlRoZSByZXF1ZXN0IHNlbnQgdG8gdGhlIHNlcnZpY2UgaXMgZW1wdHlcIixcblxuICAgIC8vIFLDqXBvbnNlXG4gICAgU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT04gOiBcIlRoZSBzZXJ2aWNlIHJldHVybmVkIGFuIGV4Y2VwdGlvbiA6ICcldmFyJSdcIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTl8yIDogXCJUaGUgc2VydmljZSByZXR1cm5lZCBhbiBleGNlcHRpb25cIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0UgOiBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHBhcnNpbmcgdGhlIHJlc3BvbnNlICcldmFyJScgb2YgdGhlIHNlcnZpY2VcIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0VfMiA6IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBwYXJzaW5nIHRoZSByZXNwb25zZVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRU1QVFkgOiBcIlRoZSByZXNwb25zZSBvZiB0aGUgc2VydmljZSBpcyBlbXB0eVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRU1QVFlfMiA6IFwiVGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZpY2UgY291bGQgbm90IGJlIGFuYWx5emVkIG9yIGlzIGVtcHR5XCIsXG4gICAgU0VSVklDRV9SRVNQT05TRV9GT1JNQVQgOiBcIlRoZSBmb3JtYXQgb2YgdGhlIHNlcnZpY2UgcmVzcG9uc2UgaXMgbm90IHN1cHBvcnRlZCAoaGFuZGxlZCBmb3JtYXQocykgOiAnJXZhciUnKVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRk9STUFUXzIgOiBcIlRoZSBmb3JtYXQgb2YgdGhlIHNlcnZpY2UgcmVzcG9uc2UgaXMgbm90IHN1cHBvcnRlZFwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRk9STUFUXzMgOiBcIk5vIHN1Z2dlc3Rpb24gbWF0Y2hpbmcgdGhlIHNlYXJjaFwiLFxuXG4gICAgLy8gQ2xhc3Nlc1xuICAgIENMQVNTX0NPTlNUUlVDVE9SIDogXCInJXZhciUnIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIixcblxuICAgIC8qKlxuICAgICAqIEZvbmN0aW9uIHF1aSB2YSByZXRvdXJuZXIgbGUgbWVzc2FnZSBkJ2VycmV1ciBhc3NvY2nDqSDDoCBsYSBjbMOpIGRvbm7DqWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0TWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGVmIC0gQ2xlZiBkZSBsJ2VycmV1ciAoZXggOiBFUlJPUl9QQVJBTSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJhbWV0cmVzIC0gUGFyYW3DqHRyZXMvdmFyaWFibGVzIGNvbmNlcm7DqXMgcGFyIGxlIG1lc3NhZ2UgZCdlcnJldXIgYXNzb2Npw6kgw6AgbGEgY2xlZiBkb25uw6llXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBtZXNzYWdlIC0gU3RyaW5nIGNvbnRlbmFudCBsZSBtZXNzYWdlIGRlIGwnZXhjZXB0aW9uXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZSA6IGZ1bmN0aW9uIChjbGVmLCBwYXJhbWV0cmVzKSB7XG4gICAgICAgIC8vIHBhcmFtIGRlIGxhIGZvbmN0aW9uIHVuaXF1ZW1lbnQgcG91ciBsYSBkb2N1bWVudGF0aW9uLi4uXG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFyZ3VtZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlIGluZGVmaW5lZCAhXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcmFtcy5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJncyA9IHBhcmFtcztcblxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXNba2V5XTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcIiV2YXIlXCIsIGFyZ3Muam9pbihcIiAtIFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXCIldmFyJVwiLCBcIiV2YXIlIChub3Qgc3BlY2lmaWVkKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZXJyb3IgZGUgc3RyaW5nLnJlcGxhY2UoKVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlc1Jlc291cmNlcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js\n");

/***/ }),

/***/ "./node_modules/leaflet-draw/dist/leaflet.draw-src.css":
/*!*************************************************************!*\
  !*** ./node_modules/leaflet-draw/dist/leaflet.draw-src.css ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvbGVhZmxldC1kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LXNyYy5jc3M/Y2FhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9sZWFmbGV0LWRyYXcvZGlzdC9sZWFmbGV0LmRyYXctc3JjLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/leaflet-draw/dist/leaflet.draw-src.css\n");

/***/ }),

/***/ "./node_modules/leaflet-draw/dist/leaflet.draw-src.js":
/*!************************************************************!*\
  !*** ./node_modules/leaflet-draw/dist/leaflet.draw-src.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n Leaflet.draw 1.0.4, a plugin that adds drawing and editing tools to Leaflet powered maps.\n (c) 2012-2017, Jacob Toye, Jon West, Smartrak, Leaflet\n\n https://github.com/Leaflet/Leaflet.draw\n http://leafletjs.com\n */\n(function (window, document, undefined) {/**\n * Leaflet.draw assumes that you have already included the Leaflet library.\n */\nL.drawVersion = \"1.0.4\";\n/**\n * @class L.Draw\n * @aka Draw\n *\n *\n * To add the draw toolbar set the option drawControl: true in the map options.\n *\n * @example\n * ```js\n *      var map = L.map('map', {drawControl: true}).setView([51.505, -0.09], 13);\n *\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n *      }).addTo(map);\n * ```\n *\n * ### Adding the edit toolbar\n * To use the edit toolbar you must initialise the Leaflet.draw control and manually add it to the map.\n *\n * ```js\n *      var map = L.map('map').setView([51.505, -0.09], 13);\n *\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n *      }).addTo(map);\n *\n *      // FeatureGroup is to store editable layers\n *      var drawnItems = new L.FeatureGroup();\n *      map.addLayer(drawnItems);\n *\n *      var drawControl = new L.Control.Draw({\n *          edit: {\n *              featureGroup: drawnItems\n *          }\n *      });\n *      map.addControl(drawControl);\n * ```\n *\n * The key here is the featureGroup option. This tells the plugin which FeatureGroup contains the layers that\n * should be editable. The featureGroup can contain 0 or more features with geometry types Point, LineString, and Polygon.\n * Leaflet.draw does not work with multigeometry features such as MultiPoint, MultiLineString, MultiPolygon,\n * or GeometryCollection. If you need to add multigeometry features to the draw plugin, convert them to a\n * FeatureCollection of non-multigeometries (Points, LineStrings, or Polygons).\n */\nL.Draw = {};\n\n/**\n * @class L.drawLocal\n * @aka L.drawLocal\n *\n * The core toolbar class of the API — it is used to create the toolbar ui\n *\n * @example\n * ```js\n *      var modifiedDraw = L.drawLocal.extend({\n *          draw: {\n *              toolbar: {\n *                  buttons: {\n *                      polygon: 'Draw an awesome polygon'\n *                  }\n *              }\n *          }\n *      });\n * ```\n *\n * The default state for the control is the draw toolbar just below the zoom control.\n *  This will allow map users to draw vectors and markers.\n *  **Please note the edit toolbar is not enabled by default.**\n */\nL.drawLocal = {\n\t// format: {\n\t// \tnumeric: {\n\t// \t\tdelimiters: {\n\t// \t\t\tthousands: ',',\n\t// \t\t\tdecimal: '.'\n\t// \t\t}\n\t// \t}\n\t// },\n\tdraw: {\n\t\ttoolbar: {\n\t\t\t// #TODO: this should be reorganized where actions are nested in actions\n\t\t\t// ex: actions.undo  or actions.cancel\n\t\t\tactions: {\n\t\t\t\ttitle: 'Cancel drawing',\n\t\t\t\ttext: 'Cancel'\n\t\t\t},\n\t\t\tfinish: {\n\t\t\t\ttitle: 'Finish drawing',\n\t\t\t\ttext: 'Finish'\n\t\t\t},\n\t\t\tundo: {\n\t\t\t\ttitle: 'Delete last point drawn',\n\t\t\t\ttext: 'Delete last point'\n\t\t\t},\n\t\t\tbuttons: {\n\t\t\t\tpolyline: 'Draw a polyline',\n\t\t\t\tpolygon: 'Draw a polygon',\n\t\t\t\trectangle: 'Draw a rectangle',\n\t\t\t\tcircle: 'Draw a circle',\n\t\t\t\tmarker: 'Draw a marker',\n\t\t\t\tcirclemarker: 'Draw a circlemarker'\n\t\t\t}\n\t\t},\n\t\thandlers: {\n\t\t\tcircle: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click and drag to draw circle.'\n\t\t\t\t},\n\t\t\t\tradius: 'Radius'\n\t\t\t},\n\t\t\tcirclemarker: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click map to place circle marker.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tmarker: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click map to place marker.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tpolygon: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click to start drawing shape.',\n\t\t\t\t\tcont: 'Click to continue drawing shape.',\n\t\t\t\t\tend: 'Click first point to close this shape.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tpolyline: {\n\t\t\t\terror: '<strong>Error:</strong> shape edges cannot cross!',\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click to start drawing line.',\n\t\t\t\t\tcont: 'Click to continue drawing line.',\n\t\t\t\t\tend: 'Click last point to finish line.'\n\t\t\t\t}\n\t\t\t},\n\t\t\trectangle: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tstart: 'Click and drag to draw rectangle.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tsimpleshape: {\n\t\t\t\ttooltip: {\n\t\t\t\t\tend: 'Release mouse to finish drawing.'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tedit: {\n\t\ttoolbar: {\n\t\t\tactions: {\n\t\t\t\tsave: {\n\t\t\t\t\ttitle: 'Save changes',\n\t\t\t\t\ttext: 'Save'\n\t\t\t\t},\n\t\t\t\tcancel: {\n\t\t\t\t\ttitle: 'Cancel editing, discards all changes',\n\t\t\t\t\ttext: 'Cancel'\n\t\t\t\t},\n\t\t\t\tclearAll: {\n\t\t\t\t\ttitle: 'Clear all layers',\n\t\t\t\t\ttext: 'Clear All'\n\t\t\t\t}\n\t\t\t},\n\t\t\tbuttons: {\n\t\t\t\tedit: 'Edit layers',\n\t\t\t\teditDisabled: 'No layers to edit',\n\t\t\t\tremove: 'Delete layers',\n\t\t\t\tremoveDisabled: 'No layers to delete'\n\t\t\t}\n\t\t},\n\t\thandlers: {\n\t\t\tedit: {\n\t\t\t\ttooltip: {\n\t\t\t\t\ttext: 'Drag handles or markers to edit features.',\n\t\t\t\t\tsubtext: 'Click cancel to undo changes.'\n\t\t\t\t}\n\t\t\t},\n\t\t\tremove: {\n\t\t\t\ttooltip: {\n\t\t\t\t\ttext: 'Click on a feature to remove.'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n/**\n * ### Events\n * Once you have successfully added the Leaflet.draw plugin to your map you will want to respond to the different\n * actions users can initiate. The following events will be triggered on the map:\n *\n * @class L.Draw.Event\n * @aka Draw.Event\n *\n * Use `L.Draw.Event.EVENTNAME` constants to ensure events are correct.\n *\n * @example\n * ```js\n * map.on(L.Draw.Event.CREATED; function (e) {\n *    var type = e.layerType,\n *        layer = e.layer;\n *\n *    if (type === 'marker') {\n *        // Do marker specific actions\n *    }\n *\n *    // Do whatever else you need to. (save to db; add to map etc)\n *    map.addLayer(layer);\n *});\n * ```\n */\nL.Draw.Event = {};\n/**\n * @event draw:created: PolyLine; Polygon; Rectangle; Circle; Marker | String\n *\n * Layer that was just created.\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\n * Triggered when a new vector or marker has been created.\n *\n */\nL.Draw.Event.CREATED = 'draw:created';\n\n/**\n * @event draw:edited: LayerGroup\n *\n * List of all layers just edited on the map.\n *\n *\n * Triggered when layers in the FeatureGroup; initialised with the plugin; have been edited and saved.\n *\n * @example\n * ```js\n *      map.on('draw:edited', function (e) {\n     *          var layers = e.layers;\n     *          layers.eachLayer(function (layer) {\n     *              //do whatever you want; most likely save back to db\n     *          });\n     *      });\n * ```\n */\nL.Draw.Event.EDITED = 'draw:edited';\n\n/**\n * @event draw:deleted: LayerGroup\n *\n * List of all layers just removed from the map.\n *\n * Triggered when layers have been removed (and saved) from the FeatureGroup.\n */\nL.Draw.Event.DELETED = 'draw:deleted';\n\n/**\n * @event draw:drawstart: String\n *\n * The type of layer this is. One of:`polyline`; `polygon`; `rectangle`; `circle`; `marker`\n *\n * Triggered when the user has chosen to draw a particular vector or marker.\n */\nL.Draw.Event.DRAWSTART = 'draw:drawstart';\n\n/**\n * @event draw:drawstop: String\n *\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\n *\n * Triggered when the user has finished a particular vector or marker.\n */\n\nL.Draw.Event.DRAWSTOP = 'draw:drawstop';\n\n/**\n * @event draw:drawvertex: LayerGroup\n *\n * List of all layers just being added from the map.\n *\n * Triggered when a vertex is created on a polyline or polygon.\n */\nL.Draw.Event.DRAWVERTEX = 'draw:drawvertex';\n\n/**\n * @event draw:editstart: String\n *\n * The type of edit this is. One of: `edit`\n *\n * Triggered when the user starts edit mode by clicking the edit tool button.\n */\n\nL.Draw.Event.EDITSTART = 'draw:editstart';\n\n/**\n * @event draw:editmove: ILayer\n *\n *  Layer that was just moved.\n *\n * Triggered as the user moves a rectangle; circle or marker.\n */\nL.Draw.Event.EDITMOVE = 'draw:editmove';\n\n/**\n * @event draw:editresize: ILayer\n *\n * Layer that was just moved.\n *\n * Triggered as the user resizes a rectangle or circle.\n */\nL.Draw.Event.EDITRESIZE = 'draw:editresize';\n\n/**\n * @event draw:editvertex: LayerGroup\n *\n * List of all layers just being edited from the map.\n *\n * Triggered when a vertex is edited on a polyline or polygon.\n */\nL.Draw.Event.EDITVERTEX = 'draw:editvertex';\n\n/**\n * @event draw:editstop: String\n *\n * The type of edit this is. One of: `edit`\n *\n * Triggered when the user has finshed editing (edit mode) and saves edits.\n */\nL.Draw.Event.EDITSTOP = 'draw:editstop';\n\n/**\n * @event draw:deletestart: String\n *\n * The type of edit this is. One of: `remove`\n *\n * Triggered when the user starts remove mode by clicking the remove tool button.\n */\nL.Draw.Event.DELETESTART = 'draw:deletestart';\n\n/**\n * @event draw:deletestop: String\n *\n * The type of edit this is. One of: `remove`\n *\n * Triggered when the user has finished removing shapes (remove mode) and saves.\n */\nL.Draw.Event.DELETESTOP = 'draw:deletestop';\n\n/**\n * @event draw:toolbaropened: String\n *\n * Triggered when a toolbar is opened.\n */\nL.Draw.Event.TOOLBAROPENED = 'draw:toolbaropened';\n\n/**\n * @event draw:toolbarclosed: String\n *\n * Triggered when a toolbar is closed.\n */\nL.Draw.Event.TOOLBARCLOSED = 'draw:toolbarclosed';\n\n/**\n * @event draw:markercontext: String\n *\n * Triggered when a marker is right clicked.\n */\nL.Draw.Event.MARKERCONTEXT = 'draw:markercontext';\n\n\nL.Draw = L.Draw || {};\n\n/**\n * @class L.Draw.Feature\n * @aka Draw.Feature\n */\nL.Draw.Feature = L.Handler.extend({\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._overlayPane = map._panes.overlayPane;\n\t\tthis._popupPane = map._panes.popupPane;\n\n\t\t// Merge default shapeOptions options with custom shapeOptions\n\t\tif (options && options.shapeOptions) {\n\t\t\toptions.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);\n\t\t}\n\t\tL.setOptions(this, options);\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.Draw.Feature.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.Draw.Feature.include(L.Mixin.Events);\n\t\t}\n\t},\n\n\t// @method enable(): void\n\t// Enables this handler\n\tenable: function () {\n\t\tif (this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.Handler.prototype.enable.call(this);\n\n\t\tthis.fire('enabled', {handler: this.type});\n\n\t\tthis._map.fire(L.Draw.Event.DRAWSTART, {layerType: this.type});\n\t},\n\n\t// @method disable(): void\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.Handler.prototype.disable.call(this);\n\n\t\tthis._map.fire(L.Draw.Event.DRAWSTOP, {layerType: this.type});\n\n\t\tthis.fire('disabled', {handler: this.type});\n\t},\n\n\t// @method addHooks(): void\n\t// Add's event listeners to this handler\n\taddHooks: function () {\n\t\tvar map = this._map;\n\n\t\tif (map) {\n\t\t\tL.DomUtil.disableTextSelection();\n\n\t\t\tmap.getContainer().focus();\n\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\n\n\t\t\tL.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Removes event listeners from this handler\n\tremoveHooks: function () {\n\t\tif (this._map) {\n\t\t\tL.DomUtil.enableTextSelection();\n\n\t\t\tthis._tooltip.dispose();\n\t\t\tthis._tooltip = null;\n\n\t\t\tL.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);\n\t\t}\n\t},\n\n\t// @method setOptions(object): void\n\t// Sets new options to this handler\n\tsetOptions: function (options) {\n\t\tL.setOptions(this, options);\n\t},\n\n\t_fireCreatedEvent: function (layer) {\n\t\tthis._map.fire(L.Draw.Event.CREATED, {layer: layer, layerType: this.type});\n\t},\n\n\t// Cancel drawing when the escape key is pressed\n\t_cancelDrawing: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._map.fire('draw:canceled', {layerType: this.type});\n\t\t\tthis.disable();\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Polyline\n * @aka Draw.Polyline\n * @inherits L.Draw.Feature\n */\nL.Draw.Polyline = L.Draw.Feature.extend({\n\tstatics: {\n\t\tTYPE: 'polyline'\n\t},\n\n\tPoly: L.Polyline,\n\n\toptions: {\n\t\tallowIntersection: true,\n\t\trepeatMode: false,\n\t\tdrawError: {\n\t\t\tcolor: '#b00b00',\n\t\t\ttimeout: 2500\n\t\t},\n\t\ticon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\n\t\t}),\n\t\ttouchIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n\t\t}),\n\t\tguidelineDistance: 20,\n\t\tmaxGuideLineLength: 4000,\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: false,\n\t\t\tclickable: true\n\t\t},\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\n\t\tshowLength: true, // Whether to display distance in the tooltip\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any map layers\n\t\tfactor: 1, // To change distance calculation\n\t\tmaxPoints: 0 // Once this number of points are placed, finish shape\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.icon = this.options.touchIcon;\n\t\t}\n\n\t\t// Need to set this here to ensure the correct message is used.\n\t\tthis.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;\n\n\t\t// Merge default drawError options with custom options\n\t\tif (options && options.drawError) {\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n\t\t}\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Polyline.TYPE;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\t\tif (this._map) {\n\t\t\tthis._markers = [];\n\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t\tthis._map.addLayer(this._markerGroup);\n\n\t\t\tthis._poly = new L.Polyline([], this.options.shapeOptions);\n\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\n\n\t\t\t// Make a transparent marker that will used to catch click events. These click\n\t\t\t// events will create the vertices. We need to do this so we can ensure that\n\t\t\t// we can create vertices over other map layers (markers, vector layers). We\n\t\t\t// also do not want to trigger any click handlers of objects we are clicking on\n\t\t\t// while drawing.\n\t\t\tif (!this._mouseMarker) {\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\n\t\t\t\t\ticon: L.divIcon({\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\n\t\t\t\t\t\ticonAnchor: [20, 20],\n\t\t\t\t\t\ticonSize: [40, 40]\n\t\t\t\t\t}),\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mouseMarker\n\t\t\t\t.on('mouseout', this._onMouseOut, this)\n\t\t\t\t.on('mousemove', this._onMouseMove, this) // Necessary to prevent 0.8 stutter\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.8 compatibility\n\t\t\t\t.addTo(this._map);\n\n\t\t\tthis._map\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.7 compatibility\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t\t.on('touchstart', this._onTouch, this)\n\t\t\t\t.on('zoomend', this._onZoomEnd, this);\n\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\tthis._cleanUpShape();\n\n\t\t// remove markers from map\n\t\tthis._map.removeLayer(this._markerGroup);\n\t\tdelete this._markerGroup;\n\t\tdelete this._markers;\n\n\t\tthis._map.removeLayer(this._poly);\n\t\tdelete this._poly;\n\n\t\tthis._mouseMarker\n\t\t\t.off('mousedown', this._onMouseDown, this)\n\t\t\t.off('mouseout', this._onMouseOut, this)\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this);\n\t\tthis._map.removeLayer(this._mouseMarker);\n\t\tdelete this._mouseMarker;\n\n\t\t// clean up DOM\n\t\tthis._clearGuides();\n\n\t\tthis._map\n\t\t\t.off('mouseup', this._onMouseUp, this)\n\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t.off('zoomlevelschange', this._onZoomEnd, this)\n\t\t\t.off('zoomend', this._onZoomEnd, this)\n\t\t\t.off('touchstart', this._onTouch, this)\n\t\t\t.off('click', this._onTouch, this);\n\t},\n\n\t// @method deleteLastVertex(): void\n\t// Remove the last vertex from the polyline, removes polyline from map if only one point exists.\n\tdeleteLastVertex: function () {\n\t\tif (this._markers.length <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lastMarker = this._markers.pop(),\n\t\t\tpoly = this._poly,\n\t\t\t// Replaces .spliceLatLngs()\n\t\t\tlatlngs = poly.getLatLngs(),\n\t\t\tlatlng = latlngs.splice(-1, 1)[0];\n\t\tthis._poly.setLatLngs(latlngs);\n\n\t\tthis._markerGroup.removeLayer(lastMarker);\n\n\t\tif (poly.getLatLngs().length < 2) {\n\t\t\tthis._map.removeLayer(poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, false);\n\t},\n\n\t// @method addVertex(): void\n\t// Add a vertex to the end of the polyline\n\taddVertex: function (latlng) {\n\t\tvar markersLength = this._markers.length;\n\t\t// markersLength must be greater than or equal to 2 before intersections can occur\n\t\tif (markersLength >= 2 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\t\telse if (this._errorShown) {\n\t\t\tthis._hideErrorTooltip();\n\t\t}\n\n\t\tthis._markers.push(this._createMarker(latlng));\n\n\t\tthis._poly.addLatLng(latlng);\n\n\t\tif (this._poly.getLatLngs().length === 2) {\n\t\t\tthis._map.addLayer(this._poly);\n\t\t}\n\n\t\tthis._vertexChanged(latlng, true);\n\t},\n\n\t// @method completeShape(): void\n\t// Closes the polyline between the first and last points\n\tcompleteShape: function () {\n\t\tif (this._markers.length <= 1 || !this._shapeIsValid()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t_finishShape: function () {\n\t\tvar latlngs = this._poly._defaultShape ? this._poly._defaultShape() : this._poly.getLatLngs();\n\t\tvar intersects = this._poly.newLatLngIntersects(latlngs[latlngs.length - 1]);\n\n\t\tif ((!this.options.allowIntersection && intersects) || !this._shapeIsValid()) {\n\t\t\tthis._showErrorTooltip();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireCreatedEvent();\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t// Called to verify the shape is valid when the user tries to finish it\n\t// Return false if the shape is not valid\n\t_shapeIsValid: function () {\n\t\treturn true;\n\t},\n\n\t_onZoomEnd: function () {\n\t\tif (this._markers !== null) {\n\t\t\tthis._updateGuide();\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar newPos = this._map.mouseEventToLayerPoint(e.originalEvent);\n\t\tvar latlng = this._map.layerPointToLatLng(newPos);\n\n\t\t// Save latlng\n\t\t// should this be moved to _updateGuide() ?\n\t\tthis._currentLatLng = latlng;\n\n\t\tthis._updateTooltip(latlng);\n\n\t\t// Update the guide line\n\t\tthis._updateGuide(newPos);\n\n\t\t// Update the mouse marker position\n\t\tthis._mouseMarker.setLatLng(latlng);\n\n\t\tL.DomEvent.preventDefault(e.originalEvent);\n\t},\n\n\t_vertexChanged: function (latlng, added) {\n\t\tthis._map.fire(L.Draw.Event.DRAWVERTEX, {layers: this._markerGroup});\n\t\tthis._updateFinishHandler();\n\n\t\tthis._updateRunningMeasure(latlng, added);\n\n\t\tthis._clearGuides();\n\n\t\tthis._updateTooltip();\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tif (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tthis._onMouseMove(e);\n\t\t\tthis._clickHandled = true;\n\t\t\tthis._disableNewMarkers();\n\t\t\tvar originalEvent = e.originalEvent;\n\t\t\tvar clientX = originalEvent.clientX;\n\t\t\tvar clientY = originalEvent.clientY;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t}\n\t},\n\n\t_startPoint: function (clientX, clientY) {\n\t\tthis._mouseDownOrigin = L.point(clientX, clientY);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX = originalEvent.clientX;\n\t\tvar clientY = originalEvent.clientY;\n\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\tthis._clickHandled = null;\n\t},\n\n\t_endPoint: function (clientX, clientY, e) {\n\t\tif (this._mouseDownOrigin) {\n\t\t\tvar dragCheckDistance = L.point(clientX, clientY)\n\t\t\t\t.distanceTo(this._mouseDownOrigin);\n\t\t\tvar lastPtDistance = this._calculateFinishDistance(e.latlng);\n\t\t\tif (this.options.maxPoints > 1 && this.options.maxPoints == this._markers.length + 1) {\n\t\t\t\tthis.addVertex(e.latlng);\n\t\t\t\tthis._finishShape();\n\t\t\t} else if (lastPtDistance < 10 && L.Browser.touch) {\n\t\t\t\tthis._finishShape();\n\t\t\t} else if (Math.abs(dragCheckDistance) < 9 * (window.devicePixelRatio || 1)) {\n\t\t\t\tthis.addVertex(e.latlng);\n\t\t\t}\n\t\t\tthis._enableNewMarkers(); // after a short pause, enable new markers\n\t\t}\n\t\tthis._mouseDownOrigin = null;\n\t},\n\n\t// ontouch prevented by clickHandled flag because some browsers fire both click/touch events,\n\t// causing unwanted behavior\n\t_onTouch: function (e) {\n\t\tvar originalEvent = e.originalEvent;\n\t\tvar clientX;\n\t\tvar clientY;\n\t\tif (originalEvent.touches && originalEvent.touches[0] && !this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n\t\t\tclientX = originalEvent.touches[0].clientX;\n\t\t\tclientY = originalEvent.touches[0].clientY;\n\t\t\tthis._disableNewMarkers();\n\t\t\tthis._touchHandled = true;\n\t\t\tthis._startPoint.call(this, clientX, clientY);\n\t\t\tthis._endPoint.call(this, clientX, clientY, e);\n\t\t\tthis._touchHandled = null;\n\t\t}\n\t\tthis._clickHandled = null;\n\t},\n\n\t_onMouseOut: function () {\n\t\tif (this._tooltip) {\n\t\t\tthis._tooltip._onMouseOut.call(this._tooltip);\n\t\t}\n\t},\n\n\t// calculate if we are currently within close enough distance\n\t// of the closing point (first point for shapes, last point for lines)\n\t// this is semi-ugly code but the only reliable way i found to get the job done\n\t// note: calculating point.distanceTo between mouseDownOrigin and last marker did NOT work\n\t_calculateFinishDistance: function (potentialLatLng) {\n\t\tvar lastPtDistance;\n\t\tif (this._markers.length > 0) {\n\t\t\tvar finishMarker;\n\t\t\tif (this.type === L.Draw.Polyline.TYPE) {\n\t\t\t\tfinishMarker = this._markers[this._markers.length - 1];\n\t\t\t} else if (this.type === L.Draw.Polygon.TYPE) {\n\t\t\t\tfinishMarker = this._markers[0];\n\t\t\t} else {\n\t\t\t\treturn Infinity;\n\t\t\t}\n\t\t\tvar lastMarkerPoint = this._map.latLngToContainerPoint(finishMarker.getLatLng()),\n\t\t\t\tpotentialMarker = new L.Marker(potentialLatLng, {\n\t\t\t\t\ticon: this.options.icon,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t\t\t});\n\t\t\tvar potentialMarkerPint = this._map.latLngToContainerPoint(potentialMarker.getLatLng());\n\t\t\tlastPtDistance = lastMarkerPoint.distanceTo(potentialMarkerPint);\n\t\t} else {\n\t\t\tlastPtDistance = Infinity;\n\t\t}\n\t\treturn lastPtDistance;\n\t},\n\n\t_updateFinishHandler: function () {\n\t\tvar markerCount = this._markers.length;\n\t\t// The last marker should have a click handler to close the polyline\n\t\tif (markerCount > 1) {\n\t\t\tthis._markers[markerCount - 1].on('click', this._finishShape, this);\n\t\t}\n\n\t\t// Remove the old marker click handler (as only the last point should close the polyline)\n\t\tif (markerCount > 2) {\n\t\t\tthis._markers[markerCount - 2].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng) {\n\t\tvar marker = new L.Marker(latlng, {\n\t\t\ticon: this.options.icon,\n\t\t\tzIndexOffset: this.options.zIndexOffset * 2\n\t\t});\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_updateGuide: function (newPos) {\n\t\tvar markerCount = this._markers ? this._markers.length : 0;\n\n\t\tif (markerCount > 0) {\n\t\t\tnewPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);\n\n\t\t\t// draw the guide line\n\t\t\tthis._clearGuides();\n\t\t\tthis._drawGuide(\n\t\t\t\tthis._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()),\n\t\t\t\tnewPos\n\t\t\t);\n\t\t}\n\t},\n\n\t_updateTooltip: function (latLng) {\n\t\tvar text = this._getTooltipText();\n\n\t\tif (latLng) {\n\t\t\tthis._tooltip.updatePosition(latLng);\n\t\t}\n\n\t\tif (!this._errorShown) {\n\t\t\tthis._tooltip.updateContent(text);\n\t\t}\n\t},\n\n\t_drawGuide: function (pointA, pointB) {\n\t\tvar length = Math.floor(Math.sqrt(Math.pow((pointB.x - pointA.x), 2) + Math.pow((pointB.y - pointA.y), 2))),\n\t\t\tguidelineDistance = this.options.guidelineDistance,\n\t\t\tmaxGuideLineLength = this.options.maxGuideLineLength,\n\t\t\t// Only draw a guideline with a max length\n\t\t\ti = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,\n\t\t\tfraction,\n\t\t\tdashPoint,\n\t\t\tdash;\n\n\t\t//create the guides container if we haven't yet\n\t\tif (!this._guidesContainer) {\n\t\t\tthis._guidesContainer = L.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);\n\t\t}\n\n\t\t//draw a dash every GuildeLineDistance\n\t\tfor (; i < length; i += this.options.guidelineDistance) {\n\t\t\t//work out fraction along line we are\n\t\t\tfraction = i / length;\n\n\t\t\t//calculate new x,y point\n\t\t\tdashPoint = {\n\t\t\t\tx: Math.floor((pointA.x * (1 - fraction)) + (fraction * pointB.x)),\n\t\t\t\ty: Math.floor((pointA.y * (1 - fraction)) + (fraction * pointB.y))\n\t\t\t};\n\n\t\t\t//add guide dash to guide container\n\t\t\tdash = L.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);\n\t\t\tdash.style.backgroundColor =\n\t\t\t\t!this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;\n\n\t\t\tL.DomUtil.setPosition(dash, dashPoint);\n\t\t}\n\t},\n\n\t_updateGuideColor: function (color) {\n\t\tif (this._guidesContainer) {\n\t\t\tfor (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {\n\t\t\t\tthis._guidesContainer.childNodes[i].style.backgroundColor = color;\n\t\t\t}\n\t\t}\n\t},\n\n\t// removes all child elements (guide dashes) from the guides container\n\t_clearGuides: function () {\n\t\tif (this._guidesContainer) {\n\t\t\twhile (this._guidesContainer.firstChild) {\n\t\t\t\tthis._guidesContainer.removeChild(this._guidesContainer.firstChild);\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar showLength = this.options.showLength,\n\t\t\tlabelText, distanceStr;\n\t\tif (this._markers.length === 0) {\n\t\t\tlabelText = {\n\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.start\n\t\t\t};\n\t\t} else {\n\t\t\tdistanceStr = showLength ? this._getMeasurementString() : '';\n\n\t\t\tif (this._markers.length === 1) {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.cont,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlabelText = {\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.end,\n\t\t\t\t\tsubtext: distanceStr\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn labelText;\n\t},\n\n\t_updateRunningMeasure: function (latlng, added) {\n\t\tvar markersLength = this._markers.length,\n\t\t\tpreviousMarkerIndex, distance;\n\n\t\tif (this._markers.length === 1) {\n\t\t\tthis._measurementRunningTotal = 0;\n\t\t} else {\n\t\t\tpreviousMarkerIndex = markersLength - (added ? 2 : 1);\n\n\t\t\t// Calculate the distance based on the version\n\t\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\t\tdistance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\n\t\t\t} else {\n\t\t\t\tdistance = this._map.distance(latlng, this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\n\t\t\t}\n\n\t\t\tthis._measurementRunningTotal += distance * (added ? 1 : -1);\n\t\t}\n\t},\n\n\t_getMeasurementString: function () {\n\t\tvar currentLatLng = this._currentLatLng,\n\t\t\tpreviousLatLng = this._markers[this._markers.length - 1].getLatLng(),\n\t\t\tdistance;\n\n\t\t// Calculate the distance from the last fixed point to the mouse position based on the version\n\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\tdistance = previousLatLng && currentLatLng && currentLatLng.distanceTo ? this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\n\t\t} else {\n\t\t\tdistance = previousLatLng && currentLatLng ? this._measurementRunningTotal + this._map.distance(currentLatLng, previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\n\t\t}\n\n\t\treturn L.GeometryUtil.readableDistance(distance, this.options.metric, this.options.feet, this.options.nautic, this.options.precision);\n\t},\n\n\t_showErrorTooltip: function () {\n\t\tthis._errorShown = true;\n\n\t\t// Update tooltip\n\t\tthis._tooltip\n\t\t\t.showAsError()\n\t\t\t.updateContent({text: this.options.drawError.message});\n\n\t\t// Update shape\n\t\tthis._updateGuideColor(this.options.drawError.color);\n\t\tthis._poly.setStyle({color: this.options.drawError.color});\n\n\t\t// Hide the error after 2 seconds\n\t\tthis._clearHideErrorTimeout();\n\t\tthis._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);\n\t},\n\n\t_hideErrorTooltip: function () {\n\t\tthis._errorShown = false;\n\n\t\tthis._clearHideErrorTimeout();\n\n\t\t// Revert tooltip\n\t\tthis._tooltip\n\t\t\t.removeError()\n\t\t\t.updateContent(this._getTooltipText());\n\n\t\t// Revert shape\n\t\tthis._updateGuideColor(this.options.shapeOptions.color);\n\t\tthis._poly.setStyle({color: this.options.shapeOptions.color});\n\t},\n\n\t_clearHideErrorTimeout: function () {\n\t\tif (this._hideErrorTimeout) {\n\t\t\tclearTimeout(this._hideErrorTimeout);\n\t\t\tthis._hideErrorTimeout = null;\n\t\t}\n\t},\n\n\t// disable new markers temporarily;\n\t// this is to prevent duplicated touch/click events in some browsers\n\t_disableNewMarkers: function () {\n\t\tthis._disableMarkers = true;\n\t},\n\n\t// see _disableNewMarkers\n\t_enableNewMarkers: function () {\n\t\tsetTimeout(function () {\n\t\t\tthis._disableMarkers = false;\n\t\t}.bind(this), 50);\n\t},\n\n\t_cleanUpShape: function () {\n\t\tif (this._markers.length > 1) {\n\t\t\tthis._markers[this._markers.length - 1].off('click', this._finishShape, this);\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Polygon\n * @aka Draw.Polygon\n * @inherits L.Draw.Polyline\n */\nL.Draw.Polygon = L.Draw.Polyline.extend({\n\tstatics: {\n\t\tTYPE: 'polygon'\n\t},\n\n\tPoly: L.Polygon,\n\n\toptions: {\n\t\tshowArea: false,\n\t\tshowLength: false,\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: true,\n\t\t\tfillColor: null, //same as color by default\n\t\t\tfillOpacity: 0.2,\n\t\t\tclickable: true\n\t\t},\n\t\t// Whether to use the metric measurement system (truthy) or not (falsy).\n\t\t// Also defines the units to use for the metric system as an array of\n\t\t// strings (e.g. `['ha', 'm']`).\n\t\tmetric: true,\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\n\t\t// Defines the precision for each type of unit (e.g. {km: 2, ft: 0}\n\t\tprecision: {}\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\tL.Draw.Polyline.prototype.initialize.call(this, map, options);\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Polygon.TYPE;\n\t},\n\n\t_updateFinishHandler: function () {\n\t\tvar markerCount = this._markers.length;\n\n\t\t// The first marker should have a click handler to close the polygon\n\t\tif (markerCount === 1) {\n\t\t\tthis._markers[0].on('click', this._finishShape, this);\n\t\t}\n\n\t\t// Add and update the double click handler\n\t\tif (markerCount > 2) {\n\t\t\tthis._markers[markerCount - 1].on('dblclick', this._finishShape, this);\n\t\t\t// Only need to remove handler if has been added before\n\t\t\tif (markerCount > 3) {\n\t\t\t\tthis._markers[markerCount - 2].off('dblclick', this._finishShape, this);\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar text, subtext;\n\n\t\tif (this._markers.length === 0) {\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.start;\n\t\t} else if (this._markers.length < 3) {\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.cont;\n\t\t\tsubtext = this._getMeasurementString();\n\t\t} else {\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.end;\n\t\t\tsubtext = this._getMeasurementString();\n\t\t}\n\n\t\treturn {\n\t\t\ttext: text,\n\t\t\tsubtext: subtext\n\t\t};\n\t},\n\n\t_getMeasurementString: function () {\n\t\tvar area = this._area,\n\t\t\tmeasurementString = '';\n\n\n\t\tif (!area && !this.options.showLength) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.options.showLength) {\n\t\t\tmeasurementString = L.Draw.Polyline.prototype._getMeasurementString.call(this);\n\t\t}\n\n\t\tif (area) {\n\t\t\tmeasurementString += '<br>' + L.GeometryUtil.readableArea(area, this.options.metric, this.options.precision);\n\t\t}\n\n\t\treturn measurementString;\n\t},\n\n\t_shapeIsValid: function () {\n\t\treturn this._markers.length >= 3;\n\t},\n\n\t_vertexChanged: function (latlng, added) {\n\t\tvar latLngs;\n\n\t\t// Check to see if we should show the area\n\t\tif (!this.options.allowIntersection && this.options.showArea) {\n\t\t\tlatLngs = this._poly.getLatLngs();\n\n\t\t\tthis._area = L.GeometryUtil.geodesicArea(latLngs);\n\t\t}\n\n\t\tL.Draw.Polyline.prototype._vertexChanged.call(this, latlng, added);\n\t},\n\n\t_cleanUpShape: function () {\n\t\tvar markerCount = this._markers.length;\n\n\t\tif (markerCount > 0) {\n\t\t\tthis._markers[0].off('click', this._finishShape, this);\n\n\t\t\tif (markerCount > 2) {\n\t\t\t\tthis._markers[markerCount - 1].off('dblclick', this._finishShape, this);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n\nL.SimpleShape = {};\n/**\n * @class L.Draw.SimpleShape\n * @aka Draw.SimpleShape\n * @inherits L.Draw.Feature\n */\nL.Draw.SimpleShape = L.Draw.Feature.extend({\n\toptions: {\n\t\trepeatMode: false\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\tthis._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\t\tif (this._map) {\n\t\t\tthis._mapDraggable = this._map.dragging.enabled();\n\n\t\t\tif (this._mapDraggable) {\n\t\t\t\tthis._map.dragging.disable();\n\t\t\t}\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\n\n\t\t\tthis._map\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('touchstart', this._onMouseDown, this)\n\t\t\t\t.on('touchmove', this._onMouseMove, this);\n\n\t\t\t// we should prevent default, otherwise default behavior (scrolling) will fire,\n\t\t\t// and that will cause document.touchend to fire and will stop the drawing\n\t\t\t// (circle, rectangle) in touch mode.\n\t\t\t// (update): we have to send passive now to prevent scroll, because by default it is {passive: true} now, which means,\n\t\t\t// handler can't event.preventDefault\n\t\t\t// check the news https://developers.google.com/web/updates/2016/06/passive-event-listeners\n\t\t\tdocument.addEventListener('touchstart', L.DomEvent.preventDefault, {passive: false});\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\t\tif (this._map) {\n\t\t\tif (this._mapDraggable) {\n\t\t\t\tthis._map.dragging.enable();\n\t\t\t}\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = '';\n\n\t\t\tthis._map\n\t\t\t\t.off('mousedown', this._onMouseDown, this)\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t\t.off('touchstart', this._onMouseDown, this)\n\t\t\t\t.off('touchmove', this._onMouseMove, this);\n\n\t\t\tL.DomEvent.off(document, 'mouseup', this._onMouseUp, this);\n\t\t\tL.DomEvent.off(document, 'touchend', this._onMouseUp, this);\n\n\t\t\tdocument.removeEventListener('touchstart', L.DomEvent.preventDefault);\n\n\t\t\t// If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return\n\t\t\tif (this._shape) {\n\t\t\t\tthis._map.removeLayer(this._shape);\n\t\t\t\tdelete this._shape;\n\t\t\t}\n\t\t}\n\t\tthis._isDrawing = false;\n\t},\n\n\t_getTooltipText: function () {\n\t\treturn {\n\t\t\ttext: this._endLabelText\n\t\t};\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._isDrawing = true;\n\t\tthis._startLatLng = e.latlng;\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'mouseup', this._onMouseUp, this)\n\t\t\t.on(document, 'touchend', this._onMouseUp, this)\n\t\t\t.preventDefault(e.originalEvent);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tif (this._isDrawing) {\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\n\t\t\tthis._drawShape(latlng);\n\t\t}\n\t},\n\n\t_onMouseUp: function () {\n\t\tif (this._shape) {\n\t\t\tthis._fireCreatedEvent();\n\t\t}\n\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Rectangle\n * @aka Draw.Rectangle\n * @inherits L.Draw.SimpleShape\n */\nL.Draw.Rectangle = L.Draw.SimpleShape.extend({\n\tstatics: {\n\t\tTYPE: 'rectangle'\n\t},\n\n\toptions: {\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: true,\n\t\t\tfillColor: null, //same as color by default\n\t\t\tfillOpacity: 0.2,\n\t\t\tclickable: true\n\t\t},\n\t\tshowArea: true, //Whether to show the area in the tooltip\n\t\tmetric: true // Whether to use the metric measurement system or imperial\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Rectangle.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;\n\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method disable(): void\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isCurrentlyTwoClickDrawing = false;\n\t\tL.Draw.SimpleShape.prototype.disable.call(this);\n\t},\n\n\t_onMouseUp: function (e) {\n\t\tif (!this._shape && !this._isCurrentlyTwoClickDrawing) {\n\t\t\tthis._isCurrentlyTwoClickDrawing = true;\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure closing click is on map\n\t\tif (this._isCurrentlyTwoClickDrawing && !_hasAncestor(e.target, 'leaflet-pane')) {\n\t\t\treturn;\n\t\t}\n\n\t\tL.Draw.SimpleShape.prototype._onMouseUp.call(this);\n\t},\n\n\t_drawShape: function (latlng) {\n\t\tif (!this._shape) {\n\t\t\tthis._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);\n\t\t\tthis._map.addLayer(this._shape);\n\t\t} else {\n\t\t\tthis._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);\n\t},\n\n\t_getTooltipText: function () {\n\t\tvar tooltipText = L.Draw.SimpleShape.prototype._getTooltipText.call(this),\n\t\t\tshape = this._shape,\n\t\t\tshowArea = this.options.showArea,\n\t\t\tlatLngs, area, subtext;\n\n\t\tif (shape) {\n\t\t\tlatLngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs();\n\t\t\tarea = L.GeometryUtil.geodesicArea(latLngs);\n\t\t\tsubtext = showArea ? L.GeometryUtil.readableArea(area, this.options.metric) : '';\n\t\t}\n\n\t\treturn {\n\t\t\ttext: tooltipText.text,\n\t\t\tsubtext: subtext\n\t\t};\n\t}\n});\n\nfunction _hasAncestor(el, cls) {\n\twhile ((el = el.parentElement) && !el.classList.contains(cls)) {\n\t\t;\n\t}\n\treturn el;\n}\n\n\n\n/**\n * @class L.Draw.Marker\n * @aka Draw.Marker\n * @inherits L.Draw.Feature\n */\nL.Draw.Marker = L.Draw.Feature.extend({\n\tstatics: {\n\t\tTYPE: 'marker'\n\t},\n\n\toptions: {\n\t\ticon: new L.Icon.Default(),\n\t\trepeatMode: false,\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Marker.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.marker.tooltip.start;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\n\n\t\tif (this._map) {\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\n\n\t\t\t// Same mouseMarker as in Draw.Polyline\n\t\t\tif (!this._mouseMarker) {\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\n\t\t\t\t\ticon: L.divIcon({\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\n\t\t\t\t\t\ticonAnchor: [20, 20],\n\t\t\t\t\t\ticonSize: [40, 40]\n\t\t\t\t\t}),\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mouseMarker\n\t\t\t\t.on('click', this._onClick, this)\n\t\t\t\t.addTo(this._map);\n\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\n\t\t\tthis._map.on('click', this._onTouch, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\n\n\t\tif (this._map) {\n\t\t\tthis._map\n\t\t\t\t.off('click', this._onClick, this)\n\t\t\t\t.off('click', this._onTouch, this);\n\t\t\tif (this._marker) {\n\t\t\t\tthis._marker.off('click', this._onClick, this);\n\t\t\t\tthis._map\n\t\t\t\t\t.removeLayer(this._marker);\n\t\t\t\tdelete this._marker;\n\t\t\t}\n\n\t\t\tthis._mouseMarker.off('click', this._onClick, this);\n\t\t\tthis._map.removeLayer(this._mouseMarker);\n\t\t\tdelete this._mouseMarker;\n\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tthis._mouseMarker.setLatLng(latlng);\n\n\t\tif (!this._marker) {\n\t\t\tthis._marker = this._createMarker(latlng);\n\t\t\t// Bind to both marker and map to make sure we get the click event.\n\t\t\tthis._marker.on('click', this._onClick, this);\n\t\t\tthis._map\n\t\t\t\t.on('click', this._onClick, this)\n\t\t\t\t.addLayer(this._marker);\n\t\t}\n\t\telse {\n\t\t\tlatlng = this._mouseMarker.getLatLng();\n\t\t\tthis._marker.setLatLng(latlng);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng) {\n\t\treturn new L.Marker(latlng, {\n\t\t\ticon: this.options.icon,\n\t\t\tzIndexOffset: this.options.zIndexOffset\n\t\t});\n\t},\n\n\t_onClick: function () {\n\t\tthis._fireCreatedEvent();\n\n\t\tthis.disable();\n\t\tif (this.options.repeatMode) {\n\t\t\tthis.enable();\n\t\t}\n\t},\n\n\t_onTouch: function (e) {\n\t\t// called on click & tap, only really does any thing on tap\n\t\tthis._onMouseMove(e); // creates & places marker\n\t\tthis._onClick(); // permanently places marker & ends interaction\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar marker = new L.Marker.Touch(this._marker.getLatLng(), {icon: this.options.icon});\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.CircleMarker\n * @aka Draw.CircleMarker\n * @inherits L.Draw.Marker\n */\nL.Draw.CircleMarker = L.Draw.Marker.extend({\n\tstatics: {\n\t\tTYPE: 'circlemarker'\n\t},\n\n\toptions: {\n\t\tstroke: true,\n\t\tcolor: '#3388ff',\n\t\tweight: 4,\n\t\topacity: 0.5,\n\t\tfill: true,\n\t\tfillColor: null, //same as color by default\n\t\tfillOpacity: 0.2,\n\t\tclickable: true,\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.CircleMarker.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circlemarker.tooltip.start;\n\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\n\t},\n\n\n\t_fireCreatedEvent: function () {\n\t\tvar circleMarker = new L.CircleMarker(this._marker.getLatLng(), this.options);\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, circleMarker);\n\t},\n\n\t_createMarker: function (latlng) {\n\t\treturn new L.CircleMarker(latlng, this.options);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Circle\n * @aka Draw.Circle\n * @inherits L.Draw.SimpleShape\n */\nL.Draw.Circle = L.Draw.SimpleShape.extend({\n\tstatics: {\n\t\tTYPE: 'circle'\n\t},\n\n\toptions: {\n\t\tshapeOptions: {\n\t\t\tstroke: true,\n\t\t\tcolor: '#3388ff',\n\t\t\tweight: 4,\n\t\t\topacity: 0.5,\n\t\t\tfill: true,\n\t\t\tfillColor: null, //same as color by default\n\t\t\tfillOpacity: 0.2,\n\t\t\tclickable: true\n\t\t},\n\t\tshowRadius: true,\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\n\t\tfeet: true, // When not metric, use feet instead of yards for display\n\t\tnautic: false // When not metric, not feet use nautic mile for display\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (map, options) {\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.Draw.Circle.TYPE;\n\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;\n\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\n\t},\n\n\t_drawShape: function (latlng) {\n\t\t// Calculate the distance based on the version\n\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\tvar distance = this._startLatLng.distanceTo(latlng);\n\t\t} else {\n\t\t\tvar distance = this._map.distance(this._startLatLng, latlng);\n\t\t}\n\n\t\tif (!this._shape) {\n\t\t\tthis._shape = new L.Circle(this._startLatLng, distance, this.options.shapeOptions);\n\t\t\tthis._map.addLayer(this._shape);\n\t\t} else {\n\t\t\tthis._shape.setRadius(distance);\n\t\t}\n\t},\n\n\t_fireCreatedEvent: function () {\n\t\tvar circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tvar latlng = e.latlng,\n\t\t\tshowRadius = this.options.showRadius,\n\t\t\tuseMetric = this.options.metric,\n\t\t\tradius;\n\n\t\tthis._tooltip.updatePosition(latlng);\n\t\tif (this._isDrawing) {\n\t\t\tthis._drawShape(latlng);\n\n\t\t\t// Get the new radius (rounded to 1 dp)\n\t\t\tradius = this._shape.getRadius().toFixed(1);\n\n\t\t\tvar subtext = '';\n\t\t\tif (showRadius) {\n\t\t\t\tsubtext = L.drawLocal.draw.handlers.circle.radius + ': ' +\n\t\t\t\t\tL.GeometryUtil.readableDistance(radius, useMetric, this.options.feet, this.options.nautic);\n\t\t\t}\n\t\t\tthis._tooltip.updateContent({\n\t\t\t\ttext: this._endLabelText,\n\t\t\t\tsubtext: subtext\n\t\t\t});\n\t\t}\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n\n/**\n * @class L.Edit.Marker\n * @aka Edit.Marker\n */\nL.Edit.Marker = L.Handler.extend({\n\t// @method initialize(): void\n\tinitialize: function (marker, options) {\n\t\tthis._marker = marker;\n\t\tL.setOptions(this, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tvar marker = this._marker;\n\n\t\tmarker.dragging.enable();\n\t\tmarker.on('dragend', this._onDragEnd, marker);\n\t\tthis._toggleMarkerHighlight();\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tvar marker = this._marker;\n\n\t\tmarker.dragging.disable();\n\t\tmarker.off('dragend', this._onDragEnd, marker);\n\t\tthis._toggleMarkerHighlight();\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar layer = e.target;\n\t\tlayer.edited = true;\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: layer});\n\t},\n\n\t_toggleMarkerHighlight: function () {\n\t\tvar icon = this._marker._icon;\n\n\t\t// Don't do anything if this layer is a marker but doesn't have an icon. Markers\n\t\t// should usually have icons. If using Leaflet.draw with Leaflet.markercluster there\n\t\t// is a chance that a marker doesn't.\n\t\tif (!icon) {\n\t\t\treturn;\n\t\t}\n\n\t\t// This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)\n\t\ticon.style.display = 'none';\n\n\t\tif (L.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {\n\t\t\tL.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected');\n\t\t\t// Offset as the border will make the icon move.\n\t\t\tthis._offsetMarker(icon, -4);\n\n\t\t} else {\n\t\t\tL.DomUtil.addClass(icon, 'leaflet-edit-marker-selected');\n\t\t\t// Offset as the border will make the icon move.\n\t\t\tthis._offsetMarker(icon, 4);\n\t\t}\n\n\t\ticon.style.display = '';\n\t},\n\n\t_offsetMarker: function (icon, offset) {\n\t\tvar iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,\n\t\t\ticonMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;\n\n\t\ticon.style.marginTop = iconMarginTop + 'px';\n\t\ticon.style.marginLeft = iconMarginLeft + 'px';\n\t}\n});\n\nL.Marker.addInitHook(function () {\n\tif (L.Edit.Marker) {\n\t\tthis.editing = new L.Edit.Marker(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n\n/**\n * @class L.Edit.Polyline\n * @aka L.Edit.Poly\n * @aka Edit.Poly\n */\nL.Edit.Poly = L.Handler.extend({\n\t// @method initialize(): void\n\tinitialize: function (poly) {\n\n\t\tthis.latlngs = [poly._latlngs];\n\t\tif (poly._holes) {\n\t\t\tthis.latlngs = this.latlngs.concat(poly._holes);\n\t\t}\n\n\t\tthis._poly = poly;\n\n\t\tthis._poly.on('revert-edited', this._updateLatLngs, this);\n\t},\n\n\t// Compatibility method to normalize Poly* objects\n\t// between 0.7.x and 1.0+\n\t_defaultShape: function () {\n\t\tif (!L.Polyline._flat) {\n\t\t\treturn this._poly._latlngs;\n\t\t}\n\t\treturn L.Polyline._flat(this._poly._latlngs) ? this._poly._latlngs : this._poly._latlngs[0];\n\t},\n\n\t_eachVertexHandler: function (callback) {\n\t\tfor (var i = 0; i < this._verticesHandlers.length; i++) {\n\t\t\tcallback(this._verticesHandlers[i]);\n\t\t}\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tthis._initHandlers();\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.addHooks();\n\t\t});\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.removeHooks();\n\t\t});\n\t},\n\n\t// @method updateMarkers(): void\n\t// Fire an update for each vertex handler\n\tupdateMarkers: function () {\n\t\tthis._eachVertexHandler(function (handler) {\n\t\t\thandler.updateMarkers();\n\t\t});\n\t},\n\n\t_initHandlers: function () {\n\t\tthis._verticesHandlers = [];\n\t\tfor (var i = 0; i < this.latlngs.length; i++) {\n\t\t\tthis._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly, this.latlngs[i], this._poly.options.poly));\n\t\t}\n\t},\n\n\t_updateLatLngs: function (e) {\n\t\tthis.latlngs = [e.layer._latlngs];\n\t\tif (e.layer._holes) {\n\t\t\tthis.latlngs = this.latlngs.concat(e.layer._holes);\n\t\t}\n\t}\n\n});\n\n/**\n * @class L.Edit.PolyVerticesEdit\n * @aka Edit.PolyVerticesEdit\n */\nL.Edit.PolyVerticesEdit = L.Handler.extend({\n\toptions: {\n\t\ticon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\n\t\t}),\n\t\ttouchIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n\t\t}),\n\t\tdrawError: {\n\t\t\tcolor: '#b00b00',\n\t\t\ttimeout: 1000\n\t\t}\n\n\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (poly, latlngs, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.icon = this.options.touchIcon;\n\t\t}\n\t\tthis._poly = poly;\n\n\t\tif (options && options.drawError) {\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n\t\t}\n\n\t\tthis._latlngs = latlngs;\n\n\t\tL.setOptions(this, options);\n\t},\n\n\t// Compatibility method to normalize Poly* objects\n\t// between 0.7.x and 1.0+\n\t_defaultShape: function () {\n\t\tif (!L.Polyline._flat) {\n\t\t\treturn this._latlngs;\n\t\t}\n\t\treturn L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler.\n\taddHooks: function () {\n\t\tvar poly = this._poly;\n\t\tvar path = poly._path;\n\n\t\tif (!(poly instanceof L.Polygon)) {\n\t\t\tpoly.options.fill = false;\n\t\t\tif (poly.options.editing) {\n\t\t\t\tpoly.options.editing.fill = false;\n\t\t\t}\n\t\t}\n\n\t\tif (path) {\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\n\t\t\t\tif (poly.options.original.className) {\n\t\t\t\t\tpoly.options.original.className.split(' ').forEach(function (className) {\n\t\t\t\t\t\tL.DomUtil.removeClass(path, className);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tpoly.options.editing.className.split(' ').forEach(function (className) {\n\t\t\t\t\tL.DomUtil.addClass(path, className);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tpoly.setStyle(poly.options.editing);\n\n\t\tif (this._poly._map) {\n\n\t\t\tthis._map = this._poly._map; // Set map\n\n\t\t\tif (!this._markerGroup) {\n\t\t\t\tthis._initMarkers();\n\t\t\t}\n\t\t\tthis._poly._map.addLayer(this._markerGroup);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler.\n\tremoveHooks: function () {\n\t\tvar poly = this._poly;\n\t\tvar path = poly._path;\n\n\t\tif (path) {\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\n\t\t\t\tpoly.options.editing.className.split(' ').forEach(function (className) {\n\t\t\t\t\tL.DomUtil.removeClass(path, className);\n\t\t\t\t});\n\t\t\t\tif (poly.options.original.className) {\n\t\t\t\t\tpoly.options.original.className.split(' ').forEach(function (className) {\n\t\t\t\t\t\tL.DomUtil.addClass(path, className);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpoly.setStyle(poly.options.original);\n\n\t\tif (poly._map) {\n\t\t\tpoly._map.removeLayer(this._markerGroup);\n\t\t\tdelete this._markerGroup;\n\t\t\tdelete this._markers;\n\t\t}\n\t},\n\n\t// @method updateMarkers(): void\n\t// Clear markers and update their location\n\tupdateMarkers: function () {\n\t\tthis._markerGroup.clearLayers();\n\t\tthis._initMarkers();\n\t},\n\n\t_initMarkers: function () {\n\t\tif (!this._markerGroup) {\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t}\n\t\tthis._markers = [];\n\n\t\tvar latlngs = this._defaultShape(),\n\t\t\ti, j, len, marker;\n\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\n\n\t\t\tmarker = this._createMarker(latlngs[i], i);\n\t\t\tmarker.on('click', this._onMarkerClick, this);\n\t\t\tmarker.on('contextmenu', this._onContextMenu, this);\n\t\t\tthis._markers.push(marker);\n\t\t}\n\n\t\tvar markerLeft, markerRight;\n\n\t\tfor (i = 0, j = len - 1; i < len; j = i++) {\n\t\t\tif (i === 0 && !(L.Polygon && (this._poly instanceof L.Polygon))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmarkerLeft = this._markers[j];\n\t\t\tmarkerRight = this._markers[i];\n\n\t\t\tthis._createMiddleMarker(markerLeft, markerRight);\n\t\t\tthis._updatePrevNext(markerLeft, markerRight);\n\t\t}\n\t},\n\n\t_createMarker: function (latlng, index) {\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\n\t\tvar marker = new L.Marker.Touch(latlng, {\n\t\t\tdraggable: true,\n\t\t\ticon: this.options.icon,\n\t\t});\n\n\t\tmarker._origLatLng = latlng;\n\t\tmarker._index = index;\n\n\t\tmarker\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\n\t\t\t.on('drag', this._onMarkerDrag, this)\n\t\t\t.on('dragend', this._fireEdit, this)\n\t\t\t.on('touchmove', this._onTouchMove, this)\n\t\t\t.on('touchend', this._fireEdit, this)\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\n\t\t\t.on('MSPointerUp', this._fireEdit, this);\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_onMarkerDragStart: function () {\n\t\tthis._poly.fire('editstart');\n\t},\n\n\t_spliceLatLngs: function () {\n\t\tvar latlngs = this._defaultShape();\n\t\tvar removed = [].splice.apply(latlngs, arguments);\n\t\tthis._poly._convertLatLngs(latlngs, true);\n\t\tthis._poly.redraw();\n\t\treturn removed;\n\t},\n\n\t_removeMarker: function (marker) {\n\t\tvar i = marker._index;\n\n\t\tthis._markerGroup.removeLayer(marker);\n\t\tthis._markers.splice(i, 1);\n\t\tthis._spliceLatLngs(i, 1);\n\t\tthis._updateIndexes(i, -1);\n\n\t\tmarker\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\n\t\t\t.off('drag', this._onMarkerDrag, this)\n\t\t\t.off('dragend', this._fireEdit, this)\n\t\t\t.off('touchmove', this._onMarkerDrag, this)\n\t\t\t.off('touchend', this._fireEdit, this)\n\t\t\t.off('click', this._onMarkerClick, this)\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\n\t\t\t.off('MSPointerUp', this._fireEdit, this);\n\t},\n\n\t_fireEdit: function () {\n\t\tthis._poly.edited = true;\n\t\tthis._poly.fire('edit');\n\t\tthis._poly._map.fire(L.Draw.Event.EDITVERTEX, {layers: this._markerGroup, poly: this._poly});\n\t},\n\n\t_onMarkerDrag: function (e) {\n\t\tvar marker = e.target;\n\t\tvar poly = this._poly;\n\n\t\tvar oldOrigLatLng = L.LatLngUtil.cloneLatLng(marker._origLatLng);\n\t\tL.extend(marker._origLatLng, marker._latlng);\n\t\tif (poly.options.poly) {\n\t\t\tvar tooltip = poly._map._editTooltip; // Access the tooltip\n\n\t\t\t// If we don't allow intersections and the polygon intersects\n\t\t\tif (!poly.options.poly.allowIntersection && poly.intersects()) {\n\t\t\t\tL.extend(marker._origLatLng, oldOrigLatLng);\n\t\t\t\tmarker.setLatLng(oldOrigLatLng);\n\t\t\t\tvar originalColor = poly.options.color;\n\t\t\t\tpoly.setStyle({color: this.options.drawError.color});\n\t\t\t\tif (tooltip) {\n\t\t\t\t\ttooltip.updateContent({\n\t\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.error\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Reset everything back to normal after a second\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tpoly.setStyle({color: originalColor});\n\t\t\t\t\tif (tooltip) {\n\t\t\t\t\t\ttooltip.updateContent({\n\t\t\t\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\t\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}\n\n\t\tif (marker._middleLeft) {\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n\t\t}\n\n\t\t//refresh the bounds when draging\n\t\tthis._poly._bounds._southWest = L.latLng(Infinity, Infinity);\n\t\tthis._poly._bounds._northEast = L.latLng(-Infinity, -Infinity);\n\t\tvar latlngs = this._poly.getLatLngs();\n\t\tthis._poly._convertLatLngs(latlngs, true);\n\t\tthis._poly.redraw();\n\t\tthis._poly.fire('editdrag');\n\t},\n\n\t_onMarkerClick: function (e) {\n\n\t\tvar minPoints = L.Polygon && (this._poly instanceof L.Polygon) ? 4 : 3,\n\t\t\tmarker = e.target;\n\n\t\t// If removing this point would create an invalid polyline/polygon don't remove\n\t\tif (this._defaultShape().length < minPoints) {\n\t\t\treturn;\n\t\t}\n\n\t\t// remove the marker\n\t\tthis._removeMarker(marker);\n\n\t\t// update prev/next links of adjacent markers\n\t\tthis._updatePrevNext(marker._prev, marker._next);\n\n\t\t// remove ghost markers near the removed marker\n\t\tif (marker._middleLeft) {\n\t\t\tthis._markerGroup.removeLayer(marker._middleLeft);\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tthis._markerGroup.removeLayer(marker._middleRight);\n\t\t}\n\n\t\t// create a ghost marker in place of the removed one\n\t\tif (marker._prev && marker._next) {\n\t\t\tthis._createMiddleMarker(marker._prev, marker._next);\n\n\t\t} else if (!marker._prev) {\n\t\t\tmarker._next._middleLeft = null;\n\n\t\t} else if (!marker._next) {\n\t\t\tmarker._prev._middleRight = null;\n\t\t}\n\n\t\tthis._fireEdit();\n\t},\n\n\t_onContextMenu: function (e) {\n\t\tvar marker = e.target;\n\t\tvar poly = this._poly;\n\t\tthis._poly._map.fire(L.Draw.Event.MARKERCONTEXT, {marker: marker, layers: this._markerGroup, poly: this._poly});\n\t\tL.DomEvent.stopPropagation;\n\t},\n\n\t_onTouchMove: function (e) {\n\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\n\t\t\tmarker = e.target;\n\n\t\tL.extend(marker._origLatLng, latlng);\n\n\t\tif (marker._middleLeft) {\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n\t\t}\n\t\tif (marker._middleRight) {\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n\t\t}\n\n\t\tthis._poly.redraw();\n\t\tthis.updateMarkers();\n\t},\n\n\t_updateIndexes: function (index, delta) {\n\t\tthis._markerGroup.eachLayer(function (marker) {\n\t\t\tif (marker._index > index) {\n\t\t\t\tmarker._index += delta;\n\t\t\t}\n\t\t});\n\t},\n\n\t_createMiddleMarker: function (marker1, marker2) {\n\t\tvar latlng = this._getMiddleLatLng(marker1, marker2),\n\t\t\tmarker = this._createMarker(latlng),\n\t\t\tonClick,\n\t\t\tonDragStart,\n\t\t\tonDragEnd;\n\n\t\tmarker.setOpacity(0.6);\n\n\t\tmarker1._middleRight = marker2._middleLeft = marker;\n\n\t\tonDragStart = function () {\n\t\t\tmarker.off('touchmove', onDragStart, this);\n\t\t\tvar i = marker2._index;\n\n\t\t\tmarker._index = i;\n\n\t\t\tmarker\n\t\t\t\t.off('click', onClick, this)\n\t\t\t\t.on('click', this._onMarkerClick, this);\n\n\t\t\tlatlng.lat = marker.getLatLng().lat;\n\t\t\tlatlng.lng = marker.getLatLng().lng;\n\t\t\tthis._spliceLatLngs(i, 0, latlng);\n\t\t\tthis._markers.splice(i, 0, marker);\n\n\t\t\tmarker.setOpacity(1);\n\n\t\t\tthis._updateIndexes(i, 1);\n\t\t\tmarker2._index++;\n\t\t\tthis._updatePrevNext(marker1, marker);\n\t\t\tthis._updatePrevNext(marker, marker2);\n\n\t\t\tthis._poly.fire('editstart');\n\t\t};\n\n\t\tonDragEnd = function () {\n\t\t\tmarker.off('dragstart', onDragStart, this);\n\t\t\tmarker.off('dragend', onDragEnd, this);\n\t\t\tmarker.off('touchmove', onDragStart, this);\n\n\t\t\tthis._createMiddleMarker(marker1, marker);\n\t\t\tthis._createMiddleMarker(marker, marker2);\n\t\t};\n\n\t\tonClick = function () {\n\t\t\tonDragStart.call(this);\n\t\t\tonDragEnd.call(this);\n\t\t\tthis._fireEdit();\n\t\t};\n\n\t\tmarker\n\t\t\t.on('click', onClick, this)\n\t\t\t.on('dragstart', onDragStart, this)\n\t\t\t.on('dragend', onDragEnd, this)\n\t\t\t.on('touchmove', onDragStart, this);\n\n\t\tthis._markerGroup.addLayer(marker);\n\t},\n\n\t_updatePrevNext: function (marker1, marker2) {\n\t\tif (marker1) {\n\t\t\tmarker1._next = marker2;\n\t\t}\n\t\tif (marker2) {\n\t\t\tmarker2._prev = marker1;\n\t\t}\n\t},\n\n\t_getMiddleLatLng: function (marker1, marker2) {\n\t\tvar map = this._poly._map,\n\t\t\tp1 = map.project(marker1.getLatLng()),\n\t\t\tp2 = map.project(marker2.getLatLng());\n\n\t\treturn map.unproject(p1._add(p2)._divideBy(2));\n\t}\n});\n\nL.Polyline.addInitHook(function () {\n\n\t// Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit\n\tif (this.editing) {\n\t\treturn;\n\t}\n\n\tif (L.Edit.Poly) {\n\n\t\tthis.editing = new L.Edit.Poly(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n\n\tthis.on('add', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.addHooks();\n\t\t}\n\t});\n\n\tthis.on('remove', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.removeHooks();\n\t\t}\n\t});\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.SimpleShape\n * @aka Edit.SimpleShape\n */\nL.Edit.SimpleShape = L.Handler.extend({\n\toptions: {\n\t\tmoveIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move'\n\t\t}),\n\t\tresizeIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(8, 8),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize'\n\t\t}),\n\t\ttouchMoveIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon'\n\t\t}),\n\t\ttouchResizeIcon: new L.DivIcon({\n\t\t\ticonSize: new L.Point(20, 20),\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon'\n\t\t}),\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (shape, options) {\n\t\t// if touch, switch to touch icon\n\t\tif (L.Browser.touch) {\n\t\t\tthis.options.moveIcon = this.options.touchMoveIcon;\n\t\t\tthis.options.resizeIcon = this.options.touchResizeIcon;\n\t\t}\n\n\t\tthis._shape = shape;\n\t\tL.Util.setOptions(this, options);\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tvar shape = this._shape;\n\t\tif (this._shape._map) {\n\t\t\tthis._map = this._shape._map;\n\t\t\tshape.setStyle(shape.options.editing);\n\n\t\t\tif (shape._map) {\n\t\t\t\tthis._map = shape._map;\n\t\t\t\tif (!this._markerGroup) {\n\t\t\t\t\tthis._initMarkers();\n\t\t\t\t}\n\t\t\t\tthis._map.addLayer(this._markerGroup);\n\t\t\t}\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tvar shape = this._shape;\n\n\t\tshape.setStyle(shape.options.original);\n\n\t\tif (shape._map) {\n\t\t\tthis._unbindMarker(this._moveMarker);\n\n\t\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n\t\t\t\tthis._unbindMarker(this._resizeMarkers[i]);\n\t\t\t}\n\t\t\tthis._resizeMarkers = null;\n\n\t\t\tthis._map.removeLayer(this._markerGroup);\n\t\t\tdelete this._markerGroup;\n\t\t}\n\n\t\tthis._map = null;\n\t},\n\n\t// @method updateMarkers(): void\n\t// Remove the edit markers from this layer\n\tupdateMarkers: function () {\n\t\tthis._markerGroup.clearLayers();\n\t\tthis._initMarkers();\n\t},\n\n\t_initMarkers: function () {\n\t\tif (!this._markerGroup) {\n\t\t\tthis._markerGroup = new L.LayerGroup();\n\t\t}\n\n\t\t// Create center marker\n\t\tthis._createMoveMarker();\n\n\t\t// Create edge marker\n\t\tthis._createResizeMarker();\n\t},\n\n\t_createMoveMarker: function () {\n\t\t// Children override\n\t},\n\n\t_createResizeMarker: function () {\n\t\t// Children override\n\t},\n\n\t_createMarker: function (latlng, icon) {\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\n\t\tvar marker = new L.Marker.Touch(latlng, {\n\t\t\tdraggable: true,\n\t\t\ticon: icon,\n\t\t\tzIndexOffset: 10\n\t\t});\n\n\t\tthis._bindMarker(marker);\n\n\t\tthis._markerGroup.addLayer(marker);\n\n\t\treturn marker;\n\t},\n\n\t_bindMarker: function (marker) {\n\t\tmarker\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\n\t\t\t.on('drag', this._onMarkerDrag, this)\n\t\t\t.on('dragend', this._onMarkerDragEnd, this)\n\t\t\t.on('touchstart', this._onTouchStart, this)\n\t\t\t.on('touchmove', this._onTouchMove, this)\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\n\t\t\t.on('touchend', this._onTouchEnd, this)\n\t\t\t.on('MSPointerUp', this._onTouchEnd, this);\n\t},\n\n\t_unbindMarker: function (marker) {\n\t\tmarker\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\n\t\t\t.off('drag', this._onMarkerDrag, this)\n\t\t\t.off('dragend', this._onMarkerDragEnd, this)\n\t\t\t.off('touchstart', this._onTouchStart, this)\n\t\t\t.off('touchmove', this._onTouchMove, this)\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\n\t\t\t.off('touchend', this._onTouchEnd, this)\n\t\t\t.off('MSPointerUp', this._onTouchEnd, this);\n\t},\n\n\t_onMarkerDragStart: function (e) {\n\t\tvar marker = e.target;\n\t\tmarker.setOpacity(0);\n\n\t\tthis._shape.fire('editstart');\n\t},\n\n\t_fireEdit: function () {\n\t\tthis._shape.edited = true;\n\t\tthis._shape.fire('edit');\n\t},\n\n\t_onMarkerDrag: function (e) {\n\t\tvar marker = e.target,\n\t\t\tlatlng = marker.getLatLng();\n\n\t\tif (marker === this._moveMarker) {\n\t\t\tthis._move(latlng);\n\t\t} else {\n\t\t\tthis._resize(latlng);\n\t\t}\n\n\t\tthis._shape.redraw();\n\t\tthis._shape.fire('editdrag');\n\t},\n\n\t_onMarkerDragEnd: function (e) {\n\t\tvar marker = e.target;\n\t\tmarker.setOpacity(1);\n\n\t\tthis._fireEdit();\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\n\n\t\tif (typeof(this._getCorners) === 'function') {\n\t\t\t// Save a reference to the opposite point\n\t\t\tvar corners = this._getCorners(),\n\t\t\t\tmarker = e.target,\n\t\t\t\tcurrentCornerIndex = marker._cornerIndex;\n\n\t\t\tmarker.setOpacity(0);\n\n\t\t\t// Copyed from Edit.Rectangle.js line 23 _onMarkerDragStart()\n\t\t\t// Latlng is null otherwise.\n\t\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\n\t\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\n\t\t}\n\n\t\tthis._shape.fire('editstart');\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\n\t\t\tmarker = e.target;\n\n\t\tif (marker === this._moveMarker) {\n\t\t\tthis._move(latlng);\n\t\t} else {\n\t\t\tthis._resize(latlng);\n\t\t}\n\n\t\tthis._shape.redraw();\n\n\t\t// prevent touchcancel in IOS\n\t\t// e.preventDefault();\n\t\treturn false;\n\t},\n\n\t_onTouchEnd: function (e) {\n\t\tvar marker = e.target;\n\t\tmarker.setOpacity(1);\n\t\tthis.updateMarkers();\n\t\tthis._fireEdit();\n\t},\n\n\t_move: function () {\n\t\t// Children override\n\t},\n\n\t_resize: function () {\n\t\t// Children override\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.Rectangle\n * @aka Edit.Rectangle\n * @inherits L.Edit.SimpleShape\n */\nL.Edit.Rectangle = L.Edit.SimpleShape.extend({\n\t_createMoveMarker: function () {\n\t\tvar bounds = this._shape.getBounds(),\n\t\t\tcenter = bounds.getCenter();\n\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\n\t},\n\n\t_createResizeMarker: function () {\n\t\tvar corners = this._getCorners();\n\n\t\tthis._resizeMarkers = [];\n\n\t\tfor (var i = 0, l = corners.length; i < l; i++) {\n\t\t\tthis._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon));\n\t\t\t// Monkey in the corner index as we will need to know this for dragging\n\t\t\tthis._resizeMarkers[i]._cornerIndex = i;\n\t\t}\n\t},\n\n\t_onMarkerDragStart: function (e) {\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\n\n\t\t// Save a reference to the opposite point\n\t\tvar corners = this._getCorners(),\n\t\t\tmarker = e.target,\n\t\t\tcurrentCornerIndex = marker._cornerIndex;\n\n\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\n\n\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\n\t},\n\n\t_onMarkerDragEnd: function (e) {\n\t\tvar marker = e.target,\n\t\t\tbounds, center;\n\n\t\t// Reset move marker position to the center\n\t\tif (marker === this._moveMarker) {\n\t\t\tbounds = this._shape.getBounds();\n\t\t\tcenter = bounds.getCenter();\n\n\t\t\tmarker.setLatLng(center);\n\t\t}\n\n\t\tthis._toggleCornerMarkers(1);\n\n\t\tthis._repositionCornerMarkers();\n\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);\n\t},\n\n\t_move: function (newCenter) {\n\t\tvar latlngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(),\n\t\t\tbounds = this._shape.getBounds(),\n\t\t\tcenter = bounds.getCenter(),\n\t\t\toffset, newLatLngs = [];\n\n\t\t// Offset the latlngs to the new center\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\n\t\t\toffset = [latlngs[i].lat - center.lat, latlngs[i].lng - center.lng];\n\t\t\tnewLatLngs.push([newCenter.lat + offset[0], newCenter.lng + offset[1]]);\n\t\t}\n\n\t\tthis._shape.setLatLngs(newLatLngs);\n\n\t\t// Reposition the resize markers\n\t\tthis._repositionCornerMarkers();\n\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\n\t},\n\n\t_resize: function (latlng) {\n\t\tvar bounds;\n\n\t\t// Update the shape based on the current position of this corner and the opposite point\n\t\tthis._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner));\n\n\t\t// Reposition the move marker\n\t\tbounds = this._shape.getBounds();\n\t\tthis._moveMarker.setLatLng(bounds.getCenter());\n\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\n\t},\n\n\t_getCorners: function () {\n\t\tvar bounds = this._shape.getBounds(),\n\t\t\tnw = bounds.getNorthWest(),\n\t\t\tne = bounds.getNorthEast(),\n\t\t\tse = bounds.getSouthEast(),\n\t\t\tsw = bounds.getSouthWest();\n\n\t\treturn [nw, ne, se, sw];\n\t},\n\n\t_toggleCornerMarkers: function (opacity) {\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n\t\t\tthis._resizeMarkers[i].setOpacity(opacity);\n\t\t}\n\t},\n\n\t_repositionCornerMarkers: function () {\n\t\tvar corners = this._getCorners();\n\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n\t\t\tthis._resizeMarkers[i].setLatLng(corners[i]);\n\t\t}\n\t}\n});\n\nL.Rectangle.addInitHook(function () {\n\tif (L.Edit.Rectangle) {\n\t\tthis.editing = new L.Edit.Rectangle(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.CircleMarker\n * @aka Edit.Circle\n * @inherits L.Edit.SimpleShape\n */\nL.Edit.CircleMarker = L.Edit.SimpleShape.extend({\n\t_createMoveMarker: function () {\n\t\tvar center = this._shape.getLatLng();\n\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\n\t},\n\n\t_createResizeMarker: function () {\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\n\t\tthis._resizeMarkers = [];\n\t},\n\n\t_move: function (latlng) {\n\t\tif (this._resizeMarkers.length) {\n\t\t\tvar resizemarkerPoint = this._getResizeMarkerPoint(latlng);\n\t\t\t// Move the resize marker\n\t\t\tthis._resizeMarkers[0].setLatLng(resizemarkerPoint);\n\t\t}\n\n\t\t// Move the circle\n\t\tthis._shape.setLatLng(latlng);\n\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\n\t},\n});\n\nL.CircleMarker.addInitHook(function () {\n\tif (L.Edit.CircleMarker) {\n\t\tthis.editing = new L.Edit.CircleMarker(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n\n\tthis.on('add', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.addHooks();\n\t\t}\n\t});\n\n\tthis.on('remove', function () {\n\t\tif (this.editing && this.editing.enabled()) {\n\t\t\tthis.editing.removeHooks();\n\t\t}\n\t});\n});\n\n\n\nL.Edit = L.Edit || {};\n/**\n * @class L.Edit.Circle\n * @aka Edit.Circle\n * @inherits L.Edit.CircleMarker\n */\nL.Edit.Circle = L.Edit.CircleMarker.extend({\n\n\t_createResizeMarker: function () {\n\t\tvar center = this._shape.getLatLng(),\n\t\t\tresizemarkerPoint = this._getResizeMarkerPoint(center);\n\n\t\tthis._resizeMarkers = [];\n\t\tthis._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));\n\t},\n\n\t_getResizeMarkerPoint: function (latlng) {\n\t\t// From L.shape.getBounds()\n\t\tvar delta = this._shape._radius * Math.cos(Math.PI / 4),\n\t\t\tpoint = this._map.project(latlng);\n\t\treturn this._map.unproject([point.x + delta, point.y - delta]);\n\t},\n\n\t_resize: function (latlng) {\n\t\tvar moveLatLng = this._moveMarker.getLatLng();\n\n\t\t// Calculate the radius based on the version\n\t\tif (L.GeometryUtil.isVersion07x()) {\n\t\t\tradius = moveLatLng.distanceTo(latlng);\n\t\t} else {\n\t\t\tradius = this._map.distance(moveLatLng, latlng);\n\t\t}\n\t\tthis._shape.setRadius(radius);\n\n\t\tif (this._map.editTooltip) {\n\t\t\tthis._map._editTooltip.updateContent({\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.subtext + '<br />' + L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\t\tsubtext: L.drawLocal.draw.handlers.circle.radius + ': ' +\n\t\t\t\tL.GeometryUtil.readableDistance(radius, true, this.options.feet, this.options.nautic)\n\t\t\t});\n\t\t}\n\n\t\tthis._shape.setRadius(radius);\n\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\n\t}\n});\n\nL.Circle.addInitHook(function () {\n\tif (L.Edit.Circle) {\n\t\tthis.editing = new L.Edit.Circle(this);\n\n\t\tif (this.options.editable) {\n\t\t\tthis.editing.enable();\n\t\t}\n\t}\n});\n\n\n\nL.Map.mergeOptions({\n\ttouchExtend: true\n});\n\n/**\n * @class L.Map.TouchExtend\n * @aka TouchExtend\n */\nL.Map.TouchExtend = L.Handler.extend({\n\n\t// @method initialize(): void\n\t// Sets TouchExtend private accessor variables\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t},\n\n\t// @method addHooks(): void\n\t// Adds dom listener events to the map container\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);\n\t\tL.DomEvent.on(this._container, 'touchend', this._onTouchEnd, this);\n\t\tL.DomEvent.on(this._container, 'touchmove', this._onTouchMove, this);\n\t\tif (this._detectIE()) {\n\t\t\tL.DomEvent.on(this._container, 'MSPointerDown', this._onTouchStart, this);\n\t\t\tL.DomEvent.on(this._container, 'MSPointerUp', this._onTouchEnd, this);\n\t\t\tL.DomEvent.on(this._container, 'MSPointerMove', this._onTouchMove, this);\n\t\t\tL.DomEvent.on(this._container, 'MSPointerCancel', this._onTouchCancel, this);\n\n\t\t} else {\n\t\t\tL.DomEvent.on(this._container, 'touchcancel', this._onTouchCancel, this);\n\t\t\tL.DomEvent.on(this._container, 'touchleave', this._onTouchLeave, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Removes dom listener events from the map container\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'touchstart', this._onTouchStart, this);\n\t\tL.DomEvent.off(this._container, 'touchend', this._onTouchEnd, this);\n\t\tL.DomEvent.off(this._container, 'touchmove', this._onTouchMove, this);\n\t\tif (this._detectIE()) {\n\t\t\tL.DomEvent.off(this._container, 'MSPointerDown', this._onTouchStart, this);\n\t\t\tL.DomEvent.off(this._container, 'MSPointerUp', this._onTouchEnd, this);\n\t\t\tL.DomEvent.off(this._container, 'MSPointerMove', this._onTouchMove, this);\n\t\t\tL.DomEvent.off(this._container, 'MSPointerCancel', this._onTouchCancel, this);\n\t\t} else {\n\t\t\tL.DomEvent.off(this._container, 'touchcancel', this._onTouchCancel, this);\n\t\t\tL.DomEvent.off(this._container, 'touchleave', this._onTouchLeave, this);\n\t\t}\n\t},\n\n\t_touchEvent: function (e, type) {\n\t\t// #TODO: fix the pageX error that is do a bug in Android where a single touch triggers two click events\n\t\t// _filterClick is what leaflet uses as a workaround.\n\t\t// This is a problem with more things than just android. Another problem is touchEnd has no touches in\n\t\t// its touch list.\n\t\tvar touchEvent = {};\n\t\tif (typeof e.touches !== 'undefined') {\n\t\t\tif (!e.touches.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttouchEvent = e.touches[0];\n\t\t} else if (e.pointerType === 'touch') {\n\t\t\ttouchEvent = e;\n\t\t\tif (!this._filterClick(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tvar containerPoint = this._map.mouseEventToContainerPoint(touchEvent),\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\n\n\t\tthis._map.fire(type, {\n\t\t\tlatlng: latlng,\n\t\t\tlayerPoint: layerPoint,\n\t\t\tcontainerPoint: containerPoint,\n\t\t\tpageX: touchEvent.pageX,\n\t\t\tpageY: touchEvent.pageY,\n\t\t\toriginalEvent: e\n\t\t});\n\t},\n\n\t/** Borrowed from Leaflet and modified for bool ops **/\n\t_filterClick: function (e) {\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\n\n\t\t// are they closer together than 500ms yet more than 100ms?\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\n\t\t// on the same event should be triggered far faster;\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\n\t\t\tL.DomEvent.stop(e);\n\t\t\treturn false;\n\t\t}\n\t\tL.DomEvent._lastClick = timeStamp;\n\t\treturn true;\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchstart';\n\t\tthis._touchEvent(e, type);\n\n\t},\n\n\t_onTouchEnd: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchend';\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_onTouchCancel: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchcancel';\n\t\tif (this._detectIE()) {\n\t\t\ttype = 'pointercancel';\n\t\t}\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_onTouchLeave: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchleave';\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tif (!this._map._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = 'touchmove';\n\t\tthis._touchEvent(e, type);\n\t},\n\n\t_detectIE: function () {\n\t\tvar ua = window.navigator.userAgent;\n\n\t\tvar msie = ua.indexOf('MSIE ');\n\t\tif (msie > 0) {\n\t\t\t// IE 10 or older => return version number\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t\t}\n\n\t\tvar trident = ua.indexOf('Trident/');\n\t\tif (trident > 0) {\n\t\t\t// IE 11 => return version number\n\t\t\tvar rv = ua.indexOf('rv:');\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t\t}\n\n\t\tvar edge = ua.indexOf('Edge/');\n\t\tif (edge > 0) {\n\t\t\t// IE 12 => return version number\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t\t}\n\n\t\t// other browser\n\t\treturn false;\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchExtend', L.Map.TouchExtend);\n\n\n/**\n * @class L.Marker.Touch\n * @aka Marker.Touch\n *\n * This isn't full Touch support. This is just to get markers to also support dom touch events after creation\n * #TODO: find a better way of getting markers to support touch.\n */\nL.Marker.Touch = L.Marker.extend({\n\n\t_initInteraction: function () {\n\t\tif (!this.addInteractiveTarget) {\n\t\t\t// 0.7.x support\n\t\t\treturn this._initInteractionLegacy();\n\t\t}\n\t\t// TODO this may need be updated to re-add touch events for 1.0+\n\t\treturn L.Marker.prototype._initInteraction.apply(this);\n\t},\n\n\t// This is an exact copy of https://github.com/Leaflet/Leaflet/blob/v0.7/src/layer/marker/Marker.js\n\t// with the addition of the touch events\n\t_initInteractionLegacy: function () {\n\n\t\tif (!this.options.clickable) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\n\n\t\tvar icon = this._icon,\n\t\t\tevents = ['dblclick',\n\t\t\t\t'mousedown',\n\t\t\t\t'mouseover',\n\t\t\t\t'mouseout',\n\t\t\t\t'contextmenu',\n\t\t\t\t'touchstart',\n\t\t\t\t'touchend',\n\t\t\t\t'touchmove'];\n\t\tif (this._detectIE) {\n\t\t\tevents.concat(['MSPointerDown',\n\t\t\t\t'MSPointerUp',\n\t\t\t\t'MSPointerMove',\n\t\t\t\t'MSPointerCancel']);\n\t\t} else {\n\t\t\tevents.concat(['touchcancel']);\n\t\t}\n\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\n\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\n\t\t}\n\n\t\tif (L.Handler.MarkerDrag) {\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\n\n\t\t\tif (this.options.draggable) {\n\t\t\t\tthis.dragging.enable();\n\t\t\t}\n\t\t}\n\t},\n\n\t_detectIE: function () {\n\t\tvar ua = window.navigator.userAgent;\n\n\t\tvar msie = ua.indexOf('MSIE ');\n\t\tif (msie > 0) {\n\t\t\t// IE 10 or older => return version number\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t\t}\n\n\t\tvar trident = ua.indexOf('Trident/');\n\t\tif (trident > 0) {\n\t\t\t// IE 11 => return version number\n\t\t\tvar rv = ua.indexOf('rv:');\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t\t}\n\n\t\tvar edge = ua.indexOf('Edge/');\n\t\tif (edge > 0) {\n\t\t\t// IE 12 => return version number\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t\t}\n\n\t\t// other browser\n\t\treturn false;\n\t}\n});\n\n\n\n/**\n * @class L.LatLngUtil\n * @aka LatLngUtil\n */\nL.LatLngUtil = {\n\t// Clones a LatLngs[], returns [][]\n\n\t// @method cloneLatLngs(LatLngs[]): L.LatLngs[]\n\t// Clone the latLng point or points or nested points and return an array with those points\n\tcloneLatLngs: function (latlngs) {\n\t\tvar clone = [];\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\n\t\t\t// Check for nested array (Polyline/Polygon)\n\t\t\tif (Array.isArray(latlngs[i])) {\n\t\t\t\tclone.push(L.LatLngUtil.cloneLatLngs(latlngs[i]));\n\t\t\t} else {\n\t\t\t\tclone.push(this.cloneLatLng(latlngs[i]));\n\t\t\t}\n\t\t}\n\t\treturn clone;\n\t},\n\n\t// @method cloneLatLng(LatLng): L.LatLng\n\t// Clone the latLng and return a new LatLng object.\n\tcloneLatLng: function (latlng) {\n\t\treturn L.latLng(latlng.lat, latlng.lng);\n\t}\n};\n\n\n\n(function () {\n\n\tvar defaultPrecision = {\n\t\tkm: 2,\n\t\tha: 2,\n\t\tm: 0,\n\t\tmi: 2,\n\t\tac: 2,\n\t\tyd: 0,\n\t\tft: 0,\n\t\tnm: 2\n\t};\n\n\n\t/**\n\t * @class L.GeometryUtil\n\t * @aka GeometryUtil\n\t */\n\tL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\t\t// Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270\n\n\t\t// @method geodesicArea(): number\n\t\tgeodesicArea: function (latLngs) {\n\t\t\tvar pointsCount = latLngs.length,\n\t\t\t\tarea = 0.0,\n\t\t\t\td2r = Math.PI / 180,\n\t\t\t\tp1, p2;\n\n\t\t\tif (pointsCount > 2) {\n\t\t\t\tfor (var i = 0; i < pointsCount; i++) {\n\t\t\t\t\tp1 = latLngs[i];\n\t\t\t\t\tp2 = latLngs[(i + 1) % pointsCount];\n\t\t\t\t\tarea += ((p2.lng - p1.lng) * d2r) *\n\t\t\t\t\t\t(2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));\n\t\t\t\t}\n\t\t\t\tarea = area * 6378137.0 * 6378137.0 / 2.0;\n\t\t\t}\n\n\t\t\treturn Math.abs(area);\n\t\t},\n\n\t\t// @method formattedNumber(n, precision): string\n\t\t// Returns n in specified number format (if defined) and precision\n\t\tformattedNumber: function (n, precision) {\n\t\t\tvar formatted = parseFloat(n).toFixed(precision),\n\t\t\t\tformat = L.drawLocal.format && L.drawLocal.format.numeric,\n\t\t\t\tdelimiters = format && format.delimiters,\n\t\t\t\tthousands = delimiters && delimiters.thousands,\n\t\t\t\tdecimal = delimiters && delimiters.decimal;\n\n\t\t\tif (thousands || decimal) {\n\t\t\t\tvar splitValue = formatted.split('.');\n\t\t\t\tformatted = thousands ? splitValue[0].replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + thousands) : splitValue[0];\n\t\t\t\tdecimal = decimal || '.';\n\t\t\t\tif (splitValue.length > 1) {\n\t\t\t\t\tformatted = formatted + decimal + splitValue[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn formatted;\n\t\t},\n\n\t\t// @method readableArea(area, isMetric, precision): string\n\t\t// Returns a readable area string in yards or metric.\n\t\t// The value will be rounded as defined by the precision option object.\n\t\treadableArea: function (area, isMetric, precision) {\n\t\t\tvar areaStr,\n\t\t\t\tunits,\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\t\tif (isMetric) {\n\t\t\t\tunits = ['ha', 'm'];\n\t\t\t\ttype = typeof isMetric;\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tunits = [isMetric];\n\t\t\t\t} else if (type !== 'boolean') {\n\t\t\t\t\tunits = isMetric;\n\t\t\t\t}\n\n\t\t\t\tif (area >= 1000000 && units.indexOf('km') !== -1) {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.000001, precision['km']) + ' km²';\n\t\t\t\t} else if (area >= 10000 && units.indexOf('ha') !== -1) {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.0001, precision['ha']) + ' ha';\n\t\t\t\t} else {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['m']) + ' m²';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarea /= 0.836127; // Square yards in 1 meter\n\n\t\t\t\tif (area >= 3097600) { //3097600 square yards in 1 square mile\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 3097600, precision['mi']) + ' mi²';\n\t\t\t\t} else if (area >= 4840) { //4840 square yards in 1 acre\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 4840, precision['ac']) + ' acres';\n\t\t\t\t} else {\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['yd']) + ' yd²';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn areaStr;\n\t\t},\n\n\t\t// @method readableDistance(distance, units): string\n\t\t// Converts a metric distance to one of [ feet, nauticalMile, metric or yards ] string\n\t\t//\n\t\t// @alternative\n\t\t// @method readableDistance(distance, isMetric, useFeet, isNauticalMile, precision): string\n\t\t// Converts metric distance to distance string.\n\t\t// The value will be rounded as defined by the precision option object.\n\t\treadableDistance: function (distance, isMetric, isFeet, isNauticalMile, precision) {\n\t\t\tvar distanceStr,\n\t\t\t\tunits,\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\n\n\t\t\tif (isMetric) {\n\t\t\t\tunits = typeof isMetric == 'string' ? isMetric : 'metric';\n\t\t\t} else if (isFeet) {\n\t\t\t\tunits = 'feet';\n\t\t\t} else if (isNauticalMile) {\n\t\t\t\tunits = 'nauticalMile';\n\t\t\t} else {\n\t\t\t\tunits = 'yards';\n\t\t\t}\n\n\t\t\tswitch (units) {\n\t\t\t\tcase 'metric':\n\t\t\t\t\t// show metres when distance is < 1km, then show km\n\t\t\t\t\tif (distance > 1000) {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['km']) + ' km';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['m']) + ' m';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'feet':\n\t\t\t\t\tdistance *= 1.09361 * 3;\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['ft']) + ' ft';\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'nauticalMile':\n\t\t\t\t\tdistance *= 0.53996;\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['nm']) + ' nm';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'yards':\n\t\t\t\tdefault:\n\t\t\t\t\tdistance *= 1.09361;\n\n\t\t\t\t\tif (distance > 1760) {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1760, precision['mi']) + ' miles';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['yd']) + ' yd';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn distanceStr;\n\t\t},\n\n\t\t// @method isVersion07x(): boolean\n\t\t// Returns true if the Leaflet version is 0.7.x, false otherwise.\n\t\tisVersion07x: function () {\n\t\t\tvar version = L.version.split('.');\n\t\t\t//If Version is == 0.7.*\n\t\t\treturn parseInt(version[0], 10) === 0 && parseInt(version[1], 10) === 7;\n\t\t},\n\t});\n\n})();\n\n\n\n/**\n * @class L.LineUtil\n * @aka Util\n * @aka L.Utils\n */\nL.Util.extend(L.LineUtil, {\n\n\t// @method segmentsIntersect(): boolean\n\t// Checks to see if two line segments intersect. Does not handle degenerate cases.\n\t// http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf\n\tsegmentsIntersect: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3) {\n\t\treturn this._checkCounterclockwise(p, p2, p3) !==\n\t\t\tthis._checkCounterclockwise(p1, p2, p3) &&\n\t\t\tthis._checkCounterclockwise(p, p1, p2) !==\n\t\t\tthis._checkCounterclockwise(p, p1, p3);\n\t},\n\n\t// check to see if points are in counterclockwise order\n\t_checkCounterclockwise: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\n\t\treturn (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);\n\t}\n});\n\n\n\n/**\n * @class L.Polyline\n * @aka Polyline\n */\nL.Polyline.include({\n\n\t// @method intersects(): boolean\n\t// Check to see if this polyline has any linesegments that intersect.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tintersects: function () {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0,\n\t\t\ti, p, p1;\n\n\t\tif (this._tooFewPointsForIntersection()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = len - 1; i >= 3; i--) {\n\t\t\tp = points[i - 1];\n\t\t\tp1 = points[i];\n\n\n\t\t\tif (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// @method newLatLngIntersects(): boolean\n\t// Check for intersection if new latlng was added to this polyline.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tnewLatLngIntersects: function (latlng, skipFirst) {\n\t\t// Cannot check a polyline for intersecting lats/lngs when not added to the map\n\t\tif (!this._map) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\n\t},\n\n\t// @method newPointIntersects(): boolean\n\t// Check for intersection if new point was added to this polyline.\n\t// newPoint must be a layer point.\n\t// NOTE: does not support detecting intersection for degenerate cases.\n\tnewPointIntersects: function (newPoint, skipFirst) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0,\n\t\t\tlastPoint = points ? points[len - 1] : null,\n\t\t\t// The previous previous line segment. Previous line segment doesn't need testing.\n\t\t\tmaxIndex = len - 2;\n\n\t\tif (this._tooFewPointsForIntersection(1)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\n\t},\n\n\t// Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).\n\t// Cannot have intersection when < 3 line segments (< 4 points)\n\t_tooFewPointsForIntersection: function (extraPoints) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tlen = points ? points.length : 0;\n\t\t// Increment length by extraPoints if present\n\t\tlen += extraPoints || 0;\n\n\t\treturn !points || len <= 3;\n\t},\n\n\t// Checks a line segment intersections with any line segments before its predecessor.\n\t// Don't need to check the predecessor as will never intersect.\n\t_lineSegmentsIntersectsRange: function (p, p1, maxIndex, minIndex) {\n\t\tvar points = this._getProjectedPoints(),\n\t\t\tp2, p3;\n\n\t\tminIndex = minIndex || 0;\n\n\t\t// Check all previous line segments (beside the immediately previous) for intersections\n\t\tfor (var j = maxIndex; j > minIndex; j--) {\n\t\t\tp2 = points[j - 1];\n\t\t\tp3 = points[j];\n\n\t\t\tif (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_getProjectedPoints: function () {\n\t\tif (!this._defaultShape) {\n\t\t\treturn this._originalPoints;\n\t\t}\n\t\tvar points = [],\n\t\t\t_shape = this._defaultShape();\n\n\t\tfor (var i = 0; i < _shape.length; i++) {\n\t\t\tpoints.push(this._map.latLngToLayerPoint(_shape[i]));\n\t\t}\n\t\treturn points;\n\t}\n});\n\n\n\n/**\n * @class L.Polygon\n * @aka Polygon\n */\nL.Polygon.include({\n\n\t// @method intersects(): boolean\n\t// Checks a polygon for any intersecting line segments. Ignores holes.\n\tintersects: function () {\n\t\tvar polylineIntersects,\n\t\t\tpoints = this._getProjectedPoints(),\n\t\t\tlen, firstPoint, lastPoint, maxIndex;\n\n\t\tif (this._tooFewPointsForIntersection()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tpolylineIntersects = L.Polyline.prototype.intersects.call(this);\n\n\t\t// If already found an intersection don't need to check for any more.\n\t\tif (polylineIntersects) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlen = points.length;\n\t\tfirstPoint = points[0];\n\t\tlastPoint = points[len - 1];\n\t\tmaxIndex = len - 2;\n\n\t\t// Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);\n\t}\n});\n\n\n\n/**\n * @class L.Control.Draw\n * @aka L.Draw\n */\nL.Control.Draw = L.Control.extend({\n\n\t// Options\n\toptions: {\n\t\tposition: 'topleft',\n\t\tdraw: {},\n\t\tedit: false\n\t},\n\n\t// @method initialize(): void\n\t// Initializes draw control, toolbars from the options\n\tinitialize: function (options) {\n\t\tif (L.version < '0.7') {\n\t\t\tthrow new Error('Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/');\n\t\t}\n\n\t\tL.Control.prototype.initialize.call(this, options);\n\n\t\tvar toolbar;\n\n\t\tthis._toolbars = {};\n\n\t\t// Initialize toolbars\n\t\tif (L.DrawToolbar && this.options.draw) {\n\t\t\ttoolbar = new L.DrawToolbar(this.options.draw);\n\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE] = toolbar;\n\n\t\t\t// Listen for when toolbar is enabled\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE].on('enable', this._toolbarEnabled, this);\n\t\t}\n\n\t\tif (L.EditToolbar && this.options.edit) {\n\t\t\ttoolbar = new L.EditToolbar(this.options.edit);\n\n\t\t\tthis._toolbars[L.EditToolbar.TYPE] = toolbar;\n\n\t\t\t// Listen for when toolbar is enabled\n\t\t\tthis._toolbars[L.EditToolbar.TYPE].on('enable', this._toolbarEnabled, this);\n\t\t}\n\t\tL.toolbar = this; //set global var for editing the toolbar\n\t},\n\n\t// @method onAdd(): container\n\t// Adds the toolbar container to the map\n\tonAdd: function (map) {\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw'),\n\t\t\taddedTopClass = false,\n\t\t\ttopClassName = 'leaflet-draw-toolbar-top',\n\t\t\ttoolbarContainer;\n\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\n\t\t\t\ttoolbarContainer = this._toolbars[toolbarId].addToolbar(map);\n\n\t\t\t\tif (toolbarContainer) {\n\t\t\t\t\t// Add class to the first toolbar to remove the margin\n\t\t\t\t\tif (!addedTopClass) {\n\t\t\t\t\t\tif (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {\n\t\t\t\t\t\t\tL.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddedTopClass = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer.appendChild(toolbarContainer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn container;\n\t},\n\n\t// @method onRemove(): void\n\t// Removes the toolbars from the map toolbar container\n\tonRemove: function () {\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\n\t\t\t\tthis._toolbars[toolbarId].removeToolbar();\n\t\t\t}\n\t\t}\n\t},\n\n\t// @method setDrawingOptions(options): void\n\t// Sets options to all toolbar instances\n\tsetDrawingOptions: function (options) {\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars[toolbarId] instanceof L.DrawToolbar) {\n\t\t\t\tthis._toolbars[toolbarId].setOptions(options);\n\t\t\t}\n\t\t}\n\t},\n\n\t_toolbarEnabled: function (e) {\n\t\tvar enabledToolbar = e.target;\n\n\t\tfor (var toolbarId in this._toolbars) {\n\t\t\tif (this._toolbars[toolbarId] !== enabledToolbar) {\n\t\t\t\tthis._toolbars[toolbarId].disable();\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.mergeOptions({\n\tdrawControlTooltips: true,\n\tdrawControl: false\n});\n\nL.Map.addInitHook(function () {\n\tif (this.options.drawControl) {\n\t\tthis.drawControl = new L.Control.Draw();\n\t\tthis.addControl(this.drawControl);\n\t}\n});\n\n\n\n/**\n * @class L.Draw.Toolbar\n * @aka Toolbar\n *\n * The toolbar class of the API — it is used to create the ui\n * This will be depreciated\n *\n * @example\n *\n * ```js\n *    var toolbar = L.Toolbar();\n *    toolbar.addToolbar(map);\n * ```\n *\n * ### Disabling a toolbar\n *\n * If you do not want a particular toolbar in your app you can turn it off by setting the toolbar to false.\n *\n * ```js\n *      var drawControl = new L.Control.Draw({\n *          draw: false,\n *          edit: {\n *              featureGroup: editableLayers\n *          }\n *      });\n * ```\n *\n * ### Disabling a toolbar item\n *\n * If you want to turn off a particular toolbar item, set it to false. The following disables drawing polygons and\n * markers. It also turns off the ability to edit layers.\n *\n * ```js\n *      var drawControl = new L.Control.Draw({\n *          draw: {\n *              polygon: false,\n *              marker: false\n *          },\n *          edit: {\n *              featureGroup: editableLayers,\n *              edit: false\n *          }\n *      });\n * ```\n */\nL.Toolbar = L.Class.extend({\n\t// @section Methods for modifying the toolbar\n\n\t// @method initialize(options): void\n\t// Toolbar constructor\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\n\t\tthis._modes = {};\n\t\tthis._actionButtons = [];\n\t\tthis._activeMode = null;\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.Toolbar.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.Toolbar.include(L.Mixin.Events);\n\t\t}\n\t},\n\n\t// @method enabled(): boolean\n\t// Gets a true/false of whether the toolbar is enabled\n\tenabled: function () {\n\t\treturn this._activeMode !== null;\n\t},\n\n\t// @method disable(): void\n\t// Disables the toolbar\n\tdisable: function () {\n\t\tif (!this.enabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._activeMode.handler.disable();\n\t},\n\n\t// @method addToolbar(map): L.DomUtil\n\t// Adds the toolbar to the map and returns the toolbar dom element\n\taddToolbar: function (map) {\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw-section'),\n\t\t\tbuttonIndex = 0,\n\t\t\tbuttonClassPrefix = this._toolbarClass || '',\n\t\t\tmodeHandlers = this.getModeHandlers(map),\n\t\t\ti;\n\n\t\tthis._toolbarContainer = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');\n\t\tthis._map = map;\n\n\t\tfor (i = 0; i < modeHandlers.length; i++) {\n\t\t\tif (modeHandlers[i].enabled) {\n\t\t\t\tthis._initModeHandler(\n\t\t\t\t\tmodeHandlers[i].handler,\n\t\t\t\t\tthis._toolbarContainer,\n\t\t\t\t\tbuttonIndex++,\n\t\t\t\t\tbuttonClassPrefix,\n\t\t\t\t\tmodeHandlers[i].title\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// if no buttons were added, do not add the toolbar\n\t\tif (!buttonIndex) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Save button index of the last button, -1 as we would have ++ after the last button\n\t\tthis._lastButtonIndex = --buttonIndex;\n\n\t\t// Create empty actions part of the toolbar\n\t\tthis._actionsContainer = L.DomUtil.create('ul', 'leaflet-draw-actions');\n\n\t\t// Add draw and cancel containers to the control container\n\t\tcontainer.appendChild(this._toolbarContainer);\n\t\tcontainer.appendChild(this._actionsContainer);\n\n\t\treturn container;\n\t},\n\n\t// @method removeToolbar(): void\n\t// Removes the toolbar and drops the handler event listeners\n\tremoveToolbar: function () {\n\t\t// Dispose each handler\n\t\tfor (var handlerId in this._modes) {\n\t\t\tif (this._modes.hasOwnProperty(handlerId)) {\n\t\t\t\t// Unbind handler button\n\t\t\t\tthis._disposeButton(\n\t\t\t\t\tthis._modes[handlerId].button,\n\t\t\t\t\tthis._modes[handlerId].handler.enable,\n\t\t\t\t\tthis._modes[handlerId].handler\n\t\t\t\t);\n\n\t\t\t\t// Make sure is disabled\n\t\t\t\tthis._modes[handlerId].handler.disable();\n\n\t\t\t\t// Unbind handler\n\t\t\t\tthis._modes[handlerId].handler\n\t\t\t\t\t.off('enabled', this._handlerActivated, this)\n\t\t\t\t\t.off('disabled', this._handlerDeactivated, this);\n\t\t\t}\n\t\t}\n\t\tthis._modes = {};\n\n\t\t// Dispose the actions toolbar\n\t\tfor (var i = 0, l = this._actionButtons.length; i < l; i++) {\n\t\t\tthis._disposeButton(\n\t\t\t\tthis._actionButtons[i].button,\n\t\t\t\tthis._actionButtons[i].callback,\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\t\tthis._actionButtons = [];\n\t\tthis._actionsContainer = null;\n\t},\n\n\t_initModeHandler: function (handler, container, buttonIndex, classNamePredix, buttonTitle) {\n\t\tvar type = handler.type;\n\n\t\tthis._modes[type] = {};\n\n\t\tthis._modes[type].handler = handler;\n\n\t\tthis._modes[type].button = this._createButton({\n\t\t\ttype: type,\n\t\t\ttitle: buttonTitle,\n\t\t\tclassName: classNamePredix + '-' + type,\n\t\t\tcontainer: container,\n\t\t\tcallback: this._modes[type].handler.enable,\n\t\t\tcontext: this._modes[type].handler\n\t\t});\n\n\t\tthis._modes[type].buttonIndex = buttonIndex;\n\n\t\tthis._modes[type].handler\n\t\t\t.on('enabled', this._handlerActivated, this)\n\t\t\t.on('disabled', this._handlerDeactivated, this);\n\t},\n\n\t/* Detect iOS based on browser User Agent, based on:\n\t * http://stackoverflow.com/a/9039885 */\n\t_detectIOS: function () {\n\t\tvar iOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);\n\t\treturn iOS;\n\t},\n\n\t_createButton: function (options) {\n\n\t\tvar link = L.DomUtil.create('a', options.className || '', options.container);\n\t\t// Screen reader tag\n\t\tvar sr = L.DomUtil.create('span', 'sr-only', options.container);\n\n\t\tlink.href = '#';\n\t\tlink.appendChild(sr);\n\n\t\tif (options.title) {\n\t\t\tlink.title = options.title;\n\t\t\tsr.innerHTML = options.title;\n\t\t}\n\n\t\tif (options.text) {\n\t\t\tlink.innerHTML = options.text;\n\t\t\tsr.innerHTML = options.text;\n\t\t}\n\n\t\t/* iOS does not use click events */\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\n\n\t\tL.DomEvent\n\t\t\t.on(link, 'click', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'mousedown', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'dblclick', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'touchstart', L.DomEvent.stopPropagation)\n\t\t\t.on(link, 'click', L.DomEvent.preventDefault)\n\t\t\t.on(link, buttonEvent, options.callback, options.context);\n\n\t\treturn link;\n\t},\n\n\t_disposeButton: function (button, callback) {\n\t\t/* iOS does not use click events */\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\n\n\t\tL.DomEvent\n\t\t\t.off(button, 'click', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'mousedown', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'dblclick', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'touchstart', L.DomEvent.stopPropagation)\n\t\t\t.off(button, 'click', L.DomEvent.preventDefault)\n\t\t\t.off(button, buttonEvent, callback);\n\t},\n\n\t_handlerActivated: function (e) {\n\t\t// Disable active mode (if present)\n\t\tthis.disable();\n\n\t\t// Cache new active feature\n\t\tthis._activeMode = this._modes[e.handler];\n\n\t\tL.DomUtil.addClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n\n\t\tthis._showActionsToolbar();\n\n\t\tthis.fire('enable');\n\t},\n\n\t_handlerDeactivated: function () {\n\t\tthis._hideActionsToolbar();\n\n\t\tL.DomUtil.removeClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n\n\t\tthis._activeMode = null;\n\n\t\tthis.fire('disable');\n\t},\n\n\t_createActions: function (handler) {\n\t\tvar container = this._actionsContainer,\n\t\t\tbuttons = this.getActions(handler),\n\t\t\tl = buttons.length,\n\t\t\tli, di, dl, button;\n\n\t\t// Dispose the actions toolbar (todo: dispose only not used buttons)\n\t\tfor (di = 0, dl = this._actionButtons.length; di < dl; di++) {\n\t\t\tthis._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);\n\t\t}\n\t\tthis._actionButtons = [];\n\n\t\t// Remove all old buttons\n\t\twhile (container.firstChild) {\n\t\t\tcontainer.removeChild(container.firstChild);\n\t\t}\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif ('enabled' in buttons[i] && !buttons[i].enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tli = L.DomUtil.create('li', '', container);\n\n\t\t\tbutton = this._createButton({\n\t\t\t\ttitle: buttons[i].title,\n\t\t\t\ttext: buttons[i].text,\n\t\t\t\tcontainer: li,\n\t\t\t\tcallback: buttons[i].callback,\n\t\t\t\tcontext: buttons[i].context\n\t\t\t});\n\n\t\t\tthis._actionButtons.push({\n\t\t\t\tbutton: button,\n\t\t\t\tcallback: buttons[i].callback\n\t\t\t});\n\t\t}\n\t},\n\n\t_showActionsToolbar: function () {\n\t\tvar buttonIndex = this._activeMode.buttonIndex,\n\t\t\tlastButtonIndex = this._lastButtonIndex,\n\t\t\ttoolbarPosition = this._activeMode.button.offsetTop - 1;\n\n\t\t// Recreate action buttons on every click\n\t\tthis._createActions(this._activeMode.handler);\n\n\t\t// Correctly position the cancel button\n\t\tthis._actionsContainer.style.top = toolbarPosition + 'px';\n\n\t\tif (buttonIndex === 0) {\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-top');\n\t\t}\n\n\t\tif (buttonIndex === lastButtonIndex) {\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n\t\t}\n\n\t\tthis._actionsContainer.style.display = 'block';\n\t\tthis._map.fire(L.Draw.Event.TOOLBAROPENED);\n\t},\n\n\t_hideActionsToolbar: function () {\n\t\tthis._actionsContainer.style.display = 'none';\n\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-top');\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n\t\tthis._map.fire(L.Draw.Event.TOOLBARCLOSED);\n\t}\n});\n\n\n\nL.Draw = L.Draw || {};\n/**\n * @class L.Draw.Tooltip\n * @aka Tooltip\n *\n * The tooltip class — it is used to display the tooltip while drawing\n * This will be depreciated\n *\n * @example\n *\n * ```js\n *    var tooltip = L.Draw.Tooltip();\n * ```\n *\n */\nL.Draw.Tooltip = L.Class.extend({\n\n\t// @section Methods for modifying draw state\n\n\t// @method initialize(map): void\n\t// Tooltip constructor\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._popupPane = map._panes.popupPane;\n\t\tthis._visible = false;\n\n\t\tthis._container = map.options.drawControlTooltips ?\n\t\t\tL.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;\n\t\tthis._singleLineLabel = false;\n\n\t\tthis._map.on('mouseout', this._onMouseOut, this);\n\t},\n\n\t// @method dispose(): void\n\t// Remove Tooltip DOM and unbind events\n\tdispose: function () {\n\t\tthis._map.off('mouseout', this._onMouseOut, this);\n\n\t\tif (this._container) {\n\t\t\tthis._popupPane.removeChild(this._container);\n\t\t\tthis._container = null;\n\t\t}\n\t},\n\n\t// @method updateContent(labelText): this\n\t// Changes the tooltip text to string in function call\n\tupdateContent: function (labelText) {\n\t\tif (!this._container) {\n\t\t\treturn this;\n\t\t}\n\t\tlabelText.subtext = labelText.subtext || '';\n\n\t\t// update the vertical position (only if changed)\n\t\tif (labelText.subtext.length === 0 && !this._singleLineLabel) {\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');\n\t\t\tthis._singleLineLabel = true;\n\t\t}\n\t\telse if (labelText.subtext.length > 0 && this._singleLineLabel) {\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');\n\t\t\tthis._singleLineLabel = false;\n\t\t}\n\n\t\tthis._container.innerHTML =\n\t\t\t(labelText.subtext.length > 0 ?\n\t\t\t\t'<span class=\"leaflet-draw-tooltip-subtext\">' + labelText.subtext + '</span>' + '<br />' : '') +\n\t\t\t'<span>' + labelText.text + '</span>';\n\n\t\tif (!labelText.text && !labelText.subtext) {\n\t\t\tthis._visible = false;\n\t\t\tthis._container.style.visibility = 'hidden';\n\t\t} else {\n\t\t\tthis._visible = true;\n\t\t\tthis._container.style.visibility = 'inherit';\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t// @method updatePosition(latlng): this\n\t// Changes the location of the tooltip\n\tupdatePosition: function (latlng) {\n\t\tvar pos = this._map.latLngToLayerPoint(latlng),\n\t\t\ttooltipContainer = this._container;\n\n\t\tif (this._container) {\n\t\t\tif (this._visible) {\n\t\t\t\ttooltipContainer.style.visibility = 'inherit';\n\t\t\t}\n\t\t\tL.DomUtil.setPosition(tooltipContainer, pos);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t// @method showAsError(): this\n\t// Applies error class to tooltip\n\tshowAsError: function () {\n\t\tif (this._container) {\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');\n\t\t}\n\t\treturn this;\n\t},\n\n\t// @method removeError(): this\n\t// Removes the error class from the tooltip\n\tremoveError: function () {\n\t\tif (this._container) {\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');\n\t\t}\n\t\treturn this;\n\t},\n\n\t_onMouseOut: function () {\n\t\tif (this._container) {\n\t\t\tthis._container.style.visibility = 'hidden';\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.DrawToolbar\n * @aka Toolbar\n */\nL.DrawToolbar = L.Toolbar.extend({\n\n\tstatics: {\n\t\tTYPE: 'draw'\n\t},\n\n\toptions: {\n\t\tpolyline: {},\n\t\tpolygon: {},\n\t\trectangle: {},\n\t\tcircle: {},\n\t\tmarker: {},\n\t\tcirclemarker: {}\n\t},\n\n\t// @method initialize(): void\n\tinitialize: function (options) {\n\t\t// Ensure that the options are merged correctly since L.extend is only shallow\n\t\tfor (var type in this.options) {\n\t\t\tif (this.options.hasOwnProperty(type)) {\n\t\t\t\tif (options[type]) {\n\t\t\t\t\toptions[type] = L.extend({}, this.options[type], options[type]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._toolbarClass = 'leaflet-draw-draw';\n\t\tL.Toolbar.prototype.initialize.call(this, options);\n\t},\n\n\t// @method getModeHandlers(): object\n\t// Get mode handlers information\n\tgetModeHandlers: function (map) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: this.options.polyline,\n\t\t\t\thandler: new L.Draw.Polyline(map, this.options.polyline),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polyline\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.polygon,\n\t\t\t\thandler: new L.Draw.Polygon(map, this.options.polygon),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polygon\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.rectangle,\n\t\t\t\thandler: new L.Draw.Rectangle(map, this.options.rectangle),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.rectangle\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.circle,\n\t\t\t\thandler: new L.Draw.Circle(map, this.options.circle),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.circle\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.marker,\n\t\t\t\thandler: new L.Draw.Marker(map, this.options.marker),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.marker\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.circlemarker,\n\t\t\t\thandler: new L.Draw.CircleMarker(map, this.options.circlemarker),\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.circlemarker\n\t\t\t}\n\t\t];\n\t},\n\n\t// @method getActions(): object\n\t// Get action information\n\tgetActions: function (handler) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: handler.completeShape,\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.finish.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.finish.text,\n\t\t\t\tcallback: handler.completeShape,\n\t\t\t\tcontext: handler\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: handler.deleteLastVertex,\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.undo.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.undo.text,\n\t\t\t\tcallback: handler.deleteLastVertex,\n\t\t\t\tcontext: handler\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.actions.title,\n\t\t\t\ttext: L.drawLocal.draw.toolbar.actions.text,\n\t\t\t\tcallback: this.disable,\n\t\t\t\tcontext: this\n\t\t\t}\n\t\t];\n\t},\n\n\t// @method setOptions(): void\n\t// Sets the options to the toolbar\n\tsetOptions: function (options) {\n\t\tL.setOptions(this, options);\n\n\t\tfor (var type in this._modes) {\n\t\t\tif (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {\n\t\t\t\tthis._modes[type].handler.setOptions(options[type]);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n\n/*L.Map.mergeOptions({\n editControl: true\n });*/\n/**\n * @class L.EditToolbar\n * @aka EditToolbar\n */\nL.EditToolbar = L.Toolbar.extend({\n\tstatics: {\n\t\tTYPE: 'edit'\n\t},\n\n\toptions: {\n\t\tedit: {\n\t\t\tselectedPathOptions: {\n\t\t\t\tdashArray: '10, 10',\n\n\t\t\t\tfill: true,\n\t\t\t\tfillColor: '#fe57a1',\n\t\t\t\tfillOpacity: 0.1,\n\n\t\t\t\t// Whether to user the existing layers color\n\t\t\t\tmaintainColor: false\n\t\t\t}\n\t\t},\n\t\tremove: {},\n\t\tpoly: null,\n\t\tfeatureGroup: null /* REQUIRED! TODO: perhaps if not set then all layers on the map are selectable? */\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (options) {\n\t\t// Need to set this manually since null is an acceptable value here\n\t\tif (options.edit) {\n\t\t\tif (typeof options.edit.selectedPathOptions === 'undefined') {\n\t\t\t\toptions.edit.selectedPathOptions = this.options.edit.selectedPathOptions;\n\t\t\t}\n\t\t\toptions.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, options.edit.selectedPathOptions);\n\t\t}\n\n\t\tif (options.remove) {\n\t\t\toptions.remove = L.extend({}, this.options.remove, options.remove);\n\t\t}\n\n\t\tif (options.poly) {\n\t\t\toptions.poly = L.extend({}, this.options.poly, options.poly);\n\t\t}\n\n\t\tthis._toolbarClass = 'leaflet-draw-edit';\n\t\tL.Toolbar.prototype.initialize.call(this, options);\n\n\t\tthis._selectedFeatureCount = 0;\n\t},\n\n\t// @method getModeHandlers(): object\n\t// Get mode handlers information\n\tgetModeHandlers: function (map) {\n\t\tvar featureGroup = this.options.featureGroup;\n\t\treturn [\n\t\t\t{\n\t\t\t\tenabled: this.options.edit,\n\t\t\t\thandler: new L.EditToolbar.Edit(map, {\n\t\t\t\t\tfeatureGroup: featureGroup,\n\t\t\t\t\tselectedPathOptions: this.options.edit.selectedPathOptions,\n\t\t\t\t\tpoly: this.options.poly\n\t\t\t\t}),\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.edit\n\t\t\t},\n\t\t\t{\n\t\t\t\tenabled: this.options.remove,\n\t\t\t\thandler: new L.EditToolbar.Delete(map, {\n\t\t\t\t\tfeatureGroup: featureGroup\n\t\t\t\t}),\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.remove\n\t\t\t}\n\t\t];\n\t},\n\n\t// @method getActions(): object\n\t// Get actions information\n\tgetActions: function (handler) {\n\t\tvar actions = [\n\t\t\t{\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.save.title,\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.save.text,\n\t\t\t\tcallback: this._save,\n\t\t\t\tcontext: this\n\t\t\t},\n\t\t\t{\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.cancel.title,\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.cancel.text,\n\t\t\t\tcallback: this.disable,\n\t\t\t\tcontext: this\n\t\t\t}\n\t\t];\n\n\t\tif (handler.removeAllLayers) {\n\t\t\tactions.push({\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.clearAll.title,\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.clearAll.text,\n\t\t\t\tcallback: this._clearAllLayers,\n\t\t\t\tcontext: this\n\t\t\t});\n\t\t}\n\n\t\treturn actions;\n\t},\n\n\t// @method addToolbar(map): L.DomUtil\n\t// Adds the toolbar to the map\n\taddToolbar: function (map) {\n\t\tvar container = L.Toolbar.prototype.addToolbar.call(this, map);\n\n\t\tthis._checkDisabled();\n\n\t\tthis.options.featureGroup.on('layeradd layerremove', this._checkDisabled, this);\n\n\t\treturn container;\n\t},\n\n\t// @method removeToolbar(): void\n\t// Removes the toolbar from the map\n\tremoveToolbar: function () {\n\t\tthis.options.featureGroup.off('layeradd layerremove', this._checkDisabled, this);\n\n\t\tL.Toolbar.prototype.removeToolbar.call(this);\n\t},\n\n\t// @method disable(): void\n\t// Disables the toolbar\n\tdisable: function () {\n\t\tif (!this.enabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._activeMode.handler.revertLayers();\n\n\t\tL.Toolbar.prototype.disable.call(this);\n\t},\n\n\t_save: function () {\n\t\tthis._activeMode.handler.save();\n\t\tif (this._activeMode) {\n\t\t\tthis._activeMode.handler.disable();\n\t\t}\n\t},\n\n\t_clearAllLayers: function () {\n\t\tthis._activeMode.handler.removeAllLayers();\n\t\tif (this._activeMode) {\n\t\t\tthis._activeMode.handler.disable();\n\t\t}\n\t},\n\n\t_checkDisabled: function () {\n\t\tvar featureGroup = this.options.featureGroup,\n\t\t\thasLayers = featureGroup.getLayers().length !== 0,\n\t\t\tbutton;\n\n\t\tif (this.options.edit) {\n\t\t\tbutton = this._modes[L.EditToolbar.Edit.TYPE].button;\n\n\t\t\tif (hasLayers) {\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\n\t\t\t} else {\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\n\t\t\t}\n\n\t\t\tbutton.setAttribute(\n\t\t\t\t'title',\n\t\t\t\thasLayers ?\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.edit\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.editDisabled\n\t\t\t);\n\t\t}\n\n\t\tif (this.options.remove) {\n\t\t\tbutton = this._modes[L.EditToolbar.Delete.TYPE].button;\n\n\t\t\tif (hasLayers) {\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\n\t\t\t} else {\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\n\t\t\t}\n\n\t\t\tbutton.setAttribute(\n\t\t\t\t'title',\n\t\t\t\thasLayers ?\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.remove\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.removeDisabled\n\t\t\t);\n\t\t}\n\t}\n});\n\n\n\n/**\n * @class L.EditToolbar.Edit\n * @aka EditToolbar.Edit\n */\nL.EditToolbar.Edit = L.Handler.extend({\n\tstatics: {\n\t\tTYPE: 'edit'\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (map, options) {\n\t\tL.Handler.prototype.initialize.call(this, map);\n\n\t\tL.setOptions(this, options);\n\n\t\t// Store the selectable layer group for ease of access\n\t\tthis._featureGroup = options.featureGroup;\n\n\t\tif (!(this._featureGroup instanceof L.FeatureGroup)) {\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\n\t\t}\n\n\t\tthis._uneditedLayerProps = {};\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.EditToolbar.Edit.TYPE;\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.EditToolbar.Edit.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.EditToolbar.Edit.include(L.Mixin.Events);\n\t\t}\n\t},\n\n\t// @method enable(): void\n\t// Enable the edit toolbar\n\tenable: function () {\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('enabled', {handler: this.type});\n\t\t//this disable other handlers\n\n\t\tthis._map.fire(L.Draw.Event.EDITSTART, {handler: this.type});\n\t\t//allow drawLayer to be updated before beginning edition.\n\n\t\tL.Handler.prototype.enable.call(this);\n\t\tthis._featureGroup\n\t\t\t.on('layeradd', this._enableLayerEdit, this)\n\t\t\t.on('layerremove', this._disableLayerEdit, this);\n\t},\n\n\t// @method disable(): void\n\t// Disable the edit toolbar\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\t\tthis._featureGroup\n\t\t\t.off('layeradd', this._enableLayerEdit, this)\n\t\t\t.off('layerremove', this._disableLayerEdit, this);\n\t\tL.Handler.prototype.disable.call(this);\n\t\tthis._map.fire(L.Draw.Event.EDITSTOP, {handler: this.type});\n\t\tthis.fire('disabled', {handler: this.type});\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks for this handler\n\taddHooks: function () {\n\t\tvar map = this._map;\n\n\t\tif (map) {\n\t\t\tmap.getContainer().focus();\n\n\t\t\tthis._featureGroup.eachLayer(this._enableLayerEdit, this);\n\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\n\t\t\tthis._tooltip.updateContent({\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n\t\t\t});\n\n\t\t\t// Quickly access the tooltip to update for intersection checking\n\t\t\tmap._editTooltip = this._tooltip;\n\n\t\t\tthis._updateTooltip();\n\n\t\t\tthis._map\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\n\t\t\t\t.on('touchmove', this._onMouseMove, this)\n\t\t\t\t.on('MSPointerMove', this._onMouseMove, this)\n\t\t\t\t.on(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks for this handler\n\tremoveHooks: function () {\n\t\tif (this._map) {\n\t\t\t// Clean up selected layers.\n\t\t\tthis._featureGroup.eachLayer(this._disableLayerEdit, this);\n\n\t\t\t// Clear the backups of the original layers\n\t\t\tthis._uneditedLayerProps = {};\n\n\t\t\tthis._tooltip.dispose();\n\t\t\tthis._tooltip = null;\n\n\t\t\tthis._map\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\n\t\t\t\t.off('touchmove', this._onMouseMove, this)\n\t\t\t\t.off('MSPointerMove', this._onMouseMove, this)\n\t\t\t\t.off(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\n\t\t}\n\t},\n\n\t// @method revertLayers(): void\n\t// Revert each layer's geometry changes\n\trevertLayers: function () {\n\t\tthis._featureGroup.eachLayer(function (layer) {\n\t\t\tthis._revertLayer(layer);\n\t\t}, this);\n\t},\n\n\t// @method save(): void\n\t// Save the layer geometries\n\tsave: function () {\n\t\tvar editedLayers = new L.LayerGroup();\n\t\tthis._featureGroup.eachLayer(function (layer) {\n\t\t\tif (layer.edited) {\n\t\t\t\teditedLayers.addLayer(layer);\n\t\t\t\tlayer.edited = false;\n\t\t\t}\n\t\t});\n\t\tthis._map.fire(L.Draw.Event.EDITED, {layers: editedLayers});\n\t},\n\n\t_backupLayer: function (layer) {\n\t\tvar id = L.Util.stamp(layer);\n\n\t\tif (!this._uneditedLayerProps[id]) {\n\t\t\t// Polyline, Polygon or Rectangle\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\n\t\t\t\tthis._uneditedLayerProps[id] = {\n\t\t\t\t\tlatlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs())\n\t\t\t\t};\n\t\t\t} else if (layer instanceof L.Circle) {\n\t\t\t\tthis._uneditedLayerProps[id] = {\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng()),\n\t\t\t\t\tradius: layer.getRadius()\n\t\t\t\t};\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker\n\t\t\t\tthis._uneditedLayerProps[id] = {\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng())\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t},\n\n\t_getTooltipText: function () {\n\t\treturn ({\n\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\n\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n\t\t});\n\t},\n\n\t_updateTooltip: function () {\n\t\tthis._tooltip.updateContent(this._getTooltipText());\n\t},\n\n\t_revertLayer: function (layer) {\n\t\tvar id = L.Util.stamp(layer);\n\t\tlayer.edited = false;\n\t\tif (this._uneditedLayerProps.hasOwnProperty(id)) {\n\t\t\t// Polyline, Polygon or Rectangle\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\n\t\t\t\tlayer.setLatLngs(this._uneditedLayerProps[id].latlngs);\n\t\t\t} else if (layer instanceof L.Circle) {\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\n\t\t\t\tlayer.setRadius(this._uneditedLayerProps[id].radius);\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker or CircleMarker\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\n\t\t\t}\n\n\t\t\tlayer.fire('revert-edited', {layer: layer});\n\t\t}\n\t},\n\n\t_enableLayerEdit: function (e) {\n\t\tvar layer = e.layer || e.target || e,\n\t\t\tpathOptions, poly;\n\n\t\t// Back up this layer (if haven't before)\n\t\tthis._backupLayer(layer);\n\n\t\tif (this.options.poly) {\n\t\t\tpoly = L.Util.extend({}, this.options.poly);\n\t\t\tlayer.options.poly = poly;\n\t\t}\n\n\t\t// Set different style for editing mode\n\t\tif (this.options.selectedPathOptions) {\n\t\t\tpathOptions = L.Util.extend({}, this.options.selectedPathOptions);\n\n\t\t\t// Use the existing color of the layer\n\t\t\tif (pathOptions.maintainColor) {\n\t\t\t\tpathOptions.color = layer.options.color;\n\t\t\t\tpathOptions.fillColor = layer.options.fillColor;\n\t\t\t}\n\n\t\t\tlayer.options.original = L.extend({}, layer.options);\n\t\t\tlayer.options.editing = pathOptions;\n\n\t\t}\n\n\t\tif (layer instanceof L.Marker) {\n\t\t\tif (layer.editing) {\n\t\t\t\tlayer.editing.enable();\n\t\t\t}\n\t\t\tlayer.dragging.enable();\n\t\t\tlayer\n\t\t\t\t.on('dragend', this._onMarkerDragEnd)\n\t\t\t\t// #TODO: remove when leaflet finally fixes their draggable so it's touch friendly again.\n\t\t\t\t.on('touchmove', this._onTouchMove, this)\n\t\t\t\t.on('MSPointerMove', this._onTouchMove, this)\n\t\t\t\t.on('touchend', this._onMarkerDragEnd, this)\n\t\t\t\t.on('MSPointerUp', this._onMarkerDragEnd, this);\n\t\t} else {\n\t\t\tlayer.editing.enable();\n\t\t}\n\t},\n\n\t_disableLayerEdit: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tlayer.edited = false;\n\t\tif (layer.editing) {\n\t\t\tlayer.editing.disable();\n\t\t}\n\n\t\tdelete layer.options.editing;\n\t\tdelete layer.options.original;\n\t\t// Reset layer styles to that of before select\n\t\tif (this._selectedPathOptions) {\n\t\t\tif (layer instanceof L.Marker) {\n\t\t\t\tthis._toggleMarkerHighlight(layer);\n\t\t\t} else {\n\t\t\t\t// reset the layer style to what is was before being selected\n\t\t\t\tlayer.setStyle(layer.options.previousOptions);\n\t\t\t\t// remove the cached options for the layer object\n\t\t\t\tdelete layer.options.previousOptions;\n\t\t\t}\n\t\t}\n\n\t\tif (layer instanceof L.Marker) {\n\t\t\tlayer.dragging.disable();\n\t\t\tlayer\n\t\t\t\t.off('dragend', this._onMarkerDragEnd, this)\n\t\t\t\t.off('touchmove', this._onTouchMove, this)\n\t\t\t\t.off('MSPointerMove', this._onTouchMove, this)\n\t\t\t\t.off('touchend', this._onMarkerDragEnd, this)\n\t\t\t\t.off('MSPointerUp', this._onMarkerDragEnd, this);\n\t\t} else {\n\t\t\tlayer.editing.disable();\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tthis._tooltip.updatePosition(e.latlng);\n\t},\n\n\t_onMarkerDragEnd: function (e) {\n\t\tvar layer = e.target;\n\t\tlayer.edited = true;\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: layer});\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar touchEvent = e.originalEvent.changedTouches[0],\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\n\t\te.target.setLatLng(latlng);\n\t},\n\n\t_hasAvailableLayers: function () {\n\t\treturn this._featureGroup.getLayers().length !== 0;\n\t}\n});\n\n\n\n/**\n * @class L.EditToolbar.Delete\n * @aka EditToolbar.Delete\n */\nL.EditToolbar.Delete = L.Handler.extend({\n\tstatics: {\n\t\tTYPE: 'remove' // not delete as delete is reserved in js\n\t},\n\n\t// @method intialize(): void\n\tinitialize: function (map, options) {\n\t\tL.Handler.prototype.initialize.call(this, map);\n\n\t\tL.Util.setOptions(this, options);\n\n\t\t// Store the selectable layer group for ease of access\n\t\tthis._deletableLayers = this.options.featureGroup;\n\n\t\tif (!(this._deletableLayers instanceof L.FeatureGroup)) {\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\n\t\t}\n\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\t\tthis.type = L.EditToolbar.Delete.TYPE;\n\n\t\tvar version = L.version.split('.');\n\t\t//If Version is >= 1.2.0\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\n\t\t\tL.EditToolbar.Delete.include(L.Evented.prototype);\n\t\t} else {\n\t\t\tL.EditToolbar.Delete.include(L.Mixin.Events);\n\t\t}\n\n\t},\n\n\t// @method enable(): void\n\t// Enable the delete toolbar\n\tenable: function () {\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('enabled', {handler: this.type});\n\n\t\tthis._map.fire(L.Draw.Event.DELETESTART, {handler: this.type});\n\n\t\tL.Handler.prototype.enable.call(this);\n\n\t\tthis._deletableLayers\n\t\t\t.on('layeradd', this._enableLayerDelete, this)\n\t\t\t.on('layerremove', this._disableLayerDelete, this);\n\t},\n\n\t// @method disable(): void\n\t// Disable the delete toolbar\n\tdisable: function () {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._deletableLayers\n\t\t\t.off('layeradd', this._enableLayerDelete, this)\n\t\t\t.off('layerremove', this._disableLayerDelete, this);\n\n\t\tL.Handler.prototype.disable.call(this);\n\n\t\tthis._map.fire(L.Draw.Event.DELETESTOP, {handler: this.type});\n\n\t\tthis.fire('disabled', {handler: this.type});\n\t},\n\n\t// @method addHooks(): void\n\t// Add listener hooks to this handler\n\taddHooks: function () {\n\t\tvar map = this._map;\n\n\t\tif (map) {\n\t\t\tmap.getContainer().focus();\n\n\t\t\tthis._deletableLayers.eachLayer(this._enableLayerDelete, this);\n\t\t\tthis._deletedLayers = new L.LayerGroup();\n\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\n\t\t\tthis._tooltip.updateContent({text: L.drawLocal.edit.handlers.remove.tooltip.text});\n\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\n\t\t}\n\t},\n\n\t// @method removeHooks(): void\n\t// Remove listener hooks from this handler\n\tremoveHooks: function () {\n\t\tif (this._map) {\n\t\t\tthis._deletableLayers.eachLayer(this._disableLayerDelete, this);\n\t\t\tthis._deletedLayers = null;\n\n\t\t\tthis._tooltip.dispose();\n\t\t\tthis._tooltip = null;\n\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\n\t\t}\n\t},\n\n\t// @method revertLayers(): void\n\t// Revert the deleted layers back to their prior state.\n\trevertLayers: function () {\n\t\t// Iterate of the deleted layers and add them back into the featureGroup\n\t\tthis._deletedLayers.eachLayer(function (layer) {\n\t\t\tthis._deletableLayers.addLayer(layer);\n\t\t\tlayer.fire('revert-deleted', {layer: layer});\n\t\t}, this);\n\t},\n\n\t// @method save(): void\n\t// Save deleted layers\n\tsave: function () {\n\t\tthis._map.fire(L.Draw.Event.DELETED, {layers: this._deletedLayers});\n\t},\n\n\t// @method removeAllLayers(): void\n\t// Remove all delateable layers\n\tremoveAllLayers: function () {\n\t\t// Iterate of the delateable layers and add remove them\n\t\tthis._deletableLayers.eachLayer(function (layer) {\n\t\t\tthis._removeLayer({layer: layer});\n\t\t}, this);\n\t\tthis.save();\n\t},\n\n\t_enableLayerDelete: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tlayer.on('click', this._removeLayer, this);\n\t},\n\n\t_disableLayerDelete: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tlayer.off('click', this._removeLayer, this);\n\n\t\t// Remove from the deleted layers so we can't accidentally revert if the user presses cancel\n\t\tthis._deletedLayers.removeLayer(layer);\n\t},\n\n\t_removeLayer: function (e) {\n\t\tvar layer = e.layer || e.target || e;\n\n\t\tthis._deletableLayers.removeLayer(layer);\n\n\t\tthis._deletedLayers.addLayer(layer);\n\n\t\tlayer.fire('deleted');\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tthis._tooltip.updatePosition(e.latlng);\n\t},\n\n\t_hasAvailableLayers: function () {\n\t\treturn this._deletableLayers.getLayers().length !== 0;\n\t}\n});\n\n\n\n}(window, document));\n//# sourceMappingURL=leaflet.draw-src.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvbGVhZmxldC1kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LXNyYy5qcz82MWZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBLDZCQUE2QixFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3hELGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3hELGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFB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RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwyQ0FBMkMsMEJBQTBCO0FBQ3JFOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQzs7QUFFeEQ7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QztBQUM5RCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLDZCQUE2Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsY0FBYztBQUN2RztBQUNBO0FBQ0EsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLDZCQUE2Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixFQUFFOztBQUVGO0FBQ0EsNkRBQTZELHdCQUF3QjtBQUNyRjtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7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QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDREQUE0RDtBQUNoSDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsbUJBQW1CO0FBQzVELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsbUJBQW1CO0FBQzlELEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxtQkFBbUI7QUFDNUQsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCOztBQUVyQiwwQkFBMEI7QUFDMUI7QUFDQSxLQUFLLHlCQUF5QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGNBQWM7QUFDZCxhQUFhO0FBQ2IsZUFBZTtBQUNmLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQSxFQUFFLEVBQUU7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFD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QUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjs7QUFFM0MsNENBQTRDLG1CQUFtQjs7QUFFL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxtQkFBbUI7O0FBRTlELHlCQUF5QixtQkFBbUI7QUFDNUMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msb0RBQW9EOztBQUVwRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QyxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtZHJhdy9kaXN0L2xlYWZsZXQuZHJhdy1zcmMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIExlYWZsZXQuZHJhdyAxLjAuNCwgYSBwbHVnaW4gdGhhdCBhZGRzIGRyYXdpbmcgYW5kIGVkaXRpbmcgdG9vbHMgdG8gTGVhZmxldCBwb3dlcmVkIG1hcHMuXG4gKGMpIDIwMTItMjAxNywgSmFjb2IgVG95ZSwgSm9uIFdlc3QsIFNtYXJ0cmFrLCBMZWFmbGV0XG5cbiBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0LmRyYXdcbiBodHRwOi8vbGVhZmxldGpzLmNvbVxuICovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkgey8qKlxuICogTGVhZmxldC5kcmF3IGFzc3VtZXMgdGhhdCB5b3UgaGF2ZSBhbHJlYWR5IGluY2x1ZGVkIHRoZSBMZWFmbGV0IGxpYnJhcnkuXG4gKi9cbkwuZHJhd1ZlcnNpb24gPSBcIjEuMC40XCI7XG4vKipcbiAqIEBjbGFzcyBMLkRyYXdcbiAqIEBha2EgRHJhd1xuICpcbiAqXG4gKiBUbyBhZGQgdGhlIGRyYXcgdG9vbGJhciBzZXQgdGhlIG9wdGlvbiBkcmF3Q29udHJvbDogdHJ1ZSBpbiB0aGUgbWFwIG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAgICAgIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge2RyYXdDb250cm9sOiB0cnVlfSkuc2V0VmlldyhbNTEuNTA1LCAtMC4wOV0sIDEzKTtcbiAqXG4gKiAgICAgIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnRpbGUub3NtLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gKiAgICAgICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cDovL29zbS5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ1xuICogICAgICB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogIyMjIEFkZGluZyB0aGUgZWRpdCB0b29sYmFyXG4gKiBUbyB1c2UgdGhlIGVkaXQgdG9vbGJhciB5b3UgbXVzdCBpbml0aWFsaXNlIHRoZSBMZWFmbGV0LmRyYXcgY29udHJvbCBhbmQgbWFudWFsbHkgYWRkIGl0IHRvIHRoZSBtYXAuXG4gKlxuICogYGBganNcbiAqICAgICAgdmFyIG1hcCA9IEwubWFwKCdtYXAnKS5zZXRWaWV3KFs1MS41MDUsIC0wLjA5XSwgMTMpO1xuICpcbiAqICAgICAgTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30udGlsZS5vc20ub3JnL3t6fS97eH0ve3l9LnBuZycsIHtcbiAqICAgICAgICAgIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwOi8vb3NtLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnXG4gKiAgICAgIH0pLmFkZFRvKG1hcCk7XG4gKlxuICogICAgICAvLyBGZWF0dXJlR3JvdXAgaXMgdG8gc3RvcmUgZWRpdGFibGUgbGF5ZXJzXG4gKiAgICAgIHZhciBkcmF3bkl0ZW1zID0gbmV3IEwuRmVhdHVyZUdyb3VwKCk7XG4gKiAgICAgIG1hcC5hZGRMYXllcihkcmF3bkl0ZW1zKTtcbiAqXG4gKiAgICAgIHZhciBkcmF3Q29udHJvbCA9IG5ldyBMLkNvbnRyb2wuRHJhdyh7XG4gKiAgICAgICAgICBlZGl0OiB7XG4gKiAgICAgICAgICAgICAgZmVhdHVyZUdyb3VwOiBkcmF3bkl0ZW1zXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH0pO1xuICogICAgICBtYXAuYWRkQ29udHJvbChkcmF3Q29udHJvbCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUga2V5IGhlcmUgaXMgdGhlIGZlYXR1cmVHcm91cCBvcHRpb24uIFRoaXMgdGVsbHMgdGhlIHBsdWdpbiB3aGljaCBGZWF0dXJlR3JvdXAgY29udGFpbnMgdGhlIGxheWVycyB0aGF0XG4gKiBzaG91bGQgYmUgZWRpdGFibGUuIFRoZSBmZWF0dXJlR3JvdXAgY2FuIGNvbnRhaW4gMCBvciBtb3JlIGZlYXR1cmVzIHdpdGggZ2VvbWV0cnkgdHlwZXMgUG9pbnQsIExpbmVTdHJpbmcsIGFuZCBQb2x5Z29uLlxuICogTGVhZmxldC5kcmF3IGRvZXMgbm90IHdvcmsgd2l0aCBtdWx0aWdlb21ldHJ5IGZlYXR1cmVzIHN1Y2ggYXMgTXVsdGlQb2ludCwgTXVsdGlMaW5lU3RyaW5nLCBNdWx0aVBvbHlnb24sXG4gKiBvciBHZW9tZXRyeUNvbGxlY3Rpb24uIElmIHlvdSBuZWVkIHRvIGFkZCBtdWx0aWdlb21ldHJ5IGZlYXR1cmVzIHRvIHRoZSBkcmF3IHBsdWdpbiwgY29udmVydCB0aGVtIHRvIGFcbiAqIEZlYXR1cmVDb2xsZWN0aW9uIG9mIG5vbi1tdWx0aWdlb21ldHJpZXMgKFBvaW50cywgTGluZVN0cmluZ3MsIG9yIFBvbHlnb25zKS5cbiAqL1xuTC5EcmF3ID0ge307XG5cbi8qKlxuICogQGNsYXNzIEwuZHJhd0xvY2FsXG4gKiBAYWthIEwuZHJhd0xvY2FsXG4gKlxuICogVGhlIGNvcmUgdG9vbGJhciBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdG9vbGJhciB1aVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogICAgICB2YXIgbW9kaWZpZWREcmF3ID0gTC5kcmF3TG9jYWwuZXh0ZW5kKHtcbiAqICAgICAgICAgIGRyYXc6IHtcbiAqICAgICAgICAgICAgICB0b29sYmFyOiB7XG4gKiAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAqICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb246ICdEcmF3IGFuIGF3ZXNvbWUgcG9seWdvbidcbiAqICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgIH1cbiAqICAgICAgICAgIH1cbiAqICAgICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgZGVmYXVsdCBzdGF0ZSBmb3IgdGhlIGNvbnRyb2wgaXMgdGhlIGRyYXcgdG9vbGJhciBqdXN0IGJlbG93IHRoZSB6b29tIGNvbnRyb2wuXG4gKiAgVGhpcyB3aWxsIGFsbG93IG1hcCB1c2VycyB0byBkcmF3IHZlY3RvcnMgYW5kIG1hcmtlcnMuXG4gKiAgKipQbGVhc2Ugbm90ZSB0aGUgZWRpdCB0b29sYmFyIGlzIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQuKipcbiAqL1xuTC5kcmF3TG9jYWwgPSB7XG5cdC8vIGZvcm1hdDoge1xuXHQvLyBcdG51bWVyaWM6IHtcblx0Ly8gXHRcdGRlbGltaXRlcnM6IHtcblx0Ly8gXHRcdFx0dGhvdXNhbmRzOiAnLCcsXG5cdC8vIFx0XHRcdGRlY2ltYWw6ICcuJ1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gfSxcblx0ZHJhdzoge1xuXHRcdHRvb2xiYXI6IHtcblx0XHRcdC8vICNUT0RPOiB0aGlzIHNob3VsZCBiZSByZW9yZ2FuaXplZCB3aGVyZSBhY3Rpb25zIGFyZSBuZXN0ZWQgaW4gYWN0aW9uc1xuXHRcdFx0Ly8gZXg6IGFjdGlvbnMudW5kbyAgb3IgYWN0aW9ucy5jYW5jZWxcblx0XHRcdGFjdGlvbnM6IHtcblx0XHRcdFx0dGl0bGU6ICdDYW5jZWwgZHJhd2luZycsXG5cdFx0XHRcdHRleHQ6ICdDYW5jZWwnXG5cdFx0XHR9LFxuXHRcdFx0ZmluaXNoOiB7XG5cdFx0XHRcdHRpdGxlOiAnRmluaXNoIGRyYXdpbmcnLFxuXHRcdFx0XHR0ZXh0OiAnRmluaXNoJ1xuXHRcdFx0fSxcblx0XHRcdHVuZG86IHtcblx0XHRcdFx0dGl0bGU6ICdEZWxldGUgbGFzdCBwb2ludCBkcmF3bicsXG5cdFx0XHRcdHRleHQ6ICdEZWxldGUgbGFzdCBwb2ludCdcblx0XHRcdH0sXG5cdFx0XHRidXR0b25zOiB7XG5cdFx0XHRcdHBvbHlsaW5lOiAnRHJhdyBhIHBvbHlsaW5lJyxcblx0XHRcdFx0cG9seWdvbjogJ0RyYXcgYSBwb2x5Z29uJyxcblx0XHRcdFx0cmVjdGFuZ2xlOiAnRHJhdyBhIHJlY3RhbmdsZScsXG5cdFx0XHRcdGNpcmNsZTogJ0RyYXcgYSBjaXJjbGUnLFxuXHRcdFx0XHRtYXJrZXI6ICdEcmF3IGEgbWFya2VyJyxcblx0XHRcdFx0Y2lyY2xlbWFya2VyOiAnRHJhdyBhIGNpcmNsZW1hcmtlcidcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhbmRsZXJzOiB7XG5cdFx0XHRjaXJjbGU6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgYW5kIGRyYWcgdG8gZHJhdyBjaXJjbGUuJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyYWRpdXM6ICdSYWRpdXMnXG5cdFx0XHR9LFxuXHRcdFx0Y2lyY2xlbWFya2VyOiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHRzdGFydDogJ0NsaWNrIG1hcCB0byBwbGFjZSBjaXJjbGUgbWFya2VyLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1hcmtlcjoge1xuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0c3RhcnQ6ICdDbGljayBtYXAgdG8gcGxhY2UgbWFya2VyLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHBvbHlnb246IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgdG8gc3RhcnQgZHJhd2luZyBzaGFwZS4nLFxuXHRcdFx0XHRcdGNvbnQ6ICdDbGljayB0byBjb250aW51ZSBkcmF3aW5nIHNoYXBlLicsXG5cdFx0XHRcdFx0ZW5kOiAnQ2xpY2sgZmlyc3QgcG9pbnQgdG8gY2xvc2UgdGhpcyBzaGFwZS4nXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwb2x5bGluZToge1xuXHRcdFx0XHRlcnJvcjogJzxzdHJvbmc+RXJyb3I6PC9zdHJvbmc+IHNoYXBlIGVkZ2VzIGNhbm5vdCBjcm9zcyEnLFxuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0c3RhcnQ6ICdDbGljayB0byBzdGFydCBkcmF3aW5nIGxpbmUuJyxcblx0XHRcdFx0XHRjb250OiAnQ2xpY2sgdG8gY29udGludWUgZHJhd2luZyBsaW5lLicsXG5cdFx0XHRcdFx0ZW5kOiAnQ2xpY2sgbGFzdCBwb2ludCB0byBmaW5pc2ggbGluZS4nXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWN0YW5nbGU6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgYW5kIGRyYWcgdG8gZHJhdyByZWN0YW5nbGUuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2ltcGxlc2hhcGU6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdGVuZDogJ1JlbGVhc2UgbW91c2UgdG8gZmluaXNoIGRyYXdpbmcuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRlZGl0OiB7XG5cdFx0dG9vbGJhcjoge1xuXHRcdFx0YWN0aW9uczoge1xuXHRcdFx0XHRzYXZlOiB7XG5cdFx0XHRcdFx0dGl0bGU6ICdTYXZlIGNoYW5nZXMnLFxuXHRcdFx0XHRcdHRleHQ6ICdTYXZlJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjYW5jZWw6IHtcblx0XHRcdFx0XHR0aXRsZTogJ0NhbmNlbCBlZGl0aW5nLCBkaXNjYXJkcyBhbGwgY2hhbmdlcycsXG5cdFx0XHRcdFx0dGV4dDogJ0NhbmNlbCdcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xlYXJBbGw6IHtcblx0XHRcdFx0XHR0aXRsZTogJ0NsZWFyIGFsbCBsYXllcnMnLFxuXHRcdFx0XHRcdHRleHQ6ICdDbGVhciBBbGwnXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRidXR0b25zOiB7XG5cdFx0XHRcdGVkaXQ6ICdFZGl0IGxheWVycycsXG5cdFx0XHRcdGVkaXREaXNhYmxlZDogJ05vIGxheWVycyB0byBlZGl0Jyxcblx0XHRcdFx0cmVtb3ZlOiAnRGVsZXRlIGxheWVycycsXG5cdFx0XHRcdHJlbW92ZURpc2FibGVkOiAnTm8gbGF5ZXJzIHRvIGRlbGV0ZSdcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhbmRsZXJzOiB7XG5cdFx0XHRlZGl0OiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHR0ZXh0OiAnRHJhZyBoYW5kbGVzIG9yIG1hcmtlcnMgdG8gZWRpdCBmZWF0dXJlcy4nLFxuXHRcdFx0XHRcdHN1YnRleHQ6ICdDbGljayBjYW5jZWwgdG8gdW5kbyBjaGFuZ2VzLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbW92ZToge1xuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0dGV4dDogJ0NsaWNrIG9uIGEgZmVhdHVyZSB0byByZW1vdmUuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5cblxuLyoqXG4gKiAjIyMgRXZlbnRzXG4gKiBPbmNlIHlvdSBoYXZlIHN1Y2Nlc3NmdWxseSBhZGRlZCB0aGUgTGVhZmxldC5kcmF3IHBsdWdpbiB0byB5b3VyIG1hcCB5b3Ugd2lsbCB3YW50IHRvIHJlc3BvbmQgdG8gdGhlIGRpZmZlcmVudFxuICogYWN0aW9ucyB1c2VycyBjYW4gaW5pdGlhdGUuIFRoZSBmb2xsb3dpbmcgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkIG9uIHRoZSBtYXA6XG4gKlxuICogQGNsYXNzIEwuRHJhdy5FdmVudFxuICogQGFrYSBEcmF3LkV2ZW50XG4gKlxuICogVXNlIGBMLkRyYXcuRXZlbnQuRVZFTlROQU1FYCBjb25zdGFudHMgdG8gZW5zdXJlIGV2ZW50cyBhcmUgY29ycmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIG1hcC5vbihMLkRyYXcuRXZlbnQuQ1JFQVRFRDsgZnVuY3Rpb24gKGUpIHtcbiAqICAgIHZhciB0eXBlID0gZS5sYXllclR5cGUsXG4gKiAgICAgICAgbGF5ZXIgPSBlLmxheWVyO1xuICpcbiAqICAgIGlmICh0eXBlID09PSAnbWFya2VyJykge1xuICogICAgICAgIC8vIERvIG1hcmtlciBzcGVjaWZpYyBhY3Rpb25zXG4gKiAgICB9XG4gKlxuICogICAgLy8gRG8gd2hhdGV2ZXIgZWxzZSB5b3UgbmVlZCB0by4gKHNhdmUgdG8gZGI7IGFkZCB0byBtYXAgZXRjKVxuICogICAgbWFwLmFkZExheWVyKGxheWVyKTtcbiAqfSk7XG4gKiBgYGBcbiAqL1xuTC5EcmF3LkV2ZW50ID0ge307XG4vKipcbiAqIEBldmVudCBkcmF3OmNyZWF0ZWQ6IFBvbHlMaW5lOyBQb2x5Z29uOyBSZWN0YW5nbGU7IENpcmNsZTsgTWFya2VyIHwgU3RyaW5nXG4gKlxuICogTGF5ZXIgdGhhdCB3YXMganVzdCBjcmVhdGVkLlxuICogVGhlIHR5cGUgb2YgbGF5ZXIgdGhpcyBpcy4gT25lIG9mOiBgcG9seWxpbmVgOyBgcG9seWdvbmA7IGByZWN0YW5nbGVgOyBgY2lyY2xlYDsgYG1hcmtlcmBcbiAqIFRyaWdnZXJlZCB3aGVuIGEgbmV3IHZlY3RvciBvciBtYXJrZXIgaGFzIGJlZW4gY3JlYXRlZC5cbiAqXG4gKi9cbkwuRHJhdy5FdmVudC5DUkVBVEVEID0gJ2RyYXc6Y3JlYXRlZCc7XG5cbi8qKlxuICogQGV2ZW50IGRyYXc6ZWRpdGVkOiBMYXllckdyb3VwXG4gKlxuICogTGlzdCBvZiBhbGwgbGF5ZXJzIGp1c3QgZWRpdGVkIG9uIHRoZSBtYXAuXG4gKlxuICpcbiAqIFRyaWdnZXJlZCB3aGVuIGxheWVycyBpbiB0aGUgRmVhdHVyZUdyb3VwOyBpbml0aWFsaXNlZCB3aXRoIHRoZSBwbHVnaW47IGhhdmUgYmVlbiBlZGl0ZWQgYW5kIHNhdmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogICAgICBtYXAub24oJ2RyYXc6ZWRpdGVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgKiAgICAgICAgICB2YXIgbGF5ZXJzID0gZS5sYXllcnM7XG4gICAgICogICAgICAgICAgbGF5ZXJzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgKiAgICAgICAgICAgICAgLy9kbyB3aGF0ZXZlciB5b3Ugd2FudDsgbW9zdCBsaWtlbHkgc2F2ZSBiYWNrIHRvIGRiXG4gICAgICogICAgICAgICAgfSk7XG4gICAgICogICAgICB9KTtcbiAqIGBgYFxuICovXG5MLkRyYXcuRXZlbnQuRURJVEVEID0gJ2RyYXc6ZWRpdGVkJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkZWxldGVkOiBMYXllckdyb3VwXG4gKlxuICogTGlzdCBvZiBhbGwgbGF5ZXJzIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gbGF5ZXJzIGhhdmUgYmVlbiByZW1vdmVkIChhbmQgc2F2ZWQpIGZyb20gdGhlIEZlYXR1cmVHcm91cC5cbiAqL1xuTC5EcmF3LkV2ZW50LkRFTEVURUQgPSAnZHJhdzpkZWxldGVkJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkcmF3c3RhcnQ6IFN0cmluZ1xuICpcbiAqIFRoZSB0eXBlIG9mIGxheWVyIHRoaXMgaXMuIE9uZSBvZjpgcG9seWxpbmVgOyBgcG9seWdvbmA7IGByZWN0YW5nbGVgOyBgY2lyY2xlYDsgYG1hcmtlcmBcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBoYXMgY2hvc2VuIHRvIGRyYXcgYSBwYXJ0aWN1bGFyIHZlY3RvciBvciBtYXJrZXIuXG4gKi9cbkwuRHJhdy5FdmVudC5EUkFXU1RBUlQgPSAnZHJhdzpkcmF3c3RhcnQnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OmRyYXdzdG9wOiBTdHJpbmdcbiAqXG4gKiBUaGUgdHlwZSBvZiBsYXllciB0aGlzIGlzLiBPbmUgb2Y6IGBwb2x5bGluZWA7IGBwb2x5Z29uYDsgYHJlY3RhbmdsZWA7IGBjaXJjbGVgOyBgbWFya2VyYFxuICpcbiAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCBhIHBhcnRpY3VsYXIgdmVjdG9yIG9yIG1hcmtlci5cbiAqL1xuXG5MLkRyYXcuRXZlbnQuRFJBV1NUT1AgPSAnZHJhdzpkcmF3c3RvcCc7XG5cbi8qKlxuICogQGV2ZW50IGRyYXc6ZHJhd3ZlcnRleDogTGF5ZXJHcm91cFxuICpcbiAqIExpc3Qgb2YgYWxsIGxheWVycyBqdXN0IGJlaW5nIGFkZGVkIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiBhIHZlcnRleCBpcyBjcmVhdGVkIG9uIGEgcG9seWxpbmUgb3IgcG9seWdvbi5cbiAqL1xuTC5EcmF3LkV2ZW50LkRSQVdWRVJURVggPSAnZHJhdzpkcmF3dmVydGV4JztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzplZGl0c3RhcnQ6IFN0cmluZ1xuICpcbiAqIFRoZSB0eXBlIG9mIGVkaXQgdGhpcyBpcy4gT25lIG9mOiBgZWRpdGBcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZWRpdCBtb2RlIGJ5IGNsaWNraW5nIHRoZSBlZGl0IHRvb2wgYnV0dG9uLlxuICovXG5cbkwuRHJhdy5FdmVudC5FRElUU1RBUlQgPSAnZHJhdzplZGl0c3RhcnQnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OmVkaXRtb3ZlOiBJTGF5ZXJcbiAqXG4gKiAgTGF5ZXIgdGhhdCB3YXMganVzdCBtb3ZlZC5cbiAqXG4gKiBUcmlnZ2VyZWQgYXMgdGhlIHVzZXIgbW92ZXMgYSByZWN0YW5nbGU7IGNpcmNsZSBvciBtYXJrZXIuXG4gKi9cbkwuRHJhdy5FdmVudC5FRElUTU9WRSA9ICdkcmF3OmVkaXRtb3ZlJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzplZGl0cmVzaXplOiBJTGF5ZXJcbiAqXG4gKiBMYXllciB0aGF0IHdhcyBqdXN0IG1vdmVkLlxuICpcbiAqIFRyaWdnZXJlZCBhcyB0aGUgdXNlciByZXNpemVzIGEgcmVjdGFuZ2xlIG9yIGNpcmNsZS5cbiAqL1xuTC5EcmF3LkV2ZW50LkVESVRSRVNJWkUgPSAnZHJhdzplZGl0cmVzaXplJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzplZGl0dmVydGV4OiBMYXllckdyb3VwXG4gKlxuICogTGlzdCBvZiBhbGwgbGF5ZXJzIGp1c3QgYmVpbmcgZWRpdGVkIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiBhIHZlcnRleCBpcyBlZGl0ZWQgb24gYSBwb2x5bGluZSBvciBwb2x5Z29uLlxuICovXG5MLkRyYXcuRXZlbnQuRURJVFZFUlRFWCA9ICdkcmF3OmVkaXR2ZXJ0ZXgnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OmVkaXRzdG9wOiBTdHJpbmdcbiAqXG4gKiBUaGUgdHlwZSBvZiBlZGl0IHRoaXMgaXMuIE9uZSBvZjogYGVkaXRgXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgaGFzIGZpbnNoZWQgZWRpdGluZyAoZWRpdCBtb2RlKSBhbmQgc2F2ZXMgZWRpdHMuXG4gKi9cbkwuRHJhdy5FdmVudC5FRElUU1RPUCA9ICdkcmF3OmVkaXRzdG9wJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkZWxldGVzdGFydDogU3RyaW5nXG4gKlxuICogVGhlIHR5cGUgb2YgZWRpdCB0aGlzIGlzLiBPbmUgb2Y6IGByZW1vdmVgXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIHJlbW92ZSBtb2RlIGJ5IGNsaWNraW5nIHRoZSByZW1vdmUgdG9vbCBidXR0b24uXG4gKi9cbkwuRHJhdy5FdmVudC5ERUxFVEVTVEFSVCA9ICdkcmF3OmRlbGV0ZXN0YXJ0JztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzpkZWxldGVzdG9wOiBTdHJpbmdcbiAqXG4gKiBUaGUgdHlwZSBvZiBlZGl0IHRoaXMgaXMuIE9uZSBvZjogYHJlbW92ZWBcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBoYXMgZmluaXNoZWQgcmVtb3Zpbmcgc2hhcGVzIChyZW1vdmUgbW9kZSkgYW5kIHNhdmVzLlxuICovXG5MLkRyYXcuRXZlbnQuREVMRVRFU1RPUCA9ICdkcmF3OmRlbGV0ZXN0b3AnO1xuXG4vKipcbiAqIEBldmVudCBkcmF3OnRvb2xiYXJvcGVuZWQ6IFN0cmluZ1xuICpcbiAqIFRyaWdnZXJlZCB3aGVuIGEgdG9vbGJhciBpcyBvcGVuZWQuXG4gKi9cbkwuRHJhdy5FdmVudC5UT09MQkFST1BFTkVEID0gJ2RyYXc6dG9vbGJhcm9wZW5lZCc7XG5cbi8qKlxuICogQGV2ZW50IGRyYXc6dG9vbGJhcmNsb3NlZDogU3RyaW5nXG4gKlxuICogVHJpZ2dlcmVkIHdoZW4gYSB0b29sYmFyIGlzIGNsb3NlZC5cbiAqL1xuTC5EcmF3LkV2ZW50LlRPT0xCQVJDTE9TRUQgPSAnZHJhdzp0b29sYmFyY2xvc2VkJztcblxuLyoqXG4gKiBAZXZlbnQgZHJhdzptYXJrZXJjb250ZXh0OiBTdHJpbmdcbiAqXG4gKiBUcmlnZ2VyZWQgd2hlbiBhIG1hcmtlciBpcyByaWdodCBjbGlja2VkLlxuICovXG5MLkRyYXcuRXZlbnQuTUFSS0VSQ09OVEVYVCA9ICdkcmF3Om1hcmtlcmNvbnRleHQnO1xuXG5cbkwuRHJhdyA9IEwuRHJhdyB8fCB7fTtcblxuLyoqXG4gKiBAY2xhc3MgTC5EcmF3LkZlYXR1cmVcbiAqIEBha2EgRHJhdy5GZWF0dXJlXG4gKi9cbkwuRHJhdy5GZWF0dXJlID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9vdmVybGF5UGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fcG9wdXBQYW5lID0gbWFwLl9wYW5lcy5wb3B1cFBhbmU7XG5cblx0XHQvLyBNZXJnZSBkZWZhdWx0IHNoYXBlT3B0aW9ucyBvcHRpb25zIHdpdGggY3VzdG9tIHNoYXBlT3B0aW9uc1xuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2hhcGVPcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zLnNoYXBlT3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMsIG9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblx0XHR9XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0dmFyIHZlcnNpb24gPSBMLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHQvL0lmIFZlcnNpb24gaXMgPj0gMS4yLjBcblx0XHRpZiAocGFyc2VJbnQodmVyc2lvblswXSwgMTApID09PSAxICYmIHBhcnNlSW50KHZlcnNpb25bMV0sIDEwKSA+PSAyKSB7XG5cdFx0XHRMLkRyYXcuRmVhdHVyZS5pbmNsdWRlKEwuRXZlbnRlZC5wcm90b3R5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRyYXcuRmVhdHVyZS5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdm9pZFxuXHQvLyBFbmFibGVzIHRoaXMgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLmZpcmUoJ2VuYWJsZWQnLCB7aGFuZGxlcjogdGhpcy50eXBlfSk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRFJBV1NUQVJULCB7bGF5ZXJUeXBlOiB0aGlzLnR5cGV9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdm9pZFxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRFJBV1NUT1AsIHtsYXllclR5cGU6IHRoaXMudHlwZX0pO1xuXG5cdFx0dGhpcy5maXJlKCdkaXNhYmxlZCcsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkJ3MgZXZlbnQgbGlzdGVuZXJzIHRvIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblxuXHRcdFx0bWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XG5cblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgTC5EcmF3LlRvb2x0aXAodGhpcy5fbWFwKTtcblxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdrZXl1cCcsIHRoaXMuX2NhbmNlbERyYXdpbmcsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKCk6IHZvaWRcblx0Ly8gUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdrZXl1cCcsIHRoaXMuX2NhbmNlbERyYXdpbmcsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wdGlvbnMob2JqZWN0KTogdm9pZFxuXHQvLyBTZXRzIG5ldyBvcHRpb25zIHRvIHRoaXMgaGFuZGxlclxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRfZmlyZUNyZWF0ZWRFdmVudDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkNSRUFURUQsIHtsYXllcjogbGF5ZXIsIGxheWVyVHlwZTogdGhpcy50eXBlfSk7XG5cdH0sXG5cblx0Ly8gQ2FuY2VsIGRyYXdpbmcgd2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkXG5cdF9jYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnZHJhdzpjYW5jZWxlZCcsIHtsYXllclR5cGU6IHRoaXMudHlwZX0pO1xuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRHJhdy5Qb2x5bGluZVxuICogQGFrYSBEcmF3LlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgTC5EcmF3LkZlYXR1cmVcbiAqL1xuTC5EcmF3LlBvbHlsaW5lID0gTC5EcmF3LkZlYXR1cmUuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdwb2x5bGluZSdcblx0fSxcblxuXHRQb2x5OiBMLlBvbHlsaW5lLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRhbGxvd0ludGVyc2VjdGlvbjogdHJ1ZSxcblx0XHRyZXBlYXRNb2RlOiBmYWxzZSxcblx0XHRkcmF3RXJyb3I6IHtcblx0XHRcdGNvbG9yOiAnI2IwMGIwMCcsXG5cdFx0XHR0aW1lb3V0OiAyNTAwXG5cdFx0fSxcblx0XHRpY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24nXG5cdFx0fSksXG5cdFx0dG91Y2hJY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApLFxuXHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LXRvdWNoLWljb24nXG5cdFx0fSksXG5cdFx0Z3VpZGVsaW5lRGlzdGFuY2U6IDIwLFxuXHRcdG1heEd1aWRlTGluZUxlbmd0aDogNDAwMCxcblx0XHRzaGFwZU9wdGlvbnM6IHtcblx0XHRcdHN0cm9rZTogdHJ1ZSxcblx0XHRcdGNvbG9yOiAnIzMzODhmZicsXG5cdFx0XHR3ZWlnaHQ6IDQsXG5cdFx0XHRvcGFjaXR5OiAwLjUsXG5cdFx0XHRmaWxsOiBmYWxzZSxcblx0XHRcdGNsaWNrYWJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0bWV0cmljOiB0cnVlLCAvLyBXaGV0aGVyIHRvIHVzZSB0aGUgbWV0cmljIG1lYXN1cmVtZW50IHN5c3RlbSBvciBpbXBlcmlhbFxuXHRcdGZlZXQ6IHRydWUsIC8vIFdoZW4gbm90IG1ldHJpYywgdG8gdXNlIGZlZXQgaW5zdGVhZCBvZiB5YXJkcyBmb3IgZGlzcGxheS5cblx0XHRuYXV0aWM6IGZhbHNlLCAvLyBXaGVuIG5vdCBtZXRyaWMsIG5vdCBmZWV0IHVzZSBuYXV0aWMgbWlsZSBmb3IgZGlzcGxheVxuXHRcdHNob3dMZW5ndGg6IHRydWUsIC8vIFdoZXRoZXIgdG8gZGlzcGxheSBkaXN0YW5jZSBpbiB0aGUgdG9vbHRpcFxuXHRcdHpJbmRleE9mZnNldDogMjAwMCwgLy8gVGhpcyBzaG91bGQgYmUgPiB0aGFuIHRoZSBoaWdoZXN0IHotaW5kZXggYW55IG1hcCBsYXllcnNcblx0XHRmYWN0b3I6IDEsIC8vIFRvIGNoYW5nZSBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXHRcdG1heFBvaW50czogMCAvLyBPbmNlIHRoaXMgbnVtYmVyIG9mIHBvaW50cyBhcmUgcGxhY2VkLCBmaW5pc2ggc2hhcGVcblx0fSxcblxuXHQvLyBAbWV0aG9kIGluaXRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0Ly8gaWYgdG91Y2gsIHN3aXRjaCB0byB0b3VjaCBpY29uXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0dGhpcy5vcHRpb25zLmljb24gPSB0aGlzLm9wdGlvbnMudG91Y2hJY29uO1xuXHRcdH1cblxuXHRcdC8vIE5lZWQgdG8gc2V0IHRoaXMgaGVyZSB0byBlbnN1cmUgdGhlIGNvcnJlY3QgbWVzc2FnZSBpcyB1c2VkLlxuXHRcdHRoaXMub3B0aW9ucy5kcmF3RXJyb3IubWVzc2FnZSA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMucG9seWxpbmUuZXJyb3I7XG5cblx0XHQvLyBNZXJnZSBkZWZhdWx0IGRyYXdFcnJvciBvcHRpb25zIHdpdGggY3VzdG9tIG9wdGlvbnNcblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRyYXdFcnJvcikge1xuXHRcdFx0b3B0aW9ucy5kcmF3RXJyb3IgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLCBvcHRpb25zLmRyYXdFcnJvcik7XG5cdFx0fVxuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkRyYXcuUG9seWxpbmUuVFlQRTtcblxuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkIGxpc3RlbmVyIGhvb2tzIHRvIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5hZGRIb29rcy5jYWxsKHRoaXMpO1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcmtlcnMgPSBbXTtcblxuXHRcdFx0dGhpcy5fbWFya2VyR3JvdXAgPSBuZXcgTC5MYXllckdyb3VwKCk7XG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApO1xuXG5cdFx0XHR0aGlzLl9wb2x5ID0gbmV3IEwuUG9seWxpbmUoW10sIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQodGhpcy5fZ2V0VG9vbHRpcFRleHQoKSk7XG5cblx0XHRcdC8vIE1ha2UgYSB0cmFuc3BhcmVudCBtYXJrZXIgdGhhdCB3aWxsIHVzZWQgdG8gY2F0Y2ggY2xpY2sgZXZlbnRzLiBUaGVzZSBjbGlja1xuXHRcdFx0Ly8gZXZlbnRzIHdpbGwgY3JlYXRlIHRoZSB2ZXJ0aWNlcy4gV2UgbmVlZCB0byBkbyB0aGlzIHNvIHdlIGNhbiBlbnN1cmUgdGhhdFxuXHRcdFx0Ly8gd2UgY2FuIGNyZWF0ZSB2ZXJ0aWNlcyBvdmVyIG90aGVyIG1hcCBsYXllcnMgKG1hcmtlcnMsIHZlY3RvciBsYXllcnMpLiBXZVxuXHRcdFx0Ly8gYWxzbyBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIGFueSBjbGljayBoYW5kbGVycyBvZiBvYmplY3RzIHdlIGFyZSBjbGlja2luZyBvblxuXHRcdFx0Ly8gd2hpbGUgZHJhd2luZy5cblx0XHRcdGlmICghdGhpcy5fbW91c2VNYXJrZXIpIHtcblx0XHRcdFx0dGhpcy5fbW91c2VNYXJrZXIgPSBMLm1hcmtlcih0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHtcblx0XHRcdFx0XHRpY29uOiBMLmRpdkljb24oe1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1tb3VzZS1tYXJrZXInLFxuXHRcdFx0XHRcdFx0aWNvbkFuY2hvcjogWzIwLCAyMF0sXG5cdFx0XHRcdFx0XHRpY29uU2l6ZTogWzQwLCA0MF1cblx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbW91c2VNYXJrZXJcblx0XHRcdFx0Lm9uKCdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQsIHRoaXMpXG5cdFx0XHRcdC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpIC8vIE5lY2Vzc2FyeSB0byBwcmV2ZW50IDAuOCBzdHV0dGVyXG5cdFx0XHRcdC5vbignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHRcdC5vbignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcykgLy8gTmVjZXNzYXJ5IGZvciAwLjggY29tcGF0aWJpbGl0eVxuXHRcdFx0XHQuYWRkVG8odGhpcy5fbWFwKTtcblxuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcykgLy8gTmVjZXNzYXJ5IGZvciAwLjcgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHQub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ3pvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpXG5cdFx0XHRcdC5vbigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gsIHRoaXMpXG5cdFx0XHRcdC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmcm9tIHRoaXMgaGFuZGxlci5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUucmVtb3ZlSG9va3MuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2NsZWFySGlkZUVycm9yVGltZW91dCgpO1xuXG5cdFx0dGhpcy5fY2xlYW5VcFNoYXBlKCk7XG5cblx0XHQvLyByZW1vdmUgbWFya2VycyBmcm9tIG1hcFxuXHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9tYXJrZXJHcm91cCk7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcmtlckdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXJzO1xuXG5cdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3BvbHkpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wb2x5O1xuXG5cdFx0dGhpcy5fbW91c2VNYXJrZXJcblx0XHRcdC5vZmYoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0Lm9mZignbW91c2VvdXQnLCB0aGlzLl9vbk1vdXNlT3V0LCB0aGlzKVxuXHRcdFx0Lm9mZignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcylcblx0XHRcdC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbW91c2VNYXJrZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9tb3VzZU1hcmtlcjtcblxuXHRcdC8vIGNsZWFuIHVwIERPTVxuXHRcdHRoaXMuX2NsZWFyR3VpZGVzKCk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5vZmYoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIHRoaXMpXG5cdFx0XHQub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdC5vZmYoJ3pvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpXG5cdFx0XHQub2ZmKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKVxuXHRcdFx0Lm9mZigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gsIHRoaXMpXG5cdFx0XHQub2ZmKCdjbGljaycsIHRoaXMuX29uVG91Y2gsIHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGVsZXRlTGFzdFZlcnRleCgpOiB2b2lkXG5cdC8vIFJlbW92ZSB0aGUgbGFzdCB2ZXJ0ZXggZnJvbSB0aGUgcG9seWxpbmUsIHJlbW92ZXMgcG9seWxpbmUgZnJvbSBtYXAgaWYgb25seSBvbmUgcG9pbnQgZXhpc3RzLlxuXHRkZWxldGVMYXN0VmVydGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoIDw9IDEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGFzdE1hcmtlciA9IHRoaXMuX21hcmtlcnMucG9wKCksXG5cdFx0XHRwb2x5ID0gdGhpcy5fcG9seSxcblx0XHRcdC8vIFJlcGxhY2VzIC5zcGxpY2VMYXRMbmdzKClcblx0XHRcdGxhdGxuZ3MgPSBwb2x5LmdldExhdExuZ3MoKSxcblx0XHRcdGxhdGxuZyA9IGxhdGxuZ3Muc3BsaWNlKC0xLCAxKVswXTtcblx0XHR0aGlzLl9wb2x5LnNldExhdExuZ3MobGF0bG5ncyk7XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihsYXN0TWFya2VyKTtcblxuXHRcdGlmIChwb2x5LmdldExhdExuZ3MoKS5sZW5ndGggPCAyKSB7XG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocG9seSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmVydGV4Q2hhbmdlZChsYXRsbmcsIGZhbHNlKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZFZlcnRleCgpOiB2b2lkXG5cdC8vIEFkZCBhIHZlcnRleCB0byB0aGUgZW5kIG9mIHRoZSBwb2x5bGluZVxuXHRhZGRWZXJ0ZXg6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgbWFya2Vyc0xlbmd0aCA9IHRoaXMuX21hcmtlcnMubGVuZ3RoO1xuXHRcdC8vIG1hcmtlcnNMZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMiBiZWZvcmUgaW50ZXJzZWN0aW9ucyBjYW4gb2NjdXJcblx0XHRpZiAobWFya2Vyc0xlbmd0aCA+PSAyICYmICF0aGlzLm9wdGlvbnMuYWxsb3dJbnRlcnNlY3Rpb24gJiYgdGhpcy5fcG9seS5uZXdMYXRMbmdJbnRlcnNlY3RzKGxhdGxuZykpIHtcblx0XHRcdHRoaXMuX3Nob3dFcnJvclRvb2x0aXAoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5fZXJyb3JTaG93bikge1xuXHRcdFx0dGhpcy5faGlkZUVycm9yVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcmtlcnMucHVzaCh0aGlzLl9jcmVhdGVNYXJrZXIobGF0bG5nKSk7XG5cblx0XHR0aGlzLl9wb2x5LmFkZExhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX3BvbHkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3ZlcnRleENoYW5nZWQobGF0bG5nLCB0cnVlKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNvbXBsZXRlU2hhcGUoKTogdm9pZFxuXHQvLyBDbG9zZXMgdGhlIHBvbHlsaW5lIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50c1xuXHRjb21wbGV0ZVNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoIDw9IDEgfHwgIXRoaXMuX3NoYXBlSXNWYWxpZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZUNyZWF0ZWRFdmVudCgpO1xuXHRcdHRoaXMuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXBlYXRNb2RlKSB7XG5cdFx0XHR0aGlzLmVuYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZmluaXNoU2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX3BvbHkuX2RlZmF1bHRTaGFwZSA/IHRoaXMuX3BvbHkuX2RlZmF1bHRTaGFwZSgpIDogdGhpcy5fcG9seS5nZXRMYXRMbmdzKCk7XG5cdFx0dmFyIGludGVyc2VjdHMgPSB0aGlzLl9wb2x5Lm5ld0xhdExuZ0ludGVyc2VjdHMobGF0bG5nc1tsYXRsbmdzLmxlbmd0aCAtIDFdKTtcblxuXHRcdGlmICgoIXRoaXMub3B0aW9ucy5hbGxvd0ludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3RzKSB8fCAhdGhpcy5fc2hhcGVJc1ZhbGlkKCkpIHtcblx0XHRcdHRoaXMuX3Nob3dFcnJvclRvb2x0aXAoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9maXJlQ3JlYXRlZEV2ZW50KCk7XG5cdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXBlYXRNb2RlKSB7XG5cdFx0XHR0aGlzLmVuYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYWxsZWQgdG8gdmVyaWZ5IHRoZSBzaGFwZSBpcyB2YWxpZCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIGZpbmlzaCBpdFxuXHQvLyBSZXR1cm4gZmFsc2UgaWYgdGhlIHNoYXBlIGlzIG5vdCB2YWxpZFxuXHRfc2hhcGVJc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXJzICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVHdWlkZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG5ld1BvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0dmFyIGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobmV3UG9zKTtcblxuXHRcdC8vIFNhdmUgbGF0bG5nXG5cdFx0Ly8gc2hvdWxkIHRoaXMgYmUgbW92ZWQgdG8gX3VwZGF0ZUd1aWRlKCkgP1xuXHRcdHRoaXMuX2N1cnJlbnRMYXRMbmcgPSBsYXRsbmc7XG5cblx0XHR0aGlzLl91cGRhdGVUb29sdGlwKGxhdGxuZyk7XG5cblx0XHQvLyBVcGRhdGUgdGhlIGd1aWRlIGxpbmVcblx0XHR0aGlzLl91cGRhdGVHdWlkZShuZXdQb3MpO1xuXG5cdFx0Ly8gVXBkYXRlIHRoZSBtb3VzZSBtYXJrZXIgcG9zaXRpb25cblx0XHR0aGlzLl9tb3VzZU1hcmtlci5zZXRMYXRMbmcobGF0bG5nKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZS5vcmlnaW5hbEV2ZW50KTtcblx0fSxcblxuXHRfdmVydGV4Q2hhbmdlZDogZnVuY3Rpb24gKGxhdGxuZywgYWRkZWQpIHtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRFJBV1ZFUlRFWCwge2xheWVyczogdGhpcy5fbWFya2VyR3JvdXB9KTtcblx0XHR0aGlzLl91cGRhdGVGaW5pc2hIYW5kbGVyKCk7XG5cblx0XHR0aGlzLl91cGRhdGVSdW5uaW5nTWVhc3VyZShsYXRsbmcsIGFkZGVkKTtcblxuXHRcdHRoaXMuX2NsZWFyR3VpZGVzKCk7XG5cblx0XHR0aGlzLl91cGRhdGVUb29sdGlwKCk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fY2xpY2tIYW5kbGVkICYmICF0aGlzLl90b3VjaEhhbmRsZWQgJiYgIXRoaXMuX2Rpc2FibGVNYXJrZXJzKSB7XG5cdFx0XHR0aGlzLl9vbk1vdXNlTW92ZShlKTtcblx0XHRcdHRoaXMuX2NsaWNrSGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9kaXNhYmxlTmV3TWFya2VycygpO1xuXHRcdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0XHR2YXIgY2xpZW50WCA9IG9yaWdpbmFsRXZlbnQuY2xpZW50WDtcblx0XHRcdHZhciBjbGllbnRZID0gb3JpZ2luYWxFdmVudC5jbGllbnRZO1xuXHRcdFx0dGhpcy5fc3RhcnRQb2ludC5jYWxsKHRoaXMsIGNsaWVudFgsIGNsaWVudFkpO1xuXHRcdH1cblx0fSxcblxuXHRfc3RhcnRQb2ludDogZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcblx0XHR0aGlzLl9tb3VzZURvd25PcmlnaW4gPSBMLnBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0dmFyIGNsaWVudFggPSBvcmlnaW5hbEV2ZW50LmNsaWVudFg7XG5cdFx0dmFyIGNsaWVudFkgPSBvcmlnaW5hbEV2ZW50LmNsaWVudFk7XG5cdFx0dGhpcy5fZW5kUG9pbnQuY2FsbCh0aGlzLCBjbGllbnRYLCBjbGllbnRZLCBlKTtcblx0XHR0aGlzLl9jbGlja0hhbmRsZWQgPSBudWxsO1xuXHR9LFxuXG5cdF9lbmRQb2ludDogZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFksIGUpIHtcblx0XHRpZiAodGhpcy5fbW91c2VEb3duT3JpZ2luKSB7XG5cdFx0XHR2YXIgZHJhZ0NoZWNrRGlzdGFuY2UgPSBMLnBvaW50KGNsaWVudFgsIGNsaWVudFkpXG5cdFx0XHRcdC5kaXN0YW5jZVRvKHRoaXMuX21vdXNlRG93bk9yaWdpbik7XG5cdFx0XHR2YXIgbGFzdFB0RGlzdGFuY2UgPSB0aGlzLl9jYWxjdWxhdGVGaW5pc2hEaXN0YW5jZShlLmxhdGxuZyk7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm1heFBvaW50cyA+IDEgJiYgdGhpcy5vcHRpb25zLm1heFBvaW50cyA9PSB0aGlzLl9tYXJrZXJzLmxlbmd0aCArIDEpIHtcblx0XHRcdFx0dGhpcy5hZGRWZXJ0ZXgoZS5sYXRsbmcpO1xuXHRcdFx0XHR0aGlzLl9maW5pc2hTaGFwZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXN0UHREaXN0YW5jZSA8IDEwICYmIEwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHR0aGlzLl9maW5pc2hTaGFwZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChNYXRoLmFicyhkcmFnQ2hlY2tEaXN0YW5jZSkgPCA5ICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSB7XG5cdFx0XHRcdHRoaXMuYWRkVmVydGV4KGUubGF0bG5nKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2VuYWJsZU5ld01hcmtlcnMoKTsgLy8gYWZ0ZXIgYSBzaG9ydCBwYXVzZSwgZW5hYmxlIG5ldyBtYXJrZXJzXG5cdFx0fVxuXHRcdHRoaXMuX21vdXNlRG93bk9yaWdpbiA9IG51bGw7XG5cdH0sXG5cblx0Ly8gb250b3VjaCBwcmV2ZW50ZWQgYnkgY2xpY2tIYW5kbGVkIGZsYWcgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGZpcmUgYm90aCBjbGljay90b3VjaCBldmVudHMsXG5cdC8vIGNhdXNpbmcgdW53YW50ZWQgYmVoYXZpb3Jcblx0X29uVG91Y2g6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0dmFyIGNsaWVudFg7XG5cdFx0dmFyIGNsaWVudFk7XG5cdFx0aWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0gJiYgIXRoaXMuX2NsaWNrSGFuZGxlZCAmJiAhdGhpcy5fdG91Y2hIYW5kbGVkICYmICF0aGlzLl9kaXNhYmxlTWFya2Vycykge1xuXHRcdFx0Y2xpZW50WCA9IG9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuXHRcdFx0Y2xpZW50WSA9IG9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuXHRcdFx0dGhpcy5fZGlzYWJsZU5ld01hcmtlcnMoKTtcblx0XHRcdHRoaXMuX3RvdWNoSGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9zdGFydFBvaW50LmNhbGwodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG5cdFx0XHR0aGlzLl9lbmRQb2ludC5jYWxsKHRoaXMsIGNsaWVudFgsIGNsaWVudFksIGUpO1xuXHRcdFx0dGhpcy5fdG91Y2hIYW5kbGVkID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5fY2xpY2tIYW5kbGVkID0gbnVsbDtcblx0fSxcblxuXHRfb25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLl9vbk1vdXNlT3V0LmNhbGwodGhpcy5fdG9vbHRpcCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNhbGN1bGF0ZSBpZiB3ZSBhcmUgY3VycmVudGx5IHdpdGhpbiBjbG9zZSBlbm91Z2ggZGlzdGFuY2Vcblx0Ly8gb2YgdGhlIGNsb3NpbmcgcG9pbnQgKGZpcnN0IHBvaW50IGZvciBzaGFwZXMsIGxhc3QgcG9pbnQgZm9yIGxpbmVzKVxuXHQvLyB0aGlzIGlzIHNlbWktdWdseSBjb2RlIGJ1dCB0aGUgb25seSByZWxpYWJsZSB3YXkgaSBmb3VuZCB0byBnZXQgdGhlIGpvYiBkb25lXG5cdC8vIG5vdGU6IGNhbGN1bGF0aW5nIHBvaW50LmRpc3RhbmNlVG8gYmV0d2VlbiBtb3VzZURvd25PcmlnaW4gYW5kIGxhc3QgbWFya2VyIGRpZCBOT1Qgd29ya1xuXHRfY2FsY3VsYXRlRmluaXNoRGlzdGFuY2U6IGZ1bmN0aW9uIChwb3RlbnRpYWxMYXRMbmcpIHtcblx0XHR2YXIgbGFzdFB0RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIGZpbmlzaE1hcmtlcjtcblx0XHRcdGlmICh0aGlzLnR5cGUgPT09IEwuRHJhdy5Qb2x5bGluZS5UWVBFKSB7XG5cdFx0XHRcdGZpbmlzaE1hcmtlciA9IHRoaXMuX21hcmtlcnNbdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxXTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBMLkRyYXcuUG9seWdvbi5UWVBFKSB7XG5cdFx0XHRcdGZpbmlzaE1hcmtlciA9IHRoaXMuX21hcmtlcnNbMF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gSW5maW5pdHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGFzdE1hcmtlclBvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoZmluaXNoTWFya2VyLmdldExhdExuZygpKSxcblx0XHRcdFx0cG90ZW50aWFsTWFya2VyID0gbmV3IEwuTWFya2VyKHBvdGVudGlhbExhdExuZywge1xuXHRcdFx0XHRcdGljb246IHRoaXMub3B0aW9ucy5pY29uLFxuXHRcdFx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCAqIDJcblx0XHRcdFx0fSk7XG5cdFx0XHR2YXIgcG90ZW50aWFsTWFya2VyUGludCA9IHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHBvdGVudGlhbE1hcmtlci5nZXRMYXRMbmcoKSk7XG5cdFx0XHRsYXN0UHREaXN0YW5jZSA9IGxhc3RNYXJrZXJQb2ludC5kaXN0YW5jZVRvKHBvdGVudGlhbE1hcmtlclBpbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXN0UHREaXN0YW5jZSA9IEluZmluaXR5O1xuXHRcdH1cblx0XHRyZXR1cm4gbGFzdFB0RGlzdGFuY2U7XG5cdH0sXG5cblx0X3VwZGF0ZUZpbmlzaEhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyQ291bnQgPSB0aGlzLl9tYXJrZXJzLmxlbmd0aDtcblx0XHQvLyBUaGUgbGFzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYSBjbGljayBoYW5kbGVyIHRvIGNsb3NlIHRoZSBwb2x5bGluZVxuXHRcdGlmIChtYXJrZXJDb3VudCA+IDEpIHtcblx0XHRcdHRoaXMuX21hcmtlcnNbbWFya2VyQ291bnQgLSAxXS5vbignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBvbGQgbWFya2VyIGNsaWNrIGhhbmRsZXIgKGFzIG9ubHkgdGhlIGxhc3QgcG9pbnQgc2hvdWxkIGNsb3NlIHRoZSBwb2x5bGluZSlcblx0XHRpZiAobWFya2VyQ291bnQgPiAyKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzW21hcmtlckNvdW50IC0gMl0ub2ZmKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG5cdFx0XHRpY29uOiB0aGlzLm9wdGlvbnMuaWNvbixcblx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCAqIDJcblx0XHR9KTtcblxuXHRcdHRoaXMuX21hcmtlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cblx0XHRyZXR1cm4gbWFya2VyO1xuXHR9LFxuXG5cdF91cGRhdGVHdWlkZTogZnVuY3Rpb24gKG5ld1Bvcykge1xuXHRcdHZhciBtYXJrZXJDb3VudCA9IHRoaXMuX21hcmtlcnMgPyB0aGlzLl9tYXJrZXJzLmxlbmd0aCA6IDA7XG5cblx0XHRpZiAobWFya2VyQ291bnQgPiAwKSB7XG5cdFx0XHRuZXdQb3MgPSBuZXdQb3MgfHwgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9jdXJyZW50TGF0TG5nKTtcblxuXHRcdFx0Ly8gZHJhdyB0aGUgZ3VpZGUgbGluZVxuXHRcdFx0dGhpcy5fY2xlYXJHdWlkZXMoKTtcblx0XHRcdHRoaXMuX2RyYXdHdWlkZShcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9tYXJrZXJzW21hcmtlckNvdW50IC0gMV0uZ2V0TGF0TG5nKCkpLFxuXHRcdFx0XHRuZXdQb3Ncblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVUb29sdGlwOiBmdW5jdGlvbiAobGF0TG5nKSB7XG5cdFx0dmFyIHRleHQgPSB0aGlzLl9nZXRUb29sdGlwVGV4dCgpO1xuXG5cdFx0aWYgKGxhdExuZykge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVQb3NpdGlvbihsYXRMbmcpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fZXJyb3JTaG93bikge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHRleHQpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd0d1aWRlOiBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpIHtcblx0XHR2YXIgbGVuZ3RoID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoTWF0aC5wb3coKHBvaW50Qi54IC0gcG9pbnRBLngpLCAyKSArIE1hdGgucG93KChwb2ludEIueSAtIHBvaW50QS55KSwgMikpKSxcblx0XHRcdGd1aWRlbGluZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLmd1aWRlbGluZURpc3RhbmNlLFxuXHRcdFx0bWF4R3VpZGVMaW5lTGVuZ3RoID0gdGhpcy5vcHRpb25zLm1heEd1aWRlTGluZUxlbmd0aCxcblx0XHRcdC8vIE9ubHkgZHJhdyBhIGd1aWRlbGluZSB3aXRoIGEgbWF4IGxlbmd0aFxuXHRcdFx0aSA9IGxlbmd0aCA+IG1heEd1aWRlTGluZUxlbmd0aCA/IGxlbmd0aCAtIG1heEd1aWRlTGluZUxlbmd0aCA6IGd1aWRlbGluZURpc3RhbmNlLFxuXHRcdFx0ZnJhY3Rpb24sXG5cdFx0XHRkYXNoUG9pbnQsXG5cdFx0XHRkYXNoO1xuXG5cdFx0Ly9jcmVhdGUgdGhlIGd1aWRlcyBjb250YWluZXIgaWYgd2UgaGF2ZW4ndCB5ZXRcblx0XHRpZiAoIXRoaXMuX2d1aWRlc0NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5fZ3VpZGVzQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy1ndWlkZXMnLCB0aGlzLl9vdmVybGF5UGFuZSk7XG5cdFx0fVxuXG5cdFx0Ly9kcmF3IGEgZGFzaCBldmVyeSBHdWlsZGVMaW5lRGlzdGFuY2Vcblx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSB0aGlzLm9wdGlvbnMuZ3VpZGVsaW5lRGlzdGFuY2UpIHtcblx0XHRcdC8vd29yayBvdXQgZnJhY3Rpb24gYWxvbmcgbGluZSB3ZSBhcmVcblx0XHRcdGZyYWN0aW9uID0gaSAvIGxlbmd0aDtcblxuXHRcdFx0Ly9jYWxjdWxhdGUgbmV3IHgseSBwb2ludFxuXHRcdFx0ZGFzaFBvaW50ID0ge1xuXHRcdFx0XHR4OiBNYXRoLmZsb29yKChwb2ludEEueCAqICgxIC0gZnJhY3Rpb24pKSArIChmcmFjdGlvbiAqIHBvaW50Qi54KSksXG5cdFx0XHRcdHk6IE1hdGguZmxvb3IoKHBvaW50QS55ICogKDEgLSBmcmFjdGlvbikpICsgKGZyYWN0aW9uICogcG9pbnRCLnkpKVxuXHRcdFx0fTtcblxuXHRcdFx0Ly9hZGQgZ3VpZGUgZGFzaCB0byBndWlkZSBjb250YWluZXJcblx0XHRcdGRhc2ggPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1kcmF3LWd1aWRlLWRhc2gnLCB0aGlzLl9ndWlkZXNDb250YWluZXIpO1xuXHRcdFx0ZGFzaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPVxuXHRcdFx0XHQhdGhpcy5fZXJyb3JTaG93biA/IHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMuY29sb3IgOiB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLmNvbG9yO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oZGFzaCwgZGFzaFBvaW50KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUd1aWRlQ29sb3I6IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdGlmICh0aGlzLl9ndWlkZXNDb250YWluZXIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fZ3VpZGVzQ29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2d1aWRlc0NvbnRhaW5lci5jaGlsZE5vZGVzW2ldLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyByZW1vdmVzIGFsbCBjaGlsZCBlbGVtZW50cyAoZ3VpZGUgZGFzaGVzKSBmcm9tIHRoZSBndWlkZXMgY29udGFpbmVyXG5cdF9jbGVhckd1aWRlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9ndWlkZXNDb250YWluZXIpIHtcblx0XHRcdHdoaWxlICh0aGlzLl9ndWlkZXNDb250YWluZXIuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHR0aGlzLl9ndWlkZXNDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZ3VpZGVzQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VG9vbHRpcFRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2hvd0xlbmd0aCA9IHRoaXMub3B0aW9ucy5zaG93TGVuZ3RoLFxuXHRcdFx0bGFiZWxUZXh0LCBkaXN0YW5jZVN0cjtcblx0XHRpZiAodGhpcy5fbWFya2Vycy5sZW5ndGggPT09IDApIHtcblx0XHRcdGxhYmVsVGV4dCA9IHtcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS50b29sdGlwLnN0YXJ0XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXN0YW5jZVN0ciA9IHNob3dMZW5ndGggPyB0aGlzLl9nZXRNZWFzdXJlbWVudFN0cmluZygpIDogJyc7XG5cblx0XHRcdGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRsYWJlbFRleHQgPSB7XG5cdFx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS50b29sdGlwLmNvbnQsXG5cdFx0XHRcdFx0c3VidGV4dDogZGlzdGFuY2VTdHJcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhYmVsVGV4dCA9IHtcblx0XHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlsaW5lLnRvb2x0aXAuZW5kLFxuXHRcdFx0XHRcdHN1YnRleHQ6IGRpc3RhbmNlU3RyXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsYWJlbFRleHQ7XG5cdH0sXG5cblx0X3VwZGF0ZVJ1bm5pbmdNZWFzdXJlOiBmdW5jdGlvbiAobGF0bG5nLCBhZGRlZCkge1xuXHRcdHZhciBtYXJrZXJzTGVuZ3RoID0gdGhpcy5fbWFya2Vycy5sZW5ndGgsXG5cdFx0XHRwcmV2aW91c01hcmtlckluZGV4LCBkaXN0YW5jZTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmV2aW91c01hcmtlckluZGV4ID0gbWFya2Vyc0xlbmd0aCAtIChhZGRlZCA/IDIgOiAxKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiYXNlZCBvbiB0aGUgdmVyc2lvblxuXHRcdFx0aWYgKEwuR2VvbWV0cnlVdGlsLmlzVmVyc2lvbjA3eCgpKSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gbGF0bG5nLmRpc3RhbmNlVG8odGhpcy5fbWFya2Vyc1twcmV2aW91c01hcmtlckluZGV4XS5nZXRMYXRMbmcoKSkgKiAodGhpcy5vcHRpb25zLmZhY3RvciB8fCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gdGhpcy5fbWFwLmRpc3RhbmNlKGxhdGxuZywgdGhpcy5fbWFya2Vyc1twcmV2aW91c01hcmtlckluZGV4XS5nZXRMYXRMbmcoKSkgKiAodGhpcy5vcHRpb25zLmZhY3RvciB8fCAxKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgKz0gZGlzdGFuY2UgKiAoYWRkZWQgPyAxIDogLTEpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0TWVhc3VyZW1lbnRTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3VycmVudExhdExuZyA9IHRoaXMuX2N1cnJlbnRMYXRMbmcsXG5cdFx0XHRwcmV2aW91c0xhdExuZyA9IHRoaXMuX21hcmtlcnNbdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxXS5nZXRMYXRMbmcoKSxcblx0XHRcdGRpc3RhbmNlO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBsYXN0IGZpeGVkIHBvaW50IHRvIHRoZSBtb3VzZSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdmVyc2lvblxuXHRcdGlmIChMLkdlb21ldHJ5VXRpbC5pc1ZlcnNpb24wN3goKSkge1xuXHRcdFx0ZGlzdGFuY2UgPSBwcmV2aW91c0xhdExuZyAmJiBjdXJyZW50TGF0TG5nICYmIGN1cnJlbnRMYXRMbmcuZGlzdGFuY2VUbyA/IHRoaXMuX21lYXN1cmVtZW50UnVubmluZ1RvdGFsICsgY3VycmVudExhdExuZy5kaXN0YW5jZVRvKHByZXZpb3VzTGF0TG5nKSAqICh0aGlzLm9wdGlvbnMuZmFjdG9yIHx8IDEpIDogdGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgfHwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzdGFuY2UgPSBwcmV2aW91c0xhdExuZyAmJiBjdXJyZW50TGF0TG5nID8gdGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgKyB0aGlzLl9tYXAuZGlzdGFuY2UoY3VycmVudExhdExuZywgcHJldmlvdXNMYXRMbmcpICogKHRoaXMub3B0aW9ucy5mYWN0b3IgfHwgMSkgOiB0aGlzLl9tZWFzdXJlbWVudFJ1bm5pbmdUb3RhbCB8fCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBMLkdlb21ldHJ5VXRpbC5yZWFkYWJsZURpc3RhbmNlKGRpc3RhbmNlLCB0aGlzLm9wdGlvbnMubWV0cmljLCB0aGlzLm9wdGlvbnMuZmVldCwgdGhpcy5vcHRpb25zLm5hdXRpYywgdGhpcy5vcHRpb25zLnByZWNpc2lvbik7XG5cdH0sXG5cblx0X3Nob3dFcnJvclRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9lcnJvclNob3duID0gdHJ1ZTtcblxuXHRcdC8vIFVwZGF0ZSB0b29sdGlwXG5cdFx0dGhpcy5fdG9vbHRpcFxuXHRcdFx0LnNob3dBc0Vycm9yKClcblx0XHRcdC51cGRhdGVDb250ZW50KHt0ZXh0OiB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLm1lc3NhZ2V9KTtcblxuXHRcdC8vIFVwZGF0ZSBzaGFwZVxuXHRcdHRoaXMuX3VwZGF0ZUd1aWRlQ29sb3IodGhpcy5vcHRpb25zLmRyYXdFcnJvci5jb2xvcik7XG5cdFx0dGhpcy5fcG9seS5zZXRTdHlsZSh7Y29sb3I6IHRoaXMub3B0aW9ucy5kcmF3RXJyb3IuY29sb3J9KTtcblxuXHRcdC8vIEhpZGUgdGhlIGVycm9yIGFmdGVyIDIgc2Vjb25kc1xuXHRcdHRoaXMuX2NsZWFySGlkZUVycm9yVGltZW91dCgpO1xuXHRcdHRoaXMuX2hpZGVFcnJvclRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuVXRpbC5iaW5kKHRoaXMuX2hpZGVFcnJvclRvb2x0aXAsIHRoaXMpLCB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLnRpbWVvdXQpO1xuXHR9LFxuXG5cdF9oaWRlRXJyb3JUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZXJyb3JTaG93biA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY2xlYXJIaWRlRXJyb3JUaW1lb3V0KCk7XG5cblx0XHQvLyBSZXZlcnQgdG9vbHRpcFxuXHRcdHRoaXMuX3Rvb2x0aXBcblx0XHRcdC5yZW1vdmVFcnJvcigpXG5cdFx0XHQudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKTtcblxuXHRcdC8vIFJldmVydCBzaGFwZVxuXHRcdHRoaXMuX3VwZGF0ZUd1aWRlQ29sb3IodGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucy5jb2xvcik7XG5cdFx0dGhpcy5fcG9seS5zZXRTdHlsZSh7Y29sb3I6IHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMuY29sb3J9KTtcblx0fSxcblxuXHRfY2xlYXJIaWRlRXJyb3JUaW1lb3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2hpZGVFcnJvclRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9oaWRlRXJyb3JUaW1lb3V0KTtcblx0XHRcdHRoaXMuX2hpZGVFcnJvclRpbWVvdXQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvLyBkaXNhYmxlIG5ldyBtYXJrZXJzIHRlbXBvcmFyaWx5O1xuXHQvLyB0aGlzIGlzIHRvIHByZXZlbnQgZHVwbGljYXRlZCB0b3VjaC9jbGljayBldmVudHMgaW4gc29tZSBicm93c2Vyc1xuXHRfZGlzYWJsZU5ld01hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kaXNhYmxlTWFya2VycyA9IHRydWU7XG5cdH0sXG5cblx0Ly8gc2VlIF9kaXNhYmxlTmV3TWFya2Vyc1xuXHRfZW5hYmxlTmV3TWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZGlzYWJsZU1hcmtlcnMgPSBmYWxzZTtcblx0XHR9LmJpbmQodGhpcyksIDUwKTtcblx0fSxcblxuXHRfY2xlYW5VcFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fbWFya2Vyc1t0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDFdLm9mZignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9maXJlQ3JlYXRlZEV2ZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvbHkgPSBuZXcgdGhpcy5Qb2x5KHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpLCB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCBwb2x5KTtcblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkRyYXcuUG9seWdvblxuICogQGFrYSBEcmF3LlBvbHlnb25cbiAqIEBpbmhlcml0cyBMLkRyYXcuUG9seWxpbmVcbiAqL1xuTC5EcmF3LlBvbHlnb24gPSBMLkRyYXcuUG9seWxpbmUuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdwb2x5Z29uJ1xuXHR9LFxuXG5cdFBvbHk6IEwuUG9seWdvbixcblxuXHRvcHRpb25zOiB7XG5cdFx0c2hvd0FyZWE6IGZhbHNlLFxuXHRcdHNob3dMZW5ndGg6IGZhbHNlLFxuXHRcdHNoYXBlT3B0aW9uczoge1xuXHRcdFx0c3Ryb2tlOiB0cnVlLFxuXHRcdFx0Y29sb3I6ICcjMzM4OGZmJyxcblx0XHRcdHdlaWdodDogNCxcblx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRmaWxsQ29sb3I6IG51bGwsIC8vc2FtZSBhcyBjb2xvciBieSBkZWZhdWx0XG5cdFx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXHRcdFx0Y2xpY2thYmxlOiB0cnVlXG5cdFx0fSxcblx0XHQvLyBXaGV0aGVyIHRvIHVzZSB0aGUgbWV0cmljIG1lYXN1cmVtZW50IHN5c3RlbSAodHJ1dGh5KSBvciBub3QgKGZhbHN5KS5cblx0XHQvLyBBbHNvIGRlZmluZXMgdGhlIHVuaXRzIHRvIHVzZSBmb3IgdGhlIG1ldHJpYyBzeXN0ZW0gYXMgYW4gYXJyYXkgb2Zcblx0XHQvLyBzdHJpbmdzIChlLmcuIGBbJ2hhJywgJ20nXWApLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblx0XHRmZWV0OiB0cnVlLCAvLyBXaGVuIG5vdCBtZXRyaWMsIHRvIHVzZSBmZWV0IGluc3RlYWQgb2YgeWFyZHMgZm9yIGRpc3BsYXkuXG5cdFx0bmF1dGljOiBmYWxzZSwgLy8gV2hlbiBub3QgbWV0cmljLCBub3QgZmVldCB1c2UgbmF1dGljIG1pbGUgZm9yIGRpc3BsYXlcblx0XHQvLyBEZWZpbmVzIHRoZSBwcmVjaXNpb24gZm9yIGVhY2ggdHlwZSBvZiB1bml0IChlLmcuIHtrbTogMiwgZnQ6IDB9XG5cdFx0cHJlY2lzaW9uOiB7fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHRMLkRyYXcuUG9seWxpbmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkRyYXcuUG9seWdvbi5UWVBFO1xuXHR9LFxuXG5cdF91cGRhdGVGaW5pc2hIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcmtlckNvdW50ID0gdGhpcy5fbWFya2Vycy5sZW5ndGg7XG5cblx0XHQvLyBUaGUgZmlyc3QgbWFya2VyIHNob3VsZCBoYXZlIGEgY2xpY2sgaGFuZGxlciB0byBjbG9zZSB0aGUgcG9seWdvblxuXHRcdGlmIChtYXJrZXJDb3VudCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fbWFya2Vyc1swXS5vbignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGFuZCB1cGRhdGUgdGhlIGRvdWJsZSBjbGljayBoYW5kbGVyXG5cdFx0aWYgKG1hcmtlckNvdW50ID4gMikge1xuXHRcdFx0dGhpcy5fbWFya2Vyc1ttYXJrZXJDb3VudCAtIDFdLm9uKCdkYmxjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHRcdC8vIE9ubHkgbmVlZCB0byByZW1vdmUgaGFuZGxlciBpZiBoYXMgYmVlbiBhZGRlZCBiZWZvcmVcblx0XHRcdGlmIChtYXJrZXJDb3VudCA+IDMpIHtcblx0XHRcdFx0dGhpcy5fbWFya2Vyc1ttYXJrZXJDb3VudCAtIDJdLm9mZignZGJsY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUb29sdGlwVGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0ZXh0LCBzdWJ0ZXh0O1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0ZXh0ID0gTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5Z29uLnRvb2x0aXAuc3RhcnQ7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA8IDMpIHtcblx0XHRcdHRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlnb24udG9vbHRpcC5jb250O1xuXHRcdFx0c3VidGV4dCA9IHRoaXMuX2dldE1lYXN1cmVtZW50U3RyaW5nKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlnb24udG9vbHRpcC5lbmQ7XG5cdFx0XHRzdWJ0ZXh0ID0gdGhpcy5fZ2V0TWVhc3VyZW1lbnRTdHJpbmcoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGV4dDogdGV4dCxcblx0XHRcdHN1YnRleHQ6IHN1YnRleHRcblx0XHR9O1xuXHR9LFxuXG5cdF9nZXRNZWFzdXJlbWVudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhcmVhID0gdGhpcy5fYXJlYSxcblx0XHRcdG1lYXN1cmVtZW50U3RyaW5nID0gJyc7XG5cblxuXHRcdGlmICghYXJlYSAmJiAhdGhpcy5vcHRpb25zLnNob3dMZW5ndGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2hvd0xlbmd0aCkge1xuXHRcdFx0bWVhc3VyZW1lbnRTdHJpbmcgPSBMLkRyYXcuUG9seWxpbmUucHJvdG90eXBlLl9nZXRNZWFzdXJlbWVudFN0cmluZy5jYWxsKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhKSB7XG5cdFx0XHRtZWFzdXJlbWVudFN0cmluZyArPSAnPGJyPicgKyBMLkdlb21ldHJ5VXRpbC5yZWFkYWJsZUFyZWEoYXJlYSwgdGhpcy5vcHRpb25zLm1ldHJpYywgdGhpcy5vcHRpb25zLnByZWNpc2lvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lYXN1cmVtZW50U3RyaW5nO1xuXHR9LFxuXG5cdF9zaGFwZUlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFya2Vycy5sZW5ndGggPj0gMztcblx0fSxcblxuXHRfdmVydGV4Q2hhbmdlZDogZnVuY3Rpb24gKGxhdGxuZywgYWRkZWQpIHtcblx0XHR2YXIgbGF0TG5ncztcblxuXHRcdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgc2hvdyB0aGUgYXJlYVxuXHRcdGlmICghdGhpcy5vcHRpb25zLmFsbG93SW50ZXJzZWN0aW9uICYmIHRoaXMub3B0aW9ucy5zaG93QXJlYSkge1xuXHRcdFx0bGF0TG5ncyA9IHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpO1xuXG5cdFx0XHR0aGlzLl9hcmVhID0gTC5HZW9tZXRyeVV0aWwuZ2VvZGVzaWNBcmVhKGxhdExuZ3MpO1xuXHRcdH1cblxuXHRcdEwuRHJhdy5Qb2x5bGluZS5wcm90b3R5cGUuX3ZlcnRleENoYW5nZWQuY2FsbCh0aGlzLCBsYXRsbmcsIGFkZGVkKTtcblx0fSxcblxuXHRfY2xlYW5VcFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcmtlckNvdW50ID0gdGhpcy5fbWFya2Vycy5sZW5ndGg7XG5cblx0XHRpZiAobWFya2VyQ291bnQgPiAwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzWzBdLm9mZignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cblx0XHRcdGlmIChtYXJrZXJDb3VudCA+IDIpIHtcblx0XHRcdFx0dGhpcy5fbWFya2Vyc1ttYXJrZXJDb3VudCAtIDFdLm9mZignZGJsY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbkwuU2ltcGxlU2hhcGUgPSB7fTtcbi8qKlxuICogQGNsYXNzIEwuRHJhdy5TaW1wbGVTaGFwZVxuICogQGFrYSBEcmF3LlNpbXBsZVNoYXBlXG4gKiBAaW5oZXJpdHMgTC5EcmF3LkZlYXR1cmVcbiAqL1xuTC5EcmF3LlNpbXBsZVNoYXBlID0gTC5EcmF3LkZlYXR1cmUuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdHJlcGVhdE1vZGU6IGZhbHNlXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdHRoaXMuX2VuZExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMuc2ltcGxlc2hhcGUudG9vbHRpcC5lbmQ7XG5cblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXIuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLmFkZEhvb2tzLmNhbGwodGhpcyk7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwRHJhZ2dhYmxlID0gdGhpcy5fbWFwLmRyYWdnaW5nLmVuYWJsZWQoKTtcblxuXHRcdFx0aWYgKHRoaXMuX21hcERyYWdnYWJsZSkge1xuXHRcdFx0XHR0aGlzLl9tYXAuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1RPRE8gcmVmYWN0b3I6IG1vdmUgY3Vyc29yIHRvIHN0eWxlc1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdjcm9zc2hhaXInO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe3RleHQ6IHRoaXMuX2luaXRpYWxMYWJlbFRleHR9KTtcblxuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHRcdC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpXG5cdFx0XHRcdC5vbigndG91Y2hzdGFydCcsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0XHQub24oJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblxuXHRcdFx0Ly8gd2Ugc2hvdWxkIHByZXZlbnQgZGVmYXVsdCwgb3RoZXJ3aXNlIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZykgd2lsbCBmaXJlLFxuXHRcdFx0Ly8gYW5kIHRoYXQgd2lsbCBjYXVzZSBkb2N1bWVudC50b3VjaGVuZCB0byBmaXJlIGFuZCB3aWxsIHN0b3AgdGhlIGRyYXdpbmdcblx0XHRcdC8vIChjaXJjbGUsIHJlY3RhbmdsZSkgaW4gdG91Y2ggbW9kZS5cblx0XHRcdC8vICh1cGRhdGUpOiB3ZSBoYXZlIHRvIHNlbmQgcGFzc2l2ZSBub3cgdG8gcHJldmVudCBzY3JvbGwsIGJlY2F1c2UgYnkgZGVmYXVsdCBpdCBpcyB7cGFzc2l2ZTogdHJ1ZX0gbm93LCB3aGljaCBtZWFucyxcblx0XHRcdC8vIGhhbmRsZXIgY2FuJ3QgZXZlbnQucHJldmVudERlZmF1bHRcblx0XHRcdC8vIGNoZWNrIHRoZSBuZXdzIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTYvMDYvcGFzc2l2ZS1ldmVudC1saXN0ZW5lcnNcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0LCB7cGFzc2l2ZTogZmFsc2V9KTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmcm9tIHRoaXMgaGFuZGxlci5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUucmVtb3ZlSG9va3MuY2FsbCh0aGlzKTtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRpZiAodGhpcy5fbWFwRHJhZ2dhYmxlKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9UT0RPIHJlZmFjdG9yOiBtb3ZlIGN1cnNvciB0byBzdHlsZXNcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnJztcblxuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vZmYoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0XHQub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2hzdGFydCcsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKVxuXHRcdFx0XHQub2ZmKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cblx0XHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwLCB0aGlzKTtcblxuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXG5cdFx0XHQvLyBJZiB0aGUgYm94IGVsZW1lbnQgZG9lc24ndCBleGlzdCB0aGV5IG11c3Qgbm90IGhhdmUgbW92ZWQgdGhlIG1vdXNlLCBzbyBkb24ndCBuZWVkIHRvIGRlc3Ryb3kvcmV0dXJuXG5cdFx0XHRpZiAodGhpcy5fc2hhcGUpIHtcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3NoYXBlKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3NoYXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9pc0RyYXdpbmcgPSBmYWxzZTtcblx0fSxcblxuXHRfZ2V0VG9vbHRpcFRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dGV4dDogdGhpcy5fZW5kTGFiZWxUZXh0XG5cdFx0fTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5faXNEcmF3aW5nID0gdHJ1ZTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IGUubGF0bG5nO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdFx0Lm9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgdGhpcylcblx0XHRcdC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwLCB0aGlzKVxuXHRcdFx0LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZztcblxuXHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24obGF0bG5nKTtcblx0XHRpZiAodGhpcy5faXNEcmF3aW5nKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQodGhpcy5fZ2V0VG9vbHRpcFRleHQoKSk7XG5cdFx0XHR0aGlzLl9kcmF3U2hhcGUobGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9zaGFwZSkge1xuXHRcdFx0dGhpcy5fZmlyZUNyZWF0ZWRFdmVudCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdGlmICh0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSkge1xuXHRcdFx0dGhpcy5lbmFibGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5EcmF3LlJlY3RhbmdsZVxuICogQGFrYSBEcmF3LlJlY3RhbmdsZVxuICogQGluaGVyaXRzIEwuRHJhdy5TaW1wbGVTaGFwZVxuICovXG5MLkRyYXcuUmVjdGFuZ2xlID0gTC5EcmF3LlNpbXBsZVNoYXBlLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAncmVjdGFuZ2xlJ1xuXHR9LFxuXG5cdG9wdGlvbnM6IHtcblx0XHRzaGFwZU9wdGlvbnM6IHtcblx0XHRcdHN0cm9rZTogdHJ1ZSxcblx0XHRcdGNvbG9yOiAnIzMzODhmZicsXG5cdFx0XHR3ZWlnaHQ6IDQsXG5cdFx0XHRvcGFjaXR5OiAwLjUsXG5cdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0ZmlsbENvbG9yOiBudWxsLCAvL3NhbWUgYXMgY29sb3IgYnkgZGVmYXVsdFxuXHRcdFx0ZmlsbE9wYWNpdHk6IDAuMixcblx0XHRcdGNsaWNrYWJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0c2hvd0FyZWE6IHRydWUsIC8vV2hldGhlciB0byBzaG93IHRoZSBhcmVhIGluIHRoZSB0b29sdGlwXG5cdFx0bWV0cmljOiB0cnVlIC8vIFdoZXRoZXIgdG8gdXNlIHRoZSBtZXRyaWMgbWVhc3VyZW1lbnQgc3lzdGVtIG9yIGltcGVyaWFsXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdC8vIFNhdmUgdGhlIHR5cGUgc28gc3VwZXIgY2FuIGZpcmUsIG5lZWQgdG8gZG8gdGhpcyBhcyBjYW5ub3QgZG8gdGhpcy5UWVBFIDooXG5cdFx0dGhpcy50eXBlID0gTC5EcmF3LlJlY3RhbmdsZS5UWVBFO1xuXG5cdFx0dGhpcy5faW5pdGlhbExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMucmVjdGFuZ2xlLnRvb2x0aXAuc3RhcnQ7XG5cblx0XHRMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB2b2lkXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pc0N1cnJlbnRseVR3b0NsaWNrRHJhd2luZyA9IGZhbHNlO1xuXHRcdEwuRHJhdy5TaW1wbGVTaGFwZS5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9zaGFwZSAmJiAhdGhpcy5faXNDdXJyZW50bHlUd29DbGlja0RyYXdpbmcpIHtcblx0XHRcdHRoaXMuX2lzQ3VycmVudGx5VHdvQ2xpY2tEcmF3aW5nID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgY2xvc2luZyBjbGljayBpcyBvbiBtYXBcblx0XHRpZiAodGhpcy5faXNDdXJyZW50bHlUd29DbGlja0RyYXdpbmcgJiYgIV9oYXNBbmNlc3RvcihlLnRhcmdldCwgJ2xlYWZsZXQtcGFuZScpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fb25Nb3VzZVVwLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0X2RyYXdTaGFwZTogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdGlmICghdGhpcy5fc2hhcGUpIHtcblx0XHRcdHRoaXMuX3NoYXBlID0gbmV3IEwuUmVjdGFuZ2xlKG5ldyBMLkxhdExuZ0JvdW5kcyh0aGlzLl9zdGFydExhdExuZywgbGF0bG5nKSwgdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fc2hhcGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zaGFwZS5zZXRCb3VuZHMobmV3IEwuTGF0TG5nQm91bmRzKHRoaXMuX3N0YXJ0TGF0TG5nLCBsYXRsbmcpKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmVjdGFuZ2xlID0gbmV3IEwuUmVjdGFuZ2xlKHRoaXMuX3NoYXBlLmdldEJvdW5kcygpLCB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblx0XHRMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9maXJlQ3JlYXRlZEV2ZW50LmNhbGwodGhpcywgcmVjdGFuZ2xlKTtcblx0fSxcblxuXHRfZ2V0VG9vbHRpcFRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdG9vbHRpcFRleHQgPSBMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9nZXRUb29sdGlwVGV4dC5jYWxsKHRoaXMpLFxuXHRcdFx0c2hhcGUgPSB0aGlzLl9zaGFwZSxcblx0XHRcdHNob3dBcmVhID0gdGhpcy5vcHRpb25zLnNob3dBcmVhLFxuXHRcdFx0bGF0TG5ncywgYXJlYSwgc3VidGV4dDtcblxuXHRcdGlmIChzaGFwZSkge1xuXHRcdFx0bGF0TG5ncyA9IHRoaXMuX3NoYXBlLl9kZWZhdWx0U2hhcGUgPyB0aGlzLl9zaGFwZS5fZGVmYXVsdFNoYXBlKCkgOiB0aGlzLl9zaGFwZS5nZXRMYXRMbmdzKCk7XG5cdFx0XHRhcmVhID0gTC5HZW9tZXRyeVV0aWwuZ2VvZGVzaWNBcmVhKGxhdExuZ3MpO1xuXHRcdFx0c3VidGV4dCA9IHNob3dBcmVhID8gTC5HZW9tZXRyeVV0aWwucmVhZGFibGVBcmVhKGFyZWEsIHRoaXMub3B0aW9ucy5tZXRyaWMpIDogJyc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRleHQ6IHRvb2x0aXBUZXh0LnRleHQsXG5cdFx0XHRzdWJ0ZXh0OiBzdWJ0ZXh0XG5cdFx0fTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIF9oYXNBbmNlc3RvcihlbCwgY2xzKSB7XG5cdHdoaWxlICgoZWwgPSBlbC5wYXJlbnRFbGVtZW50KSAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNscykpIHtcblx0XHQ7XG5cdH1cblx0cmV0dXJuIGVsO1xufVxuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5EcmF3Lk1hcmtlclxuICogQGFrYSBEcmF3Lk1hcmtlclxuICogQGluaGVyaXRzIEwuRHJhdy5GZWF0dXJlXG4gKi9cbkwuRHJhdy5NYXJrZXIgPSBMLkRyYXcuRmVhdHVyZS5leHRlbmQoe1xuXHRzdGF0aWNzOiB7XG5cdFx0VFlQRTogJ21hcmtlcidcblx0fSxcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCksXG5cdFx0cmVwZWF0TW9kZTogZmFsc2UsXG5cdFx0ekluZGV4T2Zmc2V0OiAyMDAwIC8vIFRoaXMgc2hvdWxkIGJlID4gdGhhbiB0aGUgaGlnaGVzdCB6LWluZGV4IGFueSBtYXJrZXJzXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdC8vIFNhdmUgdGhlIHR5cGUgc28gc3VwZXIgY2FuIGZpcmUsIG5lZWQgdG8gZG8gdGhpcyBhcyBjYW5ub3QgZG8gdGhpcy5UWVBFIDooXG5cdFx0dGhpcy50eXBlID0gTC5EcmF3Lk1hcmtlci5UWVBFO1xuXG5cdFx0dGhpcy5faW5pdGlhbExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMubWFya2VyLnRvb2x0aXAuc3RhcnQ7XG5cblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXIuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLmFkZEhvb2tzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe3RleHQ6IHRoaXMuX2luaXRpYWxMYWJlbFRleHR9KTtcblxuXHRcdFx0Ly8gU2FtZSBtb3VzZU1hcmtlciBhcyBpbiBEcmF3LlBvbHlsaW5lXG5cdFx0XHRpZiAoIXRoaXMuX21vdXNlTWFya2VyKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlTWFya2VyID0gTC5tYXJrZXIodGhpcy5fbWFwLmdldENlbnRlcigpLCB7XG5cdFx0XHRcdFx0aWNvbjogTC5kaXZJY29uKHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtbW91c2UtbWFya2VyJyxcblx0XHRcdFx0XHRcdGljb25BbmNob3I6IFsyMCwgMjBdLFxuXHRcdFx0XHRcdFx0aWNvblNpemU6IFs0MCwgNDBdXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0b3BhY2l0eTogMCxcblx0XHRcdFx0XHR6SW5kZXhPZmZzZXQ6IHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlTWFya2VyXG5cdFx0XHRcdC5vbignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0XHQuYWRkVG8odGhpcy5fbWFwKTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fb25Ub3VjaCwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXIuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLnJlbW92ZUhvb2tzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0Lm9mZignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0XHQub2ZmKCdjbGljaycsIHRoaXMuX29uVG91Y2gsIHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMuX21hcmtlcikge1xuXHRcdFx0XHR0aGlzLl9tYXJrZXIub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0XHQucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2VyKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX21hcmtlcjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbW91c2VNYXJrZXIub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21vdXNlTWFya2VyKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tb3VzZU1hcmtlcjtcblxuXHRcdFx0dGhpcy5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nO1xuXG5cdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVQb3NpdGlvbihsYXRsbmcpO1xuXHRcdHRoaXMuX21vdXNlTWFya2VyLnNldExhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKCF0aGlzLl9tYXJrZXIpIHtcblx0XHRcdHRoaXMuX21hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihsYXRsbmcpO1xuXHRcdFx0Ly8gQmluZCB0byBib3RoIG1hcmtlciBhbmQgbWFwIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgdGhlIGNsaWNrIGV2ZW50LlxuXHRcdFx0dGhpcy5fbWFya2VyLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0XHQuYWRkTGF5ZXIodGhpcy5fbWFya2VyKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tb3VzZU1hcmtlci5nZXRMYXRMbmcoKTtcblx0XHRcdHRoaXMuX21hcmtlci5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHJldHVybiBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG5cdFx0XHRpY29uOiB0aGlzLm9wdGlvbnMuaWNvbixcblx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldFxuXHRcdH0pO1xuXHR9LFxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZmlyZUNyZWF0ZWRFdmVudCgpO1xuXG5cdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXBlYXRNb2RlKSB7XG5cdFx0XHR0aGlzLmVuYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Ub3VjaDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBjYWxsZWQgb24gY2xpY2sgJiB0YXAsIG9ubHkgcmVhbGx5IGRvZXMgYW55IHRoaW5nIG9uIHRhcFxuXHRcdHRoaXMuX29uTW91c2VNb3ZlKGUpOyAvLyBjcmVhdGVzICYgcGxhY2VzIG1hcmtlclxuXHRcdHRoaXMuX29uQ2xpY2soKTsgLy8gcGVybWFuZW50bHkgcGxhY2VzIG1hcmtlciAmIGVuZHMgaW50ZXJhY3Rpb25cblx0fSxcblxuXHRfZmlyZUNyZWF0ZWRFdmVudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIuVG91Y2godGhpcy5fbWFya2VyLmdldExhdExuZygpLCB7aWNvbjogdGhpcy5vcHRpb25zLmljb259KTtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRHJhdy5DaXJjbGVNYXJrZXJcbiAqIEBha2EgRHJhdy5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBMLkRyYXcuTWFya2VyXG4gKi9cbkwuRHJhdy5DaXJjbGVNYXJrZXIgPSBMLkRyYXcuTWFya2VyLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnY2lyY2xlbWFya2VyJ1xuXHR9LFxuXG5cdG9wdGlvbnM6IHtcblx0XHRzdHJva2U6IHRydWUsXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblx0XHR3ZWlnaHQ6IDQsXG5cdFx0b3BhY2l0eTogMC41LFxuXHRcdGZpbGw6IHRydWUsXG5cdFx0ZmlsbENvbG9yOiBudWxsLCAvL3NhbWUgYXMgY29sb3IgYnkgZGVmYXVsdFxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cdFx0Y2xpY2thYmxlOiB0cnVlLFxuXHRcdHpJbmRleE9mZnNldDogMjAwMCAvLyBUaGlzIHNob3VsZCBiZSA+IHRoYW4gdGhlIGhpZ2hlc3Qgei1pbmRleCBhbnkgbWFya2Vyc1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHQvLyBTYXZlIHRoZSB0eXBlIHNvIHN1cGVyIGNhbiBmaXJlLCBuZWVkIHRvIGRvIHRoaXMgYXMgY2Fubm90IGRvIHRoaXMuVFlQRSA6KFxuXHRcdHRoaXMudHlwZSA9IEwuRHJhdy5DaXJjbGVNYXJrZXIuVFlQRTtcblxuXHRcdHRoaXMuX2luaXRpYWxMYWJlbFRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLmNpcmNsZW1hcmtlci50b29sdGlwLnN0YXJ0O1xuXG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXHR9LFxuXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2lyY2xlTWFya2VyID0gbmV3IEwuQ2lyY2xlTWFya2VyKHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKSwgdGhpcy5vcHRpb25zKTtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCBjaXJjbGVNYXJrZXIpO1xuXHR9LFxuXG5cdF9jcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHRyZXR1cm4gbmV3IEwuQ2lyY2xlTWFya2VyKGxhdGxuZywgdGhpcy5vcHRpb25zKTtcblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkRyYXcuQ2lyY2xlXG4gKiBAYWthIERyYXcuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgTC5EcmF3LlNpbXBsZVNoYXBlXG4gKi9cbkwuRHJhdy5DaXJjbGUgPSBMLkRyYXcuU2ltcGxlU2hhcGUuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdjaXJjbGUnXG5cdH0sXG5cblx0b3B0aW9uczoge1xuXHRcdHNoYXBlT3B0aW9uczoge1xuXHRcdFx0c3Ryb2tlOiB0cnVlLFxuXHRcdFx0Y29sb3I6ICcjMzM4OGZmJyxcblx0XHRcdHdlaWdodDogNCxcblx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRmaWxsQ29sb3I6IG51bGwsIC8vc2FtZSBhcyBjb2xvciBieSBkZWZhdWx0XG5cdFx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXHRcdFx0Y2xpY2thYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRzaG93UmFkaXVzOiB0cnVlLFxuXHRcdG1ldHJpYzogdHJ1ZSwgLy8gV2hldGhlciB0byB1c2UgdGhlIG1ldHJpYyBtZWFzdXJlbWVudCBzeXN0ZW0gb3IgaW1wZXJpYWxcblx0XHRmZWV0OiB0cnVlLCAvLyBXaGVuIG5vdCBtZXRyaWMsIHVzZSBmZWV0IGluc3RlYWQgb2YgeWFyZHMgZm9yIGRpc3BsYXlcblx0XHRuYXV0aWM6IGZhbHNlIC8vIFdoZW4gbm90IG1ldHJpYywgbm90IGZlZXQgdXNlIG5hdXRpYyBtaWxlIGZvciBkaXNwbGF5XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdC8vIFNhdmUgdGhlIHR5cGUgc28gc3VwZXIgY2FuIGZpcmUsIG5lZWQgdG8gZG8gdGhpcyBhcyBjYW5ub3QgZG8gdGhpcy5UWVBFIDooXG5cdFx0dGhpcy50eXBlID0gTC5EcmF3LkNpcmNsZS5UWVBFO1xuXG5cdFx0dGhpcy5faW5pdGlhbExhYmVsVGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMuY2lyY2xlLnRvb2x0aXAuc3RhcnQ7XG5cblx0XHRMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9kcmF3U2hhcGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHQvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJhc2VkIG9uIHRoZSB2ZXJzaW9uXG5cdFx0aWYgKEwuR2VvbWV0cnlVdGlsLmlzVmVyc2lvbjA3eCgpKSB7XG5cdFx0XHR2YXIgZGlzdGFuY2UgPSB0aGlzLl9zdGFydExhdExuZy5kaXN0YW5jZVRvKGxhdGxuZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkaXN0YW5jZSA9IHRoaXMuX21hcC5kaXN0YW5jZSh0aGlzLl9zdGFydExhdExuZywgbGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3NoYXBlKSB7XG5cdFx0XHR0aGlzLl9zaGFwZSA9IG5ldyBMLkNpcmNsZSh0aGlzLl9zdGFydExhdExuZywgZGlzdGFuY2UsIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX3NoYXBlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc2hhcGUuc2V0UmFkaXVzKGRpc3RhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2lyY2xlID0gbmV3IEwuQ2lyY2xlKHRoaXMuX3N0YXJ0TGF0TG5nLCB0aGlzLl9zaGFwZS5nZXRSYWRpdXMoKSwgdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyk7XG5cdFx0TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fZmlyZUNyZWF0ZWRFdmVudC5jYWxsKHRoaXMsIGNpcmNsZSk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZyxcblx0XHRcdHNob3dSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hvd1JhZGl1cyxcblx0XHRcdHVzZU1ldHJpYyA9IHRoaXMub3B0aW9ucy5tZXRyaWMsXG5cdFx0XHRyYWRpdXM7XG5cblx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGxhdGxuZyk7XG5cdFx0aWYgKHRoaXMuX2lzRHJhd2luZykge1xuXHRcdFx0dGhpcy5fZHJhd1NoYXBlKGxhdGxuZyk7XG5cblx0XHRcdC8vIEdldCB0aGUgbmV3IHJhZGl1cyAocm91bmRlZCB0byAxIGRwKVxuXHRcdFx0cmFkaXVzID0gdGhpcy5fc2hhcGUuZ2V0UmFkaXVzKCkudG9GaXhlZCgxKTtcblxuXHRcdFx0dmFyIHN1YnRleHQgPSAnJztcblx0XHRcdGlmIChzaG93UmFkaXVzKSB7XG5cdFx0XHRcdHN1YnRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLmNpcmNsZS5yYWRpdXMgKyAnOiAnICtcblx0XHRcdFx0XHRMLkdlb21ldHJ5VXRpbC5yZWFkYWJsZURpc3RhbmNlKHJhZGl1cywgdXNlTWV0cmljLCB0aGlzLm9wdGlvbnMuZmVldCwgdGhpcy5vcHRpb25zLm5hdXRpYyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe1xuXHRcdFx0XHR0ZXh0OiB0aGlzLl9lbmRMYWJlbFRleHQsXG5cdFx0XHRcdHN1YnRleHQ6IHN1YnRleHRcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG5cbi8qKlxuICogQGNsYXNzIEwuRWRpdC5NYXJrZXJcbiAqIEBha2EgRWRpdC5NYXJrZXJcbiAqL1xuTC5FZGl0Lk1hcmtlciA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHQvLyBAbWV0aG9kIGluaXRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkIGxpc3RlbmVyIGhvb2tzIHRvIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXI7XG5cblx0XHRtYXJrZXIuZHJhZ2dpbmcuZW5hYmxlKCk7XG5cdFx0bWFya2VyLm9uKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCBtYXJrZXIpO1xuXHRcdHRoaXMuX3RvZ2dsZU1hcmtlckhpZ2hsaWdodCgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyO1xuXG5cdFx0bWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcblx0XHRtYXJrZXIub2ZmKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCBtYXJrZXIpO1xuXHRcdHRoaXMuX3RvZ2dsZU1hcmtlckhpZ2hsaWdodCgpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS50YXJnZXQ7XG5cdFx0bGF5ZXIuZWRpdGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVE1PVkUsIHtsYXllcjogbGF5ZXJ9KTtcblx0fSxcblxuXHRfdG9nZ2xlTWFya2VySGlnaGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHQvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGxheWVyIGlzIGEgbWFya2VyIGJ1dCBkb2Vzbid0IGhhdmUgYW4gaWNvbi4gTWFya2Vyc1xuXHRcdC8vIHNob3VsZCB1c3VhbGx5IGhhdmUgaWNvbnMuIElmIHVzaW5nIExlYWZsZXQuZHJhdyB3aXRoIExlYWZsZXQubWFya2VyY2x1c3RlciB0aGVyZVxuXHRcdC8vIGlzIGEgY2hhbmNlIHRoYXQgYSBtYXJrZXIgZG9lc24ndC5cblx0XHRpZiAoIWljb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBUaGlzIGlzIHF1aXRlIG5hdWdodHksIGJ1dCBJIGRvbid0IHNlZSBhbm90aGVyIHdheSBvZiBkb2luZyBpdC4gKHNob3J0IG9mIHNldHRpbmcgYSBuZXcgaWNvbilcblx0XHRpY29uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cblx0XHRpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKGljb24sICdsZWFmbGV0LWVkaXQtbWFya2VyLXNlbGVjdGVkJykpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhpY29uLCAnbGVhZmxldC1lZGl0LW1hcmtlci1zZWxlY3RlZCcpO1xuXHRcdFx0Ly8gT2Zmc2V0IGFzIHRoZSBib3JkZXIgd2lsbCBtYWtlIHRoZSBpY29uIG1vdmUuXG5cdFx0XHR0aGlzLl9vZmZzZXRNYXJrZXIoaWNvbiwgLTQpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCAnbGVhZmxldC1lZGl0LW1hcmtlci1zZWxlY3RlZCcpO1xuXHRcdFx0Ly8gT2Zmc2V0IGFzIHRoZSBib3JkZXIgd2lsbCBtYWtlIHRoZSBpY29uIG1vdmUuXG5cdFx0XHR0aGlzLl9vZmZzZXRNYXJrZXIoaWNvbiwgNCk7XG5cdFx0fVxuXG5cdFx0aWNvbi5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cdH0sXG5cblx0X29mZnNldE1hcmtlcjogZnVuY3Rpb24gKGljb24sIG9mZnNldCkge1xuXHRcdHZhciBpY29uTWFyZ2luVG9wID0gcGFyc2VJbnQoaWNvbi5zdHlsZS5tYXJnaW5Ub3AsIDEwKSAtIG9mZnNldCxcblx0XHRcdGljb25NYXJnaW5MZWZ0ID0gcGFyc2VJbnQoaWNvbi5zdHlsZS5tYXJnaW5MZWZ0LCAxMCkgLSBvZmZzZXQ7XG5cblx0XHRpY29uLnN0eWxlLm1hcmdpblRvcCA9IGljb25NYXJnaW5Ub3AgKyAncHgnO1xuXHRcdGljb24uc3R5bGUubWFyZ2luTGVmdCA9IGljb25NYXJnaW5MZWZ0ICsgJ3B4Jztcblx0fVxufSk7XG5cbkwuTWFya2VyLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0aWYgKEwuRWRpdC5NYXJrZXIpIHtcblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0Lk1hcmtlcih0aGlzKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5lbmFibGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuTC5FZGl0ID0gTC5FZGl0IHx8IHt9O1xuXG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuUG9seWxpbmVcbiAqIEBha2EgTC5FZGl0LlBvbHlcbiAqIEBha2EgRWRpdC5Qb2x5XG4gKi9cbkwuRWRpdC5Qb2x5ID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChwb2x5KSB7XG5cblx0XHR0aGlzLmxhdGxuZ3MgPSBbcG9seS5fbGF0bG5nc107XG5cdFx0aWYgKHBvbHkuX2hvbGVzKSB7XG5cdFx0XHR0aGlzLmxhdGxuZ3MgPSB0aGlzLmxhdGxuZ3MuY29uY2F0KHBvbHkuX2hvbGVzKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2x5ID0gcG9seTtcblxuXHRcdHRoaXMuX3BvbHkub24oJ3JldmVydC1lZGl0ZWQnLCB0aGlzLl91cGRhdGVMYXRMbmdzLCB0aGlzKTtcblx0fSxcblxuXHQvLyBDb21wYXRpYmlsaXR5IG1ldGhvZCB0byBub3JtYWxpemUgUG9seSogb2JqZWN0c1xuXHQvLyBiZXR3ZWVuIDAuNy54IGFuZCAxLjArXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIUwuUG9seWxpbmUuX2ZsYXQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wb2x5Ll9sYXRsbmdzO1xuXHRcdH1cblx0XHRyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9wb2x5Ll9sYXRsbmdzKSA/IHRoaXMuX3BvbHkuX2xhdGxuZ3MgOiB0aGlzLl9wb2x5Ll9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdF9lYWNoVmVydGV4SGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl92ZXJ0aWNlc0hhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjYWxsYmFjayh0aGlzLl92ZXJ0aWNlc0hhbmRsZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXJcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0SGFuZGxlcnMoKTtcblx0XHR0aGlzLl9lYWNoVmVydGV4SGFuZGxlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlci5hZGRIb29rcygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9lYWNoVmVydGV4SGFuZGxlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlci5yZW1vdmVIb29rcygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdXBkYXRlTWFya2VycygpOiB2b2lkXG5cdC8vIEZpcmUgYW4gdXBkYXRlIGZvciBlYWNoIHZlcnRleCBoYW5kbGVyXG5cdHVwZGF0ZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9lYWNoVmVydGV4SGFuZGxlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlci51cGRhdGVNYXJrZXJzKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3ZlcnRpY2VzSGFuZGxlcnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGF0bG5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5fdmVydGljZXNIYW5kbGVycy5wdXNoKG5ldyBMLkVkaXQuUG9seVZlcnRpY2VzRWRpdCh0aGlzLl9wb2x5LCB0aGlzLmxhdGxuZ3NbaV0sIHRoaXMuX3BvbHkub3B0aW9ucy5wb2x5KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVMYXRMbmdzOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMubGF0bG5ncyA9IFtlLmxheWVyLl9sYXRsbmdzXTtcblx0XHRpZiAoZS5sYXllci5faG9sZXMpIHtcblx0XHRcdHRoaXMubGF0bG5ncyA9IHRoaXMubGF0bG5ncy5jb25jYXQoZS5sYXllci5faG9sZXMpO1xuXHRcdH1cblx0fVxuXG59KTtcblxuLyoqXG4gKiBAY2xhc3MgTC5FZGl0LlBvbHlWZXJ0aWNlc0VkaXRcbiAqIEBha2EgRWRpdC5Qb2x5VmVydGljZXNFZGl0XG4gKi9cbkwuRWRpdC5Qb2x5VmVydGljZXNFZGl0ID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRpY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24nXG5cdFx0fSksXG5cdFx0dG91Y2hJY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApLFxuXHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LXRvdWNoLWljb24nXG5cdFx0fSksXG5cdFx0ZHJhd0Vycm9yOiB7XG5cdFx0XHRjb2xvcjogJyNiMDBiMDAnLFxuXHRcdFx0dGltZW91dDogMTAwMFxuXHRcdH1cblxuXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAocG9seSwgbGF0bG5ncywgb3B0aW9ucykge1xuXHRcdC8vIGlmIHRvdWNoLCBzd2l0Y2ggdG8gdG91Y2ggaWNvblxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2gpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5pY29uID0gdGhpcy5vcHRpb25zLnRvdWNoSWNvbjtcblx0XHR9XG5cdFx0dGhpcy5fcG9seSA9IHBvbHk7XG5cblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRyYXdFcnJvcikge1xuXHRcdFx0b3B0aW9ucy5kcmF3RXJyb3IgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLCBvcHRpb25zLmRyYXdFcnJvcik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF0bG5ncyA9IGxhdGxuZ3M7XG5cblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQ29tcGF0aWJpbGl0eSBtZXRob2QgdG8gbm9ybWFsaXplIFBvbHkqIG9iamVjdHNcblx0Ly8gYmV0d2VlbiAwLjcueCBhbmQgMS4wK1xuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCFMLlBvbHlsaW5lLl9mbGF0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0XHR9XG5cdFx0cmV0dXJuIEwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkIGxpc3RlbmVyIGhvb2tzIHRvIHRoaXMgaGFuZGxlci5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9seSA9IHRoaXMuX3BvbHk7XG5cdFx0dmFyIHBhdGggPSBwb2x5Ll9wYXRoO1xuXG5cdFx0aWYgKCEocG9seSBpbnN0YW5jZW9mIEwuUG9seWdvbikpIHtcblx0XHRcdHBvbHkub3B0aW9ucy5maWxsID0gZmFsc2U7XG5cdFx0XHRpZiAocG9seS5vcHRpb25zLmVkaXRpbmcpIHtcblx0XHRcdFx0cG9seS5vcHRpb25zLmVkaXRpbmcuZmlsbCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAocG9seS5vcHRpb25zLmVkaXRpbmcgJiYgcG9seS5vcHRpb25zLmVkaXRpbmcuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGlmIChwb2x5Lm9wdGlvbnMub3JpZ2luYWwuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0cG9seS5vcHRpb25zLm9yaWdpbmFsLmNsYXNzTmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHBhdGgsIGNsYXNzTmFtZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9seS5vcHRpb25zLmVkaXRpbmcuY2xhc3NOYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhdGgsIGNsYXNzTmFtZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHBvbHkuc2V0U3R5bGUocG9seS5vcHRpb25zLmVkaXRpbmcpO1xuXG5cdFx0aWYgKHRoaXMuX3BvbHkuX21hcCkge1xuXG5cdFx0XHR0aGlzLl9tYXAgPSB0aGlzLl9wb2x5Ll9tYXA7IC8vIFNldCBtYXBcblxuXHRcdFx0aWYgKCF0aGlzLl9tYXJrZXJHcm91cCkge1xuXHRcdFx0XHR0aGlzLl9pbml0TWFya2VycygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcG9seS5fbWFwLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmcm9tIHRoaXMgaGFuZGxlci5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9seSA9IHRoaXMuX3BvbHk7XG5cdFx0dmFyIHBhdGggPSBwb2x5Ll9wYXRoO1xuXG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdGlmIChwb2x5Lm9wdGlvbnMuZWRpdGluZyAmJiBwb2x5Lm9wdGlvbnMuZWRpdGluZy5jbGFzc05hbWUpIHtcblx0XHRcdFx0cG9seS5vcHRpb25zLmVkaXRpbmcuY2xhc3NOYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHBhdGgsIGNsYXNzTmFtZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAocG9seS5vcHRpb25zLm9yaWdpbmFsLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdHBvbHkub3B0aW9ucy5vcmlnaW5hbC5jbGFzc05hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRcdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBjbGFzc05hbWUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cG9seS5zZXRTdHlsZShwb2x5Lm9wdGlvbnMub3JpZ2luYWwpO1xuXG5cdFx0aWYgKHBvbHkuX21hcCkge1xuXHRcdFx0cG9seS5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXJHcm91cDtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXJzO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZU1hcmtlcnMoKTogdm9pZFxuXHQvLyBDbGVhciBtYXJrZXJzIGFuZCB1cGRhdGUgdGhlaXIgbG9jYXRpb25cblx0dXBkYXRlTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcmtlckdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cdFx0dGhpcy5faW5pdE1hcmtlcnMoKTtcblx0fSxcblxuXHRfaW5pdE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcmtlckdyb3VwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJHcm91cCA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblx0XHR9XG5cdFx0dGhpcy5fbWFya2VycyA9IFtdO1xuXG5cdFx0dmFyIGxhdGxuZ3MgPSB0aGlzLl9kZWZhdWx0U2hhcGUoKSxcblx0XHRcdGksIGosIGxlbiwgbWFya2VyO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHRtYXJrZXIgPSB0aGlzLl9jcmVhdGVNYXJrZXIobGF0bG5nc1tpXSwgaSk7XG5cdFx0XHRtYXJrZXIub24oJ2NsaWNrJywgdGhpcy5fb25NYXJrZXJDbGljaywgdGhpcyk7XG5cdFx0XHRtYXJrZXIub24oJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXJrZXJzLnB1c2gobWFya2VyKTtcblx0XHR9XG5cblx0XHR2YXIgbWFya2VyTGVmdCwgbWFya2VyUmlnaHQ7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0aWYgKGkgPT09IDAgJiYgIShMLlBvbHlnb24gJiYgKHRoaXMuX3BvbHkgaW5zdGFuY2VvZiBMLlBvbHlnb24pKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bWFya2VyTGVmdCA9IHRoaXMuX21hcmtlcnNbal07XG5cdFx0XHRtYXJrZXJSaWdodCA9IHRoaXMuX21hcmtlcnNbaV07XG5cblx0XHRcdHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihtYXJrZXJMZWZ0LCBtYXJrZXJSaWdodCk7XG5cdFx0XHR0aGlzLl91cGRhdGVQcmV2TmV4dChtYXJrZXJMZWZ0LCBtYXJrZXJSaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIGluZGV4KSB7XG5cdFx0Ly8gRXh0ZW5kaW5nIEwuTWFya2VyIGluIFRvdWNoRXZlbnRzLmpzIHRvIGluY2x1ZGUgdG91Y2guXG5cdFx0dmFyIG1hcmtlciA9IG5ldyBMLk1hcmtlci5Ub3VjaChsYXRsbmcsIHtcblx0XHRcdGRyYWdnYWJsZTogdHJ1ZSxcblx0XHRcdGljb246IHRoaXMub3B0aW9ucy5pY29uLFxuXHRcdH0pO1xuXG5cdFx0bWFya2VyLl9vcmlnTGF0TG5nID0gbGF0bG5nO1xuXHRcdG1hcmtlci5faW5kZXggPSBpbmRleDtcblxuXHRcdG1hcmtlclxuXHRcdFx0Lm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbk1hcmtlckRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vbignZHJhZycsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcylcblx0XHRcdC5vbignZHJhZ2VuZCcsIHRoaXMuX2ZpcmVFZGl0LCB0aGlzKVxuXHRcdFx0Lm9uKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdC5vbigndG91Y2hlbmQnLCB0aGlzLl9maXJlRWRpdCwgdGhpcylcblx0XHRcdC5vbignTVNQb2ludGVyTW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdFx0Lm9uKCdNU1BvaW50ZXJVcCcsIHRoaXMuX2ZpcmVFZGl0LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcmtlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cblx0XHRyZXR1cm4gbWFya2VyO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvbHkuZmlyZSgnZWRpdHN0YXJ0Jyk7XG5cdH0sXG5cblx0X3NwbGljZUxhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdHZhciByZW1vdmVkID0gW10uc3BsaWNlLmFwcGx5KGxhdGxuZ3MsIGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fcG9seS5fY29udmVydExhdExuZ3MobGF0bG5ncywgdHJ1ZSk7XG5cdFx0dGhpcy5fcG9seS5yZWRyYXcoKTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRfcmVtb3ZlTWFya2VyOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dmFyIGkgPSBtYXJrZXIuX2luZGV4O1xuXG5cdFx0dGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIobWFya2VyKTtcblx0XHR0aGlzLl9tYXJrZXJzLnNwbGljZShpLCAxKTtcblx0XHR0aGlzLl9zcGxpY2VMYXRMbmdzKGksIDEpO1xuXHRcdHRoaXMuX3VwZGF0ZUluZGV4ZXMoaSwgLTEpO1xuXG5cdFx0bWFya2VyXG5cdFx0XHQub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9vbk1hcmtlckRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vZmYoJ2RyYWcnLCB0aGlzLl9vbk1hcmtlckRyYWcsIHRoaXMpXG5cdFx0XHQub2ZmKCdkcmFnZW5kJywgdGhpcy5fZmlyZUVkaXQsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1hcmtlckRyYWcsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaGVuZCcsIHRoaXMuX2ZpcmVFZGl0LCB0aGlzKVxuXHRcdFx0Lm9mZignY2xpY2snLCB0aGlzLl9vbk1hcmtlckNsaWNrLCB0aGlzKVxuXHRcdFx0Lm9mZignTVNQb2ludGVyTW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdFx0Lm9mZignTVNQb2ludGVyVXAnLCB0aGlzLl9maXJlRWRpdCwgdGhpcyk7XG5cdH0sXG5cblx0X2ZpcmVFZGl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9seS5lZGl0ZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3BvbHkuZmlyZSgnZWRpdCcpO1xuXHRcdHRoaXMuX3BvbHkuX21hcC5maXJlKEwuRHJhdy5FdmVudC5FRElUVkVSVEVYLCB7bGF5ZXJzOiB0aGlzLl9tYXJrZXJHcm91cCwgcG9seTogdGhpcy5fcG9seX0pO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IGUudGFyZ2V0O1xuXHRcdHZhciBwb2x5ID0gdGhpcy5fcG9seTtcblxuXHRcdHZhciBvbGRPcmlnTGF0TG5nID0gTC5MYXRMbmdVdGlsLmNsb25lTGF0TG5nKG1hcmtlci5fb3JpZ0xhdExuZyk7XG5cdFx0TC5leHRlbmQobWFya2VyLl9vcmlnTGF0TG5nLCBtYXJrZXIuX2xhdGxuZyk7XG5cdFx0aWYgKHBvbHkub3B0aW9ucy5wb2x5KSB7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IHBvbHkuX21hcC5fZWRpdFRvb2x0aXA7IC8vIEFjY2VzcyB0aGUgdG9vbHRpcFxuXG5cdFx0XHQvLyBJZiB3ZSBkb24ndCBhbGxvdyBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgcG9seWdvbiBpbnRlcnNlY3RzXG5cdFx0XHRpZiAoIXBvbHkub3B0aW9ucy5wb2x5LmFsbG93SW50ZXJzZWN0aW9uICYmIHBvbHkuaW50ZXJzZWN0cygpKSB7XG5cdFx0XHRcdEwuZXh0ZW5kKG1hcmtlci5fb3JpZ0xhdExuZywgb2xkT3JpZ0xhdExuZyk7XG5cdFx0XHRcdG1hcmtlci5zZXRMYXRMbmcob2xkT3JpZ0xhdExuZyk7XG5cdFx0XHRcdHZhciBvcmlnaW5hbENvbG9yID0gcG9seS5vcHRpb25zLmNvbG9yO1xuXHRcdFx0XHRwb2x5LnNldFN0eWxlKHtjb2xvcjogdGhpcy5vcHRpb25zLmRyYXdFcnJvci5jb2xvcn0pO1xuXHRcdFx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0XHRcdHRvb2x0aXAudXBkYXRlQ29udGVudCh7XG5cdFx0XHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlsaW5lLmVycm9yXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCBldmVyeXRoaW5nIGJhY2sgdG8gbm9ybWFsIGFmdGVyIGEgc2Vjb25kXG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHBvbHkuc2V0U3R5bGUoe2NvbG9yOiBvcmlnaW5hbENvbG9yfSk7XG5cdFx0XHRcdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdFx0XHRcdHRvb2x0aXAudXBkYXRlQ29udGVudCh7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnRleHQsXG5cdFx0XHRcdFx0XHRcdHN1YnRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnN1YnRleHRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgMTAwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlTGVmdCkge1xuXHRcdFx0bWFya2VyLl9taWRkbGVMZWZ0LnNldExhdExuZyh0aGlzLl9nZXRNaWRkbGVMYXRMbmcobWFya2VyLl9wcmV2LCBtYXJrZXIpKTtcblx0XHR9XG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlUmlnaHQpIHtcblx0XHRcdG1hcmtlci5fbWlkZGxlUmlnaHQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIsIG1hcmtlci5fbmV4dCkpO1xuXHRcdH1cblxuXHRcdC8vcmVmcmVzaCB0aGUgYm91bmRzIHdoZW4gZHJhZ2luZ1xuXHRcdHRoaXMuX3BvbHkuX2JvdW5kcy5fc291dGhXZXN0ID0gTC5sYXRMbmcoSW5maW5pdHksIEluZmluaXR5KTtcblx0XHR0aGlzLl9wb2x5Ll9ib3VuZHMuX25vcnRoRWFzdCA9IEwubGF0TG5nKC1JbmZpbml0eSwgLUluZmluaXR5KTtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpO1xuXHRcdHRoaXMuX3BvbHkuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MsIHRydWUpO1xuXHRcdHRoaXMuX3BvbHkucmVkcmF3KCk7XG5cdFx0dGhpcy5fcG9seS5maXJlKCdlZGl0ZHJhZycpO1xuXHR9LFxuXG5cdF9vbk1hcmtlckNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0dmFyIG1pblBvaW50cyA9IEwuUG9seWdvbiAmJiAodGhpcy5fcG9seSBpbnN0YW5jZW9mIEwuUG9seWdvbikgPyA0IDogMyxcblx0XHRcdG1hcmtlciA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gSWYgcmVtb3ZpbmcgdGhpcyBwb2ludCB3b3VsZCBjcmVhdGUgYW4gaW52YWxpZCBwb2x5bGluZS9wb2x5Z29uIGRvbid0IHJlbW92ZVxuXHRcdGlmICh0aGlzLl9kZWZhdWx0U2hhcGUoKS5sZW5ndGggPCBtaW5Qb2ludHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyByZW1vdmUgdGhlIG1hcmtlclxuXHRcdHRoaXMuX3JlbW92ZU1hcmtlcihtYXJrZXIpO1xuXG5cdFx0Ly8gdXBkYXRlIHByZXYvbmV4dCBsaW5rcyBvZiBhZGphY2VudCBtYXJrZXJzXG5cdFx0dGhpcy5fdXBkYXRlUHJldk5leHQobWFya2VyLl9wcmV2LCBtYXJrZXIuX25leHQpO1xuXG5cdFx0Ly8gcmVtb3ZlIGdob3N0IG1hcmtlcnMgbmVhciB0aGUgcmVtb3ZlZCBtYXJrZXJcblx0XHRpZiAobWFya2VyLl9taWRkbGVMZWZ0KSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihtYXJrZXIuX21pZGRsZUxlZnQpO1xuXHRcdH1cblx0XHRpZiAobWFya2VyLl9taWRkbGVSaWdodCkge1xuXHRcdFx0dGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIobWFya2VyLl9taWRkbGVSaWdodCk7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIGEgZ2hvc3QgbWFya2VyIGluIHBsYWNlIG9mIHRoZSByZW1vdmVkIG9uZVxuXHRcdGlmIChtYXJrZXIuX3ByZXYgJiYgbWFya2VyLl9uZXh0KSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobWFya2VyLl9wcmV2LCBtYXJrZXIuX25leHQpO1xuXG5cdFx0fSBlbHNlIGlmICghbWFya2VyLl9wcmV2KSB7XG5cdFx0XHRtYXJrZXIuX25leHQuX21pZGRsZUxlZnQgPSBudWxsO1xuXG5cdFx0fSBlbHNlIGlmICghbWFya2VyLl9uZXh0KSB7XG5cdFx0XHRtYXJrZXIuX3ByZXYuX21pZGRsZVJpZ2h0ID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlzLl9maXJlRWRpdCgpO1xuXHR9LFxuXG5cdF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblx0XHR2YXIgcG9seSA9IHRoaXMuX3BvbHk7XG5cdFx0dGhpcy5fcG9seS5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50Lk1BUktFUkNPTlRFWFQsIHttYXJrZXI6IG1hcmtlciwgbGF5ZXJzOiB0aGlzLl9tYXJrZXJHcm91cCwgcG9seTogdGhpcy5fcG9seX0pO1xuXHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0pLFxuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KSxcblx0XHRcdG1hcmtlciA9IGUudGFyZ2V0O1xuXG5cdFx0TC5leHRlbmQobWFya2VyLl9vcmlnTGF0TG5nLCBsYXRsbmcpO1xuXG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlTGVmdCkge1xuXHRcdFx0bWFya2VyLl9taWRkbGVMZWZ0LnNldExhdExuZyh0aGlzLl9nZXRNaWRkbGVMYXRMbmcobWFya2VyLl9wcmV2LCBtYXJrZXIpKTtcblx0XHR9XG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlUmlnaHQpIHtcblx0XHRcdG1hcmtlci5fbWlkZGxlUmlnaHQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIsIG1hcmtlci5fbmV4dCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvbHkucmVkcmF3KCk7XG5cdFx0dGhpcy51cGRhdGVNYXJrZXJzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUluZGV4ZXM6IGZ1bmN0aW9uIChpbmRleCwgZGVsdGEpIHtcblx0XHR0aGlzLl9tYXJrZXJHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdFx0aWYgKG1hcmtlci5faW5kZXggPiBpbmRleCkge1xuXHRcdFx0XHRtYXJrZXIuX2luZGV4ICs9IGRlbHRhO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9jcmVhdGVNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChtYXJrZXIxLCBtYXJrZXIyKSB7XG5cdFx0dmFyIGxhdGxuZyA9IHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIxLCBtYXJrZXIyKSxcblx0XHRcdG1hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihsYXRsbmcpLFxuXHRcdFx0b25DbGljayxcblx0XHRcdG9uRHJhZ1N0YXJ0LFxuXHRcdFx0b25EcmFnRW5kO1xuXG5cdFx0bWFya2VyLnNldE9wYWNpdHkoMC42KTtcblxuXHRcdG1hcmtlcjEuX21pZGRsZVJpZ2h0ID0gbWFya2VyMi5fbWlkZGxlTGVmdCA9IG1hcmtlcjtcblxuXHRcdG9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0bWFya2VyLm9mZigndG91Y2htb3ZlJywgb25EcmFnU3RhcnQsIHRoaXMpO1xuXHRcdFx0dmFyIGkgPSBtYXJrZXIyLl9pbmRleDtcblxuXHRcdFx0bWFya2VyLl9pbmRleCA9IGk7XG5cblx0XHRcdG1hcmtlclxuXHRcdFx0XHQub2ZmKCdjbGljaycsIG9uQ2xpY2ssIHRoaXMpXG5cdFx0XHRcdC5vbignY2xpY2snLCB0aGlzLl9vbk1hcmtlckNsaWNrLCB0aGlzKTtcblxuXHRcdFx0bGF0bG5nLmxhdCA9IG1hcmtlci5nZXRMYXRMbmcoKS5sYXQ7XG5cdFx0XHRsYXRsbmcubG5nID0gbWFya2VyLmdldExhdExuZygpLmxuZztcblx0XHRcdHRoaXMuX3NwbGljZUxhdExuZ3MoaSwgMCwgbGF0bG5nKTtcblx0XHRcdHRoaXMuX21hcmtlcnMuc3BsaWNlKGksIDAsIG1hcmtlcik7XG5cblx0XHRcdG1hcmtlci5zZXRPcGFjaXR5KDEpO1xuXG5cdFx0XHR0aGlzLl91cGRhdGVJbmRleGVzKGksIDEpO1xuXHRcdFx0bWFya2VyMi5faW5kZXgrKztcblx0XHRcdHRoaXMuX3VwZGF0ZVByZXZOZXh0KG1hcmtlcjEsIG1hcmtlcik7XG5cdFx0XHR0aGlzLl91cGRhdGVQcmV2TmV4dChtYXJrZXIsIG1hcmtlcjIpO1xuXG5cdFx0XHR0aGlzLl9wb2x5LmZpcmUoJ2VkaXRzdGFydCcpO1xuXHRcdH07XG5cblx0XHRvbkRyYWdFbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRtYXJrZXIub2ZmKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCwgdGhpcyk7XG5cdFx0XHRtYXJrZXIub2ZmKCdkcmFnZW5kJywgb25EcmFnRW5kLCB0aGlzKTtcblx0XHRcdG1hcmtlci5vZmYoJ3RvdWNobW92ZScsIG9uRHJhZ1N0YXJ0LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fY3JlYXRlTWlkZGxlTWFya2VyKG1hcmtlcjEsIG1hcmtlcik7XG5cdFx0XHR0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobWFya2VyLCBtYXJrZXIyKTtcblx0XHR9O1xuXG5cdFx0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdG9uRHJhZ1N0YXJ0LmNhbGwodGhpcyk7XG5cdFx0XHRvbkRyYWdFbmQuY2FsbCh0aGlzKTtcblx0XHRcdHRoaXMuX2ZpcmVFZGl0KCk7XG5cdFx0fTtcblxuXHRcdG1hcmtlclxuXHRcdFx0Lm9uKCdjbGljaycsIG9uQ2xpY2ssIHRoaXMpXG5cdFx0XHQub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9uKCdkcmFnZW5kJywgb25EcmFnRW5kLCB0aGlzKVxuXHRcdFx0Lm9uKCd0b3VjaG1vdmUnLCBvbkRyYWdTdGFydCwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5hZGRMYXllcihtYXJrZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQcmV2TmV4dDogZnVuY3Rpb24gKG1hcmtlcjEsIG1hcmtlcjIpIHtcblx0XHRpZiAobWFya2VyMSkge1xuXHRcdFx0bWFya2VyMS5fbmV4dCA9IG1hcmtlcjI7XG5cdFx0fVxuXHRcdGlmIChtYXJrZXIyKSB7XG5cdFx0XHRtYXJrZXIyLl9wcmV2ID0gbWFya2VyMTtcblx0XHR9XG5cdH0sXG5cblx0X2dldE1pZGRsZUxhdExuZzogZnVuY3Rpb24gKG1hcmtlcjEsIG1hcmtlcjIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fcG9seS5fbWFwLFxuXHRcdFx0cDEgPSBtYXAucHJvamVjdChtYXJrZXIxLmdldExhdExuZygpKSxcblx0XHRcdHAyID0gbWFwLnByb2plY3QobWFya2VyMi5nZXRMYXRMbmcoKSk7XG5cblx0XHRyZXR1cm4gbWFwLnVucHJvamVjdChwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHR9XG59KTtcblxuTC5Qb2x5bGluZS5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGhhbmRsZXIgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4gVGhpcyBpcyB0byBzdXBwb3J0IHZlcnNpb25zIG9mIExlYWZsZXQgdGhhdCBzdGlsbCBoYXZlIEwuSGFuZGxlci5Qb2x5RWRpdFxuXHRpZiAodGhpcy5lZGl0aW5nKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKEwuRWRpdC5Qb2x5KSB7XG5cblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0LlBvbHkodGhpcyk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcuZW5hYmxlKCk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5vbignYWRkJywgZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmVkaXRpbmcgJiYgdGhpcy5lZGl0aW5nLmVuYWJsZWQoKSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLmFkZEhvb2tzKCk7XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZWRpdGluZyAmJiB0aGlzLmVkaXRpbmcuZW5hYmxlZCgpKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcucmVtb3ZlSG9va3MoKTtcblx0XHR9XG5cdH0pO1xufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuU2ltcGxlU2hhcGVcbiAqIEBha2EgRWRpdC5TaW1wbGVTaGFwZVxuICovXG5MLkVkaXQuU2ltcGxlU2hhcGUgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdG1vdmVJY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC1lZGl0LW1vdmUnXG5cdFx0fSksXG5cdFx0cmVzaXplSWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOCksXG5cdFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtZWRpdGluZy1pY29uIGxlYWZsZXQtZWRpdC1yZXNpemUnXG5cdFx0fSksXG5cdFx0dG91Y2hNb3ZlSWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoMjAsIDIwKSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC1lZGl0LW1vdmUgbGVhZmxldC10b3VjaC1pY29uJ1xuXHRcdH0pLFxuXHRcdHRvdWNoUmVzaXplSWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoMjAsIDIwKSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC1lZGl0LXJlc2l6ZSBsZWFmbGV0LXRvdWNoLWljb24nXG5cdFx0fSksXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoc2hhcGUsIG9wdGlvbnMpIHtcblx0XHQvLyBpZiB0b3VjaCwgc3dpdGNoIHRvIHRvdWNoIGljb25cblx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMubW92ZUljb24gPSB0aGlzLm9wdGlvbnMudG91Y2hNb3ZlSWNvbjtcblx0XHRcdHRoaXMub3B0aW9ucy5yZXNpemVJY29uID0gdGhpcy5vcHRpb25zLnRvdWNoUmVzaXplSWNvbjtcblx0XHR9XG5cblx0XHR0aGlzLl9zaGFwZSA9IHNoYXBlO1xuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKTogdm9pZFxuXHQvLyBBZGQgbGlzdGVuZXIgaG9va3MgdG8gdGhpcyBoYW5kbGVyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNoYXBlID0gdGhpcy5fc2hhcGU7XG5cdFx0aWYgKHRoaXMuX3NoYXBlLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcCA9IHRoaXMuX3NoYXBlLl9tYXA7XG5cdFx0XHRzaGFwZS5zZXRTdHlsZShzaGFwZS5vcHRpb25zLmVkaXRpbmcpO1xuXG5cdFx0XHRpZiAoc2hhcGUuX21hcCkge1xuXHRcdFx0XHR0aGlzLl9tYXAgPSBzaGFwZS5fbWFwO1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcmtlckdyb3VwKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdE1hcmtlcnMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKCk6IHZvaWRcblx0Ly8gUmVtb3ZlIGxpc3RlbmVyIGhvb2tzIGZyb20gdGhpcyBoYW5kbGVyXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNoYXBlID0gdGhpcy5fc2hhcGU7XG5cblx0XHRzaGFwZS5zZXRTdHlsZShzaGFwZS5vcHRpb25zLm9yaWdpbmFsKTtcblxuXHRcdGlmIChzaGFwZS5fbWFwKSB7XG5cdFx0XHR0aGlzLl91bmJpbmRNYXJrZXIodGhpcy5fbW92ZU1hcmtlcik7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fcmVzaXplTWFya2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fdW5iaW5kTWFya2VyKHRoaXMuX3Jlc2l6ZU1hcmtlcnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVzaXplTWFya2VycyA9IG51bGw7XG5cblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9tYXJrZXJHcm91cCk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbWFya2VyR3JvdXA7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZU1hcmtlcnMoKTogdm9pZFxuXHQvLyBSZW1vdmUgdGhlIGVkaXQgbWFya2VycyBmcm9tIHRoaXMgbGF5ZXJcblx0dXBkYXRlTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcmtlckdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cdFx0dGhpcy5faW5pdE1hcmtlcnMoKTtcblx0fSxcblxuXHRfaW5pdE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcmtlckdyb3VwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJHcm91cCA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgY2VudGVyIG1hcmtlclxuXHRcdHRoaXMuX2NyZWF0ZU1vdmVNYXJrZXIoKTtcblxuXHRcdC8vIENyZWF0ZSBlZGdlIG1hcmtlclxuXHRcdHRoaXMuX2NyZWF0ZVJlc2l6ZU1hcmtlcigpO1xuXHR9LFxuXG5cdF9jcmVhdGVNb3ZlTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fSxcblxuXHRfY3JlYXRlUmVzaXplTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fSxcblxuXHRfY3JlYXRlTWFya2VyOiBmdW5jdGlvbiAobGF0bG5nLCBpY29uKSB7XG5cdFx0Ly8gRXh0ZW5kaW5nIEwuTWFya2VyIGluIFRvdWNoRXZlbnRzLmpzIHRvIGluY2x1ZGUgdG91Y2guXG5cdFx0dmFyIG1hcmtlciA9IG5ldyBMLk1hcmtlci5Ub3VjaChsYXRsbmcsIHtcblx0XHRcdGRyYWdnYWJsZTogdHJ1ZSxcblx0XHRcdGljb246IGljb24sXG5cdFx0XHR6SW5kZXhPZmZzZXQ6IDEwXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9iaW5kTWFya2VyKG1hcmtlcik7XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5hZGRMYXllcihtYXJrZXIpO1xuXG5cdFx0cmV0dXJuIG1hcmtlcjtcblx0fSxcblxuXHRfYmluZE1hcmtlcjogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdG1hcmtlclxuXHRcdFx0Lm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbk1hcmtlckRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vbignZHJhZycsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcylcblx0XHRcdC5vbignZHJhZ2VuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcylcblx0XHRcdC5vbigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcylcblx0XHRcdC5vbigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHQub24oJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdC5vbigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKVxuXHRcdFx0Lm9uKCdNU1BvaW50ZXJVcCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXHR9LFxuXG5cdF91bmJpbmRNYXJrZXI6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHRtYXJrZXJcblx0XHRcdC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX29uTWFya2VyRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9mZignZHJhZycsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcylcblx0XHRcdC5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9vbk1hcmtlckRyYWdFbmQsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9mZigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHQub2ZmKCdNU1BvaW50ZXJNb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHQub2ZmKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpXG5cdFx0XHQub2ZmKCdNU1BvaW50ZXJVcCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gZS50YXJnZXQ7XG5cdFx0bWFya2VyLnNldE9wYWNpdHkoMCk7XG5cblx0XHR0aGlzLl9zaGFwZS5maXJlKCdlZGl0c3RhcnQnKTtcblx0fSxcblxuXHRfZmlyZUVkaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9zaGFwZS5lZGl0ZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3NoYXBlLmZpcmUoJ2VkaXQnKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldCxcblx0XHRcdGxhdGxuZyA9IG1hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdGlmIChtYXJrZXIgPT09IHRoaXMuX21vdmVNYXJrZXIpIHtcblx0XHRcdHRoaXMuX21vdmUobGF0bG5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVzaXplKGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2hhcGUucmVkcmF3KCk7XG5cdFx0dGhpcy5fc2hhcGUuZmlyZSgnZWRpdGRyYWcnKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblx0XHRtYXJrZXIuc2V0T3BhY2l0eSgxKTtcblxuXHRcdHRoaXMuX2ZpcmVFZGl0KCk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRMLkVkaXQuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9vbk1hcmtlckRyYWdTdGFydC5jYWxsKHRoaXMsIGUpO1xuXG5cdFx0aWYgKHR5cGVvZih0aGlzLl9nZXRDb3JuZXJzKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGUgb3Bwb3NpdGUgcG9pbnRcblx0XHRcdHZhciBjb3JuZXJzID0gdGhpcy5fZ2V0Q29ybmVycygpLFxuXHRcdFx0XHRtYXJrZXIgPSBlLnRhcmdldCxcblx0XHRcdFx0Y3VycmVudENvcm5lckluZGV4ID0gbWFya2VyLl9jb3JuZXJJbmRleDtcblxuXHRcdFx0bWFya2VyLnNldE9wYWNpdHkoMCk7XG5cblx0XHRcdC8vIENvcHllZCBmcm9tIEVkaXQuUmVjdGFuZ2xlLmpzIGxpbmUgMjMgX29uTWFya2VyRHJhZ1N0YXJ0KClcblx0XHRcdC8vIExhdGxuZyBpcyBudWxsIG90aGVyd2lzZS5cblx0XHRcdHRoaXMuX29wcG9zaXRlQ29ybmVyID0gY29ybmVyc1soY3VycmVudENvcm5lckluZGV4ICsgMikgJSA0XTtcblx0XHRcdHRoaXMuX3RvZ2dsZUNvcm5lck1hcmtlcnMoMCwgY3VycmVudENvcm5lckluZGV4KTtcblx0XHR9XG5cblx0XHR0aGlzLl9zaGFwZS5maXJlKCdlZGl0c3RhcnQnKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSksXG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpLFxuXHRcdFx0bWFya2VyID0gZS50YXJnZXQ7XG5cblx0XHRpZiAobWFya2VyID09PSB0aGlzLl9tb3ZlTWFya2VyKSB7XG5cdFx0XHR0aGlzLl9tb3ZlKGxhdGxuZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Jlc2l6ZShsYXRsbmcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYXBlLnJlZHJhdygpO1xuXG5cdFx0Ly8gcHJldmVudCB0b3VjaGNhbmNlbCBpbiBJT1Ncblx0XHQvLyBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblx0XHRtYXJrZXIuc2V0T3BhY2l0eSgxKTtcblx0XHR0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcblx0XHR0aGlzLl9maXJlRWRpdCgpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fVxufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuUmVjdGFuZ2xlXG4gKiBAYWthIEVkaXQuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgTC5FZGl0LlNpbXBsZVNoYXBlXG4gKi9cbkwuRWRpdC5SZWN0YW5nbGUgPSBMLkVkaXQuU2ltcGxlU2hhcGUuZXh0ZW5kKHtcblx0X2NyZWF0ZU1vdmVNYXJrZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fc2hhcGUuZ2V0Qm91bmRzKCksXG5cdFx0XHRjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cblx0XHR0aGlzLl9tb3ZlTWFya2VyID0gdGhpcy5fY3JlYXRlTWFya2VyKGNlbnRlciwgdGhpcy5vcHRpb25zLm1vdmVJY29uKTtcblx0fSxcblxuXHRfY3JlYXRlUmVzaXplTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9nZXRDb3JuZXJzKCk7XG5cblx0XHR0aGlzLl9yZXNpemVNYXJrZXJzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvcm5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9yZXNpemVNYXJrZXJzLnB1c2godGhpcy5fY3JlYXRlTWFya2VyKGNvcm5lcnNbaV0sIHRoaXMub3B0aW9ucy5yZXNpemVJY29uKSk7XG5cdFx0XHQvLyBNb25rZXkgaW4gdGhlIGNvcm5lciBpbmRleCBhcyB3ZSB3aWxsIG5lZWQgdG8ga25vdyB0aGlzIGZvciBkcmFnZ2luZ1xuXHRcdFx0dGhpcy5fcmVzaXplTWFya2Vyc1tpXS5fY29ybmVySW5kZXggPSBpO1xuXHRcdH1cblx0fSxcblxuXHRfb25NYXJrZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0TC5FZGl0LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fb25NYXJrZXJEcmFnU3RhcnQuY2FsbCh0aGlzLCBlKTtcblxuXHRcdC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIG9wcG9zaXRlIHBvaW50XG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9nZXRDb3JuZXJzKCksXG5cdFx0XHRtYXJrZXIgPSBlLnRhcmdldCxcblx0XHRcdGN1cnJlbnRDb3JuZXJJbmRleCA9IG1hcmtlci5fY29ybmVySW5kZXg7XG5cblx0XHR0aGlzLl9vcHBvc2l0ZUNvcm5lciA9IGNvcm5lcnNbKGN1cnJlbnRDb3JuZXJJbmRleCArIDIpICUgNF07XG5cblx0XHR0aGlzLl90b2dnbGVDb3JuZXJNYXJrZXJzKDAsIGN1cnJlbnRDb3JuZXJJbmRleCk7XG5cdH0sXG5cblx0X29uTWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gZS50YXJnZXQsXG5cdFx0XHRib3VuZHMsIGNlbnRlcjtcblxuXHRcdC8vIFJlc2V0IG1vdmUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBjZW50ZXJcblx0XHRpZiAobWFya2VyID09PSB0aGlzLl9tb3ZlTWFya2VyKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9zaGFwZS5nZXRCb3VuZHMoKTtcblx0XHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblxuXHRcdFx0bWFya2VyLnNldExhdExuZyhjZW50ZXIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RvZ2dsZUNvcm5lck1hcmtlcnMoMSk7XG5cblx0XHR0aGlzLl9yZXBvc2l0aW9uQ29ybmVyTWFya2VycygpO1xuXG5cdFx0TC5FZGl0LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fb25NYXJrZXJEcmFnRW5kLmNhbGwodGhpcywgZSk7XG5cdH0sXG5cblx0X21vdmU6IGZ1bmN0aW9uIChuZXdDZW50ZXIpIHtcblx0XHR2YXIgbGF0bG5ncyA9IHRoaXMuX3NoYXBlLl9kZWZhdWx0U2hhcGUgPyB0aGlzLl9zaGFwZS5fZGVmYXVsdFNoYXBlKCkgOiB0aGlzLl9zaGFwZS5nZXRMYXRMbmdzKCksXG5cdFx0XHRib3VuZHMgPSB0aGlzLl9zaGFwZS5nZXRCb3VuZHMoKSxcblx0XHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcblx0XHRcdG9mZnNldCwgbmV3TGF0TG5ncyA9IFtdO1xuXG5cdFx0Ly8gT2Zmc2V0IHRoZSBsYXRsbmdzIHRvIHRoZSBuZXcgY2VudGVyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0b2Zmc2V0ID0gW2xhdGxuZ3NbaV0ubGF0IC0gY2VudGVyLmxhdCwgbGF0bG5nc1tpXS5sbmcgLSBjZW50ZXIubG5nXTtcblx0XHRcdG5ld0xhdExuZ3MucHVzaChbbmV3Q2VudGVyLmxhdCArIG9mZnNldFswXSwgbmV3Q2VudGVyLmxuZyArIG9mZnNldFsxXV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYXBlLnNldExhdExuZ3MobmV3TGF0TG5ncyk7XG5cblx0XHQvLyBSZXBvc2l0aW9uIHRoZSByZXNpemUgbWFya2Vyc1xuXHRcdHRoaXMuX3JlcG9zaXRpb25Db3JuZXJNYXJrZXJzKCk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVE1PVkUsIHtsYXllcjogdGhpcy5fc2hhcGV9KTtcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIGJvdW5kcztcblxuXHRcdC8vIFVwZGF0ZSB0aGUgc2hhcGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhpcyBjb3JuZXIgYW5kIHRoZSBvcHBvc2l0ZSBwb2ludFxuXHRcdHRoaXMuX3NoYXBlLnNldEJvdW5kcyhMLmxhdExuZ0JvdW5kcyhsYXRsbmcsIHRoaXMuX29wcG9zaXRlQ29ybmVyKSk7XG5cblx0XHQvLyBSZXBvc2l0aW9uIHRoZSBtb3ZlIG1hcmtlclxuXHRcdGJvdW5kcyA9IHRoaXMuX3NoYXBlLmdldEJvdW5kcygpO1xuXHRcdHRoaXMuX21vdmVNYXJrZXIuc2V0TGF0TG5nKGJvdW5kcy5nZXRDZW50ZXIoKSk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFJFU0laRSwge2xheWVyOiB0aGlzLl9zaGFwZX0pO1xuXHR9LFxuXG5cdF9nZXRDb3JuZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3NoYXBlLmdldEJvdW5kcygpLFxuXHRcdFx0bncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxuXHRcdFx0c3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCk7XG5cblx0XHRyZXR1cm4gW253LCBuZSwgc2UsIHN3XTtcblx0fSxcblxuXHRfdG9nZ2xlQ29ybmVyTWFya2VyczogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3Jlc2l6ZU1hcmtlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9yZXNpemVNYXJrZXJzW2ldLnNldE9wYWNpdHkob3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXBvc2l0aW9uQ29ybmVyTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fZ2V0Q29ybmVycygpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9yZXNpemVNYXJrZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fcmVzaXplTWFya2Vyc1tpXS5zZXRMYXRMbmcoY29ybmVyc1tpXSk7XG5cdFx0fVxuXHR9XG59KTtcblxuTC5SZWN0YW5nbGUuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXHRpZiAoTC5FZGl0LlJlY3RhbmdsZSkge1xuXHRcdHRoaXMuZWRpdGluZyA9IG5ldyBMLkVkaXQuUmVjdGFuZ2xlKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLmVuYWJsZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkVkaXQuQ2lyY2xlTWFya2VyXG4gKiBAYWthIEVkaXQuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgTC5FZGl0LlNpbXBsZVNoYXBlXG4gKi9cbkwuRWRpdC5DaXJjbGVNYXJrZXIgPSBMLkVkaXQuU2ltcGxlU2hhcGUuZXh0ZW5kKHtcblx0X2NyZWF0ZU1vdmVNYXJrZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2VudGVyID0gdGhpcy5fc2hhcGUuZ2V0TGF0TG5nKCk7XG5cblx0XHR0aGlzLl9tb3ZlTWFya2VyID0gdGhpcy5fY3JlYXRlTWFya2VyKGNlbnRlciwgdGhpcy5vcHRpb25zLm1vdmVJY29uKTtcblx0fSxcblxuXHRfY3JlYXRlUmVzaXplTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVG8gYXZvaWQgYW4gdW5kZWZpbmVkIGNoZWNrIGluIEwuRWRpdC5TaW1wbGVTaGFwZS5yZW1vdmVIb29rc1xuXHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnMgPSBbXTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl9yZXNpemVNYXJrZXJzLmxlbmd0aCkge1xuXHRcdFx0dmFyIHJlc2l6ZW1hcmtlclBvaW50ID0gdGhpcy5fZ2V0UmVzaXplTWFya2VyUG9pbnQobGF0bG5nKTtcblx0XHRcdC8vIE1vdmUgdGhlIHJlc2l6ZSBtYXJrZXJcblx0XHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnNbMF0uc2V0TGF0TG5nKHJlc2l6ZW1hcmtlclBvaW50KTtcblx0XHR9XG5cblx0XHQvLyBNb3ZlIHRoZSBjaXJjbGVcblx0XHR0aGlzLl9zaGFwZS5zZXRMYXRMbmcobGF0bG5nKTtcblxuXHRcdHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5FRElUTU9WRSwge2xheWVyOiB0aGlzLl9zaGFwZX0pO1xuXHR9LFxufSk7XG5cbkwuQ2lyY2xlTWFya2VyLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0aWYgKEwuRWRpdC5DaXJjbGVNYXJrZXIpIHtcblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0LkNpcmNsZU1hcmtlcih0aGlzKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5lbmFibGUoKTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLm9uKCdhZGQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZWRpdGluZyAmJiB0aGlzLmVkaXRpbmcuZW5hYmxlZCgpKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcuYWRkSG9va3MoKTtcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5lZGl0aW5nICYmIHRoaXMuZWRpdGluZy5lbmFibGVkKCkpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5yZW1vdmVIb29rcygpO1xuXHRcdH1cblx0fSk7XG59KTtcblxuXG5cbkwuRWRpdCA9IEwuRWRpdCB8fCB7fTtcbi8qKlxuICogQGNsYXNzIEwuRWRpdC5DaXJjbGVcbiAqIEBha2EgRWRpdC5DaXJjbGVcbiAqIEBpbmhlcml0cyBMLkVkaXQuQ2lyY2xlTWFya2VyXG4gKi9cbkwuRWRpdC5DaXJjbGUgPSBMLkVkaXQuQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0X2NyZWF0ZVJlc2l6ZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjZW50ZXIgPSB0aGlzLl9zaGFwZS5nZXRMYXRMbmcoKSxcblx0XHRcdHJlc2l6ZW1hcmtlclBvaW50ID0gdGhpcy5fZ2V0UmVzaXplTWFya2VyUG9pbnQoY2VudGVyKTtcblxuXHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnMgPSBbXTtcblx0XHR0aGlzLl9yZXNpemVNYXJrZXJzLnB1c2godGhpcy5fY3JlYXRlTWFya2VyKHJlc2l6ZW1hcmtlclBvaW50LCB0aGlzLm9wdGlvbnMucmVzaXplSWNvbikpO1xuXHR9LFxuXG5cdF9nZXRSZXNpemVNYXJrZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdC8vIEZyb20gTC5zaGFwZS5nZXRCb3VuZHMoKVxuXHRcdHZhciBkZWx0YSA9IHRoaXMuX3NoYXBlLl9yYWRpdXMgKiBNYXRoLmNvcyhNYXRoLlBJIC8gNCksXG5cdFx0XHRwb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC51bnByb2plY3QoW3BvaW50LnggKyBkZWx0YSwgcG9pbnQueSAtIGRlbHRhXSk7XG5cdH0sXG5cblx0X3Jlc2l6ZTogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBtb3ZlTGF0TG5nID0gdGhpcy5fbW92ZU1hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgcmFkaXVzIGJhc2VkIG9uIHRoZSB2ZXJzaW9uXG5cdFx0aWYgKEwuR2VvbWV0cnlVdGlsLmlzVmVyc2lvbjA3eCgpKSB7XG5cdFx0XHRyYWRpdXMgPSBtb3ZlTGF0TG5nLmRpc3RhbmNlVG8obGF0bG5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gdGhpcy5fbWFwLmRpc3RhbmNlKG1vdmVMYXRMbmcsIGxhdGxuZyk7XG5cdFx0fVxuXHRcdHRoaXMuX3NoYXBlLnNldFJhZGl1cyhyYWRpdXMpO1xuXG5cdFx0aWYgKHRoaXMuX21hcC5lZGl0VG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fbWFwLl9lZGl0VG9vbHRpcC51cGRhdGVDb250ZW50KHtcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAuc3VidGV4dCArICc8YnIgLz4nICsgTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxcblx0XHRcdFx0c3VidGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5jaXJjbGUucmFkaXVzICsgJzogJyArXG5cdFx0XHRcdEwuR2VvbWV0cnlVdGlsLnJlYWRhYmxlRGlzdGFuY2UocmFkaXVzLCB0cnVlLCB0aGlzLm9wdGlvbnMuZmVldCwgdGhpcy5vcHRpb25zLm5hdXRpYylcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYXBlLnNldFJhZGl1cyhyYWRpdXMpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRSRVNJWkUsIHtsYXllcjogdGhpcy5fc2hhcGV9KTtcblx0fVxufSk7XG5cbkwuQ2lyY2xlLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0aWYgKEwuRWRpdC5DaXJjbGUpIHtcblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0LkNpcmNsZSh0aGlzKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5lbmFibGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0dG91Y2hFeHRlbmQ6IHRydWVcbn0pO1xuXG4vKipcbiAqIEBjbGFzcyBMLk1hcC5Ub3VjaEV4dGVuZFxuICogQGFrYSBUb3VjaEV4dGVuZFxuICovXG5MLk1hcC5Ub3VjaEV4dGVuZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgaW5pdGlhbGl6ZSgpOiB2b2lkXG5cdC8vIFNldHMgVG91Y2hFeHRlbmQgcHJpdmF0ZSBhY2Nlc3NvciB2YXJpYWJsZXNcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKCk6IHZvaWRcblx0Ly8gQWRkcyBkb20gbGlzdGVuZXIgZXZlbnRzIHRvIHRoZSBtYXAgY29udGFpbmVyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0aWYgKHRoaXMuX2RldGVjdElFKCkpIHtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnTVNQb2ludGVyRG93bicsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlclVwJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlckNhbmNlbCcsIHRoaXMuX29uVG91Y2hDYW5jZWwsIHRoaXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoQ2FuY2VsLCB0aGlzKTtcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAndG91Y2hsZWF2ZScsIHRoaXMuX29uVG91Y2hMZWF2ZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmVzIGRvbSBsaXN0ZW5lciBldmVudHMgZnJvbSB0aGUgbWFwIGNvbnRhaW5lclxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdGlmICh0aGlzLl9kZXRlY3RJRSgpKSB7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdNU1BvaW50ZXJEb3duJywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ01TUG9pbnRlclVwJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdNU1BvaW50ZXJNb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnTVNQb2ludGVyQ2FuY2VsJywgdGhpcy5fb25Ub3VjaENhbmNlbCwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaENhbmNlbCwgdGhpcyk7XG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICd0b3VjaGxlYXZlJywgdGhpcy5fb25Ub3VjaExlYXZlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X3RvdWNoRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XG5cdFx0Ly8gI1RPRE86IGZpeCB0aGUgcGFnZVggZXJyb3IgdGhhdCBpcyBkbyBhIGJ1ZyBpbiBBbmRyb2lkIHdoZXJlIGEgc2luZ2xlIHRvdWNoIHRyaWdnZXJzIHR3byBjbGljayBldmVudHNcblx0XHQvLyBfZmlsdGVyQ2xpY2sgaXMgd2hhdCBsZWFmbGV0IHVzZXMgYXMgYSB3b3JrYXJvdW5kLlxuXHRcdC8vIFRoaXMgaXMgYSBwcm9ibGVtIHdpdGggbW9yZSB0aGluZ3MgdGhhbiBqdXN0IGFuZHJvaWQuIEFub3RoZXIgcHJvYmxlbSBpcyB0b3VjaEVuZCBoYXMgbm8gdG91Y2hlcyBpblxuXHRcdC8vIGl0cyB0b3VjaCBsaXN0LlxuXHRcdHZhciB0b3VjaEV2ZW50ID0ge307XG5cdFx0aWYgKHR5cGVvZiBlLnRvdWNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRpZiAoIWUudG91Y2hlcy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dG91Y2hFdmVudCA9IGUudG91Y2hlc1swXTtcblx0XHR9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcblx0XHRcdHRvdWNoRXZlbnQgPSBlO1xuXHRcdFx0aWYgKCF0aGlzLl9maWx0ZXJDbGljayhlKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodG91Y2hFdmVudCksXG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQodG91Y2hFdmVudCksXG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwge1xuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXG5cdFx0XHRsYXllclBvaW50OiBsYXllclBvaW50LFxuXHRcdFx0Y29udGFpbmVyUG9pbnQ6IGNvbnRhaW5lclBvaW50LFxuXHRcdFx0cGFnZVg6IHRvdWNoRXZlbnQucGFnZVgsXG5cdFx0XHRwYWdlWTogdG91Y2hFdmVudC5wYWdlWSxcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcblx0XHR9KTtcblx0fSxcblxuXHQvKiogQm9ycm93ZWQgZnJvbSBMZWFmbGV0IGFuZCBtb2RpZmllZCBmb3IgYm9vbCBvcHMgKiovXG5cdF9maWx0ZXJDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IGUub3JpZ2luYWxFdmVudC50aW1lU3RhbXApLFxuXHRcdFx0ZWxhcHNlZCA9IEwuRG9tRXZlbnQuX2xhc3RDbGljayAmJiAodGltZVN0YW1wIC0gTC5Eb21FdmVudC5fbGFzdENsaWNrKTtcblxuXHRcdC8vIGFyZSB0aGV5IGNsb3NlciB0b2dldGhlciB0aGFuIDUwMG1zIHlldCBtb3JlIHRoYW4gMTAwbXM/XG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXG5cdFx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xuXHRcdC8vIG9yIGNoZWNrIGlmIGNsaWNrIGlzIHNpbXVsYXRlZCBvbiB0aGUgZWxlbWVudCwgYW5kIGlmIGl0IGlzLCByZWplY3QgYW55IG5vbi1zaW11bGF0ZWQgZXZlbnRzXG5cdFx0aWYgKChlbGFwc2VkICYmIGVsYXBzZWQgPiAxMDAgJiYgZWxhcHNlZCA8IDUwMCkgfHwgKGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayAmJiAhZS5fc2ltdWxhdGVkKSkge1xuXHRcdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcC5fbG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHR5cGUgPSAndG91Y2hzdGFydCc7XG5cdFx0dGhpcy5fdG91Y2hFdmVudChlLCB0eXBlKTtcblxuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwLl9sb2FkZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHlwZSA9ICd0b3VjaGVuZCc7XG5cdFx0dGhpcy5fdG91Y2hFdmVudChlLCB0eXBlKTtcblx0fSxcblxuXHRfb25Ub3VjaENhbmNlbDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcC5fbG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHR5cGUgPSAndG91Y2hjYW5jZWwnO1xuXHRcdGlmICh0aGlzLl9kZXRlY3RJRSgpKSB7XG5cdFx0XHR0eXBlID0gJ3BvaW50ZXJjYW5jZWwnO1xuXHRcdH1cblx0XHR0aGlzLl90b3VjaEV2ZW50KGUsIHR5cGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTGVhdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAuX2xvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0eXBlID0gJ3RvdWNobGVhdmUnO1xuXHRcdHRoaXMuX3RvdWNoRXZlbnQoZSwgdHlwZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwLl9sb2FkZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHlwZSA9ICd0b3VjaG1vdmUnO1xuXHRcdHRoaXMuX3RvdWNoRXZlbnQoZSwgdHlwZSk7XG5cdH0sXG5cblx0X2RldGVjdElFOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cblx0XHR2YXIgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJyk7XG5cdFx0aWYgKG1zaWUgPiAwKSB7XG5cdFx0XHQvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcblx0XHRcdHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcobXNpZSArIDUsIHVhLmluZGV4T2YoJy4nLCBtc2llKSksIDEwKTtcblx0XHR9XG5cblx0XHR2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ1RyaWRlbnQvJyk7XG5cdFx0aWYgKHRyaWRlbnQgPiAwKSB7XG5cdFx0XHQvLyBJRSAxMSA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcblx0XHRcdHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhydiArIDMsIHVhLmluZGV4T2YoJy4nLCBydikpLCAxMCk7XG5cdFx0fVxuXG5cdFx0dmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdFZGdlLycpO1xuXHRcdGlmIChlZGdlID4gMCkge1xuXHRcdFx0Ly8gSUUgMTIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKGVkZ2UgKyA1LCB1YS5pbmRleE9mKCcuJywgZWRnZSkpLCAxMCk7XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgYnJvd3NlclxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoRXh0ZW5kJywgTC5NYXAuVG91Y2hFeHRlbmQpO1xuXG5cbi8qKlxuICogQGNsYXNzIEwuTWFya2VyLlRvdWNoXG4gKiBAYWthIE1hcmtlci5Ub3VjaFxuICpcbiAqIFRoaXMgaXNuJ3QgZnVsbCBUb3VjaCBzdXBwb3J0LiBUaGlzIGlzIGp1c3QgdG8gZ2V0IG1hcmtlcnMgdG8gYWxzbyBzdXBwb3J0IGRvbSB0b3VjaCBldmVudHMgYWZ0ZXIgY3JlYXRpb25cbiAqICNUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSBvZiBnZXR0aW5nIG1hcmtlcnMgdG8gc3VwcG9ydCB0b3VjaC5cbiAqL1xuTC5NYXJrZXIuVG91Y2ggPSBMLk1hcmtlci5leHRlbmQoe1xuXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQpIHtcblx0XHRcdC8vIDAuNy54IHN1cHBvcnRcblx0XHRcdHJldHVybiB0aGlzLl9pbml0SW50ZXJhY3Rpb25MZWdhY3koKTtcblx0XHR9XG5cdFx0Ly8gVE9ETyB0aGlzIG1heSBuZWVkIGJlIHVwZGF0ZWQgdG8gcmUtYWRkIHRvdWNoIGV2ZW50cyBmb3IgMS4wK1xuXHRcdHJldHVybiBMLk1hcmtlci5wcm90b3R5cGUuX2luaXRJbnRlcmFjdGlvbi5hcHBseSh0aGlzKTtcblx0fSxcblxuXHQvLyBUaGlzIGlzIGFuIGV4YWN0IGNvcHkgb2YgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9ibG9iL3YwLjcvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanNcblx0Ly8gd2l0aCB0aGUgYWRkaXRpb24gb2YgdGhlIHRvdWNoIGV2ZW50c1xuXHRfaW5pdEludGVyYWN0aW9uTGVnYWN5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBUT0RPIHJlZmFjdG9yIGludG8gc29tZXRoaW5nIHNoYXJlZCB3aXRoIE1hcC9QYXRoL2V0Yy4gdG8gRFJZIGl0IHVwXG5cblx0XHR2YXIgaWNvbiA9IHRoaXMuX2ljb24sXG5cdFx0XHRldmVudHMgPSBbJ2RibGNsaWNrJyxcblx0XHRcdFx0J21vdXNlZG93bicsXG5cdFx0XHRcdCdtb3VzZW92ZXInLFxuXHRcdFx0XHQnbW91c2VvdXQnLFxuXHRcdFx0XHQnY29udGV4dG1lbnUnLFxuXHRcdFx0XHQndG91Y2hzdGFydCcsXG5cdFx0XHRcdCd0b3VjaGVuZCcsXG5cdFx0XHRcdCd0b3VjaG1vdmUnXTtcblx0XHRpZiAodGhpcy5fZGV0ZWN0SUUpIHtcblx0XHRcdGV2ZW50cy5jb25jYXQoWydNU1BvaW50ZXJEb3duJyxcblx0XHRcdFx0J01TUG9pbnRlclVwJyxcblx0XHRcdFx0J01TUG9pbnRlck1vdmUnLFxuXHRcdFx0XHQnTVNQb2ludGVyQ2FuY2VsJ10pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuY29uY2F0KFsndG91Y2hjYW5jZWwnXSk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdEwuRG9tRXZlbnQub24oaWNvbiwgJ2NsaWNrJywgdGhpcy5fb25Nb3VzZUNsaWNrLCB0aGlzKTtcblx0XHRMLkRvbUV2ZW50Lm9uKGljb24sICdrZXlwcmVzcycsIHRoaXMuX29uS2V5UHJlc3MsIHRoaXMpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdEwuRG9tRXZlbnQub24oaWNvbiwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKEwuSGFuZGxlci5NYXJrZXJEcmFnKSB7XG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpO1xuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZGV0ZWN0SUU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuXHRcdHZhciBtc2llID0gdWEuaW5kZXhPZignTVNJRSAnKTtcblx0XHRpZiAobXNpZSA+IDApIHtcblx0XHRcdC8vIElFIDEwIG9yIG9sZGVyID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuXHRcdFx0cmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuXHRcdH1cblxuXHRcdHZhciB0cmlkZW50ID0gdWEuaW5kZXhPZignVHJpZGVudC8nKTtcblx0XHRpZiAodHJpZGVudCA+IDApIHtcblx0XHRcdC8vIElFIDExID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuXHRcdFx0dmFyIHJ2ID0gdWEuaW5kZXhPZigncnY6Jyk7XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcblx0XHR9XG5cblx0XHR2YXIgZWRnZSA9IHVhLmluZGV4T2YoJ0VkZ2UvJyk7XG5cdFx0aWYgKGVkZ2UgPiAwKSB7XG5cdFx0XHQvLyBJRSAxMiA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcblx0XHRcdHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcblx0XHR9XG5cblx0XHQvLyBvdGhlciBicm93c2VyXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuTGF0TG5nVXRpbFxuICogQGFrYSBMYXRMbmdVdGlsXG4gKi9cbkwuTGF0TG5nVXRpbCA9IHtcblx0Ly8gQ2xvbmVzIGEgTGF0TG5nc1tdLCByZXR1cm5zIFtdW11cblxuXHQvLyBAbWV0aG9kIGNsb25lTGF0TG5ncyhMYXRMbmdzW10pOiBMLkxhdExuZ3NbXVxuXHQvLyBDbG9uZSB0aGUgbGF0TG5nIHBvaW50IG9yIHBvaW50cyBvciBuZXN0ZWQgcG9pbnRzIGFuZCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aG9zZSBwb2ludHNcblx0Y2xvbmVMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciBjbG9uZSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdC8vIENoZWNrIGZvciBuZXN0ZWQgYXJyYXkgKFBvbHlsaW5lL1BvbHlnb24pXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShsYXRsbmdzW2ldKSkge1xuXHRcdFx0XHRjbG9uZS5wdXNoKEwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZ3MobGF0bG5nc1tpXSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmUucHVzaCh0aGlzLmNsb25lTGF0TG5nKGxhdGxuZ3NbaV0pKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvbmVMYXRMbmcoTGF0TG5nKTogTC5MYXRMbmdcblx0Ly8gQ2xvbmUgdGhlIGxhdExuZyBhbmQgcmV0dXJuIGEgbmV3IExhdExuZyBvYmplY3QuXG5cdGNsb25lTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0cmV0dXJuIEwubGF0TG5nKGxhdGxuZy5sYXQsIGxhdGxuZy5sbmcpO1xuXHR9XG59O1xuXG5cblxuKGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgZGVmYXVsdFByZWNpc2lvbiA9IHtcblx0XHRrbTogMixcblx0XHRoYTogMixcblx0XHRtOiAwLFxuXHRcdG1pOiAyLFxuXHRcdGFjOiAyLFxuXHRcdHlkOiAwLFxuXHRcdGZ0OiAwLFxuXHRcdG5tOiAyXG5cdH07XG5cblxuXHQvKipcblx0ICogQGNsYXNzIEwuR2VvbWV0cnlVdGlsXG5cdCAqIEBha2EgR2VvbWV0cnlVdGlsXG5cdCAqL1xuXHRMLkdlb21ldHJ5VXRpbCA9IEwuZXh0ZW5kKEwuR2VvbWV0cnlVdGlsIHx8IHt9LCB7XG5cdFx0Ly8gUG9ydGVkIGZyb20gdGhlIE9wZW5MYXllcnMgaW1wbGVtZW50YXRpb24uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2Jsb2IvbWFzdGVyL2xpYi9PcGVuTGF5ZXJzL0dlb21ldHJ5L0xpbmVhclJpbmcuanMjTDI3MFxuXG5cdFx0Ly8gQG1ldGhvZCBnZW9kZXNpY0FyZWEoKTogbnVtYmVyXG5cdFx0Z2VvZGVzaWNBcmVhOiBmdW5jdGlvbiAobGF0TG5ncykge1xuXHRcdFx0dmFyIHBvaW50c0NvdW50ID0gbGF0TG5ncy5sZW5ndGgsXG5cdFx0XHRcdGFyZWEgPSAwLjAsXG5cdFx0XHRcdGQyciA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRcdHAxLCBwMjtcblxuXHRcdFx0aWYgKHBvaW50c0NvdW50ID4gMikge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0NvdW50OyBpKyspIHtcblx0XHRcdFx0XHRwMSA9IGxhdExuZ3NbaV07XG5cdFx0XHRcdFx0cDIgPSBsYXRMbmdzWyhpICsgMSkgJSBwb2ludHNDb3VudF07XG5cdFx0XHRcdFx0YXJlYSArPSAoKHAyLmxuZyAtIHAxLmxuZykgKiBkMnIpICpcblx0XHRcdFx0XHRcdCgyICsgTWF0aC5zaW4ocDEubGF0ICogZDJyKSArIE1hdGguc2luKHAyLmxhdCAqIGQycikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFyZWEgPSBhcmVhICogNjM3ODEzNy4wICogNjM3ODEzNy4wIC8gMi4wO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoYXJlYSk7XG5cdFx0fSxcblxuXHRcdC8vIEBtZXRob2QgZm9ybWF0dGVkTnVtYmVyKG4sIHByZWNpc2lvbik6IHN0cmluZ1xuXHRcdC8vIFJldHVybnMgbiBpbiBzcGVjaWZpZWQgbnVtYmVyIGZvcm1hdCAoaWYgZGVmaW5lZCkgYW5kIHByZWNpc2lvblxuXHRcdGZvcm1hdHRlZE51bWJlcjogZnVuY3Rpb24gKG4sIHByZWNpc2lvbikge1xuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHBhcnNlRmxvYXQobikudG9GaXhlZChwcmVjaXNpb24pLFxuXHRcdFx0XHRmb3JtYXQgPSBMLmRyYXdMb2NhbC5mb3JtYXQgJiYgTC5kcmF3TG9jYWwuZm9ybWF0Lm51bWVyaWMsXG5cdFx0XHRcdGRlbGltaXRlcnMgPSBmb3JtYXQgJiYgZm9ybWF0LmRlbGltaXRlcnMsXG5cdFx0XHRcdHRob3VzYW5kcyA9IGRlbGltaXRlcnMgJiYgZGVsaW1pdGVycy50aG91c2FuZHMsXG5cdFx0XHRcdGRlY2ltYWwgPSBkZWxpbWl0ZXJzICYmIGRlbGltaXRlcnMuZGVjaW1hbDtcblxuXHRcdFx0aWYgKHRob3VzYW5kcyB8fCBkZWNpbWFsKSB7XG5cdFx0XHRcdHZhciBzcGxpdFZhbHVlID0gZm9ybWF0dGVkLnNwbGl0KCcuJyk7XG5cdFx0XHRcdGZvcm1hdHRlZCA9IHRob3VzYW5kcyA/IHNwbGl0VmFsdWVbMF0ucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICsgdGhvdXNhbmRzKSA6IHNwbGl0VmFsdWVbMF07XG5cdFx0XHRcdGRlY2ltYWwgPSBkZWNpbWFsIHx8ICcuJztcblx0XHRcdFx0aWYgKHNwbGl0VmFsdWUubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGZvcm1hdHRlZCA9IGZvcm1hdHRlZCArIGRlY2ltYWwgKyBzcGxpdFZhbHVlWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3JtYXR0ZWQ7XG5cdFx0fSxcblxuXHRcdC8vIEBtZXRob2QgcmVhZGFibGVBcmVhKGFyZWEsIGlzTWV0cmljLCBwcmVjaXNpb24pOiBzdHJpbmdcblx0XHQvLyBSZXR1cm5zIGEgcmVhZGFibGUgYXJlYSBzdHJpbmcgaW4geWFyZHMgb3IgbWV0cmljLlxuXHRcdC8vIFRoZSB2YWx1ZSB3aWxsIGJlIHJvdW5kZWQgYXMgZGVmaW5lZCBieSB0aGUgcHJlY2lzaW9uIG9wdGlvbiBvYmplY3QuXG5cdFx0cmVhZGFibGVBcmVhOiBmdW5jdGlvbiAoYXJlYSwgaXNNZXRyaWMsIHByZWNpc2lvbikge1xuXHRcdFx0dmFyIGFyZWFTdHIsXG5cdFx0XHRcdHVuaXRzLFxuXHRcdFx0XHRwcmVjaXNpb24gPSBMLlV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0UHJlY2lzaW9uLCBwcmVjaXNpb24pO1xuXG5cdFx0XHRpZiAoaXNNZXRyaWMpIHtcblx0XHRcdFx0dW5pdHMgPSBbJ2hhJywgJ20nXTtcblx0XHRcdFx0dHlwZSA9IHR5cGVvZiBpc01ldHJpYztcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dW5pdHMgPSBbaXNNZXRyaWNdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdHVuaXRzID0gaXNNZXRyaWM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYXJlYSA+PSAxMDAwMDAwICYmIHVuaXRzLmluZGV4T2YoJ2ttJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0YXJlYVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihhcmVhICogMC4wMDAwMDEsIHByZWNpc2lvblsna20nXSkgKyAnIGttwrInO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZWEgPj0gMTAwMDAgJiYgdW5pdHMuaW5kZXhPZignaGEnKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRhcmVhU3RyID0gTC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGFyZWEgKiAwLjAwMDEsIHByZWNpc2lvblsnaGEnXSkgKyAnIGhhJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcmVhU3RyID0gTC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGFyZWEsIHByZWNpc2lvblsnbSddKSArICcgbcKyJztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJlYSAvPSAwLjgzNjEyNzsgLy8gU3F1YXJlIHlhcmRzIGluIDEgbWV0ZXJcblxuXHRcdFx0XHRpZiAoYXJlYSA+PSAzMDk3NjAwKSB7IC8vMzA5NzYwMCBzcXVhcmUgeWFyZHMgaW4gMSBzcXVhcmUgbWlsZVxuXHRcdFx0XHRcdGFyZWFTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoYXJlYSAvIDMwOTc2MDAsIHByZWNpc2lvblsnbWknXSkgKyAnIG1pwrInO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZWEgPj0gNDg0MCkgeyAvLzQ4NDAgc3F1YXJlIHlhcmRzIGluIDEgYWNyZVxuXHRcdFx0XHRcdGFyZWFTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoYXJlYSAvIDQ4NDAsIHByZWNpc2lvblsnYWMnXSkgKyAnIGFjcmVzJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcmVhU3RyID0gTC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGFyZWEsIHByZWNpc2lvblsneWQnXSkgKyAnIHlkwrInO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcmVhU3RyO1xuXHRcdH0sXG5cblx0XHQvLyBAbWV0aG9kIHJlYWRhYmxlRGlzdGFuY2UoZGlzdGFuY2UsIHVuaXRzKTogc3RyaW5nXG5cdFx0Ly8gQ29udmVydHMgYSBtZXRyaWMgZGlzdGFuY2UgdG8gb25lIG9mIFsgZmVldCwgbmF1dGljYWxNaWxlLCBtZXRyaWMgb3IgeWFyZHMgXSBzdHJpbmdcblx0XHQvL1xuXHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdC8vIEBtZXRob2QgcmVhZGFibGVEaXN0YW5jZShkaXN0YW5jZSwgaXNNZXRyaWMsIHVzZUZlZXQsIGlzTmF1dGljYWxNaWxlLCBwcmVjaXNpb24pOiBzdHJpbmdcblx0XHQvLyBDb252ZXJ0cyBtZXRyaWMgZGlzdGFuY2UgdG8gZGlzdGFuY2Ugc3RyaW5nLlxuXHRcdC8vIFRoZSB2YWx1ZSB3aWxsIGJlIHJvdW5kZWQgYXMgZGVmaW5lZCBieSB0aGUgcHJlY2lzaW9uIG9wdGlvbiBvYmplY3QuXG5cdFx0cmVhZGFibGVEaXN0YW5jZTogZnVuY3Rpb24gKGRpc3RhbmNlLCBpc01ldHJpYywgaXNGZWV0LCBpc05hdXRpY2FsTWlsZSwgcHJlY2lzaW9uKSB7XG5cdFx0XHR2YXIgZGlzdGFuY2VTdHIsXG5cdFx0XHRcdHVuaXRzLFxuXHRcdFx0XHRwcmVjaXNpb24gPSBMLlV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0UHJlY2lzaW9uLCBwcmVjaXNpb24pO1xuXG5cdFx0XHRpZiAoaXNNZXRyaWMpIHtcblx0XHRcdFx0dW5pdHMgPSB0eXBlb2YgaXNNZXRyaWMgPT0gJ3N0cmluZycgPyBpc01ldHJpYyA6ICdtZXRyaWMnO1xuXHRcdFx0fSBlbHNlIGlmIChpc0ZlZXQpIHtcblx0XHRcdFx0dW5pdHMgPSAnZmVldCc7XG5cdFx0XHR9IGVsc2UgaWYgKGlzTmF1dGljYWxNaWxlKSB7XG5cdFx0XHRcdHVuaXRzID0gJ25hdXRpY2FsTWlsZSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR1bml0cyA9ICd5YXJkcyc7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAodW5pdHMpIHtcblx0XHRcdFx0Y2FzZSAnbWV0cmljJzpcblx0XHRcdFx0XHQvLyBzaG93IG1ldHJlcyB3aGVuIGRpc3RhbmNlIGlzIDwgMWttLCB0aGVuIHNob3cga21cblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiAxMDAwKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSAvIDEwMDAsIHByZWNpc2lvblsna20nXSkgKyAnIGttJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2VTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoZGlzdGFuY2UsIHByZWNpc2lvblsnbSddKSArICcgbSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmZWV0Jzpcblx0XHRcdFx0XHRkaXN0YW5jZSAqPSAxLjA5MzYxICogMztcblx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSwgcHJlY2lzaW9uWydmdCddKSArICcgZnQnO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ25hdXRpY2FsTWlsZSc6XG5cdFx0XHRcdFx0ZGlzdGFuY2UgKj0gMC41Mzk5Njtcblx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSAvIDEwMDAsIHByZWNpc2lvblsnbm0nXSkgKyAnIG5tJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAneWFyZHMnOlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGRpc3RhbmNlICo9IDEuMDkzNjE7XG5cblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiAxNzYwKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZVN0ciA9IEwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihkaXN0YW5jZSAvIDE3NjAsIHByZWNpc2lvblsnbWknXSkgKyAnIG1pbGVzJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2VTdHIgPSBMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoZGlzdGFuY2UsIHByZWNpc2lvblsneWQnXSkgKyAnIHlkJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGlzdGFuY2VTdHI7XG5cdFx0fSxcblxuXHRcdC8vIEBtZXRob2QgaXNWZXJzaW9uMDd4KCk6IGJvb2xlYW5cblx0XHQvLyBSZXR1cm5zIHRydWUgaWYgdGhlIExlYWZsZXQgdmVyc2lvbiBpcyAwLjcueCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdGlzVmVyc2lvbjA3eDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHZlcnNpb24gPSBMLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHRcdC8vSWYgVmVyc2lvbiBpcyA9PSAwLjcuKlxuXHRcdFx0cmV0dXJuIHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSA9PT0gMCAmJiBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCkgPT09IDc7XG5cdFx0fSxcblx0fSk7XG5cbn0pKCk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkxpbmVVdGlsXG4gKiBAYWthIFV0aWxcbiAqIEBha2EgTC5VdGlsc1xuICovXG5MLlV0aWwuZXh0ZW5kKEwuTGluZVV0aWwsIHtcblxuXHQvLyBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0KCk6IGJvb2xlYW5cblx0Ly8gQ2hlY2tzIHRvIHNlZSBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3QuIERvZXMgbm90IGhhbmRsZSBkZWdlbmVyYXRlIGNhc2VzLlxuXHQvLyBodHRwOi8vY29tcGdlb20uY3MudWl1Yy5lZHUvfmplZmZlL3RlYWNoaW5nLzM3My9ub3Rlcy94MDYtc3dlZXBsaW5lLnBkZlxuXHRzZWdtZW50c0ludGVyc2VjdDogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMiwgLypQb2ludCovIHAzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrQ291bnRlcmNsb2Nrd2lzZShwLCBwMiwgcDMpICE9PVxuXHRcdFx0dGhpcy5fY2hlY2tDb3VudGVyY2xvY2t3aXNlKHAxLCBwMiwgcDMpICYmXG5cdFx0XHR0aGlzLl9jaGVja0NvdW50ZXJjbG9ja3dpc2UocCwgcDEsIHAyKSAhPT1cblx0XHRcdHRoaXMuX2NoZWNrQ291bnRlcmNsb2Nrd2lzZShwLCBwMSwgcDMpO1xuXHR9LFxuXG5cdC8vIGNoZWNrIHRvIHNlZSBpZiBwb2ludHMgYXJlIGluIGNvdW50ZXJjbG9ja3dpc2Ugb3JkZXJcblx0X2NoZWNrQ291bnRlcmNsb2Nrd2lzZTogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMikge1xuXHRcdHJldHVybiAocDIueSAtIHAueSkgKiAocDEueCAtIHAueCkgPiAocDEueSAtIHAueSkgKiAocDIueCAtIHAueCk7XG5cdH1cbn0pO1xuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5Qb2x5bGluZVxuICogQGFrYSBQb2x5bGluZVxuICovXG5MLlBvbHlsaW5lLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cygpOiBib29sZWFuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIHBvbHlsaW5lIGhhcyBhbnkgbGluZXNlZ21lbnRzIHRoYXQgaW50ZXJzZWN0LlxuXHQvLyBOT1RFOiBkb2VzIG5vdCBzdXBwb3J0IGRldGVjdGluZyBpbnRlcnNlY3Rpb24gZm9yIGRlZ2VuZXJhdGUgY2FzZXMuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fZ2V0UHJvamVjdGVkUG9pbnRzKCksXG5cdFx0XHRsZW4gPSBwb2ludHMgPyBwb2ludHMubGVuZ3RoIDogMCxcblx0XHRcdGksIHAsIHAxO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb0Zld1BvaW50c0ZvckludGVyc2VjdGlvbigpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAzOyBpLS0pIHtcblx0XHRcdHAgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cblxuXHRcdFx0aWYgKHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShwLCBwMSwgaSAtIDIpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG5ld0xhdExuZ0ludGVyc2VjdHMoKTogYm9vbGVhblxuXHQvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIGlmIG5ldyBsYXRsbmcgd2FzIGFkZGVkIHRvIHRoaXMgcG9seWxpbmUuXG5cdC8vIE5PVEU6IGRvZXMgbm90IHN1cHBvcnQgZGV0ZWN0aW5nIGludGVyc2VjdGlvbiBmb3IgZGVnZW5lcmF0ZSBjYXNlcy5cblx0bmV3TGF0TG5nSW50ZXJzZWN0czogZnVuY3Rpb24gKGxhdGxuZywgc2tpcEZpcnN0KSB7XG5cdFx0Ly8gQ2Fubm90IGNoZWNrIGEgcG9seWxpbmUgZm9yIGludGVyc2VjdGluZyBsYXRzL2xuZ3Mgd2hlbiBub3QgYWRkZWQgdG8gdGhlIG1hcFxuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubmV3UG9pbnRJbnRlcnNlY3RzKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKSwgc2tpcEZpcnN0KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG5ld1BvaW50SW50ZXJzZWN0cygpOiBib29sZWFuXG5cdC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gaWYgbmV3IHBvaW50IHdhcyBhZGRlZCB0byB0aGlzIHBvbHlsaW5lLlxuXHQvLyBuZXdQb2ludCBtdXN0IGJlIGEgbGF5ZXIgcG9pbnQuXG5cdC8vIE5PVEU6IGRvZXMgbm90IHN1cHBvcnQgZGV0ZWN0aW5nIGludGVyc2VjdGlvbiBmb3IgZGVnZW5lcmF0ZSBjYXNlcy5cblx0bmV3UG9pbnRJbnRlcnNlY3RzOiBmdW5jdGlvbiAobmV3UG9pbnQsIHNraXBGaXJzdCkge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKSxcblx0XHRcdGxlbiA9IHBvaW50cyA/IHBvaW50cy5sZW5ndGggOiAwLFxuXHRcdFx0bGFzdFBvaW50ID0gcG9pbnRzID8gcG9pbnRzW2xlbiAtIDFdIDogbnVsbCxcblx0XHRcdC8vIFRoZSBwcmV2aW91cyBwcmV2aW91cyBsaW5lIHNlZ21lbnQuIFByZXZpb3VzIGxpbmUgc2VnbWVudCBkb2Vzbid0IG5lZWQgdGVzdGluZy5cblx0XHRcdG1heEluZGV4ID0gbGVuIC0gMjtcblxuXHRcdGlmICh0aGlzLl90b29GZXdQb2ludHNGb3JJbnRlcnNlY3Rpb24oMSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fbGluZVNlZ21lbnRzSW50ZXJzZWN0c1JhbmdlKGxhc3RQb2ludCwgbmV3UG9pbnQsIG1heEluZGV4LCBza2lwRmlyc3QgPyAxIDogMCk7XG5cdH0sXG5cblx0Ly8gUG9seWxpbmVzIHdpdGggMiBzaWRlcyBjYW4gb25seSBpbnRlcnNlY3QgaW4gY2FzZXMgd2hlcmUgcG9pbnRzIGFyZSBjb2xsaW5lYXIgKHdlIGRvbid0IHN1cHBvcnQgZGV0ZWN0aW5nIHRoZXNlKS5cblx0Ly8gQ2Fubm90IGhhdmUgaW50ZXJzZWN0aW9uIHdoZW4gPCAzIGxpbmUgc2VnbWVudHMgKDwgNCBwb2ludHMpXG5cdF90b29GZXdQb2ludHNGb3JJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChleHRyYVBvaW50cykge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKSxcblx0XHRcdGxlbiA9IHBvaW50cyA/IHBvaW50cy5sZW5ndGggOiAwO1xuXHRcdC8vIEluY3JlbWVudCBsZW5ndGggYnkgZXh0cmFQb2ludHMgaWYgcHJlc2VudFxuXHRcdGxlbiArPSBleHRyYVBvaW50cyB8fCAwO1xuXG5cdFx0cmV0dXJuICFwb2ludHMgfHwgbGVuIDw9IDM7XG5cdH0sXG5cblx0Ly8gQ2hlY2tzIGEgbGluZSBzZWdtZW50IGludGVyc2VjdGlvbnMgd2l0aCBhbnkgbGluZSBzZWdtZW50cyBiZWZvcmUgaXRzIHByZWRlY2Vzc29yLlxuXHQvLyBEb24ndCBuZWVkIHRvIGNoZWNrIHRoZSBwcmVkZWNlc3NvciBhcyB3aWxsIG5ldmVyIGludGVyc2VjdC5cblx0X2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZTogZnVuY3Rpb24gKHAsIHAxLCBtYXhJbmRleCwgbWluSW5kZXgpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fZ2V0UHJvamVjdGVkUG9pbnRzKCksXG5cdFx0XHRwMiwgcDM7XG5cblx0XHRtaW5JbmRleCA9IG1pbkluZGV4IHx8IDA7XG5cblx0XHQvLyBDaGVjayBhbGwgcHJldmlvdXMgbGluZSBzZWdtZW50cyAoYmVzaWRlIHRoZSBpbW1lZGlhdGVseSBwcmV2aW91cykgZm9yIGludGVyc2VjdGlvbnNcblx0XHRmb3IgKHZhciBqID0gbWF4SW5kZXg7IGogPiBtaW5JbmRleDsgai0tKSB7XG5cdFx0XHRwMiA9IHBvaW50c1tqIC0gMV07XG5cdFx0XHRwMyA9IHBvaW50c1tqXTtcblxuXHRcdFx0aWYgKEwuTGluZVV0aWwuc2VnbWVudHNJbnRlcnNlY3QocCwgcDEsIHAyLCBwMykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9nZXRQcm9qZWN0ZWRQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RlZmF1bHRTaGFwZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29yaWdpbmFsUG9pbnRzO1xuXHRcdH1cblx0XHR2YXIgcG9pbnRzID0gW10sXG5cdFx0XHRfc2hhcGUgPSB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgX3NoYXBlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRwb2ludHMucHVzaCh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KF9zaGFwZVtpXSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuUG9seWdvblxuICogQGFrYSBQb2x5Z29uXG4gKi9cbkwuUG9seWdvbi5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMoKTogYm9vbGVhblxuXHQvLyBDaGVja3MgYSBwb2x5Z29uIGZvciBhbnkgaW50ZXJzZWN0aW5nIGxpbmUgc2VnbWVudHMuIElnbm9yZXMgaG9sZXMuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9seWxpbmVJbnRlcnNlY3RzLFxuXHRcdFx0cG9pbnRzID0gdGhpcy5fZ2V0UHJvamVjdGVkUG9pbnRzKCksXG5cdFx0XHRsZW4sIGZpcnN0UG9pbnQsIGxhc3RQb2ludCwgbWF4SW5kZXg7XG5cblx0XHRpZiAodGhpcy5fdG9vRmV3UG9pbnRzRm9ySW50ZXJzZWN0aW9uKCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwb2x5bGluZUludGVyc2VjdHMgPSBMLlBvbHlsaW5lLnByb3RvdHlwZS5pbnRlcnNlY3RzLmNhbGwodGhpcyk7XG5cblx0XHQvLyBJZiBhbHJlYWR5IGZvdW5kIGFuIGludGVyc2VjdGlvbiBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBhbnkgbW9yZS5cblx0XHRpZiAocG9seWxpbmVJbnRlcnNlY3RzKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZW4gPSBwb2ludHMubGVuZ3RoO1xuXHRcdGZpcnN0UG9pbnQgPSBwb2ludHNbMF07XG5cdFx0bGFzdFBvaW50ID0gcG9pbnRzW2xlbiAtIDFdO1xuXHRcdG1heEluZGV4ID0gbGVuIC0gMjtcblxuXHRcdC8vIENoZWNrIHRoZSBsaW5lIHNlZ21lbnQgYmV0d2VlbiBsYXN0IGFuZCBmaXJzdCBwb2ludC4gRG9uJ3QgbmVlZCB0byBjaGVjayB0aGUgZmlyc3QgbGluZSBzZWdtZW50IChtaW5JbmRleCA9IDEpXG5cdFx0cmV0dXJuIHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShsYXN0UG9pbnQsIGZpcnN0UG9pbnQsIG1heEluZGV4LCAxKTtcblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkNvbnRyb2wuRHJhd1xuICogQGFrYSBMLkRyYXdcbiAqL1xuTC5Db250cm9sLkRyYXcgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblxuXHQvLyBPcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxuXHRcdGRyYXc6IHt9LFxuXHRcdGVkaXQ6IGZhbHNlXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKCk6IHZvaWRcblx0Ly8gSW5pdGlhbGl6ZXMgZHJhdyBjb250cm9sLCB0b29sYmFycyBmcm9tIHRoZSBvcHRpb25zXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0aWYgKEwudmVyc2lvbiA8ICcwLjcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0xlYWZsZXQuZHJhdyAwLjIuMysgcmVxdWlyZXMgTGVhZmxldCAwLjcuMCsuIERvd25sb2FkIGxhdGVzdCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvJyk7XG5cdFx0fVxuXG5cdFx0TC5Db250cm9sLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cblx0XHR2YXIgdG9vbGJhcjtcblxuXHRcdHRoaXMuX3Rvb2xiYXJzID0ge307XG5cblx0XHQvLyBJbml0aWFsaXplIHRvb2xiYXJzXG5cdFx0aWYgKEwuRHJhd1Rvb2xiYXIgJiYgdGhpcy5vcHRpb25zLmRyYXcpIHtcblx0XHRcdHRvb2xiYXIgPSBuZXcgTC5EcmF3VG9vbGJhcih0aGlzLm9wdGlvbnMuZHJhdyk7XG5cblx0XHRcdHRoaXMuX3Rvb2xiYXJzW0wuRHJhd1Rvb2xiYXIuVFlQRV0gPSB0b29sYmFyO1xuXG5cdFx0XHQvLyBMaXN0ZW4gZm9yIHdoZW4gdG9vbGJhciBpcyBlbmFibGVkXG5cdFx0XHR0aGlzLl90b29sYmFyc1tMLkRyYXdUb29sYmFyLlRZUEVdLm9uKCdlbmFibGUnLCB0aGlzLl90b29sYmFyRW5hYmxlZCwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKEwuRWRpdFRvb2xiYXIgJiYgdGhpcy5vcHRpb25zLmVkaXQpIHtcblx0XHRcdHRvb2xiYXIgPSBuZXcgTC5FZGl0VG9vbGJhcih0aGlzLm9wdGlvbnMuZWRpdCk7XG5cblx0XHRcdHRoaXMuX3Rvb2xiYXJzW0wuRWRpdFRvb2xiYXIuVFlQRV0gPSB0b29sYmFyO1xuXG5cdFx0XHQvLyBMaXN0ZW4gZm9yIHdoZW4gdG9vbGJhciBpcyBlbmFibGVkXG5cdFx0XHR0aGlzLl90b29sYmFyc1tMLkVkaXRUb29sYmFyLlRZUEVdLm9uKCdlbmFibGUnLCB0aGlzLl90b29sYmFyRW5hYmxlZCwgdGhpcyk7XG5cdFx0fVxuXHRcdEwudG9vbGJhciA9IHRoaXM7IC8vc2V0IGdsb2JhbCB2YXIgZm9yIGVkaXRpbmcgdGhlIHRvb2xiYXJcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9uQWRkKCk6IGNvbnRhaW5lclxuXHQvLyBBZGRzIHRoZSB0b29sYmFyIGNvbnRhaW5lciB0byB0aGUgbWFwXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWRyYXcnKSxcblx0XHRcdGFkZGVkVG9wQ2xhc3MgPSBmYWxzZSxcblx0XHRcdHRvcENsYXNzTmFtZSA9ICdsZWFmbGV0LWRyYXctdG9vbGJhci10b3AnLFxuXHRcdFx0dG9vbGJhckNvbnRhaW5lcjtcblxuXHRcdGZvciAodmFyIHRvb2xiYXJJZCBpbiB0aGlzLl90b29sYmFycykge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2xiYXJzLmhhc093blByb3BlcnR5KHRvb2xiYXJJZCkpIHtcblx0XHRcdFx0dG9vbGJhckNvbnRhaW5lciA9IHRoaXMuX3Rvb2xiYXJzW3Rvb2xiYXJJZF0uYWRkVG9vbGJhcihtYXApO1xuXG5cdFx0XHRcdGlmICh0b29sYmFyQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0Ly8gQWRkIGNsYXNzIHRvIHRoZSBmaXJzdCB0b29sYmFyIHRvIHJlbW92ZSB0aGUgbWFyZ2luXG5cdFx0XHRcdFx0aWYgKCFhZGRlZFRvcENsYXNzKSB7XG5cdFx0XHRcdFx0XHRpZiAoIUwuRG9tVXRpbC5oYXNDbGFzcyh0b29sYmFyQ29udGFpbmVyLCB0b3BDbGFzc05hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0b29sYmFyQ29udGFpbmVyLmNoaWxkTm9kZXNbMF0sIHRvcENsYXNzTmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhZGRlZFRvcENsYXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodG9vbGJhckNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb25SZW1vdmUoKTogdm9pZFxuXHQvLyBSZW1vdmVzIHRoZSB0b29sYmFycyBmcm9tIHRoZSBtYXAgdG9vbGJhciBjb250YWluZXJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB0b29sYmFySWQgaW4gdGhpcy5fdG9vbGJhcnMpIHtcblx0XHRcdGlmICh0aGlzLl90b29sYmFycy5oYXNPd25Qcm9wZXJ0eSh0b29sYmFySWQpKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2xiYXJzW3Rvb2xiYXJJZF0ucmVtb3ZlVG9vbGJhcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldERyYXdpbmdPcHRpb25zKG9wdGlvbnMpOiB2b2lkXG5cdC8vIFNldHMgb3B0aW9ucyB0byBhbGwgdG9vbGJhciBpbnN0YW5jZXNcblx0c2V0RHJhd2luZ09wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Zm9yICh2YXIgdG9vbGJhcklkIGluIHRoaXMuX3Rvb2xiYXJzKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbGJhcnNbdG9vbGJhcklkXSBpbnN0YW5jZW9mIEwuRHJhd1Rvb2xiYXIpIHtcblx0XHRcdFx0dGhpcy5fdG9vbGJhcnNbdG9vbGJhcklkXS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdG9vbGJhckVuYWJsZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGVuYWJsZWRUb29sYmFyID0gZS50YXJnZXQ7XG5cblx0XHRmb3IgKHZhciB0b29sYmFySWQgaW4gdGhpcy5fdG9vbGJhcnMpIHtcblx0XHRcdGlmICh0aGlzLl90b29sYmFyc1t0b29sYmFySWRdICE9PSBlbmFibGVkVG9vbGJhcikge1xuXHRcdFx0XHR0aGlzLl90b29sYmFyc1t0b29sYmFySWRdLmRpc2FibGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRkcmF3Q29udHJvbFRvb2x0aXBzOiB0cnVlLFxuXHRkcmF3Q29udHJvbDogZmFsc2Vcbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLm9wdGlvbnMuZHJhd0NvbnRyb2wpIHtcblx0XHR0aGlzLmRyYXdDb250cm9sID0gbmV3IEwuQ29udHJvbC5EcmF3KCk7XG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuZHJhd0NvbnRyb2wpO1xuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRHJhdy5Ub29sYmFyXG4gKiBAYWthIFRvb2xiYXJcbiAqXG4gKiBUaGUgdG9vbGJhciBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdWlcbiAqIFRoaXMgd2lsbCBiZSBkZXByZWNpYXRlZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqICAgIHZhciB0b29sYmFyID0gTC5Ub29sYmFyKCk7XG4gKiAgICB0b29sYmFyLmFkZFRvb2xiYXIobWFwKTtcbiAqIGBgYFxuICpcbiAqICMjIyBEaXNhYmxpbmcgYSB0b29sYmFyXG4gKlxuICogSWYgeW91IGRvIG5vdCB3YW50IGEgcGFydGljdWxhciB0b29sYmFyIGluIHlvdXIgYXBwIHlvdSBjYW4gdHVybiBpdCBvZmYgYnkgc2V0dGluZyB0aGUgdG9vbGJhciB0byBmYWxzZS5cbiAqXG4gKiBgYGBqc1xuICogICAgICB2YXIgZHJhd0NvbnRyb2wgPSBuZXcgTC5Db250cm9sLkRyYXcoe1xuICogICAgICAgICAgZHJhdzogZmFsc2UsXG4gKiAgICAgICAgICBlZGl0OiB7XG4gKiAgICAgICAgICAgICAgZmVhdHVyZUdyb3VwOiBlZGl0YWJsZUxheWVyc1xuICogICAgICAgICAgfVxuICogICAgICB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyBEaXNhYmxpbmcgYSB0b29sYmFyIGl0ZW1cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB0dXJuIG9mZiBhIHBhcnRpY3VsYXIgdG9vbGJhciBpdGVtLCBzZXQgaXQgdG8gZmFsc2UuIFRoZSBmb2xsb3dpbmcgZGlzYWJsZXMgZHJhd2luZyBwb2x5Z29ucyBhbmRcbiAqIG1hcmtlcnMuIEl0IGFsc28gdHVybnMgb2ZmIHRoZSBhYmlsaXR5IHRvIGVkaXQgbGF5ZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAgICAgIHZhciBkcmF3Q29udHJvbCA9IG5ldyBMLkNvbnRyb2wuRHJhdyh7XG4gKiAgICAgICAgICBkcmF3OiB7XG4gKiAgICAgICAgICAgICAgcG9seWdvbjogZmFsc2UsXG4gKiAgICAgICAgICAgICAgbWFya2VyOiBmYWxzZVxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIGVkaXQ6IHtcbiAqICAgICAgICAgICAgICBmZWF0dXJlR3JvdXA6IGVkaXRhYmxlTGF5ZXJzLFxuICogICAgICAgICAgICAgIGVkaXQ6IGZhbHNlXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH0pO1xuICogYGBgXG4gKi9cbkwuVG9vbGJhciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIHRoZSB0b29sYmFyXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKG9wdGlvbnMpOiB2b2lkXG5cdC8vIFRvb2xiYXIgY29uc3RydWN0b3Jcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9tb2RlcyA9IHt9O1xuXHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnMgPSBbXTtcblx0XHR0aGlzLl9hY3RpdmVNb2RlID0gbnVsbDtcblxuXHRcdHZhciB2ZXJzaW9uID0gTC52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0Ly9JZiBWZXJzaW9uIGlzID49IDEuMi4wXG5cdFx0aWYgKHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSA9PT0gMSAmJiBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCkgPj0gMikge1xuXHRcdFx0TC5Ub29sYmFyLmluY2x1ZGUoTC5FdmVudGVkLnByb3RvdHlwZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuVG9vbGJhci5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IGJvb2xlYW5cblx0Ly8gR2V0cyBhIHRydWUvZmFsc2Ugb2Ygd2hldGhlciB0aGUgdG9vbGJhciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlTW9kZSAhPT0gbnVsbDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdm9pZFxuXHQvLyBEaXNhYmxlcyB0aGUgdG9vbGJhclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5kaXNhYmxlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRUb29sYmFyKG1hcCk6IEwuRG9tVXRpbFxuXHQvLyBBZGRzIHRoZSB0b29sYmFyIHRvIHRoZSBtYXAgYW5kIHJldHVybnMgdGhlIHRvb2xiYXIgZG9tIGVsZW1lbnRcblx0YWRkVG9vbGJhcjogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1kcmF3LXNlY3Rpb24nKSxcblx0XHRcdGJ1dHRvbkluZGV4ID0gMCxcblx0XHRcdGJ1dHRvbkNsYXNzUHJlZml4ID0gdGhpcy5fdG9vbGJhckNsYXNzIHx8ICcnLFxuXHRcdFx0bW9kZUhhbmRsZXJzID0gdGhpcy5nZXRNb2RlSGFuZGxlcnMobWFwKSxcblx0XHRcdGk7XG5cblx0XHR0aGlzLl90b29sYmFyQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy10b29sYmFyIGxlYWZsZXQtYmFyJyk7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IG1vZGVIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKG1vZGVIYW5kbGVyc1tpXS5lbmFibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXRNb2RlSGFuZGxlcihcblx0XHRcdFx0XHRtb2RlSGFuZGxlcnNbaV0uaGFuZGxlcixcblx0XHRcdFx0XHR0aGlzLl90b29sYmFyQ29udGFpbmVyLFxuXHRcdFx0XHRcdGJ1dHRvbkluZGV4KyssXG5cdFx0XHRcdFx0YnV0dG9uQ2xhc3NQcmVmaXgsXG5cdFx0XHRcdFx0bW9kZUhhbmRsZXJzW2ldLnRpdGxlXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgbm8gYnV0dG9ucyB3ZXJlIGFkZGVkLCBkbyBub3QgYWRkIHRoZSB0b29sYmFyXG5cdFx0aWYgKCFidXR0b25JbmRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNhdmUgYnV0dG9uIGluZGV4IG9mIHRoZSBsYXN0IGJ1dHRvbiwgLTEgYXMgd2Ugd291bGQgaGF2ZSArKyBhZnRlciB0aGUgbGFzdCBidXR0b25cblx0XHR0aGlzLl9sYXN0QnV0dG9uSW5kZXggPSAtLWJ1dHRvbkluZGV4O1xuXG5cdFx0Ly8gQ3JlYXRlIGVtcHR5IGFjdGlvbnMgcGFydCBvZiB0aGUgdG9vbGJhclxuXHRcdHRoaXMuX2FjdGlvbnNDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCd1bCcsICdsZWFmbGV0LWRyYXctYWN0aW9ucycpO1xuXG5cdFx0Ly8gQWRkIGRyYXcgYW5kIGNhbmNlbCBjb250YWluZXJzIHRvIHRoZSBjb250cm9sIGNvbnRhaW5lclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl90b29sYmFyQ29udGFpbmVyKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYWN0aW9uc0NvbnRhaW5lcik7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlVG9vbGJhcigpOiB2b2lkXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2xiYXIgYW5kIGRyb3BzIHRoZSBoYW5kbGVyIGV2ZW50IGxpc3RlbmVyc1xuXHRyZW1vdmVUb29sYmFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRGlzcG9zZSBlYWNoIGhhbmRsZXJcblx0XHRmb3IgKHZhciBoYW5kbGVySWQgaW4gdGhpcy5fbW9kZXMpIHtcblx0XHRcdGlmICh0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eShoYW5kbGVySWQpKSB7XG5cdFx0XHRcdC8vIFVuYmluZCBoYW5kbGVyIGJ1dHRvblxuXHRcdFx0XHR0aGlzLl9kaXNwb3NlQnV0dG9uKFxuXHRcdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uYnV0dG9uLFxuXHRcdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uaGFuZGxlci5lbmFibGUsXG5cdFx0XHRcdFx0dGhpcy5fbW9kZXNbaGFuZGxlcklkXS5oYW5kbGVyXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIGlzIGRpc2FibGVkXG5cdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uaGFuZGxlci5kaXNhYmxlKCk7XG5cblx0XHRcdFx0Ly8gVW5iaW5kIGhhbmRsZXJcblx0XHRcdFx0dGhpcy5fbW9kZXNbaGFuZGxlcklkXS5oYW5kbGVyXG5cdFx0XHRcdFx0Lm9mZignZW5hYmxlZCcsIHRoaXMuX2hhbmRsZXJBY3RpdmF0ZWQsIHRoaXMpXG5cdFx0XHRcdFx0Lm9mZignZGlzYWJsZWQnLCB0aGlzLl9oYW5kbGVyRGVhY3RpdmF0ZWQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9tb2RlcyA9IHt9O1xuXG5cdFx0Ly8gRGlzcG9zZSB0aGUgYWN0aW9ucyB0b29sYmFyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9hY3Rpb25CdXR0b25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fZGlzcG9zZUJ1dHRvbihcblx0XHRcdFx0dGhpcy5fYWN0aW9uQnV0dG9uc1tpXS5idXR0b24sXG5cdFx0XHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnNbaV0uY2FsbGJhY2ssXG5cdFx0XHRcdHRoaXNcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnMgPSBbXTtcblx0XHR0aGlzLl9hY3Rpb25zQ29udGFpbmVyID0gbnVsbDtcblx0fSxcblxuXHRfaW5pdE1vZGVIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlciwgY29udGFpbmVyLCBidXR0b25JbmRleCwgY2xhc3NOYW1lUHJlZGl4LCBidXR0b25UaXRsZSkge1xuXHRcdHZhciB0eXBlID0gaGFuZGxlci50eXBlO1xuXG5cdFx0dGhpcy5fbW9kZXNbdHlwZV0gPSB7fTtcblxuXHRcdHRoaXMuX21vZGVzW3R5cGVdLmhhbmRsZXIgPSBoYW5kbGVyO1xuXG5cdFx0dGhpcy5fbW9kZXNbdHlwZV0uYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHR0aXRsZTogYnV0dG9uVGl0bGUsXG5cdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZVByZWRpeCArICctJyArIHR5cGUsXG5cdFx0XHRjb250YWluZXI6IGNvbnRhaW5lcixcblx0XHRcdGNhbGxiYWNrOiB0aGlzLl9tb2Rlc1t0eXBlXS5oYW5kbGVyLmVuYWJsZSxcblx0XHRcdGNvbnRleHQ6IHRoaXMuX21vZGVzW3R5cGVdLmhhbmRsZXJcblx0XHR9KTtcblxuXHRcdHRoaXMuX21vZGVzW3R5cGVdLmJ1dHRvbkluZGV4ID0gYnV0dG9uSW5kZXg7XG5cblx0XHR0aGlzLl9tb2Rlc1t0eXBlXS5oYW5kbGVyXG5cdFx0XHQub24oJ2VuYWJsZWQnLCB0aGlzLl9oYW5kbGVyQWN0aXZhdGVkLCB0aGlzKVxuXHRcdFx0Lm9uKCdkaXNhYmxlZCcsIHRoaXMuX2hhbmRsZXJEZWFjdGl2YXRlZCwgdGhpcyk7XG5cdH0sXG5cblx0LyogRGV0ZWN0IGlPUyBiYXNlZCBvbiBicm93c2VyIFVzZXIgQWdlbnQsIGJhc2VkIG9uOlxuXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85MDM5ODg1ICovXG5cdF9kZXRlY3RJT1M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaU9TID0gKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW0pO1xuXHRcdHJldHVybiBpT1M7XG5cdH0sXG5cblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuXHRcdHZhciBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnLCBvcHRpb25zLmNvbnRhaW5lcik7XG5cdFx0Ly8gU2NyZWVuIHJlYWRlciB0YWdcblx0XHR2YXIgc3IgPSBMLkRvbVV0aWwuY3JlYXRlKCdzcGFuJywgJ3NyLW9ubHknLCBvcHRpb25zLmNvbnRhaW5lcik7XG5cblx0XHRsaW5rLmhyZWYgPSAnIyc7XG5cdFx0bGluay5hcHBlbmRDaGlsZChzcik7XG5cblx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xuXHRcdFx0bGluay50aXRsZSA9IG9wdGlvbnMudGl0bGU7XG5cdFx0XHRzci5pbm5lckhUTUwgPSBvcHRpb25zLnRpdGxlO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnRleHQpIHtcblx0XHRcdGxpbmsuaW5uZXJIVE1MID0gb3B0aW9ucy50ZXh0O1xuXHRcdFx0c3IuaW5uZXJIVE1MID0gb3B0aW9ucy50ZXh0O1xuXHRcdH1cblxuXHRcdC8qIGlPUyBkb2VzIG5vdCB1c2UgY2xpY2sgZXZlbnRzICovXG5cdFx0dmFyIGJ1dHRvbkV2ZW50ID0gdGhpcy5fZGV0ZWN0SU9TKCkgPyAndG91Y2hzdGFydCcgOiAnY2xpY2snO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdFx0Lm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuXHRcdFx0Lm9uKGxpbmssICdtb3VzZWRvd24nLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vbihsaW5rLCAnZGJsY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vbihsaW5rLCAndG91Y2hzdGFydCcsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuXHRcdFx0Lm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpXG5cdFx0XHQub24obGluaywgYnV0dG9uRXZlbnQsIG9wdGlvbnMuY2FsbGJhY2ssIG9wdGlvbnMuY29udGV4dCk7XG5cblx0XHRyZXR1cm4gbGluaztcblx0fSxcblxuXHRfZGlzcG9zZUJ1dHRvbjogZnVuY3Rpb24gKGJ1dHRvbiwgY2FsbGJhY2spIHtcblx0XHQvKiBpT1MgZG9lcyBub3QgdXNlIGNsaWNrIGV2ZW50cyAqL1xuXHRcdHZhciBidXR0b25FdmVudCA9IHRoaXMuX2RldGVjdElPUygpID8gJ3RvdWNoc3RhcnQnIDogJ2NsaWNrJztcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vZmYoYnV0dG9uLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vZmYoYnV0dG9uLCAnbW91c2Vkb3duJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdFx0XHQub2ZmKGJ1dHRvbiwgJ2RibGNsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdFx0XHQub2ZmKGJ1dHRvbiwgJ3RvdWNoc3RhcnQnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vZmYoYnV0dG9uLCAnY2xpY2snLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KVxuXHRcdFx0Lm9mZihidXR0b24sIGJ1dHRvbkV2ZW50LCBjYWxsYmFjayk7XG5cdH0sXG5cblx0X2hhbmRsZXJBY3RpdmF0ZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gRGlzYWJsZSBhY3RpdmUgbW9kZSAoaWYgcHJlc2VudClcblx0XHR0aGlzLmRpc2FibGUoKTtcblxuXHRcdC8vIENhY2hlIG5ldyBhY3RpdmUgZmVhdHVyZVxuXHRcdHRoaXMuX2FjdGl2ZU1vZGUgPSB0aGlzLl9tb2Rlc1tlLmhhbmRsZXJdO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2FjdGl2ZU1vZGUuYnV0dG9uLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItYnV0dG9uLWVuYWJsZWQnKTtcblxuXHRcdHRoaXMuX3Nob3dBY3Rpb25zVG9vbGJhcigpO1xuXG5cdFx0dGhpcy5maXJlKCdlbmFibGUnKTtcblx0fSxcblxuXHRfaGFuZGxlckRlYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faGlkZUFjdGlvbnNUb29sYmFyKCk7XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fYWN0aXZlTW9kZS5idXR0b24sICdsZWFmbGV0LWRyYXctdG9vbGJhci1idXR0b24tZW5hYmxlZCcpO1xuXG5cdFx0dGhpcy5fYWN0aXZlTW9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmZpcmUoJ2Rpc2FibGUnKTtcblx0fSxcblxuXHRfY3JlYXRlQWN0aW9uczogZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fYWN0aW9uc0NvbnRhaW5lcixcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLmdldEFjdGlvbnMoaGFuZGxlciksXG5cdFx0XHRsID0gYnV0dG9ucy5sZW5ndGgsXG5cdFx0XHRsaSwgZGksIGRsLCBidXR0b247XG5cblx0XHQvLyBEaXNwb3NlIHRoZSBhY3Rpb25zIHRvb2xiYXIgKHRvZG86IGRpc3Bvc2Ugb25seSBub3QgdXNlZCBidXR0b25zKVxuXHRcdGZvciAoZGkgPSAwLCBkbCA9IHRoaXMuX2FjdGlvbkJ1dHRvbnMubGVuZ3RoOyBkaSA8IGRsOyBkaSsrKSB7XG5cdFx0XHR0aGlzLl9kaXNwb3NlQnV0dG9uKHRoaXMuX2FjdGlvbkJ1dHRvbnNbZGldLmJ1dHRvbiwgdGhpcy5fYWN0aW9uQnV0dG9uc1tkaV0uY2FsbGJhY2spO1xuXHRcdH1cblx0XHR0aGlzLl9hY3Rpb25CdXR0b25zID0gW107XG5cblx0XHQvLyBSZW1vdmUgYWxsIG9sZCBidXR0b25zXG5cdFx0d2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoJ2VuYWJsZWQnIGluIGJ1dHRvbnNbaV0gJiYgIWJ1dHRvbnNbaV0uZW5hYmxlZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bGkgPSBMLkRvbVV0aWwuY3JlYXRlKCdsaScsICcnLCBjb250YWluZXIpO1xuXG5cdFx0XHRidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oe1xuXHRcdFx0XHR0aXRsZTogYnV0dG9uc1tpXS50aXRsZSxcblx0XHRcdFx0dGV4dDogYnV0dG9uc1tpXS50ZXh0LFxuXHRcdFx0XHRjb250YWluZXI6IGxpLFxuXHRcdFx0XHRjYWxsYmFjazogYnV0dG9uc1tpXS5jYWxsYmFjayxcblx0XHRcdFx0Y29udGV4dDogYnV0dG9uc1tpXS5jb250ZXh0XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fYWN0aW9uQnV0dG9ucy5wdXNoKHtcblx0XHRcdFx0YnV0dG9uOiBidXR0b24sXG5cdFx0XHRcdGNhbGxiYWNrOiBidXR0b25zW2ldLmNhbGxiYWNrXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X3Nob3dBY3Rpb25zVG9vbGJhcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBidXR0b25JbmRleCA9IHRoaXMuX2FjdGl2ZU1vZGUuYnV0dG9uSW5kZXgsXG5cdFx0XHRsYXN0QnV0dG9uSW5kZXggPSB0aGlzLl9sYXN0QnV0dG9uSW5kZXgsXG5cdFx0XHR0b29sYmFyUG9zaXRpb24gPSB0aGlzLl9hY3RpdmVNb2RlLmJ1dHRvbi5vZmZzZXRUb3AgLSAxO1xuXG5cdFx0Ly8gUmVjcmVhdGUgYWN0aW9uIGJ1dHRvbnMgb24gZXZlcnkgY2xpY2tcblx0XHR0aGlzLl9jcmVhdGVBY3Rpb25zKHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlcik7XG5cblx0XHQvLyBDb3JyZWN0bHkgcG9zaXRpb24gdGhlIGNhbmNlbCBidXR0b25cblx0XHR0aGlzLl9hY3Rpb25zQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRvb2xiYXJQb3NpdGlvbiArICdweCc7XG5cblx0XHRpZiAoYnV0dG9uSW5kZXggPT09IDApIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm90b3AnKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMtdG9wJyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ1dHRvbkluZGV4ID09PSBsYXN0QnV0dG9uSW5kZXgpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm9ib3R0b20nKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMtYm90dG9tJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWN0aW9uc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuVE9PTEJBUk9QRU5FRCk7XG5cdH0sXG5cblx0X2hpZGVBY3Rpb25zVG9vbGJhcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2FjdGlvbnNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm90b3AnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbGJhckNvbnRhaW5lciwgJ2xlYWZsZXQtZHJhdy10b29sYmFyLW5vYm90dG9tJyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2FjdGlvbnNDb250YWluZXIsICdsZWFmbGV0LWRyYXctYWN0aW9ucy10b3AnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fYWN0aW9uc0NvbnRhaW5lciwgJ2xlYWZsZXQtZHJhdy1hY3Rpb25zLWJvdHRvbScpO1xuXHRcdHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5UT09MQkFSQ0xPU0VEKTtcblx0fVxufSk7XG5cblxuXG5MLkRyYXcgPSBMLkRyYXcgfHwge307XG4vKipcbiAqIEBjbGFzcyBMLkRyYXcuVG9vbHRpcFxuICogQGFrYSBUb29sdGlwXG4gKlxuICogVGhlIHRvb2x0aXAgY2xhc3Mg4oCUIGl0IGlzIHVzZWQgdG8gZGlzcGxheSB0aGUgdG9vbHRpcCB3aGlsZSBkcmF3aW5nXG4gKiBUaGlzIHdpbGwgYmUgZGVwcmVjaWF0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAgICB2YXIgdG9vbHRpcCA9IEwuRHJhdy5Ub29sdGlwKCk7XG4gKiBgYGBcbiAqXG4gKi9cbkwuRHJhdy5Ub29sdGlwID0gTC5DbGFzcy5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBkcmF3IHN0YXRlXG5cblx0Ly8gQG1ldGhvZCBpbml0aWFsaXplKG1hcCk6IHZvaWRcblx0Ly8gVG9vbHRpcCBjb25zdHJ1Y3RvclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3BvcHVwUGFuZSA9IG1hcC5fcGFuZXMucG9wdXBQYW5lO1xuXHRcdHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5vcHRpb25zLmRyYXdDb250cm9sVG9vbHRpcHMgP1xuXHRcdFx0TC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy10b29sdGlwJywgdGhpcy5fcG9wdXBQYW5lKSA6IG51bGw7XG5cdFx0dGhpcy5fc2luZ2xlTGluZUxhYmVsID0gZmFsc2U7XG5cblx0XHR0aGlzLl9tYXAub24oJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZU91dCwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNwb3NlKCk6IHZvaWRcblx0Ly8gUmVtb3ZlIFRvb2x0aXAgRE9NIGFuZCB1bmJpbmQgZXZlbnRzXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5fcG9wdXBQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZUNvbnRlbnQobGFiZWxUZXh0KTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSB0b29sdGlwIHRleHQgdG8gc3RyaW5nIGluIGZ1bmN0aW9uIGNhbGxcblx0dXBkYXRlQ29udGVudDogZnVuY3Rpb24gKGxhYmVsVGV4dCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0bGFiZWxUZXh0LnN1YnRleHQgPSBsYWJlbFRleHQuc3VidGV4dCB8fCAnJztcblxuXHRcdC8vIHVwZGF0ZSB0aGUgdmVydGljYWwgcG9zaXRpb24gKG9ubHkgaWYgY2hhbmdlZClcblx0XHRpZiAobGFiZWxUZXh0LnN1YnRleHQubGVuZ3RoID09PSAwICYmICF0aGlzLl9zaW5nbGVMaW5lTGFiZWwpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWRyYXctdG9vbHRpcC1zaW5nbGUnKTtcblx0XHRcdHRoaXMuX3NpbmdsZUxpbmVMYWJlbCA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGxhYmVsVGV4dC5zdWJ0ZXh0Lmxlbmd0aCA+IDAgJiYgdGhpcy5fc2luZ2xlTGluZUxhYmVsKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2x0aXAtc2luZ2xlJyk7XG5cdFx0XHR0aGlzLl9zaW5nbGVMaW5lTGFiZWwgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID1cblx0XHRcdChsYWJlbFRleHQuc3VidGV4dC5sZW5ndGggPiAwID9cblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwibGVhZmxldC1kcmF3LXRvb2x0aXAtc3VidGV4dFwiPicgKyBsYWJlbFRleHQuc3VidGV4dCArICc8L3NwYW4+JyArICc8YnIgLz4nIDogJycpICtcblx0XHRcdCc8c3Bhbj4nICsgbGFiZWxUZXh0LnRleHQgKyAnPC9zcGFuPic7XG5cblx0XHRpZiAoIWxhYmVsVGV4dC50ZXh0ICYmICFsYWJlbFRleHQuc3VidGV4dCkge1xuXHRcdFx0dGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdpbmhlcml0Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVwZGF0ZVBvc2l0aW9uKGxhdGxuZyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgbG9jYXRpb24gb2YgdGhlIHRvb2x0aXBcblx0dXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLFxuXHRcdFx0dG9vbHRpcENvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdGlmICh0aGlzLl92aXNpYmxlKSB7XG5cdFx0XHRcdHRvb2x0aXBDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdpbmhlcml0Jztcblx0XHRcdH1cblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0b29sdGlwQ29udGFpbmVyLCBwb3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2hvd0FzRXJyb3IoKTogdGhpc1xuXHQvLyBBcHBsaWVzIGVycm9yIGNsYXNzIHRvIHRvb2x0aXBcblx0c2hvd0FzRXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1lcnJvci1kcmF3LXRvb2x0aXAnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVFcnJvcigpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGVycm9yIGNsYXNzIGZyb20gdGhlIHRvb2x0aXBcblx0cmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1lcnJvci1kcmF3LXRvb2x0aXAnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG4vKipcbiAqIEBjbGFzcyBMLkRyYXdUb29sYmFyXG4gKiBAYWthIFRvb2xiYXJcbiAqL1xuTC5EcmF3VG9vbGJhciA9IEwuVG9vbGJhci5leHRlbmQoe1xuXG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnZHJhdydcblx0fSxcblxuXHRvcHRpb25zOiB7XG5cdFx0cG9seWxpbmU6IHt9LFxuXHRcdHBvbHlnb246IHt9LFxuXHRcdHJlY3RhbmdsZToge30sXG5cdFx0Y2lyY2xlOiB7fSxcblx0XHRtYXJrZXI6IHt9LFxuXHRcdGNpcmNsZW1hcmtlcjoge31cblx0fSxcblxuXHQvLyBAbWV0aG9kIGluaXRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEVuc3VyZSB0aGF0IHRoZSBvcHRpb25zIGFyZSBtZXJnZWQgY29ycmVjdGx5IHNpbmNlIEwuZXh0ZW5kIGlzIG9ubHkgc2hhbGxvd1xuXHRcdGZvciAodmFyIHR5cGUgaW4gdGhpcy5vcHRpb25zKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zW3R5cGVdKSB7XG5cdFx0XHRcdFx0b3B0aW9uc1t0eXBlXSA9IEwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnNbdHlwZV0sIG9wdGlvbnNbdHlwZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9vbGJhckNsYXNzID0gJ2xlYWZsZXQtZHJhdy1kcmF3Jztcblx0XHRMLlRvb2xiYXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldE1vZGVIYW5kbGVycygpOiBvYmplY3Rcblx0Ly8gR2V0IG1vZGUgaGFuZGxlcnMgaW5mb3JtYXRpb25cblx0Z2V0TW9kZUhhbmRsZXJzOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLnBvbHlsaW5lLFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5EcmF3LlBvbHlsaW5lKG1hcCwgdGhpcy5vcHRpb25zLnBvbHlsaW5lKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLnBvbHlsaW5lXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiB0aGlzLm9wdGlvbnMucG9seWdvbixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5Qb2x5Z29uKG1hcCwgdGhpcy5vcHRpb25zLnBvbHlnb24pLFxuXHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmJ1dHRvbnMucG9seWdvblxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLnJlY3RhbmdsZSxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5SZWN0YW5nbGUobWFwLCB0aGlzLm9wdGlvbnMucmVjdGFuZ2xlKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLnJlY3RhbmdsZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLmNpcmNsZSxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5DaXJjbGUobWFwLCB0aGlzLm9wdGlvbnMuY2lyY2xlKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLmNpcmNsZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLm1hcmtlcixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5NYXJrZXIobWFwLCB0aGlzLm9wdGlvbnMubWFya2VyKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLm1hcmtlclxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLmNpcmNsZW1hcmtlcixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5DaXJjbGVNYXJrZXIobWFwLCB0aGlzLm9wdGlvbnMuY2lyY2xlbWFya2VyKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLmNpcmNsZW1hcmtlclxuXHRcdFx0fVxuXHRcdF07XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBY3Rpb25zKCk6IG9iamVjdFxuXHQvLyBHZXQgYWN0aW9uIGluZm9ybWF0aW9uXG5cdGdldEFjdGlvbnM6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogaGFuZGxlci5jb21wbGV0ZVNoYXBlLFxuXHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmZpbmlzaC50aXRsZSxcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmZpbmlzaC50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogaGFuZGxlci5jb21wbGV0ZVNoYXBlLFxuXHRcdFx0XHRjb250ZXh0OiBoYW5kbGVyXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiBoYW5kbGVyLmRlbGV0ZUxhc3RWZXJ0ZXgsXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIudW5kby50aXRsZSxcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLnVuZG8udGV4dCxcblx0XHRcdFx0Y2FsbGJhY2s6IGhhbmRsZXIuZGVsZXRlTGFzdFZlcnRleCxcblx0XHRcdFx0Y29udGV4dDogaGFuZGxlclxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5hY3Rpb25zLnRpdGxlLFxuXHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuYWN0aW9ucy50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5kaXNhYmxlLFxuXHRcdFx0XHRjb250ZXh0OiB0aGlzXG5cdFx0XHR9XG5cdFx0XTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wdGlvbnMoKTogdm9pZFxuXHQvLyBTZXRzIHRoZSBvcHRpb25zIHRvIHRoZSB0b29sYmFyXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0aGlzLl9tb2Rlcykge1xuXHRcdFx0aWYgKHRoaXMuX21vZGVzLmhhc093blByb3BlcnR5KHR5cGUpICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcblx0XHRcdFx0dGhpcy5fbW9kZXNbdHlwZV0uaGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnNbdHlwZV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cblxuXG4vKkwuTWFwLm1lcmdlT3B0aW9ucyh7XG4gZWRpdENvbnRyb2w6IHRydWVcbiB9KTsqL1xuLyoqXG4gKiBAY2xhc3MgTC5FZGl0VG9vbGJhclxuICogQGFrYSBFZGl0VG9vbGJhclxuICovXG5MLkVkaXRUb29sYmFyID0gTC5Ub29sYmFyLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnZWRpdCdcblx0fSxcblxuXHRvcHRpb25zOiB7XG5cdFx0ZWRpdDoge1xuXHRcdFx0c2VsZWN0ZWRQYXRoT3B0aW9uczoge1xuXHRcdFx0XHRkYXNoQXJyYXk6ICcxMCwgMTAnLFxuXG5cdFx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRcdGZpbGxDb2xvcjogJyNmZTU3YTEnLFxuXHRcdFx0XHRmaWxsT3BhY2l0eTogMC4xLFxuXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gdXNlciB0aGUgZXhpc3RpbmcgbGF5ZXJzIGNvbG9yXG5cdFx0XHRcdG1haW50YWluQ29sb3I6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW1vdmU6IHt9LFxuXHRcdHBvbHk6IG51bGwsXG5cdFx0ZmVhdHVyZUdyb3VwOiBudWxsIC8qIFJFUVVJUkVEISBUT0RPOiBwZXJoYXBzIGlmIG5vdCBzZXQgdGhlbiBhbGwgbGF5ZXJzIG9uIHRoZSBtYXAgYXJlIHNlbGVjdGFibGU/ICovXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIE5lZWQgdG8gc2V0IHRoaXMgbWFudWFsbHkgc2luY2UgbnVsbCBpcyBhbiBhY2NlcHRhYmxlIHZhbHVlIGhlcmVcblx0XHRpZiAob3B0aW9ucy5lZGl0KSB7XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuZWRpdC5zZWxlY3RlZFBhdGhPcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRvcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnM7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuZWRpdC5zZWxlY3RlZFBhdGhPcHRpb25zLCBvcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMucmVtb3ZlKSB7XG5cdFx0XHRvcHRpb25zLnJlbW92ZSA9IEwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMucmVtb3ZlLCBvcHRpb25zLnJlbW92ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMucG9seSkge1xuXHRcdFx0b3B0aW9ucy5wb2x5ID0gTC5leHRlbmQoe30sIHRoaXMub3B0aW9ucy5wb2x5LCBvcHRpb25zLnBvbHkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Rvb2xiYXJDbGFzcyA9ICdsZWFmbGV0LWRyYXctZWRpdCc7XG5cdFx0TC5Ub29sYmFyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9zZWxlY3RlZEZlYXR1cmVDb3VudCA9IDA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRNb2RlSGFuZGxlcnMoKTogb2JqZWN0XG5cdC8vIEdldCBtb2RlIGhhbmRsZXJzIGluZm9ybWF0aW9uXG5cdGdldE1vZGVIYW5kbGVyczogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBmZWF0dXJlR3JvdXAgPSB0aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwO1xuXHRcdHJldHVybiBbXG5cdFx0XHR7XG5cdFx0XHRcdGVuYWJsZWQ6IHRoaXMub3B0aW9ucy5lZGl0LFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5FZGl0VG9vbGJhci5FZGl0KG1hcCwge1xuXHRcdFx0XHRcdGZlYXR1cmVHcm91cDogZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRcdHNlbGVjdGVkUGF0aE9wdGlvbnM6IHRoaXMub3B0aW9ucy5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnMsXG5cdFx0XHRcdFx0cG9seTogdGhpcy5vcHRpb25zLnBvbHlcblx0XHRcdFx0fSksXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5lZGl0XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiB0aGlzLm9wdGlvbnMucmVtb3ZlLFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5FZGl0VG9vbGJhci5EZWxldGUobWFwLCB7XG5cdFx0XHRcdFx0ZmVhdHVyZUdyb3VwOiBmZWF0dXJlR3JvdXBcblx0XHRcdFx0fSksXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5yZW1vdmVcblx0XHRcdH1cblx0XHRdO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QWN0aW9ucygpOiBvYmplY3Rcblx0Ly8gR2V0IGFjdGlvbnMgaW5mb3JtYXRpb25cblx0Z2V0QWN0aW9uczogZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHR2YXIgYWN0aW9ucyA9IFtcblx0XHRcdHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLnNhdmUudGl0bGUsXG5cdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLnNhdmUudGV4dCxcblx0XHRcdFx0Y2FsbGJhY2s6IHRoaXMuX3NhdmUsXG5cdFx0XHRcdGNvbnRleHQ6IHRoaXNcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYWN0aW9ucy5jYW5jZWwudGl0bGUsXG5cdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLmNhbmNlbC50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5kaXNhYmxlLFxuXHRcdFx0XHRjb250ZXh0OiB0aGlzXG5cdFx0XHR9XG5cdFx0XTtcblxuXHRcdGlmIChoYW5kbGVyLnJlbW92ZUFsbExheWVycykge1xuXHRcdFx0YWN0aW9ucy5wdXNoKHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLmNsZWFyQWxsLnRpdGxlLFxuXHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYWN0aW9ucy5jbGVhckFsbC50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5fY2xlYXJBbGxMYXllcnMsXG5cdFx0XHRcdGNvbnRleHQ6IHRoaXNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY3Rpb25zO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkVG9vbGJhcihtYXApOiBMLkRvbVV0aWxcblx0Ly8gQWRkcyB0aGUgdG9vbGJhciB0byB0aGUgbWFwXG5cdGFkZFRvb2xiYXI6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY29udGFpbmVyID0gTC5Ub29sYmFyLnByb3RvdHlwZS5hZGRUb29sYmFyLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWQoKTtcblxuXHRcdHRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXAub24oJ2xheWVyYWRkIGxheWVycmVtb3ZlJywgdGhpcy5fY2hlY2tEaXNhYmxlZCwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlVG9vbGJhcigpOiB2b2lkXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2xiYXIgZnJvbSB0aGUgbWFwXG5cdHJlbW92ZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwLm9mZignbGF5ZXJhZGQgbGF5ZXJyZW1vdmUnLCB0aGlzLl9jaGVja0Rpc2FibGVkLCB0aGlzKTtcblxuXHRcdEwuVG9vbGJhci5wcm90b3R5cGUucmVtb3ZlVG9vbGJhci5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB2b2lkXG5cdC8vIERpc2FibGVzIHRoZSB0b29sYmFyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuZW5hYmxlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWN0aXZlTW9kZS5oYW5kbGVyLnJldmVydExheWVycygpO1xuXG5cdFx0TC5Ub29sYmFyLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0X3NhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuc2F2ZSgpO1xuXHRcdGlmICh0aGlzLl9hY3RpdmVNb2RlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuZGlzYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2xlYXJBbGxMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIucmVtb3ZlQWxsTGF5ZXJzKCk7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZU1vZGUpIHtcblx0XHRcdHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGVja0Rpc2FibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGZlYXR1cmVHcm91cCA9IHRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXAsXG5cdFx0XHRoYXNMYXllcnMgPSBmZWF0dXJlR3JvdXAuZ2V0TGF5ZXJzKCkubGVuZ3RoICE9PSAwLFxuXHRcdFx0YnV0dG9uO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5lZGl0KSB7XG5cdFx0XHRidXR0b24gPSB0aGlzLl9tb2Rlc1tMLkVkaXRUb29sYmFyLkVkaXQuVFlQRV0uYnV0dG9uO1xuXG5cdFx0XHRpZiAoaGFzTGF5ZXJzKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhidXR0b24sICdsZWFmbGV0LWRpc2FibGVkJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoYnV0dG9uLCAnbGVhZmxldC1kaXNhYmxlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRidXR0b24uc2V0QXR0cmlidXRlKFxuXHRcdFx0XHQndGl0bGUnLFxuXHRcdFx0XHRoYXNMYXllcnMgP1xuXHRcdFx0XHRcdEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXRcblx0XHRcdFx0XHQ6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXREaXNhYmxlZFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnJlbW92ZSkge1xuXHRcdFx0YnV0dG9uID0gdGhpcy5fbW9kZXNbTC5FZGl0VG9vbGJhci5EZWxldGUuVFlQRV0uYnV0dG9uO1xuXG5cdFx0XHRpZiAoaGFzTGF5ZXJzKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhidXR0b24sICdsZWFmbGV0LWRpc2FibGVkJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoYnV0dG9uLCAnbGVhZmxldC1kaXNhYmxlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRidXR0b24uc2V0QXR0cmlidXRlKFxuXHRcdFx0XHQndGl0bGUnLFxuXHRcdFx0XHRoYXNMYXllcnMgP1xuXHRcdFx0XHRcdEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLnJlbW92ZVxuXHRcdFx0XHRcdDogTC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmJ1dHRvbnMucmVtb3ZlRGlzYWJsZWRcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbi8qKlxuICogQGNsYXNzIEwuRWRpdFRvb2xiYXIuRWRpdFxuICogQGFrYSBFZGl0VG9vbGJhci5FZGl0XG4gKi9cbkwuRWRpdFRvb2xiYXIuRWRpdCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRzdGF0aWNzOiB7XG5cdFx0VFlQRTogJ2VkaXQnXG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpbnRpYWxpemUoKTogdm9pZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHRcdC8vIFN0b3JlIHRoZSBzZWxlY3RhYmxlIGxheWVyIGdyb3VwIGZvciBlYXNlIG9mIGFjY2Vzc1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IG9wdGlvbnMuZmVhdHVyZUdyb3VwO1xuXG5cdFx0aWYgKCEodGhpcy5fZmVhdHVyZUdyb3VwIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuZmVhdHVyZUdyb3VwIG11c3QgYmUgYSBMLkZlYXR1cmVHcm91cCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkVkaXRUb29sYmFyLkVkaXQuVFlQRTtcblxuXHRcdHZhciB2ZXJzaW9uID0gTC52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0Ly9JZiBWZXJzaW9uIGlzID49IDEuMi4wXG5cdFx0aWYgKHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSA9PT0gMSAmJiBwYXJzZUludCh2ZXJzaW9uWzFdLCAxMCkgPj0gMikge1xuXHRcdFx0TC5FZGl0VG9vbGJhci5FZGl0LmluY2x1ZGUoTC5FdmVudGVkLnByb3RvdHlwZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEwuRWRpdFRvb2xiYXIuRWRpdC5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdm9pZFxuXHQvLyBFbmFibGUgdGhlIGVkaXQgdG9vbGJhclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCAhdGhpcy5faGFzQXZhaWxhYmxlTGF5ZXJzKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5maXJlKCdlbmFibGVkJywge2hhbmRsZXI6IHRoaXMudHlwZX0pO1xuXHRcdC8vdGhpcyBkaXNhYmxlIG90aGVyIGhhbmRsZXJzXG5cblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFNUQVJULCB7aGFuZGxlcjogdGhpcy50eXBlfSk7XG5cdFx0Ly9hbGxvdyBkcmF3TGF5ZXIgdG8gYmUgdXBkYXRlZCBiZWZvcmUgYmVnaW5uaW5nIGVkaXRpb24uXG5cblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cFxuXHRcdFx0Lm9uKCdsYXllcmFkZCcsIHRoaXMuX2VuYWJsZUxheWVyRWRpdCwgdGhpcylcblx0XHRcdC5vbignbGF5ZXJyZW1vdmUnLCB0aGlzLl9kaXNhYmxlTGF5ZXJFZGl0LCB0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdm9pZFxuXHQvLyBEaXNhYmxlIHRoZSBlZGl0IHRvb2xiYXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9mZWF0dXJlR3JvdXBcblx0XHRcdC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fZW5hYmxlTGF5ZXJFZGl0LCB0aGlzKVxuXHRcdFx0Lm9mZignbGF5ZXJyZW1vdmUnLCB0aGlzLl9kaXNhYmxlTGF5ZXJFZGl0LCB0aGlzKTtcblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFNUT1AsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblx0XHR0aGlzLmZpcmUoJ2Rpc2FibGVkJywge2hhbmRsZXI6IHRoaXMudHlwZX0pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKTogdm9pZFxuXHQvLyBBZGQgbGlzdGVuZXIgaG9va3MgZm9yIHRoaXMgaGFuZGxlclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRtYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcblxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcih0aGlzLl9lbmFibGVMYXllckVkaXQsIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwID0gbmV3IEwuRHJhdy5Ub29sdGlwKHRoaXMuX21hcCk7XG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe1xuXHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLmVkaXQudG9vbHRpcC50ZXh0LFxuXHRcdFx0XHRzdWJ0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLmVkaXQudG9vbHRpcC5zdWJ0ZXh0XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUXVpY2tseSBhY2Nlc3MgdGhlIHRvb2x0aXAgdG8gdXBkYXRlIGZvciBpbnRlcnNlY3Rpb24gY2hlY2tpbmdcblx0XHRcdG1hcC5fZWRpdFRvb2x0aXAgPSB0aGlzLl90b29sdGlwO1xuXG5cdFx0XHR0aGlzLl91cGRhdGVUb29sdGlwKCk7XG5cblx0XHRcdHRoaXMuX21hcFxuXHRcdFx0XHQub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9uKEwuRHJhdy5FdmVudC5FRElUVkVSVEVYLCB0aGlzLl91cGRhdGVUb29sdGlwLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpOiB2b2lkXG5cdC8vIFJlbW92ZSBsaXN0ZW5lciBob29rcyBmb3IgdGhpcyBoYW5kbGVyXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0Ly8gQ2xlYW4gdXAgc2VsZWN0ZWQgbGF5ZXJzLlxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcih0aGlzLl9kaXNhYmxlTGF5ZXJFZGl0LCB0aGlzKTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGhlIGJhY2t1cHMgb2YgdGhlIG9yaWdpbmFsIGxheWVyc1xuXHRcdFx0dGhpcy5fdW5lZGl0ZWRMYXllclByb3BzID0ge307XG5cblx0XHRcdHRoaXMuX3Rvb2x0aXAuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cblx0XHRcdHRoaXMuX21hcFxuXHRcdFx0XHQub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpXG5cdFx0XHRcdC5vZmYoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZihMLkRyYXcuRXZlbnQuRURJVFZFUlRFWCwgdGhpcy5fdXBkYXRlVG9vbHRpcCwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmV2ZXJ0TGF5ZXJzKCk6IHZvaWRcblx0Ly8gUmV2ZXJ0IGVhY2ggbGF5ZXIncyBnZW9tZXRyeSBjaGFuZ2VzXG5cdHJldmVydExheWVyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9yZXZlcnRMYXllcihsYXllcik7XG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzYXZlKCk6IHZvaWRcblx0Ly8gU2F2ZSB0aGUgbGF5ZXIgZ2VvbWV0cmllc1xuXHRzYXZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVkaXRlZExheWVycyA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xuXHRcdFx0aWYgKGxheWVyLmVkaXRlZCkge1xuXHRcdFx0XHRlZGl0ZWRMYXllcnMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHRsYXllci5lZGl0ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVEVELCB7bGF5ZXJzOiBlZGl0ZWRMYXllcnN9KTtcblx0fSxcblxuXHRfYmFja3VwTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0pIHtcblx0XHRcdC8vIFBvbHlsaW5lLCBQb2x5Z29uIG9yIFJlY3RhbmdsZVxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5bGluZSB8fCBsYXllciBpbnN0YW5jZW9mIEwuUG9seWdvbiB8fCBsYXllciBpbnN0YW5jZW9mIEwuUmVjdGFuZ2xlKSB7XG5cdFx0XHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0gPSB7XG5cdFx0XHRcdFx0bGF0bG5nczogTC5MYXRMbmdVdGlsLmNsb25lTGF0TG5ncyhsYXllci5nZXRMYXRMbmdzKCkpXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGUpIHtcblx0XHRcdFx0dGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXSA9IHtcblx0XHRcdFx0XHRsYXRsbmc6IEwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZyhsYXllci5nZXRMYXRMbmcoKSksXG5cdFx0XHRcdFx0cmFkaXVzOiBsYXllci5nZXRSYWRpdXMoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyIHx8IGxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGVNYXJrZXIpIHsgLy8gTWFya2VyXG5cdFx0XHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0gPSB7XG5cdFx0XHRcdFx0bGF0bG5nOiBMLkxhdExuZ1V0aWwuY2xvbmVMYXRMbmcobGF5ZXIuZ2V0TGF0TG5nKCkpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUb29sdGlwVGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAoe1xuXHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxcblx0XHRcdHN1YnRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnN1YnRleHRcblx0XHR9KTtcblx0fSxcblxuXHRfdXBkYXRlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKTtcblx0fSxcblxuXHRfcmV2ZXJ0TGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuVXRpbC5zdGFtcChsYXllcik7XG5cdFx0bGF5ZXIuZWRpdGVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblx0XHRcdC8vIFBvbHlsaW5lLCBQb2x5Z29uIG9yIFJlY3RhbmdsZVxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5bGluZSB8fCBsYXllciBpbnN0YW5jZW9mIEwuUG9seWdvbiB8fCBsYXllciBpbnN0YW5jZW9mIEwuUmVjdGFuZ2xlKSB7XG5cdFx0XHRcdGxheWVyLnNldExhdExuZ3ModGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5sYXRsbmdzKTtcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkNpcmNsZSkge1xuXHRcdFx0XHRsYXllci5zZXRMYXRMbmcodGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5sYXRsbmcpO1xuXHRcdFx0XHRsYXllci5zZXRSYWRpdXModGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5yYWRpdXMpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyIHx8IGxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGVNYXJrZXIpIHsgLy8gTWFya2VyIG9yIENpcmNsZU1hcmtlclxuXHRcdFx0XHRsYXllci5zZXRMYXRMbmcodGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXS5sYXRsbmcpO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXllci5maXJlKCdyZXZlcnQtZWRpdGVkJywge2xheWVyOiBsYXllcn0pO1xuXHRcdH1cblx0fSxcblxuXHRfZW5hYmxlTGF5ZXJFZGl0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZSxcblx0XHRcdHBhdGhPcHRpb25zLCBwb2x5O1xuXG5cdFx0Ly8gQmFjayB1cCB0aGlzIGxheWVyIChpZiBoYXZlbid0IGJlZm9yZSlcblx0XHR0aGlzLl9iYWNrdXBMYXllcihsYXllcik7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnBvbHkpIHtcblx0XHRcdHBvbHkgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMucG9seSk7XG5cdFx0XHRsYXllci5vcHRpb25zLnBvbHkgPSBwb2x5O1xuXHRcdH1cblxuXHRcdC8vIFNldCBkaWZmZXJlbnQgc3R5bGUgZm9yIGVkaXRpbmcgbW9kZVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0ZWRQYXRoT3B0aW9ucykge1xuXHRcdFx0cGF0aE9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRQYXRoT3B0aW9ucyk7XG5cblx0XHRcdC8vIFVzZSB0aGUgZXhpc3RpbmcgY29sb3Igb2YgdGhlIGxheWVyXG5cdFx0XHRpZiAocGF0aE9wdGlvbnMubWFpbnRhaW5Db2xvcikge1xuXHRcdFx0XHRwYXRoT3B0aW9ucy5jb2xvciA9IGxheWVyLm9wdGlvbnMuY29sb3I7XG5cdFx0XHRcdHBhdGhPcHRpb25zLmZpbGxDb2xvciA9IGxheWVyLm9wdGlvbnMuZmlsbENvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXllci5vcHRpb25zLm9yaWdpbmFsID0gTC5leHRlbmQoe30sIGxheWVyLm9wdGlvbnMpO1xuXHRcdFx0bGF5ZXIub3B0aW9ucy5lZGl0aW5nID0gcGF0aE9wdGlvbnM7XG5cblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0aWYgKGxheWVyLmVkaXRpbmcpIHtcblx0XHRcdFx0bGF5ZXIuZWRpdGluZy5lbmFibGUoKTtcblx0XHRcdH1cblx0XHRcdGxheWVyLmRyYWdnaW5nLmVuYWJsZSgpO1xuXHRcdFx0bGF5ZXJcblx0XHRcdFx0Lm9uKCdkcmFnZW5kJywgdGhpcy5fb25NYXJrZXJEcmFnRW5kKVxuXHRcdFx0XHQvLyAjVE9ETzogcmVtb3ZlIHdoZW4gbGVhZmxldCBmaW5hbGx5IGZpeGVzIHRoZWlyIGRyYWdnYWJsZSBzbyBpdCdzIHRvdWNoIGZyaWVuZGx5IGFnYWluLlxuXHRcdFx0XHQub24oJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKVxuXHRcdFx0XHQub24oJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9uKCd0b3VjaGVuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcylcblx0XHRcdFx0Lm9uKCdNU1BvaW50ZXJVcCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLmVkaXRpbmcuZW5hYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kaXNhYmxlTGF5ZXJFZGl0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLmVkaXRlZCA9IGZhbHNlO1xuXHRcdGlmIChsYXllci5lZGl0aW5nKSB7XG5cdFx0XHRsYXllci5lZGl0aW5nLmRpc2FibGUoKTtcblx0XHR9XG5cblx0XHRkZWxldGUgbGF5ZXIub3B0aW9ucy5lZGl0aW5nO1xuXHRcdGRlbGV0ZSBsYXllci5vcHRpb25zLm9yaWdpbmFsO1xuXHRcdC8vIFJlc2V0IGxheWVyIHN0eWxlcyB0byB0aGF0IG9mIGJlZm9yZSBzZWxlY3Rcblx0XHRpZiAodGhpcy5fc2VsZWN0ZWRQYXRoT3B0aW9ucykge1xuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIpIHtcblx0XHRcdFx0dGhpcy5fdG9nZ2xlTWFya2VySGlnaGxpZ2h0KGxheWVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlc2V0IHRoZSBsYXllciBzdHlsZSB0byB3aGF0IGlzIHdhcyBiZWZvcmUgYmVpbmcgc2VsZWN0ZWRcblx0XHRcdFx0bGF5ZXIuc2V0U3R5bGUobGF5ZXIub3B0aW9ucy5wcmV2aW91c09wdGlvbnMpO1xuXHRcdFx0XHQvLyByZW1vdmUgdGhlIGNhY2hlZCBvcHRpb25zIGZvciB0aGUgbGF5ZXIgb2JqZWN0XG5cdFx0XHRcdGRlbGV0ZSBsYXllci5vcHRpb25zLnByZXZpb3VzT3B0aW9ucztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0bGF5ZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuXHRcdFx0bGF5ZXJcblx0XHRcdFx0Lm9mZignZHJhZ2VuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0XHRcdC5vZmYoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9mZigndG91Y2hlbmQnLCB0aGlzLl9vbk1hcmtlckRyYWdFbmQsIHRoaXMpXG5cdFx0XHRcdC5vZmYoJ01TUG9pbnRlclVwJywgdGhpcy5fb25NYXJrZXJEcmFnRW5kLCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGF5ZXIuZWRpdGluZy5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGUubGF0bG5nKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUudGFyZ2V0O1xuXHRcdGxheWVyLmVkaXRlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRNT1ZFLCB7bGF5ZXI6IGxheWVyfSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciB0b3VjaEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KHRvdWNoRXZlbnQpLFxuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHRlLnRhcmdldC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fSxcblxuXHRfaGFzQXZhaWxhYmxlTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZlYXR1cmVHcm91cC5nZXRMYXllcnMoKS5sZW5ndGggIT09IDA7XG5cdH1cbn0pO1xuXG5cblxuLyoqXG4gKiBAY2xhc3MgTC5FZGl0VG9vbGJhci5EZWxldGVcbiAqIEBha2EgRWRpdFRvb2xiYXIuRGVsZXRlXG4gKi9cbkwuRWRpdFRvb2xiYXIuRGVsZXRlID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAncmVtb3ZlJyAvLyBub3QgZGVsZXRlIGFzIGRlbGV0ZSBpcyByZXNlcnZlZCBpbiBqc1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaW50aWFsaXplKCk6IHZvaWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHRMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHRcdC8vIFN0b3JlIHRoZSBzZWxlY3RhYmxlIGxheWVyIGdyb3VwIGZvciBlYXNlIG9mIGFjY2Vzc1xuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVycyA9IHRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXA7XG5cblx0XHRpZiAoISh0aGlzLl9kZWxldGFibGVMYXllcnMgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5mZWF0dXJlR3JvdXAgbXVzdCBiZSBhIEwuRmVhdHVyZUdyb3VwJyk7XG5cdFx0fVxuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkVkaXRUb29sYmFyLkRlbGV0ZS5UWVBFO1xuXG5cdFx0dmFyIHZlcnNpb24gPSBMLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHQvL0lmIFZlcnNpb24gaXMgPj0gMS4yLjBcblx0XHRpZiAocGFyc2VJbnQodmVyc2lvblswXSwgMTApID09PSAxICYmIHBhcnNlSW50KHZlcnNpb25bMV0sIDEwKSA+PSAyKSB7XG5cdFx0XHRMLkVkaXRUb29sYmFyLkRlbGV0ZS5pbmNsdWRlKEwuRXZlbnRlZC5wcm90b3R5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkVkaXRUb29sYmFyLkRlbGV0ZS5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB2b2lkXG5cdC8vIEVuYWJsZSB0aGUgZGVsZXRlIHRvb2xiYXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgIXRoaXMuX2hhc0F2YWlsYWJsZUxheWVycygpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZmlyZSgnZW5hYmxlZCcsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblxuXHRcdHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5ERUxFVEVTVEFSVCwge2hhbmRsZXI6IHRoaXMudHlwZX0pO1xuXG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVyc1xuXHRcdFx0Lm9uKCdsYXllcmFkZCcsIHRoaXMuX2VuYWJsZUxheWVyRGVsZXRlLCB0aGlzKVxuXHRcdFx0Lm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX2Rpc2FibGVMYXllckRlbGV0ZSwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHZvaWRcblx0Ly8gRGlzYWJsZSB0aGUgZGVsZXRlIHRvb2xiYXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVyc1xuXHRcdFx0Lm9mZignbGF5ZXJhZGQnLCB0aGlzLl9lbmFibGVMYXllckRlbGV0ZSwgdGhpcylcblx0XHRcdC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fZGlzYWJsZUxheWVyRGVsZXRlLCB0aGlzKTtcblxuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkRFTEVURVNUT1AsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblxuXHRcdHRoaXMuZmlyZSgnZGlzYWJsZWQnLCB7aGFuZGxlcjogdGhpcy50eXBlfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpOiB2b2lkXG5cdC8vIEFkZCBsaXN0ZW5lciBob29rcyB0byB0aGlzIGhhbmRsZXJcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKG1hcCkge1xuXHRcdFx0bWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XG5cblx0XHRcdHRoaXMuX2RlbGV0YWJsZUxheWVycy5lYWNoTGF5ZXIodGhpcy5fZW5hYmxlTGF5ZXJEZWxldGUsIHRoaXMpO1xuXHRcdFx0dGhpcy5fZGVsZXRlZExheWVycyA9IG5ldyBMLkxheWVyR3JvdXAoKTtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBMLkRyYXcuVG9vbHRpcCh0aGlzLl9tYXApO1xuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHt0ZXh0OiBMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLnJlbW92ZS50b29sdGlwLnRleHR9KTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKTogdm9pZFxuXHQvLyBSZW1vdmUgbGlzdGVuZXIgaG9va3MgZnJvbSB0aGlzIGhhbmRsZXJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9kZWxldGFibGVMYXllcnMuZWFjaExheWVyKHRoaXMuX2Rpc2FibGVMYXllckRlbGV0ZSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9kZWxldGVkTGF5ZXJzID0gbnVsbDtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcC5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblxuXHRcdFx0dGhpcy5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIHJldmVydExheWVycygpOiB2b2lkXG5cdC8vIFJldmVydCB0aGUgZGVsZXRlZCBsYXllcnMgYmFjayB0byB0aGVpciBwcmlvciBzdGF0ZS5cblx0cmV2ZXJ0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvZiB0aGUgZGVsZXRlZCBsYXllcnMgYW5kIGFkZCB0aGVtIGJhY2sgaW50byB0aGUgZmVhdHVyZUdyb3VwXG5cdFx0dGhpcy5fZGVsZXRlZExheWVycy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9kZWxldGFibGVMYXllcnMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmV2ZXJ0LWRlbGV0ZWQnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzYXZlKCk6IHZvaWRcblx0Ly8gU2F2ZSBkZWxldGVkIGxheWVyc1xuXHRzYXZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkRFTEVURUQsIHtsYXllcnM6IHRoaXMuX2RlbGV0ZWRMYXllcnN9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUFsbExheWVycygpOiB2b2lkXG5cdC8vIFJlbW92ZSBhbGwgZGVsYXRlYWJsZSBsYXllcnNcblx0cmVtb3ZlQWxsTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvZiB0aGUgZGVsYXRlYWJsZSBsYXllcnMgYW5kIGFkZCByZW1vdmUgdGhlbVxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVycy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVMYXllcih7bGF5ZXI6IGxheWVyfSk7XG5cdFx0fSwgdGhpcyk7XG5cdFx0dGhpcy5zYXZlKCk7XG5cdH0sXG5cblx0X2VuYWJsZUxheWVyRGVsZXRlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLm9uKCdjbGljaycsIHRoaXMuX3JlbW92ZUxheWVyLCB0aGlzKTtcblx0fSxcblxuXHRfZGlzYWJsZUxheWVyRGVsZXRlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLm9mZignY2xpY2snLCB0aGlzLl9yZW1vdmVMYXllciwgdGhpcyk7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSB0aGUgZGVsZXRlZCBsYXllcnMgc28gd2UgY2FuJ3QgYWNjaWRlbnRhbGx5IHJldmVydCBpZiB0aGUgdXNlciBwcmVzc2VzIGNhbmNlbFxuXHRcdHRoaXMuX2RlbGV0ZWRMYXllcnMucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVMYXllcjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0IHx8IGU7XG5cblx0XHR0aGlzLl9kZWxldGFibGVMYXllcnMucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXG5cdFx0dGhpcy5fZGVsZXRlZExheWVycy5hZGRMYXllcihsYXllcik7XG5cblx0XHRsYXllci5maXJlKCdkZWxldGVkJyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24oZS5sYXRsbmcpO1xuXHR9LFxuXG5cdF9oYXNBdmFpbGFibGVMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVsZXRhYmxlTGF5ZXJzLmdldExheWVycygpLmxlbmd0aCAhPT0gMDtcblx0fVxufSk7XG5cblxuXG59KHdpbmRvdywgZG9jdW1lbnQpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQuZHJhdy1zcmMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet-draw/dist/leaflet.draw-src.js\n");

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzVjN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxvQ0FBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUIsS0FBSyxNQUFNLEVBSU47QUFDTCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoZGVmYXVsdExldmVsLCBmYWxzZSk7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAoKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/loglevel/lib/loglevel.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/Common/CSS/GPelevationPath.css":
/*!********************************************!*\
  !*** ./src/Common/CSS/GPelevationPath.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL0NTUy9HUGVsZXZhdGlvblBhdGguY3NzPzUwMWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL0NTUy9HUGVsZXZhdGlvblBhdGguY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Common/CSS/GPelevationPath.css\n");

/***/ }),

/***/ "./src/Common/CSS/GPgeneralWidget.css":
/*!********************************************!*\
  !*** ./src/Common/CSS/GPgeneralWidget.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL0NTUy9HUGdlbmVyYWxXaWRnZXQuY3NzP2YyZGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL0NTUy9HUGdlbmVyYWxXaWRnZXQuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Common/CSS/GPgeneralWidget.css\n");

/***/ }),

/***/ "./src/Common/Controls/ElevationPathDOM.js":
/*!*************************************************!*\
  !*** ./src/Common/Controls/ElevationPathDOM.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar ElevationPathDOM = {\n  /**\n  * Add uuid to the tag ID\n  * @param {String} id - id selector\n  * @returns {String} uid - id selector with an unique id\n  */\n  _addUID: function _addUID(id) {\n    var uid = this._uid ? id + \"-\" + this._uid : id;\n    return uid;\n  },\n\n  /**\n   * Main container (DOM)\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createMainContainerElement: function _createMainContainerElement() {\n    var container = document.createElement(\"div\");\n    container.id = this._addUID(\"GPelevationPath\");\n    container.className = \"GPwidget\";\n    return container;\n  },\n  // ################################################################### //\n  // ################# Methods to display Main Panel ################### //\n  // ################################################################### //\n\n  /**\n   * Hidden checkbox for minimizing/maximizing panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createShowElevationPathElement: function _createShowElevationPathElement() {\n    var input = document.createElement(\"input\");\n    input.id = this._addUID(\"GPshowElevationPath\");\n    input.type = \"checkbox\";\n    return input;\n  },\n\n  /**\n   * Show control\n   * see event !\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createShowElevationPathPictoElement: function _createShowElevationPathPictoElement() {\n    // contexte d'execution\n    var context = this;\n    var label = document.createElement(\"label\");\n    label.id = this._addUID(\"GPshowElevationPathPicto\");\n    label.className = \"GPshowAdvancedToolPicto\";\n    label.htmlFor = this._addUID(\"GPshowElevationPath\");\n    label.title = \"Calculer un profil\"; // gestionnaire d'evenement :\n    // on ouvre le menu de saisie de saisie\n    // L'ouverture/Fermeture permet de faire le menage\n    // (reinitialisation)\n\n    if (label.addEventListener) {\n      label.addEventListener(\"click\", function (e) {\n        context.onShowElevationPathClick(e);\n      });\n    } else if (label.attachEvent) {\n      label.attachEvent(\"onclick\", function (e) {\n        context.onShowElevationPathClick(e);\n      });\n    }\n\n    var spanOpen = document.createElement(\"span\");\n    spanOpen.id = this._addUID(\"GPshowElevationPathOpen\");\n    spanOpen.className = \"GPshowAdvancedToolOpen\";\n    label.appendChild(spanOpen);\n    return label;\n  },\n  // ################################################################### //\n  // ######################### Methods to Panel ######################## //\n  // ################################################################### //\n\n  /**\n   * Create Container Panel\n   *\n   * FIXME\n   * don't call this._createElevationPathPanelHeaderElement\n   * don't call this._createElevationPathPanelProfilElement\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createElevationPathPanelElement: function _createElevationPathPanelElement() {\n    var div = document.createElement(\"div\");\n    div.id = this._addUID(\"GPelevationPathPanel\");\n    div.className = \"GPpanel\"; // div.appendChild(this._createElevationPathPanelHeaderElement());\n    // div.appendChild(this._createElevationPathPanelProfilElement());\n\n    return div;\n  },\n\n  /**\n   * Create Header Panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createElevationPathPanelHeaderElement: function _createElevationPathPanelHeaderElement() {\n    var self = this;\n    var container = document.createElement(\"div\");\n    container.className = \"GPpanelHeader\";\n    var divInfo = document.createElement(\"div\");\n    divInfo.id = this._addUID(\"GPelevationPathPanelInfo\");\n    divInfo.className = \"GPpanelInfo\";\n    divInfo.title = \"Informations\"; // add event on click\n\n    if (divInfo.addEventListener) {\n      divInfo.addEventListener(\"click\", function () {\n        self.onOpenElevationPathInfoClick();\n      });\n    } else if (divInfo.attachEvent) {\n      // internet explorer\n      divInfo.attachEvent(\"onclick\", function () {\n        self.onOpenElevationPathInfoClick();\n      });\n    }\n\n    container.appendChild(divInfo);\n    var divTitle = document.createElement(\"div\");\n    divTitle.className = \"GPpanelTitle\";\n    divTitle.innerHTML = \"Profil Altimétrique\";\n    container.appendChild(divTitle);\n    var divReduce = document.createElement(\"div\");\n    divReduce.id = this._addUID(\"GPelevationPathPanelReduce\");\n    divReduce.className = \"GPpanelReduce\";\n    divReduce.title = \"Masquer le panneau\";\n\n    if (divReduce.addEventListener) {\n      divReduce.addEventListener(\"click\", function () {\n        if (typeof self.onReduceElevationPathPanelClick === \"function\") {\n          document.getElementById(self._addUID(\"GPshowElevationPath\")).checked = false;\n          self.onReduceElevationPathPanelClick();\n        }\n      }, false);\n    } else if (divReduce.attachEvent) {\n      divReduce.attachEvent(\"onclick\", function () {\n        if (typeof self.onReduceElevationPathPanelClick === \"function\") {\n          document.getElementById(self._addUID(\"GPshowElevationPath\")).checked = false;\n          self.onReduceElevationPathPanelClick();\n        }\n      });\n    }\n\n    container.appendChild(divReduce);\n    var divClose = document.createElement(\"div\");\n    divClose.id = this._addUID(\"GPelevationPathPanelClose\");\n    divClose.className = \"GPpanelClose\";\n    divClose.title = \"Fermer le panneau\"; // Link panel close / visibility checkbox\n\n    if (divClose.addEventListener) {\n      divClose.addEventListener(\"click\", function () {\n        document.getElementById(self._addUID(\"GPshowElevationPathPicto\")).click();\n      }, false);\n    } else if (divClose.attachEvent) {\n      divClose.attachEvent(\"onclick\", function () {\n        document.getElementById(self._addUID(\"GPshowElevationPathPicto\")).click();\n      });\n    }\n\n    container.appendChild(divClose);\n    return container;\n  },\n\n  /**\n   * Create Form\n   * see evenement !\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createElevationPathPanelProfilElement: function _createElevationPathPanelProfilElement() {\n    var div = document.createElement(\"div\");\n    div.id = \"GPelevationPathProfil\";\n    return div;\n  },\n\n  /**\n   * Create Waiting Panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createElevationPathWaitingElement: function _createElevationPathWaitingElement() {\n    var div = document.createElement(\"div\");\n    div.id = this._addUID(\"GPelevationPathCalcWaitingContainer\");\n    div.className = \"GPelevationPathCalcWaitingContainerHidden\";\n    var p = document.createElement(\"p\");\n    p.className = \"GPelevationPathCalcWaiting\";\n    p.innerHTML = \"Calcul en cours...\";\n    div.appendChild(p);\n    return div;\n  },\n\n  /**\n   * Create information Panel\n   *\n   * @returns {DOMElement} DOM element\n   */\n  _createElevationPathInformationsElement: function _createElevationPathInformationsElement() {\n    var div = document.createElement(\"div\");\n    div.id = this._addUID(\"GPelevationPathInformationsContainer\");\n    div.className = \"GPelevationPathInformationsContainerHidden\";\n    var p = document.createElement(\"p\");\n    p.className = \"GPelevationPathInformations\";\n    p.innerHTML = \"Aucune information...\";\n    div.appendChild(p);\n    return div;\n  },\n\n  /**\n   * Add a information into Panel\n   *\n   * @param {String} value - value of item\n   * @returns {DOMElement} DOM element\n   */\n  _addElevationPathInformationsItem: function _addElevationPathInformationsItem(value) {\n    var div = document.getElementById(this._addUID(\"GPelevationPathInformationsContainer\"));\n\n    if (div) {\n      var p = document.createElement(\"p\");\n      p.className = \"GPelevationPathInformations\";\n      p.innerHTML = value;\n      div.appendChild(p);\n    }\n\n    return div;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ElevationPathDOM);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL0VsZXZhdGlvblBhdGhET00uanM/N2Y3OCJdLCJuYW1lcyI6WyJFbGV2YXRpb25QYXRoRE9NIiwiX2FkZFVJRCIsImlkIiwidWlkIiwiX3VpZCIsIl9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsIl9jcmVhdGVTaG93RWxldmF0aW9uUGF0aEVsZW1lbnQiLCJpbnB1dCIsInR5cGUiLCJfY3JlYXRlU2hvd0VsZXZhdGlvblBhdGhQaWN0b0VsZW1lbnQiLCJjb250ZXh0IiwibGFiZWwiLCJodG1sRm9yIiwidGl0bGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIm9uU2hvd0VsZXZhdGlvblBhdGhDbGljayIsImF0dGFjaEV2ZW50Iiwic3Bhbk9wZW4iLCJhcHBlbmRDaGlsZCIsIl9jcmVhdGVFbGV2YXRpb25QYXRoUGFuZWxFbGVtZW50IiwiZGl2IiwiX2NyZWF0ZUVsZXZhdGlvblBhdGhQYW5lbEhlYWRlckVsZW1lbnQiLCJzZWxmIiwiZGl2SW5mbyIsIm9uT3BlbkVsZXZhdGlvblBhdGhJbmZvQ2xpY2siLCJkaXZUaXRsZSIsImlubmVySFRNTCIsImRpdlJlZHVjZSIsIm9uUmVkdWNlRWxldmF0aW9uUGF0aFBhbmVsQ2xpY2siLCJnZXRFbGVtZW50QnlJZCIsImNoZWNrZWQiLCJkaXZDbG9zZSIsImNsaWNrIiwiX2NyZWF0ZUVsZXZhdGlvblBhdGhQYW5lbFByb2ZpbEVsZW1lbnQiLCJfY3JlYXRlRWxldmF0aW9uUGF0aFdhaXRpbmdFbGVtZW50IiwicCIsIl9jcmVhdGVFbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zRWxlbWVudCIsIl9hZGRFbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zSXRlbSIsInZhbHVlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBLElBQUlBLGdCQUFnQixHQUFHO0FBRW5C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Q29udGVudCI6WyJ2YXIgRWxldmF0aW9uUGF0aERPTSA9IHtcblxuICAgIC8qKlxuICAgICogQWRkIHV1aWQgdG8gdGhlIHRhZyBJRFxuICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gaWQgc2VsZWN0b3JcbiAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVpZCAtIGlkIHNlbGVjdG9yIHdpdGggYW4gdW5pcXVlIGlkXG4gICAgKi9cbiAgICBfYWRkVUlEIDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciB1aWQgPSAodGhpcy5fdWlkKSA/IGlkICsgXCItXCIgKyB0aGlzLl91aWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIHVpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFpbiBjb250YWluZXIgKERPTSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5pZCA9IHRoaXMuX2FkZFVJRChcIkdQZWxldmF0aW9uUGF0aFwiKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1B3aWRnZXRcIjtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIE1ldGhvZHMgdG8gZGlzcGxheSBNYWluIFBhbmVsICMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiBIaWRkZW4gY2hlY2tib3ggZm9yIG1pbmltaXppbmcvbWF4aW1pemluZyBwYW5lbFxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZVNob3dFbGV2YXRpb25QYXRoRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBpbnB1dC5pZCA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd0VsZXZhdGlvblBhdGhcIik7XG4gICAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBjb250cm9sXG4gICAgICogc2VlIGV2ZW50ICFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVTaG93RWxldmF0aW9uUGF0aFBpY3RvRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29udGV4dGUgZCdleGVjdXRpb25cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgbGFiZWwuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dFbGV2YXRpb25QYXRoUGljdG9cIik7XG4gICAgICAgIGxhYmVsLmNsYXNzTmFtZSA9IFwiR1BzaG93QWR2YW5jZWRUb29sUGljdG9cIjtcbiAgICAgICAgbGFiZWwuaHRtbEZvciA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd0VsZXZhdGlvblBhdGhcIik7XG4gICAgICAgIGxhYmVsLnRpdGxlID0gXCJDYWxjdWxlciB1biBwcm9maWxcIjtcblxuICAgICAgICAvLyBnZXN0aW9ubmFpcmUgZCdldmVuZW1lbnQgOlxuICAgICAgICAvLyBvbiBvdXZyZSBsZSBtZW51IGRlIHNhaXNpZSBkZSBzYWlzaWVcbiAgICAgICAgLy8gTCdvdXZlcnR1cmUvRmVybWV0dXJlIHBlcm1ldCBkZSBmYWlyZSBsZSBtZW5hZ2VcbiAgICAgICAgLy8gKHJlaW5pdGlhbGlzYXRpb24pXG4gICAgICAgIGlmIChsYWJlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uU2hvd0VsZXZhdGlvblBhdGhDbGljayhlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhYmVsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBsYWJlbC5hdHRhY2hFdmVudChcIm9uY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uU2hvd0VsZXZhdGlvblBhdGhDbGljayhlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYW5PcGVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW5PcGVuLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93RWxldmF0aW9uUGF0aE9wZW5cIik7XG4gICAgICAgIHNwYW5PcGVuLmNsYXNzTmFtZSA9IFwiR1BzaG93QWR2YW5jZWRUb29sT3BlblwiO1xuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChzcGFuT3Blbik7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBNZXRob2RzIHRvIFBhbmVsICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBDb250YWluZXIgUGFuZWxcbiAgICAgKlxuICAgICAqIEZJWE1FXG4gICAgICogZG9uJ3QgY2FsbCB0aGlzLl9jcmVhdGVFbGV2YXRpb25QYXRoUGFuZWxIZWFkZXJFbGVtZW50XG4gICAgICogZG9uJ3QgY2FsbCB0aGlzLl9jcmVhdGVFbGV2YXRpb25QYXRoUGFuZWxQcm9maWxFbGVtZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlRWxldmF0aW9uUGF0aFBhbmVsRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IHRoaXMuX2FkZFVJRChcIkdQZWxldmF0aW9uUGF0aFBhbmVsXCIpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJHUHBhbmVsXCI7XG5cbiAgICAgICAgLy8gZGl2LmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUVsZXZhdGlvblBhdGhQYW5lbEhlYWRlckVsZW1lbnQoKSk7XG4gICAgICAgIC8vIGRpdi5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVFbGV2YXRpb25QYXRoUGFuZWxQcm9maWxFbGVtZW50KCkpO1xuXG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBIZWFkZXIgUGFuZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVFbGV2YXRpb25QYXRoUGFuZWxIZWFkZXJFbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcIkdQcGFuZWxIZWFkZXJcIjtcblxuICAgICAgICB2YXIgZGl2SW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdkluZm8uaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGVsZXZhdGlvblBhdGhQYW5lbEluZm9cIik7XG4gICAgICAgIGRpdkluZm8uY2xhc3NOYW1lID0gXCJHUHBhbmVsSW5mb1wiO1xuICAgICAgICBkaXZJbmZvLnRpdGxlID0gXCJJbmZvcm1hdGlvbnNcIjtcbiAgICAgICAgLy8gYWRkIGV2ZW50IG9uIGNsaWNrXG4gICAgICAgIGlmIChkaXZJbmZvLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRpdkluZm8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uT3BlbkVsZXZhdGlvblBhdGhJbmZvQ2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGRpdkluZm8uYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGludGVybmV0IGV4cGxvcmVyXG4gICAgICAgICAgICBkaXZJbmZvLmF0dGFjaEV2ZW50KFxuICAgICAgICAgICAgICAgIFwib25jbGlja1wiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbk9wZW5FbGV2YXRpb25QYXRoSW5mb0NsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2SW5mbyk7XG5cbiAgICAgICAgdmFyIGRpdlRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2VGl0bGUuY2xhc3NOYW1lID0gXCJHUHBhbmVsVGl0bGVcIjtcbiAgICAgICAgZGl2VGl0bGUuaW5uZXJIVE1MID0gXCJQcm9maWwgQWx0aW3DqXRyaXF1ZVwiO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2VGl0bGUpO1xuXG4gICAgICAgIHZhciBkaXZSZWR1Y2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXZSZWR1Y2UuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGVsZXZhdGlvblBhdGhQYW5lbFJlZHVjZVwiKTtcbiAgICAgICAgZGl2UmVkdWNlLmNsYXNzTmFtZSA9IFwiR1BwYW5lbFJlZHVjZVwiO1xuICAgICAgICBkaXZSZWR1Y2UudGl0bGUgPSBcIk1hc3F1ZXIgbGUgcGFubmVhdVwiO1xuXG4gICAgICAgIGlmIChkaXZSZWR1Y2UuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZGl2UmVkdWNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm9uUmVkdWNlRWxldmF0aW9uUGF0aFBhbmVsQ2xpY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUHNob3dFbGV2YXRpb25QYXRoXCIpKS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25SZWR1Y2VFbGV2YXRpb25QYXRoUGFuZWxDbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXZSZWR1Y2UuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGRpdlJlZHVjZS5hdHRhY2hFdmVudChcIm9uY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vblJlZHVjZUVsZXZhdGlvblBhdGhQYW5lbENsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1BzaG93RWxldmF0aW9uUGF0aFwiKSkuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uUmVkdWNlRWxldmF0aW9uUGF0aFBhbmVsQ2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2UmVkdWNlKTtcblxuICAgICAgICB2YXIgZGl2Q2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXZDbG9zZS5pZCA9IHRoaXMuX2FkZFVJRChcIkdQZWxldmF0aW9uUGF0aFBhbmVsQ2xvc2VcIik7XG4gICAgICAgIGRpdkNsb3NlLmNsYXNzTmFtZSA9IFwiR1BwYW5lbENsb3NlXCI7XG4gICAgICAgIGRpdkNsb3NlLnRpdGxlID0gXCJGZXJtZXIgbGUgcGFubmVhdVwiO1xuXG4gICAgICAgIC8vIExpbmsgcGFuZWwgY2xvc2UgLyB2aXNpYmlsaXR5IGNoZWNrYm94XG4gICAgICAgIGlmIChkaXZDbG9zZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBkaXZDbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuX2FkZFVJRChcIkdQc2hvd0VsZXZhdGlvblBhdGhQaWN0b1wiKSkuY2xpY2soKTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXZDbG9zZS5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgZGl2Q2xvc2UuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUHNob3dFbGV2YXRpb25QYXRoUGljdG9cIikpLmNsaWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2Q2xvc2UpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBGb3JtXG4gICAgICogc2VlIGV2ZW5lbWVudCAhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlRWxldmF0aW9uUGF0aFBhbmVsUHJvZmlsRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IFwiR1BlbGV2YXRpb25QYXRoUHJvZmlsXCI7XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFdhaXRpbmcgUGFuZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVFbGV2YXRpb25QYXRoV2FpdGluZ0VsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGVsZXZhdGlvblBhdGhDYWxjV2FpdGluZ0NvbnRhaW5lclwiKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiR1BlbGV2YXRpb25QYXRoQ2FsY1dhaXRpbmdDb250YWluZXJIaWRkZW5cIjtcblxuICAgICAgICB2YXIgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgICAgICBwLmNsYXNzTmFtZSA9IFwiR1BlbGV2YXRpb25QYXRoQ2FsY1dhaXRpbmdcIjtcbiAgICAgICAgcC5pbm5lckhUTUwgPSBcIkNhbGN1bCBlbiBjb3Vycy4uLlwiO1xuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChwKTtcblxuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgaW5mb3JtYXRpb24gUGFuZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVFbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IHRoaXMuX2FkZFVJRChcIkdQZWxldmF0aW9uUGF0aEluZm9ybWF0aW9uc0NvbnRhaW5lclwiKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiR1BlbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zQ29udGFpbmVySGlkZGVuXCI7XG5cbiAgICAgICAgdmFyIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgcC5jbGFzc05hbWUgPSBcIkdQZWxldmF0aW9uUGF0aEluZm9ybWF0aW9uc1wiO1xuICAgICAgICBwLmlubmVySFRNTCA9IFwiQXVjdW5lIGluZm9ybWF0aW9uLi4uXCI7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChwKTtcblxuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBpbmZvcm1hdGlvbiBpbnRvIFBhbmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB2YWx1ZSBvZiBpdGVtXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2FkZEVsZXZhdGlvblBhdGhJbmZvcm1hdGlvbnNJdGVtIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUGVsZXZhdGlvblBhdGhJbmZvcm1hdGlvbnNDb250YWluZXJcIikpO1xuXG4gICAgICAgIGlmIChkaXYpIHtcbiAgICAgICAgICAgIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgICAgICBwLmNsYXNzTmFtZSA9IFwiR1BlbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zXCI7XG4gICAgICAgICAgICBwLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFbGV2YXRpb25QYXRoRE9NO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Common/Controls/ElevationPathDOM.js\n");

/***/ }),

/***/ "./src/Common/Controls/ProfileElevationPathDOM.js":
/*!********************************************************!*\
  !*** ./src/Common/Controls/ProfileElevationPathDOM.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* globals AmCharts, d3 */\n\n/**\n * @module ProfileElevationPathDOM\n * @alias [private] ProfileElevationPathDOM\n * @description\n * create DOM element\n */\nvar ProfileElevationPathDOM = {\n  /**\n   * Gets a css property from an element\n   *\n   * @private\n   * @param {HTMLElement} element The element to get the property from\n   * @param {String} property The css property\n   * @returns {String} The value of the property\n   *\n   * @see https://stackoverflow.com/questions/7444451/how-to-get-the-actual-rendered-font-when-its-not-defined-in-css\n   */\n  _getCssProperty: function _getCssProperty(element, property) {\n    return window.getComputedStyle(element, null).getPropertyValue(property);\n  },\n\n  /**\n   * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n   *\n   * @private\n   * @param {String} text The text to be rendered.\n   * @param {HTMLElement} container The container of the text\n   * @param {String} font The font of the container if known, format: 'weight size familiy'\n   * @returns {Number} The width of the text\n   *\n   * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n   */\n  _getTextWidth: function _getTextWidth(text, container) {\n    var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // re-use canvas object for better performance\n    var canvas =\n    /** ts-syntax */\n    this.canvas || (this.canvas = document.createElement(\"canvas\"));\n    var context = canvas.getContext(\"2d\");\n\n    if (font === null) {\n      context.font = \"\".concat(this._getCssProperty(container, \"font-weight\"), \" \").concat(this._getCssProperty(container, \"font-size\"), \" \").concat(this._getCssProperty(container, \"font-family\"));\n    } else {\n      context.font = font;\n    }\n\n    var metrics = context.measureText(text);\n    return metrics.width;\n  },\n\n  /**\n   * Converts a data point z to svg y coord\n   *\n   * @private\n   * @param {Object} z The z to convert.\n   * @param {Number} pathHeight The height of the path in the svg container in px\n   * @param {Number} minGraphZ Min z of the graph\n   * @param {Number} pxPerMZ Number of pixels per meter for the z (y) axis\n   * @returns {Number} The y svg coordinate of the point\n   *\n   */\n  _dataZToSvgY: function _dataZToSvgY(z, pathHeight, minGraphZ, pxPerMZ) {\n    return pathHeight - (z - minGraphZ) * pxPerMZ - 0.5;\n  },\n\n  /**\n   * Converts a data point dist value to svg x coord\n   *\n   * @private\n   * @param {Number} dist The dist to convert\n   * @param {Number} svgWidth The witdth of the svg container in px\n   * @param {Number} pathWidth The witdth of the path in the svg container in px\n   * @param {Number} pxPerMX Number of pixels per meter for the x axis\n   * @returns {Array} The x svg coordinate of the point\n   *\n   */\n  _dataDistToSvgX: function _dataDistToSvgX(dist, svgWidth, pathWidth, pxPerMX) {\n    return svgWidth - pathWidth + dist * pxPerMX;\n  },\n\n  /**\n   * Converts a svg x coord to dist value\n   *\n   * @private\n   * @param {Number} svgX The dist to convert\n   * @param {Number} svgWidth The witdth of the svg container in px\n   * @param {Number} pathWidth The witdth of the path in the svg container in px\n   * @param {Number} pxPerMX Number of pixels per meter for the x axis\n   * @returns {Array} The dist value\n   *\n   */\n  _svgXToDataDist: function _svgXToDataDist(svgX, svgWidth, pathWidth, pxPerMX) {\n    return (svgX + pathWidth - svgWidth) / pxPerMX;\n  },\n\n  /**\n   * Returns the index of value if it were inserted in sorted (by dist) array of data points.\n   *\n   * @private\n   * @param {Array} array Sorted array of data points (with dist property)\n   * @param {Number} value Value to test the index of.\n   * @returns {Number} The index the value would have.\n   *\n   */\n  _arrayBisect: function _arrayBisect(array, value) {\n    var idx;\n\n    if (array.length === 0) {\n      return 0;\n    }\n\n    for (idx = 0; idx < array.length; idx++) {\n      if (value < array[idx].dist) {\n        return idx;\n      }\n    }\n\n    return idx - 1;\n  },\n\n  /**\n   * Display Profile function used by default : no additonal framework needed.\n   *\n   * @public\n   * @param {Object} data - elevations values for profile\n   * @param {HTMLElement} container - html container where to display profile\n   * @param {Object} context - this control object\n   * @param {Object} className - calling class (ie ElevationPath)\n   * @returns {DOMElement} profil container\n   */\n  displayProfileByDefault: function displayProfileByDefault(data, container, context, className) {\n    var self = context;\n\n    if (!container) {\n      return;\n    }\n\n    if (!data) {\n      return;\n    } // on nettoie toujours...\n\n\n    while (container.firstChild) {\n      container.removeChild(container.firstChild);\n    }\n\n    var margin = {\n      top: 25,\n      right: 15,\n      bottom: 10,\n      left: 10\n    };\n    var _displayProfileOptions = self.options.displayProfileOptions;\n    var _points = data.points;\n    var sortedElev = JSON.parse(JSON.stringify(_points));\n    sortedElev.sort(function (e1, e2) {\n      return e1.z - e2.z;\n    });\n    var minZ = sortedElev[0].z;\n    var maxZ = sortedElev[sortedElev.length - 1].z;\n    var dist = data.distance;\n    var distUnit = \"m\";\n    var widgetDiv = document.createElement(\"div\");\n    widgetDiv.id = \"profileElevationByDefault\";\n    container.appendChild(widgetDiv); // Détermination des tailles en pixels des éléments du widget\n\n    var widgetHeigth = container.clientHeight - margin.top - margin.bottom;\n    var widgetWidth = container.clientWidth - margin.left - margin.right;\n    var zLabelWidth = 17;\n\n    var zGradWidth = this._getTextWidth(Math.round(maxZ).toLocaleString() + \",88\", container, \"400 10 Verdana\");\n\n    var xLabelHeight = 17;\n    var xGradHeight = 15;\n    var minZguideHeigth = 15;\n\n    var minXguideWidth = this._getTextWidth(Math.round(dist).toLocaleString() + \",5\", container);\n\n    var minNumXGuides = 1;\n    var pathHeight = widgetHeigth - xLabelHeight - xGradHeight;\n    var pathWidth = widgetWidth - zLabelWidth - zGradWidth;\n    var elevationSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    elevationSvg.id = \"profileElevationByDefaultSvg\";\n    elevationSvg.setAttribute(\"style\", \"display: block; margin: auto; overflow: visible; position: absolute; left: 10px;\");\n    elevationSvg.setAttribute(\"viewBox\", \"0 0 \".concat(container.clientWidth, \" \").concat(container.clientHeight));\n    elevationSvg.setAttribute(\"width\", \"100%\");\n    elevationSvg.setAttribute(\"height\", \"100%\"); // Détermination des guides en ordonnée :\n\n    var maxNumZguides = Math.floor(pathHeight / minZguideHeigth);\n    var gradZ; // Traitement du cas altitude max = altitude min\n\n    if (maxZ === minZ) {\n      gradZ = 0.1;\n    } else {\n      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10))) / 2;\n    }\n\n    var minGraphZ = Math.floor(minZ / gradZ) * gradZ;\n    var maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ; // cas où le path atteint pile les graduations extremes : ajout d'une gradiation\n\n    if (maxGraphZ === maxZ) {\n      maxGraphZ += gradZ;\n    } // cas où gradZ < 1 : nombres flottants capricieux...\n\n\n    minGraphZ = Math.round(minGraphZ * 100) / 100;\n    maxGraphZ = Math.round(maxGraphZ * 100) / 100;\n    var numZguides = Math.round((maxGraphZ - minGraphZ) / gradZ); // Si plus de guides que le max, on passe à une graduation de 10**x en 10**x (et non 10**x / 2)\n\n    if (numZguides + 1 > maxNumZguides) {\n      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10)));\n      minGraphZ = Math.floor(minZ / gradZ) * gradZ;\n      maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ; // cas où le path atteint pile les graduations extremes : ajout d'une gradiation\n\n      if (maxGraphZ === maxZ) {\n        maxGraphZ += gradZ;\n      } // cas où gradZ < 1 : nombres flottants capricieux...\n\n\n      minGraphZ = Math.round(minGraphZ * 100) / 100;\n      maxGraphZ = Math.round(maxGraphZ * 100) / 100;\n      numZguides = Math.floor((maxGraphZ - minGraphZ) / gradZ);\n    }\n\n    numZguides = Math.max(Math.round(numZguides), 1);\n    var axisZ = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    axisZ.setAttribute(\"class\", \"profile-z-vertical\");\n    var guidesZ = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    var gradZyOffsetPx = pathHeight / numZguides;\n    var pxPerMZ = pathHeight / (maxGraphZ - minGraphZ); // Traitement du cas altitude max = altitude min\n\n    if (maxZ === minZ) {\n      pxPerMZ = pathHeight / 0.2;\n    } else {\n      pxPerMZ = pathHeight / (maxGraphZ - minGraphZ);\n    }\n\n    var gradZtext;\n    var yTextTranslation;\n    var yStrokeTranslation;\n    var gradZstroke;\n    var gradZpath;\n    var gradZgrad; // Ajout des graduations au graphique\n\n    for (var i = 0; i <= numZguides; i++) {\n      gradZtext = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      gradZtext.setAttribute(\"class\", \"profile-z-graduation\");\n      gradZtext.setAttribute(\"font-family\", \"Verdana\");\n      gradZtext.setAttribute(\"font-size\", \"10px\");\n      gradZtext.setAttribute(\"fill\", \"#5E5E5E\"); // Cas où gradZ < 1 : nombres flottants capricieux...\n      // Le Math.round est pour éviter des ennuis du genre 3 * 0.1 = 0.300000000000004\n\n      gradZtext.textContent = (Math.round(100 * (minGraphZ + i * gradZ)) / 100).toLocaleString();\n      yTextTranslation = pathHeight - i * gradZyOffsetPx;\n      gradZtext.setAttribute(\"transform\", \"translate(\".concat(zLabelWidth + zGradWidth - 8, \", \").concat(yTextTranslation + 5, \")\"));\n      gradZtext.setAttribute(\"text-anchor\", \"end\");\n      axisZ.appendChild(gradZtext);\n      yStrokeTranslation = Math.round(yTextTranslation) - 0.5;\n      gradZstroke = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      gradZpath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      gradZpath.setAttribute(\"cs\", \"100,100\");\n      gradZpath.setAttribute(\"stroke-width\", \"1\");\n\n      if (i !== 0) {\n        gradZpath.setAttribute(\"stroke-opacity\", \"0.2\");\n      } else {\n        gradZpath.setAttribute(\"stroke-opacity\", \"1\");\n      }\n\n      gradZpath.setAttribute(\"stroke\", \"#000000\");\n      gradZpath.setAttribute(\"fill\", \"none\");\n      gradZpath.setAttribute(\"d\", \"M\".concat(zLabelWidth + zGradWidth, \",\").concat(yStrokeTranslation, \" L\").concat(pathWidth + zLabelWidth + zGradWidth, \",\").concat(yStrokeTranslation));\n      gradZgrad = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      gradZgrad.setAttribute(\"cs\", \"100,100\");\n      gradZgrad.setAttribute(\"stroke-width\", \"1\");\n      gradZgrad.setAttribute(\"stroke-opacity\", \"1\");\n      gradZgrad.setAttribute(\"stroke\", \"#000000\");\n      gradZgrad.setAttribute(\"fill\", \"none\");\n      gradZgrad.setAttribute(\"d\", \"M\".concat(zLabelWidth + zGradWidth, \",\").concat(yStrokeTranslation, \" L\").concat(zLabelWidth + zGradWidth + 5, \",\").concat(yStrokeTranslation));\n      gradZgrad.setAttribute(\"transform\", \"translate(-5, 0)\");\n      gradZstroke.appendChild(gradZgrad);\n      gradZstroke.appendChild(gradZpath);\n      guidesZ.appendChild(gradZstroke);\n    }\n\n    var axisZLegend = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    axisZLegend.setAttribute(\"class\", \"profile-z-legend\");\n    axisZLegend.setAttribute(\"font-family\", \"Verdana\");\n    axisZLegend.setAttribute(\"font-size\", \"11px\");\n    axisZLegend.setAttribute(\"fill\", \"#5E5E5E\");\n    axisZLegend.textContent = \"Altitude (m)\";\n    axisZLegend.setAttribute(\"transform\", \"translate(\".concat(zLabelWidth - 8, \", \").concat(Math.round(pathHeight / 2), \") rotate(-90)\"));\n    axisZLegend.setAttribute(\"text-anchor\", \"middle\");\n    axisZ.appendChild(axisZLegend);\n    elevationSvg.appendChild(axisZ);\n    elevationSvg.appendChild(guidesZ); // Détermination des guides en abscisse :\n    // Passage éventuel en km\n\n    if (dist > 2000) {\n      dist /= 1000;\n      distUnit = \"km\";\n    }\n\n    var maxNumXguides = Math.floor(pathWidth / minXguideWidth);\n    var gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10))) / 2;\n    var maxGraphX = dist; // Si plus de guides que le max, on passe à une graduation de 10**x en 10**x (et non 10**x / 2)\n\n    var numXguides = Math.floor(maxGraphX / gradX);\n\n    if (numXguides > maxNumXguides) {\n      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)));\n      numXguides = Math.floor(maxGraphX / gradX);\n    } else if (numXguides < minNumXGuides) {\n      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)) - 1);\n      numXguides = Math.floor(maxGraphX / gradX);\n    }\n\n    numXguides = Math.max(numXguides, 1);\n    var lastGradX = gradX * numXguides;\n    var axisX = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    axisX.setAttribute(\"class\", \"profile-x-vertical\");\n    var guidesX = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"); // Décalage des graduations pour que la dernière corresponde à la distance max\n\n    var pxPerMX = pathWidth / maxGraphX;\n    var xOffset = (maxGraphX - lastGradX) * pxPerMX;\n    var gradXxOffsetPx = Math.round((pathWidth - xOffset) / numXguides);\n    var gradXtext;\n    var xTextTranslation;\n    var xStrokeTranslation;\n    var gradXstroke;\n    var gradXpath;\n    var gradXgrad; // Ajout des graduations au graphique\n\n    for (var _i = 0; _i <= numXguides + 1; _i++) {\n      gradXtext = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      gradXtext.setAttribute(\"class\", \"profile-x-graduation\");\n      gradXtext.setAttribute(\"font-family\", \"Verdana\");\n      gradXtext.setAttribute(\"font-size\", \"10px\");\n      gradXtext.setAttribute(\"fill\", \"#5E5E5E\"); // Exclusion du cas de la dernière graduation : correspond à la distance max : pas de texte\n\n      if (_i !== numXguides + 1) {\n        // Cas où gradX < 1 : nombres flottants capricieux...\n        gradXtext.textContent = (Math.round(100 * _i * gradX) / 100).toLocaleString();\n      }\n\n      xTextTranslation = zLabelWidth + zGradWidth + _i * gradXxOffsetPx; // Cas de la dernière graduation : correspond à la distance max\n\n      if (_i === numXguides + 1) {\n        xTextTranslation = zLabelWidth + zGradWidth + pathWidth;\n      }\n\n      gradXtext.setAttribute(\"transform\", \"translate(\".concat(xTextTranslation, \", \").concat(pathHeight + xGradHeight + 5, \")\"));\n      gradXtext.setAttribute(\"text-anchor\", \"middle\");\n      axisX.appendChild(gradXtext);\n      xStrokeTranslation = xTextTranslation - 0.5;\n      gradXstroke = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      gradXpath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      gradXpath.setAttribute(\"cs\", \"100,100\");\n      gradXpath.setAttribute(\"stroke-width\", \"1\");\n\n      if (_i !== 0) {\n        gradXpath.setAttribute(\"stroke-opacity\", \"0.2\");\n      } else {\n        gradXpath.setAttribute(\"stroke-opacity\", \"1\");\n      }\n\n      gradXpath.setAttribute(\"stroke\", \"#000000\");\n      gradXpath.setAttribute(\"fill\", \"none\");\n      gradXpath.setAttribute(\"d\", \"M\".concat(xStrokeTranslation, \",\").concat(pathHeight, \" L\").concat(xStrokeTranslation, \",0\"));\n      gradXgrad = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      gradXgrad.setAttribute(\"cs\", \"100,100\");\n      gradXgrad.setAttribute(\"stroke-width\", \"1\");\n      gradXgrad.setAttribute(\"stroke-opacity\", \"1\");\n      gradXgrad.setAttribute(\"stroke\", \"#000000\");\n      gradXgrad.setAttribute(\"fill\", \"none\");\n      gradXgrad.setAttribute(\"d\", \"M\".concat(xStrokeTranslation, \",\").concat(pathHeight, \" L\").concat(xStrokeTranslation, \",\").concat(pathHeight - 5));\n      gradXgrad.setAttribute(\"transform\", \"translate(0, 5)\");\n      gradXstroke.appendChild(gradXgrad);\n      gradXstroke.appendChild(gradXpath);\n      guidesX.appendChild(gradXstroke);\n    }\n\n    var axisXLegend = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    axisXLegend.setAttribute(\"class\", \"profile-x-legend\");\n    axisXLegend.setAttribute(\"font-family\", \"Verdana\");\n    axisXLegend.setAttribute(\"font-size\", \"11px\");\n    axisXLegend.setAttribute(\"fill\", \"#5E5E5E\");\n    axisXLegend.textContent = \"Distance (\".concat(distUnit, \")\");\n    axisXLegend.setAttribute(\"transform\", \"translate(\".concat(zLabelWidth + zGradWidth + pathWidth / 2, \", \").concat(pathHeight + xGradHeight + xLabelHeight + 3, \")\"));\n    axisXLegend.setAttribute(\"text-anchor\", \"middle\");\n    axisX.appendChild(axisXLegend);\n    elevationSvg.appendChild(axisX);\n    elevationSvg.appendChild(guidesX);\n    var elevationPathG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    var factor = 1;\n\n    if (distUnit === \"km\") {\n      factor = 1000;\n    }\n\n    var pointX = this._dataDistToSvgX(_points[0].dist / factor, widgetWidth, pathWidth, pxPerMX);\n\n    var pointY = this._dataZToSvgY(_points[0].z, pathHeight, minGraphZ, pxPerMZ);\n\n    var pathD = \"M\".concat(pointX, \",\").concat(pointY);\n\n    for (var _i2 = 1; _i2 < _points.length; _i2++) {\n      pointX = this._dataDistToSvgX(_points[_i2].dist / factor, widgetWidth, pathWidth, pxPerMX);\n      pointY = this._dataZToSvgY(_points[_i2].z, pathHeight, minGraphZ, pxPerMZ);\n      pathD += \" L\".concat(pointX, \",\").concat(pointY);\n    }\n\n    var pathPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    pathPath.setAttribute(\"cs\", \"100,100\");\n    pathPath.setAttribute(\"stroke-width\", \"1\");\n    pathPath.setAttribute(\"stroke-opacity\", \"1\");\n    pathPath.setAttribute(\"stroke\", \"#0B6BA7\");\n    pathPath.setAttribute(\"fill\", \"none\");\n    pathPath.setAttribute(\"d\", pathD); // Fermeture du path pour le fill\n\n    pathD += \" L\".concat(pointX, \",\").concat(pathHeight);\n    pathD += \" L\".concat(widgetWidth - pathWidth, \",\").concat(pathHeight);\n    var pathFill = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    pathFill.setAttribute(\"cs\", \"100,100\");\n    pathFill.setAttribute(\"stroke-width\", \"1\");\n    pathFill.setAttribute(\"stroke-opacity\", \"0\");\n    pathFill.setAttribute(\"stroke\", \"#000000\");\n    pathFill.setAttribute(\"fill\", \"#00B798\");\n    pathFill.setAttribute(\"fill-opacity\", \"0.4\");\n    pathFill.setAttribute(\"d\", pathD);\n    elevationPathG.appendChild(pathPath);\n    elevationPathG.appendChild(pathFill);\n    elevationSvg.appendChild(elevationPathG); // Mise en place de l'écouteur d'évènement : pour l'affichage dynamique\n\n    var dynamicsG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"); // Pour écouter la position de la souris\n\n    var pathRectangle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    pathRectangle.setAttribute(\"width\", pathWidth);\n    pathRectangle.setAttribute(\"height\", pathHeight);\n    pathRectangle.setAttribute(\"transform\", \"translate(\".concat(widgetWidth - pathWidth, \",0)\"));\n    pathRectangle.setAttribute(\"visibility\", \"hidden\");\n    pathRectangle.setAttribute(\"pointer-events\", \"all\");\n    var sortedDist = JSON.parse(JSON.stringify(_points));\n    sortedDist.sort(function (e1, e2) {\n      return e1.dist - e2.dist;\n    });\n    var focusLineX = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    focusLineX.setAttribute(\"id\", \"focusLineX\");\n    focusLineX.setAttribute(\"class\", \"focusLine-default\");\n    focusLineX.setAttribute(\"fill\", \"none\");\n    focusLineX.setAttribute(\"stroke\", \"#F90\");\n    focusLineX.setAttribute(\"stroke-width\", \"0.5px\");\n    focusLineX.setAttribute(\"visibility\", \"hidden\");\n    var focusLineY = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    focusLineY.setAttribute(\"id\", \"focusLineY\");\n    focusLineY.setAttribute(\"class\", \"focusLine-default\");\n    focusLineY.setAttribute(\"fill\", \"none\");\n    focusLineY.setAttribute(\"stroke\", \"#F90\");\n    focusLineY.setAttribute(\"stroke-width\", \"0.5px\");\n    focusLineY.setAttribute(\"visibility\", \"hidden\");\n    var focusCircle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    focusCircle.setAttribute(\"id\", \"focusCircle\");\n    focusCircle.setAttribute(\"r\", 4);\n    focusCircle.setAttribute(\"class\", \"circle-default focusCircle-default\");\n    focusCircle.setAttribute(\"fill\", \"#F90\");\n    focusCircle.setAttribute(\"visibility\", \"hidden\");\n    dynamicsG.appendChild(focusCircle);\n    dynamicsG.appendChild(focusLineX);\n    dynamicsG.appendChild(focusLineY); // Tooltip\n\n    var tooltipDiv = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    var altiSpan = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n    var slopeSpan = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n    var coordsSpan = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n    tooltipDiv.setAttribute(\"style\", \"text-align:center; max-width:220px; font-size:10px; color:#000000; font-family:Verdana; z-index:50;\");\n    tooltipDiv.style.pointerEvents = \"none\";\n    tooltipDiv.style.position = \"fixed\"; // tooltipDiv.classList.add(\"tooltipInit\");\n    // IE...\n\n    tooltipDiv.setAttribute(\"class\", \"tooltipInit\");\n    tooltipDiv.setAttribute(\"text-anchor\", \"middle\");\n    widgetDiv.appendChild(tooltipDiv);\n    altiSpan.setAttribute(\"class\", \"altiPathValue\");\n    altiSpan.setAttribute(\"x\", \"0\");\n    altiSpan.setAttribute(\"dy\", \"-.7em\");\n    slopeSpan.setAttribute(\"class\", \"altiPathValue\");\n    slopeSpan.setAttribute(\"x\", \"0\");\n    slopeSpan.setAttribute(\"dy\", \"1em\");\n    coordsSpan.setAttribute(\"class\", \"altiPathCoords\");\n    coordsSpan.setAttribute(\"x\", \"0\");\n    coordsSpan.setAttribute(\"dy\", \"1em\");\n    tooltipDiv.appendChild(altiSpan);\n\n    if (_displayProfileOptions.currentSlope) {\n      tooltipDiv.appendChild(slopeSpan);\n    }\n\n    tooltipDiv.appendChild(coordsSpan);\n    var tooltipG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    dynamicsG.appendChild(tooltipG);\n    var tooltipBubble = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    tooltipBubble.setAttribute(\"cs\", \"100,100\");\n    tooltipBubble.setAttribute(\"fill\", \"#FFFFFF\");\n    tooltipBubble.setAttribute(\"stroke\", \"#CCCCCC\");\n    tooltipBubble.setAttribute(\"fill-opacity\", \"0.8\");\n    tooltipBubble.setAttribute(\"stroke-width\", \"1\");\n    tooltipBubble.setAttribute(\"stroke-opacity\", \"1\");\n    var tooltipBubbleShadow = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    tooltipBubbleShadow.setAttribute(\"cs\", \"100,100\");\n    tooltipBubbleShadow.setAttribute(\"fill\", \"#FFFFFF\");\n    tooltipBubbleShadow.setAttribute(\"stroke\", \"#000000\");\n    tooltipBubbleShadow.setAttribute(\"fill-opacity\", \"0\");\n    tooltipBubbleShadow.setAttribute(\"stroke-width\", \"1\");\n    tooltipBubbleShadow.setAttribute(\"stroke-opacity\", \"0.4\");\n    tooltipBubbleShadow.setAttribute(\"transform\", \"translate(1,1)\");\n    tooltipG.appendChild(tooltipBubbleShadow);\n    tooltipG.appendChild(tooltipBubble);\n    tooltipG.appendChild(tooltipDiv); // tooltipG.classList.add(\"tooltipInit\");\n    // IE... deprecated\n\n    tooltipG.setAttribute(\"class\", \"tooltipInit\");\n    tooltipG.style.pointerEvents = \"none\";\n\n    function onMouseOver() {\n      focusLineX.setAttribute(\"visibility\", \"visible\");\n      focusLineY.setAttribute(\"visibility\", \"visible\");\n      focusCircle.setAttribute(\"visibility\", \"visible\");\n\n      className.__createProfileMarker(self, _points[0]); // tooltips\n      // tooltipDiv.classList.remove(\"tooltipInit\");\n      // tooltipG.classList.remove(\"tooltipInit\");\n      // tooltipDiv.classList.remove(\"tooltipFadeOut\");\n      // tooltipG.classList.remove(\"tooltipFadeOut\");\n      // tooltipDiv.classList.add(\"tooltipFadeIn\");\n      // tooltipG.classList.add(\"tooltipFadeIn\");\n      // IE... deprecated\n\n\n      tooltipDiv.setAttribute(\"class\", \"tooltipFadeIn\");\n      tooltipG.setAttribute(\"class\", \"tooltipFadeIn\");\n    }\n\n    function onMouseOut() {\n      focusLineX.setAttribute(\"visibility\", \"hidden\");\n      focusLineY.setAttribute(\"visibility\", \"hidden\");\n      focusCircle.setAttribute(\"visibility\", \"hidden\");\n\n      className.__removeProfileMarker(self); // tooltips\n      // tooltipDiv.classList.remove(\"tooltipFadeIn\");\n      // tooltipG.classList.remove(\"tooltipFadeIn\");\n      // tooltipDiv.classList.add(\"tooltipFadeOut\");\n      // tooltipG.classList.add(\"tooltipFadeOut\");\n      // IE... deprecated\n\n\n      tooltipDiv.setAttribute(\"class\", \"tooltipFadeOut\");\n      tooltipG.setAttribute(\"class\", \"tooltipFadeOut\");\n    }\n\n    function onMouseMove(e) {\n      var mousePoint = elevationSvg.createSVGPoint();\n      mousePoint.x = e.clientX;\n      mousePoint.y = e.clientY;\n      var svgMousePoint = mousePoint.matrixTransform(elevationSvg.getScreenCTM().inverse());\n      var mouseDist = this._svgXToDataDist(svgMousePoint.x, widgetWidth, pathWidth, pxPerMX) * factor; // Math.max pour éviter de sortir de l'array\n\n      var distIndex = Math.max(1, this._arrayBisect(sortedDist, mouseDist));\n      var d0 = _points[distIndex - 1];\n      var d1 = _points[distIndex];\n      var d = d0;\n\n      if (mouseDist - d0.dist > d1.dist - mouseDist) {\n        d = d1;\n      }\n\n      var focusX = this._dataDistToSvgX(d.dist / factor, widgetWidth, pathWidth, pxPerMX);\n\n      var focusY = this._dataZToSvgY(d.z, pathHeight, minGraphZ, pxPerMZ); // Mise à jour des éléments graphiques\n\n\n      focusCircle.setAttribute(\"cx\", focusX);\n      focusCircle.setAttribute(\"cy\", focusY);\n      focusLineX.setAttribute(\"x1\", focusX);\n      focusLineX.setAttribute(\"y1\", pathHeight);\n      focusLineX.setAttribute(\"x2\", focusX);\n      focusLineX.setAttribute(\"y2\", 0);\n      focusLineY.setAttribute(\"x1\", zLabelWidth + zGradWidth);\n      focusLineY.setAttribute(\"y1\", focusY);\n      focusLineY.setAttribute(\"x2\", pathWidth + zLabelWidth + zGradWidth);\n      focusLineY.setAttribute(\"y2\", focusY);\n\n      className.__updateProfileMarker(self, d); // Mise à jour du tooltip\n\n\n      var altiSpanTxt = \"Altitude : \".concat(d.z.toLocaleString(), \" m\");\n      var slopeSpanTxt = \"Pente : \".concat(d.slope, \" %\");\n      var coordsSpanTxt = \"(lat : \".concat(d.lat.toLocaleString(), \" / lon : \").concat(d.lon.toLocaleString(), \")\");\n      altiSpan.innerHTML = altiSpanTxt;\n      slopeSpan.innerHTML = slopeSpanTxt;\n      coordsSpan.innerHTML = coordsSpanTxt;\n      var tooltipTextWidth = Math.max(this._getTextWidth(coordsSpanTxt, coordsSpan), this._getTextWidth(altiSpanTxt, altiSpan));\n      var toolTipBubbleD;\n\n      if (d.dist > dist * factor / 2) {\n        toolTipBubbleD = \"M -0.5 -0.5 l -6 6 l 0 16 l -\".concat(tooltipTextWidth + 10, \" 0 l 0 -44 l \").concat(tooltipTextWidth + 10, \" 0 l 0 16 l 6 6\");\n        tooltipDiv.setAttribute(\"transform\", \"translate(\".concat(-(tooltipTextWidth / 2 + 12), \",0)\")); // IE11 !\n      } else if (d.dist <= dist * factor / 2) {\n        toolTipBubbleD = \"M -0.5 -0.5 l 6 6 l 0 16 l \".concat(tooltipTextWidth + 10, \" 0 l 0 -44 l -\").concat(tooltipTextWidth + 10, \" 0 l 0 16 l -6 6\"); // Largeur de la fleche de la bulle du tooltip\n\n        tooltipDiv.setAttribute(\"transform\", \"translate(\".concat(tooltipTextWidth / 2 + 12, \",0)\")); // IE11 !\n      }\n\n      tooltipBubble.setAttribute(\"d\", toolTipBubbleD);\n      tooltipBubbleShadow.setAttribute(\"d\", toolTipBubbleD);\n      tooltipG.setAttribute(\"transform\", \"translate(\".concat(focusX, \",\").concat(focusY, \")\")); // IE11 !\n\n      tooltipG.style.transform = \"translate(\".concat(focusX, \"px,\").concat(focusY, \"px)\");\n    }\n\n    pathRectangle.addEventListener(\"pointerover\", onMouseOver);\n    pathRectangle.addEventListener(\"pointerout\", onMouseOut);\n    pathRectangle.addEventListener(\"pointermove\", onMouseMove.bind(this));\n    dynamicsG.appendChild(pathRectangle);\n    elevationSvg.appendChild(dynamicsG);\n    widgetDiv.appendChild(elevationSvg);\n    return container;\n  },\n\n  /**\n   * Display Profile without graphical rendering (raw service response)\n   *\n   * @public\n   * @param {Object} data - elevations values for profile\n   * @param {HTMLElement} container - html container where to display profile\n   * @param {Object} context - this control object\n   * @param {Object} className - calling class (ie ElevationPath)\n   * @returns {DOMElement} profil container\n   */\n  displayProfileRaw: function displayProfileRaw(data, container, context, className) {\n    if (!container) {\n      return;\n    } // on nettoie toujours...\n\n\n    while (container.firstChild) {\n      container.removeChild(container.firstChild);\n    }\n\n    var _points = data && data.points ? data.points : {};\n\n    var div = document.createElement(\"textarea\");\n    div.id = \"profilElevationResults\";\n    div.rows = 10;\n    div.cols = 50;\n    div.style.width = \"100%\";\n    div.innerHTML = JSON.stringify(_points, undefined, 4);\n    div.addEventListener(\"mouseover\", function (e) {\n      className.__customRawProfileMouseOverEvent(context, e);\n    }); // TODO\n    // for (var i = 0; i < _points.length; i++) {\n    //     var point = _points[i];\n    //     var divC  = document.createElement(\"code\");\n    //     divC.id = \"point_\" + i;\n    //     divC.innerHTML = JSON.stringify(point, undefined, 4);\n    //     div.appendChild(divC);\n    //     divC.addEventListener(\"mouseover\", function (e) {\n    //          className.__customRawProfileMouseOverEvent(context, e);\n    //     });\n    // }\n\n    container.appendChild(div);\n    return container;\n  },\n\n  /**\n   * Display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.\n   *\n   * @public\n   * @param {Object} data - elevations values for profile\n   * @param {HTMLElement} container - html container where to display profile\n   * @param {Object} context - this control object\n   * @param {Object} className - calling class (ie ElevationPath)\n   * @returns {DOMElement} profil container\n   */\n  displayProfileLibD3: function displayProfileLibD3(data, container, context, className) {\n    var self = context;\n\n    if (!container) {\n      return;\n    }\n\n    if (!data) {\n      return;\n    } // on nettoie toujours...\n\n\n    while (container.firstChild) {\n      container.removeChild(container.firstChild);\n    }\n\n    var _points = data.points;\n\n    if (data.distance > 2000) {\n      data.unit = \"km\";\n\n      for (var i = 0; i < _points.length; i++) {\n        _points[i].dist /= 1000;\n      }\n    }\n\n    var _displayProfileOptions = self.options.displayProfileOptions;\n    var margin = {\n      top: 20,\n      right: 20,\n      bottom: 30,\n      left: 40\n    };\n    var width = container.clientWidth - margin.left - margin.right;\n    var height = container.clientHeight - margin.top - margin.bottom;\n    var x = d3.scale.linear().range([0, width]);\n    var y = d3.scale.linear().range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\").ticks(5);\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\").ticks(5);\n    var line = d3.svg.line().interpolate(\"basis\").x(function (d) {\n      return x(d.dist);\n    }).y(function (d) {\n      return y(d.z);\n    });\n    var area = d3.svg.area().interpolate(\"basis\").x(function (d) {\n      return x(d.dist);\n    }).y0(height).y1(function (d) {\n      return y(d.z);\n    });\n    var svg = d3.select(container).append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    var xDomain = d3.extent(_points, function (d) {\n      return d.dist;\n    });\n    x.domain(xDomain);\n    var yDomain = [0, d3.max(_points, function (d) {\n      return d.z;\n    })];\n    y.domain(yDomain);\n    svg.append(\"path\").datum(_points).attr(\"class\", \"area-d3\").attr(\"d\", area);\n    svg.append(\"g\").attr(\"class\", \"x axis-d3\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis).append(\"text\").attr(\"y\", -15).attr(\"dy\", \".71em\").attr(\"x\", width).text(\"Distance (\" + data.unit + \")\");\n    svg.append(\"g\").attr(\"class\", \"y axis-d3\").call(yAxis).append(\"text\").attr(\"transform\", \"rotate(-90)\").attr(\"y\", 6).attr(\"dy\", \".71em\").text(\"Altitude (m)\");\n    svg.append(\"g\").attr(\"class\", \"grid-d3 vertical\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis.orient(\"bottom\").tickSize(-height, 0, 0).tickFormat(\"\"));\n    svg.append(\"g\").attr(\"class\", \"grid-d3 horizontal\").call(yAxis.orient(\"left\").tickSize(-width, 0, 0).tickFormat(\"\"));\n    svg.append(\"path\").datum(_points).attr(\"class\", \"line-d3\").attr(\"d\", line);\n    svg.selectAll(\"circle\").data(_points).enter().append(\"circle\").attr(\"cx\", function (d) {\n      return x(d.dist);\n    }).attr(\"cy\", function (d) {\n      return y(d.z);\n    }).attr(\"r\", 0).attr(\"class\", \"circle-d3\");\n    var focus = svg.append(\"g\").style(\"display\", \"none\");\n    focus.append(\"line\").attr(\"id\", \"focusLineX\").attr(\"class\", \"focusLine-d3\");\n    focus.append(\"line\").attr(\"id\", \"focusLineY\").attr(\"class\", \"focusLine-d3\");\n    focus.append(\"circle\").attr(\"id\", \"focusCircle\").attr(\"r\", 4).attr(\"class\", \"circle-d3 focusCircle-d3\");\n    var div = d3.select(container).append(\"div\").attr(\"class\", \"tooltip-d3\").style(\"opacity\", 0);\n    var bisectDist = d3.bisector(function (d) {\n      return d.dist;\n    }).left;\n    svg.append(\"rect\").attr(\"class\", \"overlay-d3\").attr(\"width\", width).attr(\"height\", height).on(\"mouseover\", function () {\n      focus.style(\"display\", null);\n\n      className.__createProfileMarker(self, _points[0]);\n    }).on(\"mouseout\", function () {\n      focus.style(\"display\", \"none\");\n\n      className.__removeProfileMarker(self); // tooltips\n\n\n      div.transition().duration(500).style(\"opacity\", 0);\n    }).on(\"mousemove\", function () {\n      var m = d3.mouse(this);\n      var distance = x.invert(m[0]); // Math.max pour éviter de sortir de l'array\n\n      var i = Math.max(1, bisectDist(_points, distance));\n      var d0 = _points[i - 1];\n      var d1 = _points[i];\n      var d = distance - d0[0] > d1[0] - distance ? d1 : d0;\n      var xc = x(d.dist);\n      var yc = y(d.z);\n      focus.select(\"#focusCircle\").attr(\"cx\", xc).attr(\"cy\", yc);\n      focus.select(\"#focusLineX\").attr(\"x1\", xc).attr(\"y1\", y(yDomain[0])).attr(\"x2\", xc).attr(\"y2\", y(yDomain[1]));\n      focus.select(\"#focusLineY\").attr(\"x1\", x(xDomain[0])).attr(\"y1\", yc).attr(\"x2\", x(xDomain[1])).attr(\"y2\", yc);\n\n      className.__updateProfileMarker(self, d); // tooltips\n\n\n      div.transition().duration(200).style(\"opacity\", 0.9);\n      var _message = \"\";\n      _message += \" Altitude : \" + d.z + \" m\";\n\n      if (_displayProfileOptions.currentSlope) {\n        _message += \"<br/> Pente : \" + d.slope + \" %\";\n      }\n\n      _message += \"<br/> (Lat : \" + d.lat + \"/ Lon : \" + d.lon + \")\";\n      div.html(_message).style(\"left\", d3.event.pageX + \"px\").style(\"top\", d3.event.pageY - 28 + \"px\");\n    }); // return d3.selectAll(\"rect.overlay\")[0][0];\n\n    return svg;\n  },\n\n  /**\n   * Display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.\n   *\n   * @public\n   * @param {Object} data - elevations values for profile\n   * @param {HTMLElement} container - html container where to display profile\n   * @param {Object} context - this control object\n   * @param {Object} className - calling class (ie ElevationPath)\n   * @returns {DOMElement} profil container\n   */\n  displayProfileLibAmCharts: function displayProfileLibAmCharts(data, container, context, className) {\n    var self = context;\n\n    if (!container) {\n      return;\n    }\n\n    if (!data) {\n      return;\n    }\n\n    var _points = data.points;\n    var ballonText = \"<span class='altiPathValue'>[[title]] : [[value]]m</span><br/>\";\n    var currentSlope = self.options.displayProfileOptions.currentSlope;\n\n    if (currentSlope) {\n      ballonText += \"<span class='altiPathValue'>Pente : [[slope]] %</span><br/>\";\n    }\n\n    ballonText += \"<span class='altiPathCoords'>(Lat: [[lat]] / Lon:[[lon]])</span>\";\n    AmCharts.addInitHandler(function () {});\n\n    if (data.distance > 2000) {\n      data.unit = \"km\";\n\n      for (var i = 0; i < _points.length; i++) {\n        _points[i].dist /= 1000;\n      }\n    }\n\n    for (var _i3 = 0; _i3 < _points.length; _i3++) {\n      var dist = _points[_i3].dist;\n      var coeffArrond = 100;\n\n      if (dist > 100) {\n        coeffArrond = 1;\n      } else if (dist > 10) {\n        coeffArrond = 10;\n      } // Correction arrondi distance totale\n\n\n      dist = Math.round(dist * coeffArrond) / coeffArrond;\n      _points[_i3].dist = dist;\n    }\n\n    var settings = {\n      type: \"serial\",\n      pathToImages: \"http://cdn.amcharts.com/lib/3/images/\",\n      categoryField: \"dist\",\n      autoMarginOffset: 0,\n      marginRight: 10,\n      marginTop: 10,\n      startDuration: 0,\n      color: \"#5E5E5E\",\n      fontSize: 8,\n      theme: \"light\",\n      thousandsSeparator: \"\",\n      numberFormatter: {\n        precision: -1,\n        decimalSeparator: \",\",\n        thousandsSeparator: \" \"\n      },\n      categoryAxis: {\n        color: \"#5E5E5E\",\n        gridPosition: \"start\",\n        minHorizontalGap: 40,\n        tickPosition: \"start\",\n        title: \"Distance (\" + data.unit + \")\",\n        titleColor: \"#5E5E5E\",\n        labelOffset: 0,\n        startOnAxis: true\n      },\n      chartCursor: {\n        animationDuration: 0,\n        bulletsEnabled: true,\n        bulletSize: 10,\n        categoryBalloonEnabled: false,\n        cursorColor: \"#F90\",\n        graphBulletAlpha: 1,\n        graphBulletSize: 1,\n        zoomable: false\n      },\n      trendLines: [],\n      graphs: [{\n        balloonColor: \"#CCCCCC\",\n        balloonText: ballonText,\n        bullet: \"round\",\n        bulletAlpha: 0,\n        bulletBorderColor: \"#FFF\",\n        bulletBorderThickness: 2,\n        bulletColor: \"#F90\",\n        bulletSize: 6,\n        hidden: false,\n        id: \"AmGraph-1\",\n        fillAlphas: 0.4,\n        fillColors: \"#C77A04\",\n        lineAlpha: 1,\n        lineColor: \"#C77A04\",\n        lineThickness: 1,\n        title: \"Altitude\",\n        valueField: \"z\"\n      }],\n      guides: [],\n      valueAxes: [{\n        id: \"ValueAxis-1\",\n        minVerticalGap: 20,\n        title: \"Altitude (m)\"\n      }],\n      balloon: {\n        borderColor: \"#CCCCCC\",\n        borderThickness: 1,\n        fillColor: \"#FFFFFF\",\n        showBullet: true\n      },\n      titles: [],\n      allLabels: [],\n      dataProvider: _points\n    };\n\n    var _containerProfile = AmCharts.makeChart(container, settings);\n\n    _containerProfile.addListener(\"changed\", function (e) {\n      var obj = e.chart.dataProvider[e.index];\n\n      className.__updateProfileMarker(self, obj);\n    });\n\n    return _containerProfile;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ProfileElevationPathDOM);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL1Byb2ZpbGVFbGV2YXRpb25QYXRoRE9NLmpzP2I3OTkiXSwibmFtZXMiOlsiUHJvZmlsZUVsZXZhdGlvblBhdGhET00iLCJfZ2V0Q3NzUHJvcGVydHkiLCJlbGVtZW50IiwicHJvcGVydHkiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIl9nZXRUZXh0V2lkdGgiLCJ0ZXh0IiwiY29udGFpbmVyIiwiZm9udCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJnZXRDb250ZXh0IiwibWV0cmljcyIsIm1lYXN1cmVUZXh0Iiwid2lkdGgiLCJfZGF0YVpUb1N2Z1kiLCJ6IiwicGF0aEhlaWdodCIsIm1pbkdyYXBoWiIsInB4UGVyTVoiLCJfZGF0YURpc3RUb1N2Z1giLCJkaXN0Iiwic3ZnV2lkdGgiLCJwYXRoV2lkdGgiLCJweFBlck1YIiwiX3N2Z1hUb0RhdGFEaXN0Iiwic3ZnWCIsIl9hcnJheUJpc2VjdCIsImFycmF5IiwidmFsdWUiLCJpZHgiLCJsZW5ndGgiLCJkaXNwbGF5UHJvZmlsZUJ5RGVmYXVsdCIsImRhdGEiLCJjbGFzc05hbWUiLCJzZWxmIiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiX2Rpc3BsYXlQcm9maWxlT3B0aW9ucyIsIm9wdGlvbnMiLCJkaXNwbGF5UHJvZmlsZU9wdGlvbnMiLCJfcG9pbnRzIiwicG9pbnRzIiwic29ydGVkRWxldiIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInNvcnQiLCJlMSIsImUyIiwibWluWiIsIm1heFoiLCJkaXN0YW5jZSIsImRpc3RVbml0Iiwid2lkZ2V0RGl2IiwiaWQiLCJhcHBlbmRDaGlsZCIsIndpZGdldEhlaWd0aCIsImNsaWVudEhlaWdodCIsIndpZGdldFdpZHRoIiwiY2xpZW50V2lkdGgiLCJ6TGFiZWxXaWR0aCIsInpHcmFkV2lkdGgiLCJNYXRoIiwicm91bmQiLCJ0b0xvY2FsZVN0cmluZyIsInhMYWJlbEhlaWdodCIsInhHcmFkSGVpZ2h0IiwibWluWmd1aWRlSGVpZ3RoIiwibWluWGd1aWRlV2lkdGgiLCJtaW5OdW1YR3VpZGVzIiwiZWxldmF0aW9uU3ZnIiwiY3JlYXRlRWxlbWVudE5TIiwic2V0QXR0cmlidXRlIiwibWF4TnVtWmd1aWRlcyIsImZsb29yIiwiZ3JhZFoiLCJwb3ciLCJjZWlsIiwibG9nIiwibWF4R3JhcGhaIiwibnVtWmd1aWRlcyIsIm1heCIsImF4aXNaIiwiZ3VpZGVzWiIsImdyYWRaeU9mZnNldFB4IiwiZ3JhZFp0ZXh0IiwieVRleHRUcmFuc2xhdGlvbiIsInlTdHJva2VUcmFuc2xhdGlvbiIsImdyYWRac3Ryb2tlIiwiZ3JhZFpwYXRoIiwiZ3JhZFpncmFkIiwiaSIsInRleHRDb250ZW50IiwiYXhpc1pMZWdlbmQiLCJtYXhOdW1YZ3VpZGVzIiwiZ3JhZFgiLCJtYXhHcmFwaFgiLCJudW1YZ3VpZGVzIiwibGFzdEdyYWRYIiwiYXhpc1giLCJndWlkZXNYIiwieE9mZnNldCIsImdyYWRYeE9mZnNldFB4IiwiZ3JhZFh0ZXh0IiwieFRleHRUcmFuc2xhdGlvbiIsInhTdHJva2VUcmFuc2xhdGlvbiIsImdyYWRYc3Ryb2tlIiwiZ3JhZFhwYXRoIiwiZ3JhZFhncmFkIiwiYXhpc1hMZWdlbmQiLCJlbGV2YXRpb25QYXRoRyIsImZhY3RvciIsInBvaW50WCIsInBvaW50WSIsInBhdGhEIiwicGF0aFBhdGgiLCJwYXRoRmlsbCIsImR5bmFtaWNzRyIsInBhdGhSZWN0YW5nbGUiLCJzb3J0ZWREaXN0IiwiZm9jdXNMaW5lWCIsImZvY3VzTGluZVkiLCJmb2N1c0NpcmNsZSIsInRvb2x0aXBEaXYiLCJhbHRpU3BhbiIsInNsb3BlU3BhbiIsImNvb3Jkc1NwYW4iLCJzdHlsZSIsInBvaW50ZXJFdmVudHMiLCJwb3NpdGlvbiIsImN1cnJlbnRTbG9wZSIsInRvb2x0aXBHIiwidG9vbHRpcEJ1YmJsZSIsInRvb2x0aXBCdWJibGVTaGFkb3ciLCJvbk1vdXNlT3ZlciIsIl9fY3JlYXRlUHJvZmlsZU1hcmtlciIsIm9uTW91c2VPdXQiLCJfX3JlbW92ZVByb2ZpbGVNYXJrZXIiLCJvbk1vdXNlTW92ZSIsImUiLCJtb3VzZVBvaW50IiwiY3JlYXRlU1ZHUG9pbnQiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwic3ZnTW91c2VQb2ludCIsIm1hdHJpeFRyYW5zZm9ybSIsImdldFNjcmVlbkNUTSIsImludmVyc2UiLCJtb3VzZURpc3QiLCJkaXN0SW5kZXgiLCJkMCIsImQxIiwiZCIsImZvY3VzWCIsImZvY3VzWSIsIl9fdXBkYXRlUHJvZmlsZU1hcmtlciIsImFsdGlTcGFuVHh0Iiwic2xvcGVTcGFuVHh0Iiwic2xvcGUiLCJjb29yZHNTcGFuVHh0IiwibGF0IiwibG9uIiwiaW5uZXJIVE1MIiwidG9vbHRpcFRleHRXaWR0aCIsInRvb2xUaXBCdWJibGVEIiwidHJhbnNmb3JtIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJkaXNwbGF5UHJvZmlsZVJhdyIsImRpdiIsInJvd3MiLCJjb2xzIiwidW5kZWZpbmVkIiwiX19jdXN0b21SYXdQcm9maWxlTW91c2VPdmVyRXZlbnQiLCJkaXNwbGF5UHJvZmlsZUxpYkQzIiwidW5pdCIsImhlaWdodCIsImQzIiwic2NhbGUiLCJsaW5lYXIiLCJyYW5nZSIsInhBeGlzIiwic3ZnIiwiYXhpcyIsIm9yaWVudCIsInRpY2tzIiwieUF4aXMiLCJsaW5lIiwiaW50ZXJwb2xhdGUiLCJhcmVhIiwieTAiLCJ5MSIsInNlbGVjdCIsImFwcGVuZCIsImF0dHIiLCJ4RG9tYWluIiwiZXh0ZW50IiwiZG9tYWluIiwieURvbWFpbiIsImRhdHVtIiwiY2FsbCIsInRpY2tTaXplIiwidGlja0Zvcm1hdCIsInNlbGVjdEFsbCIsImVudGVyIiwiZm9jdXMiLCJiaXNlY3REaXN0IiwiYmlzZWN0b3IiLCJvbiIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsIm0iLCJtb3VzZSIsImludmVydCIsInhjIiwieWMiLCJfbWVzc2FnZSIsImh0bWwiLCJldmVudCIsInBhZ2VYIiwicGFnZVkiLCJkaXNwbGF5UHJvZmlsZUxpYkFtQ2hhcnRzIiwiYmFsbG9uVGV4dCIsIkFtQ2hhcnRzIiwiYWRkSW5pdEhhbmRsZXIiLCJjb2VmZkFycm9uZCIsInNldHRpbmdzIiwidHlwZSIsInBhdGhUb0ltYWdlcyIsImNhdGVnb3J5RmllbGQiLCJhdXRvTWFyZ2luT2Zmc2V0IiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Ub3AiLCJzdGFydER1cmF0aW9uIiwiY29sb3IiLCJmb250U2l6ZSIsInRoZW1lIiwidGhvdXNhbmRzU2VwYXJhdG9yIiwibnVtYmVyRm9ybWF0dGVyIiwicHJlY2lzaW9uIiwiZGVjaW1hbFNlcGFyYXRvciIsImNhdGVnb3J5QXhpcyIsImdyaWRQb3NpdGlvbiIsIm1pbkhvcml6b250YWxHYXAiLCJ0aWNrUG9zaXRpb24iLCJ0aXRsZSIsInRpdGxlQ29sb3IiLCJsYWJlbE9mZnNldCIsInN0YXJ0T25BeGlzIiwiY2hhcnRDdXJzb3IiLCJhbmltYXRpb25EdXJhdGlvbiIsImJ1bGxldHNFbmFibGVkIiwiYnVsbGV0U2l6ZSIsImNhdGVnb3J5QmFsbG9vbkVuYWJsZWQiLCJjdXJzb3JDb2xvciIsImdyYXBoQnVsbGV0QWxwaGEiLCJncmFwaEJ1bGxldFNpemUiLCJ6b29tYWJsZSIsInRyZW5kTGluZXMiLCJncmFwaHMiLCJiYWxsb29uQ29sb3IiLCJiYWxsb29uVGV4dCIsImJ1bGxldCIsImJ1bGxldEFscGhhIiwiYnVsbGV0Qm9yZGVyQ29sb3IiLCJidWxsZXRCb3JkZXJUaGlja25lc3MiLCJidWxsZXRDb2xvciIsImhpZGRlbiIsImZpbGxBbHBoYXMiLCJmaWxsQ29sb3JzIiwibGluZUFscGhhIiwibGluZUNvbG9yIiwibGluZVRoaWNrbmVzcyIsInZhbHVlRmllbGQiLCJndWlkZXMiLCJ2YWx1ZUF4ZXMiLCJtaW5WZXJ0aWNhbEdhcCIsImJhbGxvb24iLCJib3JkZXJDb2xvciIsImJvcmRlclRoaWNrbmVzcyIsImZpbGxDb2xvciIsInNob3dCdWxsZXQiLCJ0aXRsZXMiLCJhbGxMYWJlbHMiLCJkYXRhUHJvdmlkZXIiLCJfY29udGFpbmVyUHJvZmlsZSIsIm1ha2VDaGFydCIsImFkZExpc3RlbmVyIiwib2JqIiwiY2hhcnQiLCJpbmRleCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQSx1QkFBdUIsR0FBRztBQUUxQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxpQkFBZSxFQUFHLHlCQUFVQyxPQUFWLEVBQW1CQyxRQUFuQixFQUE2QjtBQUMzQyxXQUFPQyxNQUFNLENBQUNDLGdCQUFQLENBQXdCSCxPQUF4QixFQUFpQyxJQUFqQyxFQUF1Q0ksZ0JBQXZDLENBQXdESCxRQUF4RCxDQUFQO0FBQ0gsR0FkeUI7O0FBZ0IxQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lJLGVBQWEsRUFBRyx1QkFBVUMsSUFBVixFQUFnQkMsU0FBaEIsRUFBd0M7QUFBQSxRQUFiQyxJQUFhLHVFQUFOLElBQU07QUFDcEQ7QUFDQSxRQUFJQyxNQUFNO0FBQUc7QUFBaUIsU0FBS0EsTUFBTixLQUFtQixLQUFLQSxNQUFOLEdBQWdCQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbEMsQ0FBN0I7QUFDQSxRQUFJQyxPQUFPLEdBQUdILE1BQU0sQ0FBQ0ksVUFBUCxDQUFrQixJQUFsQixDQUFkOztBQUNBLFFBQUlMLElBQUksS0FBSyxJQUFiLEVBQW1CO0FBQ2ZJLGFBQU8sQ0FBQ0osSUFBUixhQUFrQixLQUFLVCxlQUFMLENBQXFCUSxTQUFyQixFQUFnQyxhQUFoQyxDQUFsQixjQUFvRSxLQUFLUixlQUFMLENBQXFCUSxTQUFyQixFQUFnQyxXQUFoQyxDQUFwRSxjQUFvSCxLQUFLUixlQUFMLENBQXFCUSxTQUFyQixFQUFnQyxhQUFoQyxDQUFwSDtBQUNILEtBRkQsTUFFTztBQUNISyxhQUFPLENBQUNKLElBQVIsR0FBZUEsSUFBZjtBQUNIOztBQUVELFFBQUlNLE9BQU8sR0FBR0YsT0FBTyxDQUFDRyxXQUFSLENBQW9CVCxJQUFwQixDQUFkO0FBQ0EsV0FBT1EsT0FBTyxDQUFDRSxLQUFmO0FBQ0gsR0F2Q3lCOztBQXlDMUI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxjQUFZLEVBQUcsc0JBQVVDLENBQVYsRUFBYUMsVUFBYixFQUF5QkMsU0FBekIsRUFBb0NDLE9BQXBDLEVBQTZDO0FBQ3hELFdBQU9GLFVBQVUsR0FBRyxDQUFDRCxDQUFDLEdBQUdFLFNBQUwsSUFBa0JDLE9BQS9CLEdBQXlDLEdBQWhEO0FBQ0gsR0F0RHlCOztBQXdEMUI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxpQkFBZSxFQUFHLHlCQUFVQyxJQUFWLEVBQWdCQyxRQUFoQixFQUEwQkMsU0FBMUIsRUFBcUNDLE9BQXJDLEVBQThDO0FBQzVELFdBQVFGLFFBQVEsR0FBR0MsU0FBWixHQUF5QkYsSUFBSSxHQUFHRyxPQUF2QztBQUNILEdBckV5Qjs7QUF1RTFCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsaUJBQWUsRUFBRyx5QkFBVUMsSUFBVixFQUFnQkosUUFBaEIsRUFBMEJDLFNBQTFCLEVBQXFDQyxPQUFyQyxFQUE4QztBQUM1RCxXQUFPLENBQUNFLElBQUksR0FBR0gsU0FBUCxHQUFtQkQsUUFBcEIsSUFBZ0NFLE9BQXZDO0FBQ0gsR0FwRnlCOztBQXNGMUI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lHLGNBQVksRUFBRyxzQkFBVUMsS0FBVixFQUFpQkMsS0FBakIsRUFBd0I7QUFDbkMsUUFBSUMsR0FBSjs7QUFDQSxRQUFJRixLQUFLLENBQUNHLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDcEIsYUFBTyxDQUFQO0FBQ0g7O0FBQ0QsU0FBS0QsR0FBRyxHQUFHLENBQVgsRUFBY0EsR0FBRyxHQUFHRixLQUFLLENBQUNHLE1BQTFCLEVBQWtDRCxHQUFHLEVBQXJDLEVBQXlDO0FBQ3JDLFVBQUlELEtBQUssR0FBR0QsS0FBSyxDQUFDRSxHQUFELENBQUwsQ0FBV1QsSUFBdkIsRUFBNkI7QUFDekIsZUFBT1MsR0FBUDtBQUNIO0FBQ0o7O0FBQ0QsV0FBT0EsR0FBRyxHQUFHLENBQWI7QUFDSCxHQTFHeUI7O0FBNEcxQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJRSx5QkFBdUIsRUFBRyxpQ0FBVUMsSUFBVixFQUFnQjVCLFNBQWhCLEVBQTJCSyxPQUEzQixFQUFvQ3dCLFNBQXBDLEVBQStDO0FBQ3JFLFFBQUlDLElBQUksR0FBR3pCLE9BQVg7O0FBRUEsUUFBSSxDQUFDTCxTQUFMLEVBQWdCO0FBQ1o7QUFDSDs7QUFFRCxRQUFJLENBQUM0QixJQUFMLEVBQVc7QUFDUDtBQUNILEtBVG9FLENBV3JFOzs7QUFDQSxXQUFPNUIsU0FBUyxDQUFDK0IsVUFBakIsRUFBNkI7QUFDekIvQixlQUFTLENBQUNnQyxXQUFWLENBQXNCaEMsU0FBUyxDQUFDK0IsVUFBaEM7QUFDSDs7QUFFRCxRQUFNRSxNQUFNLEdBQUc7QUFDWEMsU0FBRyxFQUFHLEVBREs7QUFFWEMsV0FBSyxFQUFHLEVBRkc7QUFHWEMsWUFBTSxFQUFHLEVBSEU7QUFJWEMsVUFBSSxFQUFHO0FBSkksS0FBZjtBQU9BLFFBQUlDLHNCQUFzQixHQUFHUixJQUFJLENBQUNTLE9BQUwsQ0FBYUMscUJBQTFDO0FBQ0EsUUFBSUMsT0FBTyxHQUFHYixJQUFJLENBQUNjLE1BQW5CO0FBRUEsUUFBSUMsVUFBVSxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDRSxTQUFMLENBQWVMLE9BQWYsQ0FBWCxDQUFqQjtBQUNBRSxjQUFVLENBQUNJLElBQVgsQ0FBZ0IsVUFBVUMsRUFBVixFQUFjQyxFQUFkLEVBQWtCO0FBQzlCLGFBQU9ELEVBQUUsQ0FBQ3JDLENBQUgsR0FBT3NDLEVBQUUsQ0FBQ3RDLENBQWpCO0FBQ0gsS0FGRDtBQUlBLFFBQUl1QyxJQUFJLEdBQUdQLFVBQVUsQ0FBQyxDQUFELENBQVYsQ0FBY2hDLENBQXpCO0FBQ0EsUUFBSXdDLElBQUksR0FBR1IsVUFBVSxDQUFDQSxVQUFVLENBQUNqQixNQUFYLEdBQW9CLENBQXJCLENBQVYsQ0FBa0NmLENBQTdDO0FBQ0EsUUFBSUssSUFBSSxHQUFHWSxJQUFJLENBQUN3QixRQUFoQjtBQUNBLFFBQUlDLFFBQVEsR0FBRyxHQUFmO0FBRUEsUUFBTUMsU0FBUyxHQUFHbkQsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWxCO0FBQ0FrRCxhQUFTLENBQUNDLEVBQVYsR0FBZSwyQkFBZjtBQUNBdkQsYUFBUyxDQUFDd0QsV0FBVixDQUFzQkYsU0FBdEIsRUF0Q3FFLENBd0NyRTs7QUFDQSxRQUFNRyxZQUFZLEdBQUd6RCxTQUFTLENBQUMwRCxZQUFWLEdBQXlCekIsTUFBTSxDQUFDQyxHQUFoQyxHQUFzQ0QsTUFBTSxDQUFDRyxNQUFsRTtBQUNBLFFBQU11QixXQUFXLEdBQUczRCxTQUFTLENBQUM0RCxXQUFWLEdBQXdCM0IsTUFBTSxDQUFDSSxJQUEvQixHQUFzQ0osTUFBTSxDQUFDRSxLQUFqRTtBQUVBLFFBQU0wQixXQUFXLEdBQUcsRUFBcEI7O0FBQ0EsUUFBTUMsVUFBVSxHQUFHLEtBQUtoRSxhQUFMLENBQW1CaUUsSUFBSSxDQUFDQyxLQUFMLENBQVdiLElBQVgsRUFBaUJjLGNBQWpCLEtBQW9DLEtBQXZELEVBQThEakUsU0FBOUQsRUFBeUUsZ0JBQXpFLENBQW5COztBQUNBLFFBQU1rRSxZQUFZLEdBQUcsRUFBckI7QUFDQSxRQUFNQyxXQUFXLEdBQUcsRUFBcEI7QUFFQSxRQUFNQyxlQUFlLEdBQUcsRUFBeEI7O0FBQ0EsUUFBTUMsY0FBYyxHQUFHLEtBQUt2RSxhQUFMLENBQW1CaUUsSUFBSSxDQUFDQyxLQUFMLENBQVdoRCxJQUFYLEVBQWlCaUQsY0FBakIsS0FBb0MsSUFBdkQsRUFBNkRqRSxTQUE3RCxDQUF2Qjs7QUFDQSxRQUFNc0UsYUFBYSxHQUFHLENBQXRCO0FBRUEsUUFBTTFELFVBQVUsR0FBRzZDLFlBQVksR0FBR1MsWUFBZixHQUE4QkMsV0FBakQ7QUFDQSxRQUFNakQsU0FBUyxHQUFHeUMsV0FBVyxHQUFHRSxXQUFkLEdBQTRCQyxVQUE5QztBQUVBLFFBQU1TLFlBQVksR0FBR3BFLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELEtBQXZELENBQXJCO0FBQ0FELGdCQUFZLENBQUNoQixFQUFiLEdBQWtCLDhCQUFsQjtBQUNBZ0IsZ0JBQVksQ0FBQ0UsWUFBYixDQUEwQixPQUExQixFQUFtQyxrRkFBbkM7QUFDQUYsZ0JBQVksQ0FBQ0UsWUFBYixDQUEwQixTQUExQixnQkFBNEN6RSxTQUFTLENBQUM0RCxXQUF0RCxjQUFxRTVELFNBQVMsQ0FBQzBELFlBQS9FO0FBQ0FhLGdCQUFZLENBQUNFLFlBQWIsQ0FBMEIsT0FBMUIsRUFBbUMsTUFBbkM7QUFDQUYsZ0JBQVksQ0FBQ0UsWUFBYixDQUEwQixRQUExQixFQUFvQyxNQUFwQyxFQTdEcUUsQ0ErRHJFOztBQUNBLFFBQU1DLGFBQWEsR0FBR1gsSUFBSSxDQUFDWSxLQUFMLENBQVcvRCxVQUFVLEdBQUd3RCxlQUF4QixDQUF0QjtBQUNBLFFBQUlRLEtBQUosQ0FqRXFFLENBa0VyRTs7QUFDQSxRQUFJekIsSUFBSSxLQUFLRCxJQUFiLEVBQW1CO0FBQ2YwQixXQUFLLEdBQUcsR0FBUjtBQUNILEtBRkQsTUFFTztBQUNIQSxXQUFLLEdBQUdiLElBQUksQ0FBQ2MsR0FBTCxDQUFTLEVBQVQsRUFBY2QsSUFBSSxDQUFDZSxJQUFMLENBQVVmLElBQUksQ0FBQ2dCLEdBQUwsQ0FBUyxDQUFDNUIsSUFBSSxHQUFHRCxJQUFSLElBQWdCd0IsYUFBekIsSUFBMENYLElBQUksQ0FBQ2dCLEdBQUwsQ0FBUyxFQUFULENBQXBELENBQWQsSUFBb0YsQ0FBNUY7QUFDSDs7QUFDRCxRQUFJbEUsU0FBUyxHQUFHa0QsSUFBSSxDQUFDWSxLQUFMLENBQVd6QixJQUFJLEdBQUcwQixLQUFsQixJQUEyQkEsS0FBM0M7QUFDQSxRQUFJSSxTQUFTLEdBQUdqQixJQUFJLENBQUNlLElBQUwsQ0FBVTNCLElBQUksR0FBR3lCLEtBQWpCLElBQTBCQSxLQUExQyxDQXpFcUUsQ0EwRXJFOztBQUNBLFFBQUlJLFNBQVMsS0FBSzdCLElBQWxCLEVBQXdCO0FBQ3BCNkIsZUFBUyxJQUFJSixLQUFiO0FBQ0gsS0E3RW9FLENBOEVyRTs7O0FBQ0EvRCxhQUFTLEdBQUdrRCxJQUFJLENBQUNDLEtBQUwsQ0FBV25ELFNBQVMsR0FBRyxHQUF2QixJQUE4QixHQUExQztBQUNBbUUsYUFBUyxHQUFHakIsSUFBSSxDQUFDQyxLQUFMLENBQVdnQixTQUFTLEdBQUcsR0FBdkIsSUFBOEIsR0FBMUM7QUFFQSxRQUFJQyxVQUFVLEdBQUdsQixJQUFJLENBQUNDLEtBQUwsQ0FBVyxDQUFDZ0IsU0FBUyxHQUFHbkUsU0FBYixJQUEwQitELEtBQXJDLENBQWpCLENBbEZxRSxDQW9GckU7O0FBQ0EsUUFBSUssVUFBVSxHQUFHLENBQWIsR0FBaUJQLGFBQXJCLEVBQW9DO0FBQ2hDRSxXQUFLLEdBQUdiLElBQUksQ0FBQ2MsR0FBTCxDQUFTLEVBQVQsRUFBY2QsSUFBSSxDQUFDZSxJQUFMLENBQVVmLElBQUksQ0FBQ2dCLEdBQUwsQ0FBUyxDQUFDNUIsSUFBSSxHQUFHRCxJQUFSLElBQWdCd0IsYUFBekIsSUFBMENYLElBQUksQ0FBQ2dCLEdBQUwsQ0FBUyxFQUFULENBQXBELENBQWQsQ0FBUjtBQUNBbEUsZUFBUyxHQUFHa0QsSUFBSSxDQUFDWSxLQUFMLENBQVd6QixJQUFJLEdBQUcwQixLQUFsQixJQUEyQkEsS0FBdkM7QUFDQUksZUFBUyxHQUFHakIsSUFBSSxDQUFDZSxJQUFMLENBQVUzQixJQUFJLEdBQUd5QixLQUFqQixJQUEwQkEsS0FBdEMsQ0FIZ0MsQ0FJaEM7O0FBQ0EsVUFBSUksU0FBUyxLQUFLN0IsSUFBbEIsRUFBd0I7QUFDcEI2QixpQkFBUyxJQUFJSixLQUFiO0FBQ0gsT0FQK0IsQ0FRaEM7OztBQUNBL0QsZUFBUyxHQUFHa0QsSUFBSSxDQUFDQyxLQUFMLENBQVduRCxTQUFTLEdBQUcsR0FBdkIsSUFBOEIsR0FBMUM7QUFDQW1FLGVBQVMsR0FBR2pCLElBQUksQ0FBQ0MsS0FBTCxDQUFXZ0IsU0FBUyxHQUFHLEdBQXZCLElBQThCLEdBQTFDO0FBQ0FDLGdCQUFVLEdBQUdsQixJQUFJLENBQUNZLEtBQUwsQ0FBVyxDQUFDSyxTQUFTLEdBQUduRSxTQUFiLElBQTBCK0QsS0FBckMsQ0FBYjtBQUNIOztBQUVESyxjQUFVLEdBQUdsQixJQUFJLENBQUNtQixHQUFMLENBQVNuQixJQUFJLENBQUNDLEtBQUwsQ0FBV2lCLFVBQVgsQ0FBVCxFQUFpQyxDQUFqQyxDQUFiO0FBRUEsUUFBTUUsS0FBSyxHQUFHaEYsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsR0FBdkQsQ0FBZDtBQUNBVyxTQUFLLENBQUNWLFlBQU4sQ0FBbUIsT0FBbkIsRUFBNEIsb0JBQTVCO0FBRUEsUUFBTVcsT0FBTyxHQUFHakYsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsR0FBdkQsQ0FBaEI7QUFFQSxRQUFNYSxjQUFjLEdBQUd6RSxVQUFVLEdBQUdxRSxVQUFwQztBQUNBLFFBQUluRSxPQUFPLEdBQUdGLFVBQVUsSUFBSW9FLFNBQVMsR0FBR25FLFNBQWhCLENBQXhCLENBM0dxRSxDQTRHckU7O0FBQ0EsUUFBSXNDLElBQUksS0FBS0QsSUFBYixFQUFtQjtBQUNmcEMsYUFBTyxHQUFHRixVQUFVLEdBQUcsR0FBdkI7QUFDSCxLQUZELE1BRU87QUFDSEUsYUFBTyxHQUFHRixVQUFVLElBQUlvRSxTQUFTLEdBQUduRSxTQUFoQixDQUFwQjtBQUNIOztBQUVELFFBQUl5RSxTQUFKO0FBQ0EsUUFBSUMsZ0JBQUo7QUFDQSxRQUFJQyxrQkFBSjtBQUNBLFFBQUlDLFdBQUo7QUFDQSxRQUFJQyxTQUFKO0FBQ0EsUUFBSUMsU0FBSixDQXhIcUUsQ0F5SHJFOztBQUNBLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsSUFBSVgsVUFBckIsRUFBaUNXLENBQUMsRUFBbEMsRUFBc0M7QUFDbENOLGVBQVMsR0FBR25GLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELE1BQXZELENBQVo7QUFDQWMsZUFBUyxDQUFDYixZQUFWLENBQXVCLE9BQXZCLEVBQWdDLHNCQUFoQztBQUNBYSxlQUFTLENBQUNiLFlBQVYsQ0FBdUIsYUFBdkIsRUFBc0MsU0FBdEM7QUFDQWEsZUFBUyxDQUFDYixZQUFWLENBQXVCLFdBQXZCLEVBQW9DLE1BQXBDO0FBQ0FhLGVBQVMsQ0FBQ2IsWUFBVixDQUF1QixNQUF2QixFQUErQixTQUEvQixFQUxrQyxDQU1sQztBQUNBOztBQUNBYSxlQUFTLENBQUNPLFdBQVYsR0FBd0IsQ0FBQzlCLElBQUksQ0FBQ0MsS0FBTCxDQUFXLE9BQU9uRCxTQUFTLEdBQUcrRSxDQUFDLEdBQUdoQixLQUF2QixDQUFYLElBQTRDLEdBQTdDLEVBQWtEWCxjQUFsRCxFQUF4QjtBQUVBc0Isc0JBQWdCLEdBQUczRSxVQUFVLEdBQUdnRixDQUFDLEdBQUdQLGNBQXBDO0FBRUFDLGVBQVMsQ0FBQ2IsWUFBVixDQUF1QixXQUF2QixzQkFBaURaLFdBQVcsR0FBR0MsVUFBZCxHQUEyQixDQUE1RSxlQUFrRnlCLGdCQUFnQixHQUFHLENBQXJHO0FBQ0FELGVBQVMsQ0FBQ2IsWUFBVixDQUF1QixhQUF2QixFQUFzQyxLQUF0QztBQUNBVSxXQUFLLENBQUMzQixXQUFOLENBQWtCOEIsU0FBbEI7QUFFQUUsd0JBQWtCLEdBQUd6QixJQUFJLENBQUNDLEtBQUwsQ0FBV3VCLGdCQUFYLElBQStCLEdBQXBEO0FBRUFFLGlCQUFXLEdBQUd0RixRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxHQUF2RCxDQUFkO0FBQ0FrQixlQUFTLEdBQUd2RixRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxNQUF2RCxDQUFaO0FBQ0FrQixlQUFTLENBQUNqQixZQUFWLENBQXVCLElBQXZCLEVBQTZCLFNBQTdCO0FBQ0FpQixlQUFTLENBQUNqQixZQUFWLENBQXVCLGNBQXZCLEVBQXVDLEdBQXZDOztBQUNBLFVBQUltQixDQUFDLEtBQUssQ0FBVixFQUFhO0FBQ1RGLGlCQUFTLENBQUNqQixZQUFWLENBQXVCLGdCQUF2QixFQUF5QyxLQUF6QztBQUNILE9BRkQsTUFFTztBQUNIaUIsaUJBQVMsQ0FBQ2pCLFlBQVYsQ0FBdUIsZ0JBQXZCLEVBQXlDLEdBQXpDO0FBQ0g7O0FBQ0RpQixlQUFTLENBQUNqQixZQUFWLENBQXVCLFFBQXZCLEVBQWlDLFNBQWpDO0FBQ0FpQixlQUFTLENBQUNqQixZQUFWLENBQXVCLE1BQXZCLEVBQStCLE1BQS9CO0FBQ0FpQixlQUFTLENBQUNqQixZQUFWLENBQXVCLEdBQXZCLGFBQWdDWixXQUFXLEdBQUdDLFVBQTlDLGNBQTREMEIsa0JBQTVELGVBQW1GdEUsU0FBUyxHQUFHMkMsV0FBWixHQUEwQkMsVUFBN0csY0FBMkgwQixrQkFBM0g7QUFFQUcsZUFBUyxHQUFHeEYsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsTUFBdkQsQ0FBWjtBQUNBbUIsZUFBUyxDQUFDbEIsWUFBVixDQUF1QixJQUF2QixFQUE2QixTQUE3QjtBQUNBa0IsZUFBUyxDQUFDbEIsWUFBVixDQUF1QixjQUF2QixFQUF1QyxHQUF2QztBQUNBa0IsZUFBUyxDQUFDbEIsWUFBVixDQUF1QixnQkFBdkIsRUFBeUMsR0FBekM7QUFDQWtCLGVBQVMsQ0FBQ2xCLFlBQVYsQ0FBdUIsUUFBdkIsRUFBaUMsU0FBakM7QUFDQWtCLGVBQVMsQ0FBQ2xCLFlBQVYsQ0FBdUIsTUFBdkIsRUFBK0IsTUFBL0I7QUFDQWtCLGVBQVMsQ0FBQ2xCLFlBQVYsQ0FBdUIsR0FBdkIsYUFBZ0NaLFdBQVcsR0FBR0MsVUFBOUMsY0FBNEQwQixrQkFBNUQsZUFBbUYzQixXQUFXLEdBQUdDLFVBQWQsR0FBMkIsQ0FBOUcsY0FBbUgwQixrQkFBbkg7QUFDQUcsZUFBUyxDQUFDbEIsWUFBVixDQUF1QixXQUF2QixFQUFvQyxrQkFBcEM7QUFFQWdCLGlCQUFXLENBQUNqQyxXQUFaLENBQXdCbUMsU0FBeEI7QUFDQUYsaUJBQVcsQ0FBQ2pDLFdBQVosQ0FBd0JrQyxTQUF4QjtBQUNBTixhQUFPLENBQUM1QixXQUFSLENBQW9CaUMsV0FBcEI7QUFDSDs7QUFFRCxRQUFJSyxXQUFXLEdBQUczRixRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxNQUF2RCxDQUFsQjtBQUNBc0IsZUFBVyxDQUFDckIsWUFBWixDQUF5QixPQUF6QixFQUFrQyxrQkFBbEM7QUFDQXFCLGVBQVcsQ0FBQ3JCLFlBQVosQ0FBeUIsYUFBekIsRUFBd0MsU0FBeEM7QUFDQXFCLGVBQVcsQ0FBQ3JCLFlBQVosQ0FBeUIsV0FBekIsRUFBc0MsTUFBdEM7QUFDQXFCLGVBQVcsQ0FBQ3JCLFlBQVosQ0FBeUIsTUFBekIsRUFBaUMsU0FBakM7QUFDQXFCLGVBQVcsQ0FBQ0QsV0FBWixHQUEwQixjQUExQjtBQUVBQyxlQUFXLENBQUNyQixZQUFaLENBQXlCLFdBQXpCLHNCQUFtRFosV0FBVyxHQUFHLENBQWpFLGVBQXVFRSxJQUFJLENBQUNDLEtBQUwsQ0FBV3BELFVBQVUsR0FBRyxDQUF4QixDQUF2RTtBQUNBa0YsZUFBVyxDQUFDckIsWUFBWixDQUF5QixhQUF6QixFQUF3QyxRQUF4QztBQUVBVSxTQUFLLENBQUMzQixXQUFOLENBQWtCc0MsV0FBbEI7QUFDQXZCLGdCQUFZLENBQUNmLFdBQWIsQ0FBeUIyQixLQUF6QjtBQUNBWixnQkFBWSxDQUFDZixXQUFiLENBQXlCNEIsT0FBekIsRUFuTHFFLENBcUxyRTtBQUNBOztBQUNBLFFBQUlwRSxJQUFJLEdBQUcsSUFBWCxFQUFpQjtBQUNiQSxVQUFJLElBQUksSUFBUjtBQUNBcUMsY0FBUSxHQUFHLElBQVg7QUFDSDs7QUFFRCxRQUFNMEMsYUFBYSxHQUFHaEMsSUFBSSxDQUFDWSxLQUFMLENBQVd6RCxTQUFTLEdBQUdtRCxjQUF2QixDQUF0QjtBQUNBLFFBQUkyQixLQUFLLEdBQUdqQyxJQUFJLENBQUNjLEdBQUwsQ0FBUyxFQUFULEVBQWNkLElBQUksQ0FBQ2UsSUFBTCxDQUFVZixJQUFJLENBQUNnQixHQUFMLENBQVUvRCxJQUFELEdBQVMrRSxhQUFsQixJQUFtQ2hDLElBQUksQ0FBQ2dCLEdBQUwsQ0FBUyxFQUFULENBQTdDLENBQWQsSUFBNkUsQ0FBekY7QUFDQSxRQUFNa0IsU0FBUyxHQUFHakYsSUFBbEIsQ0E5THFFLENBZ01yRTs7QUFDQSxRQUFJa0YsVUFBVSxHQUFHbkMsSUFBSSxDQUFDWSxLQUFMLENBQVdzQixTQUFTLEdBQUdELEtBQXZCLENBQWpCOztBQUNBLFFBQUlFLFVBQVUsR0FBR0gsYUFBakIsRUFBZ0M7QUFDNUJDLFdBQUssR0FBR2pDLElBQUksQ0FBQ2MsR0FBTCxDQUFTLEVBQVQsRUFBY2QsSUFBSSxDQUFDZSxJQUFMLENBQVVmLElBQUksQ0FBQ2dCLEdBQUwsQ0FBVS9ELElBQUQsR0FBUytFLGFBQWxCLElBQW1DaEMsSUFBSSxDQUFDZ0IsR0FBTCxDQUFTLEVBQVQsQ0FBN0MsQ0FBZCxDQUFSO0FBQ0FtQixnQkFBVSxHQUFHbkMsSUFBSSxDQUFDWSxLQUFMLENBQVdzQixTQUFTLEdBQUdELEtBQXZCLENBQWI7QUFDSCxLQUhELE1BR08sSUFBSUUsVUFBVSxHQUFHNUIsYUFBakIsRUFBZ0M7QUFDbkMwQixXQUFLLEdBQUdqQyxJQUFJLENBQUNjLEdBQUwsQ0FBUyxFQUFULEVBQWNkLElBQUksQ0FBQ2UsSUFBTCxDQUFVZixJQUFJLENBQUNnQixHQUFMLENBQVUvRCxJQUFELEdBQVMrRSxhQUFsQixJQUFtQ2hDLElBQUksQ0FBQ2dCLEdBQUwsQ0FBUyxFQUFULENBQTdDLENBQUQsR0FBK0QsQ0FBNUUsQ0FBUjtBQUNBbUIsZ0JBQVUsR0FBR25DLElBQUksQ0FBQ1ksS0FBTCxDQUFXc0IsU0FBUyxHQUFHRCxLQUF2QixDQUFiO0FBQ0g7O0FBRURFLGNBQVUsR0FBR25DLElBQUksQ0FBQ21CLEdBQUwsQ0FBU2dCLFVBQVQsRUFBcUIsQ0FBckIsQ0FBYjtBQUNBLFFBQU1DLFNBQVMsR0FBR0gsS0FBSyxHQUFHRSxVQUExQjtBQUVBLFFBQU1FLEtBQUssR0FBR2pHLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELEdBQXZELENBQWQ7QUFDQTRCLFNBQUssQ0FBQzNCLFlBQU4sQ0FBbUIsT0FBbkIsRUFBNEIsb0JBQTVCO0FBRUEsUUFBTTRCLE9BQU8sR0FBR2xHLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELEdBQXZELENBQWhCLENBaE5xRSxDQWtOckU7O0FBQ0EsUUFBTXJELE9BQU8sR0FBR0QsU0FBUyxHQUFHK0UsU0FBNUI7QUFDQSxRQUFNSyxPQUFPLEdBQUcsQ0FBQ0wsU0FBUyxHQUFHRSxTQUFiLElBQTBCaEYsT0FBMUM7QUFDQSxRQUFNb0YsY0FBYyxHQUFHeEMsSUFBSSxDQUFDQyxLQUFMLENBQVcsQ0FBQzlDLFNBQVMsR0FBR29GLE9BQWIsSUFBd0JKLFVBQW5DLENBQXZCO0FBRUEsUUFBSU0sU0FBSjtBQUNBLFFBQUlDLGdCQUFKO0FBQ0EsUUFBSUMsa0JBQUo7QUFDQSxRQUFJQyxXQUFKO0FBQ0EsUUFBSUMsU0FBSjtBQUNBLFFBQUlDLFNBQUosQ0E1TnFFLENBNk5yRTs7QUFDQSxTQUFLLElBQUlqQixFQUFDLEdBQUcsQ0FBYixFQUFnQkEsRUFBQyxJQUFJTSxVQUFVLEdBQUcsQ0FBbEMsRUFBcUNOLEVBQUMsRUFBdEMsRUFBMEM7QUFDdENZLGVBQVMsR0FBR3JHLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELE1BQXZELENBQVo7QUFDQWdDLGVBQVMsQ0FBQy9CLFlBQVYsQ0FBdUIsT0FBdkIsRUFBZ0Msc0JBQWhDO0FBQ0ErQixlQUFTLENBQUMvQixZQUFWLENBQXVCLGFBQXZCLEVBQXNDLFNBQXRDO0FBQ0ErQixlQUFTLENBQUMvQixZQUFWLENBQXVCLFdBQXZCLEVBQW9DLE1BQXBDO0FBQ0ErQixlQUFTLENBQUMvQixZQUFWLENBQXVCLE1BQXZCLEVBQStCLFNBQS9CLEVBTHNDLENBT3RDOztBQUNBLFVBQUltQixFQUFDLEtBQUtNLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtBQUN0QjtBQUNBTSxpQkFBUyxDQUFDWCxXQUFWLEdBQXdCLENBQUM5QixJQUFJLENBQUNDLEtBQUwsQ0FBVyxNQUFNNEIsRUFBTixHQUFVSSxLQUFyQixJQUE4QixHQUEvQixFQUFvQy9CLGNBQXBDLEVBQXhCO0FBQ0g7O0FBRUR3QyxzQkFBZ0IsR0FBRzVDLFdBQVcsR0FBR0MsVUFBZCxHQUEyQjhCLEVBQUMsR0FBR1csY0FBbEQsQ0Fic0MsQ0FjdEM7O0FBQ0EsVUFBSVgsRUFBQyxLQUFLTSxVQUFVLEdBQUcsQ0FBdkIsRUFBMEI7QUFDdEJPLHdCQUFnQixHQUFHNUMsV0FBVyxHQUFHQyxVQUFkLEdBQTJCNUMsU0FBOUM7QUFDSDs7QUFFRHNGLGVBQVMsQ0FBQy9CLFlBQVYsQ0FBdUIsV0FBdkIsc0JBQWlEZ0MsZ0JBQWpELGVBQXNFN0YsVUFBVSxHQUFHdUQsV0FBYixHQUEyQixDQUFqRztBQUNBcUMsZUFBUyxDQUFDL0IsWUFBVixDQUF1QixhQUF2QixFQUFzQyxRQUF0QztBQUNBMkIsV0FBSyxDQUFDNUMsV0FBTixDQUFrQmdELFNBQWxCO0FBRUFFLHdCQUFrQixHQUFHRCxnQkFBZ0IsR0FBRyxHQUF4QztBQUVBRSxpQkFBVyxHQUFHeEcsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsR0FBdkQsQ0FBZDtBQUNBb0MsZUFBUyxHQUFHekcsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsTUFBdkQsQ0FBWjtBQUNBb0MsZUFBUyxDQUFDbkMsWUFBVixDQUF1QixJQUF2QixFQUE2QixTQUE3QjtBQUNBbUMsZUFBUyxDQUFDbkMsWUFBVixDQUF1QixjQUF2QixFQUF1QyxHQUF2Qzs7QUFDQSxVQUFJbUIsRUFBQyxLQUFLLENBQVYsRUFBYTtBQUNUZ0IsaUJBQVMsQ0FBQ25DLFlBQVYsQ0FBdUIsZ0JBQXZCLEVBQXlDLEtBQXpDO0FBQ0gsT0FGRCxNQUVPO0FBQ0htQyxpQkFBUyxDQUFDbkMsWUFBVixDQUF1QixnQkFBdkIsRUFBeUMsR0FBekM7QUFDSDs7QUFDRG1DLGVBQVMsQ0FBQ25DLFlBQVYsQ0FBdUIsUUFBdkIsRUFBaUMsU0FBakM7QUFDQW1DLGVBQVMsQ0FBQ25DLFlBQVYsQ0FBdUIsTUFBdkIsRUFBK0IsTUFBL0I7QUFDQW1DLGVBQVMsQ0FBQ25DLFlBQVYsQ0FBdUIsR0FBdkIsYUFBZ0NpQyxrQkFBaEMsY0FBc0Q5RixVQUF0RCxlQUFxRThGLGtCQUFyRTtBQUVBRyxlQUFTLEdBQUcxRyxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxNQUF2RCxDQUFaO0FBQ0FxQyxlQUFTLENBQUNwQyxZQUFWLENBQXVCLElBQXZCLEVBQTZCLFNBQTdCO0FBQ0FvQyxlQUFTLENBQUNwQyxZQUFWLENBQXVCLGNBQXZCLEVBQXVDLEdBQXZDO0FBQ0FvQyxlQUFTLENBQUNwQyxZQUFWLENBQXVCLGdCQUF2QixFQUF5QyxHQUF6QztBQUNBb0MsZUFBUyxDQUFDcEMsWUFBVixDQUF1QixRQUF2QixFQUFpQyxTQUFqQztBQUNBb0MsZUFBUyxDQUFDcEMsWUFBVixDQUF1QixNQUF2QixFQUErQixNQUEvQjtBQUNBb0MsZUFBUyxDQUFDcEMsWUFBVixDQUF1QixHQUF2QixhQUFnQ2lDLGtCQUFoQyxjQUFzRDlGLFVBQXRELGVBQXFFOEYsa0JBQXJFLGNBQTJGOUYsVUFBVSxHQUFHLENBQXhHO0FBQ0FpRyxlQUFTLENBQUNwQyxZQUFWLENBQXVCLFdBQXZCLEVBQW9DLGlCQUFwQztBQUVBa0MsaUJBQVcsQ0FBQ25ELFdBQVosQ0FBd0JxRCxTQUF4QjtBQUNBRixpQkFBVyxDQUFDbkQsV0FBWixDQUF3Qm9ELFNBQXhCO0FBQ0FQLGFBQU8sQ0FBQzdDLFdBQVIsQ0FBb0JtRCxXQUFwQjtBQUNIOztBQUVELFFBQUlHLFdBQVcsR0FBRzNHLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELE1BQXZELENBQWxCO0FBQ0FzQyxlQUFXLENBQUNyQyxZQUFaLENBQXlCLE9BQXpCLEVBQWtDLGtCQUFsQztBQUNBcUMsZUFBVyxDQUFDckMsWUFBWixDQUF5QixhQUF6QixFQUF3QyxTQUF4QztBQUNBcUMsZUFBVyxDQUFDckMsWUFBWixDQUF5QixXQUF6QixFQUFzQyxNQUF0QztBQUNBcUMsZUFBVyxDQUFDckMsWUFBWixDQUF5QixNQUF6QixFQUFpQyxTQUFqQztBQUNBcUMsZUFBVyxDQUFDakIsV0FBWix1QkFBdUN4QyxRQUF2QztBQUVBeUQsZUFBVyxDQUFDckMsWUFBWixDQUF5QixXQUF6QixzQkFBbURaLFdBQVcsR0FBR0MsVUFBZCxHQUEyQjVDLFNBQVMsR0FBRyxDQUExRixlQUFnR04sVUFBVSxHQUFHdUQsV0FBYixHQUEyQkQsWUFBM0IsR0FBMEMsQ0FBMUk7QUFDQTRDLGVBQVcsQ0FBQ3JDLFlBQVosQ0FBeUIsYUFBekIsRUFBd0MsUUFBeEM7QUFFQTJCLFNBQUssQ0FBQzVDLFdBQU4sQ0FBa0JzRCxXQUFsQjtBQUNBdkMsZ0JBQVksQ0FBQ2YsV0FBYixDQUF5QjRDLEtBQXpCO0FBQ0E3QixnQkFBWSxDQUFDZixXQUFiLENBQXlCNkMsT0FBekI7QUFFQSxRQUFNVSxjQUFjLEdBQUc1RyxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxHQUF2RCxDQUF2QjtBQUVBLFFBQUl3QyxNQUFNLEdBQUcsQ0FBYjs7QUFDQSxRQUFJM0QsUUFBUSxLQUFLLElBQWpCLEVBQXVCO0FBQ25CMkQsWUFBTSxHQUFHLElBQVQ7QUFDSDs7QUFFRCxRQUFJQyxNQUFNLEdBQUcsS0FBS2xHLGVBQUwsQ0FBcUIwQixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVd6QixJQUFYLEdBQWtCZ0csTUFBdkMsRUFBK0NyRCxXQUEvQyxFQUE0RHpDLFNBQTVELEVBQXVFQyxPQUF2RSxDQUFiOztBQUNBLFFBQUkrRixNQUFNLEdBQUcsS0FBS3hHLFlBQUwsQ0FBa0IrQixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVc5QixDQUE3QixFQUFnQ0MsVUFBaEMsRUFBNENDLFNBQTVDLEVBQXVEQyxPQUF2RCxDQUFiOztBQUNBLFFBQUlxRyxLQUFLLGNBQU9GLE1BQVAsY0FBaUJDLE1BQWpCLENBQVQ7O0FBRUEsU0FBSyxJQUFJdEIsR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsR0FBR25ELE9BQU8sQ0FBQ2YsTUFBNUIsRUFBb0NrRSxHQUFDLEVBQXJDLEVBQXlDO0FBQ3JDcUIsWUFBTSxHQUFHLEtBQUtsRyxlQUFMLENBQXFCMEIsT0FBTyxDQUFDbUQsR0FBRCxDQUFQLENBQVc1RSxJQUFYLEdBQWtCZ0csTUFBdkMsRUFBK0NyRCxXQUEvQyxFQUE0RHpDLFNBQTVELEVBQXVFQyxPQUF2RSxDQUFUO0FBQ0ErRixZQUFNLEdBQUcsS0FBS3hHLFlBQUwsQ0FBa0IrQixPQUFPLENBQUNtRCxHQUFELENBQVAsQ0FBV2pGLENBQTdCLEVBQWdDQyxVQUFoQyxFQUE0Q0MsU0FBNUMsRUFBdURDLE9BQXZELENBQVQ7QUFDQXFHLFdBQUssZ0JBQVNGLE1BQVQsY0FBbUJDLE1BQW5CLENBQUw7QUFDSDs7QUFFRCxRQUFNRSxRQUFRLEdBQUdqSCxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxNQUF2RCxDQUFqQjtBQUNBNEMsWUFBUSxDQUFDM0MsWUFBVCxDQUFzQixJQUF0QixFQUE0QixTQUE1QjtBQUNBMkMsWUFBUSxDQUFDM0MsWUFBVCxDQUFzQixjQUF0QixFQUFzQyxHQUF0QztBQUNBMkMsWUFBUSxDQUFDM0MsWUFBVCxDQUFzQixnQkFBdEIsRUFBd0MsR0FBeEM7QUFDQTJDLFlBQVEsQ0FBQzNDLFlBQVQsQ0FBc0IsUUFBdEIsRUFBZ0MsU0FBaEM7QUFDQTJDLFlBQVEsQ0FBQzNDLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEIsTUFBOUI7QUFDQTJDLFlBQVEsQ0FBQzNDLFlBQVQsQ0FBc0IsR0FBdEIsRUFBMkIwQyxLQUEzQixFQXZUcUUsQ0F5VHJFOztBQUNBQSxTQUFLLGdCQUFTRixNQUFULGNBQW1CckcsVUFBbkIsQ0FBTDtBQUNBdUcsU0FBSyxnQkFBU3hELFdBQVcsR0FBR3pDLFNBQXZCLGNBQW9DTixVQUFwQyxDQUFMO0FBRUEsUUFBTXlHLFFBQVEsR0FBR2xILFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELE1BQXZELENBQWpCO0FBQ0E2QyxZQUFRLENBQUM1QyxZQUFULENBQXNCLElBQXRCLEVBQTRCLFNBQTVCO0FBQ0E0QyxZQUFRLENBQUM1QyxZQUFULENBQXNCLGNBQXRCLEVBQXNDLEdBQXRDO0FBQ0E0QyxZQUFRLENBQUM1QyxZQUFULENBQXNCLGdCQUF0QixFQUF3QyxHQUF4QztBQUNBNEMsWUFBUSxDQUFDNUMsWUFBVCxDQUFzQixRQUF0QixFQUFnQyxTQUFoQztBQUNBNEMsWUFBUSxDQUFDNUMsWUFBVCxDQUFzQixNQUF0QixFQUE4QixTQUE5QjtBQUNBNEMsWUFBUSxDQUFDNUMsWUFBVCxDQUFzQixjQUF0QixFQUFzQyxLQUF0QztBQUNBNEMsWUFBUSxDQUFDNUMsWUFBVCxDQUFzQixHQUF0QixFQUEyQjBDLEtBQTNCO0FBRUFKLGtCQUFjLENBQUN2RCxXQUFmLENBQTJCNEQsUUFBM0I7QUFDQUwsa0JBQWMsQ0FBQ3ZELFdBQWYsQ0FBMkI2RCxRQUEzQjtBQUNBOUMsZ0JBQVksQ0FBQ2YsV0FBYixDQUF5QnVELGNBQXpCLEVBeFVxRSxDQTBVckU7O0FBQ0EsUUFBTU8sU0FBUyxHQUFHbkgsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsR0FBdkQsQ0FBbEIsQ0EzVXFFLENBNFVyRTs7QUFDQSxRQUFNK0MsYUFBYSxHQUFHcEgsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsTUFBdkQsQ0FBdEI7QUFDQStDLGlCQUFhLENBQUM5QyxZQUFkLENBQTJCLE9BQTNCLEVBQW9DdkQsU0FBcEM7QUFDQXFHLGlCQUFhLENBQUM5QyxZQUFkLENBQTJCLFFBQTNCLEVBQXFDN0QsVUFBckM7QUFDQTJHLGlCQUFhLENBQUM5QyxZQUFkLENBQTJCLFdBQTNCLHNCQUFxRGQsV0FBVyxHQUFHekMsU0FBbkU7QUFDQXFHLGlCQUFhLENBQUM5QyxZQUFkLENBQTJCLFlBQTNCLEVBQXlDLFFBQXpDO0FBQ0E4QyxpQkFBYSxDQUFDOUMsWUFBZCxDQUEyQixnQkFBM0IsRUFBNkMsS0FBN0M7QUFFQSxRQUFNK0MsVUFBVSxHQUFHNUUsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsU0FBTCxDQUFlTCxPQUFmLENBQVgsQ0FBbkI7QUFDQStFLGNBQVUsQ0FBQ3pFLElBQVgsQ0FBZ0IsVUFBVUMsRUFBVixFQUFjQyxFQUFkLEVBQWtCO0FBQzlCLGFBQU9ELEVBQUUsQ0FBQ2hDLElBQUgsR0FBVWlDLEVBQUUsQ0FBQ2pDLElBQXBCO0FBQ0gsS0FGRDtBQUlBLFFBQU15RyxVQUFVLEdBQUd0SCxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxNQUF2RCxDQUFuQjtBQUNBaUQsY0FBVSxDQUFDaEQsWUFBWCxDQUF3QixJQUF4QixFQUE4QixZQUE5QjtBQUNBZ0QsY0FBVSxDQUFDaEQsWUFBWCxDQUF3QixPQUF4QixFQUFpQyxtQkFBakM7QUFDQWdELGNBQVUsQ0FBQ2hELFlBQVgsQ0FBd0IsTUFBeEIsRUFBZ0MsTUFBaEM7QUFDQWdELGNBQVUsQ0FBQ2hELFlBQVgsQ0FBd0IsUUFBeEIsRUFBa0MsTUFBbEM7QUFDQWdELGNBQVUsQ0FBQ2hELFlBQVgsQ0FBd0IsY0FBeEIsRUFBd0MsT0FBeEM7QUFDQWdELGNBQVUsQ0FBQ2hELFlBQVgsQ0FBd0IsWUFBeEIsRUFBc0MsUUFBdEM7QUFFQSxRQUFNaUQsVUFBVSxHQUFHdkgsUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsTUFBdkQsQ0FBbkI7QUFDQWtELGNBQVUsQ0FBQ2pELFlBQVgsQ0FBd0IsSUFBeEIsRUFBOEIsWUFBOUI7QUFDQWlELGNBQVUsQ0FBQ2pELFlBQVgsQ0FBd0IsT0FBeEIsRUFBaUMsbUJBQWpDO0FBQ0FpRCxjQUFVLENBQUNqRCxZQUFYLENBQXdCLE1BQXhCLEVBQWdDLE1BQWhDO0FBQ0FpRCxjQUFVLENBQUNqRCxZQUFYLENBQXdCLFFBQXhCLEVBQWtDLE1BQWxDO0FBQ0FpRCxjQUFVLENBQUNqRCxZQUFYLENBQXdCLGNBQXhCLEVBQXdDLE9BQXhDO0FBQ0FpRCxjQUFVLENBQUNqRCxZQUFYLENBQXdCLFlBQXhCLEVBQXNDLFFBQXRDO0FBRUEsUUFBTWtELFdBQVcsR0FBR3hILFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELFFBQXZELENBQXBCO0FBQ0FtRCxlQUFXLENBQUNsRCxZQUFaLENBQXlCLElBQXpCLEVBQStCLGFBQS9CO0FBQ0FrRCxlQUFXLENBQUNsRCxZQUFaLENBQXlCLEdBQXpCLEVBQThCLENBQTlCO0FBQ0FrRCxlQUFXLENBQUNsRCxZQUFaLENBQXlCLE9BQXpCLEVBQWtDLG9DQUFsQztBQUNBa0QsZUFBVyxDQUFDbEQsWUFBWixDQUF5QixNQUF6QixFQUFpQyxNQUFqQztBQUNBa0QsZUFBVyxDQUFDbEQsWUFBWixDQUF5QixZQUF6QixFQUF1QyxRQUF2QztBQUVBNkMsYUFBUyxDQUFDOUQsV0FBVixDQUFzQm1FLFdBQXRCO0FBQ0FMLGFBQVMsQ0FBQzlELFdBQVYsQ0FBc0JpRSxVQUF0QjtBQUNBSCxhQUFTLENBQUM5RCxXQUFWLENBQXNCa0UsVUFBdEIsRUFsWHFFLENBb1hyRTs7QUFDQSxRQUFNRSxVQUFVLEdBQUd6SCxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxNQUF2RCxDQUFuQjtBQUNBLFFBQU1xRCxRQUFRLEdBQUcxSCxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxPQUF2RCxDQUFqQjtBQUNBLFFBQU1zRCxTQUFTLEdBQUczSCxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxPQUF2RCxDQUFsQjtBQUNBLFFBQU11RCxVQUFVLEdBQUc1SCxRQUFRLENBQUNxRSxlQUFULENBQXlCLDRCQUF6QixFQUF1RCxPQUF2RCxDQUFuQjtBQUVBb0QsY0FBVSxDQUFDbkQsWUFBWCxDQUF3QixPQUF4QixFQUFpQyxxR0FBakM7QUFDQW1ELGNBQVUsQ0FBQ0ksS0FBWCxDQUFpQkMsYUFBakIsR0FBaUMsTUFBakM7QUFDQUwsY0FBVSxDQUFDSSxLQUFYLENBQWlCRSxRQUFqQixHQUE0QixPQUE1QixDQTVYcUUsQ0E2WHJFO0FBQ0E7O0FBQ0FOLGNBQVUsQ0FBQ25ELFlBQVgsQ0FBd0IsT0FBeEIsRUFBaUMsYUFBakM7QUFDQW1ELGNBQVUsQ0FBQ25ELFlBQVgsQ0FBd0IsYUFBeEIsRUFBdUMsUUFBdkM7QUFFQW5CLGFBQVMsQ0FBQ0UsV0FBVixDQUFzQm9FLFVBQXRCO0FBRUFDLFlBQVEsQ0FBQ3BELFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsZUFBL0I7QUFDQW9ELFlBQVEsQ0FBQ3BELFlBQVQsQ0FBc0IsR0FBdEIsRUFBMkIsR0FBM0I7QUFDQW9ELFlBQVEsQ0FBQ3BELFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEIsT0FBNUI7QUFFQXFELGFBQVMsQ0FBQ3JELFlBQVYsQ0FBdUIsT0FBdkIsRUFBZ0MsZUFBaEM7QUFDQXFELGFBQVMsQ0FBQ3JELFlBQVYsQ0FBdUIsR0FBdkIsRUFBNEIsR0FBNUI7QUFDQXFELGFBQVMsQ0FBQ3JELFlBQVYsQ0FBdUIsSUFBdkIsRUFBNkIsS0FBN0I7QUFFQXNELGNBQVUsQ0FBQ3RELFlBQVgsQ0FBd0IsT0FBeEIsRUFBaUMsZ0JBQWpDO0FBQ0FzRCxjQUFVLENBQUN0RCxZQUFYLENBQXdCLEdBQXhCLEVBQTZCLEdBQTdCO0FBQ0FzRCxjQUFVLENBQUN0RCxZQUFYLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0FBRUFtRCxjQUFVLENBQUNwRSxXQUFYLENBQXVCcUUsUUFBdkI7O0FBQ0EsUUFBSXZGLHNCQUFzQixDQUFDNkYsWUFBM0IsRUFBeUM7QUFDckNQLGdCQUFVLENBQUNwRSxXQUFYLENBQXVCc0UsU0FBdkI7QUFDSDs7QUFDREYsY0FBVSxDQUFDcEUsV0FBWCxDQUF1QnVFLFVBQXZCO0FBRUEsUUFBTUssUUFBUSxHQUFHakksUUFBUSxDQUFDcUUsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsR0FBdkQsQ0FBakI7QUFFQThDLGFBQVMsQ0FBQzlELFdBQVYsQ0FBc0I0RSxRQUF0QjtBQUVBLFFBQU1DLGFBQWEsR0FBR2xJLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELE1BQXZELENBQXRCO0FBQ0E2RCxpQkFBYSxDQUFDNUQsWUFBZCxDQUEyQixJQUEzQixFQUFpQyxTQUFqQztBQUNBNEQsaUJBQWEsQ0FBQzVELFlBQWQsQ0FBMkIsTUFBM0IsRUFBbUMsU0FBbkM7QUFDQTRELGlCQUFhLENBQUM1RCxZQUFkLENBQTJCLFFBQTNCLEVBQXFDLFNBQXJDO0FBQ0E0RCxpQkFBYSxDQUFDNUQsWUFBZCxDQUEyQixjQUEzQixFQUEyQyxLQUEzQztBQUNBNEQsaUJBQWEsQ0FBQzVELFlBQWQsQ0FBMkIsY0FBM0IsRUFBMkMsR0FBM0M7QUFDQTRELGlCQUFhLENBQUM1RCxZQUFkLENBQTJCLGdCQUEzQixFQUE2QyxHQUE3QztBQUVBLFFBQU02RCxtQkFBbUIsR0FBR25JLFFBQVEsQ0FBQ3FFLGVBQVQsQ0FBeUIsNEJBQXpCLEVBQXVELE1BQXZELENBQTVCO0FBQ0E4RCx1QkFBbUIsQ0FBQzdELFlBQXBCLENBQWlDLElBQWpDLEVBQXVDLFNBQXZDO0FBQ0E2RCx1QkFBbUIsQ0FBQzdELFlBQXBCLENBQWlDLE1BQWpDLEVBQXlDLFNBQXpDO0FBQ0E2RCx1QkFBbUIsQ0FBQzdELFlBQXBCLENBQWlDLFFBQWpDLEVBQTJDLFNBQTNDO0FBQ0E2RCx1QkFBbUIsQ0FBQzdELFlBQXBCLENBQWlDLGNBQWpDLEVBQWlELEdBQWpEO0FBQ0E2RCx1QkFBbUIsQ0FBQzdELFlBQXBCLENBQWlDLGNBQWpDLEVBQWlELEdBQWpEO0FBQ0E2RCx1QkFBbUIsQ0FBQzdELFlBQXBCLENBQWlDLGdCQUFqQyxFQUFtRCxLQUFuRDtBQUNBNkQsdUJBQW1CLENBQUM3RCxZQUFwQixDQUFpQyxXQUFqQyxFQUE4QyxnQkFBOUM7QUFFQTJELFlBQVEsQ0FBQzVFLFdBQVQsQ0FBcUI4RSxtQkFBckI7QUFDQUYsWUFBUSxDQUFDNUUsV0FBVCxDQUFxQjZFLGFBQXJCO0FBQ0FELFlBQVEsQ0FBQzVFLFdBQVQsQ0FBcUJvRSxVQUFyQixFQTdhcUUsQ0ErYXJFO0FBQ0E7O0FBQ0FRLFlBQVEsQ0FBQzNELFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsYUFBL0I7QUFDQTJELFlBQVEsQ0FBQ0osS0FBVCxDQUFlQyxhQUFmLEdBQStCLE1BQS9COztBQUVBLGFBQVNNLFdBQVQsR0FBd0I7QUFDcEJkLGdCQUFVLENBQUNoRCxZQUFYLENBQXdCLFlBQXhCLEVBQXNDLFNBQXRDO0FBQ0FpRCxnQkFBVSxDQUFDakQsWUFBWCxDQUF3QixZQUF4QixFQUFzQyxTQUF0QztBQUNBa0QsaUJBQVcsQ0FBQ2xELFlBQVosQ0FBeUIsWUFBekIsRUFBdUMsU0FBdkM7O0FBQ0E1QyxlQUFTLENBQUMyRyxxQkFBVixDQUFnQzFHLElBQWhDLEVBQXNDVyxPQUFPLENBQUMsQ0FBRCxDQUE3QyxFQUpvQixDQU1wQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQW1GLGdCQUFVLENBQUNuRCxZQUFYLENBQXdCLE9BQXhCLEVBQWlDLGVBQWpDO0FBQ0EyRCxjQUFRLENBQUMzRCxZQUFULENBQXNCLE9BQXRCLEVBQStCLGVBQS9CO0FBQ0g7O0FBRUQsYUFBU2dFLFVBQVQsR0FBdUI7QUFDbkJoQixnQkFBVSxDQUFDaEQsWUFBWCxDQUF3QixZQUF4QixFQUFzQyxRQUF0QztBQUNBaUQsZ0JBQVUsQ0FBQ2pELFlBQVgsQ0FBd0IsWUFBeEIsRUFBc0MsUUFBdEM7QUFDQWtELGlCQUFXLENBQUNsRCxZQUFaLENBQXlCLFlBQXpCLEVBQXVDLFFBQXZDOztBQUNBNUMsZUFBUyxDQUFDNkcscUJBQVYsQ0FBZ0M1RyxJQUFoQyxFQUptQixDQUtuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOEYsZ0JBQVUsQ0FBQ25ELFlBQVgsQ0FBd0IsT0FBeEIsRUFBaUMsZ0JBQWpDO0FBQ0EyRCxjQUFRLENBQUMzRCxZQUFULENBQXNCLE9BQXRCLEVBQStCLGdCQUEvQjtBQUNIOztBQUVELGFBQVNrRSxXQUFULENBQXNCQyxDQUF0QixFQUF5QjtBQUNyQixVQUFNQyxVQUFVLEdBQUd0RSxZQUFZLENBQUN1RSxjQUFiLEVBQW5CO0FBQ0FELGdCQUFVLENBQUNFLENBQVgsR0FBZUgsQ0FBQyxDQUFDSSxPQUFqQjtBQUNBSCxnQkFBVSxDQUFDSSxDQUFYLEdBQWVMLENBQUMsQ0FBQ00sT0FBakI7QUFDQSxVQUFNQyxhQUFhLEdBQUdOLFVBQVUsQ0FBQ08sZUFBWCxDQUEyQjdFLFlBQVksQ0FBQzhFLFlBQWIsR0FBNEJDLE9BQTVCLEVBQTNCLENBQXRCO0FBQ0EsVUFBTUMsU0FBUyxHQUFHLEtBQUtuSSxlQUFMLENBQXFCK0gsYUFBYSxDQUFDSixDQUFuQyxFQUFzQ3BGLFdBQXRDLEVBQW1EekMsU0FBbkQsRUFBOERDLE9BQTlELElBQXlFNkYsTUFBM0YsQ0FMcUIsQ0FPckI7O0FBQ0EsVUFBTXdDLFNBQVMsR0FBR3pGLElBQUksQ0FBQ21CLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSzVELFlBQUwsQ0FBa0JrRyxVQUFsQixFQUE4QitCLFNBQTlCLENBQVosQ0FBbEI7QUFFQSxVQUFNRSxFQUFFLEdBQUdoSCxPQUFPLENBQUMrRyxTQUFTLEdBQUcsQ0FBYixDQUFsQjtBQUNBLFVBQU1FLEVBQUUsR0FBR2pILE9BQU8sQ0FBQytHLFNBQUQsQ0FBbEI7QUFDQSxVQUFJRyxDQUFDLEdBQUdGLEVBQVI7O0FBQ0EsVUFBSUYsU0FBUyxHQUFHRSxFQUFFLENBQUN6SSxJQUFmLEdBQXNCMEksRUFBRSxDQUFDMUksSUFBSCxHQUFVdUksU0FBcEMsRUFBK0M7QUFDM0NJLFNBQUMsR0FBR0QsRUFBSjtBQUNIOztBQUVELFVBQU1FLE1BQU0sR0FBRyxLQUFLN0ksZUFBTCxDQUFxQjRJLENBQUMsQ0FBQzNJLElBQUYsR0FBU2dHLE1BQTlCLEVBQXNDckQsV0FBdEMsRUFBbUR6QyxTQUFuRCxFQUE4REMsT0FBOUQsQ0FBZjs7QUFDQSxVQUFNMEksTUFBTSxHQUFHLEtBQUtuSixZQUFMLENBQWtCaUosQ0FBQyxDQUFDaEosQ0FBcEIsRUFBdUJDLFVBQXZCLEVBQW1DQyxTQUFuQyxFQUE4Q0MsT0FBOUMsQ0FBZixDQWxCcUIsQ0FvQnJCOzs7QUFDQTZHLGlCQUFXLENBQUNsRCxZQUFaLENBQXlCLElBQXpCLEVBQStCbUYsTUFBL0I7QUFDQWpDLGlCQUFXLENBQUNsRCxZQUFaLENBQXlCLElBQXpCLEVBQStCb0YsTUFBL0I7QUFFQXBDLGdCQUFVLENBQUNoRCxZQUFYLENBQXdCLElBQXhCLEVBQThCbUYsTUFBOUI7QUFDQW5DLGdCQUFVLENBQUNoRCxZQUFYLENBQXdCLElBQXhCLEVBQThCN0QsVUFBOUI7QUFDQTZHLGdCQUFVLENBQUNoRCxZQUFYLENBQXdCLElBQXhCLEVBQThCbUYsTUFBOUI7QUFDQW5DLGdCQUFVLENBQUNoRCxZQUFYLENBQXdCLElBQXhCLEVBQThCLENBQTlCO0FBRUFpRCxnQkFBVSxDQUFDakQsWUFBWCxDQUF3QixJQUF4QixFQUE4QlosV0FBVyxHQUFHQyxVQUE1QztBQUNBNEQsZ0JBQVUsQ0FBQ2pELFlBQVgsQ0FBd0IsSUFBeEIsRUFBOEJvRixNQUE5QjtBQUNBbkMsZ0JBQVUsQ0FBQ2pELFlBQVgsQ0FBd0IsSUFBeEIsRUFBOEJ2RCxTQUFTLEdBQUcyQyxXQUFaLEdBQTBCQyxVQUF4RDtBQUNBNEQsZ0JBQVUsQ0FBQ2pELFlBQVgsQ0FBd0IsSUFBeEIsRUFBOEJvRixNQUE5Qjs7QUFFQWhJLGVBQVMsQ0FBQ2lJLHFCQUFWLENBQWdDaEksSUFBaEMsRUFBc0M2SCxDQUF0QyxFQWxDcUIsQ0FvQ3JCOzs7QUFDQSxVQUFNSSxXQUFXLHdCQUFpQkosQ0FBQyxDQUFDaEosQ0FBRixDQUFJc0QsY0FBSixFQUFqQixPQUFqQjtBQUNBLFVBQU0rRixZQUFZLHFCQUFjTCxDQUFDLENBQUNNLEtBQWhCLE9BQWxCO0FBQ0EsVUFBTUMsYUFBYSxvQkFBYVAsQ0FBQyxDQUFDUSxHQUFGLENBQU1sRyxjQUFOLEVBQWIsc0JBQStDMEYsQ0FBQyxDQUFDUyxHQUFGLENBQU1uRyxjQUFOLEVBQS9DLE1BQW5CO0FBRUE0RCxjQUFRLENBQUN3QyxTQUFULEdBQXFCTixXQUFyQjtBQUNBakMsZUFBUyxDQUFDdUMsU0FBVixHQUFzQkwsWUFBdEI7QUFDQWpDLGdCQUFVLENBQUNzQyxTQUFYLEdBQXVCSCxhQUF2QjtBQUVBLFVBQU1JLGdCQUFnQixHQUFHdkcsSUFBSSxDQUFDbUIsR0FBTCxDQUNyQixLQUFLcEYsYUFBTCxDQUFtQm9LLGFBQW5CLEVBQWtDbkMsVUFBbEMsQ0FEcUIsRUFFckIsS0FBS2pJLGFBQUwsQ0FBbUJpSyxXQUFuQixFQUFnQ2xDLFFBQWhDLENBRnFCLENBQXpCO0FBS0EsVUFBSTBDLGNBQUo7O0FBQ0EsVUFBSVosQ0FBQyxDQUFDM0ksSUFBRixHQUFVQSxJQUFJLEdBQUdnRyxNQUFSLEdBQWtCLENBQS9CLEVBQWtDO0FBQzlCdUQsc0JBQWMsMENBQW1DRCxnQkFBZ0IsR0FBRyxFQUF0RCwwQkFBd0VBLGdCQUFnQixHQUFHLEVBQTNGLG9CQUFkO0FBQ0ExQyxrQkFBVSxDQUFDbkQsWUFBWCxDQUF3QixXQUF4QixzQkFBa0QsRUFBRTZGLGdCQUFnQixHQUFHLENBQW5CLEdBQXVCLEVBQXpCLENBQWxELFVBRjhCLENBRXdEO0FBQ3pGLE9BSEQsTUFHTyxJQUFJWCxDQUFDLENBQUMzSSxJQUFGLElBQVdBLElBQUksR0FBR2dHLE1BQVIsR0FBa0IsQ0FBaEMsRUFBbUM7QUFDdEN1RCxzQkFBYyx3Q0FBaUNELGdCQUFnQixHQUFHLEVBQXBELDJCQUF1RUEsZ0JBQWdCLEdBQUcsRUFBMUYscUJBQWQsQ0FEc0MsQ0FFdEM7O0FBQ0ExQyxrQkFBVSxDQUFDbkQsWUFBWCxDQUF3QixXQUF4QixzQkFBbUQ2RixnQkFBZ0IsR0FBRyxDQUFuQixHQUF1QixFQUExRSxVQUhzQyxDQUcrQztBQUN4Rjs7QUFFRGpDLG1CQUFhLENBQUM1RCxZQUFkLENBQTJCLEdBQTNCLEVBQWdDOEYsY0FBaEM7QUFDQWpDLHlCQUFtQixDQUFDN0QsWUFBcEIsQ0FBaUMsR0FBakMsRUFBc0M4RixjQUF0QztBQUVBbkMsY0FBUSxDQUFDM0QsWUFBVCxDQUFzQixXQUF0QixzQkFBZ0RtRixNQUFoRCxjQUEwREMsTUFBMUQsUUEvRHFCLENBK0RpRDs7QUFDdEV6QixjQUFRLENBQUNKLEtBQVQsQ0FBZXdDLFNBQWYsdUJBQXdDWixNQUF4QyxnQkFBb0RDLE1BQXBEO0FBQ0g7O0FBRUR0QyxpQkFBYSxDQUFDa0QsZ0JBQWQsQ0FBK0IsYUFBL0IsRUFBOENsQyxXQUE5QztBQUNBaEIsaUJBQWEsQ0FBQ2tELGdCQUFkLENBQStCLFlBQS9CLEVBQTZDaEMsVUFBN0M7QUFDQWxCLGlCQUFhLENBQUNrRCxnQkFBZCxDQUErQixhQUEvQixFQUE4QzlCLFdBQVcsQ0FBQytCLElBQVosQ0FBaUIsSUFBakIsQ0FBOUM7QUFFQXBELGFBQVMsQ0FBQzlELFdBQVYsQ0FBc0IrRCxhQUF0QjtBQUNBaEQsZ0JBQVksQ0FBQ2YsV0FBYixDQUF5QjhELFNBQXpCO0FBRUFoRSxhQUFTLENBQUNFLFdBQVYsQ0FBc0JlLFlBQXRCO0FBRUEsV0FBT3ZFLFNBQVA7QUFDSCxHQXhwQnlCOztBQTBwQjFCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0kySyxtQkFBaUIsRUFBRywyQkFBVS9JLElBQVYsRUFBZ0I1QixTQUFoQixFQUEyQkssT0FBM0IsRUFBb0N3QixTQUFwQyxFQUErQztBQUMvRCxRQUFJLENBQUM3QixTQUFMLEVBQWdCO0FBQ1o7QUFDSCxLQUg4RCxDQUsvRDs7O0FBQ0EsV0FBT0EsU0FBUyxDQUFDK0IsVUFBakIsRUFBNkI7QUFDekIvQixlQUFTLENBQUNnQyxXQUFWLENBQXNCaEMsU0FBUyxDQUFDK0IsVUFBaEM7QUFDSDs7QUFFRCxRQUFJVSxPQUFPLEdBQUliLElBQUksSUFBSUEsSUFBSSxDQUFDYyxNQUFkLEdBQXdCZCxJQUFJLENBQUNjLE1BQTdCLEdBQXNDLEVBQXBEOztBQUVBLFFBQUlrSSxHQUFHLEdBQUd6SyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsVUFBdkIsQ0FBVjtBQUNBd0ssT0FBRyxDQUFDckgsRUFBSixHQUFTLHdCQUFUO0FBQ0FxSCxPQUFHLENBQUNDLElBQUosR0FBVyxFQUFYO0FBQ0FELE9BQUcsQ0FBQ0UsSUFBSixHQUFXLEVBQVg7QUFDQUYsT0FBRyxDQUFDNUMsS0FBSixDQUFVdkgsS0FBVixHQUFrQixNQUFsQjtBQUNBbUssT0FBRyxDQUFDUCxTQUFKLEdBQWdCekgsSUFBSSxDQUFDRSxTQUFMLENBQWVMLE9BQWYsRUFBd0JzSSxTQUF4QixFQUFtQyxDQUFuQyxDQUFoQjtBQUNBSCxPQUFHLENBQUNILGdCQUFKLENBQXFCLFdBQXJCLEVBQWtDLFVBQVU3QixDQUFWLEVBQWE7QUFDM0MvRyxlQUFTLENBQUNtSixnQ0FBVixDQUEyQzNLLE9BQTNDLEVBQW9EdUksQ0FBcEQ7QUFDSCxLQUZELEVBbEIrRCxDQXNCL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTVJLGFBQVMsQ0FBQ3dELFdBQVYsQ0FBc0JvSCxHQUF0QjtBQUVBLFdBQU81SyxTQUFQO0FBQ0gsR0F6c0J5Qjs7QUEyc0IxQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJaUwscUJBQW1CLEVBQUcsNkJBQVVySixJQUFWLEVBQWdCNUIsU0FBaEIsRUFBMkJLLE9BQTNCLEVBQW9Dd0IsU0FBcEMsRUFBK0M7QUFDakUsUUFBSUMsSUFBSSxHQUFHekIsT0FBWDs7QUFFQSxRQUFJLENBQUNMLFNBQUwsRUFBZ0I7QUFDWjtBQUNIOztBQUVELFFBQUksQ0FBQzRCLElBQUwsRUFBVztBQUNQO0FBQ0gsS0FUZ0UsQ0FXakU7OztBQUNBLFdBQU81QixTQUFTLENBQUMrQixVQUFqQixFQUE2QjtBQUN6Qi9CLGVBQVMsQ0FBQ2dDLFdBQVYsQ0FBc0JoQyxTQUFTLENBQUMrQixVQUFoQztBQUNIOztBQUVELFFBQUlVLE9BQU8sR0FBR2IsSUFBSSxDQUFDYyxNQUFuQjs7QUFFQSxRQUFJZCxJQUFJLENBQUN3QixRQUFMLEdBQWdCLElBQXBCLEVBQTBCO0FBQ3RCeEIsVUFBSSxDQUFDc0osSUFBTCxHQUFZLElBQVo7O0FBQ0EsV0FBSyxJQUFJdEYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR25ELE9BQU8sQ0FBQ2YsTUFBNUIsRUFBb0NrRSxDQUFDLEVBQXJDLEVBQXlDO0FBQ3JDbkQsZUFBTyxDQUFDbUQsQ0FBRCxDQUFQLENBQVc1RSxJQUFYLElBQW1CLElBQW5CO0FBQ0g7QUFDSjs7QUFFRCxRQUFJc0Isc0JBQXNCLEdBQUdSLElBQUksQ0FBQ1MsT0FBTCxDQUFhQyxxQkFBMUM7QUFFQSxRQUFJUCxNQUFNLEdBQUc7QUFDVEMsU0FBRyxFQUFHLEVBREc7QUFFVEMsV0FBSyxFQUFHLEVBRkM7QUFHVEMsWUFBTSxFQUFHLEVBSEE7QUFJVEMsVUFBSSxFQUFHO0FBSkUsS0FBYjtBQU9BLFFBQUk1QixLQUFLLEdBQUdULFNBQVMsQ0FBQzRELFdBQVYsR0FBd0IzQixNQUFNLENBQUNJLElBQS9CLEdBQXNDSixNQUFNLENBQUNFLEtBQXpEO0FBQ0EsUUFBSWdKLE1BQU0sR0FBR25MLFNBQVMsQ0FBQzBELFlBQVYsR0FBeUJ6QixNQUFNLENBQUNDLEdBQWhDLEdBQXNDRCxNQUFNLENBQUNHLE1BQTFEO0FBRUEsUUFBSTJHLENBQUMsR0FBR3FDLEVBQUUsQ0FBQ0MsS0FBSCxDQUFTQyxNQUFULEdBQ0hDLEtBREcsQ0FDRyxDQUFDLENBQUQsRUFBSTlLLEtBQUosQ0FESCxDQUFSO0FBR0EsUUFBSXdJLENBQUMsR0FBR21DLEVBQUUsQ0FBQ0MsS0FBSCxDQUFTQyxNQUFULEdBQ0hDLEtBREcsQ0FDRyxDQUFDSixNQUFELEVBQVMsQ0FBVCxDQURILENBQVI7QUFHQSxRQUFJSyxLQUFLLEdBQUdKLEVBQUUsQ0FBQ0ssR0FBSCxDQUFPQyxJQUFQLEdBQ1BMLEtBRE8sQ0FDRHRDLENBREMsRUFFUDRDLE1BRk8sQ0FFQSxRQUZBLEVBR1BDLEtBSE8sQ0FHRCxDQUhDLENBQVo7QUFLQSxRQUFJQyxLQUFLLEdBQUdULEVBQUUsQ0FBQ0ssR0FBSCxDQUFPQyxJQUFQLEdBQ1BMLEtBRE8sQ0FDRHBDLENBREMsRUFFUDBDLE1BRk8sQ0FFQSxNQUZBLEVBR1BDLEtBSE8sQ0FHRCxDQUhDLENBQVo7QUFLQSxRQUFJRSxJQUFJLEdBQUdWLEVBQUUsQ0FBQ0ssR0FBSCxDQUFPSyxJQUFQLEdBQ05DLFdBRE0sQ0FDTSxPQUROLEVBRU5oRCxDQUZNLENBRUosVUFBVVksQ0FBVixFQUFhO0FBQ1osYUFBT1osQ0FBQyxDQUFDWSxDQUFDLENBQUMzSSxJQUFILENBQVI7QUFDSCxLQUpNLEVBS05pSSxDQUxNLENBS0osVUFBVVUsQ0FBVixFQUFhO0FBQ1osYUFBT1YsQ0FBQyxDQUFDVSxDQUFDLENBQUNoSixDQUFILENBQVI7QUFDSCxLQVBNLENBQVg7QUFTQSxRQUFJcUwsSUFBSSxHQUFHWixFQUFFLENBQUNLLEdBQUgsQ0FBT08sSUFBUCxHQUNORCxXQURNLENBQ00sT0FETixFQUVOaEQsQ0FGTSxDQUVKLFVBQVVZLENBQVYsRUFBYTtBQUNaLGFBQU9aLENBQUMsQ0FBQ1ksQ0FBQyxDQUFDM0ksSUFBSCxDQUFSO0FBQ0gsS0FKTSxFQUtOaUwsRUFMTSxDQUtIZCxNQUxHLEVBTU5lLEVBTk0sQ0FNSCxVQUFVdkMsQ0FBVixFQUFhO0FBQ2IsYUFBT1YsQ0FBQyxDQUFDVSxDQUFDLENBQUNoSixDQUFILENBQVI7QUFDSCxLQVJNLENBQVg7QUFVQSxRQUFJOEssR0FBRyxHQUFHTCxFQUFFLENBQUNlLE1BQUgsQ0FBVW5NLFNBQVYsRUFDTG9NLE1BREssQ0FDRSxLQURGLEVBRUxDLElBRkssQ0FFQSxPQUZBLEVBRVM1TCxLQUFLLEdBQUd3QixNQUFNLENBQUNJLElBQWYsR0FBc0JKLE1BQU0sQ0FBQ0UsS0FGdEMsRUFHTGtLLElBSEssQ0FHQSxRQUhBLEVBR1VsQixNQUFNLEdBQUdsSixNQUFNLENBQUNDLEdBQWhCLEdBQXNCRCxNQUFNLENBQUNHLE1BSHZDLEVBSUxnSyxNQUpLLENBSUUsR0FKRixFQUtMQyxJQUxLLENBS0EsV0FMQSxFQUthLGVBQWVwSyxNQUFNLENBQUNJLElBQXRCLEdBQTZCLEdBQTdCLEdBQW1DSixNQUFNLENBQUNDLEdBQTFDLEdBQWdELEdBTDdELENBQVY7QUFPQSxRQUFJb0ssT0FBTyxHQUFHbEIsRUFBRSxDQUFDbUIsTUFBSCxDQUFVOUosT0FBVixFQUFtQixVQUFVa0gsQ0FBVixFQUFhO0FBQzFDLGFBQU9BLENBQUMsQ0FBQzNJLElBQVQ7QUFDSCxLQUZhLENBQWQ7QUFHQStILEtBQUMsQ0FBQ3lELE1BQUYsQ0FBU0YsT0FBVDtBQUVBLFFBQUlHLE9BQU8sR0FBRyxDQUNWLENBRFUsRUFFVnJCLEVBQUUsQ0FBQ2xHLEdBQUgsQ0FBT3pDLE9BQVAsRUFBZ0IsVUFBVWtILENBQVYsRUFBYTtBQUN6QixhQUFPQSxDQUFDLENBQUNoSixDQUFUO0FBQ0gsS0FGRCxDQUZVLENBQWQ7QUFNQXNJLEtBQUMsQ0FBQ3VELE1BQUYsQ0FBU0MsT0FBVDtBQUVBaEIsT0FBRyxDQUFDVyxNQUFKLENBQVcsTUFBWCxFQUNLTSxLQURMLENBQ1dqSyxPQURYLEVBRUs0SixJQUZMLENBRVUsT0FGVixFQUVtQixTQUZuQixFQUdLQSxJQUhMLENBR1UsR0FIVixFQUdlTCxJQUhmO0FBS0FQLE9BQUcsQ0FBQ1csTUFBSixDQUFXLEdBQVgsRUFDS0MsSUFETCxDQUNVLE9BRFYsRUFDbUIsV0FEbkIsRUFFS0EsSUFGTCxDQUVVLFdBRlYsRUFFdUIsaUJBQWlCbEIsTUFBakIsR0FBMEIsR0FGakQsRUFHS3dCLElBSEwsQ0FHVW5CLEtBSFYsRUFJS1ksTUFKTCxDQUlZLE1BSlosRUFLS0MsSUFMTCxDQUtVLEdBTFYsRUFLZSxDQUFDLEVBTGhCLEVBTUtBLElBTkwsQ0FNVSxJQU5WLEVBTWdCLE9BTmhCLEVBT0tBLElBUEwsQ0FPVSxHQVBWLEVBT2U1TCxLQVBmLEVBUUtWLElBUkwsQ0FRVSxlQUFlNkIsSUFBSSxDQUFDc0osSUFBcEIsR0FBMkIsR0FSckM7QUFVQU8sT0FBRyxDQUFDVyxNQUFKLENBQVcsR0FBWCxFQUNLQyxJQURMLENBQ1UsT0FEVixFQUNtQixXQURuQixFQUVLTSxJQUZMLENBRVVkLEtBRlYsRUFHS08sTUFITCxDQUdZLE1BSFosRUFJS0MsSUFKTCxDQUlVLFdBSlYsRUFJdUIsYUFKdkIsRUFLS0EsSUFMTCxDQUtVLEdBTFYsRUFLZSxDQUxmLEVBTUtBLElBTkwsQ0FNVSxJQU5WLEVBTWdCLE9BTmhCLEVBT0t0TSxJQVBMLENBT1UsY0FQVjtBQVNBMEwsT0FBRyxDQUFDVyxNQUFKLENBQVcsR0FBWCxFQUNLQyxJQURMLENBQ1UsT0FEVixFQUNtQixrQkFEbkIsRUFFS0EsSUFGTCxDQUVVLFdBRlYsRUFFdUIsaUJBQWlCbEIsTUFBakIsR0FBMEIsR0FGakQsRUFHS3dCLElBSEwsQ0FHVW5CLEtBQUssQ0FDTkcsTUFEQyxDQUNNLFFBRE4sRUFFRGlCLFFBRkMsQ0FFUSxDQUFDekIsTUFGVCxFQUVpQixDQUZqQixFQUVvQixDQUZwQixFQUdEMEIsVUFIQyxDQUdVLEVBSFYsQ0FIVjtBQVNBcEIsT0FBRyxDQUFDVyxNQUFKLENBQVcsR0FBWCxFQUNLQyxJQURMLENBQ1UsT0FEVixFQUNtQixvQkFEbkIsRUFFS00sSUFGTCxDQUVVZCxLQUFLLENBQ05GLE1BREMsQ0FDTSxNQUROLEVBRURpQixRQUZDLENBRVEsQ0FBQ25NLEtBRlQsRUFFZ0IsQ0FGaEIsRUFFbUIsQ0FGbkIsRUFHRG9NLFVBSEMsQ0FHVSxFQUhWLENBRlY7QUFRQXBCLE9BQUcsQ0FBQ1csTUFBSixDQUFXLE1BQVgsRUFDS00sS0FETCxDQUNXakssT0FEWCxFQUVLNEosSUFGTCxDQUVVLE9BRlYsRUFFbUIsU0FGbkIsRUFHS0EsSUFITCxDQUdVLEdBSFYsRUFHZVAsSUFIZjtBQUtBTCxPQUFHLENBQUNxQixTQUFKLENBQWMsUUFBZCxFQUNLbEwsSUFETCxDQUNVYSxPQURWLEVBRUtzSyxLQUZMLEdBR0tYLE1BSEwsQ0FHWSxRQUhaLEVBSUtDLElBSkwsQ0FJVSxJQUpWLEVBSWdCLFVBQVUxQyxDQUFWLEVBQWE7QUFDckIsYUFBT1osQ0FBQyxDQUFDWSxDQUFDLENBQUMzSSxJQUFILENBQVI7QUFDSCxLQU5MLEVBT0txTCxJQVBMLENBT1UsSUFQVixFQU9nQixVQUFVMUMsQ0FBVixFQUFhO0FBQ3JCLGFBQU9WLENBQUMsQ0FBQ1UsQ0FBQyxDQUFDaEosQ0FBSCxDQUFSO0FBQ0gsS0FUTCxFQVVLMEwsSUFWTCxDQVVVLEdBVlYsRUFVZSxDQVZmLEVBV0tBLElBWEwsQ0FXVSxPQVhWLEVBV21CLFdBWG5CO0FBYUEsUUFBSVcsS0FBSyxHQUFHdkIsR0FBRyxDQUFDVyxNQUFKLENBQVcsR0FBWCxFQUFnQnBFLEtBQWhCLENBQXNCLFNBQXRCLEVBQWlDLE1BQWpDLENBQVo7QUFFQWdGLFNBQUssQ0FBQ1osTUFBTixDQUFhLE1BQWIsRUFDS0MsSUFETCxDQUNVLElBRFYsRUFDZ0IsWUFEaEIsRUFFS0EsSUFGTCxDQUVVLE9BRlYsRUFFbUIsY0FGbkI7QUFHQVcsU0FBSyxDQUFDWixNQUFOLENBQWEsTUFBYixFQUNLQyxJQURMLENBQ1UsSUFEVixFQUNnQixZQURoQixFQUVLQSxJQUZMLENBRVUsT0FGVixFQUVtQixjQUZuQjtBQUdBVyxTQUFLLENBQUNaLE1BQU4sQ0FBYSxRQUFiLEVBQ0tDLElBREwsQ0FDVSxJQURWLEVBQ2dCLGFBRGhCLEVBRUtBLElBRkwsQ0FFVSxHQUZWLEVBRWUsQ0FGZixFQUdLQSxJQUhMLENBR1UsT0FIVixFQUdtQiwwQkFIbkI7QUFLQSxRQUFJekIsR0FBRyxHQUFHUSxFQUFFLENBQUNlLE1BQUgsQ0FBVW5NLFNBQVYsRUFBcUJvTSxNQUFyQixDQUE0QixLQUE1QixFQUNMQyxJQURLLENBQ0EsT0FEQSxFQUNTLFlBRFQsRUFFTHJFLEtBRkssQ0FFQyxTQUZELEVBRVksQ0FGWixDQUFWO0FBSUEsUUFBSWlGLFVBQVUsR0FBRzdCLEVBQUUsQ0FBQzhCLFFBQUgsQ0FBWSxVQUFVdkQsQ0FBVixFQUFhO0FBQ3RDLGFBQU9BLENBQUMsQ0FBQzNJLElBQVQ7QUFDSCxLQUZnQixFQUVkcUIsSUFGSDtBQUlBb0osT0FBRyxDQUFDVyxNQUFKLENBQVcsTUFBWCxFQUNLQyxJQURMLENBQ1UsT0FEVixFQUNtQixZQURuQixFQUVLQSxJQUZMLENBRVUsT0FGVixFQUVtQjVMLEtBRm5CLEVBR0s0TCxJQUhMLENBR1UsUUFIVixFQUdvQmxCLE1BSHBCLEVBSUtnQyxFQUpMLENBSVEsV0FKUixFQUlxQixZQUFZO0FBQ3pCSCxXQUFLLENBQUNoRixLQUFOLENBQVksU0FBWixFQUF1QixJQUF2Qjs7QUFDQW5HLGVBQVMsQ0FBQzJHLHFCQUFWLENBQWdDMUcsSUFBaEMsRUFBc0NXLE9BQU8sQ0FBQyxDQUFELENBQTdDO0FBQ0gsS0FQTCxFQVFLMEssRUFSTCxDQVFRLFVBUlIsRUFRb0IsWUFBWTtBQUN4QkgsV0FBSyxDQUFDaEYsS0FBTixDQUFZLFNBQVosRUFBdUIsTUFBdkI7O0FBQ0FuRyxlQUFTLENBQUM2RyxxQkFBVixDQUFnQzVHLElBQWhDLEVBRndCLENBSXhCOzs7QUFDQThJLFNBQUcsQ0FBQ3dDLFVBQUosR0FDS0MsUUFETCxDQUNjLEdBRGQsRUFFS3JGLEtBRkwsQ0FFVyxTQUZYLEVBRXNCLENBRnRCO0FBR0gsS0FoQkwsRUFpQkttRixFQWpCTCxDQWlCUSxXQWpCUixFQWlCcUIsWUFBWTtBQUN6QixVQUFJRyxDQUFDLEdBQUdsQyxFQUFFLENBQUNtQyxLQUFILENBQVMsSUFBVCxDQUFSO0FBQ0EsVUFBSW5LLFFBQVEsR0FBRzJGLENBQUMsQ0FBQ3lFLE1BQUYsQ0FBU0YsQ0FBQyxDQUFDLENBQUQsQ0FBVixDQUFmLENBRnlCLENBR3pCOztBQUNBLFVBQUkxSCxDQUFDLEdBQUc3QixJQUFJLENBQUNtQixHQUFMLENBQVMsQ0FBVCxFQUFZK0gsVUFBVSxDQUFDeEssT0FBRCxFQUFVVyxRQUFWLENBQXRCLENBQVI7QUFFQSxVQUFJcUcsRUFBRSxHQUFHaEgsT0FBTyxDQUFDbUQsQ0FBQyxHQUFHLENBQUwsQ0FBaEI7QUFDQSxVQUFJOEQsRUFBRSxHQUFHakgsT0FBTyxDQUFDbUQsQ0FBRCxDQUFoQjtBQUNBLFVBQUkrRCxDQUFDLEdBQUd2RyxRQUFRLEdBQUdxRyxFQUFFLENBQUMsQ0FBRCxDQUFiLEdBQW1CQyxFQUFFLENBQUMsQ0FBRCxDQUFGLEdBQVF0RyxRQUEzQixHQUFzQ3NHLEVBQXRDLEdBQTJDRCxFQUFuRDtBQUVBLFVBQUlnRSxFQUFFLEdBQUcxRSxDQUFDLENBQUNZLENBQUMsQ0FBQzNJLElBQUgsQ0FBVjtBQUNBLFVBQUkwTSxFQUFFLEdBQUd6RSxDQUFDLENBQUNVLENBQUMsQ0FBQ2hKLENBQUgsQ0FBVjtBQUVBcU0sV0FBSyxDQUFDYixNQUFOLENBQWEsY0FBYixFQUNLRSxJQURMLENBQ1UsSUFEVixFQUNnQm9CLEVBRGhCLEVBRUtwQixJQUZMLENBRVUsSUFGVixFQUVnQnFCLEVBRmhCO0FBR0FWLFdBQUssQ0FBQ2IsTUFBTixDQUFhLGFBQWIsRUFDS0UsSUFETCxDQUNVLElBRFYsRUFDZ0JvQixFQURoQixFQUNvQnBCLElBRHBCLENBQ3lCLElBRHpCLEVBQytCcEQsQ0FBQyxDQUFDd0QsT0FBTyxDQUFDLENBQUQsQ0FBUixDQURoQyxFQUVLSixJQUZMLENBRVUsSUFGVixFQUVnQm9CLEVBRmhCLEVBRW9CcEIsSUFGcEIsQ0FFeUIsSUFGekIsRUFFK0JwRCxDQUFDLENBQUN3RCxPQUFPLENBQUMsQ0FBRCxDQUFSLENBRmhDO0FBR0FPLFdBQUssQ0FBQ2IsTUFBTixDQUFhLGFBQWIsRUFDS0UsSUFETCxDQUNVLElBRFYsRUFDZ0J0RCxDQUFDLENBQUN1RCxPQUFPLENBQUMsQ0FBRCxDQUFSLENBRGpCLEVBQytCRCxJQUQvQixDQUNvQyxJQURwQyxFQUMwQ3FCLEVBRDFDLEVBRUtyQixJQUZMLENBRVUsSUFGVixFQUVnQnRELENBQUMsQ0FBQ3VELE9BQU8sQ0FBQyxDQUFELENBQVIsQ0FGakIsRUFFK0JELElBRi9CLENBRW9DLElBRnBDLEVBRTBDcUIsRUFGMUM7O0FBSUE3TCxlQUFTLENBQUNpSSxxQkFBVixDQUFnQ2hJLElBQWhDLEVBQXNDNkgsQ0FBdEMsRUF2QnlCLENBeUJ6Qjs7O0FBQ0FpQixTQUFHLENBQUN3QyxVQUFKLEdBQ0tDLFFBREwsQ0FDYyxHQURkLEVBRUtyRixLQUZMLENBRVcsU0FGWCxFQUVzQixHQUZ0QjtBQUlBLFVBQUkyRixRQUFRLEdBQUcsRUFBZjtBQUNBQSxjQUFRLElBQUksaUJBQWlCaEUsQ0FBQyxDQUFDaEosQ0FBbkIsR0FBdUIsSUFBbkM7O0FBQ0EsVUFBSTJCLHNCQUFzQixDQUFDNkYsWUFBM0IsRUFBeUM7QUFDckN3RixnQkFBUSxJQUFJLG1CQUFtQmhFLENBQUMsQ0FBQ00sS0FBckIsR0FBNkIsSUFBekM7QUFDSDs7QUFDRDBELGNBQVEsSUFBSSxrQkFBa0JoRSxDQUFDLENBQUNRLEdBQXBCLEdBQTBCLFVBQTFCLEdBQXVDUixDQUFDLENBQUNTLEdBQXpDLEdBQStDLEdBQTNEO0FBRUFRLFNBQUcsQ0FBQ2dELElBQUosQ0FBU0QsUUFBVCxFQUNLM0YsS0FETCxDQUNXLE1BRFgsRUFDb0JvRCxFQUFFLENBQUN5QyxLQUFILENBQVNDLEtBQVYsR0FBbUIsSUFEdEMsRUFFSzlGLEtBRkwsQ0FFVyxLQUZYLEVBRW1Cb0QsRUFBRSxDQUFDeUMsS0FBSCxDQUFTRSxLQUFULEdBQWlCLEVBQWxCLEdBQXdCLElBRjFDO0FBR0gsS0F6REwsRUE1S2lFLENBdU9qRTs7QUFDQSxXQUFPdEMsR0FBUDtBQUNILEdBOTdCeUI7O0FBZzhCMUI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSXVDLDJCQUF5QixFQUFHLG1DQUFVcE0sSUFBVixFQUFnQjVCLFNBQWhCLEVBQTJCSyxPQUEzQixFQUFvQ3dCLFNBQXBDLEVBQStDO0FBQ3ZFLFFBQUlDLElBQUksR0FBR3pCLE9BQVg7O0FBRUEsUUFBSSxDQUFDTCxTQUFMLEVBQWdCO0FBQ1o7QUFDSDs7QUFFRCxRQUFJLENBQUM0QixJQUFMLEVBQVc7QUFDUDtBQUNIOztBQUVELFFBQUlhLE9BQU8sR0FBR2IsSUFBSSxDQUFDYyxNQUFuQjtBQUVBLFFBQUl1TCxVQUFVLEdBQUcsZ0VBQWpCO0FBQ0EsUUFBSTlGLFlBQVksR0FBR3JHLElBQUksQ0FBQ1MsT0FBTCxDQUFhQyxxQkFBYixDQUFtQzJGLFlBQXREOztBQUNBLFFBQUlBLFlBQUosRUFBa0I7QUFDZDhGLGdCQUFVLElBQUksNkRBQWQ7QUFDSDs7QUFDREEsY0FBVSxJQUFJLGtFQUFkO0FBRUFDLFlBQVEsQ0FBQ0MsY0FBVCxDQUF3QixZQUFZLENBQUUsQ0FBdEM7O0FBRUEsUUFBSXZNLElBQUksQ0FBQ3dCLFFBQUwsR0FBZ0IsSUFBcEIsRUFBMEI7QUFDdEJ4QixVQUFJLENBQUNzSixJQUFMLEdBQVksSUFBWjs7QUFDQSxXQUFLLElBQUl0RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbkQsT0FBTyxDQUFDZixNQUE1QixFQUFvQ2tFLENBQUMsRUFBckMsRUFBeUM7QUFDckNuRCxlQUFPLENBQUNtRCxDQUFELENBQVAsQ0FBVzVFLElBQVgsSUFBbUIsSUFBbkI7QUFDSDtBQUNKOztBQUVELFNBQUssSUFBSTRFLEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUduRCxPQUFPLENBQUNmLE1BQTVCLEVBQW9Da0UsR0FBQyxFQUFyQyxFQUF5QztBQUNyQyxVQUFJNUUsSUFBSSxHQUFHeUIsT0FBTyxDQUFDbUQsR0FBRCxDQUFQLENBQVc1RSxJQUF0QjtBQUNBLFVBQUlvTixXQUFXLEdBQUcsR0FBbEI7O0FBQ0EsVUFBSXBOLElBQUksR0FBRyxHQUFYLEVBQWdCO0FBQ1pvTixtQkFBVyxHQUFHLENBQWQ7QUFDSCxPQUZELE1BRU8sSUFBSXBOLElBQUksR0FBRyxFQUFYLEVBQWU7QUFDbEJvTixtQkFBVyxHQUFHLEVBQWQ7QUFDSCxPQVBvQyxDQVNyQzs7O0FBQ0FwTixVQUFJLEdBQUcrQyxJQUFJLENBQUNDLEtBQUwsQ0FBV2hELElBQUksR0FBR29OLFdBQWxCLElBQWlDQSxXQUF4QztBQUNBM0wsYUFBTyxDQUFDbUQsR0FBRCxDQUFQLENBQVc1RSxJQUFYLEdBQWtCQSxJQUFsQjtBQUNIOztBQUVELFFBQUlxTixRQUFRLEdBQUc7QUFDWEMsVUFBSSxFQUFHLFFBREk7QUFFWEMsa0JBQVksRUFBRyx1Q0FGSjtBQUdYQyxtQkFBYSxFQUFHLE1BSEw7QUFJWEMsc0JBQWdCLEVBQUcsQ0FKUjtBQUtYQyxpQkFBVyxFQUFHLEVBTEg7QUFNWEMsZUFBUyxFQUFHLEVBTkQ7QUFPWEMsbUJBQWEsRUFBRyxDQVBMO0FBUVhDLFdBQUssRUFBRyxTQVJHO0FBU1hDLGNBQVEsRUFBRyxDQVRBO0FBVVhDLFdBQUssRUFBRyxPQVZHO0FBV1hDLHdCQUFrQixFQUFHLEVBWFY7QUFZWEMscUJBQWUsRUFBRztBQUNkQyxpQkFBUyxFQUFHLENBQUMsQ0FEQztBQUVkQyx3QkFBZ0IsRUFBRyxHQUZMO0FBR2RILDBCQUFrQixFQUFHO0FBSFAsT0FaUDtBQWlCWEksa0JBQVksRUFBRztBQUNYUCxhQUFLLEVBQUcsU0FERztBQUVYUSxvQkFBWSxFQUFHLE9BRko7QUFHWEMsd0JBQWdCLEVBQUcsRUFIUjtBQUlYQyxvQkFBWSxFQUFHLE9BSko7QUFLWEMsYUFBSyxFQUFHLGVBQWU1TixJQUFJLENBQUNzSixJQUFwQixHQUEyQixHQUx4QjtBQU1YdUUsa0JBQVUsRUFBRyxTQU5GO0FBT1hDLG1CQUFXLEVBQUcsQ0FQSDtBQVFYQyxtQkFBVyxFQUFHO0FBUkgsT0FqQko7QUEyQlhDLGlCQUFXLEVBQUc7QUFDVkMseUJBQWlCLEVBQUcsQ0FEVjtBQUVWQyxzQkFBYyxFQUFHLElBRlA7QUFHVkMsa0JBQVUsRUFBRyxFQUhIO0FBSVZDLDhCQUFzQixFQUFHLEtBSmY7QUFLVkMsbUJBQVcsRUFBRyxNQUxKO0FBTVZDLHdCQUFnQixFQUFHLENBTlQ7QUFPVkMsdUJBQWUsRUFBRyxDQVBSO0FBUVZDLGdCQUFRLEVBQUc7QUFSRCxPQTNCSDtBQXFDWEMsZ0JBQVUsRUFBRyxFQXJDRjtBQXNDWEMsWUFBTSxFQUFHLENBQUM7QUFDTkMsb0JBQVksRUFBRyxTQURUO0FBRU5DLG1CQUFXLEVBQUd2QyxVQUZSO0FBR053QyxjQUFNLEVBQUcsT0FISDtBQUlOQyxtQkFBVyxFQUFHLENBSlI7QUFLTkMseUJBQWlCLEVBQUcsTUFMZDtBQU1OQyw2QkFBcUIsRUFBRyxDQU5sQjtBQU9OQyxtQkFBVyxFQUFHLE1BUFI7QUFRTmQsa0JBQVUsRUFBRyxDQVJQO0FBU05lLGNBQU0sRUFBRyxLQVRIO0FBVU52TixVQUFFLEVBQUcsV0FWQztBQVdOd04sa0JBQVUsRUFBRyxHQVhQO0FBWU5DLGtCQUFVLEVBQUcsU0FaUDtBQWFOQyxpQkFBUyxFQUFHLENBYk47QUFjTkMsaUJBQVMsRUFBRyxTQWROO0FBZU5DLHFCQUFhLEVBQUcsQ0FmVjtBQWdCTjNCLGFBQUssRUFBRyxVQWhCRjtBQWlCTjRCLGtCQUFVLEVBQUc7QUFqQlAsT0FBRCxDQXRDRTtBQXlEWEMsWUFBTSxFQUFHLEVBekRFO0FBMERYQyxlQUFTLEVBQUcsQ0FBQztBQUNUL04sVUFBRSxFQUFHLGFBREk7QUFFVGdPLHNCQUFjLEVBQUcsRUFGUjtBQUdUL0IsYUFBSyxFQUFHO0FBSEMsT0FBRCxDQTFERDtBQStEWGdDLGFBQU8sRUFBRztBQUNOQyxtQkFBVyxFQUFHLFNBRFI7QUFFTkMsdUJBQWUsRUFBRyxDQUZaO0FBR05DLGlCQUFTLEVBQUcsU0FITjtBQUlOQyxrQkFBVSxFQUFHO0FBSlAsT0EvREM7QUFxRVhDLFlBQU0sRUFBRyxFQXJFRTtBQXNFWEMsZUFBUyxFQUFHLEVBdEVEO0FBdUVYQyxrQkFBWSxFQUFHdFA7QUF2RUosS0FBZjs7QUEwRUEsUUFBSXVQLGlCQUFpQixHQUFHOUQsUUFBUSxDQUFDK0QsU0FBVCxDQUFtQmpTLFNBQW5CLEVBQThCcU8sUUFBOUIsQ0FBeEI7O0FBRUEyRCxxQkFBaUIsQ0FBQ0UsV0FBbEIsQ0FBOEIsU0FBOUIsRUFBeUMsVUFBVXRKLENBQVYsRUFBYTtBQUNsRCxVQUFJdUosR0FBRyxHQUFHdkosQ0FBQyxDQUFDd0osS0FBRixDQUFRTCxZQUFSLENBQXFCbkosQ0FBQyxDQUFDeUosS0FBdkIsQ0FBVjs7QUFDQXhRLGVBQVMsQ0FBQ2lJLHFCQUFWLENBQWdDaEksSUFBaEMsRUFBc0NxUSxHQUF0QztBQUNILEtBSEQ7O0FBS0EsV0FBT0gsaUJBQVA7QUFDSDtBQXZrQ3lCLENBQTlCO0FBMGtDZXpTLHNGQUFmIiwiZmlsZSI6Ii4vc3JjL0NvbW1vbi9Db250cm9scy9Qcm9maWxlRWxldmF0aW9uUGF0aERPTS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQW1DaGFydHMsIGQzICovXG5cbi8qKlxuICogQG1vZHVsZSBQcm9maWxlRWxldmF0aW9uUGF0aERPTVxuICogQGFsaWFzIFtwcml2YXRlXSBQcm9maWxlRWxldmF0aW9uUGF0aERPTVxuICogQGRlc2NyaXB0aW9uXG4gKiBjcmVhdGUgRE9NIGVsZW1lbnRcbiAqL1xudmFyIFByb2ZpbGVFbGV2YXRpb25QYXRoRE9NID0ge1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNzcyBwcm9wZXJ0eSBmcm9tIGFuIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBnZXQgdGhlIHByb3BlcnR5IGZyb21cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIGNzcyBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ0NDQ1MS9ob3ctdG8tZ2V0LXRoZS1hY3R1YWwtcmVuZGVyZWQtZm9udC13aGVuLWl0cy1ub3QtZGVmaW5lZC1pbi1jc3NcbiAgICAgKi9cbiAgICBfZ2V0Q3NzUHJvcGVydHkgOiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGNhbnZhcy5tZWFzdXJlVGV4dCB0byBjb21wdXRlIGFuZCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBnaXZlbiB0ZXh0IG9mIGdpdmVuIGZvbnQgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBvZiB0aGUgdGV4dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250IFRoZSBmb250IG9mIHRoZSBjb250YWluZXIgaWYga25vd24sIGZvcm1hdDogJ3dlaWdodCBzaXplIGZhbWlsaXknXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSB0ZXh0XG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExODI0MS9jYWxjdWxhdGUtdGV4dC13aWR0aC13aXRoLWphdmFzY3JpcHQvMjEwMTUzOTMjMjEwMTUzOTNcbiAgICAgKi9cbiAgICBfZ2V0VGV4dFdpZHRoIDogZnVuY3Rpb24gKHRleHQsIGNvbnRhaW5lciwgZm9udCA9IG51bGwpIHtcbiAgICAgICAgLy8gcmUtdXNlIGNhbnZhcyBvYmplY3QgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgICB2YXIgY2FudmFzID0gLyoqIHRzLXN5bnRheCAqLyh0aGlzLmNhbnZhcykgfHwgKCh0aGlzLmNhbnZhcykgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBpZiAoZm9udCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC5mb250ID0gYCR7dGhpcy5fZ2V0Q3NzUHJvcGVydHkoY29udGFpbmVyLCBcImZvbnQtd2VpZ2h0XCIpfSAke3RoaXMuX2dldENzc1Byb3BlcnR5KGNvbnRhaW5lciwgXCJmb250LXNpemVcIil9ICR7dGhpcy5fZ2V0Q3NzUHJvcGVydHkoY29udGFpbmVyLCBcImZvbnQtZmFtaWx5XCIpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4gbWV0cmljcy53aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBkYXRhIHBvaW50IHogdG8gc3ZnIHkgY29vcmRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHogVGhlIHogdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGF0aEhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBwYXRoIGluIHRoZSBzdmcgY29udGFpbmVyIGluIHB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbkdyYXBoWiBNaW4geiBvZiB0aGUgZ3JhcGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHhQZXJNWiBOdW1iZXIgb2YgcGl4ZWxzIHBlciBtZXRlciBmb3IgdGhlIHogKHkpIGF4aXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgeSBzdmcgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgKlxuICAgICAqL1xuICAgIF9kYXRhWlRvU3ZnWSA6IGZ1bmN0aW9uICh6LCBwYXRoSGVpZ2h0LCBtaW5HcmFwaFosIHB4UGVyTVopIHtcbiAgICAgICAgcmV0dXJuIHBhdGhIZWlnaHQgLSAoeiAtIG1pbkdyYXBoWikgKiBweFBlck1aIC0gMC41O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRhdGEgcG9pbnQgZGlzdCB2YWx1ZSB0byBzdmcgeCBjb29yZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdCBUaGUgZGlzdCB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN2Z1dpZHRoIFRoZSB3aXRkdGggb2YgdGhlIHN2ZyBjb250YWluZXIgaW4gcHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGF0aFdpZHRoIFRoZSB3aXRkdGggb2YgdGhlIHBhdGggaW4gdGhlIHN2ZyBjb250YWluZXIgaW4gcHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHhQZXJNWCBOdW1iZXIgb2YgcGl4ZWxzIHBlciBtZXRlciBmb3IgdGhlIHggYXhpc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHggc3ZnIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgICpcbiAgICAgKi9cbiAgICBfZGF0YURpc3RUb1N2Z1ggOiBmdW5jdGlvbiAoZGlzdCwgc3ZnV2lkdGgsIHBhdGhXaWR0aCwgcHhQZXJNWCkge1xuICAgICAgICByZXR1cm4gKHN2Z1dpZHRoIC0gcGF0aFdpZHRoKSArIGRpc3QgKiBweFBlck1YO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN2ZyB4IGNvb3JkIHRvIGRpc3QgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN2Z1ggVGhlIGRpc3QgdG8gY29udmVydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdmdXaWR0aCBUaGUgd2l0ZHRoIG9mIHRoZSBzdmcgY29udGFpbmVyIGluIHB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhdGhXaWR0aCBUaGUgd2l0ZHRoIG9mIHRoZSBwYXRoIGluIHRoZSBzdmcgY29udGFpbmVyIGluIHB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHB4UGVyTVggTnVtYmVyIG9mIHBpeGVscyBwZXIgbWV0ZXIgZm9yIHRoZSB4IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBkaXN0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBfc3ZnWFRvRGF0YURpc3QgOiBmdW5jdGlvbiAoc3ZnWCwgc3ZnV2lkdGgsIHBhdGhXaWR0aCwgcHhQZXJNWCkge1xuICAgICAgICByZXR1cm4gKHN2Z1ggKyBwYXRoV2lkdGggLSBzdmdXaWR0aCkgLyBweFBlck1YO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB2YWx1ZSBpZiBpdCB3ZXJlIGluc2VydGVkIGluIHNvcnRlZCAoYnkgZGlzdCkgYXJyYXkgb2YgZGF0YSBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFNvcnRlZCBhcnJheSBvZiBkYXRhIHBvaW50cyAod2l0aCBkaXN0IHByb3BlcnR5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0IHRoZSBpbmRleCBvZi5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW5kZXggdGhlIHZhbHVlIHdvdWxkIGhhdmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBfYXJyYXlCaXNlY3QgOiBmdW5jdGlvbiAoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBpZHg7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgYXJyYXkubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgYXJyYXlbaWR4XS5kaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWR4IC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBQcm9maWxlIGZ1bmN0aW9uIHVzZWQgYnkgZGVmYXVsdCA6IG5vIGFkZGl0b25hbCBmcmFtZXdvcmsgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZWxldmF0aW9ucyB2YWx1ZXMgZm9yIHByb2ZpbGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBodG1sIGNvbnRhaW5lciB3aGVyZSB0byBkaXNwbGF5IHByb2ZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIHRoaXMgY29udHJvbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xhc3NOYW1lIC0gY2FsbGluZyBjbGFzcyAoaWUgRWxldmF0aW9uUGF0aClcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gcHJvZmlsIGNvbnRhaW5lclxuICAgICAqL1xuICAgIGRpc3BsYXlQcm9maWxlQnlEZWZhdWx0IDogZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lciwgY29udGV4dCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBzZWxmID0gY29udGV4dDtcblxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiBuZXR0b2llIHRvdWpvdXJzLi4uXG4gICAgICAgIHdoaWxlIChjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHtcbiAgICAgICAgICAgIHRvcCA6IDI1LFxuICAgICAgICAgICAgcmlnaHQgOiAxNSxcbiAgICAgICAgICAgIGJvdHRvbSA6IDEwLFxuICAgICAgICAgICAgbGVmdCA6IDEwXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9kaXNwbGF5UHJvZmlsZU9wdGlvbnMgPSBzZWxmLm9wdGlvbnMuZGlzcGxheVByb2ZpbGVPcHRpb25zO1xuICAgICAgICB2YXIgX3BvaW50cyA9IGRhdGEucG9pbnRzO1xuXG4gICAgICAgIHZhciBzb3J0ZWRFbGV2ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShfcG9pbnRzKSk7XG4gICAgICAgIHNvcnRlZEVsZXYuc29ydChmdW5jdGlvbiAoZTEsIGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gZTEueiAtIGUyLno7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtaW5aID0gc29ydGVkRWxldlswXS56O1xuICAgICAgICB2YXIgbWF4WiA9IHNvcnRlZEVsZXZbc29ydGVkRWxldi5sZW5ndGggLSAxXS56O1xuICAgICAgICB2YXIgZGlzdCA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIGxldCBkaXN0VW5pdCA9IFwibVwiO1xuXG4gICAgICAgIGNvbnN0IHdpZGdldERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHdpZGdldERpdi5pZCA9IFwicHJvZmlsZUVsZXZhdGlvbkJ5RGVmYXVsdFwiO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQod2lkZ2V0RGl2KTtcblxuICAgICAgICAvLyBEw6l0ZXJtaW5hdGlvbiBkZXMgdGFpbGxlcyBlbiBwaXhlbHMgZGVzIMOpbMOpbWVudHMgZHUgd2lkZ2V0XG4gICAgICAgIGNvbnN0IHdpZGdldEhlaWd0aCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgY29uc3Qgd2lkZ2V0V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcblxuICAgICAgICBjb25zdCB6TGFiZWxXaWR0aCA9IDE3O1xuICAgICAgICBjb25zdCB6R3JhZFdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKE1hdGgucm91bmQobWF4WikudG9Mb2NhbGVTdHJpbmcoKSArIFwiLDg4XCIsIGNvbnRhaW5lciwgXCI0MDAgMTAgVmVyZGFuYVwiKTtcbiAgICAgICAgY29uc3QgeExhYmVsSGVpZ2h0ID0gMTc7XG4gICAgICAgIGNvbnN0IHhHcmFkSGVpZ2h0ID0gMTU7XG5cbiAgICAgICAgY29uc3QgbWluWmd1aWRlSGVpZ3RoID0gMTU7XG4gICAgICAgIGNvbnN0IG1pblhndWlkZVdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKE1hdGgucm91bmQoZGlzdCkudG9Mb2NhbGVTdHJpbmcoKSArIFwiLDVcIiwgY29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgbWluTnVtWEd1aWRlcyA9IDE7XG5cbiAgICAgICAgY29uc3QgcGF0aEhlaWdodCA9IHdpZGdldEhlaWd0aCAtIHhMYWJlbEhlaWdodCAtIHhHcmFkSGVpZ2h0O1xuICAgICAgICBjb25zdCBwYXRoV2lkdGggPSB3aWRnZXRXaWR0aCAtIHpMYWJlbFdpZHRoIC0gekdyYWRXaWR0aDtcblxuICAgICAgICBjb25zdCBlbGV2YXRpb25TdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICAgICAgZWxldmF0aW9uU3ZnLmlkID0gXCJwcm9maWxlRWxldmF0aW9uQnlEZWZhdWx0U3ZnXCI7XG4gICAgICAgIGVsZXZhdGlvblN2Zy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6IGJsb2NrOyBtYXJnaW46IGF1dG87IG92ZXJmbG93OiB2aXNpYmxlOyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDEwcHg7XCIpO1xuICAgICAgICBlbGV2YXRpb25Tdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7Y29udGFpbmVyLmNsaWVudFdpZHRofSAke2NvbnRhaW5lci5jbGllbnRIZWlnaHR9YCk7XG4gICAgICAgIGVsZXZhdGlvblN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XG4gICAgICAgIGVsZXZhdGlvblN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuXG4gICAgICAgIC8vIETDqXRlcm1pbmF0aW9uIGRlcyBndWlkZXMgZW4gb3Jkb25uw6llIDpcbiAgICAgICAgY29uc3QgbWF4TnVtWmd1aWRlcyA9IE1hdGguZmxvb3IocGF0aEhlaWdodCAvIG1pblpndWlkZUhlaWd0aCk7XG4gICAgICAgIGxldCBncmFkWjtcbiAgICAgICAgLy8gVHJhaXRlbWVudCBkdSBjYXMgYWx0aXR1ZGUgbWF4ID0gYWx0aXR1ZGUgbWluXG4gICAgICAgIGlmIChtYXhaID09PSBtaW5aKSB7XG4gICAgICAgICAgICBncmFkWiA9IDAuMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyYWRaID0gTWF0aC5wb3coMTAsIChNYXRoLmNlaWwoTWF0aC5sb2coKG1heFogLSBtaW5aKSAvIG1heE51bVpndWlkZXMpIC8gTWF0aC5sb2coMTApKSkpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWluR3JhcGhaID0gTWF0aC5mbG9vcihtaW5aIC8gZ3JhZFopICogZ3JhZFo7XG4gICAgICAgIGxldCBtYXhHcmFwaFogPSBNYXRoLmNlaWwobWF4WiAvIGdyYWRaKSAqIGdyYWRaO1xuICAgICAgICAvLyBjYXMgb8O5IGxlIHBhdGggYXR0ZWludCBwaWxlIGxlcyBncmFkdWF0aW9ucyBleHRyZW1lcyA6IGFqb3V0IGQndW5lIGdyYWRpYXRpb25cbiAgICAgICAgaWYgKG1heEdyYXBoWiA9PT0gbWF4Wikge1xuICAgICAgICAgICAgbWF4R3JhcGhaICs9IGdyYWRaO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhcyBvw7kgZ3JhZFogPCAxIDogbm9tYnJlcyBmbG90dGFudHMgY2FwcmljaWV1eC4uLlxuICAgICAgICBtaW5HcmFwaFogPSBNYXRoLnJvdW5kKG1pbkdyYXBoWiAqIDEwMCkgLyAxMDA7XG4gICAgICAgIG1heEdyYXBoWiA9IE1hdGgucm91bmQobWF4R3JhcGhaICogMTAwKSAvIDEwMDtcblxuICAgICAgICBsZXQgbnVtWmd1aWRlcyA9IE1hdGgucm91bmQoKG1heEdyYXBoWiAtIG1pbkdyYXBoWikgLyBncmFkWik7XG5cbiAgICAgICAgLy8gU2kgcGx1cyBkZSBndWlkZXMgcXVlIGxlIG1heCwgb24gcGFzc2Ugw6AgdW5lIGdyYWR1YXRpb24gZGUgMTAqKnggZW4gMTAqKnggKGV0IG5vbiAxMCoqeCAvIDIpXG4gICAgICAgIGlmIChudW1aZ3VpZGVzICsgMSA+IG1heE51bVpndWlkZXMpIHtcbiAgICAgICAgICAgIGdyYWRaID0gTWF0aC5wb3coMTAsIChNYXRoLmNlaWwoTWF0aC5sb2coKG1heFogLSBtaW5aKSAvIG1heE51bVpndWlkZXMpIC8gTWF0aC5sb2coMTApKSkpO1xuICAgICAgICAgICAgbWluR3JhcGhaID0gTWF0aC5mbG9vcihtaW5aIC8gZ3JhZFopICogZ3JhZFo7XG4gICAgICAgICAgICBtYXhHcmFwaFogPSBNYXRoLmNlaWwobWF4WiAvIGdyYWRaKSAqIGdyYWRaO1xuICAgICAgICAgICAgLy8gY2FzIG/DuSBsZSBwYXRoIGF0dGVpbnQgcGlsZSBsZXMgZ3JhZHVhdGlvbnMgZXh0cmVtZXMgOiBham91dCBkJ3VuZSBncmFkaWF0aW9uXG4gICAgICAgICAgICBpZiAobWF4R3JhcGhaID09PSBtYXhaKSB7XG4gICAgICAgICAgICAgICAgbWF4R3JhcGhaICs9IGdyYWRaO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FzIG/DuSBncmFkWiA8IDEgOiBub21icmVzIGZsb3R0YW50cyBjYXByaWNpZXV4Li4uXG4gICAgICAgICAgICBtaW5HcmFwaFogPSBNYXRoLnJvdW5kKG1pbkdyYXBoWiAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICBtYXhHcmFwaFogPSBNYXRoLnJvdW5kKG1heEdyYXBoWiAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICBudW1aZ3VpZGVzID0gTWF0aC5mbG9vcigobWF4R3JhcGhaIC0gbWluR3JhcGhaKSAvIGdyYWRaKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG51bVpndWlkZXMgPSBNYXRoLm1heChNYXRoLnJvdW5kKG51bVpndWlkZXMpLCAxKTtcblxuICAgICAgICBjb25zdCBheGlzWiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgYXhpc1ouc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJwcm9maWxlLXotdmVydGljYWxcIik7XG5cbiAgICAgICAgY29uc3QgZ3VpZGVzWiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcblxuICAgICAgICBjb25zdCBncmFkWnlPZmZzZXRQeCA9IHBhdGhIZWlnaHQgLyBudW1aZ3VpZGVzO1xuICAgICAgICBsZXQgcHhQZXJNWiA9IHBhdGhIZWlnaHQgLyAobWF4R3JhcGhaIC0gbWluR3JhcGhaKTtcbiAgICAgICAgLy8gVHJhaXRlbWVudCBkdSBjYXMgYWx0aXR1ZGUgbWF4ID0gYWx0aXR1ZGUgbWluXG4gICAgICAgIGlmIChtYXhaID09PSBtaW5aKSB7XG4gICAgICAgICAgICBweFBlck1aID0gcGF0aEhlaWdodCAvIDAuMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB4UGVyTVogPSBwYXRoSGVpZ2h0IC8gKG1heEdyYXBoWiAtIG1pbkdyYXBoWik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZ3JhZFp0ZXh0O1xuICAgICAgICBsZXQgeVRleHRUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHlTdHJva2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IGdyYWRac3Ryb2tlO1xuICAgICAgICBsZXQgZ3JhZFpwYXRoO1xuICAgICAgICBsZXQgZ3JhZFpncmFkO1xuICAgICAgICAvLyBBam91dCBkZXMgZ3JhZHVhdGlvbnMgYXUgZ3JhcGhpcXVlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bVpndWlkZXM7IGkrKykge1xuICAgICAgICAgICAgZ3JhZFp0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgZ3JhZFp0ZXh0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwicHJvZmlsZS16LWdyYWR1YXRpb25cIik7XG4gICAgICAgICAgICBncmFkWnRleHQuc2V0QXR0cmlidXRlKFwiZm9udC1mYW1pbHlcIiwgXCJWZXJkYW5hXCIpO1xuICAgICAgICAgICAgZ3JhZFp0ZXh0LnNldEF0dHJpYnV0ZShcImZvbnQtc2l6ZVwiLCBcIjEwcHhcIik7XG4gICAgICAgICAgICBncmFkWnRleHQuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIiM1RTVFNUVcIik7XG4gICAgICAgICAgICAvLyBDYXMgb8O5IGdyYWRaIDwgMSA6IG5vbWJyZXMgZmxvdHRhbnRzIGNhcHJpY2lldXguLi5cbiAgICAgICAgICAgIC8vIExlIE1hdGgucm91bmQgZXN0IHBvdXIgw6l2aXRlciBkZXMgZW5udWlzIGR1IGdlbnJlIDMgKiAwLjEgPSAwLjMwMDAwMDAwMDAwMDAwNFxuICAgICAgICAgICAgZ3JhZFp0ZXh0LnRleHRDb250ZW50ID0gKE1hdGgucm91bmQoMTAwICogKG1pbkdyYXBoWiArIGkgKiBncmFkWikpIC8gMTAwKS50b0xvY2FsZVN0cmluZygpO1xuXG4gICAgICAgICAgICB5VGV4dFRyYW5zbGF0aW9uID0gcGF0aEhlaWdodCAtIGkgKiBncmFkWnlPZmZzZXRQeDtcblxuICAgICAgICAgICAgZ3JhZFp0ZXh0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7ekxhYmVsV2lkdGggKyB6R3JhZFdpZHRoIC0gOH0sICR7eVRleHRUcmFuc2xhdGlvbiArIDV9KWApO1xuICAgICAgICAgICAgZ3JhZFp0ZXh0LnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpO1xuICAgICAgICAgICAgYXhpc1ouYXBwZW5kQ2hpbGQoZ3JhZFp0ZXh0KTtcblxuICAgICAgICAgICAgeVN0cm9rZVRyYW5zbGF0aW9uID0gTWF0aC5yb3VuZCh5VGV4dFRyYW5zbGF0aW9uKSAtIDAuNTtcblxuICAgICAgICAgICAgZ3JhZFpzdHJva2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgICBncmFkWnBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgICAgICAgICBncmFkWnBhdGguc2V0QXR0cmlidXRlKFwiY3NcIiwgXCIxMDAsMTAwXCIpO1xuICAgICAgICAgICAgZ3JhZFpwYXRoLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjFcIik7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGdyYWRacGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBcIjAuMlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JhZFpwYXRoLnNldEF0dHJpYnV0ZShcInN0cm9rZS1vcGFjaXR5XCIsIFwiMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYWRacGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCIjMDAwMDAwXCIpO1xuICAgICAgICAgICAgZ3JhZFpwYXRoLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICAgICAgZ3JhZFpwYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgYE0ke3pMYWJlbFdpZHRoICsgekdyYWRXaWR0aH0sJHt5U3Ryb2tlVHJhbnNsYXRpb259IEwke3BhdGhXaWR0aCArIHpMYWJlbFdpZHRoICsgekdyYWRXaWR0aH0sJHt5U3Ryb2tlVHJhbnNsYXRpb259YCk7XG5cbiAgICAgICAgICAgIGdyYWRaZ3JhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICAgICAgICAgIGdyYWRaZ3JhZC5zZXRBdHRyaWJ1dGUoXCJjc1wiLCBcIjEwMCwxMDBcIik7XG4gICAgICAgICAgICBncmFkWmdyYWQuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMVwiKTtcbiAgICAgICAgICAgIGdyYWRaZ3JhZC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBcIjFcIik7XG4gICAgICAgICAgICBncmFkWmdyYWQuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwiIzAwMDAwMFwiKTtcbiAgICAgICAgICAgIGdyYWRaZ3JhZC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIGdyYWRaZ3JhZC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGBNJHt6TGFiZWxXaWR0aCArIHpHcmFkV2lkdGh9LCR7eVN0cm9rZVRyYW5zbGF0aW9ufSBMJHt6TGFiZWxXaWR0aCArIHpHcmFkV2lkdGggKyA1fSwke3lTdHJva2VUcmFuc2xhdGlvbn1gKTtcbiAgICAgICAgICAgIGdyYWRaZ3JhZC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoLTUsIDApXCIpO1xuXG4gICAgICAgICAgICBncmFkWnN0cm9rZS5hcHBlbmRDaGlsZChncmFkWmdyYWQpO1xuICAgICAgICAgICAgZ3JhZFpzdHJva2UuYXBwZW5kQ2hpbGQoZ3JhZFpwYXRoKTtcbiAgICAgICAgICAgIGd1aWRlc1ouYXBwZW5kQ2hpbGQoZ3JhZFpzdHJva2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF4aXNaTGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0ZXh0XCIpO1xuICAgICAgICBheGlzWkxlZ2VuZC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInByb2ZpbGUtei1sZWdlbmRcIik7XG4gICAgICAgIGF4aXNaTGVnZW5kLnNldEF0dHJpYnV0ZShcImZvbnQtZmFtaWx5XCIsIFwiVmVyZGFuYVwiKTtcbiAgICAgICAgYXhpc1pMZWdlbmQuc2V0QXR0cmlidXRlKFwiZm9udC1zaXplXCIsIFwiMTFweFwiKTtcbiAgICAgICAgYXhpc1pMZWdlbmQuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIiM1RTVFNUVcIik7XG4gICAgICAgIGF4aXNaTGVnZW5kLnRleHRDb250ZW50ID0gXCJBbHRpdHVkZSAobSlcIjtcblxuICAgICAgICBheGlzWkxlZ2VuZC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3pMYWJlbFdpZHRoIC0gOH0sICR7TWF0aC5yb3VuZChwYXRoSGVpZ2h0IC8gMil9KSByb3RhdGUoLTkwKWApO1xuICAgICAgICBheGlzWkxlZ2VuZC5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcblxuICAgICAgICBheGlzWi5hcHBlbmRDaGlsZChheGlzWkxlZ2VuZCk7XG4gICAgICAgIGVsZXZhdGlvblN2Zy5hcHBlbmRDaGlsZChheGlzWik7XG4gICAgICAgIGVsZXZhdGlvblN2Zy5hcHBlbmRDaGlsZChndWlkZXNaKTtcblxuICAgICAgICAvLyBEw6l0ZXJtaW5hdGlvbiBkZXMgZ3VpZGVzIGVuIGFic2Npc3NlIDpcbiAgICAgICAgLy8gUGFzc2FnZSDDqXZlbnR1ZWwgZW4ga21cbiAgICAgICAgaWYgKGRpc3QgPiAyMDAwKSB7XG4gICAgICAgICAgICBkaXN0IC89IDEwMDA7XG4gICAgICAgICAgICBkaXN0VW5pdCA9IFwia21cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heE51bVhndWlkZXMgPSBNYXRoLmZsb29yKHBhdGhXaWR0aCAvIG1pblhndWlkZVdpZHRoKTtcbiAgICAgICAgbGV0IGdyYWRYID0gTWF0aC5wb3coMTAsIChNYXRoLmNlaWwoTWF0aC5sb2coKGRpc3QpIC8gbWF4TnVtWGd1aWRlcykgLyBNYXRoLmxvZygxMCkpKSkgLyAyO1xuICAgICAgICBjb25zdCBtYXhHcmFwaFggPSBkaXN0O1xuXG4gICAgICAgIC8vIFNpIHBsdXMgZGUgZ3VpZGVzIHF1ZSBsZSBtYXgsIG9uIHBhc3NlIMOgIHVuZSBncmFkdWF0aW9uIGRlIDEwKip4IGVuIDEwKip4IChldCBub24gMTAqKnggLyAyKVxuICAgICAgICBsZXQgbnVtWGd1aWRlcyA9IE1hdGguZmxvb3IobWF4R3JhcGhYIC8gZ3JhZFgpO1xuICAgICAgICBpZiAobnVtWGd1aWRlcyA+IG1heE51bVhndWlkZXMpIHtcbiAgICAgICAgICAgIGdyYWRYID0gTWF0aC5wb3coMTAsIChNYXRoLmNlaWwoTWF0aC5sb2coKGRpc3QpIC8gbWF4TnVtWGd1aWRlcykgLyBNYXRoLmxvZygxMCkpKSk7XG4gICAgICAgICAgICBudW1YZ3VpZGVzID0gTWF0aC5mbG9vcihtYXhHcmFwaFggLyBncmFkWCk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtWGd1aWRlcyA8IG1pbk51bVhHdWlkZXMpIHtcbiAgICAgICAgICAgIGdyYWRYID0gTWF0aC5wb3coMTAsIChNYXRoLmNlaWwoTWF0aC5sb2coKGRpc3QpIC8gbWF4TnVtWGd1aWRlcykgLyBNYXRoLmxvZygxMCkpKSAtIDEpO1xuICAgICAgICAgICAgbnVtWGd1aWRlcyA9IE1hdGguZmxvb3IobWF4R3JhcGhYIC8gZ3JhZFgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtWGd1aWRlcyA9IE1hdGgubWF4KG51bVhndWlkZXMsIDEpO1xuICAgICAgICBjb25zdCBsYXN0R3JhZFggPSBncmFkWCAqIG51bVhndWlkZXM7XG5cbiAgICAgICAgY29uc3QgYXhpc1ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgIGF4aXNYLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwicHJvZmlsZS14LXZlcnRpY2FsXCIpO1xuXG4gICAgICAgIGNvbnN0IGd1aWRlc1ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG5cbiAgICAgICAgLy8gRMOpY2FsYWdlIGRlcyBncmFkdWF0aW9ucyBwb3VyIHF1ZSBsYSBkZXJuacOocmUgY29ycmVzcG9uZGUgw6AgbGEgZGlzdGFuY2UgbWF4XG4gICAgICAgIGNvbnN0IHB4UGVyTVggPSBwYXRoV2lkdGggLyBtYXhHcmFwaFg7XG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSAobWF4R3JhcGhYIC0gbGFzdEdyYWRYKSAqIHB4UGVyTVg7XG4gICAgICAgIGNvbnN0IGdyYWRYeE9mZnNldFB4ID0gTWF0aC5yb3VuZCgocGF0aFdpZHRoIC0geE9mZnNldCkgLyBudW1YZ3VpZGVzKTtcblxuICAgICAgICBsZXQgZ3JhZFh0ZXh0O1xuICAgICAgICBsZXQgeFRleHRUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHhTdHJva2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IGdyYWRYc3Ryb2tlO1xuICAgICAgICBsZXQgZ3JhZFhwYXRoO1xuICAgICAgICBsZXQgZ3JhZFhncmFkO1xuICAgICAgICAvLyBBam91dCBkZXMgZ3JhZHVhdGlvbnMgYXUgZ3JhcGhpcXVlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bVhndWlkZXMgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGdyYWRYdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwidGV4dFwiKTtcbiAgICAgICAgICAgIGdyYWRYdGV4dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInByb2ZpbGUteC1ncmFkdWF0aW9uXCIpO1xuICAgICAgICAgICAgZ3JhZFh0ZXh0LnNldEF0dHJpYnV0ZShcImZvbnQtZmFtaWx5XCIsIFwiVmVyZGFuYVwiKTtcbiAgICAgICAgICAgIGdyYWRYdGV4dC5zZXRBdHRyaWJ1dGUoXCJmb250LXNpemVcIiwgXCIxMHB4XCIpO1xuICAgICAgICAgICAgZ3JhZFh0ZXh0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCIjNUU1RTVFXCIpO1xuXG4gICAgICAgICAgICAvLyBFeGNsdXNpb24gZHUgY2FzIGRlIGxhIGRlcm5pw6hyZSBncmFkdWF0aW9uIDogY29ycmVzcG9uZCDDoCBsYSBkaXN0YW5jZSBtYXggOiBwYXMgZGUgdGV4dGVcbiAgICAgICAgICAgIGlmIChpICE9PSBudW1YZ3VpZGVzICsgMSkge1xuICAgICAgICAgICAgICAgIC8vIENhcyBvw7kgZ3JhZFggPCAxIDogbm9tYnJlcyBmbG90dGFudHMgY2FwcmljaWV1eC4uLlxuICAgICAgICAgICAgICAgIGdyYWRYdGV4dC50ZXh0Q29udGVudCA9IChNYXRoLnJvdW5kKDEwMCAqIGkgKiBncmFkWCkgLyAxMDApLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhUZXh0VHJhbnNsYXRpb24gPSB6TGFiZWxXaWR0aCArIHpHcmFkV2lkdGggKyBpICogZ3JhZFh4T2Zmc2V0UHg7XG4gICAgICAgICAgICAvLyBDYXMgZGUgbGEgZGVybmnDqHJlIGdyYWR1YXRpb24gOiBjb3JyZXNwb25kIMOgIGxhIGRpc3RhbmNlIG1heFxuICAgICAgICAgICAgaWYgKGkgPT09IG51bVhndWlkZXMgKyAxKSB7XG4gICAgICAgICAgICAgICAgeFRleHRUcmFuc2xhdGlvbiA9IHpMYWJlbFdpZHRoICsgekdyYWRXaWR0aCArIHBhdGhXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JhZFh0ZXh0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eFRleHRUcmFuc2xhdGlvbn0sICR7cGF0aEhlaWdodCArIHhHcmFkSGVpZ2h0ICsgNX0pYCk7XG4gICAgICAgICAgICBncmFkWHRleHQuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICAgICAgICBheGlzWC5hcHBlbmRDaGlsZChncmFkWHRleHQpO1xuXG4gICAgICAgICAgICB4U3Ryb2tlVHJhbnNsYXRpb24gPSB4VGV4dFRyYW5zbGF0aW9uIC0gMC41O1xuXG4gICAgICAgICAgICBncmFkWHN0cm9rZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgICAgIGdyYWRYcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICAgICAgICAgIGdyYWRYcGF0aC5zZXRBdHRyaWJ1dGUoXCJjc1wiLCBcIjEwMCwxMDBcIik7XG4gICAgICAgICAgICBncmFkWHBhdGguc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMVwiKTtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZ3JhZFhwYXRoLnNldEF0dHJpYnV0ZShcInN0cm9rZS1vcGFjaXR5XCIsIFwiMC4yXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmFkWHBhdGguc2V0QXR0cmlidXRlKFwic3Ryb2tlLW9wYWNpdHlcIiwgXCIxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhZFhwYXRoLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIiMwMDAwMDBcIik7XG4gICAgICAgICAgICBncmFkWHBhdGguc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICBncmFkWHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBgTSR7eFN0cm9rZVRyYW5zbGF0aW9ufSwke3BhdGhIZWlnaHR9IEwke3hTdHJva2VUcmFuc2xhdGlvbn0sMGApO1xuXG4gICAgICAgICAgICBncmFkWGdyYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgICAgICAgICBncmFkWGdyYWQuc2V0QXR0cmlidXRlKFwiY3NcIiwgXCIxMDAsMTAwXCIpO1xuICAgICAgICAgICAgZ3JhZFhncmFkLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjFcIik7XG4gICAgICAgICAgICBncmFkWGdyYWQuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW9wYWNpdHlcIiwgXCIxXCIpO1xuICAgICAgICAgICAgZ3JhZFhncmFkLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIiMwMDAwMDBcIik7XG4gICAgICAgICAgICBncmFkWGdyYWQuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICBncmFkWGdyYWQuc2V0QXR0cmlidXRlKFwiZFwiLCBgTSR7eFN0cm9rZVRyYW5zbGF0aW9ufSwke3BhdGhIZWlnaHR9IEwke3hTdHJva2VUcmFuc2xhdGlvbn0sJHtwYXRoSGVpZ2h0IC0gNX1gKTtcbiAgICAgICAgICAgIGdyYWRYZ3JhZC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwgNSlcIik7XG5cbiAgICAgICAgICAgIGdyYWRYc3Ryb2tlLmFwcGVuZENoaWxkKGdyYWRYZ3JhZCk7XG4gICAgICAgICAgICBncmFkWHN0cm9rZS5hcHBlbmRDaGlsZChncmFkWHBhdGgpO1xuICAgICAgICAgICAgZ3VpZGVzWC5hcHBlbmRDaGlsZChncmFkWHN0cm9rZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXhpc1hMZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInRleHRcIik7XG4gICAgICAgIGF4aXNYTGVnZW5kLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwicHJvZmlsZS14LWxlZ2VuZFwiKTtcbiAgICAgICAgYXhpc1hMZWdlbmQuc2V0QXR0cmlidXRlKFwiZm9udC1mYW1pbHlcIiwgXCJWZXJkYW5hXCIpO1xuICAgICAgICBheGlzWExlZ2VuZC5zZXRBdHRyaWJ1dGUoXCJmb250LXNpemVcIiwgXCIxMXB4XCIpO1xuICAgICAgICBheGlzWExlZ2VuZC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiIzVFNUU1RVwiKTtcbiAgICAgICAgYXhpc1hMZWdlbmQudGV4dENvbnRlbnQgPSBgRGlzdGFuY2UgKCR7ZGlzdFVuaXR9KWA7XG5cbiAgICAgICAgYXhpc1hMZWdlbmQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt6TGFiZWxXaWR0aCArIHpHcmFkV2lkdGggKyBwYXRoV2lkdGggLyAyfSwgJHtwYXRoSGVpZ2h0ICsgeEdyYWRIZWlnaHQgKyB4TGFiZWxIZWlnaHQgKyAzfSlgKTtcbiAgICAgICAgYXhpc1hMZWdlbmQuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG5cbiAgICAgICAgYXhpc1guYXBwZW5kQ2hpbGQoYXhpc1hMZWdlbmQpO1xuICAgICAgICBlbGV2YXRpb25TdmcuYXBwZW5kQ2hpbGQoYXhpc1gpO1xuICAgICAgICBlbGV2YXRpb25TdmcuYXBwZW5kQ2hpbGQoZ3VpZGVzWCk7XG5cbiAgICAgICAgY29uc3QgZWxldmF0aW9uUGF0aEcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG5cbiAgICAgICAgbGV0IGZhY3RvciA9IDE7XG4gICAgICAgIGlmIChkaXN0VW5pdCA9PT0gXCJrbVwiKSB7XG4gICAgICAgICAgICBmYWN0b3IgPSAxMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBvaW50WCA9IHRoaXMuX2RhdGFEaXN0VG9TdmdYKF9wb2ludHNbMF0uZGlzdCAvIGZhY3Rvciwgd2lkZ2V0V2lkdGgsIHBhdGhXaWR0aCwgcHhQZXJNWCk7XG4gICAgICAgIGxldCBwb2ludFkgPSB0aGlzLl9kYXRhWlRvU3ZnWShfcG9pbnRzWzBdLnosIHBhdGhIZWlnaHQsIG1pbkdyYXBoWiwgcHhQZXJNWik7XG4gICAgICAgIGxldCBwYXRoRCA9IGBNJHtwb2ludFh9LCR7cG9pbnRZfWA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBfcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludFggPSB0aGlzLl9kYXRhRGlzdFRvU3ZnWChfcG9pbnRzW2ldLmRpc3QgLyBmYWN0b3IsIHdpZGdldFdpZHRoLCBwYXRoV2lkdGgsIHB4UGVyTVgpO1xuICAgICAgICAgICAgcG9pbnRZID0gdGhpcy5fZGF0YVpUb1N2Z1koX3BvaW50c1tpXS56LCBwYXRoSGVpZ2h0LCBtaW5HcmFwaFosIHB4UGVyTVopO1xuICAgICAgICAgICAgcGF0aEQgKz0gYCBMJHtwb2ludFh9LCR7cG9pbnRZfWA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXRoUGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICAgICAgcGF0aFBhdGguc2V0QXR0cmlidXRlKFwiY3NcIiwgXCIxMDAsMTAwXCIpO1xuICAgICAgICBwYXRoUGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxXCIpO1xuICAgICAgICBwYXRoUGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBcIjFcIik7XG4gICAgICAgIHBhdGhQYXRoLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIiMwQjZCQTdcIik7XG4gICAgICAgIHBhdGhQYXRoLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICBwYXRoUGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHBhdGhEKTtcblxuICAgICAgICAvLyBGZXJtZXR1cmUgZHUgcGF0aCBwb3VyIGxlIGZpbGxcbiAgICAgICAgcGF0aEQgKz0gYCBMJHtwb2ludFh9LCR7cGF0aEhlaWdodH1gO1xuICAgICAgICBwYXRoRCArPSBgIEwke3dpZGdldFdpZHRoIC0gcGF0aFdpZHRofSwke3BhdGhIZWlnaHR9YDtcblxuICAgICAgICBjb25zdCBwYXRoRmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICAgICAgcGF0aEZpbGwuc2V0QXR0cmlidXRlKFwiY3NcIiwgXCIxMDAsMTAwXCIpO1xuICAgICAgICBwYXRoRmlsbC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxXCIpO1xuICAgICAgICBwYXRoRmlsbC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBcIjBcIik7XG4gICAgICAgIHBhdGhGaWxsLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIiMwMDAwMDBcIik7XG4gICAgICAgIHBhdGhGaWxsLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCIjMDBCNzk4XCIpO1xuICAgICAgICBwYXRoRmlsbC5zZXRBdHRyaWJ1dGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwLjRcIik7XG4gICAgICAgIHBhdGhGaWxsLnNldEF0dHJpYnV0ZShcImRcIiwgcGF0aEQpO1xuXG4gICAgICAgIGVsZXZhdGlvblBhdGhHLmFwcGVuZENoaWxkKHBhdGhQYXRoKTtcbiAgICAgICAgZWxldmF0aW9uUGF0aEcuYXBwZW5kQ2hpbGQocGF0aEZpbGwpO1xuICAgICAgICBlbGV2YXRpb25TdmcuYXBwZW5kQ2hpbGQoZWxldmF0aW9uUGF0aEcpO1xuXG4gICAgICAgIC8vIE1pc2UgZW4gcGxhY2UgZGUgbCfDqWNvdXRldXIgZCfDqXbDqG5lbWVudCA6IHBvdXIgbCdhZmZpY2hhZ2UgZHluYW1pcXVlXG4gICAgICAgIGNvbnN0IGR5bmFtaWNzRyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgICAgICAgLy8gUG91ciDDqWNvdXRlciBsYSBwb3NpdGlvbiBkZSBsYSBzb3VyaXNcbiAgICAgICAgY29uc3QgcGF0aFJlY3RhbmdsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicmVjdFwiKTtcbiAgICAgICAgcGF0aFJlY3RhbmdsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBwYXRoV2lkdGgpO1xuICAgICAgICBwYXRoUmVjdGFuZ2xlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBwYXRoSGVpZ2h0KTtcbiAgICAgICAgcGF0aFJlY3RhbmdsZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3dpZGdldFdpZHRoIC0gcGF0aFdpZHRofSwwKWApO1xuICAgICAgICBwYXRoUmVjdGFuZ2xlLnNldEF0dHJpYnV0ZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgIHBhdGhSZWN0YW5nbGUuc2V0QXR0cmlidXRlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG5cbiAgICAgICAgY29uc3Qgc29ydGVkRGlzdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoX3BvaW50cykpO1xuICAgICAgICBzb3J0ZWREaXN0LnNvcnQoZnVuY3Rpb24gKGUxLCBlMikge1xuICAgICAgICAgICAgcmV0dXJuIGUxLmRpc3QgLSBlMi5kaXN0O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBmb2N1c0xpbmVYID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJsaW5lXCIpO1xuICAgICAgICBmb2N1c0xpbmVYLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiZm9jdXNMaW5lWFwiKTtcbiAgICAgICAgZm9jdXNMaW5lWC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImZvY3VzTGluZS1kZWZhdWx0XCIpO1xuICAgICAgICBmb2N1c0xpbmVYLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICBmb2N1c0xpbmVYLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIiNGOTBcIik7XG4gICAgICAgIGZvY3VzTGluZVguc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMC41cHhcIik7XG4gICAgICAgIGZvY3VzTGluZVguc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblxuICAgICAgICBjb25zdCBmb2N1c0xpbmVZID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJsaW5lXCIpO1xuICAgICAgICBmb2N1c0xpbmVZLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiZm9jdXNMaW5lWVwiKTtcbiAgICAgICAgZm9jdXNMaW5lWS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImZvY3VzTGluZS1kZWZhdWx0XCIpO1xuICAgICAgICBmb2N1c0xpbmVZLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICBmb2N1c0xpbmVZLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIiNGOTBcIik7XG4gICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMC41cHhcIik7XG4gICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblxuICAgICAgICBjb25zdCBmb2N1c0NpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpO1xuICAgICAgICBmb2N1c0NpcmNsZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImZvY3VzQ2lyY2xlXCIpO1xuICAgICAgICBmb2N1c0NpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyXCIsIDQpO1xuICAgICAgICBmb2N1c0NpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNpcmNsZS1kZWZhdWx0IGZvY3VzQ2lyY2xlLWRlZmF1bHRcIik7XG4gICAgICAgIGZvY3VzQ2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCIjRjkwXCIpO1xuICAgICAgICBmb2N1c0NpcmNsZS5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuXG4gICAgICAgIGR5bmFtaWNzRy5hcHBlbmRDaGlsZChmb2N1c0NpcmNsZSk7XG4gICAgICAgIGR5bmFtaWNzRy5hcHBlbmRDaGlsZChmb2N1c0xpbmVYKTtcbiAgICAgICAgZHluYW1pY3NHLmFwcGVuZENoaWxkKGZvY3VzTGluZVkpO1xuXG4gICAgICAgIC8vIFRvb2x0aXBcbiAgICAgICAgY29uc3QgdG9vbHRpcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwidGV4dFwiKTtcbiAgICAgICAgY29uc3QgYWx0aVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInRzcGFuXCIpO1xuICAgICAgICBjb25zdCBzbG9wZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInRzcGFuXCIpO1xuICAgICAgICBjb25zdCBjb29yZHNTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0c3BhblwiKTtcblxuICAgICAgICB0b29sdGlwRGl2LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwidGV4dC1hbGlnbjpjZW50ZXI7IG1heC13aWR0aDoyMjBweDsgZm9udC1zaXplOjEwcHg7IGNvbG9yOiMwMDAwMDA7IGZvbnQtZmFtaWx5OlZlcmRhbmE7IHotaW5kZXg6NTA7XCIpO1xuICAgICAgICB0b29sdGlwRGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgdG9vbHRpcERpdi5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgLy8gdG9vbHRpcERpdi5jbGFzc0xpc3QuYWRkKFwidG9vbHRpcEluaXRcIik7XG4gICAgICAgIC8vIElFLi4uXG4gICAgICAgIHRvb2x0aXBEaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ0b29sdGlwSW5pdFwiKTtcbiAgICAgICAgdG9vbHRpcERpdi5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcblxuICAgICAgICB3aWRnZXREaXYuYXBwZW5kQ2hpbGQodG9vbHRpcERpdik7XG5cbiAgICAgICAgYWx0aVNwYW4uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhbHRpUGF0aFZhbHVlXCIpO1xuICAgICAgICBhbHRpU3Bhbi5zZXRBdHRyaWJ1dGUoXCJ4XCIsIFwiMFwiKTtcbiAgICAgICAgYWx0aVNwYW4uc2V0QXR0cmlidXRlKFwiZHlcIiwgXCItLjdlbVwiKTtcblxuICAgICAgICBzbG9wZVNwYW4uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhbHRpUGF0aFZhbHVlXCIpO1xuICAgICAgICBzbG9wZVNwYW4uc2V0QXR0cmlidXRlKFwieFwiLCBcIjBcIik7XG4gICAgICAgIHNsb3BlU3Bhbi5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBcIjFlbVwiKTtcblxuICAgICAgICBjb29yZHNTcGFuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWx0aVBhdGhDb29yZHNcIik7XG4gICAgICAgIGNvb3Jkc1NwYW4uc2V0QXR0cmlidXRlKFwieFwiLCBcIjBcIik7XG4gICAgICAgIGNvb3Jkc1NwYW4uc2V0QXR0cmlidXRlKFwiZHlcIiwgXCIxZW1cIik7XG5cbiAgICAgICAgdG9vbHRpcERpdi5hcHBlbmRDaGlsZChhbHRpU3Bhbik7XG4gICAgICAgIGlmIChfZGlzcGxheVByb2ZpbGVPcHRpb25zLmN1cnJlbnRTbG9wZSkge1xuICAgICAgICAgICAgdG9vbHRpcERpdi5hcHBlbmRDaGlsZChzbG9wZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXBEaXYuYXBwZW5kQ2hpbGQoY29vcmRzU3Bhbik7XG5cbiAgICAgICAgY29uc3QgdG9vbHRpcEcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG5cbiAgICAgICAgZHluYW1pY3NHLmFwcGVuZENoaWxkKHRvb2x0aXBHKTtcblxuICAgICAgICBjb25zdCB0b29sdGlwQnViYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuICAgICAgICB0b29sdGlwQnViYmxlLnNldEF0dHJpYnV0ZShcImNzXCIsIFwiMTAwLDEwMFwiKTtcbiAgICAgICAgdG9vbHRpcEJ1YmJsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiI0ZGRkZGRlwiKTtcbiAgICAgICAgdG9vbHRpcEJ1YmJsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCIjQ0NDQ0NDXCIpO1xuICAgICAgICB0b29sdGlwQnViYmxlLnNldEF0dHJpYnV0ZShcImZpbGwtb3BhY2l0eVwiLCBcIjAuOFwiKTtcbiAgICAgICAgdG9vbHRpcEJ1YmJsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxXCIpO1xuICAgICAgICB0b29sdGlwQnViYmxlLnNldEF0dHJpYnV0ZShcInN0cm9rZS1vcGFjaXR5XCIsIFwiMVwiKTtcblxuICAgICAgICBjb25zdCB0b29sdGlwQnViYmxlU2hhZG93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuICAgICAgICB0b29sdGlwQnViYmxlU2hhZG93LnNldEF0dHJpYnV0ZShcImNzXCIsIFwiMTAwLDEwMFwiKTtcbiAgICAgICAgdG9vbHRpcEJ1YmJsZVNoYWRvdy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiI0ZGRkZGRlwiKTtcbiAgICAgICAgdG9vbHRpcEJ1YmJsZVNoYWRvdy5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCIjMDAwMDAwXCIpO1xuICAgICAgICB0b29sdGlwQnViYmxlU2hhZG93LnNldEF0dHJpYnV0ZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XG4gICAgICAgIHRvb2x0aXBCdWJibGVTaGFkb3cuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMVwiKTtcbiAgICAgICAgdG9vbHRpcEJ1YmJsZVNoYWRvdy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBcIjAuNFwiKTtcbiAgICAgICAgdG9vbHRpcEJ1YmJsZVNoYWRvdy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMSwxKVwiKTtcblxuICAgICAgICB0b29sdGlwRy5hcHBlbmRDaGlsZCh0b29sdGlwQnViYmxlU2hhZG93KTtcbiAgICAgICAgdG9vbHRpcEcuYXBwZW5kQ2hpbGQodG9vbHRpcEJ1YmJsZSk7XG4gICAgICAgIHRvb2x0aXBHLmFwcGVuZENoaWxkKHRvb2x0aXBEaXYpO1xuXG4gICAgICAgIC8vIHRvb2x0aXBHLmNsYXNzTGlzdC5hZGQoXCJ0b29sdGlwSW5pdFwiKTtcbiAgICAgICAgLy8gSUUuLi4gZGVwcmVjYXRlZFxuICAgICAgICB0b29sdGlwRy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInRvb2x0aXBJbml0XCIpO1xuICAgICAgICB0b29sdGlwRy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZU92ZXIgKCkge1xuICAgICAgICAgICAgZm9jdXNMaW5lWC5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcbiAgICAgICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG4gICAgICAgICAgICBmb2N1c0NpcmNsZS5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZS5fX2NyZWF0ZVByb2ZpbGVNYXJrZXIoc2VsZiwgX3BvaW50c1swXSk7XG5cbiAgICAgICAgICAgIC8vIHRvb2x0aXBzXG4gICAgICAgICAgICAvLyB0b29sdGlwRGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJ0b29sdGlwSW5pdFwiKTtcbiAgICAgICAgICAgIC8vIHRvb2x0aXBHLmNsYXNzTGlzdC5yZW1vdmUoXCJ0b29sdGlwSW5pdFwiKTtcbiAgICAgICAgICAgIC8vIHRvb2x0aXBEaXYuY2xhc3NMaXN0LnJlbW92ZShcInRvb2x0aXBGYWRlT3V0XCIpO1xuICAgICAgICAgICAgLy8gdG9vbHRpcEcuY2xhc3NMaXN0LnJlbW92ZShcInRvb2x0aXBGYWRlT3V0XCIpO1xuICAgICAgICAgICAgLy8gdG9vbHRpcERpdi5jbGFzc0xpc3QuYWRkKFwidG9vbHRpcEZhZGVJblwiKTtcbiAgICAgICAgICAgIC8vIHRvb2x0aXBHLmNsYXNzTGlzdC5hZGQoXCJ0b29sdGlwRmFkZUluXCIpO1xuICAgICAgICAgICAgLy8gSUUuLi4gZGVwcmVjYXRlZFxuICAgICAgICAgICAgdG9vbHRpcERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInRvb2x0aXBGYWRlSW5cIik7XG4gICAgICAgICAgICB0b29sdGlwRy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInRvb2x0aXBGYWRlSW5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlT3V0ICgpIHtcbiAgICAgICAgICAgIGZvY3VzTGluZVguc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgIGZvY3VzQ2lyY2xlLnNldEF0dHJpYnV0ZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICBjbGFzc05hbWUuX19yZW1vdmVQcm9maWxlTWFya2VyKHNlbGYpO1xuICAgICAgICAgICAgLy8gdG9vbHRpcHNcbiAgICAgICAgICAgIC8vIHRvb2x0aXBEaXYuY2xhc3NMaXN0LnJlbW92ZShcInRvb2x0aXBGYWRlSW5cIik7XG4gICAgICAgICAgICAvLyB0b29sdGlwRy5jbGFzc0xpc3QucmVtb3ZlKFwidG9vbHRpcEZhZGVJblwiKTtcbiAgICAgICAgICAgIC8vIHRvb2x0aXBEaXYuY2xhc3NMaXN0LmFkZChcInRvb2x0aXBGYWRlT3V0XCIpO1xuICAgICAgICAgICAgLy8gdG9vbHRpcEcuY2xhc3NMaXN0LmFkZChcInRvb2x0aXBGYWRlT3V0XCIpO1xuICAgICAgICAgICAgLy8gSUUuLi4gZGVwcmVjYXRlZFxuICAgICAgICAgICAgdG9vbHRpcERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInRvb2x0aXBGYWRlT3V0XCIpO1xuICAgICAgICAgICAgdG9vbHRpcEcuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ0b29sdGlwRmFkZU91dFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlIChlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvaW50ID0gZWxldmF0aW9uU3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgICAgICBtb3VzZVBvaW50LnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBtb3VzZVBvaW50LnkgPSBlLmNsaWVudFk7XG4gICAgICAgICAgICBjb25zdCBzdmdNb3VzZVBvaW50ID0gbW91c2VQb2ludC5tYXRyaXhUcmFuc2Zvcm0oZWxldmF0aW9uU3ZnLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICAgICAgICBjb25zdCBtb3VzZURpc3QgPSB0aGlzLl9zdmdYVG9EYXRhRGlzdChzdmdNb3VzZVBvaW50LngsIHdpZGdldFdpZHRoLCBwYXRoV2lkdGgsIHB4UGVyTVgpICogZmFjdG9yO1xuXG4gICAgICAgICAgICAvLyBNYXRoLm1heCBwb3VyIMOpdml0ZXIgZGUgc29ydGlyIGRlIGwnYXJyYXlcbiAgICAgICAgICAgIGNvbnN0IGRpc3RJbmRleCA9IE1hdGgubWF4KDEsIHRoaXMuX2FycmF5QmlzZWN0KHNvcnRlZERpc3QsIG1vdXNlRGlzdCkpO1xuXG4gICAgICAgICAgICBjb25zdCBkMCA9IF9wb2ludHNbZGlzdEluZGV4IC0gMV07XG4gICAgICAgICAgICBjb25zdCBkMSA9IF9wb2ludHNbZGlzdEluZGV4XTtcbiAgICAgICAgICAgIGxldCBkID0gZDA7XG4gICAgICAgICAgICBpZiAobW91c2VEaXN0IC0gZDAuZGlzdCA+IGQxLmRpc3QgLSBtb3VzZURpc3QpIHtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZvY3VzWCA9IHRoaXMuX2RhdGFEaXN0VG9TdmdYKGQuZGlzdCAvIGZhY3Rvciwgd2lkZ2V0V2lkdGgsIHBhdGhXaWR0aCwgcHhQZXJNWCk7XG4gICAgICAgICAgICBjb25zdCBmb2N1c1kgPSB0aGlzLl9kYXRhWlRvU3ZnWShkLnosIHBhdGhIZWlnaHQsIG1pbkdyYXBoWiwgcHhQZXJNWik7XG5cbiAgICAgICAgICAgIC8vIE1pc2Ugw6Agam91ciBkZXMgw6lsw6ltZW50cyBncmFwaGlxdWVzXG4gICAgICAgICAgICBmb2N1c0NpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCBmb2N1c1gpO1xuICAgICAgICAgICAgZm9jdXNDaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgZm9jdXNZKTtcblxuICAgICAgICAgICAgZm9jdXNMaW5lWC5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBmb2N1c1gpO1xuICAgICAgICAgICAgZm9jdXNMaW5lWC5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBwYXRoSGVpZ2h0KTtcbiAgICAgICAgICAgIGZvY3VzTGluZVguc2V0QXR0cmlidXRlKFwieDJcIiwgZm9jdXNYKTtcbiAgICAgICAgICAgIGZvY3VzTGluZVguc2V0QXR0cmlidXRlKFwieTJcIiwgMCk7XG5cbiAgICAgICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwieDFcIiwgekxhYmVsV2lkdGggKyB6R3JhZFdpZHRoKTtcbiAgICAgICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwieTFcIiwgZm9jdXNZKTtcbiAgICAgICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwieDJcIiwgcGF0aFdpZHRoICsgekxhYmVsV2lkdGggKyB6R3JhZFdpZHRoKTtcbiAgICAgICAgICAgIGZvY3VzTGluZVkuc2V0QXR0cmlidXRlKFwieTJcIiwgZm9jdXNZKTtcblxuICAgICAgICAgICAgY2xhc3NOYW1lLl9fdXBkYXRlUHJvZmlsZU1hcmtlcihzZWxmLCBkKTtcblxuICAgICAgICAgICAgLy8gTWlzZSDDoCBqb3VyIGR1IHRvb2x0aXBcbiAgICAgICAgICAgIGNvbnN0IGFsdGlTcGFuVHh0ID0gYEFsdGl0dWRlIDogJHtkLnoudG9Mb2NhbGVTdHJpbmcoKX0gbWA7XG4gICAgICAgICAgICBjb25zdCBzbG9wZVNwYW5UeHQgPSBgUGVudGUgOiAke2Quc2xvcGV9ICVgO1xuICAgICAgICAgICAgY29uc3QgY29vcmRzU3BhblR4dCA9IGAobGF0IDogJHtkLmxhdC50b0xvY2FsZVN0cmluZygpfSAvIGxvbiA6ICR7ZC5sb24udG9Mb2NhbGVTdHJpbmcoKX0pYDtcblxuICAgICAgICAgICAgYWx0aVNwYW4uaW5uZXJIVE1MID0gYWx0aVNwYW5UeHQ7XG4gICAgICAgICAgICBzbG9wZVNwYW4uaW5uZXJIVE1MID0gc2xvcGVTcGFuVHh0O1xuICAgICAgICAgICAgY29vcmRzU3Bhbi5pbm5lckhUTUwgPSBjb29yZHNTcGFuVHh0O1xuXG4gICAgICAgICAgICBjb25zdCB0b29sdGlwVGV4dFdpZHRoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGV4dFdpZHRoKGNvb3Jkc1NwYW5UeHQsIGNvb3Jkc1NwYW4pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2dldFRleHRXaWR0aChhbHRpU3BhblR4dCwgYWx0aVNwYW4pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgdG9vbFRpcEJ1YmJsZUQ7XG4gICAgICAgICAgICBpZiAoZC5kaXN0ID4gKGRpc3QgKiBmYWN0b3IpIC8gMikge1xuICAgICAgICAgICAgICAgIHRvb2xUaXBCdWJibGVEID0gYE0gLTAuNSAtMC41IGwgLTYgNiBsIDAgMTYgbCAtJHt0b29sdGlwVGV4dFdpZHRoICsgMTB9IDAgbCAwIC00NCBsICR7dG9vbHRpcFRleHRXaWR0aCArIDEwfSAwIGwgMCAxNiBsIDYgNmA7XG4gICAgICAgICAgICAgICAgdG9vbHRpcERpdi5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgkey0odG9vbHRpcFRleHRXaWR0aCAvIDIgKyAxMil9LDApYCk7IC8vIElFMTEgIVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkLmRpc3QgPD0gKGRpc3QgKiBmYWN0b3IpIC8gMikge1xuICAgICAgICAgICAgICAgIHRvb2xUaXBCdWJibGVEID0gYE0gLTAuNSAtMC41IGwgNiA2IGwgMCAxNiBsICR7dG9vbHRpcFRleHRXaWR0aCArIDEwfSAwIGwgMCAtNDQgbCAtJHt0b29sdGlwVGV4dFdpZHRoICsgMTB9IDAgbCAwIDE2IGwgLTYgNmA7XG4gICAgICAgICAgICAgICAgLy8gTGFyZ2V1ciBkZSBsYSBmbGVjaGUgZGUgbGEgYnVsbGUgZHUgdG9vbHRpcFxuICAgICAgICAgICAgICAgIHRvb2x0aXBEaXYuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHsodG9vbHRpcFRleHRXaWR0aCAvIDIgKyAxMil9LDApYCk7IC8vIElFMTEgIVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b29sdGlwQnViYmxlLnNldEF0dHJpYnV0ZShcImRcIiwgdG9vbFRpcEJ1YmJsZUQpO1xuICAgICAgICAgICAgdG9vbHRpcEJ1YmJsZVNoYWRvdy5zZXRBdHRyaWJ1dGUoXCJkXCIsIHRvb2xUaXBCdWJibGVEKTtcblxuICAgICAgICAgICAgdG9vbHRpcEcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtmb2N1c1h9LCR7Zm9jdXNZfSlgKTsgLy8gSUUxMSAhXG4gICAgICAgICAgICB0b29sdGlwRy5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7Zm9jdXNYfXB4LCR7Zm9jdXNZfXB4KWA7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoUmVjdGFuZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3ZlclwiLCBvbk1vdXNlT3Zlcik7XG4gICAgICAgIHBhdGhSZWN0YW5nbGUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdXRcIiwgb25Nb3VzZU91dCk7XG4gICAgICAgIHBhdGhSZWN0YW5nbGUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIGR5bmFtaWNzRy5hcHBlbmRDaGlsZChwYXRoUmVjdGFuZ2xlKTtcbiAgICAgICAgZWxldmF0aW9uU3ZnLmFwcGVuZENoaWxkKGR5bmFtaWNzRyk7XG5cbiAgICAgICAgd2lkZ2V0RGl2LmFwcGVuZENoaWxkKGVsZXZhdGlvblN2Zyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBQcm9maWxlIHdpdGhvdXQgZ3JhcGhpY2FsIHJlbmRlcmluZyAocmF3IHNlcnZpY2UgcmVzcG9uc2UpXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBlbGV2YXRpb25zIHZhbHVlcyBmb3IgcHJvZmlsZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGh0bWwgY29udGFpbmVyIHdoZXJlIHRvIGRpc3BsYXkgcHJvZmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gdGhpcyBjb250cm9sIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc05hbWUgLSBjYWxsaW5nIGNsYXNzIChpZSBFbGV2YXRpb25QYXRoKVxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBwcm9maWwgY29udGFpbmVyXG4gICAgICovXG4gICAgZGlzcGxheVByb2ZpbGVSYXcgOiBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyLCBjb250ZXh0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uIG5ldHRvaWUgdG91am91cnMuLi5cbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9wb2ludHMgPSAoZGF0YSAmJiBkYXRhLnBvaW50cykgPyBkYXRhLnBvaW50cyA6IHt9O1xuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgIGRpdi5pZCA9IFwicHJvZmlsRWxldmF0aW9uUmVzdWx0c1wiO1xuICAgICAgICBkaXYucm93cyA9IDEwO1xuICAgICAgICBkaXYuY29scyA9IDUwO1xuICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KF9wb2ludHMsIHVuZGVmaW5lZCwgNCk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUuX19jdXN0b21SYXdQcm9maWxlTW91c2VPdmVyRXZlbnQoY29udGV4dCwgZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBfcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vICAgICB2YXIgcG9pbnQgPSBfcG9pbnRzW2ldO1xuICAgICAgICAvLyAgICAgdmFyIGRpdkMgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvZGVcIik7XG4gICAgICAgIC8vICAgICBkaXZDLmlkID0gXCJwb2ludF9cIiArIGk7XG4gICAgICAgIC8vICAgICBkaXZDLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KHBvaW50LCB1bmRlZmluZWQsIDQpO1xuICAgICAgICAvLyAgICAgZGl2LmFwcGVuZENoaWxkKGRpdkMpO1xuICAgICAgICAvLyAgICAgZGl2Qy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vICAgICAgICAgIGNsYXNzTmFtZS5fX2N1c3RvbVJhd1Byb2ZpbGVNb3VzZU92ZXJFdmVudChjb250ZXh0LCBlKTtcbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBQcm9maWxlIHVzaW5nIEQzIGphdmFzY3JpcHQgZnJhbWV3b3JrLiBUaGlzIG1ldGhvZCBuZWVkcyBEMyBsaWJyYXJpZXMgdG8gYmUgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZWxldmF0aW9ucyB2YWx1ZXMgZm9yIHByb2ZpbGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBodG1sIGNvbnRhaW5lciB3aGVyZSB0byBkaXNwbGF5IHByb2ZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIHRoaXMgY29udHJvbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xhc3NOYW1lIC0gY2FsbGluZyBjbGFzcyAoaWUgRWxldmF0aW9uUGF0aClcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gcHJvZmlsIGNvbnRhaW5lclxuICAgICAqL1xuICAgIGRpc3BsYXlQcm9maWxlTGliRDMgOiBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyLCBjb250ZXh0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSBjb250ZXh0O1xuXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uIG5ldHRvaWUgdG91am91cnMuLi5cbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9wb2ludHMgPSBkYXRhLnBvaW50cztcblxuICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZSA+IDIwMDApIHtcbiAgICAgICAgICAgIGRhdGEudW5pdCA9IFwia21cIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9wb2ludHNbaV0uZGlzdCAvPSAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9kaXNwbGF5UHJvZmlsZU9wdGlvbnMgPSBzZWxmLm9wdGlvbnMuZGlzcGxheVByb2ZpbGVPcHRpb25zO1xuXG4gICAgICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgICAgICB0b3AgOiAyMCxcbiAgICAgICAgICAgIHJpZ2h0IDogMjAsXG4gICAgICAgICAgICBib3R0b20gOiAzMCxcbiAgICAgICAgICAgIGxlZnQgOiA0MFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgICAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKVxuICAgICAgICAgICAgLnRpY2tzKDUpO1xuXG4gICAgICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLm9yaWVudChcImxlZnRcIilcbiAgICAgICAgICAgIC50aWNrcyg1KTtcblxuICAgICAgICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImJhc2lzXCIpXG4gICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KGQuZGlzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnopO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJiYXNpc1wiKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geChkLmRpc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC55MChoZWlnaHQpXG4gICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnopO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChjb250YWluZXIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIHZhciB4RG9tYWluID0gZDMuZXh0ZW50KF9wb2ludHMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5kaXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgeC5kb21haW4oeERvbWFpbik7XG5cbiAgICAgICAgdmFyIHlEb21haW4gPSBbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgZDMubWF4KF9wb2ludHMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuejtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF07XG4gICAgICAgIHkuZG9tYWluKHlEb21haW4pO1xuXG4gICAgICAgIHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuZGF0dW0oX3BvaW50cylcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhLWQzXCIpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG5cbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXMtZDNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtMTUpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLjcxZW1cIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCB3aWR0aClcbiAgICAgICAgICAgIC50ZXh0KFwiRGlzdGFuY2UgKFwiICsgZGF0YS51bml0ICsgXCIpXCIpO1xuXG4gICAgICAgIHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzLWQzXCIpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcylcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTApXCIpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuNzFlbVwiKVxuICAgICAgICAgICAgLnRleHQoXCJBbHRpdHVkZSAobSlcIik7XG5cbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkLWQzIHZlcnRpY2FsXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh4QXhpc1xuICAgICAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIilcbiAgICAgICAgICAgICAgICAudGlja1NpemUoLWhlaWdodCwgMCwgMClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyaWQtZDMgaG9yaXpvbnRhbFwiKVxuICAgICAgICAgICAgLmNhbGwoeUF4aXNcbiAgICAgICAgICAgICAgICAub3JpZW50KFwibGVmdFwiKVxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtd2lkdGgsIDAsIDApXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoXCJcIilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgc3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5kYXR1bShfcG9pbnRzKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxpbmUtZDNcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lKTtcblxuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAuZGF0YShfcG9pbnRzKVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geChkLmRpc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnopO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiclwiLCAwKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNpcmNsZS1kM1wiKTtcblxuICAgICAgICB2YXIgZm9jdXMgPSBzdmcuYXBwZW5kKFwiZ1wiKS5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXG4gICAgICAgIGZvY3VzLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJmb2N1c0xpbmVYXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZm9jdXNMaW5lLWQzXCIpO1xuICAgICAgICBmb2N1cy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwiZm9jdXNMaW5lWVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZvY3VzTGluZS1kM1wiKTtcbiAgICAgICAgZm9jdXMuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwiZm9jdXNDaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiclwiLCA0KVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNpcmNsZS1kMyBmb2N1c0NpcmNsZS1kM1wiKTtcblxuICAgICAgICB2YXIgZGl2ID0gZDMuc2VsZWN0KGNvbnRhaW5lcikuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG9vbHRpcC1kM1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcblxuICAgICAgICB2YXIgYmlzZWN0RGlzdCA9IGQzLmJpc2VjdG9yKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5kaXN0O1xuICAgICAgICB9KS5sZWZ0O1xuXG4gICAgICAgIHN2Zy5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwib3ZlcmxheS1kM1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9jdXMuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpO1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5fX2NyZWF0ZVByb2ZpbGVNYXJrZXIoc2VsZiwgX3BvaW50c1swXSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvY3VzLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLl9fcmVtb3ZlUHJvZmlsZU1hcmtlcihzZWxmKTtcblxuICAgICAgICAgICAgICAgIC8vIHRvb2x0aXBzXG4gICAgICAgICAgICAgICAgZGl2LnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBkMy5tb3VzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB4LmludmVydChtWzBdKTtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLm1heCBwb3VyIMOpdml0ZXIgZGUgc29ydGlyIGRlIGwnYXJyYXlcbiAgICAgICAgICAgICAgICB2YXIgaSA9IE1hdGgubWF4KDEsIGJpc2VjdERpc3QoX3BvaW50cywgZGlzdGFuY2UpKTtcblxuICAgICAgICAgICAgICAgIHZhciBkMCA9IF9wb2ludHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBkMSA9IF9wb2ludHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkaXN0YW5jZSAtIGQwWzBdID4gZDFbMF0gLSBkaXN0YW5jZSA/IGQxIDogZDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgeGMgPSB4KGQuZGlzdCk7XG4gICAgICAgICAgICAgICAgdmFyIHljID0geShkLnopO1xuXG4gICAgICAgICAgICAgICAgZm9jdXMuc2VsZWN0KFwiI2ZvY3VzQ2lyY2xlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgeGMpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgeWMpO1xuICAgICAgICAgICAgICAgIGZvY3VzLnNlbGVjdChcIiNmb2N1c0xpbmVYXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeGMpLmF0dHIoXCJ5MVwiLCB5KHlEb21haW5bMF0pKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHhjKS5hdHRyKFwieTJcIiwgeSh5RG9tYWluWzFdKSk7XG4gICAgICAgICAgICAgICAgZm9jdXMuc2VsZWN0KFwiI2ZvY3VzTGluZVlcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KHhEb21haW5bMF0pKS5hdHRyKFwieTFcIiwgeWMpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeCh4RG9tYWluWzFdKSkuYXR0cihcInkyXCIsIHljKTtcblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5fX3VwZGF0ZVByb2ZpbGVNYXJrZXIoc2VsZiwgZCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0b29sdGlwc1xuICAgICAgICAgICAgICAgIGRpdi50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9tZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBfbWVzc2FnZSArPSBcIiBBbHRpdHVkZSA6IFwiICsgZC56ICsgXCIgbVwiO1xuICAgICAgICAgICAgICAgIGlmIChfZGlzcGxheVByb2ZpbGVPcHRpb25zLmN1cnJlbnRTbG9wZSkge1xuICAgICAgICAgICAgICAgICAgICBfbWVzc2FnZSArPSBcIjxici8+IFBlbnRlIDogXCIgKyBkLnNsb3BlICsgXCIgJVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbWVzc2FnZSArPSBcIjxici8+IChMYXQgOiBcIiArIGQubGF0ICsgXCIvIExvbiA6IFwiICsgZC5sb24gKyBcIilcIjtcblxuICAgICAgICAgICAgICAgIGRpdi5odG1sKF9tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIChkMy5ldmVudC5wYWdlWCkgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAoZDMuZXZlbnQucGFnZVkgLSAyOCkgKyBcInB4XCIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGQzLnNlbGVjdEFsbChcInJlY3Qub3ZlcmxheVwiKVswXVswXTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBQcm9maWxlIHVzaW5nIEFtY2hhcnRzIGZyYW1ld29yay4gVGhpcyBtZXRob2QgbmVlZHMgQW1DaGFydHMgbGlicmFyaWVzIHRvIGJlIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGVsZXZhdGlvbnMgdmFsdWVzIGZvciBwcm9maWxlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gaHRtbCBjb250YWluZXIgd2hlcmUgdG8gZGlzcGxheSBwcm9maWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSB0aGlzIGNvbnRyb2wgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsYXNzTmFtZSAtIGNhbGxpbmcgY2xhc3MgKGllIEVsZXZhdGlvblBhdGgpXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IHByb2ZpbCBjb250YWluZXJcbiAgICAgKi9cbiAgICBkaXNwbGF5UHJvZmlsZUxpYkFtQ2hhcnRzIDogZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lciwgY29udGV4dCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBzZWxmID0gY29udGV4dDtcblxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3BvaW50cyA9IGRhdGEucG9pbnRzO1xuXG4gICAgICAgIHZhciBiYWxsb25UZXh0ID0gXCI8c3BhbiBjbGFzcz0nYWx0aVBhdGhWYWx1ZSc+W1t0aXRsZV1dIDogW1t2YWx1ZV1dbTwvc3Bhbj48YnIvPlwiO1xuICAgICAgICB2YXIgY3VycmVudFNsb3BlID0gc2VsZi5vcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucy5jdXJyZW50U2xvcGU7XG4gICAgICAgIGlmIChjdXJyZW50U2xvcGUpIHtcbiAgICAgICAgICAgIGJhbGxvblRleHQgKz0gXCI8c3BhbiBjbGFzcz0nYWx0aVBhdGhWYWx1ZSc+UGVudGUgOiBbW3Nsb3BlXV0gJTwvc3Bhbj48YnIvPlwiO1xuICAgICAgICB9XG4gICAgICAgIGJhbGxvblRleHQgKz0gXCI8c3BhbiBjbGFzcz0nYWx0aVBhdGhDb29yZHMnPihMYXQ6IFtbbGF0XV0gLyBMb246W1tsb25dXSk8L3NwYW4+XCI7XG5cbiAgICAgICAgQW1DaGFydHMuYWRkSW5pdEhhbmRsZXIoZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgIGlmIChkYXRhLmRpc3RhbmNlID4gMjAwMCkge1xuICAgICAgICAgICAgZGF0YS51bml0ID0gXCJrbVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX3BvaW50c1tpXS5kaXN0IC89IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gX3BvaW50c1tpXS5kaXN0O1xuICAgICAgICAgICAgdmFyIGNvZWZmQXJyb25kID0gMTAwO1xuICAgICAgICAgICAgaWYgKGRpc3QgPiAxMDApIHtcbiAgICAgICAgICAgICAgICBjb2VmZkFycm9uZCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPiAxMCkge1xuICAgICAgICAgICAgICAgIGNvZWZmQXJyb25kID0gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcnJlY3Rpb24gYXJyb25kaSBkaXN0YW5jZSB0b3RhbGVcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnJvdW5kKGRpc3QgKiBjb2VmZkFycm9uZCkgLyBjb2VmZkFycm9uZDtcbiAgICAgICAgICAgIF9wb2ludHNbaV0uZGlzdCA9IGRpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICB0eXBlIDogXCJzZXJpYWxcIixcbiAgICAgICAgICAgIHBhdGhUb0ltYWdlcyA6IFwiaHR0cDovL2Nkbi5hbWNoYXJ0cy5jb20vbGliLzMvaW1hZ2VzL1wiLFxuICAgICAgICAgICAgY2F0ZWdvcnlGaWVsZCA6IFwiZGlzdFwiLFxuICAgICAgICAgICAgYXV0b01hcmdpbk9mZnNldCA6IDAsXG4gICAgICAgICAgICBtYXJnaW5SaWdodCA6IDEwLFxuICAgICAgICAgICAgbWFyZ2luVG9wIDogMTAsXG4gICAgICAgICAgICBzdGFydER1cmF0aW9uIDogMCxcbiAgICAgICAgICAgIGNvbG9yIDogXCIjNUU1RTVFXCIsXG4gICAgICAgICAgICBmb250U2l6ZSA6IDgsXG4gICAgICAgICAgICB0aGVtZSA6IFwibGlnaHRcIixcbiAgICAgICAgICAgIHRob3VzYW5kc1NlcGFyYXRvciA6IFwiXCIsXG4gICAgICAgICAgICBudW1iZXJGb3JtYXR0ZXIgOiB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uIDogLTEsXG4gICAgICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvciA6IFwiLFwiLFxuICAgICAgICAgICAgICAgIHRob3VzYW5kc1NlcGFyYXRvciA6IFwiIFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnlBeGlzIDoge1xuICAgICAgICAgICAgICAgIGNvbG9yIDogXCIjNUU1RTVFXCIsXG4gICAgICAgICAgICAgICAgZ3JpZFBvc2l0aW9uIDogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgIG1pbkhvcml6b250YWxHYXAgOiA0MCxcbiAgICAgICAgICAgICAgICB0aWNrUG9zaXRpb24gOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgdGl0bGUgOiBcIkRpc3RhbmNlIChcIiArIGRhdGEudW5pdCArIFwiKVwiLFxuICAgICAgICAgICAgICAgIHRpdGxlQ29sb3IgOiBcIiM1RTVFNUVcIixcbiAgICAgICAgICAgICAgICBsYWJlbE9mZnNldCA6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRPbkF4aXMgOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhcnRDdXJzb3IgOiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24gOiAwLFxuICAgICAgICAgICAgICAgIGJ1bGxldHNFbmFibGVkIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBidWxsZXRTaXplIDogMTAsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlCYWxsb29uRW5hYmxlZCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN1cnNvckNvbG9yIDogXCIjRjkwXCIsXG4gICAgICAgICAgICAgICAgZ3JhcGhCdWxsZXRBbHBoYSA6IDEsXG4gICAgICAgICAgICAgICAgZ3JhcGhCdWxsZXRTaXplIDogMSxcbiAgICAgICAgICAgICAgICB6b29tYWJsZSA6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJlbmRMaW5lcyA6IFtdLFxuICAgICAgICAgICAgZ3JhcGhzIDogW3tcbiAgICAgICAgICAgICAgICBiYWxsb29uQ29sb3IgOiBcIiNDQ0NDQ0NcIixcbiAgICAgICAgICAgICAgICBiYWxsb29uVGV4dCA6IGJhbGxvblRleHQsXG4gICAgICAgICAgICAgICAgYnVsbGV0IDogXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgIGJ1bGxldEFscGhhIDogMCxcbiAgICAgICAgICAgICAgICBidWxsZXRCb3JkZXJDb2xvciA6IFwiI0ZGRlwiLFxuICAgICAgICAgICAgICAgIGJ1bGxldEJvcmRlclRoaWNrbmVzcyA6IDIsXG4gICAgICAgICAgICAgICAgYnVsbGV0Q29sb3IgOiBcIiNGOTBcIixcbiAgICAgICAgICAgICAgICBidWxsZXRTaXplIDogNixcbiAgICAgICAgICAgICAgICBoaWRkZW4gOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpZCA6IFwiQW1HcmFwaC0xXCIsXG4gICAgICAgICAgICAgICAgZmlsbEFscGhhcyA6IDAuNCxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3JzIDogXCIjQzc3QTA0XCIsXG4gICAgICAgICAgICAgICAgbGluZUFscGhhIDogMSxcbiAgICAgICAgICAgICAgICBsaW5lQ29sb3IgOiBcIiNDNzdBMDRcIixcbiAgICAgICAgICAgICAgICBsaW5lVGhpY2tuZXNzIDogMSxcbiAgICAgICAgICAgICAgICB0aXRsZSA6IFwiQWx0aXR1ZGVcIixcbiAgICAgICAgICAgICAgICB2YWx1ZUZpZWxkIDogXCJ6XCJcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZ3VpZGVzIDogW10sXG4gICAgICAgICAgICB2YWx1ZUF4ZXMgOiBbe1xuICAgICAgICAgICAgICAgIGlkIDogXCJWYWx1ZUF4aXMtMVwiLFxuICAgICAgICAgICAgICAgIG1pblZlcnRpY2FsR2FwIDogMjAsXG4gICAgICAgICAgICAgICAgdGl0bGUgOiBcIkFsdGl0dWRlIChtKVwiXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGJhbGxvb24gOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgOiBcIiNDQ0NDQ0NcIixcbiAgICAgICAgICAgICAgICBib3JkZXJUaGlja25lc3MgOiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvciA6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgICAgIHNob3dCdWxsZXQgOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGl0bGVzIDogW10sXG4gICAgICAgICAgICBhbGxMYWJlbHMgOiBbXSxcbiAgICAgICAgICAgIGRhdGFQcm92aWRlciA6IF9wb2ludHNcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX2NvbnRhaW5lclByb2ZpbGUgPSBBbUNoYXJ0cy5tYWtlQ2hhcnQoY29udGFpbmVyLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgX2NvbnRhaW5lclByb2ZpbGUuYWRkTGlzdGVuZXIoXCJjaGFuZ2VkXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gZS5jaGFydC5kYXRhUHJvdmlkZXJbZS5pbmRleF07XG4gICAgICAgICAgICBjbGFzc05hbWUuX191cGRhdGVQcm9maWxlTWFya2VyKHNlbGYsIG9iaik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBfY29udGFpbmVyUHJvZmlsZTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQcm9maWxlRWxldmF0aW9uUGF0aERPTTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Controls/ProfileElevationPathDOM.js\n");

/***/ }),

/***/ "./src/Common/Utils/CheckRightManagement.js":
/*!**************************************************!*\
  !*** ./src/Common/Utils/CheckRightManagement.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Config */ \"./src/Common/Utils/Config.js\");\n\n\n/**\n * @module CheckRightManagement\n * @alias [private] CheckRightManagement\n * @description\n * ...\n *\n * @example\n * check();\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  /**\n   * Contrôle des droits sur les ressources.\n   *\n   * @function check\n   * @param {Object} options - liste des options\n   * @param {String} options.key - clef API\n   * @param {Array} options.resources - liste des ressources\n   * @param {Array} options.services - liste des services\n   * @returns {Object} rightManagement - undefined ou {\n   *       key : \"\",\n   *       service-1 : [resource-1, resource-2],\n   *       service-2 : [resource-1, resource-2]\n   * }\n   */\n  check: function check(options) {\n    // logger\n    var logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"checkrightmanagement\"); // si aucune option n'est renseignée...\n\n    if (!options) {\n      // message orienté pour le developpeur !\n      logger.error(\"WARNING : \" + \"no parameter specified !\");\n      return;\n    } // les options\n\n\n    var _key = options.key;\n\n    var _resources = options.resources || [];\n\n    var _services = options.services || []; // si aucune information sur les ressources,\n    // il est impossible de controler quelquechose !!!\n\n\n    if (_resources.length === 0) {\n      // message orienté pour le developpeur !\n      logger.error(\"WARNING : \" + \"no parameter 'resources' specified !\");\n      return;\n    } // si aucune information sur les services,\n    // il est impossible de controler quelquechose !!!\n\n\n    if (_services.length === 0) {\n      // message orienté pour le developpeur !\n      logger.error(\"WARNING : \" + \"no parameter 'services' specified !\");\n      return;\n    } // les ressources controlées :\n    // Ex.\n    // {\n    //   \"Itineraire\"     : [\"Pieton\", \"Voiture\"],\n    //   \"Geocode\"        : [\"PositionOfInterest\", \"StreetAddress\", \"CadastralParcel\"],\n    //   \"AutoCompletion\" : [\"PositionOfInterest\", \"StreetAddress\", \"CadastralParcel\"],\n    //   \"Elevation\"      : [\"SERVICE_CALCUL_ALTIMETRIQUE_RSC\"]\n    // }\n\n\n    var _rightManagement = {}; // la clef API n'est pas renseignée\n\n    if (!_key) {\n      // on verifie si l'autoconfiguration est disponible\n      if (!_Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isConfigLoaded()) {\n        // si l'autoconfiguration n'est pas chargée,\n        // aucune vérification des droits est possible...\n        logger.warn(\"WARNING : \" + \"The 'apiKey' parameter is missing, \" + \"and the contract key configuration has not been loaded, \" + \"so impossible to check yours rights !\");\n        return;\n      } else {\n        // si l'autoconfiguration est chargée,\n        // on recupere la/les clef(s) API, et on en profitera ensuite pour controler\n        // les droits sur les ressources.\n        _key = Object.keys(_Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].configuration.generalOptions.apiKeys);\n        logger.log(_key);\n      }\n    } // on verifie si l'autoconfiguration est disponible\n\n\n    if (!_Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isConfigLoaded()) {\n      // si l'autoconfiguration n'est pas chargée,\n      // il est toujours possible de requeter le service avec une clef API,\n      // mais les droits sur les ressources ne sont pas garantis, on risque\n      // d'obtenir des erreurs 403 forbidden...\n      // la responsabilité revient à l'utilisateur (message d'information)...\n      logger.warn(\"WARNING : \" + \"the contract key configuration has not been loaded, \" + \"so be carefull !\"); // les ressouces non controlées\n\n      var _noRightManagement = {};\n\n      for (var i = 0; i < _services.length; i++) {\n        var service = _services[i];\n        _noRightManagement[service] = [];\n\n        for (var j = 0; j < _resources.length; j++) {\n          var resource = _resources[j];\n\n          _noRightManagement[service].push(resource);\n        }\n      } // on ajoute la clef\n\n\n      _noRightManagement.key = _key;\n      logger.log(\"right management not checked\", _noRightManagement);\n      return _noRightManagement;\n    } else {\n      // si l'autoconf est chargée,\n      // on verifie la correspondance entre la clef et l'autoconfiguration,\n      // on previent l'utilisateur (message d'information) s'il n'a\n      // pas de droits sur certaines ressources ...\n      // doit on ecarter les ressources sans droit ?\n      // oui, si possible avec un message d'information pour l'utilisateur...\n      for (var k = 0; k < _resources.length; k++) {\n        var _resource = _resources[k];\n\n        for (var l = 0; l < _services.length; l++) {\n          var _service = _services[l];\n          var params = _Config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getServiceParams(_resource, _service, _key);\n\n          if (!params || Object.keys(params).length === 0) {\n            logger.warn(\"WARNING : \" + \"The contract key configuration has no rights to load this geoportal \" + \"resource (\" + _resource + \") \" + \"for this service (\" + _service + \") \");\n            continue;\n          }\n\n          if (!_rightManagement[_service]) {\n            _rightManagement[_service] = [];\n          }\n\n          _rightManagement[_service].push(_resource);\n        }\n      }\n\n      if (Object.keys(_rightManagement).length === 0) {\n        logger.warn(\"WARNING : \" + \"The contract key configuration has been loaded, \" + \"and the 'apiKey' parameter has been set, \" + \"but, there is a problem on the mapping between the contract and the key !\");\n        return;\n      } // on ajoute la clef qui correspond à la ressource vérifiée\n\n\n      _rightManagement.key = params.key;\n      logger.log(\"right management checked\", _rightManagement);\n      return _rightManagement;\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL0NoZWNrUmlnaHRNYW5hZ2VtZW50LmpzPzRmMzQiXSwibmFtZXMiOlsiY2hlY2siLCJvcHRpb25zIiwibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiZXJyb3IiLCJfa2V5Iiwia2V5IiwiX3Jlc291cmNlcyIsInJlc291cmNlcyIsIl9zZXJ2aWNlcyIsInNlcnZpY2VzIiwibGVuZ3RoIiwiX3JpZ2h0TWFuYWdlbWVudCIsIkNvbmZpZyIsImlzQ29uZmlnTG9hZGVkIiwid2FybiIsIk9iamVjdCIsImtleXMiLCJjb25maWd1cmF0aW9uIiwiZ2VuZXJhbE9wdGlvbnMiLCJhcGlLZXlzIiwibG9nIiwiX25vUmlnaHRNYW5hZ2VtZW50IiwiaSIsInNlcnZpY2UiLCJqIiwicmVzb3VyY2UiLCJwdXNoIiwiayIsIl9yZXNvdXJjZSIsImwiLCJfc2VydmljZSIsInBhcmFtcyIsImdldFNlcnZpY2VQYXJhbXMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ2U7QUFDWDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lBLE9BQUssRUFBRyxlQUFVQyxPQUFWLEVBQW1CO0FBQ3ZCO0FBRUEsUUFBSUMsTUFBTSxHQUFHQyxxRUFBTSxDQUFDQyxTQUFQLENBQWlCLHNCQUFqQixDQUFiLENBSHVCLENBS3ZCOztBQUNBLFFBQUksQ0FBQ0gsT0FBTCxFQUFjO0FBQ1Y7QUFDQUMsWUFBTSxDQUFDRyxLQUFQLENBQWEsZUFDVCwwQkFESjtBQUVBO0FBQ0gsS0FYc0IsQ0FhdkI7OztBQUNBLFFBQUlDLElBQUksR0FBR0wsT0FBTyxDQUFDTSxHQUFuQjs7QUFDQSxRQUFJQyxVQUFVLEdBQUdQLE9BQU8sQ0FBQ1EsU0FBUixJ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Q0FBYjs7QUFDQSxjQUFJLENBQUMyQixNQUFELElBQVdoQixNQUFNLENBQUNDLElBQVAsQ0FBWWUsTUFBWixFQUFvQnJCLE1BQXBCLEtBQStCLENBQTlDLEVBQWlEO0FBQzdDVixrQkFBTSxDQUFDYyxJQUFQLENBQVksZUFDUixzRUFEUSxHQUVSLFlBRlEsR0FFT2MsU0FGUCxHQUVtQixJQUZuQixHQUdSLG9CQUhRLEdBR2VFLFFBSGYsR0FHMEIsSUFIdEM7QUFJQTtBQUNIOztBQUVELGNBQUksQ0FBQ25CLGdCQUFnQixDQUFDbUIsUUFBRCxDQUFyQixFQUFpQztBQUM3Qm5CLDRCQUFnQixDQUFDbUIsUUFBRCxDQUFoQixHQUE2QixFQUE3QjtBQUNIOztBQUVEbkIsMEJBQWdCLENBQUNtQixRQUFELENBQWhCLENBQTJCSixJQUEzQixDQUFnQ0UsU0FBaEM7QUFDSDtBQUNKOztBQUVELFVBQUliLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZTCxnQkFBWixFQUE4QkQsTUFBOUIsS0FBeUMsQ0FBN0MsRUFBZ0Q7QUFDNUNWLGNBQU0sQ0FBQ2MsSUFBUCxDQUFZLGVBQ1Isa0RBRFEsR0FFUiwyQ0FGUSxHQUdSLDJFQUhKO0FBSUE7QUFDSCxPQXRDRSxDQXdDSDs7O0FBQ0FILHNCQUFnQixDQUFDTixHQUFqQixHQUF1QjBCLE1BQU0sQ0FBQzFCLEdBQTlCO0FBRUFMLFlBQU0sQ0FBQ29CLEdBQVAsQ0FBVywwQkFBWCxFQUF1Q1QsZ0JBQXZDO0FBRUEsYUFBT0EsZ0JBQVA7QUFDSDtBQUNKO0FBcEtVLENBQWYiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL1V0aWxzL0NoZWNrUmlnaHRNYW5hZ2VtZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IENvbmZpZyBmcm9tIFwiLi9Db25maWdcIjtcblxuLyoqXG4gKiBAbW9kdWxlIENoZWNrUmlnaHRNYW5hZ2VtZW50XG4gKiBAYWxpYXMgW3ByaXZhdGVdIENoZWNrUmlnaHRNYW5hZ2VtZW50XG4gKiBAZGVzY3JpcHRpb25cbiAqIC4uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjaGVjaygpO1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogQ29udHLDtGxlIGRlcyBkcm9pdHMgc3VyIGxlcyByZXNzb3VyY2VzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGNoZWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsaXN0ZSBkZXMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmtleSAtIGNsZWYgQVBJXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5yZXNvdXJjZXMgLSBsaXN0ZSBkZXMgcmVzc291cmNlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2VydmljZXMgLSBsaXN0ZSBkZXMgc2VydmljZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByaWdodE1hbmFnZW1lbnQgLSB1bmRlZmluZWQgb3Uge1xuICAgICAqICAgICAgIGtleSA6IFwiXCIsXG4gICAgICogICAgICAgc2VydmljZS0xIDogW3Jlc291cmNlLTEsIHJlc291cmNlLTJdLFxuICAgICAqICAgICAgIHNlcnZpY2UtMiA6IFtyZXNvdXJjZS0xLCByZXNvdXJjZS0yXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBjaGVjayA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiY2hlY2tyaWdodG1hbmFnZW1lbnRcIik7XG5cbiAgICAgICAgLy8gc2kgYXVjdW5lIG9wdGlvbiBuJ2VzdCByZW5zZWlnbsOpZS4uLlxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIG1lc3NhZ2Ugb3JpZW50w6kgcG91ciBsZSBkZXZlbG9wcGV1ciAhXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJXQVJOSU5HIDogXCIgK1xuICAgICAgICAgICAgICAgIFwibm8gcGFyYW1ldGVyIHNwZWNpZmllZCAhXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVzIG9wdGlvbnNcbiAgICAgICAgdmFyIF9rZXkgPSBvcHRpb25zLmtleTtcbiAgICAgICAgdmFyIF9yZXNvdXJjZXMgPSBvcHRpb25zLnJlc291cmNlcyB8fCBbXTtcbiAgICAgICAgdmFyIF9zZXJ2aWNlcyA9IG9wdGlvbnMuc2VydmljZXMgfHwgW107XG5cbiAgICAgICAgLy8gc2kgYXVjdW5lIGluZm9ybWF0aW9uIHN1ciBsZXMgcmVzc291cmNlcyxcbiAgICAgICAgLy8gaWwgZXN0IGltcG9zc2libGUgZGUgY29udHJvbGVyIHF1ZWxxdWVjaG9zZSAhISFcbiAgICAgICAgaWYgKF9yZXNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBtZXNzYWdlIG9yaWVudMOpIHBvdXIgbGUgZGV2ZWxvcHBldXIgIVxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiV0FSTklORyA6IFwiICtcbiAgICAgICAgICAgICAgICBcIm5vIHBhcmFtZXRlciAncmVzb3VyY2VzJyBzcGVjaWZpZWQgIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpIGF1Y3VuZSBpbmZvcm1hdGlvbiBzdXIgbGVzIHNlcnZpY2VzLFxuICAgICAgICAvLyBpbCBlc3QgaW1wb3NzaWJsZSBkZSBjb250cm9sZXIgcXVlbHF1ZWNob3NlICEhIVxuICAgICAgICBpZiAoX3NlcnZpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gbWVzc2FnZSBvcmllbnTDqSBwb3VyIGxlIGRldmVsb3BwZXVyICFcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgXCJubyBwYXJhbWV0ZXIgJ3NlcnZpY2VzJyBzcGVjaWZpZWQgIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxlcyByZXNzb3VyY2VzIGNvbnRyb2zDqWVzIDpcbiAgICAgICAgLy8gRXguXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICBcIkl0aW5lcmFpcmVcIiAgICAgOiBbXCJQaWV0b25cIiwgXCJWb2l0dXJlXCJdLFxuICAgICAgICAvLyAgIFwiR2VvY29kZVwiICAgICAgICA6IFtcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiLCBcIlN0cmVldEFkZHJlc3NcIiwgXCJDYWRhc3RyYWxQYXJjZWxcIl0sXG4gICAgICAgIC8vICAgXCJBdXRvQ29tcGxldGlvblwiIDogW1wiUG9zaXRpb25PZkludGVyZXN0XCIsIFwiU3RyZWV0QWRkcmVzc1wiLCBcIkNhZGFzdHJhbFBhcmNlbFwiXSxcbiAgICAgICAgLy8gICBcIkVsZXZhdGlvblwiICAgICAgOiBbXCJTRVJWSUNFX0NBTENVTF9BTFRJTUVUUklRVUVfUlNDXCJdXG4gICAgICAgIC8vIH1cbiAgICAgICAgdmFyIF9yaWdodE1hbmFnZW1lbnQgPSB7fTtcblxuICAgICAgICAvLyBsYSBjbGVmIEFQSSBuJ2VzdCBwYXMgcmVuc2VpZ27DqWVcbiAgICAgICAgaWYgKCFfa2V5KSB7XG4gICAgICAgICAgICAvLyBvbiB2ZXJpZmllIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gZXN0IGRpc3BvbmlibGVcblxuICAgICAgICAgICAgaWYgKCFDb25maWcuaXNDb25maWdMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gbidlc3QgcGFzIGNoYXJnw6llLFxuICAgICAgICAgICAgICAgIC8vIGF1Y3VuZSB2w6lyaWZpY2F0aW9uIGRlcyBkcm9pdHMgZXN0IHBvc3NpYmxlLi4uXG5cbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlICdhcGlLZXknIHBhcmFtZXRlciBpcyBtaXNzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYW5kIHRoZSBjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgbm90IGJlZW4gbG9hZGVkLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic28gaW1wb3NzaWJsZSB0byBjaGVjayB5b3VycyByaWdodHMgIVwiKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2kgbCdhdXRvY29uZmlndXJhdGlvbiBlc3QgY2hhcmfDqWUsXG4gICAgICAgICAgICAgICAgLy8gb24gcmVjdXBlcmUgbGEvbGVzIGNsZWYocykgQVBJLCBldCBvbiBlbiBwcm9maXRlcmEgZW5zdWl0ZSBwb3VyIGNvbnRyb2xlclxuICAgICAgICAgICAgICAgIC8vIGxlcyBkcm9pdHMgc3VyIGxlcyByZXNzb3VyY2VzLlxuXG4gICAgICAgICAgICAgICAgX2tleSA9IE9iamVjdC5rZXlzKENvbmZpZy5jb25maWd1cmF0aW9uLmdlbmVyYWxPcHRpb25zLmFwaUtleXMpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiB2ZXJpZmllIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gZXN0IGRpc3BvbmlibGVcblxuICAgICAgICBpZiAoIUNvbmZpZy5pc0NvbmZpZ0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAvLyBzaSBsJ2F1dG9jb25maWd1cmF0aW9uIG4nZXN0IHBhcyBjaGFyZ8OpZSxcbiAgICAgICAgICAgIC8vIGlsIGVzdCB0b3Vqb3VycyBwb3NzaWJsZSBkZSByZXF1ZXRlciBsZSBzZXJ2aWNlIGF2ZWMgdW5lIGNsZWYgQVBJLFxuICAgICAgICAgICAgLy8gbWFpcyBsZXMgZHJvaXRzIHN1ciBsZXMgcmVzc291cmNlcyBuZSBzb250IHBhcyBnYXJhbnRpcywgb24gcmlzcXVlXG4gICAgICAgICAgICAvLyBkJ29idGVuaXIgZGVzIGVycmV1cnMgNDAzIGZvcmJpZGRlbi4uLlxuICAgICAgICAgICAgLy8gbGEgcmVzcG9uc2FiaWxpdMOpIHJldmllbnQgw6AgbCd1dGlsaXNhdGV1ciAobWVzc2FnZSBkJ2luZm9ybWF0aW9uKS4uLlxuXG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgXCJ0aGUgY29udHJhY3Qga2V5IGNvbmZpZ3VyYXRpb24gaGFzIG5vdCBiZWVuIGxvYWRlZCwgXCIgK1xuICAgICAgICAgICAgICAgIFwic28gYmUgY2FyZWZ1bGwgIVwiKTtcblxuICAgICAgICAgICAgLy8gbGVzIHJlc3NvdWNlcyBub24gY29udHJvbMOpZXNcbiAgICAgICAgICAgIHZhciBfbm9SaWdodE1hbmFnZW1lbnQgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2VydmljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VydmljZSA9IF9zZXJ2aWNlc1tpXTtcbiAgICAgICAgICAgICAgICBfbm9SaWdodE1hbmFnZW1lbnRbc2VydmljZV0gPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX3Jlc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBfcmVzb3VyY2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICBfbm9SaWdodE1hbmFnZW1lbnRbc2VydmljZV0ucHVzaChyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbiBham91dGUgbGEgY2xlZlxuICAgICAgICAgICAgX25vUmlnaHRNYW5hZ2VtZW50LmtleSA9IF9rZXk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJyaWdodCBtYW5hZ2VtZW50IG5vdCBjaGVja2VkXCIsIF9ub1JpZ2h0TWFuYWdlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiBfbm9SaWdodE1hbmFnZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaSBsJ2F1dG9jb25mIGVzdCBjaGFyZ8OpZSxcbiAgICAgICAgICAgIC8vIG9uIHZlcmlmaWUgbGEgY29ycmVzcG9uZGFuY2UgZW50cmUgbGEgY2xlZiBldCBsJ2F1dG9jb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgLy8gb24gcHJldmllbnQgbCd1dGlsaXNhdGV1ciAobWVzc2FnZSBkJ2luZm9ybWF0aW9uKSBzJ2lsIG4nYVxuICAgICAgICAgICAgLy8gcGFzIGRlIGRyb2l0cyBzdXIgY2VydGFpbmVzIHJlc3NvdXJjZXMgLi4uXG5cbiAgICAgICAgICAgIC8vIGRvaXQgb24gZWNhcnRlciBsZXMgcmVzc291cmNlcyBzYW5zIGRyb2l0ID9cbiAgICAgICAgICAgIC8vIG91aSwgc2kgcG9zc2libGUgYXZlYyB1biBtZXNzYWdlIGQnaW5mb3JtYXRpb24gcG91ciBsJ3V0aWxpc2F0ZXVyLi4uXG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgX3Jlc291cmNlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBfcmVzb3VyY2UgPSBfcmVzb3VyY2VzW2tdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBfc2VydmljZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zZXJ2aWNlID0gX3NlcnZpY2VzW2xdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBDb25maWcuZ2V0U2VydmljZVBhcmFtcyhfcmVzb3VyY2UsIF9zZXJ2aWNlLCBfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMgfHwgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0FSTklORyA6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgbm8gcmlnaHRzIHRvIGxvYWQgdGhpcyBnZW9wb3J0YWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVzb3VyY2UgKFwiICsgX3Jlc291cmNlICsgXCIpIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvciB0aGlzIHNlcnZpY2UgKFwiICsgX3NlcnZpY2UgKyBcIikgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9yaWdodE1hbmFnZW1lbnRbX3NlcnZpY2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmlnaHRNYW5hZ2VtZW50W19zZXJ2aWNlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX3JpZ2h0TWFuYWdlbWVudFtfc2VydmljZV0ucHVzaChfcmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKF9yaWdodE1hbmFnZW1lbnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0FSTklORyA6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJUaGUgY29udHJhY3Qga2V5IGNvbmZpZ3VyYXRpb24gaGFzIGJlZW4gbG9hZGVkLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYW5kIHRoZSAnYXBpS2V5JyBwYXJhbWV0ZXIgaGFzIGJlZW4gc2V0LCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYnV0LCB0aGVyZSBpcyBhIHByb2JsZW0gb24gdGhlIG1hcHBpbmcgYmV0d2VlbiB0aGUgY29udHJhY3QgYW5kIHRoZSBrZXkgIVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9uIGFqb3V0ZSBsYSBjbGVmIHF1aSBjb3JyZXNwb25kIMOgIGxhIHJlc3NvdXJjZSB2w6lyaWZpw6llXG4gICAgICAgICAgICBfcmlnaHRNYW5hZ2VtZW50LmtleSA9IHBhcmFtcy5rZXk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJyaWdodCBtYW5hZ2VtZW50IGNoZWNrZWRcIiwgX3JpZ2h0TWFuYWdlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiBfcmlnaHRNYW5hZ2VtZW50O1xuICAgICAgICB9XG4gICAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Utils/CheckRightManagement.js\n");

/***/ }),

/***/ "./src/Common/Utils/Config.js":
/*!************************************!*\
  !*** ./src/Common/Utils/Config.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n\nvar logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLogger(\"config\");\n/**\n * @module Config\n * @alias [private] Config\n * @description\n * ...\n *\n * @example\n * isConfigLoaded();\n * getLayerId();\n * getLayerParams();\n * getServiceParams();\n * getResolutions();\n * getGlobalConstraints();\n * getTileMatrix();\n */\n\nvar Config = {\n  /**\n   * autoconf\n   *\n   * @public\n   * @type {Object}\n   */\n  configuration: null,\n\n  /**\n   * Controle du chargement de l'autoconf\n   *\n   * @function isConfigLoaded\n   * @this Config\n   * @public\n   * @returns {Boolean} True si l'autoconf a déjà été chargée, False sinon.\n   */\n  isConfigLoaded: function isConfigLoaded() {\n    var scope = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : {};\n\n    if (scope.Gp && scope.Gp.Config && Object.keys(scope.Gp.Config).length !== 0) {\n      /** ts-syntax */\n      this.configuration = scope.Gp.Config;\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Recuperation de l'identifiant d'une couche donnée\n   *\n   * @function getLayerId\n   * @public\n   * @param {String} layerName - nom de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n   * @param {String} service   - nom du service (par ex. \"WMS\" ou \"WMTS\")\n   * @returns {String} Identifiant de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS\")\n   */\n  getLayerId: function getLayerId(layerName, service) {\n    var layerId = null; // layer\n    // key : [layerName]$[contexte]:OGC:[service]\n    // ex : \"ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS\"\n    // service\n    // key : [layerName]$[contexte];[service]\n    // ex : PositionOfInterest$OGC:OPENLS;ReverseGeocode\n\n    if (this.configuration) {\n      var layers = this.configuration[\"layers\"];\n\n      for (var key in layers) {\n        if (layers.hasOwnProperty(key)) {\n          var parts = key.split(\"$\");\n\n          if (layerName === parts[0]) {\n            if (parts[1]) {\n              var servicePartsLayer = parts[1].split(\":\");\n              var servicePartsService = parts[1].split(\";\");\n\n              if (servicePartsService[1] === service) {\n                layerId = key;\n                break;\n              }\n\n              if (servicePartsLayer[2] === service) {\n                layerId = key;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (!layerId) {\n      logger.error(\"ERROR layer id (layer name: \" + layerName + \" / service: \" + service + \") was not found !?\");\n    }\n\n    return layerId;\n  },\n\n  /**\n   * Récupération des paramètres nécessaires à l'affichage d'une couche WMS ou WMTS\n   *\n   * @function getLayerParams\n   * @public\n   * @param {String} layerName - nom de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n   * @param {String} service   - nom du service (par ex. \"WMS\" ou \"WMTS\")\n   * @param {String} [apiKey]  - Clé de contrat API\n   * @returns {Object} params  - paramètres du service (WMS ou WMTS) pour la couche donnée\n   * @returns {String} params.url        - Url du service à requêter pour afficher la couche\n   * @returns {String} params.version    - Version du service\n   * @returns {String} params.styles     - Style par défaut de la couche\n   * @returns {String} params.format     - Format par défaut de la couche\n   * @returns {String} params.projection - Projection par défaut de la couche\n   * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche\n   * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche\n   * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche\n   * @returns {Array} params.legends     - Tableau des légendes associées à la couche\n   * @returns {Array} params.metadata    - Tableau des métadonnées associées à la couche\n   * @returns {Array} params.originators - Tableau des originators associés à la couche\n   * @returns {Array} params.title       - Nom de la resource, lisible par un humain.\n   * @returns {Array} params.description - Url de l'image d'aperçu rapide de la ressource.\n   * @returns {Array} params.quicklookUrl- Tableau des originators associés à la couche\n   * @returns {String} params.[TMSLink]          - Identifiant de la pyramide (TMS), dans le cas d'une couche WMTS\n   * @returns {Gp.Point} params.[matrixOrigin]   - Origine de la matrice (top left corner), dans le cas d'une couche WMTS\n   * @returns {Array} params.[nativeResolutions] - Tableau regroupant les résolutions de chaque niveau de la matrice, dans le cas d'une couche WMTS\n   * @returns {Array} params.[matrixIds]         - Tableau regroupant les identifiants de chaque niveau de la matrice, dans le cas d'une couche WMTS\n   */\n  getLayerParams: function getLayerParams(layerName, service, apiKey) {\n    var params = {};\n\n    if (this.configuration) {\n      // récupération de l'identifiant complet de la couche.\n      var layerId = this.getLayerId(layerName, service);\n\n      if (layerId) {\n        // récupération de l'objet de configuration de la couche\n        var layerConf = this.configuration.layers[layerId]; // controle de la clef\n\n        var key = layerConf.apiKeys[0];\n\n        if (apiKey) {\n          if (apiKey !== key) {\n            logger.error(\"ERROR different keys (\" + apiKey + \" !== \" + key + \") !?\");\n            return;\n          }\n        }\n\n        apiKey = apiKey || key;\n        params.key = apiKey; // récupération des paramètres du service\n\n        params.url = layerConf.getServerUrl(apiKey);\n        params.version = layerConf.getServiceParams().version;\n        params.styles = layerConf.getDefaultStyle();\n        params.format = layerConf.getDefaultFormat();\n        params.projection = layerConf.getDefaultProjection(); // récupération des infos de la couche\n\n        params.minScale = layerConf.getMinScaleDenominator();\n        params.maxScale = layerConf.getMaxScaleDenominator();\n        params.extent = layerConf.getBBOX();\n        params.legends = layerConf.getLegends();\n        params.metadata = layerConf.getMetadata();\n        params.originators = layerConf.getOriginators();\n        params.title = layerConf.getTitle();\n        params.description = layerConf.getDescription();\n        params.quicklookUrl = layerConf.getQuicklookUrl(); // WMTS : récupération des tileMatrixSetLimits\n\n        if (layerConf.wmtsOptions) {\n          params.tileMatrixSetLimits = layerConf.wmtsOptions.tileMatrixSetLimits;\n        } // WMTS : récupération des paramètres de la pyramide (TMS)\n\n\n        var TMSLink = layerConf.getTMSID();\n\n        if (TMSLink) {\n          params.TMSLink = TMSLink;\n          var tmsConf = this.configuration.getTMSConf(TMSLink); // Get matrix origin : Gp.Point = Object{x:Float, y:Float}\n\n          params.matrixOrigin = tmsConf.getTopLeftCorner();\n          params.nativeResolutions = tmsConf.nativeResolutions;\n          params.matrixIds = tmsConf.matrixIds;\n          params.tileMatrices = tmsConf.tileMatrices;\n        }\n      }\n    }\n\n    return params;\n  },\n\n  /**\n   * Recuperation des parametres d'un service\n   *\n   * @function getServiceParams\n   * @public\n   * @param {String} [resource] - \"PositionOfInterest\", \"StreetAddress\", \"Voiture\", \"Pieton\", ...\n   * @param {String} [service] - Geocode, Itineraire, ...\n   * @param {Array} [apiKeys]  - Clé(s) de contrat API\n   * @returns {Object} params - paramètres de la ressource\n   * @returns {String} params. -\n   * @returns {String} params. -\n   * @returns {String} params. -\n   */\n  getServiceParams: function getServiceParams(resource, service, apiKeys) {\n    var params = {};\n\n    if (this.configuration) {\n      // récupération de l'identifiant complet de la couche.\n      var layerId = this.getLayerId(resource, service);\n\n      if (layerId) {\n        // récupération de l'objet de configuration de la couche\n        var layerConf = this.configuration.layers[layerId]; // controle de la clef (on prend la première clé disponible qui est censée avoir accès à la ressource)\n\n        var key = layerConf.apiKeys[0];\n\n        if (apiKeys) {\n          if (!Array.isArray(apiKeys)) {\n            apiKeys = [apiKeys];\n          }\n\n          for (var i = 0; i < apiKeys.length; i++) {\n            if (apiKeys[i] === key) {\n              var keyIndex = i;\n              break;\n            }\n          } // si aucune clé du tableau apiKeys ne correspond, on retourne rien => pas de droits pour la ressource\n\n\n          if (typeof keyIndex === \"undefined\") {\n            return;\n          }\n        } // on retourne la première clé qui a effectivement accès à la ressource\n\n\n        var apiKey = apiKeys[keyIndex] || key;\n        params.key = apiKey; // récupération des paramètres du service\n\n        params.url = layerConf.getServerUrl(apiKey);\n        params.version = layerConf.getServiceParams().version; // récupération des infos de la couche\n\n        params.extent = layerConf.getBBOX();\n        params.title = layerConf.getTitle();\n        params.description = layerConf.getDescription();\n      }\n    }\n\n    return params;\n  },\n\n  /**\n   * Resolution en geographique\n   *\n   * @function getResolutions\n   * @public\n   * @returns {Array} resolutions\n   */\n  getResolutions: function getResolutions() {\n    var resolutions = [];\n\n    if (this.configuration) {\n      resolutions = this.configuration[\"generalOptions\"][\"wgs84Resolutions\"];\n    }\n\n    return resolutions;\n  },\n\n  /**\n   * Recuperation des parametres TMS de la configuration\n   *\n   * @function getTileMatrix\n   * @public\n   * @param {String} tmsName - tile matrix set name\n   * @returns {Object} tile matrix set\n   */\n  getTileMatrix: function getTileMatrix(tmsName) {\n    var tms = {};\n\n    if (this.configuration) {\n      if (tmsName) {\n        tms = this.configuration[\"tileMatrixSets\"][tmsName.toUpperCase()];\n      }\n    }\n\n    return tms;\n  },\n\n  /**\n   * Récupération des contraintes générales d'une couche donnée : extent, minScale, maxScale, projection\n   *\n   * @function getGlobalConstraints\n   * @public\n   * @param {String} layerId - identifiant de la couche\n   * @returns {Object} params - contraintes de la couche\n   * @returns {String} params.projection - Projection par défaut de la couche\n   * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche\n   * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche\n   * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche\n   */\n  getGlobalConstraints: function getGlobalConstraints(layerId) {\n    var params = {};\n\n    if (layerId) {\n      // récupération de l'objet de configuration de la couche\n      var layerConf = this.configuration.layers[layerId];\n      params.projection = layerConf.getDefaultProjection();\n      params.minScale = layerConf.getMinScaleDenominator();\n      params.maxScale = layerConf.getMaxScaleDenominator();\n      params.extent = layerConf.getBBOX();\n    }\n\n    return params;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Config);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL0NvbmZpZy5qcz83Zjk1Il0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIkNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJpc0NvbmZpZ0xvYWRlZCIsInNjb3BlIiwid2luZG93Iiwic2VsZiIsImdsb2JhbCIsIkdwIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImdldExheWVySWQiLCJsYXllck5hbWUiLCJzZXJ2aWNlIiwibGF5ZXJJZCIsImxheWVycyIsImtleSIsImhhc093blByb3BlcnR5IiwicGFydHMiLCJzcGxpdCIsInNlcnZpY2VQYXJ0c0xheWVyIiwic2VydmljZVBhcnRzU2VydmljZSIsImVycm9yIiwiZ2V0TGF5ZXJQYXJhbXMiLCJhcGlLZXkiLCJwYXJhbXMiLCJsYXllckNvbmYiLCJhcGlLZXlzIiwidXJsIiwiZ2V0U2VydmVyVXJsIiwidmVyc2lvbiIsImdldFNlcnZpY2VQYXJhbXMiLCJzdHlsZXMiLCJnZXREZWZhdWx0U3R5bGUiLCJmb3JtYXQiLCJnZXREZWZhdWx0Rm9ybWF0IiwicHJvamVjdGlvbiIsImdldERlZmF1bHRQcm9qZWN0aW9uIiwibWluU2NhbGUiLCJnZXRNaW5TY2FsZURlbm9taW5hdG9yIiwibWF4U2NhbGUiLCJnZXRNYXhTY2FsZURlbm9taW5hdG9yIiwiZXh0ZW50IiwiZ2V0QkJPWCIsImxlZ2VuZHMiLCJnZXRMZWdlbmRzIiwibWV0YWRhdGEiLCJnZXRNZXRhZGF0YSIsIm9yaWdpbmF0b3JzIiwiZ2V0T3JpZ2luYXRvcnMiLCJ0aXRsZSIsImdldFRpdGxlIiwiZGVzY3JpcHRpb24iLCJnZXREZXNjcmlwdGlvbiIsInF1aWNrbG9va1VybCIsImdldFF1aWNrbG9va1VybCIsIndtdHNPcHRpb25zIiwidGlsZU1hdHJpeFNldExpbWl0cyIsIlRNU0xpbmsiLCJnZXRUTVNJRCIsInRtc0NvbmYiLCJnZXRUTVNDb25mIiwibWF0cml4T3JpZ2luIiwiZ2V0VG9wTGVmdENvcm5lciIsIm5hdGl2ZVJlc29sdXRpb25zIiwibWF0cml4SWRzIiwidGlsZU1hdHJpY2VzIiwicmVzb3VyY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwia2V5SW5kZXgiLCJnZXRSZXNvbHV0aW9ucyIsInJlc29sdXRpb25zIiwiZ2V0VGlsZU1hdHJpeCIsInRtc05hbWUiLCJ0bXMiLCJ0b1VwcGVyQ2FzZSIsImdldEdsb2JhbENvbnN0cmFpbnRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFFQSxJQUFJQSxNQUFNLEdBQUdDLHFFQUFNLENBQUNDLFNBQVAsQ0FBaUIsUUFBakIsQ0FBYjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQyxNQUFNLEdBQUc7QUFFVDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsZUFBYSxFQUFHLElBUlA7O0FBVVQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxnQkFBYyxFQUFHLDBCQUFZO0FBQ3pCLFFBQUlDLEtBQUssR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxFQUFuSTs7QUFDQSxRQUFJSCxLQUFLLENBQUNJLEVBQU4sSUFBWUosS0FBSyxDQUFDSSxFQUFOLENBQVNQLE1BQXJCLElBQStCUSxNQUFNLENBQUNDLElBQVAsQ0FBWU4sS0FBSyxDQUFDSSxFQUFOLENBQVNQLE1BQXJCLEVBQTZCVSxNQUE3QixLQUF3QyxDQUEzRSxFQUE4RTtBQUMxRTtBQUFrQixXQUFLVCxhQUFOLEdBQXVCRSxLQUFLLENBQUNJLEVBQU4sQ0FBU1AsTUFBaEM7QUFDakIsYUFBTyxJQUFQO0FBQ0g7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alBROztBQW1QVDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lDLGVBQWEsRUFBRyx1QkFBVUMsT0FBVixFQUFtQjtBQUMvQixRQUFJQyxHQUFHLEdBQUcsRUFBVjs7QUFFQSxRQUFJLEtBQUszRSxhQUFULEVBQXdCO0FBQ3BCLFVBQUkwRSxPQUFKLEVBQWE7QUFDVEMsV0FBRyxHQUFHLEtBQUszRSxhQUFMLENBQW1CLGdCQUFuQixFQUFxQzBFLE9BQU8sQ0FBQ0UsV0FBUixFQUFyQyxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxXQUFPRCxHQUFQO0FBQ0gsR0FyUVE7O0FBdVFUO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJRSxzQkFBb0IsRUFBRyw4QkFBVWhFLE9BQVYsRUFBbUI7QUFDdEMsUUFBSVcsTUFBTSxHQUFHLEVBQWI7O0FBRUEsUUFBSVgsT0FBSixFQUFhO0FBQ1Q7QUFDQSxVQUFJWSxTQUFTLEdBQUcsS0FBS3pCLGFBQUwsQ0FBbUJjLE1BQW5CLENBQTBCRCxPQUExQixDQUFoQjtBQUNBVyxZQUFNLENBQUNXLFVBQVAsR0FBb0JWLFNBQVMsQ0FBQ1csb0JBQVYsRUFBcEI7QUFDQVosWUFBTSxDQUFDYSxRQUFQLEdBQWtCWixTQUFTLENBQUNhLHNCQUFWLEVBQWxCO0FBQ0FkLFlBQU0sQ0FBQ2UsUUFBUCxHQUFrQmQsU0FBUyxDQUFDZSxzQkFBVixFQUFsQjtBQUNBaEIsWUFBTSxDQUFDaUIsTUFBUCxHQUFnQmhCLFNBQVMsQ0FBQ2lCLE9BQVYsRUFBaEI7QUFDSDs7QUFFRCxXQUFPbEIsTUFBUDtBQUNIO0FBaFNRLENBQWI7QUFtU2V6QixxRUFBZixFIiwiZmlsZSI6Ii4vc3JjL0NvbW1vbi9VdGlscy9Db25maWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cbnZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiY29uZmlnXCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgQ29uZmlnXG4gKiBAYWxpYXMgW3ByaXZhdGVdIENvbmZpZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAuLi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNDb25maWdMb2FkZWQoKTtcbiAqIGdldExheWVySWQoKTtcbiAqIGdldExheWVyUGFyYW1zKCk7XG4gKiBnZXRTZXJ2aWNlUGFyYW1zKCk7XG4gKiBnZXRSZXNvbHV0aW9ucygpO1xuICogZ2V0R2xvYmFsQ29uc3RyYWludHMoKTtcbiAqIGdldFRpbGVNYXRyaXgoKTtcbiAqL1xudmFyIENvbmZpZyA9IHtcblxuICAgIC8qKlxuICAgICAqIGF1dG9jb25mXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBjb25maWd1cmF0aW9uIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xlIGR1IGNoYXJnZW1lbnQgZGUgbCdhdXRvY29uZlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGlzQ29uZmlnTG9hZGVkXG4gICAgICogQHRoaXMgQ29uZmlnXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIHNpIGwnYXV0b2NvbmYgYSBkw6lqw6Agw6l0w6kgY2hhcmfDqWUsIEZhbHNlIHNpbm9uLlxuICAgICAqL1xuICAgIGlzQ29uZmlnTG9hZGVkIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xuICAgICAgICBpZiAoc2NvcGUuR3AgJiYgc2NvcGUuR3AuQ29uZmlnICYmIE9iamVjdC5rZXlzKHNjb3BlLkdwLkNvbmZpZykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvKiogdHMtc3ludGF4ICovICh0aGlzLmNvbmZpZ3VyYXRpb24pID0gc2NvcGUuR3AuQ29uZmlnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cGVyYXRpb24gZGUgbCdpZGVudGlmaWFudCBkJ3VuZSBjb3VjaGUgZG9ubsOpZVxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGdldExheWVySWRcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSAtIG5vbSBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZSAgIC0gbm9tIGR1IHNlcnZpY2UgKHBhciBleC4gXCJXTVNcIiBvdSBcIldNVFNcIilcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBJZGVudGlmaWFudCBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1MkR0VPUE9SVEFJTDpPR0M6V01UU1wiKVxuICAgICAqL1xuICAgIGdldExheWVySWQgOiBmdW5jdGlvbiAobGF5ZXJOYW1lLCBzZXJ2aWNlKSB7XG4gICAgICAgIHZhciBsYXllcklkID0gbnVsbDtcblxuICAgICAgICAvLyBsYXllclxuICAgICAgICAvLyBrZXkgOiBbbGF5ZXJOYW1lXSRbY29udGV4dGVdOk9HQzpbc2VydmljZV1cbiAgICAgICAgLy8gZXggOiBcIk9SVEhPSU1BR0VSWS5PUlRIT1BIT1RPUyRHRU9QT1JUQUlMOk9HQzpXTVRTXCJcblxuICAgICAgICAvLyBzZXJ2aWNlXG4gICAgICAgIC8vIGtleSA6IFtsYXllck5hbWVdJFtjb250ZXh0ZV07W3NlcnZpY2VdXG4gICAgICAgIC8vIGV4IDogUG9zaXRpb25PZkludGVyZXN0JE9HQzpPUEVOTFM7UmV2ZXJzZUdlb2NvZGVcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5jb25maWd1cmF0aW9uW1wibGF5ZXJzXCJdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGxheWVycykge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoXCIkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJOYW1lID09PSBwYXJ0c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZpY2VQYXJ0c0xheWVyID0gcGFydHNbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2aWNlUGFydHNTZXJ2aWNlID0gcGFydHNbMV0uc3BsaXQoXCI7XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VQYXJ0c1NlcnZpY2VbMV0gPT09IHNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlUGFydHNMYXllclsyXSA9PT0gc2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcklkID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXllcklkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFUlJPUiBsYXllciBpZCAobGF5ZXIgbmFtZTogXCIgKyBsYXllck5hbWUgKyBcIiAvIHNlcnZpY2U6IFwiICsgc2VydmljZSArIFwiKSB3YXMgbm90IGZvdW5kICE/XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVySWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBuw6ljZXNzYWlyZXMgw6AgbCdhZmZpY2hhZ2UgZCd1bmUgY291Y2hlIFdNUyBvdSBXTVRTXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gZ2V0TGF5ZXJQYXJhbXNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSAtIG5vbSBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZSAgIC0gbm9tIGR1IHNlcnZpY2UgKHBhciBleC4gXCJXTVNcIiBvdSBcIldNVFNcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FwaUtleV0gIC0gQ2zDqSBkZSBjb250cmF0IEFQSVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBhcmFtcyAgLSBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlIChXTVMgb3UgV01UUykgcG91ciBsYSBjb3VjaGUgZG9ubsOpZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy51cmwgICAgICAgIC0gVXJsIGR1IHNlcnZpY2Ugw6AgcmVxdcOqdGVyIHBvdXIgYWZmaWNoZXIgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcGFyYW1zLnZlcnNpb24gICAgLSBWZXJzaW9uIGR1IHNlcnZpY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuc3R5bGVzICAgICAtIFN0eWxlIHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5mb3JtYXQgICAgIC0gRm9ybWF0IHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5wcm9qZWN0aW9uIC0gUHJvamVjdGlvbiBwYXIgZMOpZmF1dCBkZSBsYSBjb3VjaGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBwYXJhbXMubWluU2NhbGUgICAtIETDqW5vbWluYXRldXIgZCfDqWNoZWxsZSBtaW5pbXVtIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBhcmFtcy5tYXhTY2FsZSAgIC0gRMOpbm9taW5hdGV1ciBkJ8OpY2hlbGxlIG1heGltdW0gZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0dwLkJCb3h9IHBhcmFtcy5leHRlbnQgICAgLSBFdGVuZHVlIGRlIGxhIGNvdWNoZSwgZGFucyBsYSBwcm9qZWN0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLmxlZ2VuZHMgICAgIC0gVGFibGVhdSBkZXMgbMOpZ2VuZGVzIGFzc29jacOpZXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMubWV0YWRhdGEgICAgLSBUYWJsZWF1IGRlcyBtw6l0YWRvbm7DqWVzIGFzc29jacOpZXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMub3JpZ2luYXRvcnMgLSBUYWJsZWF1IGRlcyBvcmlnaW5hdG9ycyBhc3NvY2nDqXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMudGl0bGUgICAgICAgLSBOb20gZGUgbGEgcmVzb3VyY2UsIGxpc2libGUgcGFyIHVuIGh1bWFpbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIFVybCBkZSBsJ2ltYWdlIGQnYXBlcsOndSByYXBpZGUgZGUgbGEgcmVzc291cmNlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLnF1aWNrbG9va1VybC0gVGFibGVhdSBkZXMgb3JpZ2luYXRvcnMgYXNzb2Npw6lzIMOgIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5bVE1TTGlua10gICAgICAgICAgLSBJZGVudGlmaWFudCBkZSBsYSBweXJhbWlkZSAoVE1TKSwgZGFucyBsZSBjYXMgZCd1bmUgY291Y2hlIFdNVFNcbiAgICAgKiBAcmV0dXJucyB7R3AuUG9pbnR9IHBhcmFtcy5bbWF0cml4T3JpZ2luXSAgIC0gT3JpZ2luZSBkZSBsYSBtYXRyaWNlICh0b3AgbGVmdCBjb3JuZXIpLCBkYW5zIGxlIGNhcyBkJ3VuZSBjb3VjaGUgV01UU1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLltuYXRpdmVSZXNvbHV0aW9uc10gLSBUYWJsZWF1IHJlZ3JvdXBhbnQgbGVzIHLDqXNvbHV0aW9ucyBkZSBjaGFxdWUgbml2ZWF1IGRlIGxhIG1hdHJpY2UsIGRhbnMgbGUgY2FzIGQndW5lIGNvdWNoZSBXTVRTXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMuW21hdHJpeElkc10gICAgICAgICAtIFRhYmxlYXUgcmVncm91cGFudCBsZXMgaWRlbnRpZmlhbnRzIGRlIGNoYXF1ZSBuaXZlYXUgZGUgbGEgbWF0cmljZSwgZGFucyBsZSBjYXMgZCd1bmUgY291Y2hlIFdNVFNcbiAgICAgKi9cbiAgICBnZXRMYXllclBhcmFtcyA6IGZ1bmN0aW9uIChsYXllck5hbWUsIHNlcnZpY2UsIGFwaUtleSkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCdpZGVudGlmaWFudCBjb21wbGV0IGRlIGxhIGNvdWNoZS5cbiAgICAgICAgICAgIHZhciBsYXllcklkID0gdGhpcy5nZXRMYXllcklkKGxheWVyTmFtZSwgc2VydmljZSk7XG5cbiAgICAgICAgICAgIGlmIChsYXllcklkKSB7XG4gICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCdvYmpldCBkZSBjb25maWd1cmF0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubGF5ZXJzW2xheWVySWRdO1xuXG4gICAgICAgICAgICAgICAgLy8gY29udHJvbGUgZGUgbGEgY2xlZlxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBsYXllckNvbmYuYXBpS2V5c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcGlLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRVJST1IgZGlmZmVyZW50IGtleXMgKFwiICsgYXBpS2V5ICsgXCIgIT09IFwiICsga2V5ICsgXCIpICE/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXBpS2V5ID0gYXBpS2V5IHx8IGtleTtcbiAgICAgICAgICAgICAgICBwYXJhbXMua2V5ID0gYXBpS2V5O1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IGxheWVyQ29uZi5nZXRTZXJ2ZXJVcmwoYXBpS2V5KTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmVyc2lvbiA9IGxheWVyQ29uZi5nZXRTZXJ2aWNlUGFyYW1zKCkudmVyc2lvbjtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3R5bGVzID0gbGF5ZXJDb25mLmdldERlZmF1bHRTdHlsZSgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSBsYXllckNvbmYuZ2V0RGVmYXVsdEZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wcm9qZWN0aW9uID0gbGF5ZXJDb25mLmdldERlZmF1bHRQcm9qZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZXMgaW5mb3MgZGUgbGEgY291Y2hlXG4gICAgICAgICAgICAgICAgcGFyYW1zLm1pblNjYWxlID0gbGF5ZXJDb25mLmdldE1pblNjYWxlRGVub21pbmF0b3IoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMubWF4U2NhbGUgPSBsYXllckNvbmYuZ2V0TWF4U2NhbGVEZW5vbWluYXRvcigpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5leHRlbnQgPSBsYXllckNvbmYuZ2V0QkJPWCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5sZWdlbmRzID0gbGF5ZXJDb25mLmdldExlZ2VuZHMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMubWV0YWRhdGEgPSBsYXllckNvbmYuZ2V0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMub3JpZ2luYXRvcnMgPSBsYXllckNvbmYuZ2V0T3JpZ2luYXRvcnMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudGl0bGUgPSBsYXllckNvbmYuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGVzY3JpcHRpb24gPSBsYXllckNvbmYuZ2V0RGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMucXVpY2tsb29rVXJsID0gbGF5ZXJDb25mLmdldFF1aWNrbG9va1VybCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gV01UUyA6IHLDqWN1cMOpcmF0aW9uIGRlcyB0aWxlTWF0cml4U2V0TGltaXRzXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyQ29uZi53bXRzT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGlsZU1hdHJpeFNldExpbWl0cyA9IGxheWVyQ29uZi53bXRzT3B0aW9ucy50aWxlTWF0cml4U2V0TGltaXRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdNVFMgOiByw6ljdXDDqXJhdGlvbiBkZXMgcGFyYW3DqHRyZXMgZGUgbGEgcHlyYW1pZGUgKFRNUylcbiAgICAgICAgICAgICAgICB2YXIgVE1TTGluayA9IGxheWVyQ29uZi5nZXRUTVNJRCgpO1xuICAgICAgICAgICAgICAgIGlmIChUTVNMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5UTVNMaW5rID0gVE1TTGluaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtc0NvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24uZ2V0VE1TQ29uZihUTVNMaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG1hdHJpeCBvcmlnaW4gOiBHcC5Qb2ludCA9IE9iamVjdHt4OkZsb2F0LCB5OkZsb2F0fVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubWF0cml4T3JpZ2luID0gdG1zQ29uZi5nZXRUb3BMZWZ0Q29ybmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5uYXRpdmVSZXNvbHV0aW9ucyA9IHRtc0NvbmYubmF0aXZlUmVzb2x1dGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5tYXRyaXhJZHMgPSB0bXNDb25mLm1hdHJpeElkcztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRpbGVNYXRyaWNlcyA9IHRtc0NvbmYudGlsZU1hdHJpY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlY3VwZXJhdGlvbiBkZXMgcGFyYW1ldHJlcyBkJ3VuIHNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBnZXRTZXJ2aWNlUGFyYW1zXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVzb3VyY2VdIC0gXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJTdHJlZXRBZGRyZXNzXCIsIFwiVm9pdHVyZVwiLCBcIlBpZXRvblwiLCAuLi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlcnZpY2VdIC0gR2VvY29kZSwgSXRpbmVyYWlyZSwgLi4uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FwaUtleXNdICAtIENsw6kocykgZGUgY29udHJhdCBBUElcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbcOodHJlcyBkZSBsYSByZXNzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlUGFyYW1zIDogZnVuY3Rpb24gKHJlc291cmNlLCBzZXJ2aWNlLCBhcGlLZXlzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZSBsJ2lkZW50aWZpYW50IGNvbXBsZXQgZGUgbGEgY291Y2hlLlxuICAgICAgICAgICAgdmFyIGxheWVySWQgPSB0aGlzLmdldExheWVySWQocmVzb3VyY2UsIHNlcnZpY2UpO1xuXG4gICAgICAgICAgICBpZiAobGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlIGwnb2JqZXQgZGUgY29uZmlndXJhdGlvbiBkZSBsYSBjb3VjaGVcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJDb25mID0gdGhpcy5jb25maWd1cmF0aW9uLmxheWVyc1tsYXllcklkXTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRyb2xlIGRlIGxhIGNsZWYgKG9uIHByZW5kIGxhIHByZW1pw6hyZSBjbMOpIGRpc3BvbmlibGUgcXVpIGVzdCBjZW5zw6llIGF2b2lyIGFjY8OocyDDoCBsYSByZXNzb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGxheWVyQ29uZi5hcGlLZXlzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcGlLZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5cyA9IFthcGlLZXlzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFwaUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcGlLZXlzW2ldID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHNpIGF1Y3VuZSBjbMOpIGR1IHRhYmxlYXUgYXBpS2V5cyBuZSBjb3JyZXNwb25kLCBvbiByZXRvdXJuZSByaWVuID0+IHBhcyBkZSBkcm9pdHMgcG91ciBsYSByZXNzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXlJbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb24gcmV0b3VybmUgbGEgcHJlbWnDqHJlIGNsw6kgcXVpIGEgZWZmZWN0aXZlbWVudCBhY2PDqHMgw6AgbGEgcmVzc291cmNlXG4gICAgICAgICAgICAgICAgdmFyIGFwaUtleSA9IGFwaUtleXNba2V5SW5kZXhdIHx8IGtleTtcbiAgICAgICAgICAgICAgICBwYXJhbXMua2V5ID0gYXBpS2V5O1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IGxheWVyQ29uZi5nZXRTZXJ2ZXJVcmwoYXBpS2V5KTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmVyc2lvbiA9IGxheWVyQ29uZi5nZXRTZXJ2aWNlUGFyYW1zKCkudmVyc2lvbjtcblxuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBpbmZvcyBkZSBsYSBjb3VjaGVcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXh0ZW50ID0gbGF5ZXJDb25mLmdldEJCT1goKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudGl0bGUgPSBsYXllckNvbmYuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGVzY3JpcHRpb24gPSBsYXllckNvbmYuZ2V0RGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc29sdXRpb24gZW4gZ2VvZ3JhcGhpcXVlXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbnNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge0FycmF5fSByZXNvbHV0aW9uc1xuICAgICAqL1xuICAgIGdldFJlc29sdXRpb25zIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXNvbHV0aW9ucyA9IHRoaXMuY29uZmlndXJhdGlvbltcImdlbmVyYWxPcHRpb25zXCJdW1wid2dzODRSZXNvbHV0aW9uc1wiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHV0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVjdXBlcmF0aW9uIGRlcyBwYXJhbWV0cmVzIFRNUyBkZSBsYSBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gZ2V0VGlsZU1hdHJpeFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG1zTmFtZSAtIHRpbGUgbWF0cml4IHNldCBuYW1lXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGlsZSBtYXRyaXggc2V0XG4gICAgICovXG4gICAgZ2V0VGlsZU1hdHJpeCA6IGZ1bmN0aW9uICh0bXNOYW1lKSB7XG4gICAgICAgIHZhciB0bXMgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodG1zTmFtZSkge1xuICAgICAgICAgICAgICAgIHRtcyA9IHRoaXMuY29uZmlndXJhdGlvbltcInRpbGVNYXRyaXhTZXRzXCJdW3Rtc05hbWUudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSw6ljdXDDqXJhdGlvbiBkZXMgY29udHJhaW50ZXMgZ8OpbsOpcmFsZXMgZCd1bmUgY291Y2hlIGRvbm7DqWUgOiBleHRlbnQsIG1pblNjYWxlLCBtYXhTY2FsZSwgcHJvamVjdGlvblxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGdldEdsb2JhbENvbnN0cmFpbnRzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gaWRlbnRpZmlhbnQgZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFyYW1zIC0gY29udHJhaW50ZXMgZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcGFyYW1zLnByb2plY3Rpb24gLSBQcm9qZWN0aW9uIHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBhcmFtcy5taW5TY2FsZSAgIC0gRMOpbm9taW5hdGV1ciBkJ8OpY2hlbGxlIG1pbmltdW0gZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge051bWJlcn0gcGFyYW1zLm1heFNjYWxlICAgLSBEw6lub21pbmF0ZXVyIGQnw6ljaGVsbGUgbWF4aW11bSBkZSBsYSBjb3VjaGVcbiAgICAgKiBAcmV0dXJucyB7R3AuQkJveH0gcGFyYW1zLmV4dGVudCAgICAtIEV0ZW5kdWUgZGUgbGEgY291Y2hlLCBkYW5zIGxhIHByb2plY3Rpb24gZGUgbGEgY291Y2hlXG4gICAgICovXG4gICAgZ2V0R2xvYmFsQ29uc3RyYWludHMgOiBmdW5jdGlvbiAobGF5ZXJJZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICAgICAgaWYgKGxheWVySWQpIHtcbiAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlIGwnb2JqZXQgZGUgY29uZmlndXJhdGlvbiBkZSBsYSBjb3VjaGVcbiAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubGF5ZXJzW2xheWVySWRdO1xuICAgICAgICAgICAgcGFyYW1zLnByb2plY3Rpb24gPSBsYXllckNvbmYuZ2V0RGVmYXVsdFByb2plY3Rpb24oKTtcbiAgICAgICAgICAgIHBhcmFtcy5taW5TY2FsZSA9IGxheWVyQ29uZi5nZXRNaW5TY2FsZURlbm9taW5hdG9yKCk7XG4gICAgICAgICAgICBwYXJhbXMubWF4U2NhbGUgPSBsYXllckNvbmYuZ2V0TWF4U2NhbGVEZW5vbWluYXRvcigpO1xuICAgICAgICAgICAgcGFyYW1zLmV4dGVudCA9IGxheWVyQ29uZi5nZXRCQk9YKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Utils/Config.js\n");

/***/ }),

/***/ "./src/Common/Utils/LoggerByDefault.js":
/*!*********************************************!*\
  !*** ./src/Common/Utils/LoggerByDefault.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * @module LoggerByDefault\n * @alias [private] LoggerByDefault\n * @description\n * ...\n *\n * @example\n * getLogger();\n * disableAll();\n * enableAll();\n */\n\nvar LoggerByDefault = {\n  /**\n   * creation d'un logger statique\n   *\n   * @function getLogger\n   * @param {String} [name=\"default\"] - the logger name\n   * @returns {Object} logger\n   */\n  getLogger: function getLogger(name) {\n    // INFO :\n    // à la compilation en mode production, on substitue false\n    // avec \"true\", ceci desactive les loggers !\n    //\n    // à la compilation en mode developpement, on substitue false\n    // avec \"false\", ceci permet d'avoir les loggers actifs !\n    //\n    // lors d'une utilisation en module es6, il n'y a pas de substitution de false,\n    // les loggers sont donc actifs par defaut !\n    //\n    // > Substitute global constants configured at compile time\n    // cf. webpack.config.js\n    // on masque cette constante afin d'eviter \"referenceerror not defined\"\n    \"false\".match(/true/) ? loglevel__WEBPACK_IMPORTED_MODULE_0__[\"disableAll\"]() : loglevel__WEBPACK_IMPORTED_MODULE_0__[\"enableAll\"]();\n    var logname = name || \"default\";\n    return loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"](logname);\n  },\n\n  /**\n   * desactive tous les loggers\n   * @function disableAll\n   */\n  disableAll: function disableAll() {\n    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLoggers\"]();\n\n    for (var key in loggers) {\n      if (Object.hasOwnProperty.call(loggers, key)) {\n        var logger = loggers[key];\n        logger.disableAll();\n      }\n    }\n  },\n\n  /**\n   * active tous les loggers\n   * @function enableAll\n   */\n  enableAll: function enableAll() {\n    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLoggers\"]();\n\n    for (var key in loggers) {\n      if (Object.hasOwnProperty.call(loggers, key)) {\n        var logger = loggers[key];\n        logger.enableAll();\n      }\n    }\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (LoggerByDefault);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcz81YzkwIl0sIm5hbWVzIjpbIkxvZ2dlckJ5RGVmYXVsdCIsImdldExvZ2dlciIsIm5hbWUiLCJtYXRjaCIsIkxvZyIsImxvZ25hbWUiLCJkaXNhYmxlQWxsIiwibG9nZ2VycyIsImtleSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImxvZ2dlciIsImVuYWJsZUFsbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQUlBLGVBQWUsR0FBRztBQUNsQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxXQUFTLEVBQUcsbUJBQVVDLElBQVYsRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQyxxQkFBaUJDLEtBQWpCLENBQXVCLE1BQXZCLENBQUQsR0FBbUNDLG1EQUFBLEVBQW5DLEdBQXNEQSxrREFBQSxFQUF0RDtBQUNBLFFBQUlDLE9BQU8sR0FBR0gsSUFBSSxJQUFJLFNBQXRCO0FBQ0EsV0FBT0Usa0RBQUEsQ0FBY0MsT0FBZCxDQUFQO0FBQ0gsR0F6QmlCOztBQTBCbEI7QUFDSjtBQUNBO0FBQ0E7QUFDSUMsWUFBVSxFQUFHLHNCQUFZO0FBQ3JCLFFBQUlDLE9BQU8sR0FBR0gsbURBQUEsRUFBZDs7QUFDQSxTQUFLLElBQU1JLEdBQVgsSUFBa0JELE9BQWxCLEVBQTJCO0FBQ3ZCLFVBQUlFLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsSUFBdEIsQ0FBMkJKLE9BQTNCLEVBQW9DQyxHQUFwQyxDQUFKLEVBQThDO0FBQzFDLFlBQU1JLE1BQU0sR0FBR0wsT0FBTyxDQUFDQyxHQUFELENBQXRCO0FBQ0FJLGNBQU0sQ0FBQ04sVUFBUDtBQUNIO0FBQ0o7QUFDSixHQXRDaUI7O0FBdUNsQjtBQUNKO0FBQ0E7QUFDQTtBQUNJTyxXQUFTLEVBQUcscUJBQVk7QUFDcEIsUUFBSU4sT0FBTyxHQUFHSCxtREFBQSxFQUFkOztBQUNBLFNBQUssSUFBTUksR0FBWCxJQUFrQkQsT0FBbEIsRUFBMkI7QUFDdkIsVUFBSUUsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxJQUF0QixDQUEyQkosT0FBM0IsRUFBb0NDLEdBQXBDLENBQUosRUFBOEM7QUFDMUMsWUFBTUksTUFBTSxHQUFHTCxPQUFPLENBQUNDLEdBQUQsQ0FBdEI7QUFDQUksY0FBTSxDQUFDQyxTQUFQO0FBQ0g7QUFDSjtBQUNKO0FBbkRpQixDQUF0QjtBQXNEZWIsOEVBQWYiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIExvZyBmcm9tIFwibG9nbGV2ZWxcIjtcblxuLyoqXG4gKiBAbW9kdWxlIExvZ2dlckJ5RGVmYXVsdFxuICogQGFsaWFzIFtwcml2YXRlXSBMb2dnZXJCeURlZmF1bHRcbiAqIEBkZXNjcmlwdGlvblxuICogLi4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGdldExvZ2dlcigpO1xuICogZGlzYWJsZUFsbCgpO1xuICogZW5hYmxlQWxsKCk7XG4gKi9cbnZhciBMb2dnZXJCeURlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogY3JlYXRpb24gZCd1biBsb2dnZXIgc3RhdGlxdWVcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBnZXRMb2dnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9XCJkZWZhdWx0XCJdIC0gdGhlIGxvZ2dlciBuYW1lXG4gICAgICogQHJldHVybnMge09iamVjdH0gbG9nZ2VyXG4gICAgICovXG4gICAgZ2V0TG9nZ2VyIDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgLy8gSU5GTyA6XG4gICAgICAgIC8vIMOgIGxhIGNvbXBpbGF0aW9uIGVuIG1vZGUgcHJvZHVjdGlvbiwgb24gc3Vic3RpdHVlIF9fUFJPRFVDVElPTl9fXG4gICAgICAgIC8vIGF2ZWMgXCJ0cnVlXCIsIGNlY2kgZGVzYWN0aXZlIGxlcyBsb2dnZXJzICFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gw6AgbGEgY29tcGlsYXRpb24gZW4gbW9kZSBkZXZlbG9wcGVtZW50LCBvbiBzdWJzdGl0dWUgX19QUk9EVUNUSU9OX19cbiAgICAgICAgLy8gYXZlYyBcImZhbHNlXCIsIGNlY2kgcGVybWV0IGQnYXZvaXIgbGVzIGxvZ2dlcnMgYWN0aWZzICFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9ycyBkJ3VuZSB1dGlsaXNhdGlvbiBlbiBtb2R1bGUgZXM2LCBpbCBuJ3kgYSBwYXMgZGUgc3Vic3RpdHV0aW9uIGRlIF9fUFJPRFVDVElPTl9fLFxuICAgICAgICAvLyBsZXMgbG9nZ2VycyBzb250IGRvbmMgYWN0aWZzIHBhciBkZWZhdXQgIVxuICAgICAgICAvL1xuICAgICAgICAvLyA+IFN1YnN0aXR1dGUgZ2xvYmFsIGNvbnN0YW50cyBjb25maWd1cmVkIGF0IGNvbXBpbGUgdGltZVxuICAgICAgICAvLyBjZi4gd2VicGFjay5jb25maWcuanNcbiAgICAgICAgLy8gb24gbWFzcXVlIGNldHRlIGNvbnN0YW50ZSBhZmluIGQnZXZpdGVyIFwicmVmZXJlbmNlZXJyb3Igbm90IGRlZmluZWRcIlxuICAgICAgICAoXCJfX1BST0RVQ1RJT05fX1wiLm1hdGNoKC90cnVlLykpID8gTG9nLmRpc2FibGVBbGwoKSA6IExvZy5lbmFibGVBbGwoKTtcbiAgICAgICAgdmFyIGxvZ25hbWUgPSBuYW1lIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICByZXR1cm4gTG9nLmdldExvZ2dlcihsb2duYW1lKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRlc2FjdGl2ZSB0b3VzIGxlcyBsb2dnZXJzXG4gICAgICogQGZ1bmN0aW9uIGRpc2FibGVBbGxcbiAgICAgKi9cbiAgICBkaXNhYmxlQWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nZ2VycyA9IExvZy5nZXRMb2dnZXJzKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGxvZ2dlcnMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChsb2dnZXJzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nZ2VyID0gbG9nZ2Vyc1trZXldO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kaXNhYmxlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGFjdGl2ZSB0b3VzIGxlcyBsb2dnZXJzXG4gICAgICogQGZ1bmN0aW9uIGVuYWJsZUFsbFxuICAgICAqL1xuICAgIGVuYWJsZUFsbCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvZ2dlcnMgPSBMb2cuZ2V0TG9nZ2VycygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBsb2dnZXJzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobG9nZ2Vycywga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGxvZ2dlcnNba2V5XTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZW5hYmxlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2dnZXJCeURlZmF1bHQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Common/Utils/LoggerByDefault.js\n");

/***/ }),

/***/ "./src/Common/Utils/SelectorID.js":
/*!****************************************!*\
  !*** ./src/Common/Utils/SelectorID.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @module SelectorID\n * @alias [private] SelectorID\n * @description\n * formalisme d'un tag ID :\n * -> NAME(_ORDER)-1460636385836\n *\n * @example\n * Ex.\n *   GProutePoints-1460636385836\n *   GProutePoint_10-1460636385836\n */\nvar SelectorID = {\n  /**\n   * Construction d'un identifiant statique basé sur le timestamp,\n   * et qui s'incremente de +1 à chaque appel\n   * @function generate\n   */\n  generate: function () {\n    var timestamp = Math.floor(Date.now());\n    return function () {\n      return timestamp++;\n    };\n  }(),\n\n  /**\n   * nom du tag\n   * @function name\n   * @param {String} id - the id\n   * @returns {String} index\n   */\n  name: function name(id) {\n    var name = null;\n    var i = id.lastIndexOf(\"-\");\n\n    if (i === -1) {\n      name = id;\n    } else {\n      name = id.substring(0, i);\n    }\n\n    return name;\n  },\n\n  /**\n   * numero d'identifiant du tag\n   *\n   * @function index\n   * @param {String} id - the id\n   * @returns {String} index\n   */\n  index: function index(id) {\n    var index = null;\n    var name = this.name(id); // if (name !== id) {\n\n    var i = name.lastIndexOf(\"_\");\n\n    if (i !== -1) {\n      index = name.substring(i + 1);\n    } // }\n\n\n    return index;\n  },\n\n  /**\n   * uuid du tag\n   *\n   * @function uuid\n   * @param {String} id - the id\n   * @returns {String} uuid\n   */\n  uuid: function uuid(id) {\n    var uuid = null;\n    var i = id.lastIndexOf(\"-\");\n\n    if (i !== -1) {\n      uuid = parseInt(id.substring(i + 1), 10);\n    }\n\n    return uuid;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (SelectorID);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvQ29tbW9uL1V0aWxzL1NlbGVjdG9ySUQuanM/ZTZjNSJdLCJuYW1lcyI6WyJTZWxlY3RvcklEIiwiZ2VuZXJhdGUiLCJ0aW1lc3RhbXAiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwibmFtZSIsImlkIiwiaSIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwiaW5kZXgiLCJ1dWlkIiwicGFyc2VJbnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSUEsVUFBVSxHQUFHO0FBRWI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxVQUFRLEVBQUksWUFBWTtBQUNwQixRQUFJQyxTQUFTLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxJQUFJLENBQUNDLEdBQUwsRUFBWCxDQUFoQjtBQUNBLFdBQU8sWUFBWTtBQUNmLGFBQU9KLFNBQVMsRUFBaEI7QUFDSCxLQUZEO0FBR0gsR0FMVSxFQVBFOztBQWNiO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJSyxNQUFJLEVBQUcsY0FBVUMsRUFBVixFQUFjO0FBQ2pCLFFBQUlELElBQUksR0FBRyxJQUFYO0FBRUEsUUFBSUUsQ0FBQyxHQUFHRCxFQUFFLENBQUNFLFdBQUgsQ0FBZSxHQUFmLENBQVI7O0FBQ0EsUUFBSUQsQ0FBQyxLQUFLLENBQUMsQ0FBWCxFQUFjO0FBQ1ZGLFVBQUksR0FBR0MsRUFBUDtBQUNILEtBRkQsTUFFTztBQUNIRCxVQUFJLEdBQUdDLEVBQUUsQ0FBQ0csU0FBSCxDQUFhLENBQWIsRUFBZ0JGLENBQWhCLENBQVA7QUFDSDs7QUFFRCxXQUFPRixJQUFQO0FBQ0gsR0EvQlk7O0FBaUNiO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lLLE9BQUssRUFBRyxlQUFVSixFQUFWLEVBQWM7QUFDbEIsUUFBSUksS0FBSyxHQUFHLElBQVo7QUFFQSxRQUFJTCxJQUFJLEdBQUcsS0FBS0EsSUFBTCxDQUFVQyxFQUFWLENBQVgsQ0FIa0IsQ0FJbEI7O0FBQ0EsUUFBSUMsQ0FBQyxHQUFHRixJQUFJLENBQUNHLFdBQUwsQ0FBaUIsR0FBakIsQ0FBUjs7QUFDQSxRQUFJRCxDQUFDLEtBQUssQ0FBQyxDQUFYLEVBQWM7QUFDVkcsV0FBSyxHQUFHTCxJQUFJLENBQUNJLFNBQUwsQ0FBZUYsQ0FBQyxHQUFHLENBQW5CLENBQVI7QUFDSCxLQVJpQixDQVNsQjs7O0FBRUEsV0FBT0csS0FBUDtBQUNILEdBcERZOztBQXNEYjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxNQUFJLEVBQUcsY0FBVUwsRUFBVixFQUFjO0FBQ2pCLFFBQUlLLElBQUksR0FBRyxJQUFYO0FBRUEsUUFBSUosQ0FBQyxHQUFHRCxFQUFFLENBQUNFLFdBQUgsQ0FBZSxHQUFmLENBQVI7O0FBQ0EsUUFBSUQsQ0FBQyxLQUFLLENBQUMsQ0FBWCxFQUFjO0FBQ1ZJLFVBQUksR0FBR0MsUUFBUSxDQUFDTixFQUFFLENBQUNHLFNBQUgsQ0FBYUYsQ0FBQyxHQUFHLENBQWpCLENBQUQsRUFBc0IsRUFBdEIsQ0FBZjtBQUNIOztBQUVELFdBQU9JLElBQVA7QUFDSDtBQXRFWSxDQUFqQjtBQTBFZWIseUVBQWYiLCJmaWxlIjoiLi9zcmMvQ29tbW9uL1V0aWxzL1NlbGVjdG9ySUQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgU2VsZWN0b3JJRFxuICogQGFsaWFzIFtwcml2YXRlXSBTZWxlY3RvcklEXG4gKiBAZGVzY3JpcHRpb25cbiAqIGZvcm1hbGlzbWUgZCd1biB0YWcgSUQgOlxuICogLT4gTkFNRShfT1JERVIpLTE0NjA2MzYzODU4MzZcbiAqXG4gKiBAZXhhbXBsZVxuICogRXguXG4gKiAgIEdQcm91dGVQb2ludHMtMTQ2MDYzNjM4NTgzNlxuICogICBHUHJvdXRlUG9pbnRfMTAtMTQ2MDYzNjM4NTgzNlxuICovXG52YXIgU2VsZWN0b3JJRCA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGlvbiBkJ3VuIGlkZW50aWZpYW50IHN0YXRpcXVlIGJhc8OpIHN1ciBsZSB0aW1lc3RhbXAsXG4gICAgICogZXQgcXVpIHMnaW5jcmVtZW50ZSBkZSArMSDDoCBjaGFxdWUgYXBwZWxcbiAgICAgKiBAZnVuY3Rpb24gZ2VuZXJhdGVcbiAgICAgKi9cbiAgICBnZW5lcmF0ZSA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcCsrO1xuICAgICAgICB9O1xuICAgIH0pKCksXG5cbiAgICAvKipcbiAgICAgKiBub20gZHUgdGFnXG4gICAgICogQGZ1bmN0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpbmRleFxuICAgICAqL1xuICAgIG5hbWUgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuXG4gICAgICAgIHZhciBpID0gaWQubGFzdEluZGV4T2YoXCItXCIpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5hbWUgPSBpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBpZC5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbnVtZXJvIGQnaWRlbnRpZmlhbnQgZHUgdGFnXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpbmRleFxuICAgICAqL1xuICAgIGluZGV4IDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG51bGw7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUoaWQpO1xuICAgICAgICAvLyBpZiAobmFtZSAhPT0gaWQpIHtcbiAgICAgICAgdmFyIGkgPSBuYW1lLmxhc3RJbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleCA9IG5hbWUuc3Vic3RyaW5nKGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1dWlkIGR1IHRhZ1xuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIHV1aWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1dWlkXG4gICAgICovXG4gICAgdXVpZCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgdXVpZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGkgPSBpZC5sYXN0SW5kZXhPZihcIi1cIik7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdXVpZCA9IHBhcnNlSW50KGlkLnN1YnN0cmluZyhpICsgMSksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dWlkO1xuICAgIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0b3JJRDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Common/Utils/SelectorID.js\n");

/***/ }),

/***/ "./src/Leaflet/CSS/Controls/ElevationPath/GPelevationPathLeaflet.css":
/*!***************************************************************************!*\
  !*** ./src/Leaflet/CSS/Controls/ElevationPath/GPelevationPathLeaflet.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9DU1MvQ29udHJvbHMvRWxldmF0aW9uUGF0aC9HUGVsZXZhdGlvblBhdGhMZWFmbGV0LmNzcz9kMTJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vc3JjL0xlYWZsZXQvQ1NTL0NvbnRyb2xzL0VsZXZhdGlvblBhdGgvR1BlbGV2YXRpb25QYXRoTGVhZmxldC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Leaflet/CSS/Controls/ElevationPath/GPelevationPathLeaflet.css\n");

/***/ }),

/***/ "./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css":
/*!****************************************************!*\
  !*** ./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9DU1MvR1BnZW5lcmFsV2lkZ2V0TGVhZmxldC5jc3M/NjAxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuL3NyYy9MZWFmbGV0L0NTUy9HUGdlbmVyYWxXaWRnZXRMZWFmbGV0LmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css\n");

/***/ }),

/***/ "./src/Leaflet/Controls/ElevationPath.js":
/*!***********************************************!*\
  !*** ./src/Leaflet/Controls/ElevationPath.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var geoportal_access_lib_src_Services_Alti_Alti__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! geoportal-access-lib/src/Services/Alti/Alti */ \"./node_modules/geoportal-access-lib/src/Services/Alti/Alti.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet_draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet-draw */ \"./node_modules/leaflet-draw/dist/leaflet.draw-src.js\");\n/* harmony import */ var leaflet_draw__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet_draw__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_leaflet_draw_dist_leaflet_draw_src_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/leaflet-draw/dist/leaflet.draw-src.css */ \"./node_modules/leaflet-draw/dist/leaflet.draw-src.css\");\n/* harmony import */ var _node_modules_leaflet_draw_dist_leaflet_draw_src_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_leaflet_draw_dist_leaflet_draw_src_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Common_CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Common/CSS/GPgeneralWidget.css */ \"./src/Common/CSS/GPgeneralWidget.css\");\n/* harmony import */ var _Common_CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Common_CSS_GPgeneralWidget_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Common_CSS_GPelevationPath_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Common/CSS/GPelevationPath.css */ \"./src/Common/CSS/GPelevationPath.css\");\n/* harmony import */ var _Common_CSS_GPelevationPath_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Common_CSS_GPelevationPath_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _CSS_GPgeneralWidgetLeaflet_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../CSS/GPgeneralWidgetLeaflet.css */ \"./src/Leaflet/CSS/GPgeneralWidgetLeaflet.css\");\n/* harmony import */ var _CSS_GPgeneralWidgetLeaflet_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_CSS_GPgeneralWidgetLeaflet_css__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _CSS_Controls_ElevationPath_GPelevationPathLeaflet_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../CSS/Controls/ElevationPath/GPelevationPathLeaflet.css */ \"./src/Leaflet/CSS/Controls/ElevationPath/GPelevationPathLeaflet.css\");\n/* harmony import */ var _CSS_Controls_ElevationPath_GPelevationPathLeaflet_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_CSS_Controls_ElevationPath_GPelevationPathLeaflet_css__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n/* harmony import */ var _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Common/Utils/CheckRightManagement */ \"./src/Common/Utils/CheckRightManagement.js\");\n/* harmony import */ var _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../Common/Utils/SelectorID */ \"./src/Common/Utils/SelectorID.js\");\n/* harmony import */ var _Utils_PositionFormater__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Utils/PositionFormater */ \"./src/Leaflet/Controls/Utils/PositionFormater.js\");\n/* harmony import */ var _Utils_IconDefault__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Utils/IconDefault */ \"./src/Leaflet/Controls/Utils/IconDefault.js\");\n/* harmony import */ var _Common_Controls_ElevationPathDOM__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../Common/Controls/ElevationPathDOM */ \"./src/Common/Controls/ElevationPathDOM.js\");\n/* harmony import */ var _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../Common/Controls/ProfileElevationPathDOM */ \"./src/Common/Controls/ProfileElevationPathDOM.js\");\n/* globals AmCharts, d3 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getLogger(\"ElevationPath\");\n/**\n * @classdesc\n *\n * Leaflet Control Class to compute and display Profil Elevation.\n *\n * Use {@link module:Controls.ElevationPath L.geoportalControl.ElevationPath()} factory to create instances of that class.\n *\n * **Extends** Leaflet <a href=\"http://leafletjs.com/reference.html#control\" target=\"_blank\">L.Control</a> native class.\n *\n * @namespace\n * @alias L.geoportalControl.ElevationPath\n */\n\nvar ElevationPath = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Control.extend(\n/** @lends L.geoportalControl.ElevationPath.prototype */\n{\n  includes: _Common_Controls_ElevationPathDOM__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n\n  /**\n   * Options du service\n   *\n   * @private\n   */\n  options: {\n    position: \"topleft\",\n    active: false,\n    elevationPathOptions: {},\n    stylesOptions: {},\n    displayProfileOptions: {\n      greaterSlope: true,\n      meanSlope: true,\n      ascendingElevation: true,\n      descendingElevation: true,\n      currentSlope: true,\n      apply: null,\n      target: null\n    }\n  },\n\n  /**\n   * @constructor ElevationPath\n   *\n   * @private\n   * @param {Object} options - ElevationPath control options\n   * @param {String}   [options.apiKey] - API key for services call (isocurve and autocomplete services), mandatory if autoconf service has not been charged in advance\n   * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)\n   * @param {Boolean} [options.active] - Specify if widget has to be actived to drawing (true) or not (false) on map loading. Default is false.\n   * @param {Object} [options.elevationPathOptions = {}] - elevation service options. See {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~getAltitude Gp.Services.getAltitude()} to know all elevation options\n   * @param {Object} [options.displayProfileOptions = {}] - profile options.\n   * @param {Function} [options.displayProfileOptions.apply] - function to display profil panel.\n   * @param {Object} [options.displayProfileOptions.target] - container DOM for the profil panel.\n   * @param {Boolean} [options.displayProfileOptions.greaterSlope = true] - display the greater slope into the graph\n   * @param {Boolean} [options.displayProfileOptions.meanSlope = true] -  display the mean slope into the graph\n   * @param {Boolean} [options.displayProfileOptions.ascendingElevation = true] -  display the ascending elevation into the graph\n   * @param {Boolean} [options.displayProfileOptions.descendingElevation = true] -  display the descending elevation into the graph\n   * @param {Boolean} [options.displayProfileOptions.currentSlope = true] -  display current slope value on profile mouseover\n   *\n   * @example\n   *  var e = L.geoportalControl.ElevationPath({\n   *      active : false,\n   *      stylesOptions : {},\n   *      elevationPathOptions : {},\n   *      displayProfileOptions : {\n   *       apply : null,\n   *       target : null\n   *      }\n   *  });\n   * Exemples :\n   * - displayProfileOptions.apply : null\n   * - displayProfileOptions.apply : function (elevations, container, context) {  // do some stuff... }\n   * - displayProfileOptions.apply : ol.control.ElevationPath.DISPLAY_PROFILE_{LIB_AMCHARTS | LIB_D3 | RAW}\n   * (detect auto lib. : d3 / AmCharts)\n   */\n  initialize: function initialize(options) {\n    // on transmet les options au controle\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.setOptions(this, options); // uuid\n\n    this._uid = _Common_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_10__[\"default\"].generate(); // initialisation\n\n    this._initDisplayProfileOptions(); // les container\n\n\n    this._showContainer = null;\n    this._pictoContainer = null;\n    this._panelContainer = null;\n    this._profilContainer = null;\n    this._waitingContainer = null;\n    this._infoContainer = null; // timer sur la fenetre d'informations des données\n\n    this._timerHdlr = null; // detection si le panneau est reduit\n\n    this._reducePanel = false; // couche vectorielle dans laquelle seront saisis les points (features ci-dessus)\n\n    this._featuresLayer = null;\n    this._lastIdLayer = 0;\n    this._currentIdLayer = 0;\n    this._currentFeature = null; // graph\n\n    this._profile = null;\n    this._marker = null; // geometry à transmettre au service :  { lon : [], lat : []}\n\n    this._geometry = null; // distance du segment\n\n    this._distance = 0; // data elevations\n\n    this._data = {}; // aucun droits sur les ressources\n\n    this._noRightManagement = false; // gestion des droits sur les ressources/services\n\n    this._checkRightsManagement();\n  },\n\n  /**\n   * this method is called by this.addTo(map) when the control is added on the map\n   * and fills variable 'this._container = this.onAdd(map)',\n   * and create or disable events on map.\n   *\n   * @param {Object} map - the map\n   *\n   * @returns {DOMElement} DOM element\n   * @private\n   */\n  onAdd: function onAdd(map) {\n    // initialisation du DOM du composant\n    var container = this._container = this._initLayout();\n\n    if (map) {\n      // lors de l'ajout à la map, on active la saisie du point,\n      // mais seulement si le widget est ouvert\n      if (this.options.active) {\n        if (this._profile === null) {\n          this._panelContainer.style.display = \"none\"; // this._panelContainer.style.visibility = \"hidden\";\n        }\n\n        this._activateMapInteraction(map);\n      }\n    } // deactivate of events that may interfere with the map\n\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);\n    return container;\n  },\n\n  /**\n   * TODO this method is called when the control is removed from the map\n   * and removes events on map.\n   *\n   * @private\n   */\n  onRemove: function\n    /* map */\n  onRemove() {},\n  // ################################################################### //\n  // ########################## init resources ######################### //\n  // ################################################################### //\n\n  /**\n   * this method is called by constructor\n   * and check the rights to resources\n   *\n   * @private\n   */\n  _checkRightsManagement: function _checkRightsManagement() {\n    var rightManagement = _Common_Utils_CheckRightManagement__WEBPACK_IMPORTED_MODULE_9__[\"default\"].check({\n      key: this.options.apiKey,\n      resources: [\"SERVICE_CALCUL_ALTIMETRIQUE_RSC\"],\n      services: [\"ElevationLine\"]\n    });\n\n    if (!rightManagement) {\n      this._noRightManagement = true;\n    } // on recupère les informations utiles\n    // sur ce controle, on ne s'occupe pas de la ressource car elle est unique...\n    // Ex. la clef API issue de l'autoconfiguration si elle n'a pas\n    // été renseignée.\n\n\n    if (!this.options.apiKey) {\n      this.options.apiKey = rightManagement.key;\n    }\n  },\n  // ################################################################### //\n  // ####################### init application ########################## //\n  // ################################################################### //\n\n  /**\n   * this method is called by the constructor and initialize the ...\n   *\n   * @private\n   */\n  _initDisplayProfileOptions: function _initDisplayProfileOptions() {\n    // gestion de l'affichage du profil\n    var _profileOpts = this.options.displayProfileOptions; // gestion de la fonction du profil\n\n    var displayFunction = _profileOpts.apply;\n    _profileOpts.apply = typeof displayFunction === \"function\" ? displayFunction : ElevationPath.DISPLAY_PROFILE_BY_DEFAULT; // gestion du container du profil\n\n    var displayContainer = _profileOpts.target;\n    _profileOpts.target = typeof displayContainer !== \"undefined\" ? displayContainer : null; // les autres options\n\n    var _protoOpts = Object.getPrototypeOf(this.options);\n\n    if (typeof _profileOpts.meanSlope === \"undefined\") {\n      _profileOpts.meanSlope = _protoOpts.displayProfileOptions.meanSlope;\n    }\n\n    if (typeof _profileOpts.greaterSlope === \"undefined\") {\n      _profileOpts.greaterSlope = _protoOpts.displayProfileOptions.greaterSlope;\n    }\n\n    if (typeof _profileOpts.ascendingElevation === \"undefined\") {\n      _profileOpts.ascendingElevation = _protoOpts.displayProfileOptions.ascendingElevation;\n    }\n\n    if (typeof _profileOpts.descendingElevation === \"undefined\") {\n      _profileOpts.descendingElevation = _protoOpts.displayProfileOptions.descendingElevation;\n    }\n\n    if (typeof _profileOpts.currentSlope === \"undefined\") {\n      _profileOpts.currentSlope = _protoOpts.displayProfileOptions.currentSlope;\n    }\n  },\n  // ################################################################### //\n  // ########################### init dom ############################## //\n  // ################################################################### //\n\n  /**\n   * this method is called by this.onAdd(map)\n   * and initialize the container HTMLElement\n   *\n   * @returns {DOMElement} DOM element\n   * @private\n   */\n  _initLayout: function _initLayout() {\n    // create main container\n    var container = this._createMainContainerElement();\n\n    var inputShow = this._showContainer = this._createShowElevationPathElement();\n\n    container.appendChild(inputShow); // mode \"collapsed\"\n\n    if (this.options.active) {\n      this._showContainer.checked = true;\n    }\n\n    var picto = this._pictoContainer = this._createShowElevationPathPictoElement();\n\n    container.appendChild(picto); // panneau\n\n    var panel = this._panelContainer = this._createElevationPathPanelElement(); // header\n\n\n    var header = this._createElevationPathPanelHeaderElement();\n\n    panel.appendChild(header); // profil\n\n    var profil = this._profilContainer = this._createElevationPathPanelProfilElement();\n\n    panel.appendChild(profil); // waiting\n\n    var waiting = this._waitingContainer = this._createElevationPathWaitingElement();\n\n    panel.appendChild(waiting); // info\n\n    var info = this._infoContainer = this._createElevationPathInformationsElement();\n\n    panel.appendChild(info);\n    container.appendChild(panel);\n    return container;\n  },\n  // ################################################################### //\n  // ####################### handlers events to dom #################### //\n  // ################################################################### //\n\n  /**\n   * this method is called by event 'click' on '' picto\n   * and ...\n   *\n   * @param {Object} e - HTMLElement\n   *\n   * @private\n   */\n  onShowElevationPathClick: function onShowElevationPathClick(e) {\n    logger.trace(e);\n    var map = this._map; // interactions avec la carte\n\n    if (!this._reducePanel) {\n      if (this._showContainer.checked) {\n        this._pictoContainer.style.display = \"block\";\n        this._panelContainer.style.display = \"none\";\n\n        this._removeMapInteraction(map);\n\n        this._clear();\n      } else {\n        if (this._profile === null) {\n          this._panelContainer.style.display = \"none\";\n        }\n\n        this._activateMapInteraction(map);\n      }\n    } else {\n      if (this._profile !== null) {\n        if (this.options.displayProfileOptions.target === null) {\n          this._pictoContainer.style.display = \"none\";\n        }\n\n        this._panelContainer.style.display = \"block\";\n      }\n    }\n\n    this._reducePanel = false;\n  },\n\n  /**\n   * this method is called by event 'click' on '' picto\n   * (cf. this.),\n   * and reduce the panel\n   *\n   * @private\n   */\n  onReduceElevationPathPanelClick: function onReduceElevationPathPanelClick() {\n    this._reducePanel = true;\n    this._pictoContainer.style.display = \"block\";\n    this._panelContainer.style.display = \"none\";\n  },\n\n  /**\n   * this method is called by event 'click' on '' picto\n   * (cf. this.),\n   * and display the panel info\n   * TODO\n   *\n   * @private\n   */\n  onOpenElevationPathInfoClick: function onOpenElevationPathInfoClick() {\n    // options d'affichage\n    var meanSlope = this.options.displayProfileOptions.meanSlope;\n    var greaterSlope = this.options.displayProfileOptions.greaterSlope;\n    var ascendingElevation = this.options.displayProfileOptions.ascendingElevation;\n    var descendingElevation = this.options.displayProfileOptions.descendingElevation; // clean\n\n    var div = this._infoContainer;\n\n    if (div.childElementCount) {\n      while (div.firstChild) {\n        div.removeChild(div.firstChild);\n      }\n    } // creation des infomations\n\n\n    if (ascendingElevation) {\n      this._addElevationPathInformationsItem(\"Dénivelé positif : \" + this._data.ascendingElevation.toLocaleString() + \" m\");\n    }\n\n    if (descendingElevation) {\n      this._addElevationPathInformationsItem(\"Dénivelé négatif : \" + this._data.descendingElevation.toLocaleString() + \" m\");\n    }\n\n    if (meanSlope) {\n      this._addElevationPathInformationsItem(\"Pente moyenne : \" + this._data.meanSlope.toLocaleString() + \" %\");\n    }\n\n    if (greaterSlope) {\n      this._addElevationPathInformationsItem(\"Plus forte pente : \" + this._data.greaterSlope.toLocaleString() + \" %\");\n    } // show des informations !\n\n\n    if (div.className === \"GPelevationPathInformationsContainerVisible\") {\n      clearTimeout(this._timerHdlr);\n      div.className = \"GPelevationPathInformationsContainerHidden\";\n    } else {\n      div.className = \"GPelevationPathInformationsContainerVisible\";\n    } // hidden des informations !\n\n\n    this._timerHdlr = setTimeout(function () {\n      div.className = \"GPelevationPathInformationsContainerHidden\";\n    }, 4000);\n  },\n  // ################################################################### //\n  // ################### Map interactions management ################### //\n  // ################################################################### //\n\n  /**\n   * this method is called by this.onShowElevationPathClick,\n   * and calls method corresponding to current delimitation, if widget is not collapsed.\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _activateMapInteraction: function _activateMapInteraction(map) {\n    logger.info(\"_activateMapInteraction()\"); // Creation de la couche vectorielle sur laquelle on va dessiner\n\n    if (this._featuresLayer === null) {\n      this._featuresLayer = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.FeatureGroup();\n      map.addLayer(this._featuresLayer);\n      var self = this;\n      /* evenements : on desactive le menu systeme pour la saisie */\n\n      map.on(\"contextmenu\", function () {});\n      /* evenement sur la carte lors d'une saisie,\n      on y ajoute le layer, et on y stocke les coordonnées */\n\n      map.on(\"draw:created\", function (e) {\n        logger.trace(\"draw:created\");\n        self._currentIdLayer = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.stamp(e.layer);\n\n        self._getFeatureGeometry(e.layer);\n\n        self._addFeatureLayer(e.layer);\n      });\n      /* evenements */\n\n      map.on(\"draw:drawstart\", function () {\n        logger.trace(\"draw:drawstart\");\n\n        self._removeFeatureLayer(self._lastIdLayer);\n\n        self._lastIdLayer = self._currentIdLayer;\n      });\n      /* evenements */\n\n      map.on(\"draw:drawstop\", function () {\n        logger.trace(\"draw:drawstop\");\n\n        if (typeof self.options.elevationPathOptions.onSuccess === \"undefined\" && self.options.displayProfileOptions.target === null) {\n          self._pictoContainer.style.display = \"none\";\n          self._panelContainer.style.display = \"block\";\n        }\n\n        self._altiRequest();\n      });\n    }\n\n    this._activatePolyLineInteraction(map);\n  },\n\n  /**\n   * remove draw interaction from map (if exists)\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _removeMapInteraction: function _removeMapInteraction(map) {\n    if (!map) {\n      return;\n    }\n\n    if (this._featuresLayer !== null) {\n      map.off(\"draw:created\");\n      map.off(\"draw:drawstart\");\n      map.off(\"draw:drawstop\");\n      map.removeLayer(this._featuresLayer);\n      this._featuresLayer = null;\n    }\n\n    this._lastIdLayer = this._currentIdLayer = 0; // FIXME delete this._currentFeature ?\n\n    if (this._currentFeature) {\n      this._currentFeature.disable();\n    }\n  },\n\n  /**\n   * this method is called by this._activateMapInteraction,\n   * and creates map polyline drawing interaction.\n   *\n   * @param {Object} map - control map.\n   * @private\n   */\n  _activatePolyLineInteraction: function _activatePolyLineInteraction(map) {\n    if (this._currentFeature) {\n      this._currentFeature.disable();\n    } // liste des options par defaut\n    // cf. https://leaflet.github.io/Leaflet.draw/docs/leaflet-draw-latest.html\n    // var polylineOptions = {\n    //     allowIntersection : true,\n    //     repeatMode : false,\n    //     drawError : {\n    //         color : \"#b00b00\",\n    //         timeout : 2500\n    //     },\n    //     icon : new L.DivIcon({\n    //         iconSize : new L.Point(8, 8),\n    //         className : 'leaflet-div-icon leaflet-editing-icon'\n    //     }),\n    //     touchIcon : new L.DivIcon({\n    //         iconSize : new L.Point(20, 20),\n    //         className : 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\n    //     }),\n    //     guidelineDistance : 20,\n    //     maxGuideLineLength : 4000,\n    //     shapeOptions : {\n    //         stroke : true,\n    //         color : '#f06eaa',\n    //         weight : 4,\n    //         opacity : 0.5,\n    //         fill : false,\n    //         clickable : true\n    //     },\n    //     metric : true, // Whether to use the metric measurement system or imperial\n    //     feet : true, // When not metric, to use feet instead of yards for display.\n    //     nautic : false, // When not metric, not feet use nautic mile for display\n    //     showLength : true, // Whether to display distance in the tooltip\n    //     zIndexOffset : 2000 // This should be > than the highest z-index any map layersallowIntersection : true,\n    // };\n\n\n    var styles = this.options.stylesOptions || {};\n\n    var _shapeOptions = Object.keys(styles).length !== 0 ? styles : {\n      stroke: true,\n      color: \"#C77A04\",\n      weight: 4,\n      opacity: 0.5,\n      fill: false\n    };\n\n    this._currentFeature = new leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Draw.Polyline(map, {\n      shapeOptions: _shapeOptions\n    });\n\n    this._currentFeature.enable();\n  },\n\n  /**\n   * set current position of feature\n   *\n   * @param {Object} layer - layer\n   * @private\n   */\n  _getFeatureGeometry: function _getFeatureGeometry(layer) {\n    // on transmet toujours des coordonnées au service en EPSG:4326\n    logger.log(layer.getLatLngs());\n\n    if (this._geometry !== null) {\n      this._geometry = null;\n    }\n\n    this._geometry = [];\n    this._distance = 0;\n    var geometry = layer.getLatLngs();\n\n    for (var i = 0; i < geometry.length; i++) {\n      // on transmet au service des coordonnées en EPSG:4326\n      var LatLngI = geometry[i];\n      var LatLngJ = geometry[i + 1];\n\n      this._geometry.push({\n        lon: LatLngI.lng,\n        lat: LatLngI.lat\n      }); // on calcul la distance du segment\n\n\n      if (LatLngJ) {\n        this._distance += LatLngI.distanceTo(LatLngJ);\n      }\n    }\n\n    logger.log(\"Geometry\", this._geometry);\n    logger.log(\"Distance\", this._distance);\n  },\n\n  /**\n   * set current layer of feature\n   *\n   * @param {Object} layer - layer\n   * @private\n   */\n  _addFeatureLayer: function _addFeatureLayer(layer) {\n    if (!this._featuresLayer) {\n      return;\n    }\n\n    this._featuresLayer.addLayer(layer);\n  },\n\n  /**\n   * remove layer feature from group\n   *\n   * @param {Integer} id - id\n   * @private\n   */\n  _removeFeatureLayer: function _removeFeatureLayer(id) {\n    if (!this._featuresLayer) {\n      return;\n    }\n\n    if (id === 0) {\n      return;\n    }\n\n    if (!id) {\n      this._featuresLayer.clearLayers();\n    } else {\n      this._featuresLayer.removeLayer(id);\n    }\n  },\n  // ################################################################### //\n  // ############################ Alti request ######################### //\n  // ################################################################### //\n\n  /**\n   * this methode is called by this. method,\n   * it generates and sends alti request, then displays results\n   *\n   * @private\n   */\n  _altiRequest: function _altiRequest() {\n    logger.log(\"_altiRequest\"); // les coordonnées sont obligatoires\n\n    if (!this._geometry) {\n      logger.log(\"missing position\");\n      return;\n    } // oups, aucun droits !\n\n\n    if (this._noRightManagement) {\n      return;\n    } // on construit les options pour la requête\n\n\n    var options = {}; // on surcharge avec les options de l'utilisateur\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, this.options.elevationPathOptions); // au cas où la clef API n'est pas renseignée dans les options du service,\n    // on utilise celle de l'autoconf ou celle renseignée au niveau du controle\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, {\n      apiKey: options.apiKey || this.options.apiKey\n    }); // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert\n    // true par défaut (https)\n\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, {\n      ssl: this.options.ssl\n    }); // le sampling est soit defini par l'utilisateur (opts),\n    // ou soit calculé dynamiquement...\n\n    var _sampling = options.sampling;\n\n    if (!_sampling) {\n      // computing sampling\n      var _computeSampling;\n\n      var _length = this._currentFeature._measurementRunningTotal; // FIXME !!!\n\n      logger.trace(\"length\", _length);\n      var p = Math.floor(_length) / 5; // en mètre sur un pas moyen de 5m !\n\n      if (p >= 200) {\n        _computeSampling = 200;\n      } else {\n        _computeSampling = Math.floor(p);\n      }\n\n      _sampling = _computeSampling;\n    } // on y ajoute les callbacks ainsi que les options par defaut\n\n\n    var self = this;\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, {\n      /** sampling à 200 (iso portail) */\n      sampling: _sampling,\n      // callback onSuccess\n      onSuccess: this.options.elevationPathOptions.onSuccess || function (result) {\n        logger.log(result);\n\n        if (result) {\n          if (self.options.displayProfileOptions.target !== null) {\n            self._pictoContainer.style.display = \"block\";\n            self._panelContainer.style.display = \"block\";\n          }\n\n          self._displayProfil(result.elevations);\n\n          self._waitingContainer.className = \"GPelevationPathCalcWaitingContainerHidden\";\n          self._waiting = false;\n        }\n      },\n      // callback onFailure\n      onFailure: this.options.elevationPathOptions.onFailure || function (error) {\n        logger.log(error.message);\n        self._pictoContainer.style.display = \"block\";\n        self._panelContainer.style.display = \"none\";\n        self._waitingContainer.className = \"GPelevationPathCalcWaitingContainerHidden\";\n        self._waiting = false;\n\n        self._clear();\n      }\n    }); // et enfin, la geometrie\n\n    var positions = this._geometry;\n    leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.Util.extend(options, {\n      positions: positions\n    });\n    logger.log(options); // mise en place de la patience\n\n    this._waitingContainer.className = \"GPelevationPathCalcWaitingContainerVisible\"; // Request altitude service\n\n    var altiService = new geoportal_access_lib_src_Services_Alti_Alti__WEBPACK_IMPORTED_MODULE_0__[\"default\"](options);\n    altiService.call();\n  },\n  // ################################################################### //\n  // ########################## Profil display ######################### //\n  // ################################################################### //\n\n  /**\n   * this method computes results elevations (Z and distance)\n   *\n   * @param {Array} elevations - array of elevation\n   * @return {Array} elevations\n   * @private\n   */\n  _computeElevationMeasure: function _computeElevationMeasure(elevations) {\n    // Returns the distance from c1 to c2 using the haversine formula\n    var _haversineDistance = function _haversineDistance(c1, c2) {\n      var lat1 = _Utils_PositionFormater__WEBPACK_IMPORTED_MODULE_11__[\"default\"].decimalToRadian(c1[1]);\n      var lat2 = _Utils_PositionFormater__WEBPACK_IMPORTED_MODULE_11__[\"default\"].decimalToRadian(c2[1]);\n      var deltaLatBy2 = (lat2 - lat1) / 2;\n      var deltaLonBy2 = _Utils_PositionFormater__WEBPACK_IMPORTED_MODULE_11__[\"default\"].decimalToRadian(c2[0] - c1[0]) / 2;\n      var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n      return 2 * 6378137 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    };\n\n    var _data = elevations;\n    var _unit = \"m\";\n    var _sketchPoints = this._geometry; // section actuelle du sketch sur laquelle on est\n\n    var _currentSection = 0; // longueur cumulée des sections précédentes\n\n    var _previousSectionsLength = 0;\n    var _nextSectionBegining = _sketchPoints[1]; // Calcul de la distance au départ pour chaque point + arrondi des lat/lon\n\n    _data[0].dist = 0;\n    _data[0].slope = 0;\n    _data[0].lat = Math.round(_data[0].lat * 10000) / 10000;\n    _data[0].lon = Math.round(_data[0].lon * 10000) / 10000;\n    var _distanceMinus = 0;\n    var _distancePlus = 0;\n    var _ascendingElevation = 0;\n    var _descendingElevation = 0;\n    var _distance = 0;\n    var _slopes = 0;\n    var distances = [];\n\n    for (var i = 1; i < _data.length; i++) {\n      var a = [_data[i].lon, _data[i].lat];\n\n      var distanceToStart = _previousSectionsLength + _haversineDistance(a, [_sketchPoints[_currentSection].lon, _sketchPoints[_currentSection].lat]);\n\n      var dist = distanceToStart - _distance; // Changement de section\n\n      if (a[0].toFixed(8) === _nextSectionBegining.lon.toFixed(8) && a[1].toFixed(8) === _nextSectionBegining.lat.toFixed(8)) {\n        _currentSection++;\n        _previousSectionsLength = distanceToStart; // Pas de next section si on est sur le dernier point\n\n        if (i !== _data.length - 1) {\n          _nextSectionBegining = _sketchPoints[_currentSection + 1];\n        }\n      }\n\n      var za = _data[i].z;\n      var zb = _data[i - 1].z;\n\n      if (za < 0) {\n        za = 0;\n      }\n\n      if (zb < 0) {\n        zb = 0;\n      }\n\n      var slope = za - zb;\n\n      if (slope < 0) {\n        _distanceMinus += dist;\n        _descendingElevation += slope;\n      } else if (slope > 0) {\n        _distancePlus += dist;\n        _ascendingElevation += slope;\n      }\n\n      _distance = distanceToStart;\n      _data[i].dist = distanceToStart;\n      distances.push(distanceToStart);\n      _slopes += slope ? Math.abs(Math.round(slope / dist * 100)) : 0;\n      _data[i].slope = slope ? Math.abs(Math.round(slope / dist * 100)) : 0; // EVOL ?\n      // cf. gradiant\n      // http://www.color-hex.com/color/00b798\n\n      var value = _data[i].slope;\n\n      if (value > 15 && value < 30) {\n        _data[i].color = \"#005b4c\";\n      } else if (value > 30 && value < 45) {\n        _data[i].color = \"#00362d\";\n      } else if (value > 45) {\n        _data[i].color = \"#00120f\";\n      } else {\n        _data[i].color = \"#00B798\";\n      }\n\n      _data[i].lat = Math.round(_data[i].lat * 10000) / 10000;\n      _data[i].lon = Math.round(_data[i].lon * 10000) / 10000;\n    } // check distance totale\n\n\n    logger.trace(\"List Distances\", distances); // Correction des altitudes aberrantes + arrondi des calculs de distance + ...\n\n    var _altMin = _data[0].z;\n    var _altMax = _data[0].z;\n    var _greaterSlope = _data[0].slope;\n\n    for (var ji = 0; ji < _data.length; ji++) {\n      var d = _data[ji];\n\n      if (d.z < -100) {\n        d.z = 0;\n      }\n\n      if (d.z > _altMax) {\n        _altMax = d.z;\n      }\n\n      if (d.z < _altMin) {\n        _altMin = d.z;\n      }\n\n      if (d.slope > _greaterSlope) {\n        _greaterSlope = d.slope;\n      }\n    }\n\n    return {\n      greaterSlope: _greaterSlope,\n      // pente max\n      meanSlope: Math.round(_slopes / _data.length),\n      // pente moyenne\n      distancePlus: _distancePlus,\n      // distance cumulée positive\n      distanceMinus: _distanceMinus,\n      // distance cumulée négative\n      ascendingElevation: _ascendingElevation,\n      // dénivelé cumulée positive\n      descendingElevation: _descendingElevation,\n      // dénivelé cumulée négative\n      altMin: _altMin.toLocaleString(),\n      // altitude min TODO: inutile ?\n      altMax: _altMax.toLocaleString(),\n      // altitude max TODO: inutile ?\n      distance: this._distance,\n      // distance totale\n      unit: _unit,\n      // unité des mesures de distance\n      points: _data\n    };\n  },\n\n  /**\n   * this method is called by this. (in case of success)\n   * and display results\n   *\n   * @param {Array} elevations - array of elevation\n   * @private\n   */\n  _displayProfil: function _displayProfil(elevations) {\n    // on reactive le menu systeme en fin de saisie !\n    var map = this._map;\n    map.off(\"contextmenu\"); // data\n\n    if (this._data) {\n      this._data = {};\n    } // sauvegarde des données\n\n\n    var data = this._data = this._computeElevationMeasure(elevations); // container\n\n\n    var container = this.options.displayProfileOptions.target;\n\n    if (container) {\n      container.appendChild(this._panelContainer);\n    }\n\n    container = this._profilContainer; // TODO contexte ?\n\n    var context = this;\n    var _profileOpts = this.options.displayProfileOptions; // fonction\n\n    var displayFunction = _profileOpts.apply; // Calcul du profil\n\n    if (typeof AmCharts !== \"undefined\" && typeof d3 !== \"undefined\") {\n      logger.trace(\"Aucune lib. n'est presente !\");\n    } // execution...\n\n\n    displayFunction.call(this, data, container, context); // affichage des informations du profil ?\n\n    var element = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.DomUtil.get(\"GPelevationPathPanelInfo-\" + this._uid);\n\n    if (_profileOpts.greaterSlope || _profileOpts.meanSlope || _profileOpts.ascendingElevation || _profileOpts.descendingElevation) {\n      // on affiche les informations\n      element.style.display = \"block\";\n    }\n  },\n  // ################################################################### //\n  // ################################ clean ############################ //\n  // ################################################################### //\n\n  /**\n   * this method clears all data\n   *\n   * @private\n   */\n  _clear: function _clear() {\n    this._geometry = null;\n    this._profile = null; // on vide le container\n\n    if (this._profilContainer) {\n      while (this._profilContainer.firstChild) {\n        this._profilContainer.removeChild(this._profilContainer.firstChild);\n      }\n    } // on supprime le marker\n\n\n    var map = this._map;\n\n    if (this._marker) {\n      map.removeLayer(this._marker);\n      this._marker = null;\n    }\n  }\n});\n/**\n * create Profile Marker\n *\n * @param {Object} context - context\n * @param {Object} data - data\n */\n\nElevationPath.__createProfileMarker = function (context, data) {\n  logger.log(\"__createProfileMarker\");\n  var self = context;\n  var map = self._map; // var _srs    = L.CRS.EPSG4326;\n  // var _pointA = _srs.latLngToPoint(L.latLng(self._geometry[0].lat, self._geometry[0].lon));\n  // var _pointB = _srs.latLngToPoint(L.latLng(self._geometry[self._geometry.length - 1].lat, self._geometry[self._geometry.length - 1].lon));\n  // var _point  = L.LineUtil.closestPointOnSegment(_srs.latLngToPoint(L.latLng(data.lat, data.lon)), _pointA, _pointB );\n  // creation d\"un marker\n\n  self._marker = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.marker(leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.latLng(data), {\n    icon: new _Utils_IconDefault__WEBPACK_IMPORTED_MODULE_12__[\"default\"](\"orange\"),\n    draggable: false,\n    clickable: false,\n    zIndexOffset: 1000\n  });\n\n  self._marker.addTo(map);\n};\n/**\n * update Profile Marker\n *\n * @param {Object} context - context\n * @param {Object} data - data\n */\n\n\nElevationPath.__updateProfileMarker = function (context, data) {\n  logger.log(\"__updateProfileMarker\");\n  var self = context;\n  var map = self._map; // var _srs    = L.CRS.EPSG4326;\n  // var _pointA = _srs.latLngToPoint(L.latLng(self._geometry[0].lat, self._geometry[0].lon));\n  // var _pointB = _srs.latLngToPoint(L.latLng(self._geometry[self._geometry.length - 1].lat, self._geometry[self._geometry.length - 1].lon));\n  // var _point  = L.LineUtil.closestPointOnSegment( _srs.latLngToPoint(L.latLng(data.lat, data.lon)), _pointA, _pointB );\n\n  if (self._marker) {\n    self._marker.setLatLng(leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.latLng(data));\n\n    self._marker.update();\n  } else {\n    // creation d\"un marker\n    self._marker = leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.marker(leaflet__WEBPACK_IMPORTED_MODULE_1___default.a.latLng(data), {\n      icon: new _Utils_IconDefault__WEBPACK_IMPORTED_MODULE_12__[\"default\"](\"orange\"),\n      draggable: false,\n      clickable: false,\n      zIndexOffset: 1000\n    });\n\n    self._marker.addTo(map);\n  }\n};\n/**\n * remove Profile Marker\n *\n * @param {Object} context - context\n */\n\n\nElevationPath.__removeProfileMarker = function (context) {\n  logger.log(\"__removeProfileMarker\");\n  var self = context;\n  var map = self._map;\n\n  if (self._marker) {\n    map.removeLayer(self._marker);\n    self._marker = null;\n  }\n};\n/**\n * custom operation into raw profil...\n * TODO\n */\n\n\nElevationPath.__customRawProfileOperation = function () {\n  logger.log(\"__customRawProfileOperation\");\n};\n/**\n * custom operation into raw profil...\n * TODO\n *\n * @param {Object} context - context\n * @param {Object} e - event\n */\n\n\nElevationPath.__customRawProfileMouseOverEvent = function (context, e) {\n  logger.log(\"__customRawProfileMouseOverEvent\", context, e);\n};\n/**\n * Display Profile function used by default : no additonal framework needed.\n *\n * @static\n * @param {Object} data - elevations values for profile\n * @param {HTMLElement} container - html container where to display profile\n * @param {Object} context - this control object\n */\n\n\nElevationPath.DISPLAY_PROFILE_BY_DEFAULT = function (data, container, context) {\n  logger.trace(\"ElevationPath.DISPLAY_PROFILE_BY_DEFAULT\");\n  var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_14__[\"default\"].displayProfileByDefault(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet\n\n  if (profile) {\n    this._profile = profile;\n  }\n};\n/**\n * Display Profile without graphical rendering (raw service response)\n *\n * @static\n * @param {Object} data - elevations values for profile\n * @param {HTMLElement} container - html container where to display profile\n * @param {Object} context - this control object\n */\n\n\nElevationPath.DISPLAY_PROFILE_RAW = function (data, container, context) {\n  logger.trace(\"ElevationPath.DISPLAY_PROFILE_RAW\");\n  var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_14__[\"default\"].displayProfileRaw(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet\n\n  if (profile) {\n    this._profile = profile;\n  }\n};\n/**\n * Display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.\n *\n * @static\n * @param {Object} data - elevations values for profile\n * @param {HTMLElement} container - html container where to display profile\n * @param {Object} context - this control object\n */\n\n\nElevationPath.DISPLAY_PROFILE_LIB_D3 = function (data, container, context) {\n  logger.trace(\"ElevationPath.DISPLAY_PROFILE_LIB_D3\");\n\n  if (typeof d3 === \"undefined\") {\n    logger.log(\"Lib. D3 is not loaded !\");\n    return;\n  }\n\n  var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_14__[\"default\"].displayProfileLibD3(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet\n\n  if (profile) {\n    this._profile = profile;\n  }\n};\n/**\n * Display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.\n *\n * @static\n * @param {Object} data - elevations values for profile\n * @param {HTMLElement} container - html container where to display profile\n * @param {Object} context - this control object\n */\n\n\nElevationPath.DISPLAY_PROFILE_LIB_AMCHARTS = function (data, container, context) {\n  logger.trace(\"ElevationPath.DISPLAY_PROFILE_LIB_AMCHARTS\"); // Calcul du profile\n\n  if (typeof AmCharts === \"undefined\") {\n    logger.log(\"Lib. AmCharts is not loaded !\");\n    return;\n  }\n\n  var profile = _Common_Controls_ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_14__[\"default\"].displayProfileLibAmCharts(data, container, context, ElevationPath); // on sauvegarde le profil du container dans l'objet\n\n  if (profile) {\n    this._profile = profile;\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ElevationPath); // Expose Isocurve as L.geoportalControl.ElevationPath (for a build bundle)\n\nif (window.L) {\n  if (!window.L.geoportalControl) {\n    window.L.geoportalControl = {};\n  }\n\n  window.L.geoportalControl.ElevationPath = ElevationPath;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9Db250cm9scy9FbGV2YXRpb25QYXRoLmpzPzViODgiXSwibmFtZXMiOlsibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiRWxldmF0aW9uUGF0aCIsIkwiLCJDb250cm9sIiwiZXh0ZW5kIiwiaW5jbHVkZXMiLCJFbGV2YXRpb25QYXRoRE9NIiwib3B0aW9ucyIsInBvc2l0aW9uIiwiYWN0aXZlIiwiZWxldmF0aW9uUGF0aE9wdGlvbnMiLCJzdHlsZXNPcHRpb25zIiwiZGlzcGxheVByb2ZpbGVPcHRpb25zIiwiZ3JlYXRlclNsb3BlIiwibWVhblNsb3BlIiwiYXNjZW5kaW5nRWxldmF0aW9uIiwiZGVzY2VuZGluZ0VsZXZhdGlvbiIsImN1cnJlbnRTbG9wZSIsImFwcGx5IiwidGFyZ2V0IiwiaW5pdGlhbGl6ZSIsIlV0aWwiLCJzZXRPcHRpb25zIiwiX3VpZCIsIklEIiwiZ2VuZXJhdGUiLCJfaW5pdERpc3BsYXlQcm9maWxlT3B0aW9ucyIsIl9zaG93Q29udGFpbmVyIiwiX3BpY3RvQ29udGFpbmVyIiwiX3BhbmVsQ29udGFpbmVyIiwiX3Byb2ZpbENvbnRhaW5lciIsIl93YWl0aW5nQ29udGFpbmVyIiwiX2luZm9Db250YWluZXIiLCJfdGltZXJIZGxyIiwiX3JlZHVjZVBhbmVsIiwiX2ZlYXR1cmVzTGF5ZXIiLCJfbGFzdElkTGF5ZXIiLCJfY3VycmVudElkTGF5ZXIiLCJfY3VycmVudEZlYXR1cmUiLCJfcHJvZmlsZSIsIl9tYXJrZXIiLCJfZ2VvbWV0cnkiLCJfZGlzdGFuY2UiLCJfZGF0YSIsIl9ub1JpZ2h0TWFuYWdlbWVudCIsIl9jaGVja1JpZ2h0c01hbmFnZW1lbnQiLCJvbkFkZCIsIm1hcCIsImNvbnRhaW5lciIsIl9jb250YWluZXIiLCJfaW5pdExheW91dCIsInN0eWxlIiwiZGlzcGxheSIsIl9hY3RpdmF0ZU1hcEludGVyYWN0aW9uIiwiRG9tRXZlbnQiLCJkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbiIsImRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsIm9uUmVtb3ZlIiwicmlnaHRNYW5hZ2VtZW50IiwiUmlnaHRNYW5hZ2VtZW50IiwiY2hlY2siLCJrZXkiLCJhcGlLZXkiLCJyZXNvdXJjZXMiLCJzZXJ2aWNlcyIsIl9wcm9maWxlT3B0cyIsImRpc3BsYXlGdW5jdGlvbiIsIkRJU1BMQVlfUFJPRklMRV9CWV9ERUZBVUxUIiwiZGlzcGxheUNvbnRhaW5lciIsIl9wcm90b09wdHMiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIl9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCIsImlucHV0U2hvdyIsIl9jcmVhdGVTaG93RWxldmF0aW9uUGF0aEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNoZWNrZWQiLCJwaWN0byIsIl9jcmVhdGVTaG93RWxldmF0aW9uUGF0aFBpY3RvRWxlbWVudCIsInBhbmVsIiwiX2NyZWF0ZUVsZXZhdGlvblBhdGhQYW5lbEVsZW1lbnQiLCJoZWFkZXIiLCJfY3JlYXRlRWxldmF0aW9uUGF0aFBhbmVsSGVhZGVyRWxlbWVudCIsInByb2ZpbCIsIl9jcmVhdGVFbGV2YXRpb25QYXRoUGFuZWxQcm9maWxFbGVtZW50Iiwid2FpdGluZyIsIl9jcmVhdGVFbGV2YXRpb25QYXRoV2FpdGluZ0VsZW1lbnQiLCJpbmZvIiwiX2NyZWF0ZUVsZXZhdGlvblBhdGhJbmZvcm1hdGlvbnNFbGVtZW50Iiwib25TaG93RWxldmF0aW9uUGF0aENsaWNrIiwiZSIsInRyYWNlIiwiX21hcCIsIl9yZW1vdmVNYXBJbnRlcmFjdGlvbiIsIl9jbGVhciIsIm9uUmVkdWNlRWxldmF0aW9uUGF0aFBhbmVsQ2xpY2siLCJvbk9wZW5FbGV2YXRpb25QYXRoSW5mb0NsaWNrIiwiZGl2IiwiY2hpbGRFbGVtZW50Q291bnQiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJfYWRkRWxldmF0aW9uUGF0aEluZm9ybWF0aW9uc0l0ZW0iLCJ0b0xvY2FsZVN0cmluZyIsImNsYXNzTmFtZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJGZWF0dXJlR3JvdXAiLCJhZGRMYXllciIsInNlbGYiLCJvbiIsInN0YW1wIiwibGF5ZXIiLCJfZ2V0RmVhdHVyZUdlb21ldHJ5IiwiX2FkZEZlYXR1cmVMYXllciIsIl9yZW1vdmVGZWF0dXJlTGF5ZXIiLCJvblN1Y2Nlc3MiLCJfYWx0aVJlcXVlc3QiLCJfYWN0aXZhdGVQb2x5TGluZUludGVyYWN0aW9uIiwib2ZmIiwicmVtb3ZlTGF5ZXIiLCJkaXNhYmxlIiwic3R5bGVzIiwiX3NoYXBlT3B0aW9ucyIsImtleXMiLCJsZW5ndGgiLCJzdHJva2UiLCJjb2xvciIsIndlaWdodCIsIm9wYWNpdHkiLCJmaWxsIiwiRHJhdyIsIlBvbHlsaW5lIiwic2hhcGVPcHRpb25zIiwiZW5hYmxlIiwibG9nIiwiZ2V0TGF0TG5ncyIsImdlb21ldHJ5IiwiaSIsIkxhdExuZ0kiLCJMYXRMbmdKIiwicHVzaCIsImxvbiIsImxuZyIsImxhdCIsImRpc3RhbmNlVG8iLCJpZCIsImNsZWFyTGF5ZXJzIiwic3NsIiwiX3NhbXBsaW5nIiwic2FtcGxpbmciLCJfY29tcHV0ZVNhbXBsaW5nIiwiX2xlbmd0aCIsIl9tZWFzdXJlbWVudFJ1bm5pbmdUb3RhbCIsInAiLCJNYXRoIiwiZmxvb3IiLCJyZXN1bHQiLCJfZGlzcGxheVByb2ZpbCIsImVsZXZhdGlvbnMiLCJfd2FpdGluZyIsIm9uRmFpbHVyZSIsImVycm9yIiwibWVzc2FnZSIsInBvc2l0aW9ucyIsImFsdGlTZXJ2aWNlIiwiU2VydmljZUFsdGkiLCJjYWxsIiwiX2NvbXB1dGVFbGV2YXRpb25NZWFzdXJlIiwiX2hhdmVyc2luZURpc3RhbmNlIiwiYzEiLCJjMiIsImxhdDEiLCJQb3NpdGlvbkZvcm1hdGVyIiwiZGVjaW1hbFRvUmFkaWFuIiwibGF0MiIsImRlbHRhTGF0QnkyIiwiZGVsdGFMb25CeTIiLCJhIiwic2luIiwiY29zIiwiYXRhbjIiLCJzcXJ0IiwiX3VuaXQiLCJfc2tldGNoUG9pbnRzIiwiX2N1cnJlbnRTZWN0aW9uIiwiX3ByZXZpb3VzU2VjdGlvbnNMZW5ndGgiLCJfbmV4dFNlY3Rpb25CZWdpbmluZyIsImRpc3QiLCJzbG9wZSIsInJvdW5kIiwiX2Rpc3RhbmNlTWludXMiLCJfZGlzdGFuY2VQbHVzIiwiX2FzY2VuZGluZ0VsZXZhdGlvbiIsIl9kZXNjZW5kaW5nRWxldmF0aW9uIiwiX3Nsb3BlcyIsImRpc3RhbmNlcyIsImRpc3RhbmNlVG9TdGFydCIsInRvRml4ZWQiLCJ6YSIsInoiLCJ6YiIsImFicyIsInZhbHVlIiwiX2FsdE1pbiIsIl9hbHRNYXgiLCJfZ3JlYXRlclNsb3BlIiwiamkiLCJkIiwiZGlzdGFuY2VQbHVzIiwiZGlzdGFuY2VNaW51cyIsImFsdE1pbiIsImFsdE1heCIsImRpc3RhbmNlIiwidW5pdCIsInBvaW50cyIsImRhdGEiLCJjb250ZXh0IiwiQW1DaGFydHMiLCJkMyIsImVsZW1lbnQiLCJEb21VdGlsIiwiZ2V0IiwiX19jcmVhdGVQcm9maWxlTWFya2VyIiwibWFya2VyIiwibGF0TG5nIiwiaWNvbiIsIkljb25EZWZhdWx0IiwiZHJhZ2dhYmxlIiwiY2xpY2thYmxlIiwiekluZGV4T2Zmc2V0IiwiYWRkVG8iLCJfX3VwZGF0ZVByb2ZpbGVNYXJrZXIiLCJzZXRMYXRMbmciLCJ1cGRhdGUiLCJfX3JlbW92ZVByb2ZpbGVNYXJrZXIiLCJfX2N1c3RvbVJhd1Byb2ZpbGVPcGVyYXRpb24iLCJfX2N1c3RvbVJhd1Byb2ZpbGVNb3VzZU92ZXJFdmVudCIsInByb2ZpbGUiLCJQcm9maWxlRWxldmF0aW9uUGF0aERPTSIsImRpc3BsYXlQcm9maWxlQnlEZWZhdWx0IiwiRElTUExBWV9QUk9GSUxFX1JBVyIsImRpc3BsYXlQcm9maWxlUmF3IiwiRElTUExBWV9QUk9GSUxFX0xJQl9EMyIsImRpc3BsYXlQcm9maWxlTGliRDMiLCJESVNQTEFZX1BST0ZJTEVfTElCX0FNQ0hBUlRTIiwiZGlzcGxheVByb2ZpbGVMaWJBbUNoYXJ0cyIsIndpbmRvdyIsImdlb3BvcnRhbENvbnRy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RTFOLFFBQU0sQ0FBQzZGLEtBQVAsQ0FBYSw0Q0FBYixFQUQ2RSxDQUc3RTs7QUFDQSxNQUFJLE9BQU84SCxRQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ2pDM04sVUFBTSxDQUFDd0ksR0FBUCxDQUFXLCtCQUFYO0FBQ0E7QUFDSDs7QUFFRCxNQUFJdUcsT0FBTyxHQUFHQyxpRkFBdUIsQ0FBQ08seUJBQXhCLENBQWtEOUIsSUFBbEQsRUFBd0R2SyxTQUF4RCxFQUFtRXdLLE9BQW5FLEVBQTRFdk4sYUFBNUUsQ0FBZCxDQVQ2RSxDQVU3RTs7QUFDQSxNQUFJNE8sT0FBSixFQUFhO0FBQ1QsU0FBS3RNLFFBQUwsR0FBZ0JzTSxPQUFoQjtBQUNIO0FBQ0osQ0FkRDs7QUFnQmU1Tyw0RUFBZixFLENBRUE7O0FBQ0EsSUFBSXFQLE1BQU0sQ0FBQ3BQLENBQVgsRUFBYztBQUNWLE1BQUksQ0FBQ29QLE1BQU0sQ0FBQ3BQLENBQVAsQ0FBU3FQLGdCQUFkLEVBQWdDO0FBQzVCRCxVQUFNLENBQUNwUCxDQUFQLENBQVNxUCxnQkFBVCxHQUE0QixFQUE1QjtBQUNIOztBQUNERCxRQUFNLENBQUNwUCxDQUFQLENBQVNxUCxnQkFBVCxDQUEwQnRQLGFBQTFCLEdBQTBDQSxhQUExQztBQUNIIiwiZmlsZSI6Ii4vc3JjL0xlYWZsZXQvQ29udHJvbHMvRWxldmF0aW9uUGF0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQW1DaGFydHMsIGQzICovXG5pbXBvcnQgU2VydmljZUFsdGkgZnJvbSBcImdlb3BvcnRhbC1hY2Nlc3MtbGliL3NyYy9TZXJ2aWNlcy9BbHRpL0FsdGlcIjtcbmltcG9ydCBMIGZyb20gXCJsZWFmbGV0XCI7XG5pbXBvcnQgXCJsZWFmbGV0LWRyYXdcIjtcbmltcG9ydCBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0LWRyYXcvZGlzdC9sZWFmbGV0LmRyYXctc3JjLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vQ29tbW9uL0NTUy9HUGdlbmVyYWxXaWRnZXQuY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9Db21tb24vQ1NTL0dQZWxldmF0aW9uUGF0aC5jc3NcIjtcbmltcG9ydCBcIi4uL0NTUy9HUGdlbmVyYWxXaWRnZXRMZWFmbGV0LmNzc1wiO1xuaW1wb3J0IFwiLi4vQ1NTL0NvbnRyb2xzL0VsZXZhdGlvblBhdGgvR1BlbGV2YXRpb25QYXRoTGVhZmxldC5jc3NcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbmltcG9ydCBSaWdodE1hbmFnZW1lbnQgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9DaGVja1JpZ2h0TWFuYWdlbWVudFwiO1xuaW1wb3J0IElEIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHMvU2VsZWN0b3JJRFwiO1xuaW1wb3J0IFBvc2l0aW9uRm9ybWF0ZXIgZnJvbSBcIi4vVXRpbHMvUG9zaXRpb25Gb3JtYXRlclwiO1xuaW1wb3J0IEljb25EZWZhdWx0IGZyb20gXCIuL1V0aWxzL0ljb25EZWZhdWx0XCI7XG5pbXBvcnQgRWxldmF0aW9uUGF0aERPTSBmcm9tIFwiLi4vLi4vQ29tbW9uL0NvbnRyb2xzL0VsZXZhdGlvblBhdGhET01cIjtcbmltcG9ydCBQcm9maWxlRWxldmF0aW9uUGF0aERPTSBmcm9tIFwiLi4vLi4vQ29tbW9uL0NvbnRyb2xzL1Byb2ZpbGVFbGV2YXRpb25QYXRoRE9NXCI7XG5cbnZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiRWxldmF0aW9uUGF0aFwiKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogTGVhZmxldCBDb250cm9sIENsYXNzIHRvIGNvbXB1dGUgYW5kIGRpc3BsYXkgUHJvZmlsIEVsZXZhdGlvbi5cbiAqXG4gKiBVc2Uge0BsaW5rIG1vZHVsZTpDb250cm9scy5FbGV2YXRpb25QYXRoIEwuZ2VvcG9ydGFsQ29udHJvbC5FbGV2YXRpb25QYXRoKCl9IGZhY3RvcnkgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiB0aGF0IGNsYXNzLlxuICpcbiAqICoqRXh0ZW5kcyoqIExlYWZsZXQgPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NvbnRyb2xcIiB0YXJnZXQ9XCJfYmxhbmtcIj5MLkNvbnRyb2w8L2E+IG5hdGl2ZSBjbGFzcy5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgTC5nZW9wb3J0YWxDb250cm9sLkVsZXZhdGlvblBhdGhcbiAqL1xudmFyIEVsZXZhdGlvblBhdGggPSBMLkNvbnRyb2wuZXh0ZW5kKC8qKiBAbGVuZHMgTC5nZW9wb3J0YWxDb250cm9sLkVsZXZhdGlvblBhdGgucHJvdG90eXBlICovIHtcblxuICAgIGluY2x1ZGVzIDogRWxldmF0aW9uUGF0aERPTSxcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgZHUgc2VydmljZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvcHRpb25zIDoge1xuICAgICAgICBwb3NpdGlvbiA6IFwidG9wbGVmdFwiLFxuICAgICAgICBhY3RpdmUgOiBmYWxzZSxcbiAgICAgICAgZWxldmF0aW9uUGF0aE9wdGlvbnMgOiB7fSxcbiAgICAgICAgc3R5bGVzT3B0aW9ucyA6IHt9LFxuICAgICAgICBkaXNwbGF5UHJvZmlsZU9wdGlvbnMgOiB7XG4gICAgICAgICAgICBncmVhdGVyU2xvcGUgOiB0cnVlLFxuICAgICAgICAgICAgbWVhblNsb3BlIDogdHJ1ZSxcbiAgICAgICAgICAgIGFzY2VuZGluZ0VsZXZhdGlvbiA6IHRydWUsXG4gICAgICAgICAgICBkZXNjZW5kaW5nRWxldmF0aW9uIDogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRTbG9wZSA6IHRydWUsXG4gICAgICAgICAgICBhcHBseSA6IG51bGwsXG4gICAgICAgICAgICB0YXJnZXQgOiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yIEVsZXZhdGlvblBhdGhcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBFbGV2YXRpb25QYXRoIGNvbnRyb2wgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIFtvcHRpb25zLmFwaUtleV0gLSBBUEkga2V5IGZvciBzZXJ2aWNlcyBjYWxsIChpc29jdXJ2ZSBhbmQgYXV0b2NvbXBsZXRlIHNlcnZpY2VzKSwgbWFuZGF0b3J5IGlmIGF1dG9jb25mIHNlcnZpY2UgaGFzIG5vdCBiZWVuIGNoYXJnZWQgaW4gYWR2YW5jZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3NsID0gdHJ1ZV0gLSB1c2Ugb2Ygc3NsIG9yIG5vdCAoZGVmYXVsdCB0cnVlLCBzZXJ2aWNlIHJlcXVlc3RlZCB1c2luZyBodHRwcyBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFjdGl2ZV0gLSBTcGVjaWZ5IGlmIHdpZGdldCBoYXMgdG8gYmUgYWN0aXZlZCB0byBkcmF3aW5nICh0cnVlKSBvciBub3QgKGZhbHNlKSBvbiBtYXAgbG9hZGluZy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWxldmF0aW9uUGF0aE9wdGlvbnMgPSB7fV0gLSBlbGV2YXRpb24gc2VydmljZSBvcHRpb25zLiBTZWUge0BsaW5rIGh0dHA6Ly9pZ25mLmdpdGh1Yi5pby9nZW9wb3J0YWwtYWNjZXNzLWxpYi9sYXRlc3QvanNkb2MvbW9kdWxlLVNlcnZpY2VzLmh0bWwjfmdldEFsdGl0dWRlIEdwLlNlcnZpY2VzLmdldEFsdGl0dWRlKCl9IHRvIGtub3cgYWxsIGVsZXZhdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucyA9IHt9XSAtIHByb2ZpbGUgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMuYXBwbHldIC0gZnVuY3Rpb24gdG8gZGlzcGxheSBwcm9maWwgcGFuZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucy50YXJnZXRdIC0gY29udGFpbmVyIERPTSBmb3IgdGhlIHByb2ZpbCBwYW5lbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucy5ncmVhdGVyU2xvcGUgPSB0cnVlXSAtIGRpc3BsYXkgdGhlIGdyZWF0ZXIgc2xvcGUgaW50byB0aGUgZ3JhcGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucy5tZWFuU2xvcGUgPSB0cnVlXSAtICBkaXNwbGF5IHRoZSBtZWFuIHNsb3BlIGludG8gdGhlIGdyYXBoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMuYXNjZW5kaW5nRWxldmF0aW9uID0gdHJ1ZV0gLSAgZGlzcGxheSB0aGUgYXNjZW5kaW5nIGVsZXZhdGlvbiBpbnRvIHRoZSBncmFwaFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzcGxheVByb2ZpbGVPcHRpb25zLmRlc2NlbmRpbmdFbGV2YXRpb24gPSB0cnVlXSAtICBkaXNwbGF5IHRoZSBkZXNjZW5kaW5nIGVsZXZhdGlvbiBpbnRvIHRoZSBncmFwaFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzcGxheVByb2ZpbGVPcHRpb25zLmN1cnJlbnRTbG9wZSA9IHRydWVdIC0gIGRpc3BsYXkgY3VycmVudCBzbG9wZSB2YWx1ZSBvbiBwcm9maWxlIG1vdXNlb3ZlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgdmFyIGUgPSBMLmdlb3BvcnRhbENvbnRyb2wuRWxldmF0aW9uUGF0aCh7XG4gICAgICogICAgICBhY3RpdmUgOiBmYWxzZSxcbiAgICAgKiAgICAgIHN0eWxlc09wdGlvbnMgOiB7fSxcbiAgICAgKiAgICAgIGVsZXZhdGlvblBhdGhPcHRpb25zIDoge30sXG4gICAgICogICAgICBkaXNwbGF5UHJvZmlsZU9wdGlvbnMgOiB7XG4gICAgICogICAgICAgYXBwbHkgOiBudWxsLFxuICAgICAqICAgICAgIHRhcmdldCA6IG51bGxcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfSk7XG4gICAgICogRXhlbXBsZXMgOlxuICAgICAqIC0gZGlzcGxheVByb2ZpbGVPcHRpb25zLmFwcGx5IDogbnVsbFxuICAgICAqIC0gZGlzcGxheVByb2ZpbGVPcHRpb25zLmFwcGx5IDogZnVuY3Rpb24gKGVsZXZhdGlvbnMsIGNvbnRhaW5lciwgY29udGV4dCkgeyAgLy8gZG8gc29tZSBzdHVmZi4uLiB9XG4gICAgICogLSBkaXNwbGF5UHJvZmlsZU9wdGlvbnMuYXBwbHkgOiBvbC5jb250cm9sLkVsZXZhdGlvblBhdGguRElTUExBWV9QUk9GSUxFX3tMSUJfQU1DSEFSVFMgfCBMSUJfRDMgfCBSQVd9XG4gICAgICogKGRldGVjdCBhdXRvIGxpYi4gOiBkMyAvIEFtQ2hhcnRzKVxuICAgICAqL1xuICAgIGluaXRpYWxpemUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBvbiB0cmFuc21ldCBsZXMgb3B0aW9ucyBhdSBjb250cm9sZVxuICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAvLyB1dWlkXG4gICAgICAgIHRoaXMuX3VpZCA9IElELmdlbmVyYXRlKCk7XG5cbiAgICAgICAgLy8gaW5pdGlhbGlzYXRpb25cbiAgICAgICAgdGhpcy5faW5pdERpc3BsYXlQcm9maWxlT3B0aW9ucygpO1xuXG4gICAgICAgIC8vIGxlcyBjb250YWluZXJcbiAgICAgICAgdGhpcy5fc2hvd0NvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BpY3RvQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFuZWxDb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm9maWxDb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWl0aW5nQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5mb0NvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgLy8gdGltZXIgc3VyIGxhIGZlbmV0cmUgZCdpbmZvcm1hdGlvbnMgZGVzIGRvbm7DqWVzXG4gICAgICAgIHRoaXMuX3RpbWVySGRsciA9IG51bGw7XG5cbiAgICAgICAgLy8gZGV0ZWN0aW9uIHNpIGxlIHBhbm5lYXUgZXN0IHJlZHVpdFxuICAgICAgICB0aGlzLl9yZWR1Y2VQYW5lbCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNvdWNoZSB2ZWN0b3JpZWxsZSBkYW5zIGxhcXVlbGxlIHNlcm9udCBzYWlzaXMgbGVzIHBvaW50cyAoZmVhdHVyZXMgY2ktZGVzc3VzKVxuICAgICAgICB0aGlzLl9mZWF0dXJlc0xheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdElkTGF5ZXIgPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50SWRMYXllciA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGZWF0dXJlID0gbnVsbDtcblxuICAgICAgICAvLyBncmFwaFxuICAgICAgICB0aGlzLl9wcm9maWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFya2VyID0gbnVsbDtcblxuICAgICAgICAvLyBnZW9tZXRyeSDDoCB0cmFuc21ldHRyZSBhdSBzZXJ2aWNlIDogIHsgbG9uIDogW10sIGxhdCA6IFtdfVxuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG5cbiAgICAgICAgLy8gZGlzdGFuY2UgZHUgc2VnbWVudFxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IDA7XG5cbiAgICAgICAgLy8gZGF0YSBlbGV2YXRpb25zXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICAvLyBhdWN1biBkcm9pdHMgc3VyIGxlcyByZXNzb3VyY2VzXG4gICAgICAgIHRoaXMuX25vUmlnaHRNYW5hZ2VtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZ2VzdGlvbiBkZXMgZHJvaXRzIHN1ciBsZXMgcmVzc291cmNlcy9zZXJ2aWNlc1xuICAgICAgICB0aGlzLl9jaGVja1JpZ2h0c01hbmFnZW1lbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoaXMuYWRkVG8obWFwKSB3aGVuIHRoZSBjb250cm9sIGlzIGFkZGVkIG9uIHRoZSBtYXBcbiAgICAgKiBhbmQgZmlsbHMgdmFyaWFibGUgJ3RoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKScsXG4gICAgICogYW5kIGNyZWF0ZSBvciBkaXNhYmxlIGV2ZW50cyBvbiBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIC0gdGhlIG1hcFxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkFkZCA6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgLy8gaW5pdGlhbGlzYXRpb24gZHUgRE9NIGR1IGNvbXBvc2FudFxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5faW5pdExheW91dCgpO1xuXG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIC8vIGxvcnMgZGUgbCdham91dCDDoCBsYSBtYXAsIG9uIGFjdGl2ZSBsYSBzYWlzaWUgZHUgcG9pbnQsXG4gICAgICAgICAgICAvLyBtYWlzIHNldWxlbWVudCBzaSBsZSB3aWRnZXQgZXN0IG91dmVydFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJvZmlsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYW5lbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuX3BhbmVsQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZU1hcEludGVyYWN0aW9uKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWFjdGl2YXRlIG9mIGV2ZW50cyB0aGF0IG1heSBpbnRlcmZlcmUgd2l0aCB0aGUgbWFwXG4gICAgICAgIEwuRG9tRXZlbnRcbiAgICAgICAgICAgIC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpXG4gICAgICAgICAgICAuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICAgICAqIGFuZCByZW1vdmVzIGV2ZW50cyBvbiBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUmVtb3ZlIDogZnVuY3Rpb24gKC8qIG1hcCAqLykge30sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgaW5pdCByZXNvdXJjZXMgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBjb25zdHJ1Y3RvclxuICAgICAqIGFuZCBjaGVjayB0aGUgcmlnaHRzIHRvIHJlc291cmNlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tSaWdodHNNYW5hZ2VtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmlnaHRNYW5hZ2VtZW50ID0gUmlnaHRNYW5hZ2VtZW50LmNoZWNrKHtcbiAgICAgICAgICAgIGtleSA6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgICAgICByZXNvdXJjZXMgOiBbXCJTRVJWSUNFX0NBTENVTF9BTFRJTUVUUklRVUVfUlNDXCJdLFxuICAgICAgICAgICAgc2VydmljZXMgOiBbXCJFbGV2YXRpb25MaW5lXCJdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmlnaHRNYW5hZ2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ub1JpZ2h0TWFuYWdlbWVudCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiByZWN1cMOocmUgbGVzIGluZm9ybWF0aW9ucyB1dGlsZXNcbiAgICAgICAgLy8gc3VyIGNlIGNvbnRyb2xlLCBvbiBuZSBzJ29jY3VwZSBwYXMgZGUgbGEgcmVzc291cmNlIGNhciBlbGxlIGVzdCB1bmlxdWUuLi5cbiAgICAgICAgLy8gRXguIGxhIGNsZWYgQVBJIGlzc3VlIGRlIGwnYXV0b2NvbmZpZ3VyYXRpb24gc2kgZWxsZSBuJ2EgcGFzXG4gICAgICAgIC8vIMOpdMOpIHJlbnNlaWduw6llLlxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hcGlLZXkgPSByaWdodE1hbmFnZW1lbnQua2V5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBpbml0IGFwcGxpY2F0aW9uICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBhbmQgaW5pdGlhbGl6ZSB0aGUgLi4uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0RGlzcGxheVByb2ZpbGVPcHRpb25zIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXN0aW9uIGRlIGwnYWZmaWNoYWdlIGR1IHByb2ZpbFxuICAgICAgICB2YXIgX3Byb2ZpbGVPcHRzID0gdGhpcy5vcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucztcblxuICAgICAgICAvLyBnZXN0aW9uIGRlIGxhIGZvbmN0aW9uIGR1IHByb2ZpbFxuICAgICAgICB2YXIgZGlzcGxheUZ1bmN0aW9uID0gX3Byb2ZpbGVPcHRzLmFwcGx5O1xuICAgICAgICBfcHJvZmlsZU9wdHMuYXBwbHkgPSAodHlwZW9mIGRpc3BsYXlGdW5jdGlvbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgPyBkaXNwbGF5RnVuY3Rpb24gOiBFbGV2YXRpb25QYXRoLkRJU1BMQVlfUFJPRklMRV9CWV9ERUZBVUxUO1xuXG4gICAgICAgIC8vIGdlc3Rpb24gZHUgY29udGFpbmVyIGR1IHByb2ZpbFxuICAgICAgICB2YXIgZGlzcGxheUNvbnRhaW5lciA9IF9wcm9maWxlT3B0cy50YXJnZXQ7XG4gICAgICAgIF9wcm9maWxlT3B0cy50YXJnZXQgPSAodHlwZW9mIGRpc3BsYXlDb250YWluZXIgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICA/IGRpc3BsYXlDb250YWluZXIgOiBudWxsO1xuXG4gICAgICAgIC8vIGxlcyBhdXRyZXMgb3B0aW9uc1xuICAgICAgICB2YXIgX3Byb3RvT3B0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mIF9wcm9maWxlT3B0cy5tZWFuU2xvcGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIF9wcm9maWxlT3B0cy5tZWFuU2xvcGUgPSBfcHJvdG9PcHRzLmRpc3BsYXlQcm9maWxlT3B0aW9ucy5tZWFuU2xvcGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBfcHJvZmlsZU9wdHMuZ3JlYXRlclNsb3BlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBfcHJvZmlsZU9wdHMuZ3JlYXRlclNsb3BlID0gX3Byb3RvT3B0cy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMuZ3JlYXRlclNsb3BlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgX3Byb2ZpbGVPcHRzLmFzY2VuZGluZ0VsZXZhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgX3Byb2ZpbGVPcHRzLmFzY2VuZGluZ0VsZXZhdGlvbiA9IF9wcm90b09wdHMuZGlzcGxheVByb2ZpbGVPcHRpb25zLmFzY2VuZGluZ0VsZXZhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIF9wcm9maWxlT3B0cy5kZXNjZW5kaW5nRWxldmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBfcHJvZmlsZU9wdHMuZGVzY2VuZGluZ0VsZXZhdGlvbiA9IF9wcm90b09wdHMuZGlzcGxheVByb2ZpbGVPcHRpb25zLmRlc2NlbmRpbmdFbGV2YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBfcHJvZmlsZU9wdHMuY3VycmVudFNsb3BlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBfcHJvZmlsZU9wdHMuY3VycmVudFNsb3BlID0gX3Byb3RvT3B0cy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMuY3VycmVudFNsb3BlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgaW5pdCBkb20gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoaXMub25BZGQobWFwKVxuICAgICAqIGFuZCBpbml0aWFsaXplIHRoZSBjb250YWluZXIgSFRNTEVsZW1lbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRMYXlvdXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBtYWluIGNvbnRhaW5lclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY3JlYXRlTWFpbkNvbnRhaW5lckVsZW1lbnQoKTtcblxuICAgICAgICB2YXIgaW5wdXRTaG93ID0gdGhpcy5fc2hvd0NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZVNob3dFbGV2YXRpb25QYXRoRWxlbWVudCgpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXRTaG93KTtcblxuICAgICAgICAvLyBtb2RlIFwiY29sbGFwc2VkXCJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dDb250YWluZXIuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGljdG8gPSB0aGlzLl9waWN0b0NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZVNob3dFbGV2YXRpb25QYXRoUGljdG9FbGVtZW50KCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChwaWN0byk7XG5cbiAgICAgICAgLy8gcGFubmVhdVxuICAgICAgICB2YXIgcGFuZWwgPSB0aGlzLl9wYW5lbENvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZXZhdGlvblBhdGhQYW5lbEVsZW1lbnQoKTtcblxuICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX2NyZWF0ZUVsZXZhdGlvblBhdGhQYW5lbEhlYWRlckVsZW1lbnQoKTtcbiAgICAgICAgcGFuZWwuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcblxuICAgICAgICAvLyBwcm9maWxcbiAgICAgICAgdmFyIHByb2ZpbCA9IHRoaXMuX3Byb2ZpbENvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZXZhdGlvblBhdGhQYW5lbFByb2ZpbEVsZW1lbnQoKTtcbiAgICAgICAgcGFuZWwuYXBwZW5kQ2hpbGQocHJvZmlsKTtcblxuICAgICAgICAvLyB3YWl0aW5nXG4gICAgICAgIHZhciB3YWl0aW5nID0gdGhpcy5fd2FpdGluZ0NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZXZhdGlvblBhdGhXYWl0aW5nRWxlbWVudCgpO1xuICAgICAgICBwYW5lbC5hcHBlbmRDaGlsZCh3YWl0aW5nKTtcblxuICAgICAgICAvLyBpbmZvXG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5faW5mb0NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZXZhdGlvblBhdGhJbmZvcm1hdGlvbnNFbGVtZW50KCk7XG4gICAgICAgIHBhbmVsLmFwcGVuZENoaWxkKGluZm8pO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChwYW5lbCk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIGhhbmRsZXJzIGV2ZW50cyB0byBkb20gIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgZXZlbnQgJ2NsaWNrJyBvbiAnJyBwaWN0b1xuICAgICAqIGFuZCAuLi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gSFRNTEVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25TaG93RWxldmF0aW9uUGF0aENsaWNrIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKGUpO1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIGludGVyYWN0aW9ucyBhdmVjIGxhIGNhcnRlXG4gICAgICAgIGlmICghdGhpcy5fcmVkdWNlUGFuZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG93Q29udGFpbmVyLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9waWN0b0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhbmVsQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVNYXBJbnRlcmFjdGlvbihtYXApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm9maWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhbmVsQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVNYXBJbnRlcmFjdGlvbihtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucy50YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGljdG9Db250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wYW5lbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVkdWNlUGFuZWwgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGV2ZW50ICdjbGljaycgb24gJycgcGljdG9cbiAgICAgKiAoY2YuIHRoaXMuKSxcbiAgICAgKiBhbmQgcmVkdWNlIHRoZSBwYW5lbFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblJlZHVjZUVsZXZhdGlvblBhdGhQYW5lbENsaWNrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZWR1Y2VQYW5lbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BpY3RvQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuX3BhbmVsQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGV2ZW50ICdjbGljaycgb24gJycgcGljdG9cbiAgICAgKiAoY2YuIHRoaXMuKSxcbiAgICAgKiBhbmQgZGlzcGxheSB0aGUgcGFuZWwgaW5mb1xuICAgICAqIFRPRE9cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25PcGVuRWxldmF0aW9uUGF0aEluZm9DbGljayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gb3B0aW9ucyBkJ2FmZmljaGFnZVxuICAgICAgICB2YXIgbWVhblNsb3BlID0gdGhpcy5vcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucy5tZWFuU2xvcGU7XG4gICAgICAgIHZhciBncmVhdGVyU2xvcGUgPSB0aGlzLm9wdGlvbnMuZGlzcGxheVByb2ZpbGVPcHRpb25zLmdyZWF0ZXJTbG9wZTtcbiAgICAgICAgdmFyIGFzY2VuZGluZ0VsZXZhdGlvbiA9IHRoaXMub3B0aW9ucy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMuYXNjZW5kaW5nRWxldmF0aW9uO1xuICAgICAgICB2YXIgZGVzY2VuZGluZ0VsZXZhdGlvbiA9IHRoaXMub3B0aW9ucy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMuZGVzY2VuZGluZ0VsZXZhdGlvbjtcblxuICAgICAgICAvLyBjbGVhblxuICAgICAgICB2YXIgZGl2ID0gdGhpcy5faW5mb0NvbnRhaW5lcjtcbiAgICAgICAgaWYgKGRpdi5jaGlsZEVsZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgd2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0aW9uIGRlcyBpbmZvbWF0aW9uc1xuXG4gICAgICAgIGlmIChhc2NlbmRpbmdFbGV2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVsZXZhdGlvblBhdGhJbmZvcm1hdGlvbnNJdGVtKFwiRMOpbml2ZWzDqSBwb3NpdGlmIDogXCIgKyB0aGlzLl9kYXRhLmFzY2VuZGluZ0VsZXZhdGlvbi50b0xvY2FsZVN0cmluZygpICsgXCIgbVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjZW5kaW5nRWxldmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zSXRlbShcIkTDqW5pdmVsw6kgbsOpZ2F0aWYgOiBcIiArIHRoaXMuX2RhdGEuZGVzY2VuZGluZ0VsZXZhdGlvbi50b0xvY2FsZVN0cmluZygpICsgXCIgbVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZWFuU2xvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVsZXZhdGlvblBhdGhJbmZvcm1hdGlvbnNJdGVtKFwiUGVudGUgbW95ZW5uZSA6IFwiICsgdGhpcy5fZGF0YS5tZWFuU2xvcGUudG9Mb2NhbGVTdHJpbmcoKSArIFwiICVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JlYXRlclNsb3BlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zSXRlbShcIlBsdXMgZm9ydGUgcGVudGUgOiBcIiArIHRoaXMuX2RhdGEuZ3JlYXRlclNsb3BlLnRvTG9jYWxlU3RyaW5nKCkgKyBcIiAlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdyBkZXMgaW5mb3JtYXRpb25zICFcbiAgICAgICAgaWYgKGRpdi5jbGFzc05hbWUgPT09IFwiR1BlbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zQ29udGFpbmVyVmlzaWJsZVwiKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXJIZGxyKTtcbiAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIkdQZWxldmF0aW9uUGF0aEluZm9ybWF0aW9uc0NvbnRhaW5lckhpZGRlblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiR1BlbGV2YXRpb25QYXRoSW5mb3JtYXRpb25zQ29udGFpbmVyVmlzaWJsZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGlkZGVuIGRlcyBpbmZvcm1hdGlvbnMgIVxuICAgICAgICB0aGlzLl90aW1lckhkbHIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIkdQZWxldmF0aW9uUGF0aEluZm9ybWF0aW9uc0NvbnRhaW5lckhpZGRlblwiO1xuICAgICAgICB9LCA0MDAwKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMgTWFwIGludGVyYWN0aW9ucyBtYW5hZ2VtZW50ICMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5vblNob3dFbGV2YXRpb25QYXRoQ2xpY2ssXG4gICAgICogYW5kIGNhbGxzIG1ldGhvZCBjb3JyZXNwb25kaW5nIHRvIGN1cnJlbnQgZGVsaW1pdGF0aW9uLCBpZiB3aWRnZXQgaXMgbm90IGNvbGxhcHNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgLSBjb250cm9sIG1hcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hY3RpdmF0ZU1hcEludGVyYWN0aW9uIDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIl9hY3RpdmF0ZU1hcEludGVyYWN0aW9uKClcIik7XG5cbiAgICAgICAgLy8gQ3JlYXRpb24gZGUgbGEgY291Y2hlIHZlY3RvcmllbGxlIHN1ciBsYXF1ZWxsZSBvbiB2YSBkZXNzaW5lclxuICAgICAgICBpZiAodGhpcy5fZmVhdHVyZXNMYXllciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXNMYXllciA9IG5ldyBMLkZlYXR1cmVHcm91cCgpO1xuICAgICAgICAgICAgbWFwLmFkZExheWVyKHRoaXMuX2ZlYXR1cmVzTGF5ZXIpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvKiBldmVuZW1lbnRzIDogb24gZGVzYWN0aXZlIGxlIG1lbnUgc3lzdGVtZSBwb3VyIGxhIHNhaXNpZSAqL1xuICAgICAgICAgICAgbWFwLm9uKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgICAgICAvKiBldmVuZW1lbnQgc3VyIGxhIGNhcnRlIGxvcnMgZCd1bmUgc2Fpc2llLFxuICAgICAgICAgICAgb24geSBham91dGUgbGUgbGF5ZXIsIGV0IG9uIHkgc3RvY2tlIGxlcyBjb29yZG9ubsOpZXMgKi9cbiAgICAgICAgICAgIG1hcC5vbihcImRyYXc6Y3JlYXRlZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImRyYXc6Y3JlYXRlZFwiKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuX2N1cnJlbnRJZExheWVyID0gTC5VdGlsLnN0YW1wKGUubGF5ZXIpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fZ2V0RmVhdHVyZUdlb21ldHJ5KGUubGF5ZXIpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2FkZEZlYXR1cmVMYXllcihlLmxheWVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvKiBldmVuZW1lbnRzICovXG4gICAgICAgICAgICBtYXAub24oXCJkcmF3OmRyYXdzdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiZHJhdzpkcmF3c3RhcnRcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlRmVhdHVyZUxheWVyKHNlbGYuX2xhc3RJZExheWVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9sYXN0SWRMYXllciA9IHNlbGYuX2N1cnJlbnRJZExheWVyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8qIGV2ZW5lbWVudHMgKi9cbiAgICAgICAgICAgIG1hcC5vbihcImRyYXc6ZHJhd3N0b3BcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImRyYXc6ZHJhd3N0b3BcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuZWxldmF0aW9uUGF0aE9wdGlvbnMub25TdWNjZXNzID09PSBcInVuZGVmaW5lZFwiICYmIHNlbGYub3B0aW9ucy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMudGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3BpY3RvQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFuZWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5fYWx0aVJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWN0aXZhdGVQb2x5TGluZUludGVyYWN0aW9uKG1hcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBkcmF3IGludGVyYWN0aW9uIGZyb20gbWFwIChpZiBleGlzdHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIC0gY29udHJvbCBtYXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlTWFwSW50ZXJhY3Rpb24gOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmVhdHVyZXNMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwLm9mZihcImRyYXc6Y3JlYXRlZFwiKTtcbiAgICAgICAgICAgIG1hcC5vZmYoXCJkcmF3OmRyYXdzdGFydFwiKTtcbiAgICAgICAgICAgIG1hcC5vZmYoXCJkcmF3OmRyYXdzdG9wXCIpO1xuICAgICAgICAgICAgbWFwLnJlbW92ZUxheWVyKHRoaXMuX2ZlYXR1cmVzTGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXNMYXllciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0SWRMYXllciA9IHRoaXMuX2N1cnJlbnRJZExheWVyID0gMDtcblxuICAgICAgICAvLyBGSVhNRSBkZWxldGUgdGhpcy5fY3VycmVudEZlYXR1cmUgP1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEZlYXR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRGZWF0dXJlLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5fYWN0aXZhdGVNYXBJbnRlcmFjdGlvbixcbiAgICAgKiBhbmQgY3JlYXRlcyBtYXAgcG9seWxpbmUgZHJhd2luZyBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgLSBjb250cm9sIG1hcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hY3RpdmF0ZVBvbHlMaW5lSW50ZXJhY3Rpb24gOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RmVhdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEZlYXR1cmUuZGlzYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGlzdGUgZGVzIG9wdGlvbnMgcGFyIGRlZmF1dFxuICAgICAgICAvLyBjZi4gaHR0cHM6Ly9sZWFmbGV0LmdpdGh1Yi5pby9MZWFmbGV0LmRyYXcvZG9jcy9sZWFmbGV0LWRyYXctbGF0ZXN0Lmh0bWxcbiAgICAgICAgLy8gdmFyIHBvbHlsaW5lT3B0aW9ucyA9IHtcbiAgICAgICAgLy8gICAgIGFsbG93SW50ZXJzZWN0aW9uIDogdHJ1ZSxcbiAgICAgICAgLy8gICAgIHJlcGVhdE1vZGUgOiBmYWxzZSxcbiAgICAgICAgLy8gICAgIGRyYXdFcnJvciA6IHtcbiAgICAgICAgLy8gICAgICAgICBjb2xvciA6IFwiI2IwMGIwMFwiLFxuICAgICAgICAvLyAgICAgICAgIHRpbWVvdXQgOiAyNTAwXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAgaWNvbiA6IG5ldyBMLkRpdkljb24oe1xuICAgICAgICAvLyAgICAgICAgIGljb25TaXplIDogbmV3IEwuUG9pbnQoOCwgOCksXG4gICAgICAgIC8vICAgICAgICAgY2xhc3NOYW1lIDogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24nXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICAgIHRvdWNoSWNvbiA6IG5ldyBMLkRpdkljb24oe1xuICAgICAgICAvLyAgICAgICAgIGljb25TaXplIDogbmV3IEwuUG9pbnQoMjAsIDIwKSxcbiAgICAgICAgLy8gICAgICAgICBjbGFzc05hbWUgOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LXRvdWNoLWljb24nXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICAgIGd1aWRlbGluZURpc3RhbmNlIDogMjAsXG4gICAgICAgIC8vICAgICBtYXhHdWlkZUxpbmVMZW5ndGggOiA0MDAwLFxuICAgICAgICAvLyAgICAgc2hhcGVPcHRpb25zIDoge1xuICAgICAgICAvLyAgICAgICAgIHN0cm9rZSA6IHRydWUsXG4gICAgICAgIC8vICAgICAgICAgY29sb3IgOiAnI2YwNmVhYScsXG4gICAgICAgIC8vICAgICAgICAgd2VpZ2h0IDogNCxcbiAgICAgICAgLy8gICAgICAgICBvcGFjaXR5IDogMC41LFxuICAgICAgICAvLyAgICAgICAgIGZpbGwgOiBmYWxzZSxcbiAgICAgICAgLy8gICAgICAgICBjbGlja2FibGUgOiB0cnVlXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAgbWV0cmljIDogdHJ1ZSwgLy8gV2hldGhlciB0byB1c2UgdGhlIG1ldHJpYyBtZWFzdXJlbWVudCBzeXN0ZW0gb3IgaW1wZXJpYWxcbiAgICAgICAgLy8gICAgIGZlZXQgOiB0cnVlLCAvLyBXaGVuIG5vdCBtZXRyaWMsIHRvIHVzZSBmZWV0IGluc3RlYWQgb2YgeWFyZHMgZm9yIGRpc3BsYXkuXG4gICAgICAgIC8vICAgICBuYXV0aWMgOiBmYWxzZSwgLy8gV2hlbiBub3QgbWV0cmljLCBub3QgZmVldCB1c2UgbmF1dGljIG1pbGUgZm9yIGRpc3BsYXlcbiAgICAgICAgLy8gICAgIHNob3dMZW5ndGggOiB0cnVlLCAvLyBXaGV0aGVyIHRvIGRpc3BsYXkgZGlzdGFuY2UgaW4gdGhlIHRvb2x0aXBcbiAgICAgICAgLy8gICAgIHpJbmRleE9mZnNldCA6IDIwMDAgLy8gVGhpcyBzaG91bGQgYmUgPiB0aGFuIHRoZSBoaWdoZXN0IHotaW5kZXggYW55IG1hcCBsYXllcnNhbGxvd0ludGVyc2VjdGlvbiA6IHRydWUsXG4gICAgICAgIC8vIH07XG5cbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMub3B0aW9ucy5zdHlsZXNPcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgX3NoYXBlT3B0aW9ucyA9IChPYmplY3Qua2V5cyhzdHlsZXMpLmxlbmd0aCAhPT0gMCkgPyBzdHlsZXMgOiB7XG4gICAgICAgICAgICBzdHJva2UgOiB0cnVlLFxuICAgICAgICAgICAgY29sb3IgOiBcIiNDNzdBMDRcIixcbiAgICAgICAgICAgIHdlaWdodCA6IDQsXG4gICAgICAgICAgICBvcGFjaXR5IDogMC41LFxuICAgICAgICAgICAgZmlsbCA6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3VycmVudEZlYXR1cmUgPSBuZXcgTC5EcmF3LlBvbHlsaW5lKG1hcCwge1xuICAgICAgICAgICAgc2hhcGVPcHRpb25zIDogX3NoYXBlT3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEZlYXR1cmUuZW5hYmxlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNldCBjdXJyZW50IHBvc2l0aW9uIG9mIGZlYXR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciAtIGxheWVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RmVhdHVyZUdlb21ldHJ5IDogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIC8vIG9uIHRyYW5zbWV0IHRvdWpvdXJzIGRlcyBjb29yZG9ubsOpZXMgYXUgc2VydmljZSBlbiBFUFNHOjQzMjZcbiAgICAgICAgbG9nZ2VyLmxvZyhsYXllci5nZXRMYXRMbmdzKCkpO1xuXG4gICAgICAgIGlmICh0aGlzLl9nZW9tZXRyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBbXTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSAwO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IGxheWVyLmdldExhdExuZ3MoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gb24gdHJhbnNtZXQgYXUgc2VydmljZSBkZXMgY29vcmRvbm7DqWVzIGVuIEVQU0c6NDMyNlxuICAgICAgICAgICAgdmFyIExhdExuZ0kgPSBnZW9tZXRyeVtpXTtcbiAgICAgICAgICAgIHZhciBMYXRMbmdKID0gZ2VvbWV0cnlbaSArIDFdO1xuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9uIDogTGF0TG5nSS5sbmcsXG4gICAgICAgICAgICAgICAgbGF0IDogTGF0TG5nSS5sYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gb24gY2FsY3VsIGxhIGRpc3RhbmNlIGR1IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChMYXRMbmdKKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgKz0gTGF0TG5nSS5kaXN0YW5jZVRvKExhdExuZ0opO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLmxvZyhcIkdlb21ldHJ5XCIsIHRoaXMuX2dlb21ldHJ5KTtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkRpc3RhbmNlXCIsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnQgbGF5ZXIgb2YgZmVhdHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gbGF5ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRGZWF0dXJlTGF5ZXIgOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mZWF0dXJlc0xheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmVhdHVyZXNMYXllci5hZGRMYXllcihsYXllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBsYXllciBmZWF0dXJlIGZyb20gZ3JvdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaWQgLSBpZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUZlYXR1cmVMYXllciA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZlYXR1cmVzTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpZCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXNMYXllci5jbGVhckxheWVycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXNMYXllci5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgQWx0aSByZXF1ZXN0ICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZGUgaXMgY2FsbGVkIGJ5IHRoaXMuIG1ldGhvZCxcbiAgICAgKiBpdCBnZW5lcmF0ZXMgYW5kIHNlbmRzIGFsdGkgcmVxdWVzdCwgdGhlbiBkaXNwbGF5cyByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbHRpUmVxdWVzdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIl9hbHRpUmVxdWVzdFwiKTtcblxuICAgICAgICAvLyBsZXMgY29vcmRvbm7DqWVzIHNvbnQgb2JsaWdhdG9pcmVzXG4gICAgICAgIGlmICghdGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJtaXNzaW5nIHBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3VwcywgYXVjdW4gZHJvaXRzICFcbiAgICAgICAgaWYgKHRoaXMuX25vUmlnaHRNYW5hZ2VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiBjb25zdHJ1aXQgbGVzIG9wdGlvbnMgcG91ciBsYSByZXF1w6p0ZVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vIG9uIHN1cmNoYXJnZSBhdmVjIGxlcyBvcHRpb25zIGRlIGwndXRpbGlzYXRldXJcbiAgICAgICAgTC5VdGlsLmV4dGVuZChvcHRpb25zLCB0aGlzLm9wdGlvbnMuZWxldmF0aW9uUGF0aE9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGF1IGNhcyBvw7kgbGEgY2xlZiBBUEkgbidlc3QgcGFzIHJlbnNlaWduw6llIGRhbnMgbGVzIG9wdGlvbnMgZHUgc2VydmljZSxcbiAgICAgICAgLy8gb24gdXRpbGlzZSBjZWxsZSBkZSBsJ2F1dG9jb25mIG91IGNlbGxlIHJlbnNlaWduw6llIGF1IG5pdmVhdSBkdSBjb250cm9sZVxuICAgICAgICBMLlV0aWwuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFwaUtleSA6IG9wdGlvbnMuYXBpS2V5IHx8IHRoaXMub3B0aW9ucy5hcGlLZXlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2kgbCd1dGlsaXNhdGV1ciBhIHNww6ljaWZpw6kgbGUgcGFyYW3DqHRyZSBzc2wgYXUgbml2ZWF1IGR1IGNvbnRyb2wsIG9uIHMnZW4gc2VydFxuICAgICAgICAvLyB0cnVlIHBhciBkw6lmYXV0IChodHRwcylcbiAgICAgICAgTC5VdGlsLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICAgICAgICBzc2wgOiB0aGlzLm9wdGlvbnMuc3NsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxlIHNhbXBsaW5nIGVzdCBzb2l0IGRlZmluaSBwYXIgbCd1dGlsaXNhdGV1ciAob3B0cyksXG4gICAgICAgIC8vIG91IHNvaXQgY2FsY3Vsw6kgZHluYW1pcXVlbWVudC4uLlxuICAgICAgICB2YXIgX3NhbXBsaW5nID0gb3B0aW9ucy5zYW1wbGluZztcbiAgICAgICAgaWYgKCFfc2FtcGxpbmcpIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGluZyBzYW1wbGluZ1xuICAgICAgICAgICAgdmFyIF9jb21wdXRlU2FtcGxpbmc7XG4gICAgICAgICAgICB2YXIgX2xlbmd0aCA9IHRoaXMuX2N1cnJlbnRGZWF0dXJlLl9tZWFzdXJlbWVudFJ1bm5pbmdUb3RhbDsgLy8gRklYTUUgISEhXG4gICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJsZW5ndGhcIiwgX2xlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcCA9IE1hdGguZmxvb3IoX2xlbmd0aCkgLyA1OyAvLyBlbiBtw6h0cmUgc3VyIHVuIHBhcyBtb3llbiBkZSA1bSAhXG4gICAgICAgICAgICBpZiAocCA+PSAyMDApIHtcbiAgICAgICAgICAgICAgICBfY29tcHV0ZVNhbXBsaW5nID0gMjAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY29tcHV0ZVNhbXBsaW5nID0gTWF0aC5mbG9vcihwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zYW1wbGluZyA9IF9jb21wdXRlU2FtcGxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiB5IGFqb3V0ZSBsZXMgY2FsbGJhY2tzIGFpbnNpIHF1ZSBsZXMgb3B0aW9ucyBwYXIgZGVmYXV0XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgTC5VdGlsLmV4dGVuZChvcHRpb25zLCB7XG5cbiAgICAgICAgICAgIC8qKiBzYW1wbGluZyDDoCAyMDAgKGlzbyBwb3J0YWlsKSAqL1xuICAgICAgICAgICAgc2FtcGxpbmcgOiBfc2FtcGxpbmcsXG5cbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIG9uU3VjY2Vzc1xuICAgICAgICAgICAgb25TdWNjZXNzIDogdGhpcy5vcHRpb25zLmVsZXZhdGlvblBhdGhPcHRpb25zLm9uU3VjY2VzcyB8fCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5kaXNwbGF5UHJvZmlsZU9wdGlvbnMudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9waWN0b0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFuZWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kaXNwbGF5UHJvZmlsKHJlc3VsdC5lbGV2YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fd2FpdGluZ0NvbnRhaW5lci5jbGFzc05hbWUgPSBcIkdQZWxldmF0aW9uUGF0aENhbGNXYWl0aW5nQ29udGFpbmVySGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBjYWxsYmFjayBvbkZhaWx1cmVcbiAgICAgICAgICAgIG9uRmFpbHVyZSA6IHRoaXMub3B0aW9ucy5lbGV2YXRpb25QYXRoT3B0aW9ucy5vbkZhaWx1cmUgfHwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9waWN0b0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgIHNlbGYuX3BhbmVsQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICBzZWxmLl93YWl0aW5nQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1BlbGV2YXRpb25QYXRoQ2FsY1dhaXRpbmdDb250YWluZXJIaWRkZW5cIjtcbiAgICAgICAgICAgICAgICBzZWxmLl93YWl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZXQgZW5maW4sIGxhIGdlb21ldHJpZVxuICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5fZ2VvbWV0cnk7XG4gICAgICAgIEwuVXRpbC5leHRlbmQob3B0aW9ucywge1xuICAgICAgICAgICAgcG9zaXRpb25zIDogcG9zaXRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxvZ2dlci5sb2cob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbWlzZSBlbiBwbGFjZSBkZSBsYSBwYXRpZW5jZVxuICAgICAgICB0aGlzLl93YWl0aW5nQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1BlbGV2YXRpb25QYXRoQ2FsY1dhaXRpbmdDb250YWluZXJWaXNpYmxlXCI7XG5cbiAgICAgICAgLy8gUmVxdWVzdCBhbHRpdHVkZSBzZXJ2aWNlXG4gICAgICAgIHZhciBhbHRpU2VydmljZSA9IG5ldyBTZXJ2aWNlQWx0aShvcHRpb25zKTtcbiAgICAgICAgYWx0aVNlcnZpY2UuY2FsbCgpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgUHJvZmlsIGRpc3BsYXkgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGNvbXB1dGVzIHJlc3VsdHMgZWxldmF0aW9ucyAoWiBhbmQgZGlzdGFuY2UpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGV2YXRpb25zIC0gYXJyYXkgb2YgZWxldmF0aW9uXG4gICAgICogQHJldHVybiB7QXJyYXl9IGVsZXZhdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb21wdXRlRWxldmF0aW9uTWVhc3VyZSA6IGZ1bmN0aW9uIChlbGV2YXRpb25zKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGZyb20gYzEgdG8gYzIgdXNpbmcgdGhlIGhhdmVyc2luZSBmb3JtdWxhXG4gICAgICAgIHZhciBfaGF2ZXJzaW5lRGlzdGFuY2UgPSBmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgICAgICAgICB2YXIgbGF0MSA9IFBvc2l0aW9uRm9ybWF0ZXIuZGVjaW1hbFRvUmFkaWFuKGMxWzFdKTtcbiAgICAgICAgICAgIHZhciBsYXQyID0gUG9zaXRpb25Gb3JtYXRlci5kZWNpbWFsVG9SYWRpYW4oYzJbMV0pO1xuICAgICAgICAgICAgdmFyIGRlbHRhTGF0QnkyID0gKGxhdDIgLSBsYXQxKSAvIDI7XG4gICAgICAgICAgICB2YXIgZGVsdGFMb25CeTIgPSBQb3NpdGlvbkZvcm1hdGVyLmRlY2ltYWxUb1JhZGlhbihjMlswXSAtIGMxWzBdKSAvIDI7XG4gICAgICAgICAgICB2YXIgYSA9IE1hdGguc2luKGRlbHRhTGF0QnkyKSAqIE1hdGguc2luKGRlbHRhTGF0QnkyKSArXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZGVsdGFMb25CeTIpICogTWF0aC5zaW4oZGVsdGFMb25CeTIpICpcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpO1xuICAgICAgICAgICAgcmV0dXJuIDIgKiA2Mzc4MTM3ICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZGF0YSA9IGVsZXZhdGlvbnM7XG5cbiAgICAgICAgdmFyIF91bml0ID0gXCJtXCI7XG5cbiAgICAgICAgdmFyIF9za2V0Y2hQb2ludHMgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICAgICAgLy8gc2VjdGlvbiBhY3R1ZWxsZSBkdSBza2V0Y2ggc3VyIGxhcXVlbGxlIG9uIGVzdFxuICAgICAgICB2YXIgX2N1cnJlbnRTZWN0aW9uID0gMDtcbiAgICAgICAgLy8gbG9uZ3VldXIgY3VtdWzDqWUgZGVzIHNlY3Rpb25zIHByw6ljw6lkZW50ZXNcbiAgICAgICAgdmFyIF9wcmV2aW91c1NlY3Rpb25zTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIF9uZXh0U2VjdGlvbkJlZ2luaW5nID0gX3NrZXRjaFBvaW50c1sxXTtcblxuICAgICAgICAvLyBDYWxjdWwgZGUgbGEgZGlzdGFuY2UgYXUgZMOpcGFydCBwb3VyIGNoYXF1ZSBwb2ludCArIGFycm9uZGkgZGVzIGxhdC9sb25cbiAgICAgICAgX2RhdGFbMF0uZGlzdCA9IDA7XG4gICAgICAgIF9kYXRhWzBdLnNsb3BlID0gMDtcbiAgICAgICAgX2RhdGFbMF0ubGF0ID0gTWF0aC5yb3VuZChfZGF0YVswXS5sYXQgKiAxMDAwMCkgLyAxMDAwMDtcbiAgICAgICAgX2RhdGFbMF0ubG9uID0gTWF0aC5yb3VuZChfZGF0YVswXS5sb24gKiAxMDAwMCkgLyAxMDAwMDtcblxuICAgICAgICB2YXIgX2Rpc3RhbmNlTWludXMgPSAwO1xuICAgICAgICB2YXIgX2Rpc3RhbmNlUGx1cyA9IDA7XG4gICAgICAgIHZhciBfYXNjZW5kaW5nRWxldmF0aW9uID0gMDtcbiAgICAgICAgdmFyIF9kZXNjZW5kaW5nRWxldmF0aW9uID0gMDtcbiAgICAgICAgdmFyIF9kaXN0YW5jZSA9IDA7XG4gICAgICAgIHZhciBfc2xvcGVzID0gMDtcblxuICAgICAgICB2YXIgZGlzdGFuY2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGEgPSBbX2RhdGFbaV0ubG9uLCBfZGF0YVtpXS5sYXRdO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlVG9TdGFydCA9IF9wcmV2aW91c1NlY3Rpb25zTGVuZ3RoICsgX2hhdmVyc2luZURpc3RhbmNlKGEsIFtfc2tldGNoUG9pbnRzW19jdXJyZW50U2VjdGlvbl0ubG9uLCBfc2tldGNoUG9pbnRzW19jdXJyZW50U2VjdGlvbl0ubGF0XSk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlVG9TdGFydCAtIF9kaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlbWVudCBkZSBzZWN0aW9uXG4gICAgICAgICAgICBpZiAoYVswXS50b0ZpeGVkKDgpID09PSBfbmV4dFNlY3Rpb25CZWdpbmluZy5sb24udG9GaXhlZCg4KSAmJiBhWzFdLnRvRml4ZWQoOCkgPT09IF9uZXh0U2VjdGlvbkJlZ2luaW5nLmxhdC50b0ZpeGVkKDgpKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRTZWN0aW9uKys7XG4gICAgICAgICAgICAgICAgX3ByZXZpb3VzU2VjdGlvbnNMZW5ndGggPSBkaXN0YW5jZVRvU3RhcnQ7XG4gICAgICAgICAgICAgICAgLy8gUGFzIGRlIG5leHQgc2VjdGlvbiBzaSBvbiBlc3Qgc3VyIGxlIGRlcm5pZXIgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gX2RhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfbmV4dFNlY3Rpb25CZWdpbmluZyA9IF9za2V0Y2hQb2ludHNbX2N1cnJlbnRTZWN0aW9uICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgemEgPSBfZGF0YVtpXS56O1xuICAgICAgICAgICAgdmFyIHpiID0gX2RhdGFbaSAtIDFdLno7XG4gICAgICAgICAgICBpZiAoemEgPCAwKSB7XG4gICAgICAgICAgICAgICAgemEgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHpiIDwgMCkge1xuICAgICAgICAgICAgICAgIHpiID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzbG9wZSA9IHphIC0gemI7XG4gICAgICAgICAgICBpZiAoc2xvcGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgX2Rpc3RhbmNlTWludXMgKz0gZGlzdDtcbiAgICAgICAgICAgICAgICBfZGVzY2VuZGluZ0VsZXZhdGlvbiArPSBzbG9wZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xvcGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgX2Rpc3RhbmNlUGx1cyArPSBkaXN0O1xuICAgICAgICAgICAgICAgIF9hc2NlbmRpbmdFbGV2YXRpb24gKz0gc2xvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZGlzdGFuY2UgPSBkaXN0YW5jZVRvU3RhcnQ7XG4gICAgICAgICAgICBfZGF0YVtpXS5kaXN0ID0gZGlzdGFuY2VUb1N0YXJ0O1xuXG4gICAgICAgICAgICBkaXN0YW5jZXMucHVzaChkaXN0YW5jZVRvU3RhcnQpO1xuXG4gICAgICAgICAgICBfc2xvcGVzICs9IChzbG9wZSkgPyBNYXRoLmFicyhNYXRoLnJvdW5kKHNsb3BlIC8gZGlzdCAqIDEwMCkpIDogMDtcbiAgICAgICAgICAgIF9kYXRhW2ldLnNsb3BlID0gKHNsb3BlKSA/IE1hdGguYWJzKE1hdGgucm91bmQoc2xvcGUgLyBkaXN0ICogMTAwKSkgOiAwO1xuXG4gICAgICAgICAgICAvLyBFVk9MID9cbiAgICAgICAgICAgIC8vIGNmLiBncmFkaWFudFxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5jb2xvci1oZXguY29tL2NvbG9yLzAwYjc5OFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2RhdGFbaV0uc2xvcGU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAxNSAmJiB2YWx1ZSA8IDMwKSB7XG4gICAgICAgICAgICAgICAgX2RhdGFbaV0uY29sb3IgPSBcIiMwMDViNGNcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiAzMCAmJiB2YWx1ZSA8IDQ1KSB7XG4gICAgICAgICAgICAgICAgX2RhdGFbaV0uY29sb3IgPSBcIiMwMDM2MmRcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiA0NSkge1xuICAgICAgICAgICAgICAgIF9kYXRhW2ldLmNvbG9yID0gXCIjMDAxMjBmXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9kYXRhW2ldLmNvbG9yID0gXCIjMDBCNzk4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9kYXRhW2ldLmxhdCA9IE1hdGgucm91bmQoX2RhdGFbaV0ubGF0ICogMTAwMDApIC8gMTAwMDA7XG4gICAgICAgICAgICBfZGF0YVtpXS5sb24gPSBNYXRoLnJvdW5kKF9kYXRhW2ldLmxvbiAqIDEwMDAwKSAvIDEwMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZGlzdGFuY2UgdG90YWxlXG4gICAgICAgIGxvZ2dlci50cmFjZShcIkxpc3QgRGlzdGFuY2VzXCIsIGRpc3RhbmNlcyk7XG5cbiAgICAgICAgLy8gQ29ycmVjdGlvbiBkZXMgYWx0aXR1ZGVzIGFiZXJyYW50ZXMgKyBhcnJvbmRpIGRlcyBjYWxjdWxzIGRlIGRpc3RhbmNlICsgLi4uXG4gICAgICAgIHZhciBfYWx0TWluID0gX2RhdGFbMF0uejtcbiAgICAgICAgdmFyIF9hbHRNYXggPSBfZGF0YVswXS56O1xuICAgICAgICB2YXIgX2dyZWF0ZXJTbG9wZSA9IF9kYXRhWzBdLnNsb3BlO1xuXG4gICAgICAgIGZvciAodmFyIGppID0gMDsgamkgPCBfZGF0YS5sZW5ndGg7IGppKyspIHtcbiAgICAgICAgICAgIHZhciBkID0gX2RhdGFbamldO1xuICAgICAgICAgICAgaWYgKGQueiA8IC0xMDApIHtcbiAgICAgICAgICAgICAgICBkLnogPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQueiA+IF9hbHRNYXgpIHtcbiAgICAgICAgICAgICAgICBfYWx0TWF4ID0gZC56O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQueiA8IF9hbHRNaW4pIHtcbiAgICAgICAgICAgICAgICBfYWx0TWluID0gZC56O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZC5zbG9wZSA+IF9ncmVhdGVyU2xvcGUpIHtcbiAgICAgICAgICAgICAgICBfZ3JlYXRlclNsb3BlID0gZC5zbG9wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JlYXRlclNsb3BlIDogX2dyZWF0ZXJTbG9wZSwgLy8gcGVudGUgbWF4XG4gICAgICAgICAgICBtZWFuU2xvcGUgOiBNYXRoLnJvdW5kKF9zbG9wZXMgLyBfZGF0YS5sZW5ndGgpLCAvLyBwZW50ZSBtb3llbm5lXG4gICAgICAgICAgICBkaXN0YW5jZVBsdXMgOiBfZGlzdGFuY2VQbHVzLCAvLyBkaXN0YW5jZSBjdW11bMOpZSBwb3NpdGl2ZVxuICAgICAgICAgICAgZGlzdGFuY2VNaW51cyA6IF9kaXN0YW5jZU1pbnVzLCAvLyBkaXN0YW5jZSBjdW11bMOpZSBuw6lnYXRpdmVcbiAgICAgICAgICAgIGFzY2VuZGluZ0VsZXZhdGlvbiA6IF9hc2NlbmRpbmdFbGV2YXRpb24sIC8vIGTDqW5pdmVsw6kgY3VtdWzDqWUgcG9zaXRpdmVcbiAgICAgICAgICAgIGRlc2NlbmRpbmdFbGV2YXRpb24gOiBfZGVzY2VuZGluZ0VsZXZhdGlvbiwgLy8gZMOpbml2ZWzDqSBjdW11bMOpZSBuw6lnYXRpdmVcbiAgICAgICAgICAgIGFsdE1pbiA6IF9hbHRNaW4udG9Mb2NhbGVTdHJpbmcoKSwgLy8gYWx0aXR1ZGUgbWluIFRPRE86IGludXRpbGUgP1xuICAgICAgICAgICAgYWx0TWF4IDogX2FsdE1heC50b0xvY2FsZVN0cmluZygpLCAvLyBhbHRpdHVkZSBtYXggVE9ETzogaW51dGlsZSA/XG4gICAgICAgICAgICBkaXN0YW5jZSA6IHRoaXMuX2Rpc3RhbmNlLCAvLyBkaXN0YW5jZSB0b3RhbGVcbiAgICAgICAgICAgIHVuaXQgOiBfdW5pdCwgLy8gdW5pdMOpIGRlcyBtZXN1cmVzIGRlIGRpc3RhbmNlXG4gICAgICAgICAgICBwb2ludHMgOiBfZGF0YVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy4gKGluIGNhc2Ugb2Ygc3VjY2VzcylcbiAgICAgKiBhbmQgZGlzcGxheSByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGV2YXRpb25zIC0gYXJyYXkgb2YgZWxldmF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzcGxheVByb2ZpbCA6IGZ1bmN0aW9uIChlbGV2YXRpb25zKSB7XG4gICAgICAgIC8vIG9uIHJlYWN0aXZlIGxlIG1lbnUgc3lzdGVtZSBlbiBmaW4gZGUgc2Fpc2llICFcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgbWFwLm9mZihcImNvbnRleHRtZW51XCIpO1xuXG4gICAgICAgIC8vIGRhdGFcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdXZlZ2FyZGUgZGVzIGRvbm7DqWVzXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSA9IHRoaXMuX2NvbXB1dGVFbGV2YXRpb25NZWFzdXJlKGVsZXZhdGlvbnMpO1xuXG4gICAgICAgIC8vIGNvbnRhaW5lclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmRpc3BsYXlQcm9maWxlT3B0aW9ucy50YXJnZXQ7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9wYW5lbENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyID0gdGhpcy5fcHJvZmlsQ29udGFpbmVyO1xuXG4gICAgICAgIC8vIFRPRE8gY29udGV4dGUgP1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIF9wcm9maWxlT3B0cyA9IHRoaXMub3B0aW9ucy5kaXNwbGF5UHJvZmlsZU9wdGlvbnM7XG5cbiAgICAgICAgLy8gZm9uY3Rpb25cbiAgICAgICAgdmFyIGRpc3BsYXlGdW5jdGlvbiA9IF9wcm9maWxlT3B0cy5hcHBseTtcblxuICAgICAgICAvLyBDYWxjdWwgZHUgcHJvZmlsXG4gICAgICAgIGlmICh0eXBlb2YgQW1DaGFydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGQzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJBdWN1bmUgbGliLiBuJ2VzdCBwcmVzZW50ZSAhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXhlY3V0aW9uLi4uXG4gICAgICAgIGRpc3BsYXlGdW5jdGlvbi5jYWxsKHRoaXMsIGRhdGEsIGNvbnRhaW5lciwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gYWZmaWNoYWdlIGRlcyBpbmZvcm1hdGlvbnMgZHUgcHJvZmlsID9cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBMLkRvbVV0aWwuZ2V0KFwiR1BlbGV2YXRpb25QYXRoUGFuZWxJbmZvLVwiICsgdGhpcy5fdWlkKTtcbiAgICAgICAgaWYgKF9wcm9maWxlT3B0cy5ncmVhdGVyU2xvcGUgfHxcbiAgICAgICAgICAgIF9wcm9maWxlT3B0cy5tZWFuU2xvcGUgfHxcbiAgICAgICAgICAgIF9wcm9maWxlT3B0cy5hc2NlbmRpbmdFbGV2YXRpb24gfHxcbiAgICAgICAgICAgIF9wcm9maWxlT3B0cy5kZXNjZW5kaW5nRWxldmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBvbiBhZmZpY2hlIGxlcyBpbmZvcm1hdGlvbnNcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgY2xlYW4gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGNsZWFycyBhbGwgZGF0YVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvZmlsZSA9IG51bGw7XG5cbiAgICAgICAgLy8gb24gdmlkZSBsZSBjb250YWluZXJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbENvbnRhaW5lcikge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3Byb2ZpbENvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZmlsQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX3Byb2ZpbENvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uIHN1cHByaW1lIGxlIG1hcmtlclxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBpZiAodGhpcy5fbWFya2VyKSB7XG4gICAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2VyKTtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBjcmVhdGUgUHJvZmlsZSBNYXJrZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZGF0YVxuICovXG5FbGV2YXRpb25QYXRoLl9fY3JlYXRlUHJvZmlsZU1hcmtlciA9IGZ1bmN0aW9uIChjb250ZXh0LCBkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZyhcIl9fY3JlYXRlUHJvZmlsZU1hcmtlclwiKTtcblxuICAgIHZhciBzZWxmID0gY29udGV4dDtcbiAgICB2YXIgbWFwID0gc2VsZi5fbWFwO1xuXG4gICAgLy8gdmFyIF9zcnMgICAgPSBMLkNSUy5FUFNHNDMyNjtcbiAgICAvLyB2YXIgX3BvaW50QSA9IF9zcnMubGF0TG5nVG9Qb2ludChMLmxhdExuZyhzZWxmLl9nZW9tZXRyeVswXS5sYXQsIHNlbGYuX2dlb21ldHJ5WzBdLmxvbikpO1xuICAgIC8vIHZhciBfcG9pbnRCID0gX3Nycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKHNlbGYuX2dlb21ldHJ5W3NlbGYuX2dlb21ldHJ5Lmxlbmd0aCAtIDFdLmxhdCwgc2VsZi5fZ2VvbWV0cnlbc2VsZi5fZ2VvbWV0cnkubGVuZ3RoIC0gMV0ubG9uKSk7XG4gICAgLy8gdmFyIF9wb2ludCAgPSBMLkxpbmVVdGlsLmNsb3Nlc3RQb2ludE9uU2VnbWVudChfc3JzLmxhdExuZ1RvUG9pbnQoTC5sYXRMbmcoZGF0YS5sYXQsIGRhdGEubG9uKSksIF9wb2ludEEsIF9wb2ludEIgKTtcblxuICAgIC8vIGNyZWF0aW9uIGRcInVuIG1hcmtlclxuICAgIHNlbGYuX21hcmtlciA9IEwubWFya2VyKEwubGF0TG5nKGRhdGEpLCB7XG4gICAgICAgIGljb24gOiBuZXcgSWNvbkRlZmF1bHQoXCJvcmFuZ2VcIiksXG4gICAgICAgIGRyYWdnYWJsZSA6IGZhbHNlLFxuICAgICAgICBjbGlja2FibGUgOiBmYWxzZSxcbiAgICAgICAgekluZGV4T2Zmc2V0IDogMTAwMFxuICAgIH0pO1xuXG4gICAgc2VsZi5fbWFya2VyLmFkZFRvKG1hcCk7XG59O1xuXG4vKipcbiAqIHVwZGF0ZSBQcm9maWxlIE1hcmtlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBkYXRhXG4gKi9cbkVsZXZhdGlvblBhdGguX191cGRhdGVQcm9maWxlTWFya2VyID0gZnVuY3Rpb24gKGNvbnRleHQsIGRhdGEpIHtcbiAgICBsb2dnZXIubG9nKFwiX191cGRhdGVQcm9maWxlTWFya2VyXCIpO1xuXG4gICAgdmFyIHNlbGYgPSBjb250ZXh0O1xuICAgIHZhciBtYXAgPSBzZWxmLl9tYXA7XG5cbiAgICAvLyB2YXIgX3NycyAgICA9IEwuQ1JTLkVQU0c0MzI2O1xuICAgIC8vIHZhciBfcG9pbnRBID0gX3Nycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKHNlbGYuX2dlb21ldHJ5WzBdLmxhdCwgc2VsZi5fZ2VvbWV0cnlbMF0ubG9uKSk7XG4gICAgLy8gdmFyIF9wb2ludEIgPSBfc3JzLmxhdExuZ1RvUG9pbnQoTC5sYXRMbmcoc2VsZi5fZ2VvbWV0cnlbc2VsZi5fZ2VvbWV0cnkubGVuZ3RoIC0gMV0ubGF0LCBzZWxmLl9nZW9tZXRyeVtzZWxmLl9nZW9tZXRyeS5sZW5ndGggLSAxXS5sb24pKTtcbiAgICAvLyB2YXIgX3BvaW50ICA9IEwuTGluZVV0aWwuY2xvc2VzdFBvaW50T25TZWdtZW50KCBfc3JzLmxhdExuZ1RvUG9pbnQoTC5sYXRMbmcoZGF0YS5sYXQsIGRhdGEubG9uKSksIF9wb2ludEEsIF9wb2ludEIgKTtcblxuICAgIGlmIChzZWxmLl9tYXJrZXIpIHtcbiAgICAgICAgc2VsZi5fbWFya2VyLnNldExhdExuZyhMLmxhdExuZyhkYXRhKSk7XG4gICAgICAgIHNlbGYuX21hcmtlci51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGlvbiBkXCJ1biBtYXJrZXJcbiAgICAgICAgc2VsZi5fbWFya2VyID0gTC5tYXJrZXIoTC5sYXRMbmcoZGF0YSksIHtcbiAgICAgICAgICAgIGljb24gOiBuZXcgSWNvbkRlZmF1bHQoXCJvcmFuZ2VcIiksXG4gICAgICAgICAgICBkcmFnZ2FibGUgOiBmYWxzZSxcbiAgICAgICAgICAgIGNsaWNrYWJsZSA6IGZhbHNlLFxuICAgICAgICAgICAgekluZGV4T2Zmc2V0IDogMTAwMFxuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLl9tYXJrZXIuYWRkVG8obWFwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHJlbW92ZSBQcm9maWxlIE1hcmtlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gY29udGV4dFxuICovXG5FbGV2YXRpb25QYXRoLl9fcmVtb3ZlUHJvZmlsZU1hcmtlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgbG9nZ2VyLmxvZyhcIl9fcmVtb3ZlUHJvZmlsZU1hcmtlclwiKTtcblxuICAgIHZhciBzZWxmID0gY29udGV4dDtcbiAgICB2YXIgbWFwID0gc2VsZi5fbWFwO1xuXG4gICAgaWYgKHNlbGYuX21hcmtlcikge1xuICAgICAgICBtYXAucmVtb3ZlTGF5ZXIoc2VsZi5fbWFya2VyKTtcbiAgICAgICAgc2VsZi5fbWFya2VyID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGN1c3RvbSBvcGVyYXRpb24gaW50byByYXcgcHJvZmlsLi4uXG4gKiBUT0RPXG4gKi9cbkVsZXZhdGlvblBhdGguX19jdXN0b21SYXdQcm9maWxlT3BlcmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGxvZ2dlci5sb2coXCJfX2N1c3RvbVJhd1Byb2ZpbGVPcGVyYXRpb25cIik7XG59O1xuXG4vKipcbiAqIGN1c3RvbSBvcGVyYXRpb24gaW50byByYXcgcHJvZmlsLi4uXG4gKiBUT0RPXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gZSAtIGV2ZW50XG4gKi9cbkVsZXZhdGlvblBhdGguX19jdXN0b21SYXdQcm9maWxlTW91c2VPdmVyRXZlbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZSkge1xuICAgIGxvZ2dlci5sb2coXCJfX2N1c3RvbVJhd1Byb2ZpbGVNb3VzZU92ZXJFdmVudFwiLCBjb250ZXh0LCBlKTtcbn07XG5cbi8qKlxuICogRGlzcGxheSBQcm9maWxlIGZ1bmN0aW9uIHVzZWQgYnkgZGVmYXVsdCA6IG5vIGFkZGl0b25hbCBmcmFtZXdvcmsgbmVlZGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZWxldmF0aW9ucyB2YWx1ZXMgZm9yIHByb2ZpbGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGh0bWwgY29udGFpbmVyIHdoZXJlIHRvIGRpc3BsYXkgcHJvZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSB0aGlzIGNvbnRyb2wgb2JqZWN0XG4gKi9cbkVsZXZhdGlvblBhdGguRElTUExBWV9QUk9GSUxFX0JZX0RFRkFVTFQgPSBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiRWxldmF0aW9uUGF0aC5ESVNQTEFZX1BST0ZJTEVfQllfREVGQVVMVFwiKTtcblxuICAgIHZhciBwcm9maWxlID0gUHJvZmlsZUVsZXZhdGlvblBhdGhET00uZGlzcGxheVByb2ZpbGVCeURlZmF1bHQoZGF0YSwgY29udGFpbmVyLCBjb250ZXh0LCBFbGV2YXRpb25QYXRoKTtcbiAgICAvLyBvbiBzYXV2ZWdhcmRlIGxlIHByb2ZpbCBkdSBjb250YWluZXIgZGFucyBsJ29iamV0XG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgdGhpcy5fcHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEaXNwbGF5IFByb2ZpbGUgd2l0aG91dCBncmFwaGljYWwgcmVuZGVyaW5nIChyYXcgc2VydmljZSByZXNwb25zZSlcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGVsZXZhdGlvbnMgdmFsdWVzIGZvciBwcm9maWxlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBodG1sIGNvbnRhaW5lciB3aGVyZSB0byBkaXNwbGF5IHByb2ZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gdGhpcyBjb250cm9sIG9iamVjdFxuICovXG5FbGV2YXRpb25QYXRoLkRJU1BMQVlfUFJPRklMRV9SQVcgPSBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiRWxldmF0aW9uUGF0aC5ESVNQTEFZX1BST0ZJTEVfUkFXXCIpO1xuXG4gICAgdmFyIHByb2ZpbGUgPSBQcm9maWxlRWxldmF0aW9uUGF0aERPTS5kaXNwbGF5UHJvZmlsZVJhdyhkYXRhLCBjb250YWluZXIsIGNvbnRleHQsIEVsZXZhdGlvblBhdGgpO1xuICAgIC8vIG9uIHNhdXZlZ2FyZGUgbGUgcHJvZmlsIGR1IGNvbnRhaW5lciBkYW5zIGwnb2JqZXRcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICB0aGlzLl9wcm9maWxlID0gcHJvZmlsZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERpc3BsYXkgUHJvZmlsZSB1c2luZyBEMyBqYXZhc2NyaXB0IGZyYW1ld29yay4gVGhpcyBtZXRob2QgbmVlZHMgRDMgbGlicmFyaWVzIHRvIGJlIGxvYWRlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGVsZXZhdGlvbnMgdmFsdWVzIGZvciBwcm9maWxlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBodG1sIGNvbnRhaW5lciB3aGVyZSB0byBkaXNwbGF5IHByb2ZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gdGhpcyBjb250cm9sIG9iamVjdFxuICovXG5FbGV2YXRpb25QYXRoLkRJU1BMQVlfUFJPRklMRV9MSUJfRDMgPSBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgbG9nZ2VyLnRyYWNlKFwiRWxldmF0aW9uUGF0aC5ESVNQTEFZX1BST0ZJTEVfTElCX0QzXCIpO1xuXG4gICAgaWYgKHR5cGVvZiBkMyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBsb2dnZXIubG9nKFwiTGliLiBEMyBpcyBub3QgbG9hZGVkICFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvZmlsZSA9IFByb2ZpbGVFbGV2YXRpb25QYXRoRE9NLmRpc3BsYXlQcm9maWxlTGliRDMoZGF0YSwgY29udGFpbmVyLCBjb250ZXh0LCBFbGV2YXRpb25QYXRoKTtcbiAgICAvLyBvbiBzYXV2ZWdhcmRlIGxlIHByb2ZpbCBkdSBjb250YWluZXIgZGFucyBsJ29iamV0XG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgdGhpcy5fcHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEaXNwbGF5IFByb2ZpbGUgdXNpbmcgQW1jaGFydHMgZnJhbWV3b3JrLiBUaGlzIG1ldGhvZCBuZWVkcyBBbUNoYXJ0cyBsaWJyYXJpZXMgdG8gYmUgbG9hZGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZWxldmF0aW9ucyB2YWx1ZXMgZm9yIHByb2ZpbGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIGh0bWwgY29udGFpbmVyIHdoZXJlIHRvIGRpc3BsYXkgcHJvZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSB0aGlzIGNvbnRyb2wgb2JqZWN0XG4gKi9cbkVsZXZhdGlvblBhdGguRElTUExBWV9QUk9GSUxFX0xJQl9BTUNIQVJUUyA9IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICBsb2dnZXIudHJhY2UoXCJFbGV2YXRpb25QYXRoLkRJU1BMQVlfUFJPRklMRV9MSUJfQU1DSEFSVFNcIik7XG5cbiAgICAvLyBDYWxjdWwgZHUgcHJvZmlsZVxuICAgIGlmICh0eXBlb2YgQW1DaGFydHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkxpYi4gQW1DaGFydHMgaXMgbm90IGxvYWRlZCAhXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb2ZpbGUgPSBQcm9maWxlRWxldmF0aW9uUGF0aERPTS5kaXNwbGF5UHJvZmlsZUxpYkFtQ2hhcnRzKGRhdGEsIGNvbnRhaW5lciwgY29udGV4dCwgRWxldmF0aW9uUGF0aCk7XG4gICAgLy8gb24gc2F1dmVnYXJkZSBsZSBwcm9maWwgZHUgY29udGFpbmVyIGRhbnMgbCdvYmpldFxuICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgIHRoaXMuX3Byb2ZpbGUgPSBwcm9maWxlO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVsZXZhdGlvblBhdGg7XG5cbi8vIEV4cG9zZSBJc29jdXJ2ZSBhcyBMLmdlb3BvcnRhbENvbnRyb2wuRWxldmF0aW9uUGF0aCAoZm9yIGEgYnVpbGQgYnVuZGxlKVxuaWYgKHdpbmRvdy5MKSB7XG4gICAgaWYgKCF3aW5kb3cuTC5nZW9wb3J0YWxDb250cm9sKSB7XG4gICAgICAgIHdpbmRvdy5MLmdlb3BvcnRhbENvbnRyb2wgPSB7fTtcbiAgICB9XG4gICAgd2luZG93LkwuZ2VvcG9ydGFsQ29udHJvbC5FbGV2YXRpb25QYXRoID0gRWxldmF0aW9uUGF0aDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Leaflet/Controls/ElevationPath.js\n");

/***/ }),

/***/ "./src/Leaflet/Controls/Utils/IconDefault.js":
/*!***************************************************!*\
  !*** ./src/Leaflet/Controls/Utils/IconDefault.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"leaflet\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Common/Utils/LoggerByDefault */ \"./src/Common/Utils/LoggerByDefault.js\");\n\n\nvar logger = _Common_Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLogger(\"icondefault\");\n/**  cf. http://leafletjs.com/reference.html#icon */\n\nvar IconDefault = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Icon.Default.extend(\n/** @lends IconDefault.prototype */\n{\n  /**\n  * Liste des icones\n  *   TODO : image retina à convertir en x2...\n  */\n  images: {\n    retina: {\n      shadow: \"data:image/png;base64,...\",\n      color: {\n        blue: \"data:image/png;base64,...\",\n        orange: \"data:image/png;base64,...\",\n        red: \"data:image/png;base64,...\",\n        green: \"data:image/png;base64,...\"\n      }\n    },\n    shadow: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=\",\n    color: {\n      blue: \"data:image/png;base64,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\",\n      orange: \"data:image/png;base64,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\",\n      red: \"data:image/png;base64,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\",\n      green: \"data:image/png;base64,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\"\n    }\n  },\n\n  /**\n   * constructor\n   * (extend to L.Icon.Default)\n   *\n   * @param {String} color - blue, green or red, blue by default.\n   * @param {Object} options - options of L.Icon\n   */\n  initialize: function initialize(color, options) {\n    // on merge les options avec celles par defaut\n    leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Util.extend(this.options, options);\n    var _color = null;\n    var _images =\n    /* (L.Browser.retina) ? this.images.retina : */\n    this.images;\n\n    switch (color) {\n      case \"red\":\n        _color = _images.color.red;\n        break;\n\n      case \"green\":\n        _color = _images.color.green;\n        break;\n\n      case \"orange\":\n        _color = _images.color.orange;\n        break;\n\n      case \"blue\":\n        _color = _images.color.blue;\n        break;\n\n      default:\n        _color = _images.color.blue;\n    } // icones classiques\n\n\n    this.options.iconUrl = _color;\n    this.options.shadowUrl = _images.shadow; // icones pour écran Retina\n\n    if (leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Browser.retina) {\n      this.options.iconRetinaUrl = _color;\n      this.options.shadowRetinaUrl = _images.shadow;\n    }\n  },\n\n  /**\n   * Overload function to ensure compatibility between versions 0.7.X and 1.0.X\n   * (extend to L.Icon._getIconUrl)\n   *\n   * @param {String} name - name\n   *\n   * @returns {String} url\n   *\n   */\n  _getIconUrl: function _getIconUrl(name) {\n    logger.trace(\"OVERWRITTEN L.Icon.Default._getIconUrl(\" + name + \")\");\n    return leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Icon.prototype._getIconUrl.call(this, name);\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (IconDefault);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9Db250cm9scy9VdGlscy9JY29uRGVmYXVsdC5qcz9kYWIzIl0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIkljb25EZWZhdWx0IiwiTCIsIkljb24iLCJEZWZhdWx0IiwiZXh0ZW5kIiwiaW1hZ2VzIiwicmV0aW5hIiwic2hhZG93IiwiY29sb3IiLCJibHVlIiwib3JhbmdlIiwicmVkIiwiZ3JlZW4iLCJpbml0aWFsaXplIiwib3B0aW9ucyIsIlV0aWwiLCJfY29sb3IiLCJfaW1hZ2VzIiwiaWNvblVybCIsInNoYWRvd1VybCIsIkJyb3dzZXIiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93UmV0aW5hVXJsIiwiX2dldEljb25VcmwiLCJuYW1lIiwidHJhY2UiLCJwcm90b3R5cGUiLCJjYWxsIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQSxJQUFJQSxNQUFNLEdBQUdDLHFFQUFNLENBQUNDLFNBQVAsQ0FBaUIsYUFBakIsQ0FBYjtBQUVBOztBQUNBLElBQUlDLFdBQVcsR0FBR0MsOENBQUMsQ0FBQ0MsSUFBRixDQUFPQyxPQUFQLENBQWVDLE1BQWY7QUFBc0I7QUFBb0M7QUFFeEU7QUFDSjtBQUNBO0FBQ0E7QUFDSUMsUUFBTSxFQUFHO0FBQ0xDLFVBQU0sRUFBRztBQUNMQyxZQUFNLEVBQUcsMkJBREo7QUFFTEMsV0FBSyxFQUFHO0FBQ0pDLFlBQUksRUFBRywyQkFESDtBQUVKQyxjQUFNLEVBQUcsMkJBRkw7QUFHSkMsV0FBRyxFQUFHLDJCQUhGO0FBSUpDLGFBQUssRUFBRztBQUpKO0FBRkgsS0FESjtBQVVMTCxVQUFNLEVBQUcsZ2tDQVZKO0FBV0xDLFNBQUssRUFBRztBQUNKQyxVQUFJLEVBQUcsb3pFQURIO0FBRUpDLFlBQU0sRUFBRyx3N0VBRkw7QUFHSkMsU0FBRyxFQUFHLHc1RUFIRjtBQUlKQyxXQUFLLEVBQUc7QUFKSjtBQVhILEdBTitEOztBQXlCeEU7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsWUFBVSxFQUFHLG9CQUFVTCxLQUFWLEVBQWlCTSxPQUFqQixFQUEwQjtBQUNuQztBQUNBYixrREFBQyxDQUFDYyxJQUFGLENBQU9YLE1BQVAsQ0FBYyxLQUFLVSxPQUFuQixFQUE0QkEsT0FBNUI7QUFFQSxRQUFJRSxNQUFNLEdBQUcsSUFBYjtBQUNBLFFBQUlDLE9BQU87QUFBRztBQUFnRCxTQUFLWixNQUFuRTs7QUFDQSxZQUFRRyxLQUFSO0FBQ0ksV0FBSyxLQUFMO0FBQ0lRLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNHLEdBQXZCO0FBQ0E7O0FBQ0osV0FBSyxPQUFMO0FBQ0lLLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNJLEtBQXZCO0FBQ0E7O0FBQ0osV0FBSyxRQUFMO0FBQ0lJLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNFLE1BQXZCO0FBQ0E7O0FBQ0osV0FBSyxNQUFMO0FBQ0lNLGNBQU0sR0FBR0MsT0FBTyxDQUFDVCxLQUFSLENBQWNDLElBQXZCO0FBQ0E7O0FBQ0o7QUFDSU8sY0FBTSxHQUFHQyxPQUFPLENBQUNULEtBQVIsQ0FBY0MsSUFBdkI7QUFkUixLQU5tQyxDQXVCbkM7OztBQUNBLFNBQUtLLE9BQUwsQ0FBYUksT0FBYixHQUF1QkYsTUFBdkI7QUFDQSxTQUFLRixPQUFMLENBQWFLLFNBQWIsR0FBeUJGLE9BQU8sQ0FBQ1YsTUFBakMsQ0F6Qm1DLENBMkJuQzs7QUFDQSxRQUFJTiw4Q0FBQyxDQUFDbUIsT0FBRixDQUFVZCxNQUFkLEVBQXNCO0FBQ2xCLFdBQUtRLE9BQUwsQ0FBYU8sYUFBYixHQUE2QkwsTUFBN0I7QUFDQSxXQUFLRixPQUFMLENBQWFRLGVBQWIsR0FBK0JMLE9BQU8sQ0FBQ1YsTUFBdkM7QUFDSDtBQUNKLEdBaEV1RTs7QUFrRXhFO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJZ0IsYUFBVyxFQUFHLHFCQUFVQyxJQUFWLEVBQWdCO0FBQzFCM0IsVUFBTSxDQUFDNEIsS0FBUCxDQUFhLDRDQUE0Q0QsSUFBNUMsR0FBbUQsR0FBaEU7QUFDQSxXQUFPdkIsOENBQUMsQ0FBQ0MsSUFBRixDQUFPd0IsU0FBUCxDQUFpQkgsV0FBakIsQ0FBNkJJLElBQTdCLENBQWtDLElBQWxDLEVBQXdDSCxJQUF4QyxDQUFQO0FBQ0g7QUE5RXVFLENBQTFELENBQWxCO0FBaUZleEIsMEVBQWYiLCJmaWxlIjoiLi9zcmMvTGVhZmxldC9Db250cm9scy9VdGlscy9JY29uRGVmYXVsdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMIGZyb20gXCJsZWFmbGV0XCI7XG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi9Db21tb24vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cbnZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiaWNvbmRlZmF1bHRcIik7XG5cbi8qKiAgY2YuIGh0dHA6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2ljb24gKi9cbnZhciBJY29uRGVmYXVsdCA9IEwuSWNvbi5EZWZhdWx0LmV4dGVuZCgvKiogQGxlbmRzIEljb25EZWZhdWx0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAqIExpc3RlIGRlcyBpY29uZXNcbiAgICAqICAgVE9ETyA6IGltYWdlIHJldGluYSDDoCBjb252ZXJ0aXIgZW4geDIuLi5cbiAgICAqL1xuICAgIGltYWdlcyA6IHtcbiAgICAgICAgcmV0aW5hIDoge1xuICAgICAgICAgICAgc2hhZG93IDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICBjb2xvciA6IHtcbiAgICAgICAgICAgICAgICBibHVlIDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICAgICAgb3JhbmdlIDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICAgICAgcmVkIDogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXCIsXG4gICAgICAgICAgICAgICAgZ3JlZW4gOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwuLi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3cgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ2tBQUFBcENBWUFBQUNvWUFEMkFBQUM1RWxFUVZSWXcrMllXNC9UTUJDRjQ1UzBTMWx1WFpDQUJ5NUNnTFFnd2YvL1M0QllCTFRkSkxheDBmRnFtQjA3bm5RZkVHcWtJeWRwVkg4NU0rTkxqUGUrK2RjUGM0UThRaDRoajVEL0FhUUp4NkgvNFRNd0IwUGVCTndVN0VHUUFtQXRzTmZBem9aa2dJYTBaZ0xNYTRBajZDeElBc2poak9Db0w1ejdHbGcxSkFPa2FpY2d2UUJYdW5jd0pBV2prc0x0QlRXWmUwNENuWVJrdFVHZGlsQUxwcFpCT2dIR1pjQnpMNk9DbEFCdk1TVkl6eUJqYXpPZ3J2QUNmMXlkQzVtZ3VxQVZnNlJoZGtTV1FGajJ1eGZhcS9CcklaT0xFV2daZEFMSUR2Y01jWkxEOFpiTEM5ZGU0eVIxc1lNaTRHMjBTNFEvUFdlSll4VE9abjV6SlhBTlpISXhBZDRKV2hQSWxvVEpaaHpNUWR1TTg5V1EzTVVWQUUvUm5oQVhwVHljcXlzM05aQUxPQmJCN2tGcmdMZXNRbDJoNDVGY2o4TDF0VFNvaFV3dXhoeThIL1FnNks3Z0lzKzNra2FpZ1FDT2N5RVhDSE4wN3d5UWF6aHJtSXVsdktNUUF3TWNtTE5xeUNWeU1BSStCdXhTTWVUazNPUGlrTFkySjF1RStWSFFrNkFOcmhkcyt0TkFScUJlYUdjNzJjSzU1MEZQNFdoWG1GbWNNR2hUd0FSMWlmT2UzRXZQcUllZ0ZtRitDOGdWeTBPZkFhV1FQTVI3Z0YxT1FLcUdvQmpxOTBIUE1QMDFCVWpQT3FHRmtzQzRlbUU0OHRXUUFIMFltdk9nRjNEU1Q2eGllSmdIQVd4UEFITXVOaHJJbUlkdm9OT0tOV0lPY0UrVVhFMHBZQW5rWDZ1aFdzZ1ZYRHhIZFRmQ21yRUVtTUIyek1GaW1MVk90aWlhanhpR1dyYlU1MkVlQ2R5T3dQRVFEOExxeVBIOVRpMmtnWU1mNE9oU0tCN3FZSUxiQnYzQ3VWVEoxMVk4MG9hc2VpTVdPT05jL1k3a0pZZTB4TDJmMEJhaUZUeGtuSE81SGFNR011YmxLd3hGR3pZZFdzQkYxNzRIL1FEa25oVEhtSEhOMzlpV0Zua1p4OGxQeU04V0hmWUVMbWxMS3RnV05tRk56UWNDMWI0N2dKNGhMMTlpN282NWRoSDBOZWdiY2E4dk9OWm9QN2RvSWVPQzl6WG04Ump1TDBHZjRkNE9ZYVU1bGpvM0dZaXF6cldRSGZKeEE2QUxoRHBWS3Y5cVllWkE4ZU0zRWhmUFNDbXB1RDBBQUFBQVNVVk9SSzVDWUlJPVwiLFxuICAgICAgICBjb2xvciA6IHtcbiAgICAgICAgICAgIGJsdWUgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUdta2xFUVZSWXc3VlhlVXlUWnhqdk5uZkVMRnV5SXpPYWJlcm1NWkVlUUMvT2Nsa080OUNwT0hYT0xKbC9DQVVSdVliUWkzS0xnRWhicmhaMWFEd21hb0dxS0lJNm9kQVRtSC9zY0RGYmRDN0x2RnFPQ2MrZTk1czJWRzUwWC9MTG0vZjQvWjduZVkvbmUxOGFBTkNtQXI1RS94WmYxdURPa1RjR2NXUjZobDkyNDd0VDVVN1k2U052V3NLVDYzUDU4cWJmZUxKRzhNNXFjZ1RrbnJ2dnJkRGJzVDdNbCt0djgyWDZ2VnhKRTMzYVJtZ1N5WXRjV1ZNcVg5N1l2Mkp2VzM5VWhSRTJIdXlCTCt0K2dLMTExNmx5MDZFZVdGTmxBbUh4bFFFME9NaVY2bVFDU2N1c0tSbGhTM1FMZVZKZGwxKzIzaDVkWTRGTkIzdGhyYllib3FwdEVGbHBoVEMxaFNwSm5iUnZ4UDROV2dzRTVKeXo4NlFOTmkvNXFTVVRHdUZrMWd1NTR0Tjl3dUsyd2MzbytXYzEzUkNtc29Cd0VxekdjWnN4c3ZDU3kvOXdKS2Y3VVdmMW1FWThKV2Zld2M2N1VVb0RiRGpRQytGcUs0UXFMVk1HR1I5ZDJ3dXJLenFCazNucUlULzl6THhSUmpnWjlicVFndWIrRGRvZUNDMDNROGorMFFoRmhCSFIvZVAzVS96Q2xuN1V1K2hpaEoxK2JCTmZmTEl2bWt5UDBncEJaV1lYaEt1c3NLNm1CejVIVDZNMU5xcGNwK21CQ1BYb3NZUWZyZWtHdnJqZXdkNTkvR3ZLQ0U3VGJLLzA0L1pWNVFaWVZXbUR3SDFtRjN4YTJRM3JhM0RCQzV2QlQxb1A3UFRqNEMwK0NjTDhjN0MyQ3RlanFodUNudUlRSGFLSHp2Y1JmWnBueWxGZlhzWUp4M3BOTHdoS3pSQXdBaEVxRzBTcHVzQkhmQUtreHczdzQ2MjdNUGhvQ0g3OTh6N3MwWm5CSi9NRUpiWlNiWFBoRVIyaWg3cDJvay96U2oyY0VKRGQ0Q0FlKzVXWW5CQ2dSMnVydXlFdzZ6Um9XNi9EV0ovT2VBUDhwZC9CR3R6T1pLcEc4b2tlMFNYNkdNbVJrNkdGbHlBYzU5SzMyT1RFaW5JTFJKUmNoYWg4SFF3TkQ4TjQzNVo5WjBGWTFFcXR4VWcrMFNPNlJKL21tWHo0VnVTK0RweFhDM2dYbVp3SUw3ZEJTSDR6S0U1MHdFU2Y4cXdWZ3JQMUVJbFRPNUpQOUlndTBhZXhkaDI4RjFsbUFFR0pHZmg3akU2RWx5TTVSdy9GRGNZSmpXaGJlaUJZb1lOSXBjMkZUL1NJTGl2cDBGMWlwRFdrNEJJRW8yVnVvZEVKVWlmaGJpbHRuTkJJWFBVRkNNcHRodEF5cXdzL0JQbEVGL1ZiYUl4RXJkeFBwaHNVN3JjQ3A4RG9oQytHdkJJUEpTL3RXMmp0dlRtbUFldU5POEJOT1lRZUc4Ry8yT3pDSjNxK3NvWUI1aTZOaE1hS3IxN0ZTYWw3R0lIaGV1VjN1U0NZOHFZVnVFbTFjT3pxZFdyN2t1L1IwQkRvVFQrRFQrb2hDTTYvQ0N2S0xLTzRSSStkWFBlQXVhTXFrc2FLclo3TDNGRTVGSUZia0ljZWVPWjJPY0hPNndJaFRrTm8wZmZnalJHeEVxb2dYSFlVUEhmV0FDL2xBRHB3R2NMUlkzYWVLNC9vUkdDS1ljWlhQVm9lWC9rZWxWWVk4ZFVHZjhWNUVCUmJnSlhUNVFJUGhQOWVQSmk0MjhKS09pRVloWVhGQnFvdTJHdWgrcC9tRUIxL1JmTXc2clk3Y3hjalRybmVJMUZyRHl1elVTUm05bWl3RUp4OEUvZ1VtcWx5dkhHa25laXdFclIyMUYzdE5PSzVUZjB5WGFUK083RGdDdkFMVFVCWGRNNFloQy9JYXdQVSsyUGR1cU12dWFSNmVveFN3VWs3NWdncXNZSjdWaWNzbndHSWtaQlNYS09Vd3c3M1dHWHlxUCtKMi9iOWMrZ2kxWUFnL3hwd2NrM2dKdXVjTnJoNUp2RFB2UXIwV0ZYZjBwaXl0OGY4L1dJMGhWNHBSeHhrUVpkSkRmREpOT0FtTTBBZzhqeVQ2aHowV0dYV3VQOTRZaDJqY2ZqbVhBR3ZIQ01zbFJpbURIWXVIdURzeTJRdEh1SWF2em5oYllVUnE1UjU3S3B6QkJSWktQSmk4ZVFnNDhoNGo4U0Rkb3dpZmRJckVWZFUrZ2JPNlFOdlJSdDRaQnRoVWFaaFVuamxZT2JOYWdWM2tlb2VydTNyVTdyY3VjZXFVMW1KQnh5K0JXWllsTkVCSCswZUg0dlJpQitPWXliVTJobmJsWWxUdmtIaW5NNG01NFlueFN5YVpZU0Y2UjNqd2dQN3VkS0xHSVg2ci9sYk5hOU42eTVNRnlualdEdHJIZDc1WnZUWUFQTy82UmdGMGs3Nm1RbGEzRkdxN2RPK2NIOHNLbjBWbzduRGxsd0FocXdMUGt4ckh3V21ISk9vK0FLSjRyYWI1T2dyTTdyVnU4ZVdiMlB1MERoNGVEZ1hvT2Z2cDdZN1FlcWtuUm12Y1RCRXlxOW0vSFFRU0NTejZMSHEzejB5enNOeVNSZk1TMjUzd2wyS3lSRGJjWlBjZkpLalptU0VPamN4eWkrWThkVU90c0lFSDZSMndOeWtkcXJrWUowUlY5MkgwVzU4cGtmUWs3Y0tldnNMSzEwUHk4U2RNR2ZYTlhBVFkrcFBieUpSL0VUNm45bklmenROdFpZUlY5WG5pUXU5SUEydk9WZ3k0aXI3R0NMVm1tZCt6amtIMGVBRjlQbzZLNjFwbUNYSHhVNXJITVlkMWZ0YzNvd2p3UlNWUnpMakt2cVpFdHk2Y1JVRDdqR3FpT2R1NUhHNk1kSGpOY05ZR3FmRG01WVJ6TEJCQ0NEbC8yYms4YThnZGJxY2Z3RUN1NjJGZy9IcmdnQUFBQUJKUlU1RXJrSmdnZz09XCIsXG4gICAgICAgICAgICBvcmFuZ2UgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBRnpVa2RDQUs3T0hPa0FBQUFnWTBoU1RRQUFlaVlBQUlDRUFBRDZBQUFBZ09nQUFIVXdBQURxWUFBQU9wZ0FBQmR3bkxwUlBBQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUFTQUFBQUVnQVJzbHJQZ0FBQmdoSlJFRlVXTU9kbDF1SW5HY2R4bi9mZVdhK21mbG1KbVpicVZxS2lnZXdLSzVnb0hnUlNFbThFQzg4RjZ0QkZMZmdaYnpKblZkUllXRXhyVkJvWGF6V2xBWUwwZFZpc0xCWXpFVVVTYmVOalpRbXhHWjNOak83YzU3di9QNjltTm5EN016dXp2ckNBOFBNKy8rZTkzbitoL2NiN2M5UHpYS0U5UkhBRzM2K0JYUlBQMzM5MENEdFQzTUhrbFNBN3dLbmdWT1diYU9oQTVBa0VVcXBLbkFGZVBITU05ZVg5eWVack1RQXpnSG5pMTRsbjgyNlpMTHUyS1kwVGZEN1hYcTlOb0hmZnhYNDhabW5yNitNa1N5Tks2a0FsNHFsOHFsaXNZeHBXYWdvSkExNmdJeHMxRTBiSTFjQW9OTnVzbEZiOTRFbnYvak05Y3NqKzBTRVhhaUl5Tis5Y3VWVTVkaHhkRW1JMjNYU29BT29JY2tPVkJJU3QrdkU3UTBLUlk4SDN2K0JiTTdOdjd3ME56czNRckxIb3BkTDVjckh5cVVLU2JkQjZuZEExQlJJaVZzMU1vNU55U3NEL0dKcGJ2YmtqcEtkczUwckZMMlQ1VktacE5kQWttamlBelhESE95ZThGdlMyY0MyTFdabUhqQUVMdjF4YnJZeUlGR0NLS21Ja3ZNbHI0aUsrMGdhRGUwWlFIY3lXSVV5VnFHTW1EWld2b1JWS0dPNjNzZytVTVNkR3E2Ym8rUjV4MFhKdVlGZEdxRHhMYTlVekp1bVFScDBSM3kzQ2hVMDAyWmpjNVBiZCs2d0dlbThlL3NPNit2ckJHR0lWYWdNVGRtSlNjTWVwWklIR2ovNHd3OC9hNWpEZXZsNjNzMmg0bkFnZmJoTTF5T01RdDY3VitXalo4N3krVk5QWW1YekFOejd4MTlZdWZRemlsRkl5U3NUdCt2YmNTcnNZVGxabkV5bUVnVEJDVjJVNUVYSmlVekdKZzFhSTlJMXc2RFpiUEhvRStmNStKZWUyaVlBZUdqMmNSNDc5enlOam8rU0ZOMTJ4cXpMWlJ4RXlXbGQ0RU9XYlJtSUFwVnVKMUUzTGFJd1JMa3pQUHpZbDhjYVVVUndaejdJdzEvNENxMVdHOFBPakJTQkN2dll0b25BSjNVUnFlaWFObFlwdXVYZyt3SGxSejQxa1FCQUtVWDV3NSttMS9QSEtrN1NCRjBERWZGTWdVakpNR25hcm83V0ZHaWcwbmhmQWhFaGpRSTBUUnVMMXd3TkZTa0VmRjJFZTNHU2pwMGtEWHE0V1p2N2IxOUhKZU5FV3lTck4vNUczblVRbGV6cEo0TWtUUkhobmk0aTFUaE91aXBOQnlmYWtoc0htSVpHUm5WNTY1V0xZeW9BMXQ2OFJ1T05xM2o1REtuZkhpWFJkS0lvUmtUdUdsLzl6SU1DZkM3ckdKL0k1dk9vY0dzUUNvaVF6N3ZjLzgrL1dIMzdCcm5LZ3pqRlk3UldiL1B1OG1WV0x2MlVtVW9PeHpZR0pGdHhtb2JoWkZtcmQwaFM5U1B0cGJPUEFweDBzL1pmSDNtb1JOeXVqVTVhTzRlUmNXbDJBalpiUG42WVlGc0dYdDZoNG1VeERYMHN4aW9lcDlrSmVHKzlmZlZyejk5NGZLc1pYK3Y2MGJWdVB6emhGbzZSZEhZMVZ0UkRFcDlTNFJpbGdqUHlNQlgyaVh1OTBkSWJGc0ZtMjBmZ0p3Q203QlRFenpkYS91L3pyalZzcGwySlZvcTR2YzQweXlyTzBPcUdkUHZ4YTkvNDFZM1hZZlErdWRMc2hPOEVRWXlaSzA0NTRpZEFLVFlhZlVUa3dyYmx1MFo5S2pCZmIvcG91dmwvRVpodW1hNGYwZTdILy96bTRodFh0MG4yM0hhTDlWWlFTNUlVM2M0ZW1VVFROT29OSDloUnNWY0pBcjdBczdWV2dKSEpEVHA0U3BpRk12MG9vZEdMYndtOE1rb3llc2NqSWd0cm00R3ZsRUkzN1NPbzBLazFBa1Rrd2hPTEsra2VFdGlEbWdndjFGc2hScll3RllHUkxSSkVLZlYyZkZlRUYvZFczRjY3dGpCL3R4YW1Jb0ttNjVOMzdJSnUyZFJhRVFMejMvNzFtOUU0eWJoZGlNZ3RFVm5hN0VRWStRb2lhbC9vVG80b1RxazJvcHFJUERlcGQvUUR6amgvdnhtRE90Z3EzY3F5M29nUXVQaWRGOTdxVGlhWnJBUVJXVzc3NmJWT2tHSVczamZaSmlkSHFvVFZSdHdWa1lYOXBzQ2t4Ty9Hd25valJodk1sdkdFMnptcXpSZ1Jmbm4yTnpkYis1TWNuTmJMOWE1Nng0OEZJK3Z0U2JhRGFQRGZqU1FTbUQ5b25oMWtGeUtTaXNoQ3RabWdXL1pZMmE1dHhvakk0dmQrZTdONkNNbUJkaUhDNGxvanJjV3BvRHN1SUdpbWhZaHdwNWFtSWx6Z2tLVWYxZ01nWFpCbnE0MEV3OGtOQm1HdXhIb3pBZVNsNy8vdTM3Y1BKVG1VWW9DTGR6ZFZKTU5jZ0xEV0ZvVERWVXhyRnlKVVJWaXNOaFZHenFQV1Z2UUNXUkpoWlNxUzRRdjNORmhZYXcxMHJiVUVOQzRNYW5zYUpZTy9EdFBnWmkrUUs3VzIwT3JMc2loNVhaUk1TVEpkVHJaSHpXcHprSXV0NzZhejYyaHJ1ZVh6SFBEcVVZTCtCOFhWS1V6dVVpbWZBQUFBSlhSRldIUmtZWFJsT21OeVpXRjBaUUF5TURFeUxUQTRMVEU0VkRFME9qVXdPalUyS3pBeE9qQXdGbENrWHdBQUFDVjBSVmgwWkdGMFpUcHRiMlJwWm5rQU1qQXhNaTB3T0MweE9GUXhORG8xTURvMU5pc3dNVG93TUdjTkhPTUFBQUFaZEVWWWRGTnZablIzWVhKbEFFRmtiMkpsSUVsdFlXZGxVbVZoWkhseHlXVThBQUFBQUVsRlRrU3VRbUNDXCIsXG4gICAgICAgICAgICByZWQgOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBRnpVa2RDQUs3T0hPa0FBQUFnWTBoU1RRQUFlaVlBQUlDRUFBRDZBQUFBZ09nQUFIVXdBQURxWUFBQU9wZ0FBQmR3bkxwUlBBQUFBQVppUzBkRUFQOEEvd0Qvb0wybmt3QUFBQWx3U0ZsekFBQUFTQUFBQUVnQVJzbHJQZ0FBQmU1SlJFRlVXTU9kbFd1SVhHY1p4My9uUGJlNVpXYk8yYzBhOFZJRXBTcTBpbzJRQlQ4RlVsSUZFYnpmb2tVVUtmZ3hJdVNibitKdFlURVFxRlFDUW1reFZJaU5GaGNMd1pvVnRyRk50NDBFU3JQRUpqdTdzL2VaTStmK1BuNlkyWFZuWjNabjAvZndjQTd2ZVovemU1Ly84N3pQTWY1NmZKSUhHQjhGYXIzbjIwRDc5Tnoxa1U3R1h3NkcrTUQzZ2RQQUtkdHhNSlFGUUpaRWFLMGJ3QlhnMlNmbXJsODdBSEppMkx3Sm5BWE9WZjN4U3JGY29WQXVEeXpLczR5dzNTTFkyaVRxQkM4QlAzMWliblorQUhKMU1CSWZlSzdxZWFlcW5vOWwyK2c0SVE4NklMcHZvWEljekNNVkFGb2I2Nnd1TFlYQW1jL1BYYi9jQjNueHNSTjdBZGZyWTJNUGUrUGo2Q2p1Zm55azZBYTJYeWZzaExRMjFnbGFyYWUrOE9yc3haM043SkhvajNYZmY5anp4OGpXTjhoYmJkQjZ0T1U1YVhPVmd1TlE5OFlBZm52MStPVEpIWWdBUFR0N3BGWTc2WGsrMmZvNmtpU2c4d0V6TExNcjI1QjMyZW9xam0weDhiNWpwc0J6THg2ZjlMc1FBUkY4RWM3VnExVjBKMENTdU05WkZWeHNyNDd0MVJISHhxN1hzTDA2VnEwNkFFcWJ5NVJMUmVxMTJsRVJ6dmJrRWtDK1ZhdFdLcGFweU50dDZKRVJ3Zlk5RE1kbWRXMk5Pd3NMckNtRGR4WVdXRnBhSW9wamJOL3JhckxMSnc4QzZyVXFJRC82ODJNblRFc1FnSzlYU2lWMG5IUTE3ZzJyVmlXT0k5NXRMUE94Sjg5dzRzeDNzQ3ZkYXJyM3R4bm1mL2ticW5GRTNhdVRycXp1K09rZ3dDNFdjQXV1SDBYUnBCS2hJc0prd2JISk45Zjc5VGNWRzV0YlBIcnVaM3o4cVIvdkFBQSs4UGdwUHZmNzM3RWVodWc4UmJuMmdIUWwxMFdFMDByZ3c3WnRtZHRWc3BNSDJ5S0pZL1RFQkE5OTZZc0RWU3NpbEQvMFFSNzZ5cGZaM0dwaEZncDlBTjNwNEZnbUFwOVVJdUlyUXcyVXBYSmR3aWpHZStTUm9RQUFyVFhlcHo5RkVFYmRmT3p5bHl4SGRkZldMRUVTTGJwYmxydFB0TTRBUWFmSnZnQVJJWThpRE1NWThEY002YTVCUWlVWTk5SThIOWhKSGdTVUhadmx1VmZSYVRvQTJvYmMvOGMvcWJnMmtxVjkvb2FweVBJY3diaW5SS1NSWm5sYjUzbDNSOXZoUmpHV0FZVjJpN2N1WEJ5SUFtQng5bCtzejh4UUs3amtXMXY5RUtWSTBoUVJ1V3QrOWRqN0JmaHMwVlNmS0ZaSzZDRG9xL2xLdWNUeWE2OXgvK1k4cFdQSGNNZDhOdThzOE03bEY1ai94YStaS0JWd1RkV0ZiUHNaQm1heHdHSXJJTlA2SjhiemozNEc0R1RaY2Y3K2tYcUZ0Tm5zNzdTbE1tYTV4RWFVc0JiR2hGbUdZNXJVWEJ1LzZHSXBOZUJqSHozS1JwVHc3bFo3NW1zM2J6eHVkUVhnNVhhU3pMYmpaTEk4TmthMnNyTHJZTFdScUVQZEg2UHUybjBmMDUwT2FSRDBsNTR5UUlTMU1FTGc1d0RiRUlCZnJZYlJDeFczTXZEZmtFeVRMaStOYXZqZEtNWW4ySXhpMm1uMjhqZHUzbmlsMXlDRm5sM1ppTk8zb3pqdE5iNUR0UGloYlYrejJva1JrZlBEV24wdU1MVVN4aGltOVo0QWx1ZlJUaEsyMHV6R045LzQ5OHdPaE4wSFVmU2xsU2h1Wm5tT0toWFo4MjZrR1liQlNpY0cwZWQzUzdnN0VnUkNnYWViWVl4Wkx2Vy9HV0dXNzlISk05YlQ3TGJBbi9vaC84L0p0azB2Umttb3RVWTV6cUdsTXBTaTJjdkZ0K2Rmei9kRVlyREhtb0x4aDVVd3hqeHk1RkFBczFvbHluSldVbjFYTUo3ZFczRktHSHBOM1kyeVhFUXdURFZTS3VVNk5LTUVRYWErKyticnlTQmtVQzVFNUxhSVhGMkxFMHpmUjdUZTExU3BSSkxsTkpLOEtTTFBERHM3Nm9BOVRpM0grVWlwVkxISVVwZ2djT0Y3YjczUkhnNFpIZ2tpY20wcjE3T3RMTWM2T2o1Y3BuS0pYQXYzVTkwV2tlbjl1b0FhVVp6VFMxR0dJUXhQZUxGRUkwNFJ1UGprcmZuTjl3cTV2S0o1T3hUQnJOYjJKTnRGRlB3M2xVUmc2cUIrZHBCY2lFZ3VJdE9OT0VPNXprRFpMb1lwSW5McEI3Zm1Hd2REUnAvblM0c1p6VlFFVlM2RENJWmpJeUlzcE9RQzV4a3gxTzYvNEQ3V1J1VHBScFJobGtyZFJsaXJzeFJuSVBMOEQvL3o1cDJSa0gwTzQ5N3J3dDJjUkJCVXdRV0V4VndRWkdRVVBjaEFXeGxtRGNHNDFFZzBacTFHTTlFRW9xNEt4dnloSUEvUWFhY1hzKzV6NzM2K08zK1lTRWFtWk1kdUJhS3VORk5oVTlRMUVWNlJ3ekVPblpPZHhuay83ZVppZSthUWNqM1F1TGFKZWdaNDZVR2MvZ2NVZVR0ekRnL280d0FBQUNWMFJWaDBaR0YwWlRwamNtVmhkR1VBTWpBeE1pMHdPQzB4T0ZReE5EbzFNRG8xTmlzd01Ub3dNQlpRcEY4QUFBQWxkRVZZZEdSaGRHVTZiVzlrYVdaNUFESXdNVEl0TURndE1UaFVNVFE2TlRBNk5UWXJNREU2TURCbkRSempBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUFCSlJVNUVya0pnZ2c9PVwiLFxuICAgICAgICAgICAgZ3JlZW4gOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBcENBWUFBQURBazRMT0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFaaVMwZEVBUDhBL3dEL29MMm5rd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBZDBTVTFGQjl3SkNnb0REZ3FIRC9NQUFBWlZTVVJCVkZqRHBaWnRpRnhYR2NkL2MrNjlNN1B6dXJ2ZFRUWk5HdnhRVENKcUZTb2srTW1GUVBTRFVsc1FoQmF4V05ob3JRbFdQeFNLVFlxc0ZMWUdBOFZDSVNERVNJcENJTFlRVzR4Sk50SEdHQm9vWnRsMTZVcktOck12TTdOM1h1NjU1NXpIRDdPWjdPenNXL0JlL25Cbnpubk8venpQODMvT2N4S1B2L0lPVzMyS1h6ajJLRkJjL25tN2N1dmw4SU9YRDIxcWwzajhsVDl2c09qeGZ1Qjd3Q0hnb0FvVUNWOEJZSnNXUkdhQmM4RHB2end4Zm5GOWtsOTBreFErZjl3RFhnUmV5ZzlrYzhWa0g0V2cyRFV2ZHBxeVhxUmNLeE9INWwzZ1orODlPWDVyRFpMenF3aGU3UWZPWkFjeUI0ZlNPMGg2S2JTTnFOdDZGMGxTSmNuNFdRQStiY3l5Y0hlaEFUenozcFBqYjYrY3AwU0VlOGp2T2RZdnNSdlBEbVFPUHBMWmpSWExZalJQellTSXVDNUV0c2xpTkU5Wkw3SXR2WTJkRCsvc1NSYURzOE5uOW85MGtMUTkySHZjQTg3bWR1VDI3TXc4UWlXdVVETWhWdXltTUM1bVBwb2o0MlVZeXUwQStNM3dtZjNEOTBsRVFBVGd4ZlQyOVBERFBUdXA2akt4MDhnYXI2K0NOZjhYaEVXOVFFcWxHTncxNkFGbmhzL3M3MitGQzZHdzc5Vis0S1h0UFVQVWJaM0lSUjA3RFZTU1FsQ2tFQlJSQ2RYK3p2bjVMcS9tb2hLRm9FaDJLRE80TEI0VUxVZStteHBJNVJTS01BNXhJbTBVZzE2U0tza25qVHRNZlR4RkdJZE1mVHpGek9JTW9WbWlHUFFDZE5qVVRZM0I5SFpFZU81cnY5L3YrWWdnd25jSzZRS3h4QjNxeVFVNWFpYms3aWNsdnYzWVV6ejkxV2ZKK3dVQUxzeSt3K3NmL29wR3VzRmdhaHVMZXJGdDE3Qk4wbDRQUWM3djEwdm1nSi9mOThzY2NDRGpaNW1QNWpwSXZJVEhZbGptK1FOSCtOYXVwenJHRGc1OW5jL205L0tEQzA4VEQ4VUV5cWRoRysxeGg4UFArZWdsYzBqaFpMZVhVcDRWMnlGUFB4RlFOeld5bVd3WEFZQWc3TTUraG0vcyt5Wnp6UklwTDkxaFh6YzFraW9BSjU5VFFIOUMzV09YTmxKZWl0Q0VmTEgzUzJzU0FGZ3hQTmI3WlhRbDdySjNJaVJhQ3hkOWNhTEZnWFVHY2RKZXlEaURpS0JkdEM2QkU2RmhHeWd2MFdVdm5zT0tSWncwRkhESFJnNkhkQ3pXdEhYeVFaNGJuMTdIckJLRUZkTmFBTWVsMGwveGN6NVdiT2Q1aGNJNEEzQkhpV1BXYVJlS3VOWU9qRU9NdzJoRGdnUXVkcHljZUwzREM5Y3FYc1pMbDdnKzlROEtRWUVsczlTMkZlUHdFZ3Jic0loanh1dmIrMnRKRFl4L1JYSnVYemJJMGRSUit4Qnd5cER0eVhMcnZ4OXlMYnpDOXZSMkhrb084Sjl3a3JNenAvbnQrQnYwREtid1ZVQ2owVnh4ZUVBUUpLbmVEUkVyei9zaUFrNU9OdWVpSnpJN01yQWlycm9lNHpKQzcwTkZwaGVtK1Bua1VXemtVSDZDWkc5QTM2NGlYc0tqdWxUcHJLOThucVY2RmRlMEYvNzIvUTgrOGhHaDh1K2Z2bC9ZODlyVlduL3RRRGFYSTZ3dTNlOFpZWXp4TGZsc2pseW1VMlVOMnlBTzR6VWJWWE5lSXlMSEFIenVKL3cxWFk3L21ON21XS1VCSkhaVXk5VXR0ZWhzTVV0WUQ3RU44LzZsWjY5ZkJtaUZDeERMdVdoQlQwYjkwYU4rem05ci8wRWZFZGZ5d2pMYWRkUlhKNDVhWUN4YTBQaktwNTNGQjBDcU4wbXpHV0ZDODgvTHoxMi9zS0l6cnBqbjVGUnpMaW9aWi9CNmZNVHhRRkFraUJZMDRtUzBzek91WUtsT0hHMGc4bWF6Rk9HbEZHSmx5MGptZlhROVJwZjFiVVQrdEc2UFg4N1BpV2crYWlEZ3BieVdwTGVBUktDSXlqSEE2SldSRzNaVmp4ZFdvakp4cEFUOHJqa1g0V2U5TFNVN0tBVFloaVd1NkJuZzlPcHh0VllDeFRIV0xFWDJYbUU2dHpHVW55QXF4NGhqN01ySURkMUZzanBjSWtKbDRvWGJZdVc4cmhxU2ZVa2tkdXZDU3ltc2RrUnpVVW1zdkxXV3AybzlPWXFUc1doUmI2cGNQK3VqeXpIaTVPVFZILzhyWEpOa0xVOUVoT3JVQ3hkTnpWdzFOVU42SUxsbXN2Mk1oeGhIY3k0S2dSUHI1YXdyOFozZ2hDN3I1VXJ1M29pZjhZZ1dOTUFiMTM1eXM3SSt5WWJ4NE8yNGFpWnQ1RWoySmpzdkdTa1BCS0o1clJIR05sTGZ1dUVTRVNxVFA3SWlMVytVcnhCTEcwRSthRlczY09yYWtadXpHNUpzSEM0Qk9LVXJwdVJNNjRvalRsQitBaEdoT2E4dE1McFpIYW5OMUZPWi9HRUl2QmxYWXZ3ZUJTSWsrd0owcTdyLzhQZWpONmMzSmRuU0NldmtaTFNndGRoV0xzU0JMbXRZZFJEK0grRVNLbE9IWjhYSnFiZ2FFeFFDNGlXRDArNThaZXJ3cmEyUmJNN0I4cVg4aEs3RWlCTjBXU1BDNk9vT3VuNU8yTnBiblQ3OGtkWHVuS2xiYk9RdVZxY1BYNVl0c3FnSDYzNk02YklHWWJUai9yTjVUcmIrVktkSEx0cW1lNnM2UGZMdWc5ajlEL0ZDYzFnMnFmN1ZBQUFBQUVsRlRrU3VRbUNDXCJcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb25zdHJ1Y3RvclxuICAgICAqIChleHRlbmQgdG8gTC5JY29uLkRlZmF1bHQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgLSBibHVlLCBncmVlbiBvciByZWQsIGJsdWUgYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2YgTC5JY29uXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICAvLyBvbiBtZXJnZSBsZXMgb3B0aW9ucyBhdmVjIGNlbGxlcyBwYXIgZGVmYXV0XG4gICAgICAgIEwuVXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgX2NvbG9yID0gbnVsbDtcbiAgICAgICAgdmFyIF9pbWFnZXMgPSAvKiAoTC5Ccm93c2VyLnJldGluYSkgPyB0aGlzLmltYWdlcy5yZXRpbmEgOiAqLyB0aGlzLmltYWdlcztcbiAgICAgICAgc3dpdGNoIChjb2xvcikge1xuICAgICAgICAgICAgY2FzZSBcInJlZFwiOlxuICAgICAgICAgICAgICAgIF9jb2xvciA9IF9pbWFnZXMuY29sb3IucmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdyZWVuXCI6XG4gICAgICAgICAgICAgICAgX2NvbG9yID0gX2ltYWdlcy5jb2xvci5ncmVlbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcmFuZ2VcIjpcbiAgICAgICAgICAgICAgICBfY29sb3IgPSBfaW1hZ2VzLmNvbG9yLm9yYW5nZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJibHVlXCI6XG4gICAgICAgICAgICAgICAgX2NvbG9yID0gX2ltYWdlcy5jb2xvci5ibHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfY29sb3IgPSBfaW1hZ2VzLmNvbG9yLmJsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpY29uZXMgY2xhc3NpcXVlc1xuICAgICAgICB0aGlzLm9wdGlvbnMuaWNvblVybCA9IF9jb2xvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNoYWRvd1VybCA9IF9pbWFnZXMuc2hhZG93O1xuXG4gICAgICAgIC8vIGljb25lcyBwb3VyIMOpY3JhbiBSZXRpbmFcbiAgICAgICAgaWYgKEwuQnJvd3Nlci5yZXRpbmEpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pY29uUmV0aW5hVXJsID0gX2NvbG9yO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNoYWRvd1JldGluYVVybCA9IF9pbWFnZXMuc2hhZG93O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkIGZ1bmN0aW9uIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IGJldHdlZW4gdmVyc2lvbnMgMC43LlggYW5kIDEuMC5YXG4gICAgICogKGV4dGVuZCB0byBMLkljb24uX2dldEljb25VcmwpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAqXG4gICAgICovXG4gICAgX2dldEljb25VcmwgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJPVkVSV1JJVFRFTiBMLkljb24uRGVmYXVsdC5fZ2V0SWNvblVybChcIiArIG5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiBMLkljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEljb25EZWZhdWx0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Leaflet/Controls/Utils/IconDefault.js\n");

/***/ }),

/***/ "./src/Leaflet/Controls/Utils/PositionFormater.js":
/*!********************************************************!*\
  !*** ./src/Leaflet/Controls/Utils/PositionFormater.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n* implementation :\n* cf. http://uihacker.blogspot.fr/2011/07/javascript-formatting-latitudelongitude.html?m=1\n* cf. http://andrew.hedges.name/experiments/convert_lat_long/\n* FIXME formater la sortie\n* cf. http://mottie.github.io/javascript-number-formatter/\n* cf. https://github.com/j-/number-formatter\n*\n*/\n\n/** ... */\nvar PositionFormater = {\n  /** ... */\n  NORTH: \"N\",\n\n  /** ... */\n  SOUTH: \"S\",\n\n  /** ... */\n  EAST: \"E\",\n\n  /** ... */\n  WEST: \"O\",\n\n  /** ... */\n  digitSecond: 2,\n\n  /** ... */\n  digitDecimal: 5,\n\n  /** ... */\n  digitRadian: 8,\n\n  /**\n   * @param {Number} inputNum -inputNum\n   * @param {Integer} numPoints - numPoints\n   *\n   * @returns {Number} rounded result\n   */\n  roundToDecimal: function roundToDecimal(inputNum, numPoints) {\n    var multiplier = Math.pow(10, numPoints);\n    return Math.round(inputNum * multiplier) / multiplier;\n  },\n\n  /**\n   * @param {Number} location -location\n   *\n   * @returns {Number} location in radian\n   */\n  decimalToRadian: function decimalToRadian(location) {\n    var d = 0.01745329251994329577;\n    return this.roundToDecimal(location * d, this.digitRadian);\n  },\n\n  /**\n   * @param {Number} location -location\n   *\n   * @returns {Number} location in grade\n   */\n  decimalToGrade: function decimalToGrade(location) {\n    var d = 1.11111111111111111111;\n    return this.roundToDecimal(location * d, this.digitRadian);\n  },\n\n  /**\n   * @param {Number} location -location\n   * @param {String} hemisphere -hemisphere\n   * @param {Boolean} obj -specifies if an object must be returned\n   *\n   * @returns {String|Object} DMS (String or Object depending on obj parameter value)\n   */\n  decimalToDMS: function decimalToDMS(location, hemisphere, obj) {\n    if (location < 0) {\n      location *= -1; // strip dash '-'\n    }\n\n    var degrees = Math.floor(location); // strip decimal remainer for degrees\n\n    var minutesFromRemainder = (location - degrees) * 60; // multiply the remainer by 60\n\n    var minutes = Math.floor(minutesFromRemainder); // get minutes from integer\n\n    var secondsFromRemainder = (minutesFromRemainder - minutes) * 60; // multiply the remainer by 60\n\n    var seconds = this.roundToDecimal(secondsFromRemainder, this.digitSecond); // get minutes by rounding to integer\n\n    var dms = degrees + \"° \" + minutes + \"' \" + seconds + \"\\\" \";\n\n    if (hemisphere) {\n      dms += hemisphere;\n    }\n\n    if (obj) {\n      return {\n        d: degrees,\n        m: minutes,\n        s: seconds,\n        direction: hemisphere\n      };\n    }\n\n    return dms;\n  },\n\n  /**\n   * @param {Number} location -location\n   * @param {Boolean} obj -specifies if an object must be returned\n   *\n   * @returns {String|Object} DMS (String or Object depending on obj parameter value)\n   */\n  decimalLatToDMS: function decimalLatToDMS(location, obj) {\n    var hemisphere = location < 0 ? this.SOUTH : this.NORTH; // south if negative\n\n    return this.decimalToDMS(location, hemisphere, obj);\n  },\n\n  /**\n   * @param {Number} location -location\n   * @param {Boolean} obj -specifies if an object must be returned\n   *\n   * @returns {String|Object} DMS (String or Object depending on obj parameter value)\n   */\n  decimalLonToDMS: function decimalLonToDMS(location, obj) {\n    var hemisphere = location < 0 ? this.WEST : this.EAST; // west if negative\n\n    return this.decimalToDMS(location, hemisphere, obj);\n  },\n\n  /**\n   * @param {Number} degrees -degrees\n   * @param {Number} minutes -minutes\n   * @param {Number} seconds -seconds\n   * @param {String} hemisphere -hemisphere\n   *\n   * @returns {Number} decimal\n   */\n  DMSToDecimal: function DMSToDecimal(degrees, minutes, seconds, hemisphere) {\n    var ddVal = degrees + minutes / 60 + seconds / 3600;\n    ddVal = hemisphere === this.SOUTH || hemisphere === this.WEST ? ddVal * -1 : ddVal;\n    var decimal = this.roundToDecimal(ddVal, this.digitDecimal);\n    return decimal;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (PositionFormater);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvTGVhZmxldC9Db250cm9scy9VdGlscy9Qb3NpdGlvbkZvcm1hdGVyLmpzPzM4ZmQiXSwibmFtZXMiOlsiUG9zaXRpb25Gb3JtYXRlciIsIk5PUlRIIiwiU09VVEgiLCJFQVNUIiwiV0VTVCIsImRpZ2l0U2Vjb25kIiwiZGlnaXREZWNpbWFsIiwiZGlnaXRSYWRpYW4iLCJyb3VuZFRvRGVjaW1hbCIsImlucHV0TnVtIiwibnVtUG9pbnRzIiwibXVsdGlwbGllciIsIk1hdGgiLCJwb3ciLCJyb3VuZCIsImRlY2ltYWxUb1JhZGlhbiIsImxvY2F0aW9uIiwiZCIsImRlY2ltYWxUb0dyYWRlIiwiZGVjaW1hbFRvRE1TIiwiaGVtaXNwaGVyZSIsIm9iaiIsImRlZ3JlZXMiLCJmbG9vciIsIm1pbnV0ZXNGcm9tUmVtYWluZGVyIiwibWludXRlcyIsInNlY29uZHNGcm9tUmVtYWluZGVyIiwic2Vjb25kcyIsImRtcyIsIm0iLCJzIiwiZGlyZWN0aW9uIiwiZGVjaW1hbExhdFRvRE1TIiwiZGVjaW1hbExvblRvRE1TIiwiRE1TVG9EZWNpbWFsIiwiZGRWYWwiLCJkZWNpbWFsIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLElBQUlBLGdCQUFnQixHQUFHO0FBRW5CO0FBQ0FDLE9BQUssRUFBRyxHQUhXOztBQUtuQjtBQUNBQyxPQUFLLEVBQUcsR0FOVzs7QUFRbkI7QUFDQUMsTUFBSSxFQUFHLEdBVFk7O0FBV25CO0FBQ0FDLE1BQUksRUFBRyxHQVpZOztBQWNuQjtBQUNBQyxhQUFXLEVBQUcsQ0FmSzs7QUFpQm5CO0FBQ0FDLGNBQVksRUFBRyxDQWxCSTs7QUFvQm5CO0FBQ0FDLGFBQVcsRUFBRyxDQXJCSzs7QUF1Qm5CO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxnQkFBYyxFQUFHLHdCQUFVQyxRQUFWLEVBQW9CQyxTQUFw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LEdBQXhDLENBQVA7QUFDSCxHQTdHa0I7O0FBK0duQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lhLGNBQVksRUFBRyxzQkFBVVosT0FBVixFQUFtQkcsT0FBbkIsRUFBNEJFLE9BQTVCLEVBQXFDUCxVQUFyQyxFQUFpRDtBQUM1RCxRQUFJZSxLQUFLLEdBQUdiLE9BQU8sR0FBR0csT0FBTyxHQUFHLEVBQXBCLEdBQXlCRSxPQUFPLEdBQUcsSUFBL0M7QUFDQVEsU0FBSyxHQUFJZixVQUFVLEtBQUssS0FBS2xCLEtBQXBCLElBQTZCa0IsVUFBVSxLQUFLLEtBQUtoQixJQUFsRCxHQUEwRCtCLEtBQUssR0FBRyxDQUFDLENBQW5FLEdBQXVFQSxLQUEvRTtBQUVBLFFBQUlDLE9BQU8sR0FBRyxLQUFLNUIsY0FBTCxDQUFvQjJCLEtBQXBCLEVBQTJCLEtBQUs3QixZQUFoQyxDQUFkO0FBQ0EsV0FBTzhCLE9BQVA7QUFDSDtBQTdIa0IsQ0FBdkI7QUFpSWVwQywrRUFBZiIsImZpbGUiOiIuL3NyYy9MZWFmbGV0L0NvbnRyb2xzL1V0aWxzL1Bvc2l0aW9uRm9ybWF0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogaW1wbGVtZW50YXRpb24gOlxuKiBjZi4gaHR0cDovL3VpaGFja2VyLmJsb2dzcG90LmZyLzIwMTEvMDcvamF2YXNjcmlwdC1mb3JtYXR0aW5nLWxhdGl0dWRlbG9uZ2l0dWRlLmh0bWw/bT0xXG4qIGNmLiBodHRwOi8vYW5kcmV3LmhlZGdlcy5uYW1lL2V4cGVyaW1lbnRzL2NvbnZlcnRfbGF0X2xvbmcvXG4qIEZJWE1FIGZvcm1hdGVyIGxhIHNvcnRpZVxuKiBjZi4gaHR0cDovL21vdHRpZS5naXRodWIuaW8vamF2YXNjcmlwdC1udW1iZXItZm9ybWF0dGVyL1xuKiBjZi4gaHR0cHM6Ly9naXRodWIuY29tL2otL251bWJlci1mb3JtYXR0ZXJcbipcbiovXG4vKiogLi4uICovXG52YXIgUG9zaXRpb25Gb3JtYXRlciA9IHtcblxuICAgIC8qKiAuLi4gKi9cbiAgICBOT1JUSCA6IFwiTlwiLFxuXG4gICAgLyoqIC4uLiAqL1xuICAgIFNPVVRIIDogXCJTXCIsXG5cbiAgICAvKiogLi4uICovXG4gICAgRUFTVCA6IFwiRVwiLFxuXG4gICAgLyoqIC4uLiAqL1xuICAgIFdFU1QgOiBcIk9cIixcblxuICAgIC8qKiAuLi4gKi9cbiAgICBkaWdpdFNlY29uZCA6IDIsXG5cbiAgICAvKiogLi4uICovXG4gICAgZGlnaXREZWNpbWFsIDogNSxcblxuICAgIC8qKiAuLi4gKi9cbiAgICBkaWdpdFJhZGlhbiA6IDgsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5wdXROdW0gLWlucHV0TnVtXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBudW1Qb2ludHMgLSBudW1Qb2ludHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgcmVzdWx0XG4gICAgICovXG4gICAgcm91bmRUb0RlY2ltYWwgOiBmdW5jdGlvbiAoaW5wdXROdW0sIG51bVBvaW50cykge1xuICAgICAgICB2YXIgbXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBudW1Qb2ludHMpO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChpbnB1dE51bSAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC1sb2NhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn0gbG9jYXRpb24gaW4gcmFkaWFuXG4gICAgICovXG4gICAgZGVjaW1hbFRvUmFkaWFuIDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBkID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmRUb0RlY2ltYWwobG9jYXRpb24gKiBkLCB0aGlzLmRpZ2l0UmFkaWFuKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC1sb2NhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn0gbG9jYXRpb24gaW4gZ3JhZGVcbiAgICAgKi9cbiAgICBkZWNpbWFsVG9HcmFkZSA6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICB2YXIgZCA9IDEuMTExMTExMTExMTExMTExMTExMTE7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kVG9EZWNpbWFsKGxvY2F0aW9uICogZCwgdGhpcy5kaWdpdFJhZGlhbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvbiAtbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGVtaXNwaGVyZSAtaGVtaXNwaGVyZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2JqIC1zcGVjaWZpZXMgaWYgYW4gb2JqZWN0IG11c3QgYmUgcmV0dXJuZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8T2JqZWN0fSBETVMgKFN0cmluZyBvciBPYmplY3QgZGVwZW5kaW5nIG9uIG9iaiBwYXJhbWV0ZXIgdmFsdWUpXG4gICAgICovXG4gICAgZGVjaW1hbFRvRE1TIDogZnVuY3Rpb24gKGxvY2F0aW9uLCBoZW1pc3BoZXJlLCBvYmopIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uIDwgMCkge1xuICAgICAgICAgICAgbG9jYXRpb24gKj0gLTE7IC8vIHN0cmlwIGRhc2ggJy0nXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVncmVlcyA9IE1hdGguZmxvb3IobG9jYXRpb24pOyAvLyBzdHJpcCBkZWNpbWFsIHJlbWFpbmVyIGZvciBkZWdyZWVzXG4gICAgICAgIHZhciBtaW51dGVzRnJvbVJlbWFpbmRlciA9IChsb2NhdGlvbiAtIGRlZ3JlZXMpICogNjA7IC8vIG11bHRpcGx5IHRoZSByZW1haW5lciBieSA2MFxuICAgICAgICB2YXIgbWludXRlcyA9IE1hdGguZmxvb3IobWludXRlc0Zyb21SZW1haW5kZXIpOyAvLyBnZXQgbWludXRlcyBmcm9tIGludGVnZXJcbiAgICAgICAgdmFyIHNlY29uZHNGcm9tUmVtYWluZGVyID0gKG1pbnV0ZXNGcm9tUmVtYWluZGVyIC0gbWludXRlcykgKiA2MDsgLy8gbXVsdGlwbHkgdGhlIHJlbWFpbmVyIGJ5IDYwXG4gICAgICAgIHZhciBzZWNvbmRzID0gdGhpcy5yb3VuZFRvRGVjaW1hbChzZWNvbmRzRnJvbVJlbWFpbmRlciwgdGhpcy5kaWdpdFNlY29uZCk7IC8vIGdldCBtaW51dGVzIGJ5IHJvdW5kaW5nIHRvIGludGVnZXJcblxuICAgICAgICB2YXIgZG1zID0gZGVncmVlcyArIFwiwrAgXCIgKyBtaW51dGVzICsgXCInIFwiICsgc2Vjb25kcyArIFwiXFxcIiBcIjtcbiAgICAgICAgaWYgKGhlbWlzcGhlcmUpIHtcbiAgICAgICAgICAgIGRtcyArPSBoZW1pc3BoZXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkIDogZGVncmVlcyxcbiAgICAgICAgICAgICAgICBtIDogbWludXRlcyxcbiAgICAgICAgICAgICAgICBzIDogc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gOiBoZW1pc3BoZXJlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRtcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC1sb2NhdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2JqIC1zcGVjaWZpZXMgaWYgYW4gb2JqZWN0IG11c3QgYmUgcmV0dXJuZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8T2JqZWN0fSBETVMgKFN0cmluZyBvciBPYmplY3QgZGVwZW5kaW5nIG9uIG9iaiBwYXJhbWV0ZXIgdmFsdWUpXG4gICAgICovXG4gICAgZGVjaW1hbExhdFRvRE1TIDogZnVuY3Rpb24gKGxvY2F0aW9uLCBvYmopIHtcbiAgICAgICAgdmFyIGhlbWlzcGhlcmUgPSAobG9jYXRpb24gPCAwKSA/IHRoaXMuU09VVEggOiB0aGlzLk5PUlRIOyAvLyBzb3V0aCBpZiBuZWdhdGl2ZVxuICAgICAgICByZXR1cm4gdGhpcy5kZWNpbWFsVG9ETVMobG9jYXRpb24sIGhlbWlzcGhlcmUsIG9iaik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvbiAtbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9iaiAtc3BlY2lmaWVzIGlmIGFuIG9iamVjdCBtdXN0IGJlIHJldHVybmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE9iamVjdH0gRE1TIChTdHJpbmcgb3IgT2JqZWN0IGRlcGVuZGluZyBvbiBvYmogcGFyYW1ldGVyIHZhbHVlKVxuICAgICAqL1xuICAgIGRlY2ltYWxMb25Ub0RNUyA6IGZ1bmN0aW9uIChsb2NhdGlvbiwgb2JqKSB7XG4gICAgICAgIHZhciBoZW1pc3BoZXJlID0gKGxvY2F0aW9uIDwgMCkgPyB0aGlzLldFU1QgOiB0aGlzLkVBU1Q7IC8vIHdlc3QgaWYgbmVnYXRpdmVcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjaW1hbFRvRE1TKGxvY2F0aW9uLCBoZW1pc3BoZXJlLCBvYmopO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyAtZGVncmVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW51dGVzIC1taW51dGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgLXNlY29uZHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGVtaXNwaGVyZSAtaGVtaXNwaGVyZVxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn0gZGVjaW1hbFxuICAgICAqL1xuICAgIERNU1RvRGVjaW1hbCA6IGZ1bmN0aW9uIChkZWdyZWVzLCBtaW51dGVzLCBzZWNvbmRzLCBoZW1pc3BoZXJlKSB7XG4gICAgICAgIHZhciBkZFZhbCA9IGRlZ3JlZXMgKyBtaW51dGVzIC8gNjAgKyBzZWNvbmRzIC8gMzYwMDtcbiAgICAgICAgZGRWYWwgPSAoaGVtaXNwaGVyZSA9PT0gdGhpcy5TT1VUSCB8fCBoZW1pc3BoZXJlID09PSB0aGlzLldFU1QpID8gZGRWYWwgKiAtMSA6IGRkVmFsO1xuXG4gICAgICAgIHZhciBkZWNpbWFsID0gdGhpcy5yb3VuZFRvRGVjaW1hbChkZFZhbCwgdGhpcy5kaWdpdERlY2ltYWwpO1xuICAgICAgICByZXR1cm4gZGVjaW1hbDtcbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBvc2l0aW9uRm9ybWF0ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Leaflet/Controls/Utils/PositionFormater.js\n");

/***/ }),

/***/ "leaflet":
/*!********************!*\
  !*** external "L" ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = L;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwgXCJMXCI/ZmEyYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJsZWFmbGV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBMOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///leaflet\n");

/***/ }),

/***/ "node-fetch":
/*!***********************************************************************************!*\
  !*** external {"commonjs2":"node-fetch","commonjs":"node-fetch","amd":"require"} ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = undefined;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJub2RlLWZldGNoXCIsXCJjb21tb25qc1wiOlwibm9kZS1mZXRjaFwiLFwiYW1kXCI6XCJyZXF1aXJlXCJ9P2FiYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoibm9kZS1mZXRjaC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///node-fetch\n");

/***/ }),

/***/ "xmldom":
/*!***************************************************************************!*\
  !*** external {"commonjs2":"xmldom","commonjs":"xmldom","amd":"require"} ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = undefined;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJ4bWxkb21cIixcImNvbW1vbmpzXCI6XCJ4bWxkb21cIixcImFtZFwiOlwicmVxdWlyZVwifT9hNmJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InhtbGRvbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///xmldom\n");

/***/ })

/******/ })["default"];